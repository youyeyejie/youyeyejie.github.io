<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>半城烟火半城仙</title>
      <link href="/_posts/%E5%8D%8A%E5%9F%8E%E7%83%9F%E7%81%AB%E5%8D%8A%E5%9F%8E%E4%BB%99/"/>
      <url>/_posts/%E5%8D%8A%E5%9F%8E%E7%83%9F%E7%81%AB%E5%8D%8A%E5%9F%8E%E4%BB%99/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_01.webp&quot;);" viewBox="0 0 1000 1949"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_02.webp&quot;);" viewBox="0 0 1000 1950"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_03.webp&quot;);" viewBox="0 0 1000 1949"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_04.webp&quot;);" viewBox="0 0 1000 1950"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_05.webp&quot;);" viewBox="0 0 1000 1949"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_06.webp&quot;);" viewBox="0 0 1000 1950"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_07.webp&quot;);" viewBox="0 0 1000 1949"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_08.webp&quot;);" viewBox="0 0 1000 1950"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_09.webp&quot;);" viewBox="0 0 1000 1949"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_10.webp&quot;);" viewBox="0 0 1000 1949"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_11.webp&quot;);" viewBox="0 0 1000 1950"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_12.webp&quot;);" viewBox="0 0 1000 1949"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_13.webp&quot;);" viewBox="0 0 1000 1950"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_14.webp&quot;);" viewBox="0 0 1000 1949"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_15.webp&quot;);" viewBox="0 0 1000 1950"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./半城烟火半城仙_16.webp&quot;);" viewBox="0 0 1000 1949"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fluid首页侧边栏网站统计</title>
      <link href="/_posts/Fluid%E9%A6%96%E9%A1%B5%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%BD%91%E7%AB%99%E7%BB%9F%E8%AE%A1/"/>
      <url>/_posts/Fluid%E9%A6%96%E9%A1%B5%E4%BE%A7%E8%BE%B9%E6%A0%8F%E7%BD%91%E7%AB%99%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本期美化同样贯彻了前几期美化的原则：<strong>无侵入式美化</strong>，即不修改主题的源代码，只通过修改配置文件、自定义样式以及Hexo注入器来实现美化。前几期的美化可以点击下方的链接卡片查看。</p><p><a href="/tags/Fluid/" name="/img/avatar/avatar.webp" class="LinkCard">Fluid主题美化</a></p><p>在浏览其他人的博客时，我发现许多主题在首页都会有一个侧边栏，展示一些网站的统计数据，比如文章总数、全站字数、总访问量、总访客数、建站时长和上次更新等信息，而Fluid 主题却不具备这样的功能。因此，在本期中，我们将在 Fluid主题的首页实现一个侧边栏，在其中展示网站的统计数据。</p><h1 id="实现">实现</h1><h2 id="javascript-脚本">JavaScript 脚本</h2><p>首先，我们需要在博客的 <code>source/js</code> 目录下创建一个名为<code>Sidebar.js</code> 的 JavaScript 文件，代码如下：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">lastUpdate</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">fetch</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'/sitemap.xml'</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">response</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">response</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">text</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">str</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">DOMParser</span><span style="color: #ABB2BF">()).</span><span style="color: #61AFEF">parseFromString</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">str</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"text/xml"</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #ABB2BF">    .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">lastmodDates</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Array</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">from</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelectorAll</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'url &gt; lastmod'</span><span style="color: #ABB2BF">)).</span><span style="color: #61AFEF">map</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Date</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">mostRecentDate</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Date</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">max</span><span style="color: #ABB2BF">(...</span><span style="color: #E06C75">lastmodDates</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">now</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Date</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">diffTime</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">abs</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">now</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">mostRecentDate</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">diffDays</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">floor</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">diffTime</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">1000</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">24</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">diffDays</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'sidebar-site-update'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`今天`</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'sidebar-site-update'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`</span><span style="color: #C678DD">${</span><span style="color: #E06C75">diffDays</span><span style="color: #C678DD">}</span><span style="color: #98C379">天前`</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    })</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">updateSidebar</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'sidebar-word-count'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'g-total-word-id'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'sidebar-post-count'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'g-total-posts-id'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'sidebar-site-age'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'time-day'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'天'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'sidebar-site-pv'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'vercount_value_site_pv'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'sidebar-site-uv'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'vercount_value_site_uv'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">lastUpdate</span><span style="color: #ABB2BF">(); </span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">createSidebar</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">main</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'main'</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sideCol</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createElement</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'div'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">sideCol</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">className</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"side-col d-none d-lg-block col-lg-2"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">sideCol</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">paddingTop</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"60px"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">sideCol</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">float</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"right"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">sideCol</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">position</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"sticky"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">sideCol</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">top</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"2rem"</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sideBar</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`</span></span><span class="line"><span style="color: #98C379">        &lt;aside class="sidebar" id="site-stats"&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;div class="sidebar-element"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span&gt;&lt;i class="fas fa-file-alt"&gt;&lt;/i&gt; &amp;nbsp;文章总数&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span id="sidebar-post-count"&gt;&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;div class="sidebar-element"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span&gt;&lt;i class="fas fa-chart-bar" style="font-size: 0.72rem;"&gt;&lt;/i&gt; &amp;nbsp;全站字数&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span id="sidebar-word-count"&gt;&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;div class="sidebar-element"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span&gt;&lt;i class="fas fa-eye" style="font-size: 0.72rem;"&gt;&lt;/i&gt; &amp;nbsp;总访问量&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span id="sidebar-site-pv"&gt;&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;div class="sidebar-element"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span&gt;&lt;i class="fas fa-user"&gt;&lt;/i&gt; &amp;nbsp;总访客数&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span id="sidebar-site-uv"&gt;&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;div class="sidebar-element"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span&gt;&lt;i class="fas fa-calendar-alt"&gt;&lt;/i&gt; &amp;nbsp;建站时长&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span id="sidebar-site-age"&gt;&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;div class="sidebar-element"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span&gt;&lt;i class="fa-solid fa-pen-nib"&gt;&lt;/i&gt; &amp;nbsp;上次更新&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span id="sidebar-site-update"&gt;&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;/aside&gt;</span></span><span class="line"><span style="color: #98C379">    `</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">sideCol</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">sideBar</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">main</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">insertBefore</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">sideCol</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">main</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">firstChild</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">updateSidebar</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">judgeSidebarHidden</span><span style="color: #ABB2BF">();</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sidebar_pv</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'sidebar-site-pv'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">sidebar_pv</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'1314'</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">vercount_pv</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'vercount_value_site_pv'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">intervalId</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">setInterval</span><span style="color: #ABB2BF">(() </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">vercount_pv</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'vercount_value_site_pv'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">vercount_pv</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'1314'</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #61AFEF">updateSidebar</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #61AFEF">clearInterval</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">intervalId</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }, </span><span style="color: #D19A66">100</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">judgeSidebarHidden</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">boardRect</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'board'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">getBoundingClientRect</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sideColRect</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'.side-col.d-none.d-lg-block.col-lg-2'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">getBoundingClientRect</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sideBar</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'site-stats'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// console.log(boardRect.right, sideColRect.left);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">boardRect</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sideColRect</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">sideBar</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">display</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'none'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">sideBar</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">display</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'block'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'meta[property="og:url"][content="https://youyeyejie.github.io/index.html"]'</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'meta[property="og:url"][content^="https://youyeyejie.github.io/page/"]'</span><span style="color: #ABB2BF">)) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">addEventListener</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'DOMContentLoaded'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">createSidebar</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">addEventListener</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'resize'</span><span style="color: #ABB2BF">, () </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">judgeSidebarHidden</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    });</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p>其中：</p><ul><li><code>lastUpdate</code> 函数用于获取博客上一次更新的时间，这依靠的是sitemap中记录的博客上次修改时间，因此需要我们每次更新博客时都会更新网站地图，可以使用<code>hexo-generator-sitemap</code> 插件来实现。</li><li><code>updateSidebar</code>函数用于更新侧边栏中的网站统计数据，为此我还修改了在<a href="/_posts/Fluid页脚美化/">Fluid页脚美化</a>中网站运行时间的相关代码。</li><li><code>createSidebar</code>函数用于定位以及创建侧边栏，由于统计数据中的访问量一项的更新可能存在延迟，因此我在函数中还设置了检查逻辑，循环检查直到访问量不等于默认的1314 时，更新侧边栏数据。</li><li><code>judgeSidebarHidden</code>函数用于判断侧边栏是否需要隐藏，当侧边栏与内容区重叠时，隐藏侧边栏；当侧边栏与内容区不重叠时，显示侧边栏。</li><li>最后通过检查页面的元数据，判断该页面是否是首页，从而决定是否插入侧边栏</li></ul><h2 id="css-样式">CSS 样式</h2><p>通过上面的脚本，我们已经实现了一个简易的侧边栏，接下来只需要稍微美化一下。</p><p>只需要在 <code>source/css</code> 目录下创建一个名为<code>Sidebar.css</code> 的 CSS 文件，代码如下：</p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">:root</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">--sitestat-bg-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#ffffffa4</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #C678DD">[</span><span style="color: #D19A66">data-user-color-scheme</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"dark"</span><span style="color: #C678DD">]</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">--sitestat-bg-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#242a38a4</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #61AFEF">#site-stats</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    margin: </span><span style="color: #D19A66">4</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">auto</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">auto</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    padding: </span><span style="color: #D19A66">15</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">20</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    top: </span><span style="color: #D19A66">4</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    background-color: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--sitestat-bg-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-backdrop-filter</span><span style="color: #ABB2BF">: </span><span style="color: #56B6C2">blur</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">15</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    backdrop-filter: </span><span style="color: #56B6C2">blur</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">15</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">block</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    width: </span><span style="color: #D19A66">240</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #D19A66">.sidebar-element</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">flex</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    justify-content: </span><span style="color: #D19A66">space-between</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    margin: </span><span style="color: #D19A66">15</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">15</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    font-size: </span><span style="color: #D19A66">0.95</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="在配置文件中引入">在配置文件中引入</h2><p>最后，我们需要在博客的 <code>_config.fluid.yml</code>配置文件中引入上面创建的 JavaScript 和 CSS 文件。可以在<code>head</code> 部分添加以下内容：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_js</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">js/Sidebar.js</span></span><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">css/Sidebar.css</span></span></code></pre></div></div></figure><h1 id="总结">总结</h1><p>通过以上步骤，我们成功地在 Fluid主题的首页实现了一个侧边栏，展示了网站的统计数据。这个侧边栏不仅美观，而且实用，可以让访客更好地了解网站的内容和活跃度。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo Blog Building </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Fluid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo使用Vercount统计访问数据</title>
      <link href="/_posts/Hexo%E4%BD%BF%E7%94%A8Vercount%E7%BB%9F%E8%AE%A1%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE/"/>
      <url>/_posts/Hexo%E4%BD%BF%E7%94%A8Vercount%E7%BB%9F%E8%AE%A1%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>在我使用的 fluid 主题中，支持 Busuanzi、Leancloud 和 Umami三种访问统计方式的配置，其中后两者需要额外的配置和部署，比较麻烦，因此我起初选用了Busuanzi 用以统计访问数据。然而，Busuanzi在访问量较大时会出现数据不准确的情况，加之前些天服务不稳定，于是我便决定更换为Vercount 进行访问统计。</p><p><a href="https://vercount.one" name="./image.webp" class="LinkCard">Vercount官网</a></p><p>Vercount 初始化自动同步所有不蒜子的数据，兼容不蒜子的 span标签，理论上可以无痛切换；且使用 POST请求进行统计，页面浏览量每访问一次加一，独立访客量通过用户的 UserAgent和 IP 地址判断，因此数据更加准确。而在我更换到 Vercount 后，Vercount又新增了自定义访客数据的功能，因此我决定写一篇文章来记录一下切换到Vercount 的过程以及如何使用它来统计访问数据。</p><h1 id="配置">配置</h1><h2 id="替换脚本">替换脚本</h2><p>如果只是希望简单的统计数据，那么只需要用 Vercount 的脚本替换掉Busuanzi 的脚本即可。如果你没有对 fluid主题进行过修改，那么只需要在主题的 <code>_config.fluid.yml</code>文件底部找到 Busuanzi 相关的配置项并进行替换。</p><figure class="shiki diff"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">- busuanzi: https://busuanzi.ibruce.info/busuanzi/2.3/</span></span><span class="line"><span style="color: #98C379">+ busuanzi: https://events.vercount.one/js?i=</span></span></code></pre></div></div></figure><p>如果你像我一样自定义了页脚内容，那么只需要将页脚注入中 Busuanzi的相关代码替换为 Vercount 的代码即可。</p><figure class="shiki diff"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">- &lt;script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;</span></span><span class="line"><span style="color: #98C379">+ &lt;script defer src="https://events.vercount.one/js"&gt;&lt;/script&gt;</span></span></code></pre></div></div></figure><p><a href="/_posts/fluid页脚美化" name="/img/avatar/avatar.webp" class="LinkCard">fluid页脚美化</a></p><p>由于 Vercount 兼容 <code>vercount_value_</code> 和<code>busuanzi_value_</code> 的 span 标签，因此无需修改 HTML模板中的相关标签。</p><h2 id="自定义访客数据">自定义访客数据</h2><p>如果你希望更进一步，自定义访客数据，或者和我一样由于在 Busuanzi服务瘫痪时切换到Vercount，未能成功同步原有的数据，那么你可以参考下面的步骤来进行配置。</p><p>首先，你需要在 <a href="https://www.vercount.one/dashboard">Vercount仪表盘</a>中关联你的站点。如果你和我一样，使用 Github Pages站点托管服务，那么可以选择第二种认证方式——“FileUpload”，在站点根目录下创建一个验证文件。为了避免每次部署都需要手动上传验证文件，你可以在<code>scripts/</code> 目录下创建一个脚本，自动上传验证文件。</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">fs</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">require</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'fs'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">path</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">require</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'path'</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">content</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'&lt;your-vercount-verify-content&gt;'</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">// 替换为你的 Vercount 验证码</span></span><span class="line"><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">filePath1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">path</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">join</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">__dirname</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'../.deploy_git/.well-known/&lt;your-vercount-verify-filename&gt;'</span><span style="color: #ABB2BF">); </span><span style="color: #7F848E; font-style: italic">// 替换为你的 Vercount 验证文件名</span></span><span class="line"><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">filePath2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">path</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">join</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">__dirname</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'../.deploy_git/.nojekyll'</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #E5C07B">fs</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">mkdirSync</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">path</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">dirname</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">filePath1</span><span style="color: #ABB2BF">), { </span><span style="color: #E06C75">recursive</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF"> });</span></span><span class="line"><span style="color: #E5C07B">fs</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">writeFileSync</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">filePath1</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">content</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #E5C07B">fs</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">writeFileSync</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">filePath2</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">''</span><span style="color: #ABB2BF">);</span></span></code></pre></div></div></figure><p>其中</p><ul><li>&lt;your-vercount-verify-content&gt; 形如<code>vercount-domain-verify=&lt;your-domain&gt;,&lt;verify-code&gt;</code></li><li>&lt;your-vercount-verify-filename&gt; 形如<code>vercount-verify-&lt;something else&gt;.txt</code>。</li></ul><p>你可以在 Vercount 仪表盘中找到相应的验证信息。</p><p>由于 Github Pages 默认启用了 Jekyll，屏蔽了以 <code>.</code>开头的目录和文件，因此需要在站点根目录下创建一个 <code>.nojekyll</code>文件来禁用 Jekyll 的处理，脚本中也已经实现。</p><h2 id="vercount-与-busuanzi-的数据对比">Vercount 与 Busuanzi的数据对比</h2><table style="text-align: center; width: 100%;"><thead><tr><th scope="col" style="width: 16%;">&nbsp;<i class="fa-solid fa-cloud"></i> Service</th><th scope="col" style="width: 16%;">&nbsp;<i class="fa-solid fa-eye"></i> Site PV &nbsp;</th><th scope="col" style="width: 16%;">&nbsp;<i class="fas fa-user-friends"></i> Site UV &nbsp;</th><th scope="col" style="width: 16%;">&nbsp;<i class="fa-solid fa-file-lines"></i> Page PV &nbsp;</th><th scope="col" style="width: 36%;"><i class="fa-solid fa-clock"></i> Update Time</th></tr></thead><tbody><tr><td><strong><a href="https://vercount.one" target="_blank">Vercount</a></strong></td><td><em><span id="show_vercount_value_site_pv">loading</span></em></td><td><em><span id="show_vercount_value_site_uv">loading</span></em></td><td><em><span id="show_vercount_value_page_pv">loading</span></em></td><td><em><span id="show_vercount_time">loading</span></em></td></tr><tr><td><strong><a href="https://busuanzi.ibruce.info" target="_blank">Busuanzi</a></strong></td><td><em><span id="show_busuanzi_value_site_pv">loading</span></em></td><td><em><span id="show_busuanzi_value_site_uv">loading</span></em></td><td><em><span id="show_busuanzi_value_page_pv">loading</span></em></td><td><em><span id="show_busuanzi_time">loading</span></em></td></tr></tbody></table><script defer="" src="/js/BusuanziAndVercount.js"></script>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ed0dd10" role="button" aria-expanded="false" aria-controls="collapse-6ed0dd10">        <div class="fold-arrow">▶</div>数据问题已修复，见评论区      </div>      <div class="fold-collapse collapse" id="collapse-6ed0dd10">        <div class="fold-content">          <p>前文提到，Vercount 每次调用都会自动同步 Busuanzi 的数据，但只会返回Vercount 自身的数据，因此要想获取到 Busuanzi 的数据，还需要自行调用Busuanzi 的 API。因此，每次访问一个页面，Busuanzi的数据会自增二，从而造成一定误差。</p>        </div>      </div>    </div><h1 id="总结">总结</h1><p>Vercount 提供了一个简单易用的访问统计服务，兼容 Busuanzi的数据格式，支持自定义访客数据，并且使用 POST请求进行统计，数据更加准确。通过简单的配置和脚本，你可以轻松地将 Hexo博客的访问统计从 Busuanzi 切换到 Vercount。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo Blog Building </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Fluid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fluid随机背景</title>
      <link href="/_posts/Fluid%E9%9A%8F%E6%9C%BA%E8%83%8C%E6%99%AF/"/>
      <url>/_posts/Fluid%E9%9A%8F%E6%9C%BA%E8%83%8C%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本期美化同样贯彻了前几期美化的原则：<strong>无侵入式美化</strong>，即不修改主题的源代码，只通过修改配置文件、自定义样式以及Hexo注入器来实现美化。前几期的美化可以点击下方的链接卡片查看。</p><p><a href="/tags/Fluid/" name="/img/avatar/avatar.webp" class="LinkCard">Fluid主题美化</a></p><p>在本期中，我们将为Fluid主题的文章页添加一个随机背景功能，使每次访问文章时都能看到不同的背景图片。顺带一提，目前我使用的背景图都出自B站的UP主<a href="https://space.bilibili.com/33716779">Lyasmind</a> 哦！</p><h1 id="实现">实现</h1><p>首先，在博客的 <code>source/js</code> 目录下创建一个名为<code>RandomBanner.js</code> 的 JavaScript 文件，代码如下：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">imgs</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// paths to your banner images</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #98C379">"/img/banner/banner.webp"</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #98C379">"/img/banner/banner1.webp"</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">]</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">random_banner</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">imgs</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">floor</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">random</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">imgs</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">)];</span></span><span class="line"><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">banner</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'banner'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">banner</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">metaOgType</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'meta[property="og:type"]'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">log</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">" metaOgType.content: "</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">metaOgType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">metaOgType</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">content</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"not found"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">metaOgType</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">metaOgType</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">content</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"article"</span><span style="color: #ABB2BF">) { </span><span style="color: #7F848E; font-style: italic">//判断是否为文章页</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">background</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">banner</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">background</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">background</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">includes</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"/img/banner/random.webp"</span><span style="color: #ABB2BF">)) { </span><span style="color: #7F848E; font-style: italic">// 特殊判断规则</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">banner</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">background</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`url(</span><span style="color: #C678DD">${</span><span style="color: #E06C75">random_banner</span><span style="color: #C678DD">}</span><span style="color: #98C379">) center center / cover no-repeat`</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><ul><li>在上面的代码中，我们首先定义了一个包含所有背景图片路径的数组<code>imgs</code>。当然如果你要随机的图片较多，也可以通过文件夹的方式来管理，只需要对后续的代码进行相应的调整即可。</li><li>接着，我们通过检查 <code>meta</code> 标签中的 <code>og:type</code>属性来判断当前页面是否为文章页。这是由于博客会通过<code>&lt;head&gt;</code> 中的 <code>og:type</code>来区分页面类型，例如文章页的词条为： <figure class="shiki html"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">meta</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">property</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"og:type"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">content</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"article"</span><span style="color: #ABB2BF">&gt;</span></span></code></pre></div></div></figure> 而其他页面则是<figure class="shiki html"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">meta</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">property</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"og:type"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">content</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"website"</span><span style="color: #ABB2BF">&gt;</span></span></code></pre></div></div></figure> 你也可以通过浏览器的开发者工具来查看当前页面的<code>meta</code>标签。更进一步，你也可以通过其他方式制定相应规则，判断某个页面是否要进行随机背景的更换，如仅限首页或特定标签页等等。</li><li>然后，我们通过检查 <code>banner</code>元素的背景样式来判断是否需要更换背景图片。在我的<code>_config.fluid.yml</code> 设置中，文章页的默认 banner 路径是<code>/img/banner/random.webp</code>，而在 front-matter指定的背景图路径是文章对应文件夹，因此如果当前背景包含<code>/img/banner/random.webp</code>这一字符串，则说明其使用了默认路径，可以将其替换为随机选择的背景图片。</li></ul><p>在实现了上述代码后，我们需要确保它在页面加载时被执行。为此，我们需要在博客的<code>_config.fluid.yml</code> 文件中添加以下配置：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_js</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/RandomBanner.js</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 文章页随机 Banner</span></span></code></pre></div></div></figure><h1 id="总结">总结</h1><p>通过以上步骤，我们成功为 Fluid主题的文章页实现了随机背景的功能。每次访问文章时，都可以看到不同的Banner，从而提升了页面的视觉效果和用户体验。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo Blog Building </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Fluid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fluid自定义右键菜单</title>
      <link href="/_posts/Fluid%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
      <url>/_posts/Fluid%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本期美化同样贯彻了前两期美化的原则：<strong>无侵入式美化</strong>，即不修改主题的源代码，只通过修改配置文件、自定义样式以及Hexo注入器来实现美化。前两期的美化可以点击下方的链接卡片查看。</p><p><a href="/_posts/Fluid主题美化/" name="/img/avatar/avatar.webp" class="LinkCard">Fluid主题美化</a><a href="/_posts/Fluid页脚美化/" name="/img/avatar/avatar.webp" class="LinkCard">Fluid页脚美化</a></p><p>在本期中，我们将实现一个自定义的右键菜单，我参考了苍岚和loyeh两位博主的实现方式，在他们的基础上进行了改进和扩展，最终实现了一个更加美观和实用的右键菜单。如果不关心实现，可以直接跳转至<a href="#总结">总结</a> 获取实现代码和使用方法。</p><p><a href="https://www.zywvvd.com/notes/hexo/theme/fluid/fluid-custom-rightmenu/fluid-custom-rightmenu/" name="https://www.zywvvd.com/image/avatar.png" class="LinkCard">Fluid-39-自定义右键菜单</a><a href="https://lo-y-eh.github.io/posts/92dc.html" name="https://lo-y-eh.github.io/medias/avatar.jpg" class="LinkCard">右键菜单</a></p><h1 id="功能设计">功能设计</h1><p>在设计这个右键菜单时，我主要考虑了我个人的使用习惯，兼顾访客可能存在的需求。最终，我设计了以下功能：</p><ol type="1"><li>在覆盖浏览器原本的右键菜单时，必须留有使用浏览器原生右键菜单的入口。</li><li>提供常用的功能，如前进、后退、刷新等</li><li>提供快速返回顶部和快速跳转到页脚的功能</li><li>应对各种情况做出不同的响应，如：<ul><li>选中文本时，提供复制文本、必应搜索等功能</li><li>在图片上，提供复制图片链接、下载图片等功能</li><li>在链接上，提供打开链接等功能</li></ul></li><li>常驻功能中，提供复制当前页面链接的功能和切换主题昼夜模式的功能</li><li>提供站内搜索、快速访问博客分类和文章标签的入口</li><li>为访客提供随机访问文章的功能</li></ol><p>综上，我们只需要依次设计实现这些功能即可。</p><h1 id="实现步骤">实现步骤</h1><ol type="1"><li>创建右键菜单的 HTML 结构</li><li>使用 Hexo 注入器将 HTML 结构注入到页面中</li><li>使用 CSS 美化右键菜单</li><li>使用 JavaScript 实现右键菜单的显示与隐藏</li><li>使用 JavaScript 实现右键菜单的各项功能</li></ol><h2 id="创建右键菜单的-html-结构">创建右键菜单的 HTML 结构</h2><p>在 Hexo 的 <code>source/html</code> 目录下创建一个<code>RightMenu.html</code> 文件，内容如下：</p><figure class="shiki html"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"tooltip-rightmenu"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"tooltip-rightmenu"</span><span style="color: #ABB2BF">&gt;如需原始右键菜单请按下 &lt;</span><span style="color: #E06C75">strong</span><span style="color: #ABB2BF">&gt;Ctrl+右键&lt;/</span><span style="color: #E06C75">strong</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"tooltip-rightmenu-return"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"tooltip-rightmenu"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"rightmenu-wrapper"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">  &lt;</span><span style="color: #E06C75">ul</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"list-v rightmenu"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"rightmenu-content"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"navigation menuNavigation-Content"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"nav icon-only fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">aria-label</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"back"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #E5C07B">history</span><span style="color: #98C379">.</span><span style="color: #61AFEF">back</span><span style="color: #98C379">()"</span><span style="color: #ABB2BF">&gt;&lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-chevron-left"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"nav icon-only fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">aria-label</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"forward"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #E5C07B">history</span><span style="color: #98C379">.</span><span style="color: #61AFEF">forward</span><span style="color: #98C379">()"</span><span style="color: #ABB2BF">&gt;&lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-chevron-right"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"nav icon-only fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">aria-label</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"reload"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #E5C07B">window</span><span style="color: #98C379">.</span><span style="color: #E5C07B">location</span><span style="color: #98C379">.</span><span style="color: #61AFEF">reload</span><span style="color: #98C379">()"</span><span style="color: #ABB2BF">&gt;&lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-rotate-right"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"nav icon-only fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">aria-label</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"top"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #61AFEF">scrollToTopSmooth</span><span style="color: #98C379">();"</span><span style="color: #ABB2BF">&gt;&lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-chevron-up"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"nav icon-only fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">aria-label</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"bottom"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #61AFEF">scrollToBottomSmooth</span><span style="color: #98C379">();"</span><span style="color: #ABB2BF">&gt;&lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-chevron-down"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">hr</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"top-line"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"copy-selected-text"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_self"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #61AFEF">copySelectedText</span><span style="color: #98C379">();"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-copy"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">复制选中</span></span><span class="line"><span style="color: #ABB2BF">                &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"search-selected-text-BING"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_blank"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #61AFEF">searchSelectedTextBing</span><span style="color: #98C379">();"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-magnifying-glass-arrow-right"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">必应搜索</span></span><span class="line"><span style="color: #ABB2BF">                &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"go-to-link"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_blank"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-arrow-up-right-from-square"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">转到链接</span></span><span class="line"><span style="color: #ABB2BF">                &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"download-image"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_self"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #61AFEF">downloadImage</span><span style="color: #98C379">();"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-image"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">下载图片</span></span><span class="line"><span style="color: #ABB2BF">                &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"copy-image-link"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_self"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #61AFEF">copyImageLink</span><span style="color: #98C379">();"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-link"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    复制图片链接</span></span><span class="line"><span style="color: #ABB2BF">                &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">hr</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_self"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #61AFEF">RandomGo</span><span style="color: #98C379">()"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-paper-plane"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">随便看看</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_self"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">href</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"javascript:;"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">data-toggle</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"modal"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">data-target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"#modalSearch"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">aria-label</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"Search"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-magnifying-glass"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">站内搜索</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_self"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">href</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"/categories/"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"iconfont icon-category-fill"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">博客分类</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_self"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">href</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"/tags/"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-tags"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">文章标签</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        </span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">hr</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_self"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #61AFEF">copyLink</span><span style="color: #98C379">();"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-copy"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">复制链接</span></span><span class="line"><span style="color: #ABB2BF">                &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"menuLoad-Content"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">style</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"display: block;"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"vlts-menu fix-cursor-default"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_self"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">onclick</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"</span><span style="color: #E5C07B">document</span><span style="color: #98C379">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #98C379">('color-toggle-btn').</span><span style="color: #61AFEF">click</span><span style="color: #98C379">();"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fa-solid fa-circle-half-stroke"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">切换昼夜</span></span><span class="line"><span style="color: #ABB2BF">            &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">ul</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">src</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"/js/RightMenu.js"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">type</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"text/javascript"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">link</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">href</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"/css/RightMenu.css"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">type</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"text/css"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">rel</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"stylesheet"</span><span style="color: #ABB2BF">/&gt;</span></span></code></pre></div></div></figure><p>其中 <code>tooltip-rightmenu</code> 和<code>tooltip-rightmenu-return</code>是用于提示用户如何使用右键菜单的元素，<code>rightmenu-wrapper</code>是右键菜单的容器，<code>rightmenu-content</code>是右键菜单的内容列表，也是我们需要实现的功能项。</p><p>在代码的最后，我们引入了 <code>RightMenu.js</code> 和<code>RightMenu.css</code>文件，这两个文件将分别用于实现右键菜单的逻辑和样式，因此我们不必在<code>_config.fluid.yml</code> 中再进行额外的配置。</p><h2 id="使用-hexo-注入器将-html-结构注入到页面中">使用 Hexo 注入器将HTML 结构注入到页面中</h2><p>在 Hexo 的 <code>scripts/injector.js</code> 文件中添加以下代码：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E5C07B">hexo</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">extend</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">filter</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">register</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'theme_inject'</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">injects</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic">// 右键菜单</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">injects</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">bodyBegin</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">file</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'default'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"source/html/RightMenu.html"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">});</span></span></code></pre></div></div></figure><p>这段代码将 <code>RightMenu.html</code> 文件注入到页面的<code>&lt;body&gt;</code> 标签开始的位置。这样，当页面加载时，右键菜单的HTML 结构就会被插入到页面中。</p><h2 id="使用-css-美化右键菜单">使用 CSS 美化右键菜单</h2><p>接下来我们将实现右键菜单的样式。在 <code>source/css</code>目录下创建一个 <code>RightMenu.css</code> 文件，内容如下：</p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">div</span><span style="color: #61AFEF">#rightmenu-wrapper</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    display: -webkit-box </span><span style="color: #7F848E; font-style: italic">/* OLD - iOS 6-, Safari 3.1-6 */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: -moz-box </span><span style="color: #7F848E; font-style: italic">/* OLD - Firefox 19- (buggy but mostly works) */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    position: </span><span style="color: #D19A66">fixed</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    z-index: </span><span style="color: #D19A66">2147483648</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    user-select: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-user-select</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-moz-user-select</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-ms-user-select</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v.rightmenu</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    display: -webkit-box </span><span style="color: #7F848E; font-style: italic">/* OLD - iOS 6-, Safari 3.1-6 */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: -moz-box </span><span style="color: #7F848E; font-style: italic">/* OLD - Firefox 19- (buggy but mostly works) */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">block</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    background-color: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--body-bg-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    opacity: </span><span style="color: #D19A66">0.9</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    max-width: </span><span style="color: #D19A66">240</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    overflow: </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    z-index: </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: -webkit-box </span><span style="color: #7F848E; font-style: italic">/* OLD - iOS 6-, Safari 3.1-6 */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: -moz-box </span><span style="color: #7F848E; font-style: italic">/* OLD - Firefox 19- (buggy but mostly works) */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    position: </span><span style="color: #D19A66">absolute</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    box-shadow: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">12</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0.8</span><span style="color: #ABB2BF">), </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0.08</span><span style="color: #ABB2BF">), </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">16</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0.08</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-box-shadow</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0.08</span><span style="color: #ABB2BF">), </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0.08</span><span style="color: #ABB2BF">), </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">16</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span><span style="color: #D19A66">0.08</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    margin-top: </span><span style="color: #D19A66">-6</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-border-radius</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    padding: </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v.rightmenu</span><span style="color: #C678DD"> </span><span style="color: #E06C75">li</span><span style="color: #D19A66">.navigation</span><span style="color: #ABB2BF">,</span><span style="color: #C678DD"> </span><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v.rightmenu</span><span style="color: #C678DD"> </span><span style="color: #E06C75">li</span><span style="color: #D19A66">.music</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    display: -webkit-box </span><span style="color: #7F848E; font-style: italic">/* OLD - iOS 6-, Safari 3.1-6 */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: -moz-box </span><span style="color: #7F848E; font-style: italic">/* OLD - Firefox 19- (buggy but mostly works) */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: -ms-flexbox </span><span style="color: #7F848E; font-style: italic">/* TWEENER - IE 10 */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: -webkit-flex </span><span style="color: #7F848E; font-style: italic">/* NEW - Chrome */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">flex</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic">/* NEW, Spec - Opera 12.1, Firefox 20+ */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">flex</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    margin: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">12</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">12</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    justify-content: </span><span style="color: #D19A66">space-between</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-justify-content</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">space-between</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-khtml-justify-content</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">space-between</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-moz-justify-content</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">space-between</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-o-justify-content</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">space-between</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-ms-justify-content</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">space-between</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v</span><span style="color: #C678DD"> </span><span style="color: #ABB2BF">&gt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    white-space: </span><span style="color: #D19A66">nowrap</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    word-break: </span><span style="color: #D19A66">keep-all</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v</span><span style="color: #C678DD"> </span><span style="color: #E06C75">hr</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    margin-top: </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    margin-bottom: </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v.rightmenu</span><span style="color: #C678DD"> </span><span style="color: #E06C75">li</span><span style="color: #D19A66">.navigation</span><span style="color: #C678DD"> </span><span style="color: #E06C75">a</span><span style="color: #D19A66">.nav</span><span style="color: #C678DD"> </span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">,</span><span style="color: #C678DD"> </span><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v.rightmenu</span><span style="color: #C678DD"> </span><span style="color: #E06C75">li</span><span style="color: #D19A66">.music</span><span style="color: #C678DD"> </span><span style="color: #E06C75">a</span><span style="color: #D19A66">.nav</span><span style="color: #C678DD"> </span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    margin: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    width: </span><span style="color: #D19A66">16</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    line-height: </span><span style="color: #D19A66">32</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v</span><span style="color: #C678DD"> </span><span style="color: #ABB2BF">&gt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    white-space: </span><span style="color: #D19A66">nowrap</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    word-break: </span><span style="color: #D19A66">keep-all</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v.rightmenu</span><span style="color: #C678DD"> </span><span style="color: #E06C75">a</span><span style="color: #D19A66">.vlts-menu</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    text-overflow: </span><span style="color: #D19A66">ellipsis</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    overflow: </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    line-height: </span><span style="color: #D19A66">36</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    font-weight: </span><span style="color: #D19A66">normal</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    margin-left: </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.rightmenu-icon</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">margin: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">110</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v</span><span style="color: #C678DD"> </span><span style="color: #ABB2BF">&gt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    transition: </span><span style="color: #D19A66">all</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.28</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">ease</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-transition</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">all</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.28</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">ease</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-khtml-transition</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">all</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.28</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">ease</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-moz-transition</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">all</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.28</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">ease</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-o-transition</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">all</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.28</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">ease</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-ms-transition</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">all</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.28</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">ease</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: -webkit-box </span><span style="color: #7F848E; font-style: italic">/* OLD - iOS 6-, Safari 3.1-6 */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: -moz-box </span><span style="color: #7F848E; font-style: italic">/* OLD - Firefox 19- (buggy but mostly works) */</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">block</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--text-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    font-size: </span><span style="color: #D19A66">1</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    font-weight: </span><span style="color: #D19A66">bold</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    line-height: </span><span style="color: #D19A66">36</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    padding: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    text-overflow: </span><span style="color: #D19A66">ellipsis</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-border-radius</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v</span><span style="color: #C678DD"> </span><span style="color: #ABB2BF">&gt;</span><span style="color: #E06C75">li</span><span style="color: #ABB2BF">&gt;</span><span style="color: #E06C75">a</span><span style="color: #C678DD"> </span><span style="color: #56B6C2">:hover</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--link-hover-color</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">ul</span><span style="color: #D19A66">.list-v.rightmenu</span><span style="color: #C678DD"> </span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    cursor: </span><span style="color: #D19A66">default</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">/* 信息提示框 */</span></span><span class="line"><span style="color: #56B6C2">:root</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--tooltip-bg-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#181c27a4</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--tooltip-text-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#eeeeee</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #C678DD">[</span><span style="color: #D19A66">data-user-color-scheme</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"dark"</span><span style="color: #C678DD">]</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--tooltip-bg-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#eeeeeea4</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--tooltip-text-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#181c27</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.tooltip-rightmenu</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    position: </span><span style="color: #D19A66">fixed</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    top: </span><span style="color: #D19A66">13</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    left: </span><span style="color: #D19A66">50</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    transform: </span><span style="color: #56B6C2">translate</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">-50</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">-50</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">); </span><span style="color: #7F848E; font-style: italic">/* 居中 */</span></span><span class="line"><span style="color: #ABB2BF">    background: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--tooltip-bg-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--tooltip-text-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    padding: </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">25</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">5</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    opacity: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    z-index: </span><span style="color: #D19A66">99</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    transition: opacity </span><span style="color: #D19A66">1</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">ease-in-out</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.show-tooltip</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    opacity: </span><span style="color: #D19A66">0.8</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p>如果你想要更改右键菜单的样式，可以借助浏览器的开发者工具选择对应的元素，修改其CSS 属性。</p><h2 id="使用-javascript-实现右键菜单的显示与隐藏">使用 JavaScript实现右键菜单的显示与隐藏</h2><p>为了让我们自定义的右键菜单能够在用户右键点击时显示，我们需要使用JavaScript 来实现这一功能。在 <code>source/js</code> 目录下创建一个<code>RightMenu.js</code> 文件，内容如下：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">// 右键菜单</span></span><span class="line"><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">right_click_num</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">rect</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"rightmenu-content"</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">getBoundingClientRect</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">oncontextmenu</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">e</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #7F848E; font-style: italic">// 检查是否按下了Ctrl键</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">ctrlKey</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">preventDefault</span><span style="color: #ABB2BF">(); </span><span style="color: #7F848E; font-style: italic">//阻止浏览器自带的右键菜单显示</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">menu</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"rightmenu-wrapper"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #E5C07B">menu</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">display</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"block"</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">//将自定义的“右键菜单”显示出来</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientX</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">rect</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">width</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerWidth</span><span style="color: #ABB2BF">) { </span><span style="color: #7F848E; font-style: italic">// 如果超出屏幕右边</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientX</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">rect</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">width</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">menu</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"0px"</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">// 如果超出屏幕左边，则调整位置到左侧贴边</span></span><span class="line"><span style="color: #ABB2BF">        } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">menu</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientX</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">rect</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">width</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"px"</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">// 否则调整到鼠标位置的左侧</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">menu</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientX</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"px"</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">// 设置位置，跟随鼠标</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientY</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">rect</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerHeight</span><span style="color: #ABB2BF">) { </span><span style="color: #7F848E; font-style: italic">// 如果超出屏幕底部</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientY</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">rect</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">menu</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">top</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"0px"</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">// 如果超出屏幕顶部，则调整位置到顶部</span></span><span class="line"><span style="color: #ABB2BF">        } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">menu</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">top</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientY</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">rect</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"px"</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">// 否则调整到鼠标位置的上方</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">menu</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">top</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientY</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"px"</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">// 设置位置，跟随鼠标</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #E06C75">right_click_num</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">right_click_num</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">//右键点击次数加1</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">right_click_num</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">){</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'tooltip-rightmenu'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">add</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 3秒后隐藏提示框</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(() </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }, </span><span style="color: #D19A66">3000</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">onclick</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">e</span><span style="color: #ABB2BF">){ </span><span style="color: #7F848E; font-style: italic">//点击窗口，右键菜单隐藏</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">menu</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"rightmenu-wrapper"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #E5C07B">menu</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">display</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"none"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p>这样，我们就实现了一个基本的右键菜单显示与隐藏功能。当用户右键点击时，自定义的右键菜单会显示在鼠标位置，并且如果用户按下了<code>Ctrl</code> 键，则会显示浏览器原生的右键菜单。</p><h2 id="使用-javascript-实现右键菜单的各项功能">使用 JavaScript实现右键菜单的各项功能</h2><p>在上一步中，我们已经实现了右键菜单的显示与隐藏功能，但其中的部分选项仍旧是一个空壳。接下来，我们将为这些选项添加功能。同样是在<code>RightMenu.js</code> 文件中，我们将添加以下代码：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">// 监听鼠标右键按下事件</span></span><span class="line"><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">addEventListener</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'contextmenu'</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">event</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 检查是否有选中的文本</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">copySelectedTextItem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'copy-selected-text'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">searchSelectedTextItem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'search-selected-text-BING'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">selectedText</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getSelection</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">toString</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">trim</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">selectedText</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">copySelectedTextItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">searchSelectedTextItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">copySelectedTextItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">searchSelectedTextItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 检查是否有链接被点击</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">goToLinkItem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'go-to-link'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">link</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">event</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">target</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">closest</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'a[href]'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">link</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">goToLinkItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">goToLinkItem</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'a'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">setAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'href'</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">link</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">href</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">goToLinkItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">//检查是否有图片被点击</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">downloadImageItem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'download-image'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">copyImageItem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'copy-image-link'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">img</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">event</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">target</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">closest</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'img'</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">event</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">target</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">closest</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'svg'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">img</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">downloadImageItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">img</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">tagName</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">toLowerCase</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'img'</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">copyImageItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">downloadImageItem</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'a'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">setAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'onclick'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">`downloadImage('</span><span style="color: #C678DD">${</span><span style="color: #E5C07B">img</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">src</span><span style="color: #C678DD">}</span><span style="color: #98C379">')`</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">copyImageItem</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'a'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">setAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'onclick'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">`copyImageLink('</span><span style="color: #C678DD">${</span><span style="color: #E5C07B">img</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">src</span><span style="color: #C678DD">}</span><span style="color: #98C379">')`</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">img</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">tagName</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">toLowerCase</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'svg'</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">img</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">contains</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'custom-gallery-svg'</span><span style="color: #ABB2BF">)) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">backgroundImage</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">img</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">backgroundImage</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">urlMatch</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">backgroundImage</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">match</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">/url</span><span style="color: #56B6C2">\(</span><span style="color: #D19A66">["']?</span><span style="color: #E06C75">(.</span><span style="color: #D19A66">*?</span><span style="color: #E06C75">)</span><span style="color: #D19A66">["']?</span><span style="color: #56B6C2">\)</span><span style="color: #E06C75">/</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">urlMatch</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">urlMatch</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">imageUrl</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">urlMatch</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">downloadImageItem</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'a'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">setAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'onclick'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">`downloadImage('</span><span style="color: #C678DD">${</span><span style="color: #E06C75">imageUrl</span><span style="color: #C678DD">}</span><span style="color: #98C379">')`</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">copyImageItem</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'a'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">setAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'onclick'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">`copyImageLink('</span><span style="color: #C678DD">${</span><span style="color: #E06C75">imageUrl</span><span style="color: #C678DD">}</span><span style="color: #98C379">')`</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">downloadImageItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">copyImageItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 根据前三者判断第一栏是否有元素，需要分割线</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">topLineItem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'top-line'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">copySelectedTextItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!</span><span style="color: #E06C75">link</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!</span><span style="color: #E06C75">img</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">topLineItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">topLineItem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 更新尺寸相关参数</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">rect</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"rightmenu-content"</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">getBoundingClientRect</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">});</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">// 平滑滚动到顶部</span></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">scrollToTopSmooth</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">scrollTo</span><span style="color: #ABB2BF">({</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">top</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">behavior</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'smooth'</span></span><span class="line"><span style="color: #ABB2BF">    });</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">// 平滑滚动到底部</span></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">scrollToBottomSmooth</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">scrollTo</span><span style="color: #ABB2BF">({</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">top</span><span style="color: #ABB2BF">: </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">body</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">scrollHeight</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">behavior</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'smooth'</span></span><span class="line"><span style="color: #ABB2BF">    });</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">// 复制选中-复制选中文本功能</span></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">copySelectedText</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">selectedText</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getSelection</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">toString</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">selectedText</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">navigator</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">clipboard</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">writeText</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">selectedText</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'tooltip-rightmenu-return'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'选中文本已复制到剪贴板'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">add</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(() </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }, </span><span style="color: #D19A66">1500</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">// 必应搜索-在Bing上搜索选中文本功能</span></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">searchSelectedTextBing</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">selectedText</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getSelection</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">toString</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">trim</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">selectedText</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">bingSearchUrl</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`https://www.bing.com/search?q=</span><span style="color: #C678DD">${</span><span style="color: #61AFEF">encodeURIComponent</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">selectedText</span><span style="color: #ABB2BF">)</span><span style="color: #C678DD">}</span><span style="color: #98C379">`</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">open</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">bingSearchUrl</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'_blank'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">// 下载图片-下载选中图片功能</span></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">downloadImage</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">imgsrc</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E06C75">imgsrc</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">error</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'Image source is required'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">name</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">imgsrc</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">split</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'/'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">(); </span><span style="color: #7F848E; font-style: italic">// Extract the image name from the path</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">fetch</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">imgsrc</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">response</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">response</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">blob</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">        .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">blob</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">a</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createElement</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'a'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">url</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">URL</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createObjectURL</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">blob</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">a</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">href</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">url</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">a</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">download</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">name</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">body</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">appendChild</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">a</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">click</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">URL</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">revokeObjectURL</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">url</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">body</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">removeChild</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'tooltip-rightmenu-return'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'图片已下载'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">add</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(() </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            }, </span><span style="color: #D19A66">1500</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        })</span></span><span class="line"><span style="color: #ABB2BF">        .</span><span style="color: #61AFEF">catch</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">error</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">error</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'Error downloading image:'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">error</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">// 复制图片链接-复制选中图片链接功能</span></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">copyImageLink</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">imgsrc</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">imgsrc</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">navigator</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">clipboard</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">writeText</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">imgsrc</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'tooltip-rightmenu-return'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'链接已复制到剪贴板'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">add</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(() </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }, </span><span style="color: #D19A66">1500</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">// 随便看看-随机跳转到文章</span></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">RandomGo</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">JSON</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">parse</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">sessionStorage</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getItem</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'posts'</span><span style="color: #ABB2BF">)) </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> [];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">posts</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">fetch</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'/sitemap.xml'</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">response</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">response</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">text</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">        .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">str</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">DOMParser</span><span style="color: #ABB2BF">()).</span><span style="color: #61AFEF">parseFromString</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">str</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"text/xml"</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #ABB2BF">        .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">entries</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelectorAll</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'url &gt; loc'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Array</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">from</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">entries</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                .</span><span style="color: #61AFEF">map</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">entry</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">entry</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                .</span><span style="color: #61AFEF">filter</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">link</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">link</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">includes</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'/_posts/'</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #ABB2BF">                .</span><span style="color: #61AFEF">map</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">link</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">link</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">substring</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">link</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">indexOf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'/_posts/'</span><span style="color: #ABB2BF">)));</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">sessionStorage</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">setItem</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'posts'</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">JSON</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">stringify</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF">)); </span><span style="color: #7F848E; font-style: italic">// 保存到 sessionStorage</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">log</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'Posts updated:'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF">); </span><span style="color: #7F848E; font-style: italic">// 调试输出更新后的链接列表</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">randomIndex</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">floor</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">random</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">posts</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">randomLink</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF">[</span><span style="color: #E06C75">randomIndex</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">location</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">href</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">randomLink</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        })</span></span><span class="line"><span style="color: #ABB2BF">        .</span><span style="color: #61AFEF">catch</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">error</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">error</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'Error fetching sitemap:'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">error</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">randomIndex</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">floor</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">random</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">posts</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">randomLink</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF">[</span><span style="color: #E06C75">randomIndex</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">location</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">href</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">randomLink</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">// 复制链接-复制当前地址功能</span></span><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">copyLink</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">link</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">location</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">href</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">navigator</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">clipboard</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">writeText</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">link</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'tooltip-rightmenu-return'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'链接已复制到剪贴板'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">add</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 3秒后隐藏提示框</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(() </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tooltip</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">classList</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'show-tooltip'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }, </span><span style="color: #D19A66">1500</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p>这段代码实现了右键菜单的各项功能，包括复制选中文本、必应搜索、跳转到链接、下载图片、复制图片链接、随机跳转到文章以及复制当前页面链接。</p><h1 id="总结">总结</h1><p>通过以上步骤，我们成功实现了一个无侵入式的自定义右键菜单。这个右键菜单不仅美观，而且功能丰富，能够满足大部分用户的需求。以下是完整的使用方法：</p><ol type="1"><li>在 Hexo 的 <code>source/html</code> 目录下创建<code>RightMenu.html</code> 文件，并将<a href="#创建右键菜单的-html-结构">上述HTML结构</a>复制到该文件中。</li><li>在 Hexo 的 <code>scripts/injector.js</code> 文件中添加<a href="#使用-hexo-注入器将-html-结构注入到页面中">上述注入器代码</a>。</li><li>在 Hexo 的 <code>source/css</code> 目录下创建<code>RightMenu.css</code> 文件，并将<a href="#使用-css-美化右键菜单">上述CSS样式</a>复制到该文件中。</li><li>在 Hexo 的 <code>source/js</code> 目录下创建<code>RightMenu.js</code>文件，并将上述JavaScript代码复制到该文件中，<strong>注意</strong>需要包括<a href="#使用-javascript-实现右键菜单的显示与隐藏">右键菜单显示和隐藏</a>和<a href="#使用-javascript-实现右键菜单的各项功能">各项功能实现</a>两部分代码，必要时需要替换<code>RandomGo()</code> 函数的实现。</li></ol><p>如果你想要使用这个右键菜单，只需将上述代码复制到你的 Hexo博客中即可。你可以根据自己的需求进一步修改和扩展这个右键菜单的功能。如果你对这个右键菜单有任何疑问或建议，欢迎在评论区留言讨论。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo Blog Building </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Fluid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蔷薇花又开</title>
      <link href="/_posts/%E8%94%B7%E8%96%87%E8%8A%B1%E5%8F%88%E5%BC%80/"/>
      <url>/_posts/%E8%94%B7%E8%96%87%E8%8A%B1%E5%8F%88%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_01.webp&quot;);" viewBox="0 0 1000 1636"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_02.webp&quot;);" viewBox="0 0 1000 1636"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_03.webp&quot;);" viewBox="0 0 1000 1635"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_04.webp&quot;);" viewBox="0 0 1000 1636"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_05.webp&quot;);" viewBox="0 0 1000 1636"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_06.webp&quot;);" viewBox="0 0 1000 1636"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_07.webp&quot;);" viewBox="0 0 1000 1636"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_08.webp&quot;);" viewBox="0 0 1000 1635"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_09.webp&quot;);" viewBox="0 0 1000 1636"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蔷薇花又开_10.webp&quot;);" viewBox="0 0 1000 1636"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-2-3 PyTorch基础【Xflops-HPC Start Guide】</title>
      <link href="/_posts/6-2-3-PyTorch%E5%9F%BA%E7%A1%80%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/"/>
      <url>/_posts/6-2-3-PyTorch%E5%9F%BA%E7%A1%80%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/</url>
      
        <content type="html"><![CDATA[<div class="note note-info">            <p>新学期即将来临，Xflops超算队招新以及HelloHPC超算校内赛正在火热筹备中。作为Xflops超算队的一员，我与其他成员将共同负责<a href="https://xflops.sjtu.edu.cn/hpc-start-guide">HPC入门指南</a>的修订与编写。Xflops超算队的HPC入门指南系列文章旨在帮助新成员快速入门和了解HPC知识，为校内赛的参赛者提供必要的知识储备和技能指导。</p>          </div><p><a href="https://xflops.sjtu.edu.cn/hpc-start-guide" name="/img/cover/xflops.webp" target="_blank" class="LinkCard">HPC入门指南</a></p><h1 id="pytorch基础">PyTorch基础</h1><p>在前面的内容中，我们介绍了Python的基本语法和数据结构。本节将介绍PyTorch的基础知识，帮助你了解如何使用PyTorch进行张量运算和深度学习模型的构建。</p><h2 id="pytorch简介">PyTorch简介</h2><p><a href="https://pytorch.org/">PyTorch</a> 是一个开源的 Python机器学习库，基于 Torch，用于自然语言处理等应用程序。它最初由 Facebook人工智能研究院（FAIR）在 2017 年 1月发布，现在已经成为人工智能领域最受欢迎的框架之一。PyTorch提供了两个主要功能：一是具有强大的 GPU加速的张量计算；二是包含自动微分系统的深度神经网络构建。</p><p>随着深度学习的快速发展，PyTorch以其独特的优势在学术界和工业界得到了广泛的应用。这里简要列举几个 PyTorch的主要优势：</p><ol type="1"><li><strong>动态计算图</strong>：采用动态计算图机制，运行时可动态构建。相比静态计算图而言更加灵活，便于调试和修改模型结构，适合快速原型设计和研究。</li><li><strong>易于使用</strong>：PyTorch 拥有简洁直观的 API设计，代码风格接近于标准Python，便于上手和开发，适合初学者和研究人员快速实现模型。</li><li><strong>强大的社区支持</strong>：拥有庞大活跃的社区，可获取丰富学习资源、示例代码和解决方案。同时得到众多研究机构和企业支持，持续发展更新。</li><li><strong>跨平台支持</strong>：支持 Windows、Linux 和 macOS等多种操作系统，可在 CPU 和 GPU上运行，满足不同环境下的开发和部署需求。</li></ol><h2 id="pytorch基础概念">PyTorch基础概念</h2><h3 id="张量tensor">张量（Tensor）</h3><p>张量是 PyTorch 中的基本数据结构，类似 NumPy的数组，可表示标量、向量、矩阵及更高维数据，能在 CPU 或 GPU 上运行，通过CUDA 技术加速计算。</p><p><strong>创建张量</strong>有多种方式，其中使用较多的有直接创建和使用函数创建两种方式：</p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> torch</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 创建标量张量</span></span><span class="line"><span style="color: #ABB2BF">scalar </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">tensor</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">5</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 创建向量张量</span></span><span class="line"><span style="color: #ABB2BF">vector </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">tensor</span><span style="color: #ABB2BF">([</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">])</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 创建矩阵张量</span></span><span class="line"><span style="color: #ABB2BF">matrix </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">tensor</span><span style="color: #ABB2BF">([[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">], [</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">]])</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 创建3x3全零张量</span></span><span class="line"><span style="color: #ABB2BF">zeros </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">zeros</span><span style="color: #ABB2BF">((</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 创建2x2全一张量</span></span><span class="line"><span style="color: #ABB2BF">ones </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">ones</span><span style="color: #ABB2BF">((</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 创建3x3单位矩阵张量</span></span><span class="line"><span style="color: #ABB2BF">eye_matrix </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">eye</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 创建2x3随机张量（正态分布）</span></span><span class="line"><span style="color: #ABB2BF">random_tensor </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">randn</span><span style="color: #ABB2BF">((</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">))</span></span></code></pre></div></div></figure><p>张量支持加减乘除、矩阵运算、索引和切片等数学运算，与 NumPy数组操作类似。 </p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 张量加法</span></span><span class="line"><span style="color: #ABB2BF">result </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> matrix </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> random_tensor</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 矩阵乘法</span></span><span class="line"><span style="color: #ABB2BF">product </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> matrix </span><span style="color: #56B6C2">@</span><span style="color: #ABB2BF"> random_tensor.</span><span style="color: #61AFEF">t</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># @表示矩阵乘法，t()用于转置张量</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 索引和切片</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(matrix[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">])  </span><span style="color: #7F848E; font-style: italic"># 输出第一行第二列元素</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(random_tensor[:, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">])  </span><span style="color: #7F848E; font-style: italic"># 输出所有行第二列元素</span></span></code></pre></div></div></figure><p></p><h3 id="自动微分autograd">自动微分（Autograd）</h3><p>自动微分是 PyTorch实现神经网络训练的关键，可自动计算张量梯度，通过反向传播更新模型参数，无需手动推导导数公式。可以通过将张量的<code>requires_grad</code> 属性设为 <code>True</code> 启用自动微分功能。</p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">x </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">tensor</span><span style="color: #ABB2BF">([</span><span style="color: #D19A66">1.0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">2.0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">3.0</span><span style="color: #ABB2BF">], </span><span style="color: #E06C75; font-style: italic">requires_grad</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">True</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">y </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> x </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span></span><span class="line"><span style="color: #ABB2BF">z </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> y.</span><span style="color: #61AFEF">mean</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">z.</span><span style="color: #61AFEF">backward</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 反向传播计算梯度</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(x.grad)  </span><span style="color: #7F848E; font-style: italic"># 输出x的梯度</span></span></code></pre></div></div></figure><p></p><p>训练神经网络时，每次迭代前需用 <code>zero_grad()</code>方法清零梯度，避免累加。</p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">optimizer.</span><span style="color: #61AFEF">zero_grad</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 假设optimizer是优化器对象</span></span></code></pre></div></div></figure><h3 id="pytorch算子">PyTorch算子</h3><p>PyTorch算子是指在PyTorch中定义的操作或函数，用于对张量进行计算和处理。算子可以是内置的，也可以是用户自定义的。内置算子包括常见的数学运算、激活函数、损失函数等。</p><p>用户可以根据需要自定义算子，以实现特定的功能或优化性能。自定义算子通常需要使用C++或CUDA编写，并通过PyTorch提供的接口进行注册和调用。</p><h3 id="神经网络模块nn.module">神经网络模块（nn.Module）</h3><p><code>nn.Module</code>是构建神经网络的基类，继承该类可定义自己的神经网络模型，提供常用神经网络层，方便构建复杂结构。</p><p>在定义神经网络模型时：需实现<code>__init__</code>方法（初始化层和参数）和 <code>forward</code>方法（定义前向传播过程）。</p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> torch.nn </span><span style="color: #C678DD">as</span><span style="color: #ABB2BF"> nn</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Net</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">nn</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">Module</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">__init__</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #56B6C2">super</span><span style="color: #ABB2BF">(Net, </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">).</span><span style="color: #56B6C2">__init__</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.fc1 </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> nn.</span><span style="color: #61AFEF">Linear</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">784</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">256</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 输入层到隐藏层的线性层</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.relu </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> nn.</span><span style="color: #61AFEF">ReLU</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 激活函数层</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.fc2 </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> nn.</span><span style="color: #61AFEF">Linear</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">256</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 隐藏层到输出层的线性层</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">forward</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B; font-style: italic">self</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">x</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">        x </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">fc1</span><span style="color: #ABB2BF">(x)</span></span><span class="line"><span style="color: #ABB2BF">        x </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">relu</span><span style="color: #ABB2BF">(x)</span></span><span class="line"><span style="color: #ABB2BF">        x </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">self</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">fc2</span><span style="color: #ABB2BF">(x)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> x</span></span></code></pre></div></div></figure><p>可以通过<code>parameters()</code>方法获取模型参数（权重和偏置），自动被自动微分系统跟踪，用于计算梯度和更新参数。</p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">model </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Net</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> param </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> model.</span><span style="color: #61AFEF">parameters</span><span style="color: #ABB2BF">():</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(param)</span></span></code></pre></div></div></figure><h2 id="使用pytorch进行模型训练">使用PyTorch进行模型训练</h2><h3 id="数据准备">数据准备</h3><ol type="1"><li><strong>数据集加载</strong>：使用<code>torch.utils.data.Dataset</code>和<code>torch.utils.data.DataLoader</code>类处理数据集。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> torchvision</span></span><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> torchvision.transforms </span><span style="color: #C678DD">as</span><span style="color: #ABB2BF"> transforms</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 定义数据转换操作（如归一化）</span></span><span class="line"><span style="color: #ABB2BF">transform </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> transforms.</span><span style="color: #61AFEF">Compose</span><span style="color: #ABB2BF">([transforms.</span><span style="color: #61AFEF">ToTensor</span><span style="color: #ABB2BF">(), transforms.</span><span style="color: #61AFEF">Normalize</span><span style="color: #ABB2BF">((</span><span style="color: #D19A66">0.5</span><span style="color: #ABB2BF">,), (</span><span style="color: #D19A66">0.5</span><span style="color: #ABB2BF">,))])</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 加载训练集和测试集</span></span><span class="line"><span style="color: #ABB2BF">trainset </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torchvision.datasets.</span><span style="color: #61AFEF">MNIST</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">root</span><span style="color: #56B6C2">=</span><span style="color: #98C379">'./data'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">train</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">True</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">download</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">True</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">transform</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">transform)</span></span><span class="line"><span style="color: #ABB2BF">testset </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torchvision.datasets.</span><span style="color: #61AFEF">MNIST</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">root</span><span style="color: #56B6C2">=</span><span style="color: #98C379">'./data'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">train</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">False</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">download</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">True</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">transform</span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF">transform)</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 创建数据加载器</span></span><span class="line"><span style="color: #ABB2BF">trainloader </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.utils.data.</span><span style="color: #61AFEF">DataLoader</span><span style="color: #ABB2BF">(trainset, </span><span style="color: #E06C75; font-style: italic">batch_size</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">64</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">shuffle</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">True</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">testloader </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.utils.data.</span><span style="color: #61AFEF">DataLoader</span><span style="color: #ABB2BF">(testset, </span><span style="color: #E06C75; font-style: italic">batch_size</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">64</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">shuffle</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">False</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure></li><li><strong>数据预处理</strong>：输入神经网络前，进行归一化、标准化、数据增强等预处理，<code>torchvision.transforms</code>模块提供丰富预处理函数。</li></ol><h3 id="模型定义">模型定义</h3><p>根据任务需求，使用<code>nn.Module</code>定义合适的神经网络模型，如全连接神经网络、卷积神经网络（CNN）、循环神经网络（RNN）等。</p><h3 id="损失函数和优化器选择">损失函数和优化器选择</h3><ol type="1"><li><strong>损失函数</strong>：衡量模型预测结果与真实标签的差距，PyTorch提供均方误差损失（MSELoss）、交叉熵损失（CrossEntropyLoss）等，依任务类型选择。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">criterion </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> nn.</span><span style="color: #61AFEF">CrossEntropyLoss</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 分类任务常用</span></span></code></pre></div></div></figure></li><li><strong>优化器</strong>：更新模型参数以最小化损失函数，支持随机梯度下降（SGD）、Adam、RMSprop等优化算法。 <figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">optimizer </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.optim.</span><span style="color: #61AFEF">Adam</span><span style="color: #ABB2BF">(model.</span><span style="color: #61AFEF">parameters</span><span style="color: #ABB2BF">(), </span><span style="color: #E06C75; font-style: italic">lr</span><span style="color: #56B6C2">=</span><span style="color: #D19A66">0.001</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure></li></ol><h3 id="模型训练">模型训练</h3><ol type="1"><li><strong>训练循环</strong>：迭代处理小批量数据，包含前向传播、计算损失、反向传播和更新参数。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">model.</span><span style="color: #61AFEF">train</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 设置模型为训练模式</span></span><span class="line"><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> epoch </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(num_epochs):</span></span><span class="line"><span style="color: #ABB2BF">    running_loss </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.0</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> inputs, labels </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> trainloader:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 梯度清零</span></span><span class="line"><span style="color: #ABB2BF">        optimizer.</span><span style="color: #61AFEF">zero_grad</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 前向传播</span></span><span class="line"><span style="color: #ABB2BF">        outputs </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">model</span><span style="color: #ABB2BF">(inputs.</span><span style="color: #61AFEF">view</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">784</span><span style="color: #ABB2BF">))  </span><span style="color: #7F848E; font-style: italic"># 将图像数据展平为向量</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 计算损失</span></span><span class="line"><span style="color: #ABB2BF">        loss </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">criterion</span><span style="color: #ABB2BF">(outputs, labels)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 反向传播</span></span><span class="line"><span style="color: #ABB2BF">        loss.</span><span style="color: #61AFEF">backward</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic"># 更新参数</span></span><span class="line"><span style="color: #ABB2BF">        optimizer.</span><span style="color: #61AFEF">step</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">        running_loss </span><span style="color: #56B6C2">+=</span><span style="color: #ABB2BF"> loss.</span><span style="color: #61AFEF">item</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">f</span><span style="color: #98C379">'Epoch </span><span style="color: #D19A66">{</span><span style="color: #ABB2BF">epoch </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1}</span><span style="color: #98C379">, Loss: </span><span style="color: #D19A66">{</span><span style="color: #ABB2BF">running_loss </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">len</span><span style="color: #ABB2BF">(trainloader)</span><span style="color: #D19A66">}</span><span style="color: #98C379">'</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure></li><li><strong>训练技巧</strong>：训练中可使用学习率调整、正则化（L1/L2正则化、Dropout）、数据增强等技巧提升模型性能。</li></ol><h3 id="模型评估">模型评估</h3><p>训练后用测试集评估模型泛化能力，计算准确率、精确率、召回率、F1值等指标。</p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">model.</span><span style="color: #61AFEF">eval</span><span style="color: #ABB2BF">()  </span><span style="color: #7F848E; font-style: italic"># 设置模型为评估模式</span></span><span class="line"><span style="color: #ABB2BF">correct </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #ABB2BF">total </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #C678DD">with</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">no_grad</span><span style="color: #ABB2BF">():  </span><span style="color: #7F848E; font-style: italic"># 不计算梯度，提高评估速度</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> inputs, labels </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> testloader:</span></span><span class="line"><span style="color: #ABB2BF">        outputs </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">model</span><span style="color: #ABB2BF">(inputs.</span><span style="color: #61AFEF">view</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">784</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #ABB2BF">        _, predicted </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">max</span><span style="color: #ABB2BF">(outputs.data, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        total </span><span style="color: #56B6C2">+=</span><span style="color: #ABB2BF"> labels.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        correct </span><span style="color: #56B6C2">+=</span><span style="color: #ABB2BF"> (predicted </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> labels).</span><span style="color: #61AFEF">sum</span><span style="color: #ABB2BF">().</span><span style="color: #61AFEF">item</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">f</span><span style="color: #98C379">'Accuracy on test set: </span><span style="color: #D19A66">{100</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> correct </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> total</span><span style="color: #D19A66">}</span><span style="color: #98C379">%'</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><h3 id="模型保存和加载">模型保存和加载</h3><p>在训练完成后，通常需要保存模型以便后续使用或部署。PyTorch提供了简单的模型保存和加载方法。</p><ol type="1"><li><p><strong>保存模型</strong>：使用<code>torch.save()</code>函数保存模型参数或整个模型。</p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 保存模型参数</span></span><span class="line"><span style="color: #ABB2BF">torch.</span><span style="color: #61AFEF">save</span><span style="color: #ABB2BF">(model.</span><span style="color: #61AFEF">state_dict</span><span style="color: #ABB2BF">(),</span><span style="color: #98C379">'model.pth'</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 保存整个模型</span></span><span class="line"><span style="color: #ABB2BF">torch.</span><span style="color: #61AFEF">save</span><span style="color: #ABB2BF">(model,</span><span style="color: #98C379">'model.pkl'</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><p></p></li><li><p><strong>加载模型</strong>：用<code>torch.load()</code>函数加载，加载参数需先创建模型实例再用<code>load_state_dict()</code>方法。</p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 加载模型参数</span></span><span class="line"><span style="color: #ABB2BF">model </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Net</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">model.</span><span style="color: #61AFEF">load_state_dict</span><span style="color: #ABB2BF">(torch.</span><span style="color: #61AFEF">load</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'model.pth'</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 加载整个模型</span></span><span class="line"><span style="color: #ABB2BF">model </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> torch.</span><span style="color: #61AFEF">load</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'model.pkl'</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><p></p></li></ol><h2 id="小结">小结</h2><p>通过本节内容，我们希望你对PyTorch的基本概念有一定了解。实际上，我们在这里介绍的只是PyTorch的冰山一角，并不要求你完全掌握所有内容。你只需要对PyTorch张量运算的基本规则和PyTorch的基础工作流程有一定了解即可，如果感兴趣，可以自行查找资料学习编写PyTorch的算子的方法。</p><p>这里我们给出一些有用的链接，供你进一步学习和参考：</p><ul><li><a href="https://pytorch.org/docs/stable/index.html">PyTorch官方文档</a></li><li><a href="https://pytorch.ac.cn/tutorials/beginner/basics/tensorqs_tutorial.html">PyTorch张量的基本运算</a></li><li><a href="https://pytorch.ac.cn/tutorials/beginner/basics/autogradqs_tutorial.html">PyTorch自动微分</a></li><li><a href="https://pytorch.ac.cn/tutorials/advanced/custom_ops_landing_page.html">PyTorch自定义算子手册</a></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-75c6aad8" role="button" aria-expanded="false" aria-controls="collapse-75c6aad8">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-75c6aad8">        <div class="fold-content">          <ol type="1"><li>使用PyTorch的张量类型，编写程序使用定积分的定义计算<span class="math inline">$\int_{0}^{y} \frac{1}{x^2+1} \, dx$</span>的值<ul><li>输入：一维torch.Tensor张量，每个数字代表一个y的取值。</li><li>输出：一维torch.Tensor张量，每个位置对应于输入的y计算得到的定积分的值。</li></ul></li><li>（选做）自己编写一个PyTorch算子（基于C++或CUDA），输入一个张量x，返回张量<span class="math inline">$\frac{1}{x^2+1}$</span>。并在python中调用这个算子运用定积分的定义计算<span class="math inline">$\int_{0}^{y} \frac{1}{x^2+1} \,dx$</span>的值（输入输出要求与 1 中相同）</li><li>（选做）使用PyTorch构建一个简单的神经网络模型，对手写数字（MNIST数据集）进行分类，并评估模型性能。</li></ol>        </div>      </div>    </div>]]></content>
      
      
      <categories>
          
          <category> Xflops-HPC Start Guide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xflops </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-2-2 Python语法基础【Xflops-HPC Start Guide】</title>
      <link href="/_posts/6-2-2-Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/"/>
      <url>/_posts/6-2-2-Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/</url>
      
        <content type="html"><![CDATA[<div class="note note-info">            <p>新学期即将来临，Xflops超算队招新以及HelloHPC超算校内赛正在火热筹备中。作为Xflops超算队的一员，我与其他成员将共同负责<a href="https://xflops.sjtu.edu.cn/hpc-start-guide">HPC入门指南</a>的修订与编写。Xflops超算队的HPC入门指南系列文章旨在帮助新成员快速入门和了解HPC知识，为校内赛的参赛者提供必要的知识储备和技能指导。</p>          </div><p><a href="https://xflops.sjtu.edu.cn/hpc-start-guide" name="/img/cover/xflops.webp" target="_blank" class="LinkCard">HPC入门指南</a></p><h1 id="python语法基础">Python语法基础</h1><p>在这节內容中，我们将介绍Python的基本语法和数据结构。</p><h2 id="python基础语法">Python基础语法</h2><p>Python是一种易于学习和使用的编程语言，其语法简洁明了。以下是一些Python的基本语法概念：</p><ul><li><strong>注释</strong>：Python使用 <code>#</code>符号来表示单行注释，使用三重引号 <code>"""</code> 或 <code>'''</code>来表示多行注释。 <figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 这是一个单行注释</span></span><span class="line"><span style="color: #98C379">"""</span></span><span class="line"><span style="color: #98C379">这是一个多行注释</span></span><span class="line"><span style="color: #98C379">"""</span></span></code></pre></div></div></figure></li><li><strong>变量与赋值</strong>：Python中的变量不需要声明类型，可以直接赋值。</li><li><strong>数据类型</strong>：Python支持多种数据类型，包括整数、浮点数、字符串、列表、元组、字典等。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">x </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 整数</span></span><span class="line"><span style="color: #ABB2BF">y </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">3.14</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 浮点数</span></span><span class="line"><span style="color: #ABB2BF">name </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Alice"</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 字符串</span></span></code></pre></div></div></figure></li><li><strong>运算符</strong>：Python支持常见的算术运算符、比较运算符和逻辑运算符。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">a </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">5</span></span><span class="line"><span style="color: #ABB2BF">b </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 算术运算</span></span><span class="line"><span style="color: #56B6C2">sum</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> a </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> b  </span><span style="color: #7F848E; font-style: italic"># 加法</span></span><span class="line"><span style="color: #ABB2BF">diff </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> a </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> b  </span><span style="color: #7F848E; font-style: italic"># 减法</span></span><span class="line"><span style="color: #ABB2BF">product </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> a </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> b  </span><span style="color: #7F848E; font-style: italic"># 乘法</span></span><span class="line"><span style="color: #ABB2BF">quotient </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> a </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> b  </span><span style="color: #7F848E; font-style: italic"># 除法</span></span><span class="line"><span style="color: #ABB2BF">remainder </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> a </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> b  </span><span style="color: #7F848E; font-style: italic"># 取余</span></span><span class="line"><span style="color: #ABB2BF">power </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> a </span><span style="color: #56B6C2">**</span><span style="color: #ABB2BF"> b  </span><span style="color: #7F848E; font-style: italic"># 幂运算</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 比较运算</span></span><span class="line"><span style="color: #ABB2BF">larger </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (a </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> b)  </span><span style="color: #7F848E; font-style: italic"># 大于</span></span><span class="line"><span style="color: #ABB2BF">smaller </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (a </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> b)  </span><span style="color: #7F848E; font-style: italic"># 小于</span></span><span class="line"><span style="color: #ABB2BF">is_equal </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (a </span><span style="color: #56B6C2">==</span><span style="color: #ABB2BF"> b)  </span><span style="color: #7F848E; font-style: italic"># 等于</span></span><span class="line"><span style="color: #ABB2BF">is_not_equal </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (a </span><span style="color: #56B6C2">!=</span><span style="color: #ABB2BF"> b)  </span><span style="color: #7F848E; font-style: italic"># 不等于</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 逻辑运算</span></span><span class="line"><span style="color: #ABB2BF">and_result </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (a </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">and</span><span style="color: #ABB2BF"> b </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 与运算</span></span><span class="line"><span style="color: #ABB2BF">or_result </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (a </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">or</span><span style="color: #ABB2BF"> b </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 或运算</span></span><span class="line"><span style="color: #ABB2BF">not_result </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">not</span><span style="color: #ABB2BF"> (a </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 非运算</span></span></code></pre></div></div></figure></li><li><strong>输入输出</strong>：使用 <code>print()</code>函数输出内容，使用 <code>input()</code> 函数获取用户输入。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">name </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">input</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"Enter your name: "</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"Hello, "</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> name)</span></span></code></pre></div></div></figure></li><li><strong>控制结构</strong>：Python使用缩进来表示代码块，支持条件语句、循环语句等。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> x </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"x is positive"</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #C678DD">elif</span><span style="color: #ABB2BF"> x </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"x is negative"</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #C678DD">else</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"x is zero"</span><span style="color: #ABB2BF">)</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">in</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">range</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">5</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(i)  </span><span style="color: #7F848E; font-style: italic"># 输出0到4</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> x </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(x)</span></span><span class="line"><span style="color: #ABB2BF">    x </span><span style="color: #56B6C2">-=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 每次循环减1，直到x为0</span></span></code></pre></div></div></figure></li><li><strong>函数</strong>：Python使用 <code>def</code>关键字定义函数，可以有参数和返回值。 <figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">add</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">a</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66; font-style: italic">b</span><span style="color: #ABB2BF">):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> a </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> b</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">result </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">add</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">5</span><span style="color: #ABB2BF">)  </span><span style="color: #7F848E; font-style: italic"># 调用函数</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(result)  </span><span style="color: #7F848E; font-style: italic"># 输出8</span></span></code></pre></div></div></figure></li><li><strong>异常处理</strong>：Python使用 <code>try</code> 和<code>except</code> 语句来处理异常。 <figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">try</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    result </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 可能引发除以零异常</span></span><span class="line"><span style="color: #C678DD">except</span><span style="color: #ABB2BF"> ZeroDivisionError:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"Cannot divide by zero"</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure></li></ul><p>读者可以通过以下链接了解Python的基本语法：</p><ul><li><a href="https://www.runoob.com/python3/python3-basic-syntax.html">Python基础语法</a></li><li><a href="https://www.runoob.com/python3/python3-data-type.html">Python基本数据类型</a></li><li><a href="https://www.runoob.com/python3/python3-conditional-statements.html">Python条件语句</a>：if、elif、else</li><li><a href="https://www.runoob.com/python3/python3-loop.html">Python循环语句</a>：for、while</li></ul><h2 id="python基础数据结构">Python基础数据结构</h2><p>Python内置了多种数据结构，常用的有以下几种：</p><ul><li><strong>数字（Number）</strong>：支持证书整数（int）、浮点数（float）、布尔值（bool）和复数（complex）。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">integer </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">42</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 整数</span></span><span class="line"><span style="color: #ABB2BF">floating </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">3.14</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 浮点数</span></span><span class="line"><span style="color: #ABB2BF">boolean </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">True</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 布尔值</span></span><span class="line"><span style="color: #ABB2BF">complex_number </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #C678DD">j</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 复数</span></span></code></pre></div></div></figure></li><li><strong>字符串（String）</strong>：用于存储文本数据，可以使用单引号或双引号定义。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">greeting </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Hello, World!"</span></span></code></pre></div></div></figure></li><li><strong>列表（List）</strong>：有序可变的元素集合，可以包含不同类型的元素。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">fruits </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [</span><span style="color: #98C379">"apple"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"banana"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"cherry"</span><span style="color: #ABB2BF">]</span></span></code></pre></div></div></figure></li><li><strong>元组（Tuple）</strong>：有序不可变的元素集合，通常用于存储多个值。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">point </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">20</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure></li><li><strong>字典（Dictionary）</strong>：无序可变的键值对集合，适合用于存储关联数据。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">student </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {</span><span style="color: #98C379">"name"</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">"Alice"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"age"</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">20</span><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure></li><li><strong>集合（Set）</strong>：无序不重复的元素集合，常用于去重和集合运算。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">unique_numbers </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> {</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">5</span><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure></li></ul><p>读者可以通过以下链接了解Python的基础数据结构：</p><ul><li><a href="https://www.runoob.com/python3/python3-number.html">Python数字</a></li><li><a href="https://www.runoob.com/python3/python3-string.html">Python字符串</a></li><li><a href="https://www.runoob.com/python3/python3-list.html">Python列表</a></li><li><a href="https://www.runoob.com/python3/python3-tuple.html">Python元组</a></li><li><a href="https://www.runoob.com/python3/python3-dictionary.html">Python字典</a></li><li><a href="https://www.runoob.com/python3/python3-set.html">Python集合</a></li></ul><h2 id="可变与不可变类型">可变与不可变类型</h2><p>在Python中，数据类型可以分为不可变类型和可变类型，以上面介绍的六种数据结构为例：</p><ul><li>不可变类型：数字（Number）、字符串（String）、元组（Tuple）</li><li>可变类型：列表（List）、字典（Dictionary）、集合（Set）</li></ul><p>所谓“不可变类型”的数据对象，是指一旦创建后，其内容不能被修改；而用户视角下的修改操作实际上是创建了一个新的对象。相对的，“可变类型”的数据对象在创建之后，其值能够被修改，而且对象的身份保持不变。更进一步解释，当对不可变类型的对象进行修改时，其对应的内存地址会发生变化，而对可变类型的对象进行修改时，其内存地址保持不变。</p><p>这里给出一个简单的例子来说明可变与不可变类型的区别：</p><figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 示例1：字符串（不可变）</span></span><span class="line"><span style="color: #ABB2BF">s </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"hello"</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">id</span><span style="color: #ABB2BF">(s))  </span><span style="color: #7F848E; font-style: italic"># 输出：140701435548848</span></span><span class="line"><span style="color: #ABB2BF">s </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> s </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" world"</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">id</span><span style="color: #ABB2BF">(s))  </span><span style="color: #7F848E; font-style: italic"># 输出：140701435549008（ID改变，说明创建了新对象）</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># 示例2：列表（可变）</span></span><span class="line"><span style="color: #ABB2BF">lst </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">]</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">id</span><span style="color: #ABB2BF">(lst))  </span><span style="color: #7F848E; font-style: italic"># 输出：140701435550080</span></span><span class="line"><span style="color: #ABB2BF">lst.</span><span style="color: #61AFEF">append</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #56B6C2">print</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">id</span><span style="color: #ABB2BF">(lst))  </span><span style="color: #7F848E; font-style: italic"># 输出：140701435550080（ID未变，还是原来的对象）</span></span></code></pre></div></div></figure><p>那么，这在实际应用中有什么影响呢？举两个例子：</p><ul><li>作为函数参数时：<ul><li>不可变对象作为参数传递时，函数内部对其修改不会影响到外部的原始对象。</li><li>可变对象作为参数传递时，函数内部对其修改会直接影响到外部的原始对象。</li></ul></li><li>在容器中的情况：<ul><li>不可变对象可以作为dict的键或者set的元素，因为它们的哈希值不会改变。</li><li>可变对象不能作为dict的键或者set的元素，因为它们的值可能会变化，导致哈希冲突。</li></ul></li></ul><p>因此，理解可变和不可变对象的区别，对于编写可靠的代码、避免意外副作用以及进行性能优化都非常关键。</p><h2 id="小结">小结</h2><p>通过本节内容，我们希望你对Python的基本语法和数据结构有一定了解。Python是一种易于学习和使用的编程语言，具有丰富的内置数据结构和强大的功能。掌握这些基础知识后，你将能够更好地使用Python进行编程。</p><p>至于更进阶的Python知识，可以自行查阅相关资料或参考书籍，例如：</p><ul><li><a href="https://docs.python.org/3/">Python官方文档</a></li><li><a href="https://cs50.harvard.edu/python/">CS50课程</a></li><li><a href="https://cs61a.org/">CS61A课程</a></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-58ad0d12" role="button" aria-expanded="false" aria-controls="collapse-58ad0d12">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-58ad0d12">        <div class="fold-content">          <ol type="1"><li>编写一个Python程序，创建一个包含至少5个元素的列表，使用循环接受用户输入并将输入的值添加到列表中，然后判断每项的类型，并输出每项的类型和内容。</li><li>尝试运行下述的Python代码，并解释<code>data1.txt</code>中的内容。<figure class="shiki python"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">import</span><span style="color: #ABB2BF"> time</span></span><span class="line"><span style="color: #C678DD">def</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">save_data</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66; font-style: italic">filename</span><span style="color: #ABB2BF"> ,</span><span style="color: #D19A66; font-style: italic">datas</span><span style="color: #ABB2BF"> = []):</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic"># add timestamp as header</span></span><span class="line"><span style="color: #ABB2BF">    datas.</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, time.</span><span style="color: #61AFEF">time</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">with</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">open</span><span style="color: #ABB2BF">(filename ,</span><span style="color: #98C379">'w'</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">as</span><span style="color: #ABB2BF"> f:</span></span><span class="line"><span style="color: #ABB2BF">        f.</span><span style="color: #61AFEF">write</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">join</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">map</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">str</span><span style="color: #ABB2BF">,datas)))</span></span><span class="line"></span><span class="line"><span style="color: #61AFEF">save_data</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'data0.txt'</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #61AFEF">save_data</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'data1.txt'</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure></li><li>（选做）不使用任何第三方库，尝试利用定积分的定义编写一个Python程序计算<span class="math inline">$\int_{0}^{1} \frac{1}{x^2+1} \,dx$</span>的值。</li></ol>        </div>      </div>    </div>]]></content>
      
      
      <categories>
          
          <category> Xflops-HPC Start Guide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xflops </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-2-1 Python环境管理【Xflops-HPC Start Guide】</title>
      <link href="/_posts/6-2-1-Python%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/"/>
      <url>/_posts/6-2-1-Python%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/</url>
      
        <content type="html"><![CDATA[<div class="note note-info">            <p>新学期即将来临，Xflops超算队招新以及HelloHPC超算校内赛正在火热筹备中。作为Xflops超算队的一员，我与其他成员将共同负责<a href="https://xflops.sjtu.edu.cn/hpc-start-guide">HPC入门指南</a>的修订与编写。Xflops超算队的HPC入门指南系列文章旨在帮助新成员快速入门和了解HPC知识，为校内赛的参赛者提供必要的知识储备和技能指导。</p>          </div><p><a href="https://xflops.sjtu.edu.cn/hpc-start-guide" name="/img/cover/xflops.webp" target="_blank" class="LinkCard">HPC入门指南</a></p><h1 id="python简介">Python简介</h1><p>Python是一种广泛使用的高级编程语言，因其简洁易读的语法和强大的库支持而受到开发者的喜爱，近年来随着AI和数据科学的兴起，Python的使用越来越普及。Python支持多种编程范式，包括面向对象、函数式和命令式编程，并且拥有丰富的标准库和第三方库，使得开发者可以快速构建各种应用程序。因其适用于包括数据分析、机器学习、Web开发、自动化脚本等在内的多种应用场景，我们需要掌握基础的Python知识。</p><p>在本节内容中，我们将会向您介绍Python环境的搭建与管理，以便您能够在自己的计算机上进行Python编程和开发。而在后续的内容中，我们还将介绍Python的基本语法以及Pytorch库的使用。</p><h1 id="python环境搭建">Python环境搭建</h1><div class="note note-success">            <p>我们提供的标准开发环境中已经包含了Python环境和Conda，因此您可以运行下面的命令激活conda环境进行Python编程和开发。</p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">source</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">~/scripts/conda.sh</span></span></code></pre></div></div></figure>如果您希望在自己的计算机上搭建Python环境，可以参考以下内容。<p></p>          </div><p>在开始Python编程之前，您需要在您的计算机上安装Python环境。一般来说，我们可以直接安装Python的官方版本，也可以使用Miniconda等发行版来管理Python环境和依赖库。</p><h2 id="安装python的官方版本">安装Python的官方版本</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-483ebe8a" role="button" aria-expanded="false" aria-controls="collapse-483ebe8a">        <div class="fold-arrow">▶</div>MacOS系统与Linux系统已预装Python      </div>      <div class="fold-collapse collapse" id="collapse-483ebe8a">        <div class="fold-content">          <p>事实上MacOS系统与Linux系统默认安装了<code>python</code>，可以在命令行中使用<code>python3</code>命令运行。但是预装的Python是一些系统工具的依赖，通常不建议使用这个Python作为您的开发环境。我们推荐您使用<code>conda</code>来创建Python开发环境。</p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-daaf6971" role="button" aria-expanded="false" aria-controls="collapse-daaf6971">        <div class="fold-arrow">▶</div>Windows上快速安装Python      </div>      <div class="fold-collapse collapse" id="collapse-daaf6971">        <div class="fold-content">          <p>新版本的Windows上有<code>winget</code>可以用于快速安装常用工具链。运行<code>winget install Python</code>即可自动完成Python的安装。但是如果有多Python环境管理的需求，我们仍然建议您使用<code>conda</code>来创建Python的开发环境。</p>        </div>      </div>    </div><p>以下是安装Python官方版本的步骤：</p><ol type="1"><li><strong>下载Python</strong>：访问<a href="https://www.python.org/downloads/">Python官网</a>下载适合您操作系统的Python版本。建议下载最新的稳定版本。</li><li><strong>安装Python</strong>：运行下载的安装程序，按照提示完成安装。在安装过程中，请确保勾选“AddPython to PATH”选项，这样可以在命令行中直接使用Python命令。</li><li><strong>验证安装</strong>：安装完成后，在命令行中输入以下命令来验证Python是否安装成功并添加到环境变量中：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">python</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--version</span></span></code></pre></div></div></figure> 如果安装成功，您将看到Python的版本信息。</li><li><strong>安装pip</strong>：Python 3.4及以上版本默认包含<code>pip</code> ，如果您的版本不包含，可以手动安装。验证<code>pip</code> 是否安装成功： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--version</span></span></code></pre></div></div></figure></li></ol><h3 id="使用miniconda安装python">使用Miniconda安装Python</h3><p>Anaconda是一个流行的Python发行版，包含了Python解释器和大量的科学计算和数据分析库。而Miniconda是Anaconda的轻量级版本，适合需要更小安装包的用户。这里以Miniconda为例介绍安装步骤：</p><ol type="1"><li><strong>下载Miniconda</strong>：访问Anaconda官网的<a href="https://www.anaconda.com/download/success">Miniconda下载界面</a>下载适合您操作系统的Miniconda安装包。</li><li><strong>安装Miniconda</strong>：运行下载的安装程序，按照提示完成安装。在安装过程中，您可以选择将Miniconda添加到系统的环境变量中，这样可以在命令行中直接使用<code>conda</code> 命令。</li><li><strong>验证安装</strong>：安装完成后，在命令行中输入以下命令来验证Miniconda是否安装成功：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--version</span></span></code></pre></div></div></figure> 如果安装成功，您将看到conda的版本信息。</li></ol><h2 id="选择合适的ide">选择合适的IDE</h2><p>Python只是一种编程语言，您还需要一个合适的集成开发环境（IDE）来编写和运行Python代码。我们推荐使用以下两种IDE：</p><ul><li>VSCode + Python插件</li><li>Pycharm</li></ul><p>如果在搭建Python环境的过程中遇到问题，可以参考以下教程：</p><ul><li><a href="https://www.runoob.com/vscode/vscode-install.html">VSCode安装教程</a></li><li><a href="https://www.runoob.com/pycharm/pycharm-install.html">Pycharm安装教程</a></li><li><a href="https://www.runoob.com/python3/python3-install.html">Python安装教程</a></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-268c7555" role="button" aria-expanded="false" aria-controls="collapse-268c7555">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-268c7555">        <div class="fold-content">          <ol type="1"><li>在您的计算机上安装Python环境，并验证安装是否成功。</li><li>使用IDE通过SSH连接到标准开发环境，并尝试编写和运行一个简单的Python程序，例如打印“Hello,World!”，并在终端中运行该程序。</li></ol>        </div>      </div>    </div><h1 id="python环境管理">Python环境管理</h1><p>Python环境管理是指在不同的项目中使用不同的Python版本和依赖库，以避免版本冲突和依赖问题。常用的Python环境管理工具有<code>venv</code>、<code>virtualenv</code> 和 <code>conda</code>。</p><h2 id="使用-venv-进行环境管理">使用 venv 进行环境管理</h2><p>venv 是 Python自带的虚拟环境管理工具，可以创建独立的Python环境，通常配合 pip使用来管理项目的依赖库。以下是使用 venv 进行环境管理的常用指令：</p><ul><li><strong>创建虚拟环境</strong>：在命令行中输入以下命令来创建一个新的虚拟环境：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">python</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-m</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">venv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">myenv</span></span></code></pre></div></div></figure> 这将创建一个名为 <code>myenv</code> 的虚拟环境。</li><li><strong>激活虚拟环境</strong>：<ul><li>Windows用户： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">myenv/Scripts/activate</span></span></code></pre></div></div></figure></li><li>macOS和Linux用户： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">source</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">myenv/bin/activate</span></span></code></pre></div></div></figure></li></ul></li><li><strong>安装依赖库</strong>：在虚拟环境中，您可以使用 pip安装所需的依赖库，例如： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">numpy</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">pandas</span></span></code></pre></div></div></figure></li><li><strong>退出虚拟环境</strong>：完成开发后，您可以通过以下命令退出虚拟环境：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">deactivate</span></span></code></pre></div></div></figure></li><li><strong>删除虚拟环境</strong>：如果您不再需要某个虚拟环境，可以直接删除该目录。</li></ul><h2 id="使用-virtualenv-进行环境管理">使用 virtualenv 进行环境管理</h2><p>virtualenv 是一个第三方库，可以创建独立的Python环境，使用前需要用 pip安装它。virtualenv 的使用与 venv类似，这里不多赘述，感兴趣的读者可以参考<a href="https://virtualenv.pypa.io/en/latest/">virtualenv官方文档</a>。</p><h2 id="使用-conda-进行环境管理">使用 conda 进行环境管理</h2><p>conda 是 Anaconda 和 Miniconda自带的包管理和环境管理工具，适用于数据科学和机器学习领域。以下是使用conda 进行环境管理的常用指令：</p><ul><li><strong>创建虚拟环境</strong>：在命令行中输入以下命令来创建一个新的虚拟环境：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">create</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--name</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">myenv</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">python=</span><span style="color: #D19A66">3.8</span></span></code></pre></div></div></figure> 这将创建一个名为 <code>myenv</code>的虚拟环境，并安装Python 3.8版本。</li><li><strong>激活虚拟环境</strong>：在命令行中输入以下命令来激活虚拟环境：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">activate</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">myenv</span></span></code></pre></div></div></figure></li><li><strong>安装依赖库</strong>：在虚拟环境中，您可以使用 conda安装所需的依赖库，例如： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">numpy</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">pandas</span></span></code></pre></div></div></figure></li><li><strong>退出虚拟环境</strong>：完成开发后，您可以通过以下命令退出虚拟环境：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">deactivate</span></span></code></pre></div></div></figure></li><li><strong>列出所有虚拟环境</strong>：在命令行中输入以下命令来列出所有已创建的虚拟环境：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">env</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">list</span></span></code></pre></div></div></figure></li><li><strong>删除虚拟环境</strong>：如果您不再需要某个虚拟环境，可以使用以下命令删除它：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">remove</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--name</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">myenv</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--all</span></span></code></pre></div></div></figure></li><li><strong>导出环境</strong>：在命令行中输入以下命令来生成当前环境中已安装的所有包及其版本信息的文件，以便于在其他环境中复现相同的依赖：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">env</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">export</span><span style="color: #ABB2BF"> &gt; </span><span style="color: #98C379">environment.yml</span></span></code></pre></div></div></figure></li><li><strong>根据依赖文件创建环境</strong>：在命令行中输入以下命令来根据<code>environment.yml</code> 文件创建一个新的conda环境：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">env</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">create</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">environment.yml</span></span></code></pre></div></div></figure></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-82fcff42" role="button" aria-expanded="false" aria-controls="collapse-82fcff42">        <div class="fold-arrow">▶</div>离线conda环境迁移      </div>      <div class="fold-collapse collapse" id="collapse-82fcff42">        <div class="fold-content">          <p>使用上述导出环境并根据依赖文件创建环境的的方式需要新conda环境安装的机器上能够连接互联网下载依赖文件。如果您需要将现有的conda环境迁移到无互联网连接的机器上，可以使用以下命令导出conda环境到单个文件中：</p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">pack</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-n</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">your_env_name</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-o</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">env_packages.tar.gz</span></span></code></pre></div></div></figure>将此文件上传到需要安装此环境的机器上。并运行以下命令来安装此环境：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">tar</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-xzf</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">env_packages.tar.gz</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-C</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">new_env_path</span></span></code></pre></div></div></figure>我们推荐<code>new_env_path</code>设置为该机器原有的conda环境的虚拟环境管理路径。例如对于标准开发环境来说应该是<code>/home/xflops/apps/miniconda3/envs/&lt;your_env_name&gt;</code>，这样之后你可以方便的使用该机器的<code>conda</code>管理此环境。你也可以设置为一个自选的<code>new_env_path</code>。这样你将需要运行下述命令来激活此环境：<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">source new_env_path/bin/activate  # Linux/macOS</span></span><span class="line"><span style="color: #abb2bf">.\new_env_path\Scripts\activate   # Windows</span></span></code></pre></div></div></figure><strong>但需要注意</strong>：该迁移方式直接将依赖项的代码与二进制进行迁移，因此需保证迁移前后的系统一致处理器架构一致，例如将linux上的环境按上述方法迁移到windows将无法使用。<p></p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-0e4fc786" role="button" aria-expanded="false" aria-controls="collapse-0e4fc786">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-0e4fc786">        <div class="fold-content">          <p>使用 <code>venv</code> 或 <code>conda</code>工具，在实践中亲自体会一遍创建、激活、安装依赖、退出和删除虚拟环境的过程。</p>        </div>      </div>    </div><h1 id="python包管理">Python包管理</h1><p>Python包管理是指管理Python项目中的依赖库和包。常用的Python包管理工具有<code>pip</code> 和<code>conda</code>。实际上，Python的环境管理与包管理是紧密相关的，这里将简要介绍这两种工具的使用。</p><h2 id="使用-pip-管理包">使用 pip 管理包</h2><p>pip 是 Python自带的包管理工具，可以安装、升级和卸载Python包。以下是一些常用的 pip命令：</p><ul><li><strong>安装包</strong>：在命令行中输入以下命令来安装一个Python包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name</span></span></code></pre></div></div></figure><ul><li><strong>安装特定版本的包</strong>：如果您需要安装特定版本的包，可以在包名后指定版本号或最低版本号，例如：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name==</span><span style="color: #D19A66">1.0</span><span style="color: #98C379">.0</span></span><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_nam</span><span style="color: #ABB2BF">e&gt;</span><span style="color: #98C379">=</span><span style="color: #D19A66">1.0</span><span style="color: #98C379">.0</span></span></code></pre></div></div></figure></li></ul></li><li><strong>升级包</strong>：在命令行中输入以下命令来升级一个已安装的Python包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--upgrade</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name</span></span></code></pre></div></div></figure><ul><li>由于 pip 本身也是一个Python包，因此您可以使用同样的命令来升级 pip自身，这在某些情况下是必要的。</li></ul></li><li><strong>卸载包</strong>：在命令行中输入以下命令来卸载一个已安装的Python包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">uninstall</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name</span></span></code></pre></div></div></figure></li><li><strong>列出已安装的包</strong>：在命令行中输入以下命令来列出当前环境中已安装的所有Python包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">list</span></span></code></pre></div></div></figure></li><li><strong>查看包信息</strong>：在命令行中输入以下命令来查看某个已安装包的详细信息：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">show</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name</span></span></code></pre></div></div></figure></li><li><strong>搜索包</strong>：在命令行中输入以下命令来搜索Python包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">search</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name</span></span></code></pre></div></div></figure></li><li><strong>生成依赖文件</strong>：在命令行中输入以下命令来生成当前环境中已安装的所有包及其版本信息的文件，以便于在其他环境中复现相同的依赖：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">freeze</span><span style="color: #ABB2BF"> &gt; </span><span style="color: #98C379">requirements.txt</span></span></code></pre></div></div></figure></li><li><strong>安装依赖文件中的包</strong>：在命令行中输入以下命令来安装<code>requirements.txt</code> 文件中列出的所有包： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-r</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">requirements.txt</span></span></code></pre></div></div></figure></li><li><strong>配置镜像源</strong>：如果在使用 pip时遇到网络问题，可以尝试更换镜像源。常用的镜像源包括清华大学、阿里云等，具体操作可以参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">清华pip镜像源配置</a>。在命令行输入以下命令来配置清华大学的镜像源： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">config</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">set</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">global.index-url</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">https://pypi.tuna.tsinghua.edu.cn/simple</span></span></code></pre></div></div></figure>或者临时使用清华镜像源安装包： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">pip</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-i</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">https://pypi.tuna.tsinghua.edu.cn/simple</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name</span></span></code></pre></div></div></figure></li></ul><p>需要注意的是，上述操作均针对的是当前所处于的Python环境。如果您在虚拟环境中操作，所有的包管理操作都将只影响该虚拟环境中的Python包；相反，如果您在全局环境中操作，则会影响全局的Python包。</p><h2 id="使用-conda-管理包">使用 conda 管理包</h2><p>conda 是 Anaconda 和 Miniconda自带的包管理和环境管理工具，可以安装、升级和卸载Python包以及其他语言的包。以下是一些常用的conda 命令：</p><ul><li><strong>安装包</strong>：在命令行中输入以下命令来安装一个或多个Python包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name1</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name2</span></span></code></pre></div></div></figure><ul><li><strong>安装特定版本的包</strong>：如果您需要安装特定版本的包，可以在包名后指定版本号，例如：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name=</span><span style="color: #D19A66">1.0</span><span style="color: #98C379">.0</span></span></code></pre></div></div></figure></li></ul></li><li><strong>升级包</strong>：在命令行中输入以下命令来升级一个已安装的Python包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">update</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name</span></span></code></pre></div></div></figure><ul><li><strong>升级所有包</strong>：如果您想要升级当前环境中的所有包，可以使用以下命令：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">update</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--all</span></span></code></pre></div></div></figure></li></ul></li><li><strong>卸载包</strong>：在命令行中输入以下命令来卸载一个已安装的Python包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">remove</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name</span></span></code></pre></div></div></figure></li><li><strong>搜索包</strong>：在命令行中输入以下命令来搜索Python包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">search</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">package_name</span></span></code></pre></div></div></figure></li><li><strong>列出已安装的包</strong>：在命令行中输入以下命令来列出当前环境中已安装的所有包：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">list</span></span></code></pre></div></div></figure></li><li><strong>配置镜像源</strong>：如果在使用 conda时遇到网络问题，可以尝试更换镜像源。常用的镜像源包括清华大学、阿里云等，具体操作可以参考<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">清华conda镜像源配置</a>。在命令行输入以下命令来配置清华大学的镜像源： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">config</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--add</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">channels</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">config</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--set</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">show_channel_urls</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">yes</span></span></code></pre></div></div></figure>配置后可以通过下面的指令验证配置是否成功： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">conda</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">config</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--show</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">channels</span></span></code></pre></div></div></figure></li></ul><p>如果在使用 conda 时遇到问题，可以参考<a href="https://docs.conda.io/projects/conda/en/latest/">Conda官方文档</a>。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-ceda47f3" role="button" aria-expanded="false" aria-controls="collapse-ceda47f3">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-ceda47f3">        <div class="fold-content">          <ol type="1"><li>使用 <code>pip</code> 或 <code>conda</code>工具，在实践中亲自体会一遍安装、升级、卸载包的过程。</li><li>配置镜像源，对比使用镜像源和不使用镜像源安装同一个包的安装速度差异。</li><li>在你的计算机上，一共存在几个版本的Python？如果存在多个，请思考它们之间的关系。</li><li>对比你的计算机上的Python全局环境和虚拟环境中同一个包（如<code>numpy</code>）的版本，他们是否存在差异？如果存在差异，请思考原因。</li><li>小明创建并激活了一个名为 <code>myenv</code>的虚拟环境，并在其中安装了 <code>numpy</code> 和<code>pandas</code>。然而，小明代码中的 <code>import numpy</code>却在他使用的IDEVSCode中报错，提示找不到该模块，请思考可能的原因以及解决方法。并思考：如果小明在这个虚拟环境中运行该代码，是否会报错（假设不存在其他错误）？</li></ol>        </div>      </div>    </div>]]></content>
      
      
      <categories>
          
          <category> Xflops-HPC Start Guide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xflops </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-4 网络安全概述【Xflops-HPC Start Guide】</title>
      <link href="/_posts/5-4-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/"/>
      <url>/_posts/5-4-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%BF%B0%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/</url>
      
        <content type="html"><![CDATA[<div class="note note-info">            <p>新学期即将来临，Xflops超算队招新以及HelloHPC超算校内赛正在火热筹备中。作为Xflops超算队的一员，我与其他成员将共同负责<a href="https://xflops.sjtu.edu.cn/hpc-start-guide">HPC入门指南</a>的修订与编写。Xflops超算队的HPC入门指南系列文章旨在帮助新成员快速入门和了解HPC知识，为校内赛的参赛者提供必要的知识储备和技能指导。</p>          </div><p><a href="https://xflops.sjtu.edu.cn/hpc-start-guide" name="/img/cover/xflops.webp" target="_blank" class="LinkCard">HPC入门指南</a></p><h1 id="网络安全概述">网络安全概述</h1><p>在前面的章节中，我们介绍了计算机网络的OSI七层模型，以及登录交我算集群的方法和SSH协议的使用。现在，我们将进一步探讨计算机网络安全的基本概念和常见的安全风险。</p><h2 id="常见的密码算法">常见的密码算法</h2><p>在现代的计算机系统通信中，密码算法是保护数据安全的核心技术。它们用于加密和解密数据，确保信息在传输和存储过程中的机密性、完整性和可用性。密码算法可以防止未经授权的访问和数据泄露。</p><p>密码算法的种类繁多，主要可以分为三大类：</p><ul><li><strong>哈希算法</strong><ul><li>哈希算法又称为散列算法、摘要算法。常见的哈希算法有MD5、SHA-1、SHA-256等。哈希算法将任意长度的数据转换为固定长度的哈希值，常用于数据完整性校验和数字签名。</li></ul></li><li><strong>对称加密算法</strong><ul><li>常见的对称加密算法有AES、DES等。对称加密算法使用相同的密钥进行加密和解密，速度快，适合大数据量的加密。</li></ul></li><li><strong>非对称加密算法</strong><ul><li>常见的非对称加密算法有RSA、DSA等。非对称加密算法使用一对密钥（公钥和私钥）进行加密和解密，安全性高，但速度较慢，常用于小数据量的加密和数字签名。</li></ul></li></ul><p>了解常见的密码算法的加密原理的是必要的，这里给出几篇文章供参考：</p><ul><li><a href="https://javaguide.cn/system-design/security/encryption-algorithms.html">常见加密算法</a></li><li><a href="https://missing-semester-cn.github.io/2020/security/">常用的密码算法原理</a></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5d9f8c08" role="button" aria-expanded="false" aria-controls="collapse-5d9f8c08">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-5d9f8c08">        <div class="fold-content">          <ol type="1"><li>寻找一个在线加密工具，如<a href="https://www.lddgo.net/base/class?classID=3">在线工具大全</a>，对同一段文本使用不同的加密算法进行加密，观察不同算法的输出结果，学会分辨不同的加密算法。</li><li>标准开发环境中已安装OpenSSL工具，请自行查找相关资料，对同一文件使用不同的加密算法进行加密，观察不同算法的输出结果。</li><li>（选做）使用OpenSSL工具，计算此前配置标准开发环境时所下载文件的SHA256 哈希值，与我们给出的哈希值进行对比，验证文件的完整性。</li></ol>        </div>      </div>    </div><h2 id="弱口令">弱口令</h2><h3 id="什么是弱口令">什么是弱口令</h3><p>弱口令是指那些容易被他人猜测或破解的密码。它们通常由简单的数字、字母或常见词汇组成，缺乏复杂性和长度，从而降低了密码的安全性。</p><p>常见的弱口令分为两种：</p><ol type="1"><li>较短的密码。如: s7t1。可被穷举爆破。</li><li>易被猜测或侧信道攻击的密码。<ul><li>简单序列：如 123456、000000 等。</li><li>重复字符：如 aaaaaa、111111 等。</li><li>键盘顺序：如 qwerty、asdfgh 等。</li><li>常见单词或短语：如 password、iloveyou、sjtu1896 等。</li><li>个人信息：姓名、生日、电话号码等。</li></ul>这类密码容易被密码字典爆破或社会工程学攻击。</li></ol><h3 id="弱口令的风险">弱口令的风险</h3><p>由于弱口令的简单性和易猜测性，它们在网络安全中构成了严重的威胁。攻击者可以通过暴力破解、字典攻击或社会工程学等方式轻易地猜测出弱口令，从而获取对系统或服务的访问权限，导致未经授权的访问，进而产生严重的后果。</p><ul><li>SSH中如果设置了password认证且设置的是弱口令，将可能导致服务器被未经授权登录，且攻击者可以进行与你同权限的任意操作。</li><li>数据库中如果设置了弱口令被猜测成功后，攻击者将可以获取数据库的访问权限，进而对数据进行任意操作。</li><li>无线局域网中如果设置了弱口令被猜测成功后，攻击者将可以进入局域网中对局域网其他设备进行攻击。</li></ul><h3 id="防范方式">防范方式</h3><p>弱口令带来的风险是显而易见的，因此在实际应用中，我们需要采取措施来防范弱口令的使用。</p><ul><li><strong>使用强密码</strong>：强密码通常由大写字母、小写字母、数字和特殊字符组成，长度通常超过8位。强密码的复杂性使得暴力破解和字典攻击变得非常困难。</li><li><strong>定期更换密码</strong>：定期更换密码可以降低密码被猜测或泄露的风险。建议每隔一段时间（如3个月）更换一次密码。</li><li><strong>使用密码管理工具</strong>：密码管理工具可以帮助用户生成和存储强密码，避免使用弱口令。它们可以自动填充密码，减少用户记忆负担，同时提高密码的安全性。</li><li><strong>采用其他更为安全的身份认证方法</strong>：如SSH中采用publickey认证，通过生成一对公私钥来进行身份认证，避免使用弱口令。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-f5fef654" role="button" aria-expanded="false" aria-controls="collapse-f5fef654">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-f5fef654">        <div class="fold-content">          <ol type="1"><li>思考一下，如果有一个密码是由8位数字组成的，假设一个攻击者每秒可以尝试1 万个密码，那么这个密码在多长时间内会被破解？</li><li>如果这个密码是由8位数字及大小写字母组成，那么这个攻击者需要多长时间才能破解这个密码？如果包含特殊字符呢？</li><li>尝试使用一个在线密码强度测试工具，如<a href="https://www.metools.info/code/password328.html">密码强度检测</a>，测试你当前使用的密码的强度，并尝试改进它。</li></ol>        </div>      </div>    </div><h2 id="公网ip">公网IP</h2><blockquote><p>本节的IP地址均指IPv4协议下的IP地址。</p></blockquote><h3 id="什么是公网ip">什么是公网IP</h3><p>在网络世界中，每台连接到互联网的设备都有一个独特的地址，这就是IP地址。公网IP地址是可以直接从互联网访问的地址，与之相对的是私网IP地址，通常用于局域网内部。</p><p>公网IP地址是由互联网服务提供商（ISP）分配给用户的IP地址，它在全球范围内是唯一的，允许任何互联网上的设备直接访问。公网IP地址通常用于服务器、路由器等需要从互联网上直接访问的设备。例如，我们希望从任意接入互联网的地方使用ssh连接到服务器，一个简单的方法是让服务器拥有一个公网IP并运行sshd服务。</p><p>与之相对的是私网IP地址，它通常用于局域网内部的设备，如家庭路由器、公司网络等。私网IP地址不能直接从互联网上访问，通常需要通过NAT（网络地址转换）技术将其转换为公网IP地址。</p><h3 id="公网ip的风险">公网IP的风险</h3><p>一个设备一旦配置了公网IP地址，就意味着它已经暴露在互联网上，任何人都可以尝试访问这个设备。这种暴露带来了许多安全风险，尤其是当设备上运行的服务存在漏洞或配置不当时，极有可能成为黑客攻击的目标。</p><p>常见的攻击方式有：</p><ul><li><strong>端口扫描</strong>：攻击者可以扫描设备的开放端口，识别出运行的服务和应用程序。这些服务可能存在已知的漏洞或弱口令，从而成为攻击的入口。</li><li><strong>暴力破解</strong>：攻击者可以尝试使用暴力破解或字典攻击来猜测设备上服务的登录凭据，尤其是当服务使用弱口令时。</li><li><strong>利用已知漏洞</strong>：攻击者可以利用设备上运行的服务的已知漏洞进行攻击。</li><li><strong>拒绝服务攻击（DoS/DDoS）</strong>：攻击者可以通过发送大量请求来使设备无法正常工作，导致服务中断。</li></ul><h3 id="防范方式-1">防范方式</h3><div class="note note-warning">            <p>“没有危险的IP/端口，只有危险的服务”</p>          </div><p>公网IP地址本身并不危险，关键在于配置在公网IP上的服务是否安全。只要确保这些服务的安全性，就可以降低被攻击的风险。</p><p>因此，防范公网IP的风险主要是确保配置在公网IP上的服务的安全性。具体措施包括：</p><ul><li>定期更新和打补丁。确保所有运行的服务和应用程序都及时更新到最新版本，修复已知的安全漏洞。</li><li>关闭不必要的服务。定期审查设备上运行的服务，关闭不必要的服务，减少攻击面。</li><li>审查开放的服务的安全性。确保当前主机开放的所有服务均是安全的。</li><li>使用强密码。确保所有服务的登录凭据都使用强密码，避免使用弱口令。</li><li>使用防火墙。配置防火墙规则，仅允许必要的服务和端口对外开放。</li><li>使用入侵检测系统（IDS）和入侵防御系统（IPS）。这些系统可以监控网络流量，检测和阻止可疑活动，提供额外的安全防护。</li><li>限制访问权限。配置服务的访问控制列表（ACL），仅允许特定的IP地址或IP段访问服务。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-a7524aa5" role="button" aria-expanded="false" aria-controls="collapse-a7524aa5">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-a7524aa5">        <div class="fold-content">          <ol type="1"><li>访问<a href="https://net.sjtu.edu.cn/index.html">上海交通大学网络信息中心网站首页</a>，查看页面底的IP地址信息，了解你的计算机的公网IP地址。</li><li>在命令行中使用 <code>ipconfig</code> 命令（Windows）或<code>ifconfig</code> 命令（Linux/Mac）查看你的计算机的IP地址信息。</li><li>如果你开通了上海交通大学学生宿舍有线网，且连接了SJTU无线网，对比上一步中不同网卡的IP地址信息，了解不同网络环境下的IP地址分配情况。</li><li>使用 <code>netstat</code>命令查看当前计算机上开放的端口和服务，了解哪些服务正在监听公网IP地址。</li><li>了解常用网站的公网IP地址。（提示：可以使用 <code>ping</code>命令或在线工具查询网站的IP地址）</li><li>（选做）如果你有一个公网IP地址，尝试配置一个简单的Web服务器，并确保它的安全性。可以使用Nginx或Apache等常见的Web服务器软件。</li></ol>        </div>      </div>    </div>]]></content>
      
      
      <categories>
          
          <category> Xflops-HPC Start Guide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xflops </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>齿轮损伤原理初探</title>
      <link href="/_posts/%E9%BD%BF%E8%BD%AE%E6%8D%9F%E4%BC%A4%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/"/>
      <url>/_posts/%E9%BD%BF%E8%BD%AE%E6%8D%9F%E4%BC%A4%E5%8E%9F%E7%90%86%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今年暑假，我与同学组队参加挑战者杯，赛题为CS-03航发齿轮损伤智能化识别项目。作为非机械专业学生，为了更好地理解赛题和数据，我需要先了解一些齿轮损伤的基本原理，以下是我查阅了一些文献资料后对相关内容的总结。内容不够全面严谨，仅供参考。</p></blockquote><h1 id="齿轮损伤原理">齿轮损伤原理</h1><h2 id="一擦伤">一、擦伤</h2><h3 id="产生原理">产生原理</h3><ul><li>核心机制：润滑失效导致齿面金属直接接触，在高压力和相对滑动作用下，微凸体发生粘着、撕裂及材料转移。</li><li>影响因素：<ul><li>润滑条件：油膜厚度不足（如高速重载时润滑油粘度低、油量不足）。</li><li>材料与表面：表面粗糙度过高、材料硬度低，易发生塑性变形。</li><li>工况：接触压力超过材料屈服强度，滑动速度与载荷特性加剧摩擦。</li></ul></li></ul><h3 id="形貌特点">形貌特点</h3><ul><li>齿面呈现<strong>沿滑动方向的粗糙划痕或撕裂痕迹</strong>，宽度和深度不一，严重时可见材料转移或堆积。</li><li>显微镜下观察：表面不规则起伏，有塑性变形特征及细小裂纹。</li></ul><h3 id="对剩余寿命的影响">对剩余寿命的影响</h3><ul><li>较严重</li><li>轻微擦伤：及时改善润滑可减小影响，寿命略微降低。</li><li>严重擦伤：接触应力集中加剧，加速疲劳裂纹扩展，剩余寿命大幅缩短，可能短期失效。</li></ul><h3 id="损伤叠加与竞争">损伤叠加与竞争</h3><ul><li>叠加：与剥落、点蚀叠加时，擦伤形成的损伤区易成为裂纹萌生源，加剧材料脱落。</li><li>竞争：与磨损可能竞争——若磨损去除表面损伤层，可能抑制擦伤发展；反之，擦伤加剧磨损。</li></ul><h2 id="二剥落">二、剥落</h2><h3 id="产生原理-1">产生原理</h3><ul><li>核心机制：齿面在接触应力反复作用下，次表层萌生疲劳裂纹并扩展，最终导致材料脱落。</li><li>影响因素：<ul><li>材料缺陷：渗碳层质量不佳（残余应力、碳化物分布不均）、夹杂物。</li><li>工况：过载、疲劳、装配误差导致接触应力分布不均，润滑不良加剧应力集中。</li></ul></li></ul><h3 id="形貌特点-1">形貌特点</h3><ul><li>疲劳剥落早期特征：剥落起始位置的周围以及下方亮带区可见明显鱼鳞状排布的微裂纹。</li><li>分布位置：所有的轮齿在工作面靠近齿根位置均存在一条白色亮带，剥落损伤基本发生在齿根亮带附近。</li><li>宏观特点：材料呈片状大片剥落，形状呈三角形、椭圆形或不规则形状；齿面出现<strong>不规则片状或块状凹坑，边缘陡峭</strong>，坑底有疲劳条纹，宏观上可能沿应力方向分布。</li><li>微观特点：坑底和边缘有塑性变形、疲劳裂纹，可见夹杂物等缺陷。</li></ul><h3 id="严重程度评估">严重程度评估</h3><ul><li>亮带区可见许多沿齿长方向的鱼鳞状的微裂纹，斜向基体内部扩展，为剥落的早期形貌。剥落起始区周围的齿面也呈现更为严重的鱼鳞状损伤，严重的已经发展为小的剥落凹坑。</li></ul><h3 id="对剩余寿命的影响-1">对剩余寿命的影响</h3><ul><li><strong>剥落会显着降低疲劳寿命（最严重！）</strong></li><li>轻度剥落：承载面积减小，寿命显著降低。</li><li>严重剥落：可能引发断齿，剩余寿命几乎为零。</li></ul><h3 id="损伤叠加与竞争-1">损伤叠加与竞争</h3><ul><li>叠加：与擦伤、点蚀叠加时，剥落坑加剧应力集中，会加剧其他损伤扩展，如擦伤因表面完整性破坏而加重。</li><li>竞争：与磨损可能竞争——若磨损快速去除剥落边缘，可能延缓裂纹扩展；反之，剥落主导损伤进程。</li></ul><h2 id="三点蚀">三、点蚀</h2><h3 id="产生原理-2">产生原理</h3><ul><li>核心机制：齿面周期性接触应力超过疲劳极限，表层/次表层萌生微裂纹，润滑油渗入后在压力下促使裂纹扩展，微小的齿轮材料剥落，最终形成麻点凹坑。</li><li>影响因素：<ul><li>接触应力：节线附近滑动速度低、油膜薄，应力集中易引发点蚀。齿轮的几何特性也会产生不可忽略的影响。</li><li>材料特性：硬度不足、韧性差或内部缺陷（如夹杂物）加速裂纹萌生。</li><li>化学反应：渗入的润滑剂与齿轮发生化学反应，随后可能产生应力腐蚀开裂、蚀刻或反应层等：抗磨损（AW）和极压（EP）添加剂可能促进微点蚀。</li></ul></li></ul><h3 id="形貌特点-2">形貌特点</h3><ul><li>一般发生在靠近节线的齿根面处</li><li>点蚀可以分为微点蚀和宏观点蚀，这里的定义比较模糊，<strong>目前看来本次比赛中的“点蚀”指的是微点蚀</strong>，而宏观点蚀对应的是剥落。后续讨论“点蚀”均指的是微点蚀。</li><li>齿面分布大小不一的<strong>麻点状凹坑</strong>，初期直径几微米到几十微米，后期可相互连接，节线附近及齿根区域更密集。</li><li>凹坑分布的区域尺寸沿齿形的深度和宽度不超过数十微米，而其沿轴向的长度通常可达上百微米。</li><li>凹坑形状近似圆形/椭圆形，边缘整齐，坑底平滑。</li></ul><p><img src="https://notes.sjtu.edu.cn/uploads/upload_06696cb71e9f06fb98a09c59d0bbcb04.png" srcset="/img/loading/loading3.gif" lazyload><img src="https://notes.sjtu.edu.cn/uploads/upload_7e6e477b0e76a9b7f87ac495519f9b44.png" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="对剩余寿命的影响-2">对剩余寿命的影响</h3><ul><li>初期影响较小，一旦放任导致加剧后则较为严重。</li><li>初期点蚀：寿命降低约20%~50%，及时处理可延缓恶化。</li><li>严重点蚀：有效承载面积大幅减小，寿命可能仅为正常的20%以下，最终因疲劳失效报废。</li></ul><h3 id="损伤叠加与竞争-2">损伤叠加与竞争</h3><ul><li>叠加：与擦伤叠加时，擦伤加剧齿面粗糙，促进点蚀裂纹萌生；与剥落叠加时，点蚀坑成为剥落裂纹源。</li><li>竞争：与磨损可能竞争——良好润滑下点蚀主导，润滑恶化时磨损加剧可能抑制点蚀（磨损去除表面微裂纹）。</li></ul><h2 id="四磨损">四、磨损</h2><blockquote><p>定义比较模糊</p></blockquote><h3 id="产生原理-3">产生原理</h3><ul><li>磨粒磨损：硬质颗粒（如灰尘、金属屑）进入齿面，刮削材料导致损失。</li><li>粘着磨损：润滑不良时齿面直接接触，金属粘着后撕裂，导致材料转移。→<strong>擦伤</strong></li><li>腐蚀磨损：润滑油含腐蚀性物质或环境潮湿，齿面发生化学/电化学反应，产物脱落加剧磨损。</li></ul><h3 id="形貌特点-3">形貌特点</h3><ul><li>磨损的特点是接触齿轮齿表面的滑动和滚动运动导致材料逐渐损失，在齿轮系统的整个使用寿命期间不断改变齿形。</li><li>当齿轮齿出现裂纹时，每颗齿轮齿的磨损量会发生变化，随着与裂纹齿的距离而逐渐减少。连续相邻磨损齿的退化过程是一致的。</li><li>磨粒磨损：齿面有沿滑动方向的细密划痕，表面粗糙如砂纸打磨，严重时齿廓变形。</li><li>粘着磨损：齿面出现不规则粘着痕迹（材料转移堆积），撕裂处有裂纹和剥落。</li><li>腐蚀磨损：齿面有锈斑、氧化物，表面粗糙暗淡，后期出现腐蚀坑。</li></ul><p><img src="https://notes.sjtu.edu.cn/uploads/upload_d126d7584558e5b5a0cc774622bf646f.png" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="对剩余寿命的影响-3">对剩余寿命的影响</h3><ul><li>轻度磨损：维护后寿命影响有限。</li><li>严重磨损：齿厚减薄、啮合精度下降，加速疲劳裂纹和剥落，剩余寿命大幅缩短，可能因强度不足断齿。</li></ul><h3 id="损伤叠加与竞争-3">损伤叠加与竞争</h3><ul><li>叠加：与擦伤、点蚀叠加时，磨损导致齿面粗糙，润滑失效加剧擦伤，应力集中促进点蚀。</li><li>竞争：与点蚀竞争——磨损快速去除表面缺陷时抑制点蚀，反之点蚀主导。</li></ul><h2 id="五压伤">五、压伤</h2><h3 id="产生原理-4">产生原理</h3><ul><li>核心机制：外来硬质物体（如金属碎片、砂石）嵌入齿面或被碾压，导致局部塑性变形或凹坑。</li><li>影响因素：异物进入啮合区、冲击载荷过大、接触应力异常，使齿面材料塑性流动。</li></ul><h3 id="形貌特点-4">形貌特点</h3><ul><li>齿面出现局部凹坑或变形区域，形状与压入物相关，边缘圆滑，周围材料塑性隆起，压伤区硬度降低。</li></ul><p><img src="https://notes.sjtu.edu.cn/uploads/upload_8bfaf7dbb66f1569283db7fbe890ce66.png" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="对剩余寿命的影响-4">对剩余寿命的影响</h3><ul><li>轻度压伤：若不发展，影响较小，但可能成为疲劳裂纹源。</li><li>严重压伤：局部承载能力下降，引发剥落或裂纹，剩余寿命缩短，可能立即失效。</li></ul><h1 id="损伤形貌">损伤形貌</h1><h2 id="identification-of-gear-wear-damage-using-topography-analysis">Identificationof gear wear damage using topography analysis</h2><ul><li>The skewness (Ssk) parameter is suitable to quantify the shape ofthe asperity distribution;</li><li>The root mean square height (Sq) parameter is suitable to quantifythe severity of damage;</li><li>A new roughness parameter was proposed: surface motion orientation(Smo);</li><li>The Smo parameter is suitable to quantify the surface textureorientation with respect to the motion direction;</li><li>The Ssk and Smo parameters were used to distinguish between failuremodes originating from the adhesive wear (scuffing) to those triggeredby the contact fatigue wear mechanism (micropitting, macropitting andspalling)</li></ul><blockquote><ul><li>偏度 （Ssk） 参数适用于量化凹凸度分布的形状;</li><li>均方根高度 （Sq） 参数适用于量化损坏的严重程度;</li><li>提出了一个新的粗糙度参数：表面运动方向 （Smo）;</li><li>Smo 参数适用于量化表面纹理相对于运动方向的方向;</li><li>Ssk 和 Smo参数用于区分源自粘着磨损（划伤）的失效模式和由接触疲劳磨损机制触发的失效模式（微点蚀、宏点蚀和剥落）</li></ul></blockquote><p>表面纹理相对于运动方向的方向已被证明是区分粘着磨损 （scu）和疲劳失效（mpt、pit、spa）的合适特征。 <img src="https://notes.sjtu.edu.cn/uploads/upload_04752a2eebabfe0c5d99dc81061eada8.png" srcset="/img/loading/loading3.gif" lazyload><img src="https://notes.sjtu.edu.cn/uploads/upload_1d7597a4f7297bd800ebada349653aa9.png" srcset="/img/loading/loading3.gif" lazyload><img src="https://notes.sjtu.edu.cn/uploads/upload_fec1a2cdd61c78083e16314e745cfb3c.png" srcset="/img/loading/loading3.gif" lazyload></p><h1 id="参考文献">参考文献</h1><ol type="1"><li>Liu H, Liu H, Zhu C, et al.&nbsp;A Review on Micropitting Studies ofSteel Gears[J]. Coatings, 2019, 9(1): 42.</li><li>Chen T, Zhu C, Chen J, et al.&nbsp;A review on gear scuffing studies:Theories, experiments and design[J]. Tribology International, 2024, 196:109741.</li><li>Gao X, Lei Y, Yang X, et al.&nbsp;Dynamic interactions of surface wearand tooth crack in gear transmission systems: An investigation ofprogressive-degradation mechanisms[J]. Wear, 2025, 571: 205861.</li><li>Cohen R, Bachar L, Matania O, et al.&nbsp;Few-shot learning forestimating gear wear severity towards digital twinning[J]. EngineeringFailure Analysis, 2025, 170: 109330.</li><li>Vijayraghavan P. Gear Failures, Reasons and Preventions[J].</li><li>Poleto J C, Fernandes C M C G, Barros L Y, et al.&nbsp;Identification ofgear wear damage using topography analysis[J]. Wear, 2023, 522:204837.</li><li>Kundu P, Darpe A K, Kulkarni M S, et al.&nbsp;Online damage severitylevel classification in gears under natural damage progression[J]. TheInternational Journal of Advanced Manufacturing Technology, 2023, 124:1-20.</li><li>Ma R, Chen Y, Cao Q. Research on dynamics and fault mechanism ofspur gear pair with spalling defect[J]. Journal of Sound and Vibration,2012, 331: 2097-2109.</li><li>刘怀举,张博宇,朱才朝,等.齿轮接触疲劳理论研究进展[J].机械工程学报,2022,58(3):1-13.</li><li>赵海洋.航空发动机减速器齿轮齿面剥落故障分析[J].机械研究与应用,2024,37(1):55-59.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 齿轮损伤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-2 信息安全意识【Xflops-HPC Start Guide】</title>
      <link href="/_posts/1-2-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%84%8F%E8%AF%86%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/"/>
      <url>/_posts/1-2-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%84%8F%E8%AF%86%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/</url>
      
        <content type="html"><![CDATA[<div class="note note-info">            <p>新学期即将来临，Xflops超算队招新以及HelloHPC超算校内赛正在火热筹备中。作为Xflops超算队的一员，我与其他成员将共同负责<a href="https://xflops.sjtu.edu.cn/hpc-start-guide">HPC入门指南</a>的修订与编写。Xflops超算队的HPC入门指南系列文章旨在帮助新成员快速入门和了解HPC知识，为校内赛的参赛者提供必要的知识储备和技能指导。</p>          </div><p><a href="https://xflops.sjtu.edu.cn/hpc-start-guide" name="/img/cover/xflops.webp" target="_blank" class="LinkCard">HPC入门指南</a></p><h1 id="信息安全意识">信息安全意识</h1><p>在使用互联网时，信息安全意识至关重要，因为网络攻击，数据泄露和隐私侵害随时可能发生。为了保护个人信息和数据安全，以下是一些基本的安全意识和实践建议：</p><ol type="1"><li><strong>使用强密码</strong>：<ul><li>密码应包含大写字母、小写字母、数字和特殊字符，长度至少12位。</li><li>不要使用容易猜测的密码，如生日、姓名等，推荐使用随机生成的强密码。</li><li>对于随机生成的强密码，推荐使用密码管理器进行生成与管理，如<a href="https://keepassxc.org/">KeePassXC</a>或<a href="https://bitwarden.com/">Bitwarden</a>等</li><li>定期更换密码，并避免在多个账户上使用相同的密码。</li></ul></li></ol>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6c1e277b" role="button" aria-expanded="false" aria-controls="collapse-6c1e277b">        <div class="fold-arrow">▶</div>熵：密码强度的定量衡量      </div>      <div class="fold-collapse collapse" id="collapse-6c1e277b">        <div class="fold-content">          <p>密码并非长度越长越安全，例如密码<code>123456</code>明显比<code>ejn4</code>更容易被破解。通常我们使用”熵”来定量衡量密码的复杂性。“熵”越大则代表密码越难被破解。这里的熵计算标准并不统一，因为其需要同时考虑弱密码字典与密码本身的字符串组合等因素。常见的密码管理器中均内置有熵的计算功能，一般来说，<strong>强度超过40bit的密码可以抵抗在线攻击，强度超过80bit的密码足以抵抗离线攻击</strong>。</p>        </div>      </div>    </div><ol start="2" type="1"><li><strong>启用双因素认证(2FA)</strong>：<ul><li>在支持的服务上启用双因素认证，增加账户安全性，如Github、Google等。</li></ul></li><li><strong>注意钓鱼攻击</strong>：<ul><li>不要轻易点击不明链接或下载未知附件。</li><li>验证发件人身份，尤其是涉及敏感信息或财务交易时。</li><li>在交大，如果收到不以“<span class="citation" data-cites="sjtu.edu.cn">@sjtu.edu.cn</span>”结尾的邮件，内容是“财务报表”、“奖学金异常”、“账户异常”等的邮件，请务必不要点击链接或下载附件（哪怕是以“<span class="citation" data-cites="sjtu.edu.cn">@sjtu.edu.cn</span>”结尾的邮件也要谨慎对待），“你也不想让这些数字因你而归零吧”.jpg</li></ul></li><li><strong>妥善保管Jaccount账号与密码</strong>：<ul><li>对于交大学生，Jaccount账号是你在校期间的最重要的身份标识，务必妥善保管。</li><li>不要将Jaccount账号和密码告诉他人，尤其是陌生人。</li><li>如果怀疑账号被盗，请立即修改密码并联系学校信息中心。</li></ul></li><li><strong>定期备份数据</strong>：<ul><li>定期备份重要数据到外部存储设备或云存储服务</li></ul></li><li><strong>使用安全的网络连接</strong>：<ul><li>避免在公共Wi-Fi网络上进行敏感操作，如网上银行或购物。</li><li>不要连接不明的Wi-Fi热点，尤其是没有密码保护的网络。</li></ul></li><li><strong>保持软件更新</strong>：<ul><li>定期更新操作系统、应用程序和防病毒软件，以修补已知的安全漏洞。</li><li>启用自动更新功能，确保软件始终处于最新状态。</li></ul></li><li><strong>警惕不明U盘</strong>：<ul><li>不要随意插入不明来源的U盘或其他外部存储设备，这可能会导致恶意软件感染。</li></ul></li><li><strong>了解隐私设置</strong>：<ul><li>在社交媒体和在线服务中，了解并调整隐私设置，控制个人信息的公开程度。</li><li>定期检查应用权限，确保只授予必要的权限。</li></ul></li></ol><p>实际上，信息安全意识远远不是三言两语能说清楚的，其养成需要长期的学习和实践。以下是一些推荐的资源和文章，帮助你更深入地了解信息安全和隐私保护。</p><ul><li><a href="https://www.bilibili.com/video/BV17p4y1Y7BB?vd_source=a03ab5db01c2fd1c452104c1fa0d9326">如何安全上网避免隐私泄露</a></li><li><a href="https://www.zhihu.com/question/398551131">知乎：如何在互联网上尽可能的保护自己的隐私</a></li><li><a href="https://www.thepaper.cn/newsDetail_forward_30838925">从“我”开始的安全指南</a></li><li><a href="https://github.com/BushidoUK/Operational-Security-101">上网和设备安全的建议</a>，适于对安全有较高追求的读者</li><li><a href="https://www.bilibili.com/video/BV1yA4y1U77y">数据管理的建议</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Xflops-HPC Start Guide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xflops </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-1 如何高效获取信息【Xflops-HPC Start Guide】</title>
      <link href="/_posts/1-1-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/"/>
      <url>/_posts/1-1-%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF%E3%80%90Xflops-HPC%20Start%20Guide%E3%80%91/</url>
      
        <content type="html"><![CDATA[<div class="note note-info">            <p>新学期即将来临，Xflops超算队招新以及HelloHPC超算校内赛正在火热筹备中。作为Xflops超算队的一员，我与其他成员将共同负责<a href="https://xflops.sjtu.edu.cn/hpc-start-guide">HPC入门指南</a>的修订与编写。Xflops超算队的HPC入门指南系列文章旨在帮助新成员快速入门和了解HPC知识，为校内赛的参赛者提供必要的知识储备和技能指导。本文是该系列的第一篇，对往年版本进行了更新与修订，主要介绍信息素养的重要性以及如何有效获取和使用信息。</p>          </div><p><a href="https://xflops.sjtu.edu.cn/hpc-start-guide" name="/img/cover/xflops.webp" target="_blank" class="LinkCard">HPC入门指南</a></p><h1 id="如何高效获取信息">如何高效获取信息</h1><h2 id="信息素养是什么">信息素养是什么</h2><p>信息素养（InformationLiteracy）是指个体在信息社会中所具备的获取、评估、组织、利用和创造信息的综合能力，它是数字化时代每个人不可或缺的核心素养之一，其内涵不仅包括对信息工具和技术的操作能力，更强调对信息的批判性思维和伦理意识。然而，由于我国教育的局限性，绝大部分的高中生长期处于与外部社会相对隔绝的信息环境，在信息素养方面的认知和实践都相对薄弱，对于如何正确的获取和使用信息缺乏认知和经验。本文假设读者初次使用互联网，旨在提供一些具体指导，帮助读者高效获取信息并做出明智的判断。<img src="https://notes.sjtu.edu.cn/uploads/upload_26ba10c16291e180b4115220f6045a08.png" srcset="/img/loading/loading3.gif" lazyload alt="chatgpt:信息素养是什么"> <img src="https://notes.sjtu.edu.cn/uploads/upload_fe88bd386dcc86bf3cdc4535498157db.jpg" srcset="/img/loading/loading3.gif" lazyload alt="chatgpt:信息素养的tips"></p><h3 id="信息从哪来">信息从哪来?</h3><p>按照信息密度从高到低，可以将今天互联网的第一手信息来源大致分为以下几类：</p><ol type="1"><li>高密度：学术文献和数据库，政府和专业机构发表物，行业报告和白皮书，课程和书籍</li><li>中密度：专业新闻媒体，百科，博客和个人网站，技术文档</li><li>低密度：社交媒体，问答平台，(短)视频平台，即时通讯应用</li></ol><p>高密度信源通常意味着较高的阅读门槛和时间投入，适合深入理解特定领域的内容；相反，低密度信源则门槛较低，更适合获取快速和浅显的信息。</p><p>作出这些区分的目的并不是希望塑造一种信息的等级制，而是希望明确，当大家对于信息有不同程度的需求时，应该从何处下手。</p><p>例如：</p><ul><li>如果你希望实时跟进某个领域的最新进程，而不需要对它有深入的理解，可以考虑关注特定的自媒体/公众号/前沿推送。</li><li>如果需要快速解决某个技术问题(bug报错，编程工具快速入门)，则博客和技术文档是最佳的选择。</li><li>如果希望对某个具体问题有深入透彻的理解，才需要深入挖掘文献和书籍。</li></ul><h3 id="信息的门户">信息的门户</h3><p>正如ChatGPT所说，信息的获取始于需求。当你意识到自己需要某方面的信息以解决问题时，便需要某种媒介，从海量信息中筛选出有用的部分。</p><p>下面三个章节将介绍三种形式的媒介：向他人求助，搜索引擎，AI大语言模型。</p><p>推荐阅读:</p><ul><li><a href="https://survivesjtu.gitbook.io/survivesjtumanual/li-zhi-pian/ren-shi-xin-xi-su-yang">交大生存手册：认识信息素养</a></li><li><a href="https://rainchan.win/SurfingTutorial/">给新大学生的网上冲浪指南</a></li><li><a href="https://ac-wiki.org/">大学生的百科全书</a></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-2374797c" role="button" aria-expanded="false" aria-controls="collapse-2374797c">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-2374797c">        <div class="fold-content">          <ol type="1"><li>尝试梳理你对信息的需求，以及你日常生活中摄取新信息的途径和内容。</li><li>了解’信息茧房’和’推荐算法’的概念和关联，试作思考和评论。</li><li>(选做)选取一个对你来说陌生但是感兴趣的概念，尝试在两个小时内获得尽可能全面深入的理解。可以从基本原理，应用场景，发展脉络，未来方向等方面入手。<ul><li>参考词：深度学习，函数式编程，风险投资，量子计算，GPU，排队论···</li></ul></li></ol>        </div>      </div>    </div><h2 id="如何向他人求助">如何向他人求助</h2><p>当你无法通过自助手段解决问题时，向他人求助是一个好选择。使用合适的方式提问可以节省各方的时间并且提高解决问题的可能性。以下是有效提问的关键要素：</p><ol type="1"><li>没有笨的问题：任何问题都有被提出的价值，把问题憋在心里只是阻碍自己的进步。</li><li>描述清晰：清楚地描述你的问题背景，你尝试过的解决方法和你当前的困惑。问题要具体，避免笼统或含糊不清的描述。</li><li>选择合适的被提问方：在多数情况下，他人没有义务或能力解答你。</li><li>尊重他人时间：理解他人可能有自己的工作安排，礼貌提问，耐心等待回复。</li></ol><div class="note note-warning">            <p>这里单列一节的原因是网络社区中通常充斥着不少低质量的求助提问，这在拉低讨论质量的同时引起社区的普遍反感。<strong>请务必在提问前充分理解这一节的精神。</strong></p>          </div><p>推荐阅读:</p><ul><li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">提问的智慧</a><strong>(强烈推荐)</strong></li><li><a href="https://github.com/tangx/Stop-Ask-Questions-The-Stupid-Ways">别像弱智一样提问</a></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-da1680c0" role="button" aria-expanded="false" aria-controls="collapse-da1680c0">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-da1680c0">        <div class="fold-content">          <ol type="1"><li>回忆你上一次编程/学习时遇到的困难，尝试写出一个清晰的问题描述。<ul><li>包括问题背景，尝试过的解决方法，当前的困惑等。</li><li>如果你不确定问题是否清晰，可以请教身边的人。</li></ul></li><li>阅读以下提问示例，并指出其中的优缺点。<ul><li>示例1：“我在使用C++ vector时遇到了问题. 它没有正常工作.有人能帮我吗？”</li><li>示例2：“我正在进行一个C++项目，并使用标准模板库中的vector类。我尝试使用at()方法访问元素，但一直得到out_of_range异常。以下是我的代码片段：<a href="https://pastebin.com/6NpwHfMv">pastebin链接</a>”</li></ul></li></ol>        </div>      </div>    </div><h2 id="如何使用搜索引擎">如何使用搜索引擎</h2><p>以下是一些通常的步骤和技巧，有助于使用搜索引擎。</p><ol type="1"><li>使用正确的语言搜索<ul><li>技术性内容建议使用英文关键词。</li><li>只有涉及中文世界独有内容时建议使用中文搜索。</li></ul></li><li>选择合适的搜索引擎：<ul><li>建议使用 Google，Bing。<ul><li>注意区分浏览器与搜索引擎的区别。</li></ul></li><li>由于国内存在APP信息孤岛，部分信息也建议在B站，小红书，知乎等网站内直接搜索。</li></ul></li><li>输入关键词：<ul><li>尽量使用简洁且具体的关键词，</li><li>避免输入太笼统或太长的句子。</li><li>使用<a href="https://support.google.com/websearch/answer/35890">高级搜索</a></li></ul></li><li>评估搜索结果：<ul><li>检查网站来源，不同的网站有不同的可信度和内容倾向。<ul><li>百科推荐使用<a href="http://en.wikipedia.org">英文维基</a></li><li>编程问答社区：推荐Stackoverflow，不推荐CSDN</li></ul></li><li><a href="https://zhuanlan.zhihu.com/p/570534448">信息甄别的建议</a></li></ul></li></ol><h2 id="ai的使用">AI的使用</h2><p>近年来，人工智能领域蓬勃发展，AI大语言模型已深度融入我们生活的方方面面。简单来讲，大语言模型通过对海量文本数据的学习训练，具备理解和生成类人自然语言的能力。这类模型可与人类对话交流、答疑解惑、提供建议，甚至进行内容创作。当下，围绕大语言模型（LLM）的应用丰富多样，下面为大家作初步介绍，助您快速入门。</p><h3 id="基础大模型">基础大模型</h3><p>基础大模型分为闭源和开源两种类型，通常每家公司都有部分模型开源，部分模型闭源。</p><ul><li>闭源模型，用户只能借助平台提供的接口访问，无法知晓模型的全部细节。</li><li>开源模型则是指模型的权重和架构完全公开。使用这类模型，既可以通过公开的AI聊天平台，也能在自己的计算设备上进行部署，还可通过模型构建方提供的界面（若有）来操作。</li></ul><p>不同模型在语言能力、推理能力、知识储备丰富度、编程能力等方面存在差异。您可以多进行尝试以找到最适合您的模型，同时可参考<a href="https://huggingface.co/spaces/lmsys/chatbot-arena-leaderboard">AI排行榜</a>。</p><p>但是，AI的回答并非绝对正确的！在使用AI的过程中，请务必注意大模型的回答中是否存在错误，务必对结果加以检验。</p><p>尽管大模型功能强大，但要想获得高质量回答，需掌握合适的提问方式。通过精心调整提问语句（prompt，提示词）来优化大模型回答的技术，被称为提示工程（promptengineering）。若大模型的回答不尽人意，不妨深入了解相关内容。</p><h3 id="大模型平台">大模型平台</h3><p>大模型平台是指提供大语言模型服务的在线平台，用户可以通过这些平台访问和使用各种大语言模型。平台通常提供了友好的用户界面，方便用户与模型进行交互。下面给出一些常见的大模型平台：</p><h4 id="国外平台">国外平台</h4><ul><li><strong><a href="https://chatgpt.com/">ChatGPT</a></strong>：OpenAI公司的ChatGPT，在自然语言处理领域表现卓越，具有出色的对话理解与生成能力。</li><li><strong><a href="https://gemini.google.com/app">Gemini</a></strong>：GoogleGemini，谷歌推出的大语言模型，在语义理解、知识应用等方面展现出强大实力。</li><li><strong><a href="https://claude.ai/">Claude</a></strong>：Anthropic公司的ClaudeAI，在多轮对话、复杂任务处理方面有良好表现。</li><li><strong><a href="https://llama.meta.com/">Llama</a></strong>：Meta公司的llama模型，开源且性能优秀，为众多开发者提供了模型基础。</li><li><strong><a href="https://huggingface.co/">HuggingFace</a></strong>：HuggingFace，全球最大的AI开源社区，汇聚了丰富的模型资源与开发工具。</li><li><strong><a href="https://ollama.com/">Ollama</a></strong>：ollama，可用于在本地部署开源大模型的框架，方便用户在自有环境中使用模型。</li></ul><h4 id="国内平台">国内平台</h4><ul><li><strong><a href="https://www.deepseek.com/">DeepSeek</a></strong>：DeepSeek，在多模态融合、专业领域知识问答上具备优势。</li><li><strong><a href="https://www.doubao.com/">豆包</a></strong>：字节跳动的豆包智能体平台，功能丰富，能满足多种场景下的交互需求。</li><li><strong><a href="https://kimi.moonshot.cn/">Kimi</a></strong>：月之暗面Kimi Chat，具有独特的交互设计与个性化服务能力。</li><li><strong><a href="https://tongyi.aliyun.com/">通义千问</a></strong>：阿里巴巴的通义千问，在电商、办公等领域能提供贴合实际需求的服务。</li><li><strong><a href="https://chatglm.cn/">智谱ChatGLM</a></strong>：智谱ChatGLM，在中文语言理解与生成上进行了针对性优化。</li><li><strong><a href="https://yiyan.baidu.com/">文心一言</a></strong>：百度的文心一言，整合百度丰富的知识图谱与数据资源，为用户提供全面服务。</li></ul><h4 id="校内平台">校内平台</h4><ul><li><strong><a href="https://chat.sjtu.edu.cn/">DeepSeek本地版</a></strong>：由Xflops超算队协助上海交通大学网络信息中心部署的本地DeepSeek模型，支持DeepSeek、QWen等模型，可以在DeepSeek官方平台“服务器繁忙”时解决你的燃眉之急。</li><li><strong><a href="https://my.sjtu.edu.cn/ai/ui/worktable">AI应用平台</a></strong>：上海交通大学的AI应用平台，集成了多种AI工具与服务。</li></ul><h3 id="ai应用">AI应用</h3><p>这里我们将大致列举各类基于大模型构建的AI应用，重点关注能助力日常工作与生活的应用。上文提到的大模型平台也自带一些实用工具，大家可自行探索。</p><h4 id="ai编程助手">AI编程助手</h4><ul><li><strong><a href="https://github.com/features/copilot">GithubCopilot</a></strong> ：GithubCopilot，学生可免费使用，强烈推荐。它能在编程过程中实时提供代码建议，大幅提升编程效率。</li></ul><h4 id="ai搜索">AI搜索</h4><ul><li><strong><a href="https://metaso.cn/">秘塔AI搜索</a></strong>：秘塔AI搜索，在知识检索、信息汇总方面表现出色。</li><li><strong><a href="https://devv.ai/zh">devv</a></strong>：面向程序员的AI搜索，专注于编程相关知识的快速查找与解答。</li></ul><h4 id="ai智能体">AI智能体</h4><ul><li><strong><a href="https://poe.com/">Poe</a></strong>：AI聊天平台，集成了众多开源与闭源模型及智能体，用户可按需选择使用。</li></ul><h4 id="ai生成">AI生成</h4><ul><li><strong><a href="https://zhiwen.xfyun.cn/">讯飞智文</a></strong>：讯飞智文，可生成PPT</li><li><strong><a href="https://suno.com/">Suno AI</a></strong> ：SunoAI，可用于音频生成与处理。</li></ul><h4 id="mcp服务">MCP服务</h4><ul><li><strong><a href="https://bailian.console.aliyun.com/">阿里云百炼</a></strong>：阿里云百炼，全链路大模型服务与应用开发平台。</li><li><strong><a href="https://modelscope.cn/home">魔搭社区</a></strong>：魔搭社区，开源模型社区，提供丰富的AI模型与工具，支持多种应用场景。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-ba639f03" role="button" aria-expanded="false" aria-controls="collapse-ba639f03">        <div class="fold-arrow">▶</div>练习      </div>      <div class="fold-collapse collapse" id="collapse-ba639f03">        <div class="fold-content">          <ol type="1"><li>试用2~3款大模型。</li><li>向大模型或者聊天智能体提问农夫过河问题，如“一个农夫需要将狼、羊、狐狸、鸡和米五种物品运送过河，每次只能带两件，且狼和羊/狐狸和鸡/鸡和米不能单独相处，每次运送时农夫必须在船上，最少需要过河几次？”，测试模型的推理能力。</li><li>分别通过搜索和向AI提问，了解思维链(Chain-of-Thought)，RAG(RetrievalAugmentedGeneration)，多模态(Multimodal)等大模型相关概念，对比两类信息获取方法的优劣，对比使用中英文提问的差异。</li><li>(选做)让AI使用你熟悉的编程语言编写程序，在仅通过调整prompt，不手动修改AI输出的代码的条件下，让AI生成可以完美运行的程序。例如：用C++编写2048游戏。</li><li>(选做)让AI回答入门文档中其他章节的练习题。</li></ol>        </div>      </div>    </div>]]></content>
      
      
      <categories>
          
          <category> Xflops-HPC Start Guide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xflops </tag>
            
            <tag> HPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fluid页脚美化</title>
      <link href="/_posts/Fluid%E9%A1%B5%E8%84%9A%E7%BE%8E%E5%8C%96/"/>
      <url>/_posts/Fluid%E9%A1%B5%E8%84%9A%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本期美化同样贯彻了上期美化的原则：<strong>无侵入式美化</strong>，即不修改主题的源代码，只通过修改配置文件、自定义样式以及Hexo注入器来实现美化。上一期的美化包括以下内容，可以点击下方的链接卡片查看。</p><div class="note note-secondary">            <ul><li>黑暗模式下修改加粗字体和斜体样式</li><li>博客标题霓虹灯效样式</li><li>标题颜色渐变样式</li><li>修改滚动条样式</li><li>使用 Mac 风格代码块样式</li><li>修改行内代码样式</li><li>文章界面背景毛玻璃样式</li><li>链接卡片样式</li><li>统一文章图片宽度</li><li>首页文章滑入动效</li><li>首页文章图片悬浮鼠标悬停动效</li><li>彩虹加载动效</li><li>背景动态线条动效</li><li>标签页根据焦点切换显示</li></ul>          </div><p><a href="/_posts/Fluid主题美化1-0/" name="/img/avatar/avatar.webp" class="LinkCard">Fluid主题美化1.0</a></p><h1 id="关于页添加-github-热力图">关于页添加 Github 热力图</h1><p>这个功能的实现比较简单，可以直接调用Github ChartAPI来实现。项目地址见下方。</p><p><a href="https://github.com/2016rshah/githubchart-api" name="https://avatars.githubusercontent.com/u/6821244?v=4" class="LinkCard">GithubChart API</a></p><p>只需要在 <code>source/about/index.md</code>文件中添加一行代码即可在关于页添加Github热力图：</p><figure class="shiki html"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">img</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">src</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"https://ghchart.rshah.org/0d6aae/用户名"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">alt</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"图表名"</span><span style="color: #ABB2BF"> /&gt;</span></span></code></pre></div></div></figure><p>其中 <code>用户名</code> 替换为你的GitHub用户名，<code>图表名</code>替换为你想要的图表名称（可以是任意字符串），<code>0d6aae</code>替换为你想要的颜色代码（可以在<a href="https://www.w3schools.com/colors/colors_picker.asp">这里</a>选择颜色），如果使用默认颜色则可以省略。</p><h1 id="文章页添加-giscus-评论区">文章页添加 Giscus 评论区</h1><p>Fluid主题多种评论区的支持，我选择了其中基于GitHubDiscussion的评论系统的Giscus插件，</p><p><a href="https://giscus.app/" name="https://avatars.githubusercontent.com/in/106117" class="LinkCard">Giscus</a></p><p>具体配置步骤如下：</p><ol type="1"><li>首先需要确保博客的仓库是公开的，且安装了<a href="https://github.com/apps/giscus">Giscus的App</a>。</li><li>然后你需要在仓库中<a href="https://docs.github.com/zh/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/enabling-or-disabling-github-discussions-for-a-repository">启用GitHubDiscussions功能</a>。</li><li>接着你需要在<a href="https://giscus.app/">Giscus的配置页面</a>中获取相关参数。<ul><li><strong>注意</strong>：<code>repo</code>字段需要填写你的GitHub仓库地址，格式为<code>用户名/仓库名</code>，而不包含域名部分。</li></ul></li><li>此外你还需要在 <code>_config.fluid.yml</code>文件中开启文章页的评论区服务，并选择Giscus；然后再在下方的<code>giscus</code> 配置中填写上一步获取到的相关参数。</li></ol><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">post</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">comments</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">enable</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">true</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">type</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">giscus</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># Giscus</span></span><span class="line"><span style="color: #E06C75">giscus</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">repo</span><span style="color: #ABB2BF">: [</span><span style="color: #98C379">用户名/仓库名</span><span style="color: #ABB2BF">]</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">repo-id</span><span style="color: #ABB2BF">: [</span><span style="color: #98C379">仓库ID</span><span style="color: #ABB2BF">]</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">category</span><span style="color: #ABB2BF">: [</span><span style="color: #98C379">分类名</span><span style="color: #ABB2BF">]</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">category-id</span><span style="color: #ABB2BF">: [</span><span style="color: #98C379">分类ID</span><span style="color: #ABB2BF">]</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">theme-light</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">light</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">theme-dark</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">dark</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">mapping</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">pathname</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">reactions-enabled</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">emit-metadata</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">0</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">input-position</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">top</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">lang</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">zh-CN</span></span></code></pre></div></div></figure><h1 id="页脚处添加网站运行时间">页脚处添加网站运行时间</h1><p>这个功能比较常见，能在许多博客都搜索到相关的教程，这里我参考官方博客HexoTheme Fluid的实现方式，并进行了一定修改。</p><p><a href="https://hexo.fluid-dev.com/posts/fluid-footer-custom/" name="https://hexo.fluid-dev.com/img/avatar.png" class="LinkCard">Fluid页脚增加网站运行时长</a></p><p>首先在 <code>source/js/</code> 目录下新建一个<code>Duration.js</code>文件（如果不存在该目录则需要先创建），代码如下：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">!</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic">/** 计时起始时间，自行修改 **/</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">start</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Date</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"2025/06/19 23:36:01"</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">update</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">now</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Date</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">now</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">setTime</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">now</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getTime</span><span style="color: #ABB2BF">()</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">250</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">days</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">now</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">start</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1000</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">24</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">dnum</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">floor</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">days</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">hours</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">now</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">start</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1000</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">24</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dnum</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">hnum</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">floor</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">hours</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">String</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">hnum</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> ){</span></span><span class="line"><span style="color: #ABB2BF">      </span><span style="color: #E06C75">hnum</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"0"</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">hnum</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">minutes</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">now</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">start</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1000</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">24</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dnum</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">hnum</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">mnum</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">floor</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">minutes</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">String</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">mnum</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> ){</span></span><span class="line"><span style="color: #ABB2BF">      </span><span style="color: #E06C75">mnum</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"0"</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">mnum</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">seconds</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">now</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">start</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1000</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">24</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dnum</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">hnum</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">60</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">mnum</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">snum</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">round</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">seconds</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">String</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">snum</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> ){</span></span><span class="line"><span style="color: #ABB2BF">      </span><span style="color: #E06C75">snum</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"0"</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">snum</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"duration-container"</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`</span></span><span class="line"><span style="color: #98C379">        &amp;nbsp;须弥藏芥&amp;nbsp;已逾</span></span><span class="line"><span style="color: #98C379">        &lt;span id="time-day"&gt;</span><span style="color: #C678DD">${</span><span style="color: #E06C75">dnum</span><span style="color: #C678DD">}</span><span style="color: #98C379">&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">        日又</span></span><span class="line"><span style="color: #98C379">        &lt;span id="time-hour"&gt;</span><span style="color: #C678DD">${</span><span style="color: #E06C75">hnum</span><span style="color: #C678DD">}</span><span style="color: #98C379">&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">        时</span></span><span class="line"><span style="color: #98C379">        &lt;span id="time-minute"&gt;</span><span style="color: #C678DD">${</span><span style="color: #E06C75">mnum</span><span style="color: #C678DD">}</span><span style="color: #98C379">&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">        分</span></span><span class="line"><span style="color: #98C379">        &lt;span id="time-second"&gt;</span><span style="color: #C678DD">${</span><span style="color: #E06C75">snum</span><span style="color: #C678DD">}</span><span style="color: #98C379">&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">        秒</span></span><span class="line"><span style="color: #98C379">    `</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #61AFEF">update</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #61AFEF">setInterval</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">update</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">1000</span><span style="color: #ABB2BF">); </span></span><span class="line"><span style="color: #ABB2BF">})();</span></span></code></pre></div></div></figure><p>脚本中 <code>start</code>变量的值需要修改为你博客的创建时间，如果是部署在GitHubPages上的博客，可以在仓库的提交记录中找到创建时间。</p><p>在这之后，你还需要修改 <code>_config.fluid.yml</code> 文件，在<code>footer</code> 的 <code>content</code> 中添加以下内容：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">footer</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">content</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'</span></span><span class="line"><span style="color: #98C379">    &lt;div class="duration"&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;i class="fas fa-calendar"&gt;&lt;/i&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;span id="duration-container"&gt;人生缓缓&amp;nbsp;自有答案&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;script src="/js/Duration.js"&gt;&lt;/script&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">  '</span></span></code></pre></div></div></figure><p>当然，由于我还在页脚处做了其他的美化，因此 <code>content</code>的内容与此处展示的并不相同，你可以根据自己的需要进行调整，也可以跳转至<a href="#总结">总结</a>部分查看我的完整配置。</p><h1 id="页脚处添加全站字数统计">页脚处添加全站字数统计</h1><p>在Fluid主题中，内置了hexo-wordcount插件，可以通过配置<code>_config.fluid.yml</code>在文章的副标题下方显示该文章的字数统计。因此，要实现全站字数统计，我们只需要在页脚处添加一个显示全站字数的元素，这同样可以通过修改<code>_config.fluid.yml</code> 文件中 <code>footer</code> 的<code>content</code>字段以及Hexo注入器来实现。这部分实现参考了呈呈的小站。</p><p><a href="https://blog.fengcl.com/2022/08/21/fluid-theme/#%E5%85%A8%E7%AB%99%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1" name="https://blog.fengcl.com/uploads/ef1d0cfcf9284c00f4afb7a7d38dc6c0.png" class="LinkCard">切换到fluid主题的记录</a></p><p>修改 <code>_config.fluid.yml</code> 文件如下：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">footer</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">content</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'</span></span><span class="line"><span style="color: #98C379">    # 原有内容，下面是新加的</span></span><span class="line"><span style="color: #98C379">    &lt;div style="font-size: 0.85rem"&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;span id="g-total-word-id"&gt;Getting word count...&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">  '</span></span></code></pre></div></div></figure><p>然后需要在 <code>source/_inject/</code> 目录下新建一个<code>WordCount.ejs</code>文件（如果不存在该目录则需要先创建）来调用hexo-wordcount插件的<code>wordtotal</code>函数获取全站字数统计，一定要注意路径正确，否则在生成页面时很大概率会报错：</p><figure class="shiki html"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">type</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"text/javascript"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"g-total-word-id"</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"全站总字数 &lt;%= wordtotal(site) %&gt;"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">&lt;/</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">&gt;</span></span></code></pre></div></div></figure><p>接下来在 <code>scripts</code> 目录下新建一个 <code>injector.js</code>文件（如果不存在该目录则需要先创建，也可以复用之前的注入器代码），代码如下：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">// 全站字数统计</span></span><span class="line"><span style="color: #E5C07B">hexo</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">extend</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">filter</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">register</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'theme_inject'</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">injects</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">injects</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">bodyEnd</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">file</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'WordCount'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'source/_inject/WordCount.ejs'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">});</span></span></code></pre></div></div></figure><p>这样就可以在页脚处显示全站字数统计。</p><h1 id="页脚处添加全站文章统计">页脚处添加全站文章统计</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-e7f8b48e" role="button" aria-expanded="false" aria-controls="collapse-e7f8b48e">        <div class="fold-arrow">▶</div>此方式已弃用，改为下面的实现方式。      </div>      <div class="fold-collapse collapse" id="collapse-e7f8b48e">        <div class="fold-content">          <p>Fluid主题内置了对全站文章统计的支持，但只在归档页显示。由于我并不了解ejs语法，也不愿意修改主题的源代码，因此决定自行实现。</p><p>在 <code>source/js/</code> 目录下新建一个 <code>TotalPosts.js</code>文件（如果不存在该目录则需要先创建），代码如下：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">JSON</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">parse</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">sessionStorage</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getItem</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'posts'</span><span style="color: #ABB2BF">)) </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> [];</span></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">posts</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">fetch</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'/sitemap.xml'</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">response</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">response</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">text</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">str</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">DOMParser</span><span style="color: #ABB2BF">()).</span><span style="color: #61AFEF">parseFromString</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">str</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"text/xml"</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #ABB2BF">    .</span><span style="color: #61AFEF">then</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">entries</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelectorAll</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'url &gt; loc'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Array</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">from</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">entries</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            .</span><span style="color: #61AFEF">map</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">entry</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">entry</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            .</span><span style="color: #61AFEF">filter</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">link</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">link</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">includes</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'/_posts/'</span><span style="color: #ABB2BF">))</span></span><span class="line"><span style="color: #ABB2BF">            .</span><span style="color: #61AFEF">map</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">link</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">link</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">substring</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">link</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">indexOf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'/_posts/'</span><span style="color: #ABB2BF">)));</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">sessionStorage</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">setItem</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'posts'</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">JSON</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">stringify</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF">)); </span><span style="color: #7F848E; font-style: italic">// 保存到 sessionStorage</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">log</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'Posts updated:'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">posts</span><span style="color: #ABB2BF">); </span><span style="color: #7F848E; font-style: italic">// 调试输出更新后的链接列表</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'g-total-posts-id'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">posts</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    })</span></span><span class="line"><span style="color: #ABB2BF">    .</span><span style="color: #61AFEF">catch</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">error</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">error</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'Error fetching sitemap:'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">error</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">} </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'g-total-posts-id'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">posts</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p>然后在 <code>_config.fluid.yml</code> 文件中修改 <code>footer</code>的 <code>content</code> 字段，添加全站文章统计的调用代码：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">footer</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">content</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'</span></span><span class="line"><span style="color: #98C379">    &lt;div class="total-posts" style="font-size: 0.85rem; margin: 0.15rem 0.15rem;"&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;i class="fas fa-file-alt"&gt;&lt;/i&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;span id="g-total-posts-id"&gt;Getting total posts...&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;script src="/js/TotalPosts.js"&gt;&lt;/script&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">  '</span></span></code></pre></div></div></figure>        </div>      </div>    </div><p>在 <code>source/_inject/</code> 目录下新建一个<code>PostCount.ejs</code>文件（如果不存在该目录则需要先创建）来获取全站文章统计：</p><figure class="shiki html"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">type</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"text/javascript"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'g-total-posts-id'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #98C379">"&lt;%= site.posts.length %&gt;"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">&lt;/</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">&gt;</span></span></code></pre></div></div></figure><p>接下来在 <code>scripts</code> 目录下新建一个 <code>injector.js</code>文件（如果不存在该目录则需要先创建，也可以复用之前的注入器代码），代码如下：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">// 全站文章统计</span></span><span class="line"><span style="color: #E5C07B">hexo</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">extend</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">filter</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">register</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'theme_inject'</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">injects</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">injects</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">bodyEnd</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">file</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'PostCount'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'source/_inject/PostCount.ejs'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">});</span></span></code></pre></div></div></figure><p>然后在 <code>_config.fluid.yml</code> 文件中修改 <code>footer</code>的 <code>content</code> 字段，添加全站文章统计的调用代码：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">footer</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">content</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'</span></span><span class="line"><span style="color: #98C379">    &lt;div class="total-posts" style="font-size: 0.85rem; margin: 0.15rem 0.15rem;"&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;i class="fas fa-file-alt"&gt;&lt;/i&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;span id="g-total-posts-id"&gt;Getting total posts...&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">  '</span></span></code></pre></div></div></figure><p>这样就可以在页脚处显示全站文章统计了。</p><h1 id="页脚处添加一言">页脚处添加一言</h1><p>一言是一个提供一句话服务的网站，Fluid主题内置了对一言的支持，但只能在首页作为副标题显示。而我希望保留首页的副标题，因此决定将一言添加到页脚处。具体的调用可以参考一言开发者中心的文档。</p><p><a href="https://developer.hitokoto.cn/sentence/" name="https://developer.hitokoto.cn/logo.png" class="LinkCard">一言开发者中心</a></p><p>首先在 <code>source/js/</code> 目录下新建一个<code>Hitokoto.js</code>文件（如果不存在该目录则需要先创建），代码如下：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">async</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">fetchSlogan</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">try</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">await</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">fetch</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'https://v1.hitokoto.cn/?c=i'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">await</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">res</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">json</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">hitokotoElem</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'hitokoto'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">hitokotoElem</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">hitokotoElem</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`</span><span style="color: #C678DD">${</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hitokoto</span><span style="color: #C678DD">}</span><span style="color: #98C379">  —— </span><span style="color: #C678DD">${</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">from_who</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">''</span><span style="color: #C678DD">}</span><span style="color: #98C379">《</span><span style="color: #C678DD">${</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">from</span><span style="color: #C678DD">}</span><span style="color: #98C379">》`</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">catch</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">err</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">error</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">err</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #61AFEF">fetchSlogan</span><span style="color: #ABB2BF">();</span></span></code></pre></div></div></figure><p>其中请求的参数 <code>c=i</code>表示获取诗词，你可以根据自己的喜好，参考<a href="https://developer.hitokoto.cn/sentence/#%E5%8F%A5%E5%AD%90%E7%B1%BB%E5%9E%8B-%E5%8F%82%E6%95%B0">一言开发者中心</a>修改为其他类型的内容。</p><p>然后在 <code>_config.fluid.yml</code> 文件中修改 <code>footer</code>的 <code>content</code> 字段，添加一言的调用代码：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">footer</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">content</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'</span></span><span class="line"><span style="color: #98C379">    &lt;div class="hitokoto" style="font-size: 0.85rem; margin: 0.15rem 0.15rem;"&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;i class="fas fa-quote-left"&gt;&lt;/i&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;a href="https://developer.hitokoto.cn/" id="hitokoto_text"&gt;&lt;span id="hitokoto"&gt;Getting poem...&lt;/span&gt;&lt;/a&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;script src="/js/Hitokoto.js" defer&gt;&lt;/script&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">  '</span></span></code></pre></div></div></figure><p>正如一言官网所说：“动漫也好、小说也好、网络也好，不论在哪里，我们总会看到有那么一两个句子能穿透你的心。我们把这些句子汇聚起来，形成一言网络，以传递更多的感动。如果可以，我们希望我们没有停止服务的那一天。”</p><p>或许眼前触动你的句子，在某刻也曾击穿他人的心灵。</p><h1 id="页脚信息添加图标">页脚信息添加图标</h1><p>忘记在哪个博客看到博主为页脚的信息添加了图标，因此这次也对这里进行了美化。由于上一期美化中已经引入了Font Awesome 图标库，因此只需要在相应的位置添加图标的 HTML代码即可。</p><p>为了添加图标，我们还需要知道图标和其对应的类名。可以在<a href="https://fontawesome.com/icons">FontAwesome官网</a>上根据版本搜索你想要的图标，并获取其类名。</p><p>例如我选用了以下图标：</p><table><thead><tr><th style="text-align: center;">图标预览</th><th style="text-align: center;">类名</th><th style="text-align: center;">用途说明</th></tr></thead><tbody><tr><td style="text-align: center;"><i class="fas fa-quote-left"></i></td><td style="text-align: center;"><code>fas fa-quote-left</code></td><td style="text-align: center;">一言</td></tr><tr><td style="text-align: center;"><i class="fas fa-chart-bar"></i></td><td style="text-align: center;"><code>fas fa-chart-bar</code></td><td style="text-align: center;">全站字数统计</td></tr><tr><td style="text-align: center;"><i class="fas fa-file-alt"></i></td><td style="text-align: center;"><code>fas fa-file-alt</code></td><td style="text-align: center;">全站文章统计</td></tr><tr><td style="text-align: center;"><i class="fas fa-eye"></i></td><td style="text-align: center;"><code>fas fa-eye</code></td><td style="text-align: center;">总访问量</td></tr><tr><td style="text-align: center;"><i class="fas fa-user-friends"></i></td><td style="text-align: center;"><code>fas fa-user-friends</code></td><td style="text-align: center;">总访客数</td></tr><tr><td style="text-align: center;"><i class="fas fa-calendar"></i></td><td style="text-align: center;"><code>fas fa-calendar</code></td><td style="text-align: center;">网站运行时间</td></tr></tbody></table><h1 id="总结">总结</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-0344b8c7" role="button" aria-expanded="false" aria-controls="collapse-0344b8c7">        <div class="fold-arrow">▶</div>如果对当前的样式已经满意，那么主题配置中的代码如折叠中所示。      </div>      <div class="fold-collapse collapse" id="collapse-0344b8c7">        <div class="fold-content">          <p>至此，本次的美化就全部完成了！</p><p>最终，<code>_config.fluid.yml</code> 文件的 <code>footer</code> 的<code>content</code> 和 <code>statistics</code> 部分如下所示：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">footer</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">content</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'</span></span><span class="line"><span style="color: #98C379">    &lt;div class="powered-by"&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;a href="https://hexo.io" target="_blank" rel="nofollow noopener"&gt;&lt;span&gt;Hexo&lt;/span&gt;&lt;/a&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;i class="iconfont icon-love"&gt;&lt;/i&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"&gt;&lt;span&gt;Fluid&lt;/span&gt;&lt;/a&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;div class="info" style="font-size: 0.85rem; margin: 0.15rem 0.15rem;"&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;div class="duration"&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;i class="fas fa-calendar"&gt;&lt;/i&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;span id="duration-container"&gt;人生缓缓&amp;nbsp;自有答案&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;script src="/js/Duration.js"&gt;&lt;/script&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;span id="wordcount" style="display: inline;"&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;i class="fas fa-chart-bar"&gt;&lt;/i&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;span id="g-total-word-id"&gt;Getting word count...&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;span id="postcount" style="display: inline;"&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;i class="fas fa-file-alt"&gt;&lt;/i&gt;</span></span><span class="line"><span style="color: #98C379">        &lt;span id="g-total-posts-id"&gt;Getting post count...&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;div class="hitokoto" style="font-size: 0.85rem; margin: 0.15rem 0.15rem;"&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;i class="fas fa-quote-left"&gt;&lt;/i&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;a href="https://developer.hitokoto.cn/" id="hitokoto_text"&gt;&lt;span id="hitokoto"&gt;Getting poem...&lt;/span&gt;&lt;/a&gt;</span></span><span class="line"><span style="color: #98C379">      &lt;script src="/js/Hitokoto.js" defer&gt;&lt;/script&gt;</span></span><span class="line"><span style="color: #98C379">    &lt;/div&gt;</span></span><span class="line"><span style="color: #98C379">    '</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">statistics</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">enable</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">true</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">source</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">"busuanzi"</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">pv_format</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'&lt;i class="fas fa-shoe-prints"&gt;&lt;/i&gt;  总访问量 {} 次'</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 显示的文本，{}是数字的占位符（必须包含)，下同</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">uv_format</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'&lt;i class="fas fa-user-friends"&gt;&lt;/i&gt;  总访客数 {} 人'</span></span></code></pre></div></div></figure><p>其中，<code>content</code> 部分的第一个 <code>&lt;div&gt;</code>是本博客的框架与主题信息，第二个 <code>&lt;div&gt;</code>是网站运行时间、全站字数和文章统计，第三个 <code>&lt;div&gt;</code>是一言，后两者手动指定了样式。<code>statistics</code>部分是网站的访问量和访客数统计。</p>        </div>      </div>    </div><p>但是很可惜，我希望把全站字数统计、文章统计和总访问量、总访客数统计在一行内显示，因此不得不继续折腾。</p><p>首先把 <code>_config.fluid.yml</code> 文件的 <code>footer</code> 的<code>content</code> 置空，<code>statistics</code> 部分的<code>enable</code> 设置为 <code>false</code>，即</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">footer</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">content</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">''</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">statistics</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">enable</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">false</span></span></code></pre></div></div></figure><p>接着在 <code>source/html/</code> 目录下新建一个<code>Footer.html</code>文件（如果不存在该目录则需要先创建），并添加以下内容：</p><figure class="shiki html"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"footer-inner"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"powered-by"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">href</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"https://hexo.io"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_blank"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">rel</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"nofollow noopener"</span><span style="color: #ABB2BF">&gt;&lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;Hexo&lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"iconfont icon-love"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">href</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"https://github.com/fluid-dev/hexo-theme-fluid"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_blank"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">rel</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"nofollow noopener"</span><span style="color: #ABB2BF">&gt;&lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;Fluid&lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"iconfont icon-love"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">href</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"https://eu.umami.is/share/1fs3cnD9TAP8JzML/youyeyejie.github.io"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">target</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"_blank"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">rel</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"nofollow noopener"</span><span style="color: #ABB2BF">&gt;&lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;Umami&lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"hitokoto"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fas fa-quote-left"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">href</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"https://developer.hitokoto.cn/"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"hitokoto_text"</span><span style="color: #ABB2BF">&gt;&lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"hitokoto"</span><span style="color: #ABB2BF">&gt;且以群词 注解我这座荒山&lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">src</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"/js/Hitokoto.js"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">defer</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"data"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"total-word-container"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fas fa-chart-bar"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"g-total-word-id"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            字汇长河</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">&amp;nbsp;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"total-posts-container"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fas fa-file-alt"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"g-total-posts-id"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            文舟靠岸</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">&amp;nbsp;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"busuanzi_container_site_pv"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fas fa-eye"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"busuanzi_value_site_pv"</span><span style="color: #ABB2BF">&gt;1314&lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            目光所及</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">&amp;nbsp;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"busuanzi_container_site_uv"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fas fa-user-friends"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"busuanzi_value_site_uv"</span><span style="color: #ABB2BF">&gt;520&lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            访客驻足</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">src</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">defer</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"duration"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"fas fa-calendar"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"duration-container"</span><span style="color: #ABB2BF">&gt;人生缓缓</span><span style="color: #E06C75">&amp;nbsp;</span><span style="color: #ABB2BF">自有答案&lt;/</span><span style="color: #E06C75">span</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">src</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"/js/Duration.js"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">link</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">href</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"/css/Footer.css"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">type</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"text/css"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">rel</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"stylesheet"</span><span style="color: #ABB2BF">/&gt;</span></span></code></pre></div></div></figure><p>其中，我将页脚分为四行显示：</p><ul><li><code>powered-by</code> 是本博客的框架与主题信息；</li><li><code>hitokoto</code> 是一言；</li><li><code>data</code>是全站字数统计、文章统计、总访问量和总访客数统计；</li><li><code>duration</code> 是网站运行时间。</li></ul><p>然后需要用Hexo注入器将这个文件注入到页脚中。在<code>scripts/injector.js</code> 文件中添加如下内容：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E5C07B">hexo</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">extend</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">filter</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">register</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'theme_inject'</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">injects</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic">// 注入页脚</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">injects</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">footer</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">file</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'footer'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'source/html/Footer.html'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic">// 全站字数及文章统计</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">injects</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">bodyEnd</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">file</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'footerData'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'source/_inject/FooterData.ejs'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">});</span></span></code></pre></div></div></figure><p>接着修改 <code>source/_inject/FooterData.ejs</code>文件，让其只返回字数统计的部分：</p><figure class="shiki html"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">type</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"text/javascript"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"g-total-word-id"</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"&lt;%= wordtotal(site) %&gt;"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'g-total-posts-id'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">textContent</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #98C379">"&lt;%= site.posts.length %&gt;"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">&lt;/</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">&gt;</span></span></code></pre></div></div></figure><p>最后在 <code>source/css/</code> 目录下新建一个<code>Footer.css</code>文件（如果不存在该目录则需要先创建），覆盖原先的页脚样式，代码如下：</p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #D19A66">.footer-inner</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    padding: </span><span style="color: #D19A66">1</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    font-family: </span><span style="color: #D19A66">serif</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    font-size: </span><span style="color: #D19A66">0.85</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    margin: </span><span style="color: #D19A66">0.15</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.15</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.powered-by</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    font-size: </span><span style="color: #D19A66">1</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">span</span><span style="color: #61AFEF">#busuanzi_container_site_pv</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #E06C75">span</span><span style="color: #61AFEF">#busuanzi_container_site_uv</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #E06C75">span</span><span style="color: #61AFEF">#busuanzi_container_page_pv</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">inline</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p>这样就完成了页脚的美化，最终的效果甚得我心！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo Blog Building </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Fluid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让搜索引擎收录你的博客</title>
      <link href="/_posts/%E8%AE%A9%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/_posts/%E8%AE%A9%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%94%B6%E5%BD%95%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>在成功搭建起自己的博客并发表了几篇文章后，你期待满满地打开浏览器搜索自己的博客，准备好迎接扑面而来的成就感和满足感，然而这是你却发现搜索出来的内容不能说一模一样吧，也只能说是毫不相干。在查询原因后，你知道了从搭建好博客到被人们从搜索引擎发现之间还差了一步：那就是<strong>让搜索引擎收录你的博客</strong>。</p><h1 id="步骤">步骤</h1><h2 id="进入网站管理后台验证网站所有者">进入网站管理后台验证网站所有者</h2><p>为了让搜索引擎收录你的博客，你需要先验证你对该网站的所有权。这里给出几个主流搜索引擎的网站管理平台：</p><p><a href="https://www.bing.com/webmasters" class="LinkCard">BingWebmaster Tools</a><a href="https://search.google.com/search-console" class="LinkCard">GoogleSearch Console</a><a href="https://ziyuan.baidu.com/site/index" class="LinkCard">百度搜索资源平台</a></p><p>以 Bing Webmaster Tools 为例，首先访问 <a href="https://www.bing.com/webmasters">Bing Webmaster Tools</a>并登录你的微软账号、Google账号或Facebook账号三种全球网络相对通用的账号的其中一个。</p><figure><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="Step 1"><figcaption aria-hidden="true">Step 1</figcaption></figure><p>接着，选择右侧的“手动添加网站”，在输入框中填入你的博客URL，然后点击“添加”。</p><figure><img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="Step 2"><figcaption aria-hidden="true">Step 2</figcaption></figure><p>在弹出的“选择一种验证方法”中，选择第二个：HTML Meta 标记</p><figure><img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload alt="Step 3"><figcaption aria-hidden="true">Step 3</figcaption></figure><p>将其中的内容复制下来待用。</p><p>其他网站同理。如果你希望让你的博客被多个搜索引擎收录，你可以参考上述步骤分别获取各个搜索引擎的验证标记。</p><h2 id="在-hexo-中添加验证标记">在 Hexo 中添加验证标记</h2><p>前一步中你所复制的 <code>&lt;meta&gt;</code>标记需要被粘贴到你网站的主页中，且该标记应位于第一个<code>&lt;body&gt;</code> 部分前面的 <code>&lt;head&gt;</code>部分中。</p><p>以我所使用的fluid主题为例，你当然可以选择修改<code>hexo\themes\fluid\layout\_partial\head.ejs</code>文件，从而实现在每次生成静态文件时都自动添加该标记。但是，采用这个方法有一个缺点：一旦你更新或更换了主题，将会导致你之前添加的验证标记丢失。</p><p>因此我们选择使用Hexo注入器来添加验证标记。Hexo注入器允许你在生成的HTML 文件中注入自定义内容。</p><p>在 <code>scripts</code> 目录下创建一个 JavaScript 文件如<code>injector.js</code>，并添加以下内容：</p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E5C07B">hexo</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">extend</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">injector</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">register</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'head_begin'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'/*你复制的内容*/</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'default'</span><span style="color: #ABB2BF">);</span></span></code></pre></div></div></figure><p>如果你前一步复制了多个验证标记，你可以重复上面这段代码，将每个验证标记都添加到<code>injector.js</code> 文件中。</p><h2 id="生成网站地图备用">生成网站地图备用</h2><p>由于大部分搜索引擎会通过你提交的网站地图来索引你的博客，因此生成网站地图是一个必要的步骤。</p><p>在 Hexo 中生成网站地图可以使用 <code>hexo-generator-sitemap</code>插件。首先，在博客根目录下执行以下命令安装插件：</p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">npm</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">hexo-generator-sitemap</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--save</span></span></code></pre></div></div></figure><p>然后在 <code>_config.yml</code> 文件中添加以下配置：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">sitemap</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">path</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">sitemap.xml</span></span></code></pre></div></div></figure><p>在这之后，只要你每次执行 <code>hexo generate</code>命令生成静态文件时，网站地图就会自动生成并保存在博客根目录下的<code>sitemap.xml</code> 文件中。</p><h2 id="继续未完成的网站验证">继续未完成的网站验证</h2><p>在完成上述步骤后，我们回到网站管理后台继续操作。点击验证按钮，搜索引擎将会检查你的网站是否包含了你所添加的验证标记。</p><figure><img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload alt="Step 4"><figcaption aria-hidden="true">Step 4</figcaption></figure><p>一段时间后，你将会收到验证成功的通知。</p><p>点击左侧的网站地图选项，选择右上角“提交网站地图”，在输入框中填入你此前生成的<code>sitemap.xml</code> 文件的路径，然后点击“提交”。地图路径一般为<code>https://your-blog-url/sitemap.xml</code>，其中<code>your-blog-url</code> 替换为你的博客 URL。</p><figure><img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload alt="Step 5"><figcaption aria-hidden="true">Step 5</figcaption></figure><p>等待状态变为成功，一段时间后，你的博客就会被搜索引擎收录，你就可以通过搜索引擎来访问你的博客了。</p><h1 id="总结">总结</h1><p>通过上述步骤，你可以让你的博客被主流搜索引擎收录，从而让更多人能够通过搜索引擎发现你的博客。请注意，搜索引擎收录可能需要一些时间，因此请耐心等待。</p><ul><li><strong>注1</strong>：博主在谷歌的 Google Search Console中验证了网站所有权，但是提交站点地图时反复显示“无法抓取”，暂不清楚产生该问题的原因以及解决方法。但在两天后，邮箱收到网站被收录的邮件，尝试后发现已经可以通过谷歌搜索引擎搜索到博客了，因此并未继续探究。</li><li><strong>注2</strong>：博主仅在必应和谷歌验证了网站所有权，二者均在三天后收录了博客。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo Blog Building </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理</title>
      <link href="/_posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
      <url>/_posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>刘功申老师</em> 2024-2025学年春季学期教学内容进行整理。</p></blockquote><h1 id="操作系统概述">操作系统概述</h1><ul><li>操作系统的概念<ul><li>操作系统是控制和管理计算机系统内各种硬件和软件资源、有效地组织多道程序运行的系统软件（或程序集合），是用户与计算机之间的接口。</li></ul></li><li>操作系统的要点<ul><li>是软件，且是系统软件</li><li>基本职能是控制和管理系统资源</li><li>提供服务，方便用户使用</li></ul></li><li>输入输出<ul><li>缓冲技术<ul><li>处于CPU和外设之间，解决速度不匹配问题</li><li>例如，SPOOLING（Simultaneous Peripheral OperationOn-Line，即外部设备联机并行操作）技术将磁盘模拟成IO设备，也称为假脱机。<ul><li>缓和了CPU与低速I/O设备速度不匹配的矛盾</li><li>设备并没有分配给任何进程.在输入井或输出井中，分配给进程的是一存储区和建立一张I/O请求表</li><li>实现了虚拟设备功能.多个进程同时使用一独享设备，而对每一进程而言，都认为自己独占这一设备，不过，该设备是逻辑上的设备</li></ul></li></ul></li><li>中断技术<ul><li>解决CPU和外设的协调 (不再需要轮询外设状态)</li></ul></li><li>DMA技术<ul><li>进一步解放CPU</li></ul></li></ul></li><li>操作系统的类型<ul><li>分时系统</li><li>实时系统</li><li>微机操作系统</li><li>网络操作系统</li><li>分布式操作系统</li></ul></li><li>操作系统的特征<ul><li>并发</li><li>共享</li><li>虚拟</li><li>不确定性</li></ul></li><li>现代操作系统的新特征<ul><li>微内核体系结构</li><li>多线程</li><li>对称多处理</li><li>分布式</li><li>面向对象设计</li></ul></li><li>操作系统的功能<ul><li>处理机管理（进程调度）</li><li>存储管理</li><li>设备管理</li><li>文件管理</li><li>用户接口</li></ul></li></ul><h1 id="内存管理">内存管理</h1><h2 id="内存管理的概念">内存管理的概念</h2><ul><li>作用：提高主存的利用率，将尽可能多的作业同时加载到主存中</li><li>层次：<ul><li>寄存器</li><li>主存</li><li>辅助存储器</li></ul></li><li>需求：<ul><li>重定位：进程装入内存中的地址变化 （不固定）</li><li>保护：防止进程越界访问</li><li>共享：对共享区域的受控访问</li><li>逻辑组织：逻辑地址的组织更符合程序的构造</li><li>物理组织：管理主存、辅存等分级存储方式</li></ul></li></ul><h2 id="存储管理技术">存储管理技术</h2><ul><li>单一连续区（不分区）</li><li>固定分区<ul><li>大小一致</li><li>大小不一致</li></ul></li><li>动态可变分区<ul><li>不会产生内部碎片</li></ul></li><li>单纯分页/分段</li><li>虚拟存储系统<ul><li>分页</li><li>分段</li><li>段页式</li></ul></li></ul><h3 id="地址重定位">地址重定位</h3><ul><li>固定定位</li><li>静态重定位</li><li>动态重定位<ul><li>将逻辑地址变换成物理地址由硬件自动完成</li><li>优点：<ul><li>运行期间可以换进换出内存：换出阻塞的进程</li><li>可以在内存中移动进程：搜集内存中的外部碎片</li><li>空间不必连续</li><li>便于信息共享</li><li>是内存虚拟管理的基础</li></ul></li></ul></li></ul><h3 id="动态可变分区分配算法">动态可变分区分配算法</h3><ul><li>首次适配（First）：空闲分区链表按地址排序，分配快，回收效率高，小碎片多</li><li>临近适配（Next）：从上次分配的地址开始查找，减少搜索时间</li><li>最佳适配（Best）：空闲分区链表按块从小到大排序，选择最小的足够大的空闲分区，小碎片多</li><li>最差适配（Worst）：空闲分区链表按块从大到小排序，选择最大的空闲分区，多中等碎片</li><li>算法对比<ul><li>复杂度：最佳（2+2）&gt;最差（1+2）&gt;首次（1+1）&gt;循环（1+1）</li><li>小碎片产生的可能性：最佳 &gt;首次 &gt; 循环 &gt; 最差</li><li>后继大作业分配成功的可能性：最佳 &gt;首次 &gt; 循环 &gt; 最差</li></ul></li></ul><h3 id="内存扩充技术">内存扩充技术</h3><ul><li>主辅存交换<ul><li>覆盖技术：<ul><li>用于一个作业的内部</li><li>同一程序按程序的逻辑结构分段，不会同时运行的程序段分在一组内，该组称为覆盖段</li><li>极端情况下覆盖段在主存中只保留一个段，其他段在辅存中</li><li>应用程序不透明，需要程序员干预</li></ul></li><li>交换技术（虚拟存储技术）：<ul><li>用于不同的作业，任一时刻主存中只保留一个完整的用户作业</li><li>对应用程序而言是透明的，无需程序员干预</li></ul></li></ul></li></ul><h3 id="虚拟存储技术">虚拟存储技术</h3><ul><li>简单分页——页表（page table）<ul><li>逻辑地址到物理地址的转换：<ul><li>逻辑地址 = 页号 + 页内偏移</li><li>物理地址 = 帧号 + 页内偏移</li></ul></li></ul></li><li>系统抖动：频繁换入换出页面</li><li>虚拟存储器的大小限制：<ul><li>存放程序指令和数据的外存区域称为交换区。</li><li>虚拟存储器大小 = 交换区大小 + 内存大小</li></ul></li><li>虚拟地址空间大小：<ul><li>计算机地址结构的限制（例如，指令地址字长度等）</li></ul></li><li>地址映射<ul><li>将进程中程序的虚拟（逻辑）地址转化为物理地址</li><li>维护地址映射表</li></ul></li><li>物理内存的管理<ul><li>物理内存的回收、分配</li></ul></li><li>缺页异常的处理<ul><li>分配内存</li><li>将需要的内容从磁盘swap区加载到内存</li></ul></li><li>页大小<ul><li>页越大，内零头越大；</li><li>页越小，需要的页越多，页表就越大</li></ul></li></ul><h3 id="逻辑地址到物理地址的转换">逻辑地址到物理地址的转换</h3><ul><li>页表（page table）<ul><li>逻辑地址 = 页号 + 页内偏移</li><li>物理地址 = 帧号 + 页内偏移</li></ul><figure><img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload alt="页表"><figcaption aria-hidden="true">页表</figcaption></figure></li><li>快表（TLB：Translation Lookaside Buffer）<ul><li>页表在Cache或寄存器中的副本</li><li>用于加速地址转换</li></ul><figure><img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload alt="快表"><figcaption aria-hidden="true">快表</figcaption></figure></li><li>多级页表<ul><li>把整个页表进行分页，分成一张张小页表，每个小页表的大小与页框相同。</li><li>对小页表顺序编号，允许小页表分散存放在不连续的页框中。</li><li>为了进行索引查找，应该为这些小页表建一张页目录表（一级页表），其表项指出小页表（二级页表）所在页框号及相关信息。</li><li>逻辑地址结构有三部分组成：页目录号、页号和位移。</li></ul><img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload alt="多级页表"> <img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload alt="二级页表"></li><li>反向页表（Inverted Page Table）<ul><li>虚拟地址的页号使用散列函数映射到哈希表中。</li><li>把 <span class="math inline"><em>n</em></span> 位页号映射到 <span class="math inline"><em>m</em></span> 位帧号（<span class="math inline"><em>n</em> &gt; <em>m</em></span>）</li><li>大小与物理内存成正比</li></ul><figure><img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload alt="反向页表"><figcaption aria-hidden="true">反向页表</figcaption></figure></li></ul><h2 id="空闲内存页的管理">空闲内存页的管理</h2><ul><li>位图方式：<ul><li>每个Bit表示一块的使用状态。0表示空闲，1表示已分配。</li><li>表示能力：32MB主存，页大小为4K，1KB的空间就足够表示。</li><li>效率高：只要修改对应bit就可以</li></ul></li><li>空闲链表方式：<ul><li>用链结构表示空闲页。</li></ul></li></ul><h2 id="物理页框回收">物理页框回收</h2><ul><li>全局淘汰策略：从所有作业所占用的帧中选择。</li><li>局部淘汰策略：从本作业所占用的帧中选择</li></ul><h3 id="淘汰算法">淘汰算法</h3><ol type="1"><li>最优淘汰算法（OPT-Optimal）<ul><li>淘汰将来最长时间不使用的页面。</li><li>需要预知未来的页面访问情况，实际不可行。</li><li>作为理论上的评价标准，用以鉴别其他淘汰算法的优劣</li></ul></li><li>先进先出淘汰算法（FIFO）<ul><li>淘汰最先进入内存的页面。</li><li>实现简单。</li><li>可能导致系统抖动（频繁换入换出页面）。</li></ul></li><li>最近最少未使用算法（LFU-Least Frequently Used）<ul><li>淘汰在一定时间内未被访问的页面。</li><li>为每页面设置访问计数器，通过比较所有页的计数器值来确定淘汰的页面。</li><li>需要定期对计数器清零，以淘汰过期页</li><li>过于复杂</li></ul></li><li>最久不使用淘汰算法（NUR-Not Used Recently），即Clock算法<ul><li>结合了FIFO和LFU的思想。</li><li>1个访问位<ul><li>每个页面有一个访问位，表示最近是否被访问过。</li><li>使用一个指针指向当前检查的页面，按顺序检查页面。</li><li>如果访问位为1，则清零并继续检查下一个页面；如果为0，则淘汰该页面。</li></ul></li><li>1个访问位 + 1个修改位<ul><li>每个页面有一个访问位和一个修改位。</li><li>访问位表示最近是否被访问过，修改位表示页面是否被修改过。</li><li>使用一个指针指向当前检查的页面，按顺序检查页面。</li><li>如果访问位为1，则清零并继续检查下一个页面；如果为0，则淘汰该页面。</li></ul></li><li>适用于大多数实际情况，性能较好。</li></ul></li></ol><h2 id="段页式虚拟存储管理">段页式虚拟存储管理</h2><ul><li><strong>虚拟分段的优点</strong>：<ul><li>简化不断增长的数据结构处理方式</li><li>允许分块编译</li><li>有助于进程间的共享</li><li>有助于实现保护机制</li></ul></li><li>段页式地址翻译<ul><li>段号 <span class="math inline"><em>s</em></span> + 页号 <span class="math inline"><em>p</em></span> + 页内偏移 <span class="math inline"><em>d</em></span></li><li>为了进行地址变换，系统为每一个作业建立一张段表，再为每一段建立一张页表。同样，也有一个段表控制寄存器，存放当前作业段表的长度和始址。</li></ul><figure><img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload alt="段页式存储管理"><figcaption aria-hidden="true">段页式存储管理</figcaption></figure></li><li>读取策略<ul><li>请求式分页</li><li>预约式分页</li></ul></li><li>放置策略<ul><li>最佳适配</li><li>首次适配</li><li>近邻适配</li><li>最差适配</li></ul></li><li>替换策略<ul><li>算法<ul><li>Opt</li><li>FIFO</li><li>LRU</li><li>Clock（NRU）</li></ul></li><li>页缓冲</li></ul></li><li>清除策略（回写）<ul><li>请求式清除</li><li>预约式清除</li></ul></li></ul><h2 id="物理主存储器的分配和管理">物理主存储器的分配和管理</h2><ul><li>伙伴系统（Buddy system）<ul><li>将内存分成大小为 <span class="math inline">2<sup><em>n</em></sup></span> 的块。</li><li>分配时，寻找最小的满足要求的块。</li><li>回收时，将相邻的块合并成更大的块。</li><li>优点：减少碎片，提高内存利用率。</li></ul><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">Void </span><span style="color: #61AFEF">get_hole</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75"> </span><span style="color: #C678DD">int</span><span style="color: #E06C75"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #61AFEF">If</span><span style="color: #ABB2BF"> ( i </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> ( u</span><span style="color: #C678DD">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) ) failure;</span></span><span class="line"><span style="color: #61AFEF">If</span><span style="color: #ABB2BF"> ( </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">i_list empty</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> )</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #61AFEF">get_hole</span><span style="color: #ABB2BF">( i</span><span style="color: #C678DD">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">split hole into buddies</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">put buddies on i_list</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">take first hole on i_list</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure> <img src="image-23.webp" srcset="/img/loading/loading3.gif" lazyload alt="伙伴系统"></li><li>Slab系统<ul><li>将内存分成多个大小相同的块（slab）。</li><li>每个 slab 包含多个对象，每个对象大小相同。</li><li>对象分配和回收时，直接在 slab中进行，不需要频繁的内存分配和释放。</li><li>优点：减少碎片，提高内存利用率。</li></ul><figure><img src="image-24.webp" srcset="/img/loading/loading3.gif" lazyload alt="Slab系统"><figcaption aria-hidden="true">Slab系统</figcaption></figure></li><li>SLUB：在 SLAB的基础上简化设计，提高性能。更适合多处理器系统使用。是目前Linux版本的默认配置。</li><li>SLOB：为嵌入式系统提供极简的内存分配方案。</li></ul><h1 id="进程管理">进程管理</h1><h2 id="进程概念">进程概念</h2><ul><li>进程的概念<ul><li>程序在操作系统上的一次运行过程。</li><li>系统进行资源分配和调度的一个可并发执行的独立单位。</li><li>在进程看来，自己独占计算机系统，并可以调用OS提供的服务。</li></ul></li><li>进程的特性<ul><li>动态性：进程具有生命周期，经历创建、运行、消亡等过程。</li><li>并发性：多个进程可以并发地执行。</li><li>独立性：进程既是系统中资源分配和保护的基本单位，也是系统调度的独立单位。</li></ul></li><li>进程的组成<ul><li>代码段：或叫共享正文段，在多个程序间可以实现共享。含代码和不变的数据。</li><li>数据上下文：<ul><li>用户层：<ul><li>数据区：外部变量和静态变量</li><li>工作区：即栈，包含局部变量，函数调用的现场。</li></ul></li><li>操作系统层：执行现场和核心栈</li><li>寄存器层：控制寄存器和数据寄存器。</li></ul></li></ul></li><li>进程控制块(PCB)<ul><li>进程的基本信息和状态信息的集合。</li><li><strong>每个进程有且仅有一个进程控制块。</strong></li><li>分为两部分：<ul><li>常驻内存部分：进程无论处于什么状态，系统都可能要查询的PCB成员。</li><li>可交换部分：进程不在执行时系统不需要访问的PCB成员。内存紧张时可以将他们换出到磁盘上。</li></ul></li></ul></li><li>进程是程序的一次动态执行活动，而程序是进程运行的静态描述文本</li></ul><h2 id="进程状态与转移">进程状态与转移</h2><h3 id="进程状态">进程状态</h3><ul><li>两状态：<ul><li>Not Running</li><li>Running</li></ul></li><li>三状态：<ul><li>Running</li><li>Ready</li><li>Block</li></ul><figure><img src="image-25.webp" srcset="/img/loading/loading3.gif" lazyload alt="三状态"><figcaption aria-hidden="true">三状态</figcaption></figure></li><li>五状态：<ul><li>Created：限制进程数量</li><li>Ready</li><li>Running</li><li>Sleep</li><li>Terminated：便于其他应用程序分析统计操作系统的性能</li></ul></li><li>六/七状态：<ul><li>挂起 Suspend: 需要评估加载资源</li></ul><figure><img src="image-26.webp" srcset="/img/loading/loading3.gif" lazyload alt="挂起状态"><figcaption aria-hidden="true">挂起状态</figcaption></figure></li></ul><h3 id="进程状态转换">进程状态转换</h3><ul><li>运行态 → 阻塞态<ul><li>等待资源/事件等；如等待外设传输，或人工干预。</li></ul></li><li>阻塞态 → 就绪态<ul><li>资源得到满足；如外设传输结束；人工干预完成。</li></ul></li><li>运行态 → 就绪态<ul><li>运行时间片到；出现有更高优先权进程。</li></ul></li><li>就绪态 → 运行态<ul><li>选择一个就绪进程运行。</li></ul></li></ul><h2 id="pcb的组织方式">PCB的组织方式</h2><figure><img src="image-27.webp" srcset="/img/loading/loading3.gif" lazyload alt="PCB的组织方式"><figcaption aria-hidden="true">PCB的组织方式</figcaption></figure><ul><li>链表方式</li></ul><h2 id="进程控制">进程控制</h2><h3 id="进程创建与进程终止">进程创建与进程终止</h3><ul><li>进程创建<ul><li>系统调用：<code>fork</code><ul><li>创建一个新进程，返回值为0表示子进程，返回值为子进程ID表示父进程。</li></ul></li><li>复制父进程的PCB和地址空间<ul><li>子进程与父进程共享代码段，但有独立的数据段和栈段。</li></ul></li><li>分配新的PCB和地址空间<ul><li>子进程拥有独立的PCB和地址空间。</li></ul></li><li>调用 <code>exec()</code> 函数<ul><li>用于加载新程序到子进程的地址空间中，替换子进程的代码段和数据段。</li><li>子进程执行新的程序，父进程继续执行原来的程序。</li></ul></li></ul></li><li>进程终止<ul><li>系统调用：<code>exit()</code><ul><li>释放PCB和地址空间</li><li>释放子进程的资源</li><li>通知父进程子进程已终止</li></ul></li><li>父进程等待子进程终止<ul><li>系统调用：<code>wait()</code></li><li>父进程阻塞，直到子进程终止</li><li>父进程获取子进程的退出状态</li></ul></li><li>僵尸进程<ul><li>子进程终止后，父进程未调用<code>wait()</code>，子进程的PCB仍然存在，称为僵尸进程。</li><li>僵尸进程会占用系统资源，但不会占用CPU时间。</li><li>父进程用 <code>while</code> 循环调用 <code>wait()</code>来避免僵尸进程的产生。</li></ul></li></ul></li></ul><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">include </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">stdio.h</span><span style="color: #C678DD">&gt;</span></span><span class="line"><span style="color: #ABB2BF">include </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">stdlib.h</span><span style="color: #C678DD">&gt;</span></span><span class="line"><span style="color: #ABB2BF">include </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">sys</span><span style="color: #C678DD">/</span><span style="color: #ABB2BF">types.h</span><span style="color: #C678DD">&gt;</span></span><span class="line"><span style="color: #ABB2BF">include </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">unistd.h</span><span style="color: #C678DD">&gt;</span></span><span class="line"><span style="color: #ABB2BF">include </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">sys</span><span style="color: #C678DD">/</span><span style="color: #ABB2BF">wait.h</span><span style="color: #C678DD">&gt;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">main</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">pid_t</span><span style="color: #ABB2BF"> pid;</span></span><span class="line"><span style="color: #ABB2BF">    pid </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">fork</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (pid </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">perror</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"fork error"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">exit</span><span style="color: #ABB2BF">(EXIT_FAILURE);</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (pid </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 子进程中使用execlp执行date命令，显示当前日期和时间</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">execlp</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"date"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"date"</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">perror</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"execlp error in child"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">exit</span><span style="color: #ABB2BF">(EXIT_FAILURE);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 父进程等待子进程结束</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> status;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">pid_t</span><span style="color: #ABB2BF"> wpid </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">wait</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF">status);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">WIFEXITED</span><span style="color: #ABB2BF">(status)) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"Child process </span><span style="color: #D19A66">%d</span><span style="color: #98C379"> exited with status </span><span style="color: #D19A66">%d</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, wpid, </span><span style="color: #61AFEF">WEXITSTATUS</span><span style="color: #ABB2BF">(status));</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"Parent process </span><span style="color: #D19A66">%d</span><span style="color: #98C379"> continues.</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, </span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="进程模式">进程模式</h3><ul><li>进程模式<ul><li>用户模式：用户程序运行的模式，限制访问系统资源。</li><li>内核模式：操作系统内核运行的模式，允许访问所有系统资源。</li></ul></li><li>进程切换与模式切换<ul><li>进程切换的目的：换一个新进程占用CPU</li><li>进程切换时机：<ul><li>外部中断（时间片、IO等）：不可预知</li><li>异常（div 0）：不可预知</li><li>陷阱（Int x）：可预知</li><li>系统调用</li></ul></li><li>模式切换的目的<ul><li>在用户态和核心态之间的切换</li></ul></li><li>模式切换的时机：<ul><li>同上</li></ul></li></ul></li><li>中断与陷阱的区别</li><li>发生模式切换并不一定发生进程切换，发生进程切换时，必然伴随着模式切换，因为，进程切换是核心功能，无法在用户模式下完成。</li></ul><h2 id="线程">线程</h2><ul><li>线程的概念<ul><li>线程是进程中的一个执行单元，是操作系统调度和执行的基本单位。</li><li><strong>进程是资源分配的基本单位，而线程是CPU调度的基本单位。</strong></li></ul></li><li>线程的基本特征<ul><li>独立的线程执行状态（运行、就绪、阻塞等）。</li><li>独立的线程上下文环境。</li><li>独立执行栈：保存线程的上下文。</li><li>独立的静态存储区，用于存放局部变量</li><li>存在独立的线程控制块来描述线程的各类管理信息。</li><li>存取所属进程内的主存和其它资源，在本进程的范围内与所有线程共享这些资源。<ul><li>同一程序地址空间。</li><li>运行代码。</li><li>全局变量。</li><li>设备和文件资源。</li></ul></li></ul></li></ul><h3 id="用户级多线程">用户级多线程</h3><ul><li>一个线程被阻塞后，只代表该线程对应的执行线索暂停，不会必然导致整个进程的阻塞，同进程中的其它线程仍有可能被调度执行。</li><li>同进程内的线程是并发执行的（单CPU环境），能够实现一些资源的共享，如全局变量等。对共享的资源，在访问时需要解决同步或互斥的问题。</li><li>优势<ul><li>创建快：创建线程的开销（包括时间开销和资源开销）要远小于创建进程。</li><li>终止快：终止一个线程比终止一个进程花费的时间少。</li><li>切换快：同进程内的线程切换开销要远远小于进程之间的切换开销。</li><li>通信快：进程内部的线程间的数据通信效率要远效率进程间的数据通信效率。</li></ul></li><li>基本思想：<ul><li>内核以进程为单位进行调度，不知道线程的存在。</li><li>线程的所有状态变化都发生在用户空间中。</li><li>管理线程的工作由应用程序来完成，操作系统感觉不到进程内部的多执行线索。</li></ul></li><li>管理线程的工作包括：<ul><li>线程创建和撤销</li><li>线程间通信</li><li>调度和现场保存与恢复等。</li></ul></li></ul><h3 id="内核级多线程">内核级多线程</h3><ul><li>基本思想：<ul><li>所有的线程管理工作全部由操作系统核心完成。</li><li>操作系统核心为进程中的每个线程维护上下文。</li><li>操作系统基于线程实现处理器调度，任何进程都至少包含一个线程。</li></ul></li><li>缺点：<ul><li>即使同进程内的线程切换也需要进入核心态执行调度算法。（伴随着模式切换）</li></ul></li><li>优点：<ul><li>如果一个线程被阻塞，内核可以调度同进程中的其他线程执行。</li><li>同进程内的线程并行度好，可以分别调度到多个处理器上。</li></ul></li></ul><h3 id="混合方法实现多线程">混合方法实现多线程</h3><figure><img src="image-28.webp" srcset="/img/loading/loading3.gif" lazyload alt="混合多线程"><figcaption aria-hidden="true">混合多线程</figcaption></figure><ul><li>使用了4个实体：<ul><li>进程、用户级线程、轻量级进程、内核级线程</li></ul></li><li>关系：<ul><li>轻量级进程和内核级线程严格1对1。</li><li>轻量级进程对应用程序可见，其数据结构在进程地址空间中。</li><li>内核级线程的数据结构保存在内核地址空间中。</li></ul></li></ul><h2 id="调度算法">调度算法</h2><h3 id="调度的层次">调度的层次</h3><ul><li>高级调度(长程调度)：又称作业调度，它决定处于输入池中的哪个后备作业可以调入系统，成为一个或一组就绪进程。</li><li>中级调度（中程调度）：又称对换调度，它决定处于交换区中的就绪进程中哪一个可以调入内存，以便直接参与对CPU的竞争。在内存资源紧张时，将内存中处于阻塞状态的进程调至交换区。</li><li>低级调度（短程调度）：又称进程调度或处理机调度，它决定驻在内存中的哪一个就绪进程可以占用CPU，使其获得实实在在的执行。</li></ul><figure><img src="image-29.webp" srcset="/img/loading/loading3.gif" lazyload alt="调度层次"><figcaption aria-hidden="true">调度层次</figcaption></figure><ul><li>对内核级线程，操作系统使用线程技术，对线程的调度为低级调度。</li><li>对用户级线程，低级调度的对象是进程，线程的调度由应用程序来做。</li><li>对混合式线程，低级调度的对象是内核级线程。</li></ul><h3 id="作业调度算法">作业调度算法</h3><ol type="1"><li>先来先服务（FCFS）<ul><li>按作业到达的先后顺序进行调度。</li><li>简单易实现，但可能导致长作业阻塞短作业，平均周转时间较长。</li></ul></li><li>短作业优先（SJF）<ul><li>优先调度执行时间短的作业。|</li><li>可以减少平均周转时间，但可能导致长作业饥饿。</li></ul></li><li>最高响应比作业优先（HRN）<ul><li>计算每个作业的响应比，优先调度响应比高的作业。</li><li><span class="math display">$$HRN = \frac{等待时间 +服务时间}{服务时间} = \frac{T_w + T_s}{T_s} = 1 +\frac{T_w}{T_s}$$</span></li><li>既照顾了先来者，又优待了短作业。</li></ul></li></ol><h3 id="进程调度算法">进程调度算法</h3><ul><li>调度时机<ul><li>时钟中断：当前进程时间片结束</li><li>I/O 中断</li><li>Memory 异常，如缺页异常</li><li>Trap（陷阱）：软中断等</li><li>系统调用<ul><li>如进程退出exit（）</li><li>打开文件</li></ul></li></ul></li></ul><ol type="1"><li>先来先服务(FCFS-First Come First Server)<ul><li>非抢占式调度算法</li></ul></li><li>时间片轮转法(RR-Round-Robin)<ul><li>抢占式调度算法</li><li>适用于交互式分时系统</li><li>各就绪进程轮流运行一小段时间，这一小段时间称为时间片。</li><li>在时间片内，如进程运行任务完成或因I/O等原因进入阻塞状态，该进程就提前让出CPU。</li><li>当一个进程耗费完一个时间片而尚未执行完毕，调度程序就强迫它放弃处理机，使其重新排到就绪队列末尾。</li></ul></li><li>最短进程优先(SPN-Shortest Process Next)<ul><li>非抢占式调度算法</li><li>优先调度执行时间短的进程。</li><li>可以减少平均周转时间，但可能导致长进程饥饿。</li><li>难点：如何预测进程的运行时间<ul><li><span class="math display">$$ \begin{aligned}  S_{n+1}&amp;=\alpha \cdot T_{n} + (1-\alpha) \cdot S_{n}\\  &amp;= \alpha \cdot T_{n} + (1-\alpha)\alpha T_{n-1} + \cdots +(1-\alpha)^{i}\alpha T_{n-i} + \cdots + (1-\alpha)^{n-1}\alpha S_{1}  \end{aligned} $$</span></li></ul></li></ul></li><li>最短剩余时间优先(SRT-Shortest Remaining Time)<ul><li>抢占式调度算法</li><li>优先调度剩余执行时间短的进程。</li><li>可以减少平均周转时间，但可能导致长进程饥饿。</li><li>难点：如何预测进程的剩余执行时间</li></ul></li><li>最高响应比优先(HRRN-Highest Response Ratio Next)<ul><li>非抢占式调度算法</li><li>计算每个进程的响应比，优先调度响应比高的进程。</li><li><span class="math display">$$HRR = \frac{等待时间 +服务时间}{服务时间} = \frac{T_w + T_s}{T_s} = 1 +\frac{T_w}{T_s}$$</span></li><li>既照顾了先来者，又优待了短进程。</li></ul></li><li>优先级调度算法<ul><li>抢占式或非抢占式调度算法</li><li>静态优先级调度<ul><li>每个进程在创建时就被赋予一个固定的优先级。</li><li>优先级高的进程先执行。</li><li>可能导致低优先级进程饥饿。</li></ul></li><li>动态优先级调度<ul><li>优先级根据进程的运行情况动态调整。</li></ul></li></ul></li><li>多级反馈队列调度算法(Feedback)<ul><li>将就绪队列分为多个优先级队列，每个队列有不同的时间片。</li><li>向短时间作业、I/O繁忙和交互式进程倾斜</li></ul></li></ol><table><thead><tr><th></th><th>选择函数</th><th>决策模式</th><th>吞吐量</th><th>响应时间</th><th>开销</th><th>对进程的影响</th><th>饿死</th></tr></thead><tbody><tr><td>FCFS</td><td>Max(w)</td><td>非抢占</td><td>不强调</td><td>可能很高，特别是当进程执行时间差别很大时</td><td>最小</td><td>对短进程不利；对IO进程不利</td><td>无</td></tr><tr><td>RR</td><td>C</td><td>抢占（时间片）</td><td>时间片太小，吞吐量很低</td><td>为短进程提供好的响应时间</td><td>最小</td><td>公平</td><td>无</td></tr><tr><td>SPN</td><td>Min(s)</td><td>非抢占</td><td>高</td><td>为短进程提供好的响应时间</td><td>可能较高</td><td>对长进程不利</td><td>可能</td></tr><tr><td>SRT</td><td>Min(s-e)</td><td>抢占（条件满足时）</td><td>高</td><td>提供好的响应时间</td><td>可能较高</td><td>对长进程不利</td><td>可能</td></tr><tr><td>HRRN</td><td>Max（R）</td><td>非抢占</td><td>高</td><td>提供好的响应时间</td><td>可能较高</td><td>很好的平衡</td><td>无</td></tr><tr><td>Feedback</td><td></td><td>抢占（时间片）</td><td>不强调</td><td>不强调</td><td>可能较高</td><td>可能对IO进程有利</td><td>可能</td></tr></tbody></table><h2 id="实时调度">实时调度</h2><ul><li>实时系统定义：系统的正确性不仅取决于计算的逻辑结果，而且还依赖于产生结果的时间</li><li>实时任务的特征：<ul><li>实时<ul><li>硬实时任务（100%实时）</li><li>软实时任务(概率实时)</li></ul></li><li>周期<ul><li>非周期任务</li><li>周期任务</li></ul></li></ul></li><li>调度算法<ul><li>静态表驱动(static table-driven scheduling)<ul><li>用于周期性任务</li></ul></li><li>静态优先级驱动抢占调度(static priority-driven preemptive scheduling)<ul><li>速率单调算法</li></ul></li><li>基于动态规划的调度(dynamic planning-based scheduling)</li><li>动态尽力调度(dynamic best effort scheduling)<ul><li>时限调度算法</li></ul></li></ul></li></ul><h3 id="时限调度">时限调度</h3><ol type="1"><li>最早截止时间优先调度<ul><li>优先调度截止时间最早的任务。</li><li>适用于硬实时系统。</li></ul></li><li>最小松弛时间优先调度<ul><li>优先调度松弛时间最小的任务。</li><li>松弛时间 = 截止时间 - 当前时间 - 任务执行时间</li><li>适用于软实时系统。</li></ul></li></ol><h3 id="速率单调调度">速率单调调度</h3><ul><li>优先级最高的任务是周期最短的任务，总是调度优先级最高的就绪进程。</li><li>在运行过程中，若有优先级更高的就绪进程，则<strong>剥夺</strong>当前运行进程，调度更高优先级进程运行。</li><li>CPU使用率：<span class="math inline">$U=\frac{C}{T}$</span></li><li>时间要求<ul><li>必要时间：<span class="math display">$$\sum\frac{C_i}{T_i} \leq1$$</span></li><li>精确计算：<span class="math display">$$\sum\frac{C_i}{T_i} \leqn(2^{1/n}-1)$$</span></li></ul></li></ul><h3 id="优先级逆转priority-inversion问题">优先级逆转（Priorityinversion）问题</h3><ul><li>当较高优先级的任务需要去等待一个较低优先级的任务时，会产生优先级逆转问题</li><li>解决方法：<ul><li>优先级继承：<ul><li>优先级低的任务继承与它共享同一资源的优先级较高的任务的优先级</li></ul></li><li>优先级置顶：<ul><li>优先级与资源关联，每个资源都对应一个优先级。</li><li>调度器动态地将资源的优先级分配给使用该资源的任务。</li><li>任务结束时，优先级恢复原来的值。</li></ul></li></ul></li></ul><h3 id="多处理器调度">多处理器调度</h3><ol type="1"><li>负载共享调度算法<ul><li>进程并不分配给一个特定处理器，系统维护一个全局性就绪线程队列，当一个处理器空闲时，就选择一个就绪线程占有处理器运行。</li><li>三种负载共享算法<ul><li>先来先服务</li><li>最少线程数优先</li><li>最少线程数优先（可抢占）</li></ul></li></ul></li><li>群（组）调度算法<ul><li>把一组进程在同一时间一次性调度到一组处理器上运行。</li><li>面向应用进程平均分配<ul><li>CPU资源浪费较大</li></ul></li><li>面向所有线程平均分配（加权）</li></ul></li><li>处理器专派调度算法<ul><li>给一个应用专门指派一组处理器，一旦一个应用被调度，它的每个线程被分配一个处理器并一直占有处理器运行直到整个应用运行结束。</li></ul></li><li>动态调度算法<ul><li>由操作系统和应用进程共同完成调度。分工如下：<ul><li>操作系统中的调度负责在应用进程之间划分处理器。即调度进程</li><li>应用进程中的调度负责在分配给它的处理器上执行可运行线程的子集，哪一些线程应该执行，哪一些线程应该挂起完全是应用进程确定。即调度线程</li></ul></li></ul></li></ol><h1 id="进程通信">进程通信</h1><ul><li>互斥<ul><li>要求各进程互斥地使用资源，当资源空闲时，任何进程都有资格使用该资源。</li></ul></li><li>同步<ul><li>具有同步关系的进程之间必须按某种依赖关系相互合作，在指定的依赖关系未满足前，即使资源空闲也不允许被使用。</li></ul></li><li>临界资源<ul><li>一个时刻只能被一个进程访问或使用的资源。临界资源可能是硬件设备，也可能是软件资源。</li></ul></li><li>临界区：是一段代码。进程通过这段代码访问临界资源。当一个进程进入这段代码时，不允许其他进程进入。又称临界段或互斥段。<ul><li>进入临界区：进程开始执行临界区的代码。</li><li>离开临界区：进程由执行临界区代码到不再执行临界区内的代码。</li><li>临界区基本特征：原子性、可嵌套、可中断</li></ul></li></ul><h2 id="互斥">互斥</h2><ul><li>互斥对系统的要求<ul><li>互斥进入：在所有共享相同资源或对象的临界段中，每次只能允许一个进程进入</li><li>空闲让进：当无进程在临界区中，必须让某希望进入进程立即进入临界区。</li><li>有限停留：一个进程只能在临界段内停留有限的时间。</li><li>公平进入：不能让某进程无限等待进入临界区，不会出现饥饿状况。</li><li>不受干涉：一个在非临界区停止的进程必须不干涉其他进程。</li><li>硬件无关：对进程速度和处理器的数目没有任何要求和限制。</li></ul></li><li>实现方法<ul><li>基于CPU特殊指令或硬件支持<ul><li>中断禁用</li><li>特殊指令 <figure class="shiki text"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">test&amp;set</span></span><span class="line"><span style="color: #abb2bf">test&amp;clear</span></span><span class="line"><span style="color: #abb2bf">exchange</span></span><span class="line"><span style="color: #abb2bf">fetch&amp;add</span></span></code></pre></div></div></figure></li></ul></li><li>软件方法<ul><li>Peterson算法</li><li>严格交替法</li></ul></li><li>程序设计语言支持的方法：<ul><li>管程（JAVA等语言）</li></ul></li><li>操作系统支持的方法<ul><li>信号量、消息</li></ul></li></ul></li></ul><h3 id="peterson算法">Peterson算法</h3><ul><li>假定两个互斥进程，编号为0，1</li><li>全局变量：设置进程状态数组<code>Wanted_In[2]</code>，<ul><li><code>Wanted_In[0/1] =0</code>,表示0/1号进程不在临界区，也不处于希望进入临界区的状态。</li><li><code>Wanted_In[0/1] =1</code>,表示0/1号进程处在临界区，或者处于等待进入（或即将）临界区的状态。</li></ul></li><li>全局变量：<ul><li><code>Observer</code>：标示最后一个试图（或成功）进入临界区的进程编号。</li></ul></li></ul><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> observer；</span><span style="color: #7F848E; font-style: italic">                  /*当前观察进程*/</span><span style="color: #ABB2BF">         </span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">wanted_in</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">];</span><span style="color: #7F848E; font-style: italic">               /*记录进程是否希望进入临界区*/</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">/*进入临界区函数*/</span></span><span class="line"><span style="color: #61AFEF">enter_section</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #E06C75"> </span><span style="color: #E06C75; font-style: italic">process</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">   </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> other </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">-</span><span style="color: #ABB2BF"> process;</span><span style="color: #7F848E; font-style: italic">     /* other：其它进程号*/</span></span><span class="line"><span style="color: #ABB2BF">   </span><span style="color: #E06C75">wanted_in</span><span style="color: #ABB2BF">[process] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">TRUE</span><span style="color: #ABB2BF">;</span><span style="color: #7F848E; font-style: italic">   /*本进程要进入临界区*/</span></span><span class="line"><span style="color: #ABB2BF">   observer </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> process;</span><span style="color: #7F848E; font-style: italic">          /*本进程要观察进入临界区情况*/</span></span><span class="line"><span style="color: #ABB2BF">   </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (observer </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> process </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF">  </span><span style="color: #E06C75">wanted_in</span><span style="color: #ABB2BF">[other]) {}</span><span style="color: #7F848E; font-style: italic"> /*测试进入*/</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">/*离开临界区函数*/</span></span><span class="line"><span style="color: #61AFEF">leave_section</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #E06C75"> </span><span style="color: #E06C75; font-style: italic">process</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">wanted_in</span><span style="color: #ABB2BF">[process] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">FALSE</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="信号量">信号量</h2><ul><li>基本思想<ul><li>进程要申请互斥资源，要等待信号的到来。<ul><li>如果缓存区中有信号，消耗一个信号后，占有资源</li><li>如果缓冲区中没有信号，把自己阻塞在这个信号上。<ul><li>如果在阻塞过程中，收到信号，消耗掉该信号后，进程被唤醒执行。</li><li>如果多个进程阻塞在一个信号上，有信号到来，会根据调度原则，决定哪个进程真正收到该信号。</li></ul></li></ul></li><li>进程在释放资源时，发出释放资源的信号。</li></ul></li><li>信号量的定义<ul><li>资源申请操作（<code>semWait</code>操作，<code>P</code>）（进入临界区前调用该操作）：<ul><li>信号灯的值减1；</li><li>如果其值为负值，把进程阻塞在该信号上。</li></ul></li><li>资源释放操作（<code>semSignal</code>操作，<code>V</code>）（离开临界区前调用该操作）：<ul><li>信号灯的值增1；</li><li>如果其值为负值或0，表明有进程阻塞在该信号上。从阻塞的进程中，按调度原则挑选一个唤醒。</li></ul></li></ul></li><li><code>semWait</code>和<code>semSignal</code>操作是不可中断的，一般把这种不能中断的操作称作原语。即<code>semWait</code>原语、<code>semSignal</code>原语，又称<code>P</code>，<code>V</code>操作。</li></ul><figure class="shiki text"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">/*信号量的定义*/</span></span><span class="line"><span style="color: #abb2bf">typedef struct semaphore {</span></span><span class="line"><span style="color: #abb2bf">    int   value;        /*可用资源数*/</span></span><span class="line"><span style="color: #abb2bf">    Queue  queue;           /*被阻塞进程队列*/</span></span><span class="line"><span style="color: #abb2bf">} Semaphore;</span></span><span class="line"><span style="color: #abb2bf">Semaphore s;</span></span><span class="line"><span style="color: #abb2bf">Void P(semaphore s)</span></span><span class="line"><span style="color: #abb2bf">{</span></span><span class="line"><span style="color: #abb2bf">    s.value --;</span></span><span class="line"><span style="color: #abb2bf">    If (s.value &lt; 0 ){</span></span><span class="line"><span style="color: #abb2bf">        将进程放入阻塞队列s.queue</span></span><span class="line"><span style="color: #abb2bf">        阻塞该进程,重新进程调度</span></span><span class="line"><span style="color: #abb2bf">    }</span></span><span class="line"><span style="color: #abb2bf">}</span></span><span class="line"><span style="color: #abb2bf">Void V(semaphore s)</span></span><span class="line"><span style="color: #abb2bf">{</span></span><span class="line"><span style="color: #abb2bf">    s.value ++; </span></span><span class="line"><span style="color: #abb2bf">    If (s.value &lt;= 0 ){</span></span><span class="line"><span style="color: #abb2bf">        从阻塞队列s.queue取出一进程,唤醒该进程</span></span><span class="line"><span style="color: #abb2bf">    }</span></span><span class="line"><span style="color: #abb2bf">}</span></span></code></pre></div></div></figure><h3 id="信号量实现互斥">信号量实现互斥</h3><ul><li>实现进程互斥，信号灯的取值含义：<ul><li>正值：表示还能有几个进程分配到资源（即进入临界区）。</li><li>0：表示没有待分配资源，但也没有进程在等待资源。</li><li>负值：（绝对值）等待分配资源的进程数，即阻塞的进程数。</li></ul></li></ul><figure><img src="image-30.webp" srcset="/img/loading/loading3.gif" lazyload alt="信号量实现互斥"><figcaption aria-hidden="true">信号量实现互斥</figcaption></figure><h3 id="信号量实现同步">信号量实现同步</h3><ul><li>用信号灯表示所等待的操作是否已经完成。<ul><li>用P操作表示等待其他进程协作任务完成的通知，</li><li>用V操作（向其他进程）发送协作任务完成的通知。</li><li>信号灯初始值一般为0。</li><li>一般一个进程执行P操作，另一个进程执行V操作。</li></ul></li><li>半同步和全同步<ul><li>半同步：进程a要同步等待进程b，而进程b则不必同步等待进程a。</li><li>全同步：进程a要同步等待进程b，而进程b也要同步等待进程a。</li></ul></li></ul><h4 id="生产者和消费者问题">生产者和消费者问题</h4><ul><li>问题描述：<ul><li>一群生产者，每个生产者每次生产一件产品。</li><li>一群消费者，每个消费者每次消费一件产品。</li><li>一个产品仓库（最大可暂存n个产品）。</li><li>如果仓库满，生产者暂停生产。</li><li>如果仓库空，消费者暂停消费。</li></ul></li><li>信号量设置：<ul><li><code>Buffers</code>：表示仓库（缓冲区）的空闲容量。<ul><li>生产者生产一个产品后，放入缓冲区前，对此执行wait操作</li><li>消费者消费一个产品后，对此执行signal操作</li><li>初始值为n</li></ul></li><li><code>Products</code>：表示仓库中的产品数量。<ul><li>生产者生产一个产品后，放入缓冲区对此执行signal操作</li><li>消费者消费一个产品前，对此执行wait操作</li><li>初始值为0</li></ul></li><li><code>Mutex</code>：实现对缓存区操作的互斥<ul><li><span class="math inline">1</span>：表示没有进程进行缓冲区操作</li><li><span class="math inline">0</span>：表示有一个进程正在对缓存区进行操作。</li><li><span class="math inline">−<em>m</em></span>：表示有一个进程正在对缓存区进行操作，还有m个进程在等待进入缓存区操作。初始值为1</li></ul></li></ul></li></ul><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">Semaphore Buffers</span><span style="color: #C678DD">=</span><span style="color: #ABB2BF">N;</span></span><span class="line"><span style="color: #ABB2BF">Semaphore Products</span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">Semaphore mutex＝</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">；</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">/*生产者*/</span></span><span class="line"><span style="color: #ABB2BF">Void </span><span style="color: #61AFEF">Producer</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">TRUE</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        /*生产产品*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">P</span><span style="color: #ABB2BF">(Buffers);</span><span style="color: #7F848E; font-style: italic">  /*等待缓冲区有空闲容量*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">P</span><span style="color: #ABB2BF">(mutex);</span><span style="color: #7F848E; font-style: italic">    /*进入临界区，互斥访问缓冲区*/</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        /*向缓冲区放入产品*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">V</span><span style="color: #ABB2BF">(mutex);</span><span style="color: #7F848E; font-style: italic">    /*离开临界区*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">V</span><span style="color: #ABB2BF">(Products);</span><span style="color: #7F848E; font-style: italic"> /*通知消费者有新产品可用*/</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #7F848E; font-style: italic">/*消费者*/</span><span style="color: #ABB2BF">  </span></span><span class="line"><span style="color: #ABB2BF">Void </span><span style="color: #61AFEF">Consumer</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">TRUE</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">P</span><span style="color: #ABB2BF">(Products);</span><span style="color: #7F848E; font-style: italic"> /*等待缓冲区有产品*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">P</span><span style="color: #ABB2BF">(mutex);</span><span style="color: #7F848E; font-style: italic">    /*进入临界区，互斥访问缓冲区*/</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        /*从缓冲区取出产品*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">V</span><span style="color: #ABB2BF">(mutex);</span><span style="color: #7F848E; font-style: italic">    /*离开临界区*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">V</span><span style="color: #ABB2BF">(Buffers);</span><span style="color: #7F848E; font-style: italic">  /*通知生产者有空闲容量*/</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        /*消费产品*/</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h4 id="读者写者问题">读者/写者问题</h4><ul><li>问题描述：<ul><li>若干个并发进程对数据对象进行读写的情况。</li><li>多个读操作可以并发执行（与生产/消费问题不同）。</li><li>一个写者不能与任何的读者或者其它写者同时访问数据对象</li></ul></li><li>全局变量和信号量设置：<ul><li><code>Count</code>：表示正在执行读操作的进程数目，初始值为0</li><li><code>Mutex</code>：表示是否有读者在对全局变量count进行修改，初始值为1</li><li><code>Wrt</code>：表示是否有进程在执行读或写的操作，1表示没有，0和负值表示有，初始值为1</li></ul></li></ul><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">Semaphore Count</span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">Semaphore Mutex</span><span style="color: #C678DD">=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">Semaphore Wrt</span><span style="color: #C678DD">=</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">/*读者*/</span></span><span class="line"><span style="color: #ABB2BF">Void </span><span style="color: #61AFEF">Reader</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">TRUE</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">P</span><span style="color: #ABB2BF">(Mutex);</span><span style="color: #7F848E; font-style: italic">       /*进入临界区，互斥访问Count*/</span></span><span class="line"><span style="color: #ABB2BF">        Count</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span><span style="color: #7F848E; font-style: italic">        /*增加读者计数*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (Count </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">P</span><span style="color: #ABB2BF">(Wrt);</span><span style="color: #7F848E; font-style: italic">     /*如果是第一个读者，阻止写者*/</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">V</span><span style="color: #ABB2BF">(Mutex);</span><span style="color: #7F848E; font-style: italic">       /*离开临界区*/</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        /*执行读操作*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">P</span><span style="color: #ABB2BF">(Mutex);</span><span style="color: #7F848E; font-style: italic">       /*进入临界区，互斥访问Count*/</span></span><span class="line"><span style="color: #ABB2BF">        Count</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">;</span><span style="color: #7F848E; font-style: italic">        /*减少读者计数*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (Count </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">V</span><span style="color: #ABB2BF">(Wrt);</span><span style="color: #7F848E; font-style: italic">     /*如果是最后一个读者，允许写者*/</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">V</span><span style="color: #ABB2BF">(Mutex);</span><span style="color: #7F848E; font-style: italic">       /*离开临界区*/</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">/*写者*/</span></span><span class="line"><span style="color: #ABB2BF">Void </span><span style="color: #61AFEF">Writer</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">TRUE</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">P</span><span style="color: #ABB2BF">(Wrt);</span><span style="color: #7F848E; font-style: italic">         /*进入临界区，阻止读者和写者*/</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        /*执行写操作*/</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">V</span><span style="color: #ABB2BF">(Wrt);</span><span style="color: #7F848E; font-style: italic">         /*离开临界区，允许读者和写者*/</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><ul><li>优化：公平的思路：使用写者优先实现方法，即如果写者已在等待进入，后续的读者不应该进入。</li></ul><h2 id="管程monitor">管程（Monitor）</h2><ul><li>将临界资源和访问临界资源的代码（临界区）组织到同一个数据结构（对象）中</li><li>管程的实现方式：<ul><li>高级程序设计语言，如JAVA，Pascal</li><li>程序库</li></ul></li></ul><h2 id="进程间数据交换">进程间数据交换</h2><ul><li><p>消息通信</p><figure><img src="image-31.webp" srcset="/img/loading/loading3.gif" lazyload alt="消息通信"><figcaption aria-hidden="true">消息通信</figcaption></figure></li><li><p>共享存储区</p><figure><img src="image-32.webp" srcset="/img/loading/loading3.gif" lazyload alt="共享存储区"><figcaption aria-hidden="true">共享存储区</figcaption></figure></li><li><p>管道通信</p><ul><li><p>匿名管道</p><ul><li>通过<code>pipe</code>函数创建</li><li>通过<code>read</code>和<code>write</code>函数进行读写操作</li></ul><p>输入和输出端代码分别如下 </p><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;stdio.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;unistd.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;sys/types.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;sys/stat.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;fcntl.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;string.h&gt;</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">BUFFER_SIZE</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">main</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">fds</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">buf</span><span style="color: #ABB2BF">[BUFFER_SIZE];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// for (int i=0; i&lt;BUFFER_SIZE; i++) buf[i]='0';</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">//临时数组，用于存放通信的消息</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">pipe</span><span style="color: #ABB2BF">(fds) </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">perror</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"pipe"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> inFilename</span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"testfile/local.txt"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> outFilename</span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"testfile/target.txt"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> in </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">open</span><span style="color: #ABB2BF">(inFilename, O_RDWR, </span><span style="color: #E06C75">0</span><span style="color: #D19A66">666</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> out </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">open</span><span style="color: #ABB2BF">(outFilename, O_CREAT </span><span style="color: #C678DD">|</span><span style="color: #ABB2BF"> O_TRUNC </span><span style="color: #C678DD">|</span><span style="color: #ABB2BF"> O_RDWR, </span><span style="color: #E06C75">0</span><span style="color: #D19A66">666</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">//fflush(stdout);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">ssize_t</span><span style="color: #ABB2BF"> length;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">pid_t</span><span style="color: #ABB2BF"> pid </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">fork</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(pid </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">//子进程只写，关闭读出端</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"child process </span><span style="color: #D19A66">%d</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, </span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fds</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">((length </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">read</span><span style="color: #ABB2BF">(in, buf, BUFFER_SIZE </span><span style="color: #C678DD">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)) </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"child process </span><span style="color: #D19A66">%d</span><span style="color: #98C379"> read </span><span style="color: #56B6C2">\"</span><span style="color: #D19A66">%s</span><span style="color: #56B6C2">\"</span><span style="color: #98C379"> from file</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, </span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">(), buf);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">write</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fds</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">],buf,</span><span style="color: #61AFEF">strlen</span><span style="color: #ABB2BF">(buf)</span><span style="color: #C678DD">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"child process </span><span style="color: #D19A66">%d</span><span style="color: #98C379"> write </span><span style="color: #56B6C2">\"</span><span style="color: #D19A66">%s</span><span style="color: #56B6C2">\"</span><span style="color: #98C379"> to pipe</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, </span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">(), buf);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #7F848E; font-style: italic">//将buf的内容写入管道</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">memset</span><span style="color: #ABB2BF">(buf, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">sizeof</span><span style="color: #ABB2BF">(buf));</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fds</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">//父进程只读，关闭写入端</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"parent process </span><span style="color: #D19A66">%d</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, </span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">());</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fds</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">//从管道里读数据，放入buf</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">((length </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">read</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fds</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">],buf,BUFFER_SIZE)) </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"parent process </span><span style="color: #D19A66">%d</span><span style="color: #98C379"> read </span><span style="color: #56B6C2">\"</span><span style="color: #D19A66">%s</span><span style="color: #56B6C2">\"</span><span style="color: #98C379"> from pipe</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, </span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">(), buf);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">write</span><span style="color: #ABB2BF">(out, buf, </span><span style="color: #61AFEF">strlen</span><span style="color: #ABB2BF">(buf));</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"parent process </span><span style="color: #D19A66">%d</span><span style="color: #98C379"> write </span><span style="color: #56B6C2">\"</span><span style="color: #D19A66">%s</span><span style="color: #56B6C2">\"</span><span style="color: #98C379"> to file</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, </span><span style="color: #61AFEF">getpid</span><span style="color: #ABB2BF">(), buf);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">memset</span><span style="color: #ABB2BF">(buf, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">sizeof</span><span style="color: #ABB2BF">(buf));</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fds</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">]);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p></li><li><p>命名管道（FIFO）</p><ul><li>通过<code>mkfifo</code>命令创建命名管道</li><li>通过<code>open</code>函数打开命名管道进行读写操作</li></ul><p></p><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;stdio.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;unistd.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;fcntl.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;stdlib.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;string.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;errno.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;sys/types.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;sys/stat.h&gt;</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">BUFFER_SIZE</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">128</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">main</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #ABB2BF">file </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"testfile/fifo.txt"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> fd </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">open</span><span style="color: #ABB2BF">(file, O_WRONLY);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(fd</span><span style="color: #C678DD">&lt;</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">perror</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"open failed"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"open fifo.txt success! </span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> inFilename</span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"testfile/local.txt"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> in </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">open</span><span style="color: #ABB2BF">(inFilename, O_RDWR, </span><span style="color: #E06C75">0</span><span style="color: #D19A66">666</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">umask</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">ssize_t</span><span style="color: #ABB2BF"> ret </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mkfifo</span><span style="color: #ABB2BF">(file, </span><span style="color: #E06C75">0</span><span style="color: #D19A66">777</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(ret </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(errno </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> EEXIST)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">perror</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"mkfifo failed."</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"mkfifo success.</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">buf</span><span style="color: #ABB2BF">[BUFFER_SIZE];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">((ret </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">read</span><span style="color: #ABB2BF">(in, buf, BUFFER_SIZE </span><span style="color: #C678DD">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)) </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        ret </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">write</span><span style="color: #ABB2BF">(fd, buf, </span><span style="color: #61AFEF">strlen</span><span style="color: #ABB2BF">(buf));</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(ret</span><span style="color: #C678DD">&lt;</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">perror</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"write failed.</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"read from input and write to buffer: </span><span style="color: #D19A66">%s</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, buf);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">memset</span><span style="color: #ABB2BF">(buf, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">sizeof</span><span style="color: #ABB2BF">(buf));</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"read closed.</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">(in);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">(fd);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure> <figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;stdio.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;unistd.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;fcntl.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;stdlib.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;string.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;errno.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;sys/types.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;sys/stat.h&gt;</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">BUFFER_SIZE</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">128</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">main</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #ABB2BF">file </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"testfile/fifo.txt"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> fd </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">open</span><span style="color: #ABB2BF">(file, O_RDONLY);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(fd</span><span style="color: #C678DD">&lt;</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">perror</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"open failed"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"open fifo.txt success! </span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">umask</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">ssize_t</span><span style="color: #ABB2BF"> ret </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mkfifo</span><span style="color: #ABB2BF">(file, </span><span style="color: #E06C75">0</span><span style="color: #D19A66">777</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(ret </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(errno </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> EEXIST)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">perror</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"mkfifo failed."</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"mkfifo success.</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">buf</span><span style="color: #ABB2BF">[BUFFER_SIZE];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> outFilename</span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"testfile/target.txt"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> out </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">open</span><span style="color: #ABB2BF">(outFilename, O_CREAT </span><span style="color: #C678DD">|</span><span style="color: #ABB2BF"> O_TRUNC </span><span style="color: #C678DD">|</span><span style="color: #ABB2BF"> O_RDWR, </span><span style="color: #E06C75">0</span><span style="color: #D19A66">666</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">sleep</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">memset</span><span style="color: #ABB2BF">(buf, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">sizeof</span><span style="color: #ABB2BF">(buf));</span></span><span class="line"><span style="color: #ABB2BF">        ret </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">read</span><span style="color: #ABB2BF">(fd, buf, BUFFER_SIZE</span><span style="color: #C678DD">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(ret</span><span style="color: #C678DD">&lt;</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">perror</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"read failed.</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF">(ret</span><span style="color: #C678DD">==</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"write closed.</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">write</span><span style="color: #ABB2BF">(out, buf, </span><span style="color: #61AFEF">strlen</span><span style="color: #ABB2BF">(buf));</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">printf</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"read from buffer and write to output: </span><span style="color: #D19A66">%s</span><span style="color: #56B6C2">\n</span><span style="color: #98C379">"</span><span style="color: #ABB2BF">, buf);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">(out);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">close</span><span style="color: #ABB2BF">(fd);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p></li></ul></li><li><p>Socket通信</p></li></ul><h2 id="进程死锁">进程死锁</h2><ul><li>资源分配图（Resource allocation graph）<ul><li>每个资源和进程用节点表示</li><li>从进程到资源的边表示请求但还没授权；</li><li>从资源到进程的边表示已经授权；</li><li>圆点表示资源的实例。</li></ul><figure><img src="image-33.webp" srcset="/img/loading/loading3.gif" lazyload alt="资源分配图"><figcaption aria-hidden="true">资源分配图</figcaption></figure></li></ul><h3 id="死锁的产生条件">死锁的产生条件</h3><ul><li>必要条件：<ul><li>互斥使用：（资源）每次只能允许一个进程占有和使用，其它申请该资源的进程被阻塞。</li><li>保持并等待：当进程等待分配给它新的资源时，保持占有已分配的资源。</li><li>不可剥夺 ：不能强迫回收进程占有的未使用完的资源。</li></ul></li><li>充分条件：<ul><li>循环等待：存在一个闭合的进程─资源链</li></ul></li></ul><h3 id="应对死锁的方法">应对死锁的方法</h3><h4 id="死锁预防破环死锁产生的条件">死锁预防：破环死锁产生的条件</h4><ol type="1"><li>互斥占用：无法利用</li><li>保持等待：<ul><li>静态分配策略：系统一次申请它所要用到的资源，如果能满足就分配，如果不能满足，一个也不分配。</li></ul></li><li>不可剥夺：<ul><li>主动释放</li><li>强制回收</li></ul></li><li>循环等待：<ul><li>资源排序：采用有序资源使用法可以防止循环等待条件。如果一个进程已经分配了类型R的资源，那么以后它只能申请在资源顺序表中排在R后面的资源类型。</li></ul></li></ol><h4 id="死锁避免允许3个必要条件通过一定的策略使系统达不到死锁点状态">死锁避免：允许3个必要条件，通过一定的策略使系统达不到死锁点(状态)。</h4><ul><li>银行家算法<ul><li><span class="math inline"><em>R</em><em>e</em><em>s</em><em>o</em><em>u</em><em>r</em><em>c</em><em>e</em> = <em>R</em> = (<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, ..., <em>R</em><sub><em>m</em></sub>)</span>，系统中每种资源的总量；</li><li><span class="math inline"><em>A</em><em>v</em><em>a</em><em>i</em><em>l</em><em>a</em><em>b</em><em>l</em><em>e</em> = <em>V</em> = (<em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, ..., <em>V</em><sub><em>m</em></sub>)</span>，尚未分配的每种资源的数量；</li><li><span class="math inline">$Claim = C =\left[\begin{array}{ccc}C_{11} &amp; C_{12} &amp; \ldots &amp;C_{1m}\\C_{21} &amp; C_{22} &amp; \ldots &amp; C_{2m}\\\vdots &amp;\vdots &amp; \ddots &amp; \vdots\\C_{n1} &amp; C_{n2} &amp; \ldots &amp;C_{nm}\end{array}\right]$</span>，<span class="math inline"><em>C</em><sub><em>i</em><em>j</em></sub></span>表示进程i对资源j的需求数量；</li><li><span class="math inline">$Allocation = A=\left[\begin{array}{ccc}A_{11} &amp; A_{12} &amp; \ldots &amp;A_{1m}\\A_{21} &amp; A_{22} &amp; \ldots &amp; A_{2m}\\\vdots &amp;\vdots &amp; \ddots &amp; \vdots\\A_{n1} &amp; A_{n2} &amp; \ldots &amp;A_{nm}\end{array}\right]$</span>，<span class="math inline"><em>A</em><sub><em>i</em><em>j</em></sub></span>表示进程i已经分配了j类资源的数量。</li><li>必须成立的条件<ul><li><span class="math inline">$R_{j}=V_{j}+\sum_{i=1}^{N}A_{ij}$</span>，每类资源的未分配和已分配之和固定</li><li><span class="math inline"><em>C</em><sub><em>i</em><em>j</em></sub> ≤ <em>R</em><sub><em>i</em></sub></span>,对所有的 <span class="math inline"><em>i</em></span>, <span class="math inline"><em>j</em></span>请求受限</li><li><span class="math inline"><em>A</em><sub><em>i</em><em>j</em></sub> ≤ <em>C</em><sub><em>i</em><em>j</em></sub></span>,对所有的 <span class="math inline"><em>i</em></span>, <span class="math inline"><em>j</em></span> 获得小于等于请求</li></ul></li><li>仅当 <span class="math display">$$R_{j} \geq C_{(n+1) j} +\sum_{l=1}^{n} C_{i l j} \text {, 对所有的 } j$$</span> 成立时,才启动进程 <span class="math inline"><em>P</em><sub><em>n</em> + 1</sub></span>。</li></ul></li><li>缺点: 该策略假设了最坏情况,即所有进程同时满足最大资源需求时才启动。</li><li>两个步骤：<ul><li>申请者申请资源时，需要同时把未来的资源最大需求量告诉系统。</li><li>如果对资源的分配可能会导致死锁，就暂不允许进一步为进程分配资源。</li></ul></li></ul><h4 id="死锁检测">死锁检测</h4><ul><li>基本思路：<ul><li>使用死锁检测，只要可能，就将所申请的资源分配给进程。</li><li>操作系统定期地执行检查算法，以判断是否存在条件4的循环等待链。</li><li>待检测出死锁时，再想办法解决死锁。</li></ul></li><li>检测的时机：<ul><li>可以在进程申请资源时进行检测</li><li>可以在死锁解除过程中进行检测</li></ul></li><li>Coffman算法<ul><li>基本数据结构：<ul><li>进程等待资源矩阵Q：指明每个进程对每种资源的需求</li><li>资源占用矩阵Allocation：表明每个进程已经占用的每种资源的数量。</li><li>剩余资源向量Available：表明所剩余的每种资源的数量</li><li>临时空闲资源向量W：初始值等于Available</li></ul></li><li>步骤：<ul><li>标记Allocation矩阵中行全为零的进程</li><li>初始化W，W=available</li><li>查找下标i，使进程i当前未标记且Q的第i行小于等于W。</li><li>如果找不到这样的行，终止算法</li><li>如果找到这样的行，标记进程i，并把Allocation中相应的行加到W，返回步骤3。</li></ul></li><li>算法结束时，如果有未标记的进程，则<strong>每个未标记的进程都是可能死锁的进程</strong>。</li></ul></li></ul><figure><img src="image-34.webp" srcset="/img/loading/loading3.gif" lazyload alt="应对死锁"><figcaption aria-hidden="true">应对死锁</figcaption></figure><h4 id="死锁解除">死锁解除</h4><ul><li>强迫撤销所有的死锁进程。</li><li>将每一个死锁进程退回到一些以前定义的“检查点”，再启动进程。<ul><li>需要系统支持进程的回退和重启动机制。</li></ul></li><li>逐个撤销死锁进程，直至死锁不存在。<ul><li>终止死锁进程的次序应当基于最小代价的标准。</li><li>每终止一个进程后就调用死锁检测算法，以判定死锁是否还存在。</li></ul></li><li>相继地剥夺进程所占的资源，直至死锁不再存在。同样，剥夺资源的次序应基于成本方面的考虑。<ul><li>被剥夺资源的进程必需回退到获得该资源之前的某个执行点上。</li></ul></li><li>成本核算因素<ul><li>目前为止消耗的处理器时间最少</li><li>目前为止产生的输出最少</li><li>预计剩余时间最长</li><li>目前为止分配的资源总量最少</li><li>优先级最低</li></ul></li></ul><h3 id="哲学家就餐问题">哲学家就餐问题</h3><ul><li>问题描述<ul><li>n位哲学家围坐圆桌</li><li>n把筷子</li><li>m个盘子</li><li>每个哲学家需要同时使用2把筷子和1个盘子才能用餐</li></ul></li><li>解决方法<ul><li>如果无法拿到右筷子，则释放左筷子，随机等待一段时间后再进餐。<ul><li>在大多数情况下可行，不能保证万无一失</li></ul></li><li>设计一个信号量，使得某一个时刻只能有4个哲学家进餐</li></ul></li></ul><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">/* program diningphilosophers */</span></span><span class="line"><span style="color: #ABB2BF">semaphore </span><span style="color: #E06C75">fork</span><span style="color: #ABB2BF">[n];</span></span><span class="line"><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i</span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">n; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">fork</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #ABB2BF">semaphore plate </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">min</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">n</span><span style="color: #C678DD">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> m</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">philosopher</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #E06C75"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">think</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">wait</span><span style="color: #ABB2BF">(plate);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">wait</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fork</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">wait</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fork</span><span style="color: #ABB2BF">[(i</span><span style="color: #C678DD">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span><span style="color: #C678DD">%</span><span style="color: #ABB2BF">n]);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">eat</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">signal</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fork</span><span style="color: #ABB2BF">[(i</span><span style="color: #C678DD">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span><span style="color: #C678DD">%</span><span style="color: #ABB2BF">n]);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">signal</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fork</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">signal</span><span style="color: #ABB2BF">(plate);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h1 id="设备管理">设备管理</h1><h2 id="设备概述">设备概述</h2><figure><img src="image-35.webp" srcset="/img/loading/loading3.gif" lazyload alt="计算机常见IO设备"><figcaption aria-hidden="true">计算机常见IO设备</figcaption></figure><ul><li>设备分类<ul><li>按照数据传输方式分类<ul><li>字符设备：数据以字符为单位传输，如键盘、鼠标、打印机等。</li><li>块设备：数据以块为单位传输，如硬盘、光盘等。</li><li>流设备：数据以连续流的方式传输，如网络接口、串口等。</li></ul></li><li>按照访问方式分类<ul><li>顺序访问设备：只能按顺序访问数据，如磁带。</li><li>随机访问设备：可以随机访问数据，如硬盘。</li></ul></li><li>按照功能分类<ul><li>输入设备：如键盘、鼠标、扫描仪等。</li><li>输出设备：如显示器、打印机等。</li><li>输入输出设备：如硬盘、网络接口等。</li></ul></li><li>按存在形式上（OS角度）：<ul><li>物理设备</li><li>逻辑设备</li></ul></li><li>按资源属性（OS管理角度）：<ul><li>共享设备</li><li>独占设备</li><li>虚拟设备</li></ul></li></ul></li><li>设备管理层次关系<ul><li>底层通信（中断处理）：<ul><li>实现软件和硬件设备的通信。</li></ul></li><li>设备驱动：<ul><li>功能：接受来自上层的抽象操作请求，并负责操作的具体实施。</li><li>主要组成：与设备打交道的软件、共享支持、缓冲区支持等。</li></ul></li><li>对用户层的I/O接口：<ul><li>每个I/O调用接口对应具体的设备抽象操作。</li></ul></li><li>使用设备的用户级程序：<ul><li>通过调用所提供的接口来实现对设备的使用或控制。</li></ul></li></ul></li></ul><h2 id="中断响应">中断响应</h2><ul><li>设备向中断控制器发送中断信号</li><li>中断控制器比较各个中断的优先级。如果有未被屏蔽的中断，中断控制器向CPU发送中断信号。</li><li>CPU现场保存后，通过询问中断控制器，确定中断源（中断号）。</li><li>通过中断号，找到对应的中断处理程序。</li><li>中断处理结束后，<ul><li>原运行在核心态：恢复现场，转向被中断的任务继续执行。</li><li>原运行在用户态：检查调度标志、信号设置标志（runrun）。如果被设置，进行相应处理。否则恢复现场，继续执行。</li></ul></li></ul><h2 id="设备的四类资源">设备的四类资源</h2><ul><li>I/O地址<ul><li>需要把单个设备的I/O编址映射到系统全局编址。</li></ul></li><li>I/O中断请求<ul><li>中断控制器支持的中断数量有限，每个进行了编号。设备接入系统后，需要分配中断号。</li></ul></li><li>I/O通道<ul><li>I/O通道是一种<strong>硬件</strong>设施，带有专用处理器的，可以独立地完成系统处理器交付的I/O操作任务</li><li>通道具有自己专门的指令集，即通道指令。通道执行来自处理器的通道程序，完成后只需向系统处理器发出中断，请求结束。</li></ul></li><li>DMA数据传输通道<ul><li>内存和I/O设备之间的自动化数据通路，在主存和I/O设备之间成块传送数据过程中，不需要CPU干预，CPU资源的利用率再次得到提高。</li><li>DMA不仅设有中断机构，而且，还增加了DMA传输控制机构（类似于CPU）。</li></ul></li><li>I/O缓冲区<ul><li>缓存区需求：<ul><li>提高CPU和外设的并行度</li><li>缓解外设速度慢的瓶颈</li></ul></li><li>缓冲区分类：<ul><li>硬件缓冲：有些设备中会包含专门的硬件寄存器等用于缓冲。</li><li>软件缓冲：直接在主存中。<ul><li>单缓冲：一个缓冲，外设和CPU互斥进行操作。</li><li>双缓冲：设置两个缓冲区，交替使用。</li><li>循环缓冲：类似于循环队列，依次使用。</li><li>缓冲池：系统维护一组大小相同的缓冲区，进程和设备按需要申请，使用完后重新归入缓冲池中。</li></ul></li></ul></li></ul></li></ul><h2 id="设备分配">设备分配</h2><ul><li><p>设备分配表</p><ul><li>设备控制表（device control table，DCT）<ul><li>一张DCT对应一个设备</li><li>有指向COCT的指针</li></ul><figure><img src="image-36.webp" srcset="/img/loading/loading3.gif" lazyload alt="DCT"><figcaption aria-hidden="true">DCT</figcaption></figure></li><li>控制器控制表（controller control table，COCT）<ul><li>一张COCT对应一个控制器</li><li>有指向CHCT的指针</li></ul></li><li>通道控制表（channel control table，CHCT）<ul><li>一张CHCT对应一个通道</li><li>有指向COCT的指针</li></ul></li><li>系统设备表（system device table，SDT）<ul><li>一张SDT对应一个系统</li><li>有指向DCT的指针</li></ul></li></ul><p><img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload></p></li><li><p>设备分配方式</p><ul><li>静态分配<ul><li>用于对独占设备的分配，在用户作业开始执行前由系统一次性分配该作业所要求的全部设备。</li><li>静态分配方式不会出现死锁，但设备的利用率低。因此，静态分配方式不符合分配的总原则。</li></ul></li><li>动态分配<ul><li>在进程执行过程中根据执行需要进行。</li><li>动态分配方式有利于提高设备的利用率，但如果分配算法使用不当，则有可能造成进程死锁。</li></ul></li></ul></li></ul><h2 id="上层统一接口">上层统一接口</h2><ul><li>统一标识，统一操作</li><li>操作：抽象为文件名-文件操作</li><li>主设备号：可以找到相应的设备驱动程序</li><li>次设备号：指定具体的物理设备</li></ul><h2 id="设备驱动程序">设备驱动程序</h2><ul><li>设备驱动程序是操作系统内核的一部分，负责与硬件设备进行通信。</li><li>设备驱动程序的主要功能包括：<ul><li>初始化设备：在设备启动时进行初始化设置。</li><li>处理I/O请求：接收来自上层的I/O请求，并将其转换为设备可以理解的格式。</li><li>处理中断：响应设备发出的中断信号，处理设备状态变化。</li><li>错误处理：处理设备操作中的错误情况。</li></ul></li></ul><h1 id="外部存储">外部存储</h1><h2 id="hdd">HDD</h2><h3 id="磁盘结构">磁盘结构</h3><figure><img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload alt="磁盘结构"><figcaption aria-hidden="true">磁盘结构</figcaption></figure><ul><li>磁盘时延 = 寻道时间 + 旋转时间 + 传输时间 + 控制器负载<ul><li>寻道时间：依赖移动臂移动速度，磁道的位置 （Ts）</li><li>旋转时间：依赖磁盘转速，扇区距离磁头的距离 （平均：1/2r）</li><li>传输时间：依赖磁盘的带宽，需求的数据总量（T=b/rN）<ul><li>b表示要传送的字节数，N表示一个磁道中的字节数，r表示旋转速度</li></ul></li><li>总的存取时间为：<span class="math inline">$T = Ts + \frac{1}{2r} +\frac{b}{rN}$</span></li></ul></li><li>应对延迟的方法<ul><li>缓存<ul><li>文件访问级缓存</li></ul></li><li>RAM磁盘<ul><li>保留部分RAM作为高速文件系统</li></ul></li><li>RAID<ul><li>并行访问（容错）</li></ul></li><li>智能调度算法<ul><li>读写头调度</li><li>元信息布置</li></ul></li></ul></li><li>磁盘高速缓存<ul><li><strong>主存</strong>中的一块空间</li><li>提高进程访问磁盘的速度</li><li>粒度与扇区大小相等</li><li>替换策略<ul><li>最近最少使用算法（LRU）</li><li>最不常用算法（LFU）</li><li>基于频率的替换算法</li></ul></li></ul></li></ul><h4 id="磁盘调度">磁盘调度</h4><ol type="1"><li>先来先服务（FCFS）<ul><li>按照请求到达的顺序处理磁盘I/O请求。</li><li>优点：<ul><li>简单易实现</li><li>公平</li></ul></li><li>缺点：<ul><li>可能导致长时间的寻道时间，尤其是在请求分布不均匀时</li><li>磁头移动幅度大</li></ul></li><li>适合较轻负载的系统</li></ul><figure><img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload alt="FCFS"><figcaption aria-hidden="true">FCFS</figcaption></figure></li><li>最短寻道时间优先（SSTF）<ul><li>选择距离当前磁头位置最近的请求进行处理。</li><li>优点：<ul><li>寻道时间较短，服务效率较高，服务平均等待时间较短。</li><li>提供比FIFO更高的效率</li></ul></li><li>缺点：<ul><li>公平性差，可能导致饥饿现象，即某些请求长时间得不到处理</li><li>对于远离当前磁头位置的请求，等待时间较长</li><li>适合中度负载的系统</li></ul></li></ul><figure><img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload alt="SSTF"><figcaption aria-hidden="true">SSTF</figcaption></figure></li><li>电梯算法（SCAN）<ul><li>磁头从一端移动到另一端，处理所有请求，然后反向移动。</li><li>算法特点:<ul><li>每个请求的等待时间不均匀，且平均等待时间长。</li><li>如到达另一端反向时，将扫描的是刚刚扫描过的磁道，这里的请求显然少，而另一端的请求多，且等待服务的时间长。</li></ul></li><li>算法优化：<ul><li>磁头并不是每次扫描都移动到最远的磁道上，一旦在当前方向上前面没有请求，就开始反向移动。</li></ul></li><li>比较适合磁盘负载较重的系统。</li></ul><figure><img src="image-41.webp" srcset="/img/loading/loading3.gif" lazyload alt="SCAN"><figcaption aria-hidden="true">SCAN</figcaption></figure></li><li>循环扫描算法（C-SCAN）<ul><li>磁头从一端移动到另一端，处理所有请求，然后返回到起始位置，继续处理请求。</li></ul><figure><img src="image-42.webp" srcset="/img/loading/loading3.gif" lazyload alt="C-SCAN"><figcaption aria-hidden="true">C-SCAN</figcaption></figure></li><li>PRI（基于进程优先级的调度）</li><li>LIFO（后进先出）<ul><li>局部性最好，资源利用率最高。</li></ul></li><li>N-step-SCAN<ul><li>避免磁头臂粘性</li><li>把请求分为长度为N的多个队列；一次处理一个队列；新到的请求加到其他队列中。</li><li>特性：N较大时，等价于SCAN；N=1时，等价于FIFO</li></ul></li><li>F-SCAN<ul><li>N=2时的N-step-SCAN</li></ul></li></ol><ul><li>OpenEuler的磁盘调度器<ul><li>电梯调度器(Elevator)</li><li>时限IO调度器（deadline IO scheduler）</li><li>预期IO调度器（anticipatory IO scheduler）</li></ul></li></ul><h4 id="raid">RAID</h4><ul><li>将文件数据分条（striped）到多个磁盘上</li><li>通过并行提高性能</li><li>通过冗余提高可靠性</li></ul><p>和 <em>计算机组成与系统结构</em> 课程笔记结合食用更佳哦。</p><p><a href="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/#%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97raid" name="/img/avatar/avatar.webp" class="LinkCard">计算机组成与系统结构</a></p><h2 id="ssd">SSD</h2><ul><li>SSD（Solid StateDrive）是一种基于闪存技术的存储设备，具有更快的读写速度和更低的延迟。</li><li>SSD没有机械移动部件，因此更耐冲击，可靠性更高。</li><li>SSD的缺点包括价格较高和写入次数有限。</li><li>工作特性：<ul><li>闪存块不能覆盖写：必须先擦除整个块才能写入新数据。</li><li>闪存块寿命有限</li><li>闪存快存在读干扰</li><li>闪存块可能出现坏块</li><li>垃圾回收<ul><li>SSD会定期执行垃圾回收操作，将无效数据块合并，释放空间。</li></ul></li><li>写放大<ul><li>写入以块（block）为单位进行，可能导致实际写入的数据量大于请求写入的数据量。</li><li>擦除以页（page）为单位进行，写入以块（block）为单位进行。</li></ul></li></ul></li><li>优势<ul><li>性能好</li><li>功耗低</li><li>防震</li><li>低噪声</li><li>体积小</li></ul></li><li>缺点<ul><li>价格高</li></ul></li></ul><h1 id="文件系统">文件系统</h1><h2 id="文件系统目标和要求">文件系统目标和要求</h2><ul><li>目标：方便用户管理自己的数据资源</li><li>基本要求<ul><li>文件按名存储</li><li>文件有序组织，文件名分层次管理</li><li>如支持树形目录结构</li><li>操作简单，存取效率高。</li></ul></li><li>其它要求：<ul><li>支持多用户系统，多用户能够共享同一个磁介质。</li><li>有一定的安全性保证，最好能进行数据恢复。</li><li>存储空间的利用率高</li></ul></li></ul><h2 id="文件系统概念">文件系统概念</h2><ul><li>文件：<ul><li>由文件名字标识的一组相关信息的集合。文件名是字母或数字组成的字母数字串</li></ul></li><li>文件系统：<ul><li>软件观点：操作系统中，为用户和应用程序管理文件的系统软件集合。</li><li>存储格式观点：文件系统是文件在存储介质上保存和管理相关的约定。在操作系统中，这种约定的实现也被称为文件系统。一种相关约定就对应一种文件系统，所以目前存在多种文件系统：FAT，FAT32，NTFS，EXT2等。</li></ul></li><li>操作系统和文件系统<ul><li>早期：一个操作系统一般都支持一种文件系统。在设计操作系统时，常常会专门为此设计一种文件系统。</li><li>目前：为实现文件和文件系统共享，一个操作系统除支持为它设计的文件系统外，还可能支持其他文件系统。如Linux支持Ext2，FAT等。</li></ul></li><li>文件类型<ul><li>普通文件：即前面所讨论的存储在外存设备上的数据文件。</li><li>目录文件：文件在管理普通数据文件时，需要保存其相应的文件和属性，这些属性以目录文件的形式存储在磁盘中。</li><li>块设备文件：在unix/Linux等操作系统中，对应于磁盘、光盘或磁带等块设备的文件。</li><li>字符设备文件：在unix/Linux等操作系统中，对应于终端、打印机等字符设备的文件。</li></ul></li><li>文件属性<ul><li>文件的类型属性：如普通文件、目录文件、系统文件、隐式文件、设备文件等。</li><li>文件的保护属性：如可读、可写、可执行、可创建、可删除等。</li><li>创建者属性</li><li>创建和访问时间属性</li><li>文件大小</li></ul></li><li>文件的逻辑组织方式<ul><li>堆文件</li><li>顺序文件</li><li>索引顺序文件</li><li>索引文件</li><li>散列文件</li></ul></li></ul><h2 id="文件存储资源分配和磁盘空闲空间管理策略">文件存储资源分配和磁盘空闲空间管理策略</h2><h3 id="分配策略">分配策略</h3><ul><li>静态分配（预分配）<ul><li>在文件创建时就分配好所需的连续的存储空间。</li><li>优点：访问速度快，文件存储连续。</li><li>缺点：无法预知文件的未来大小，可能会出现分区浪费和预留分区的大小不够，难以动态调整。</li></ul></li><li>动态分配<ul><li>在使用时，按文件大小分配磁盘空间。</li><li>一般占有不连续的磁盘块。</li></ul></li></ul><h3 id="分区大小">分区大小</h3><ul><li>可变长、连续大分区<ul><li>文件访问性能高。无内部碎片</li><li>难于重复使用存储空间。有外部碎片</li><li>分配方法：<ul><li>首次适应</li><li>最佳适应</li><li>循环首次适应</li></ul></li></ul></li><li>块（固定大小）<ul><li>灵活性强、不一定相邻</li><li>管理较复杂</li></ul></li></ul><h3 id="文件存储方式">文件存储方式</h3><ol type="1"><li>连续分配<ul><li>一个文件占用磁盘上的一系列连续数据块</li><li>初始块号以及占用的块数量放在目录项中（例如，FCB）</li><li>优点<ul><li>速度快 – 可以实现最小寻道时间和磁头移动</li><li>方便地访问文件中的任何块</li></ul></li><li>缺点<ul><li>类似于动态存储分配策略<ul><li>外部碎片 – 可以压缩</li></ul></li><li>文件增长困难<ul><li>可以找一个大的连续块，并搬迁文件的位置</li></ul></li></ul></li></ul><figure><img src="image-44.webp" srcset="/img/loading/loading3.gif" lazyload alt="连续分配"><figcaption aria-hidden="true">连续分配</figcaption></figure></li><li>链接分配<ul><li>每一个数据块包含一个指向下一个数据块的指针</li><li>查找时间复杂度为 <span class="math inline"><em>O</em>(<em>n</em>)</span> , <span class="math inline"><em>n</em></span> 是文件的大小</li><li>指针的损坏能造成整个文件的丢失</li></ul><figure><img src="image-43.webp" srcset="/img/loading/loading3.gif" lazyload alt="链接表"><figcaption aria-hidden="true">链接表</figcaption></figure></li><li>索引分配<ul><li>一个索引块包含一些指向数据块的指针</li><li>优点<ul><li>支持随机读写</li><li>可靠性提高</li></ul></li><li>缺点：<ul><li>二次访问，性能不高</li><li>需要额外空间来保存索引节点</li></ul></li><li>索引节点大小如何确定？<ul><li>大索引节点：小文件时浪费空间</li><li>小索引节点：无法支持大文件</li></ul></li></ul><figure><img src="image-45.webp" srcset="/img/loading/loading3.gif" lazyload alt="索引分配"><figcaption aria-hidden="true">索引分配</figcaption></figure></li></ol><h3 id="空闲空间管理">空闲空间管理</h3><ol type="1"><li>位图法<ul><li>使用位图来表示磁盘块的使用情况</li><li>每个磁盘块对应一个位，0表示空闲，1表示已分配</li><li>优点：简单、易于实现</li><li>缺点：需要额外的存储空间来保存位图</li></ul></li><li>链接表法<ul><li>使用链表来管理空闲块</li><li>每个空闲块包含指向下一个空闲块的指针</li><li>优点：节省空间，动态分配</li><li>缺点：查找时间较长，指针损坏可能导致内存泄漏</li></ul></li><li>索引法<ul><li>使用索引块来管理空闲块</li><li>索引块包含指向空闲块的指针</li><li>优点：支持随机访问，查找时间较短</li><li>缺点：需要额外的存储空间来保存索引块</li></ul></li></ol><figure><img src="image-46.webp" srcset="/img/loading/loading3.gif" lazyload alt="空闲空间管理"><figcaption aria-hidden="true">空闲空间管理</figcaption></figure><h3 id="fat文件系统">FAT文件系统</h3><ul><li>采用链接分配方式</li><li>每个文件的目录项中包含一个指向FAT表的指针<ul><li>FAT表内容：<ul><li>位图法记录空闲块</li><li>链表法记录文件数据地址</li></ul></li></ul></li><li>FAT12<ul><li>FAT entry size: 12bits：可支持4K个表项</li><li>如果cluster大小为32K，则可支持最大磁盘容量：128M</li></ul></li><li>FAT16<ul><li>FAT entry size: 16bits：可支持表项数：64K</li><li>如果cluster大小为 32K，则可支持最大磁盘容量2G</li></ul></li><li>FAT32<ul><li>结构和FAT12/16完全不同</li><li>FAT 表项大小32bits，28bit用于保存cluster号</li><li>可支持最大磁盘容量: (2**28)*32K=8T</li></ul></li></ul><h2 id="目录结构">目录结构</h2><ul><li>目录文件的内容<ul><li>目录下所有文件（含子目录）的属性信息：文件名，文件属性，文件内容存储的位置。</li><li>每个文件对应的信息成为一个目录项。也就是说目录文件的内容是目录项的集合。</li></ul></li><li>目录项的内容<ul><li>基本信息<ul><li>文件名：在一个特定的目录中具有唯一性。</li><li>文件类型：例如文本文件，二进制文件，目标模块等。</li><li>文件组织：系统所支持的不同组织形式。</li></ul></li><li>存储信息<ul><li>地址信息：文件存放在磁盘的物理地址（例如：柱面号、磁道号或在磁盘上的块号）。两种方式：<ul><li>起始地址</li><li>扇区地址数组</li></ul></li><li>文件的大小，以字节、字或块计。</li><li>分配大小：文件的最大尺寸</li></ul></li><li>存取控制信息<ul><li>文件主：拥有文件的控制权。文件主能授予和取消其他用户对文件的存取权和改变这些权限。</li><li>访问控制：权限用户的口令和用户名等</li><li>允许的操作：控制读、写、执行和在网上的传输等。</li></ul></li><li>使用信息<ul><li>创建日期：文件首次存放在目录中的时间。</li><li>读时间：最后一次读文件的时间。</li><li>修改时间：最后一次更新、插入或删除的时间。</li><li>备份时间：文件最后一次备份到其他介质的时间。</li></ul></li></ul></li><li>间接式访问：如果对目录文件的属性进行修改，那么与该目录中文件的内容没有关系，实际上是：<strong>修改上级目录文件的内容</strong>。</li><li>目录结构<ul><li>线性结构</li><li>Hash 表</li><li>树</li></ul></li></ul><h2 id="流文件操作与系统调用间的关系">流文件操作与系统调用间的关系</h2><figure><img src="image-47.webp" srcset="/img/loading/loading3.gif" lazyload alt="流文件操作与系统调用间的关系"><figcaption aria-hidden="true">流文件操作与系统调用间的关系</figcaption></figure><h2 id="unix文件系统">UNIX文件系统</h2><h3 id="unix文件索引结构">UNIX文件索引结构</h3><p>UNIX索引节点如下</p><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> dinode { </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">ushort</span><span style="color: #ABB2BF">       di_mode；</span><span style="color: #7F848E; font-style: italic">      // 文件控制模式</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">short</span><span style="color: #ABB2BF">        di_nlink；</span><span style="color: #7F848E; font-style: italic">     // 文件的链接数</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">ushort</span><span style="color: #ABB2BF">       di_uid；</span><span style="color: #7F848E; font-style: italic">       // 文件主用户标识数</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">ushort</span><span style="color: #ABB2BF">       di_gid；</span><span style="color: #7F848E; font-style: italic">       // 文件主同组用户组标识数</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">off_t</span><span style="color: #ABB2BF">        di_size；</span><span style="color: #7F848E; font-style: italic">      // 文件长度，以字节为单位</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF">         </span><span style="color: #E06C75">di_addr</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">40</span><span style="color: #ABB2BF">]；</span><span style="color: #7F848E; font-style: italic">  // 地址索引表，存放文件的盘块号</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">time_t</span><span style="color: #ABB2BF">       di_atime；</span><span style="color: #7F848E; font-style: italic">     // 文件最近一次访问时间</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">time_t</span><span style="color: #ABB2BF">       di_mtime；</span><span style="color: #7F848E; font-style: italic">     // 文件最近一次修改时间</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">time_t</span><span style="color: #ABB2BF">       di_ctime；</span><span style="color: #7F848E; font-style: italic">     // 文件创建时间</span></span><span class="line"><span style="color: #ABB2BF">} dinode;</span></span></code></pre></div></div></figure><p>其中的<code>di_addr</code>字段是一个数组，存放文件的盘块号。每三个字节表示一个磁盘号；相当于能够表示13个磁盘号的数组</p><ul><li>前10个表项是直接寻址。<ul><li>直接存放文件前10磁盘块地址。</li><li>假定一个磁盘块1K，那么可以表示10K以内的文件</li><li>如果文件大小可用10以内磁盘块保存，后面间接寻址不使用。</li></ul></li><li>第11个表项是一级间接寻址。<ul><li>表示的磁盘块不是直接存放文件的内容，而是存放直接寻址表项。即表明<span class="math inline">1024/3</span>个磁盘块号，用于存放文件内容。</li><li>该级地址最多可表示文件大小 <span class="math inline">1024/3 × 1024</span>。</li></ul></li><li>第12个表项是二级间接寻址。<ul><li>表示的磁盘块不是直接存放文件，而是存放一级间接寻址表项。即表明 <span class="math inline">1024/3</span>个磁盘块号，用于存放一级寻址表项。</li><li>该级地址最多可表示文件大小 <span class="math inline">1024/3 × 1024/3 × 1024</span>。</li></ul></li><li>第13个表项是三级间接寻址。<ul><li>表示的磁盘块不是直接存放文件，而是存放二级间接寻址表项。即表明 <span class="math inline">1024/3</span>个磁盘块号，用于存放二级寻址表项。</li><li>该级地址最多可表示文件大小 <span class="math inline">1024/3 × 1024/3 × 1024/3 × 1024</span>。</li></ul></li></ul><figure><img src="image-48.webp" srcset="/img/loading/loading3.gif" lazyload alt="UNIX文件索引结构"><figcaption aria-hidden="true">UNIX文件索引结构</figcaption></figure><h3 id="unix目录系统结构">UNIX目录系统结构</h3><p>目录项如下</p><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> direct {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">ino_t</span><span style="color: #ABB2BF"> d_ino;</span><span style="color: #7F848E; font-style: italic">                // 文件的inode号</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">d_name</span><span style="color: #ABB2BF">[NAME_MAX </span><span style="color: #C678DD">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span><span style="color: #7F848E; font-style: italic">  // 文件名</span></span><span class="line"><span style="color: #ABB2BF">};</span></span></code></pre></div></div></figure><figure><img src="image-49.webp" srcset="/img/loading/loading3.gif" lazyload alt="UNIX目录系统结构"><figcaption aria-hidden="true">UNIX目录系统结构</figcaption></figure><h3 id="unix文件系统在磁盘的存储布局">UNIX文件系统在磁盘的存储布局</h3><ul><li>分布概述：<ul><li>一个物理磁盘能够被划分成多个逻辑分区，相当于一个逻辑盘。对每一个逻辑盘，盘块的物理地址是连续的。</li><li>可以把一个逻辑盘的存储地址空间看成一个一维的线性空间。</li><li>一个文件系统对应一个逻辑盘。一个物理磁盘上可以同时存在多个文件系统。</li></ul></li></ul><p><img src="image-50.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li><p>引导块：</p><ul><li>在块号为0的引导块中包含操作系统的自举程序</li><li>该块不属于文件系统一部分。</li><li>有些逻辑分区上没有这一块的内容</li></ul></li><li><p>超级块</p><ul><li>用于存放文件系统的核心数据</li><li>各部分的盘块分布</li><li>空闲节点数，空闲节点表</li><li>空闲盘块数，空闲盘块索引</li><li>文件系统的类型、版本号，文件系统的状态</li><li>超级块在文件系统启动时，为了快速更新，被复制到内存一份。</li><li>磁盘上超级块需要定时更新</li><li>为了保证超级块的安全性，超级块在磁盘上有备份，用于文件系统恢复。</li></ul><p></p><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> filsys {</span></span><span class="line"><span style="color: #C678DD">ushort</span><span style="color: #ABB2BF">       s_isize；</span><span style="color: #7F848E; font-style: italic">        /* 磁盘索引节点区所占用的盘块总数 */</span></span><span class="line"><span style="color: #C678DD">daddr_t</span><span style="color: #ABB2BF">    s_fsize；</span><span style="color: #7F848E; font-style: italic">        /* 整个文件系统的盘块总数 */</span></span><span class="line"><span style="color: #ABB2BF">Short        s_nfree；</span><span style="color: #7F848E; font-style: italic">        /* 直接管理的空闲块数目 */</span></span><span class="line"><span style="color: #C678DD">daddr_t</span><span style="color: #ABB2BF">    </span><span style="color: #E06C75">s_free</span><span style="color: #ABB2BF">[NICFREE]；</span><span style="color: #7F848E; font-style: italic">/* 空闲块索引表 */</span></span><span class="line"><span style="color: #ABB2BF">Short        s_ninode；</span><span style="color: #7F848E; font-style: italic">        /*直接管理的空闲索引节点数 */</span></span><span class="line"><span style="color: #C678DD">ino_t</span><span style="color: #ABB2BF">        </span><span style="color: #E06C75">s_inode</span><span style="color: #ABB2BF">[NICINOD]；</span><span style="color: #7F848E; font-style: italic"> /* 空闲I节点索引表 */</span></span><span class="line"><span style="color: #ABB2BF">Char         s_flock；</span><span style="color: #7F848E; font-style: italic">        /* 处理空闲块表时的加锁标志位 */</span></span><span class="line"><span style="color: #ABB2BF">Char         s_ilock；</span><span style="color: #7F848E; font-style: italic">          /* 处理空闲I节点表时的加锁标志位 */</span></span><span class="line"><span style="color: #ABB2BF">Char         s_fmod；</span><span style="color: #7F848E; font-style: italic">        /* 文件系统超级块被修改标志 */</span></span><span class="line"><span style="color: #C678DD">daddr_t</span><span style="color: #ABB2BF">    s_tfree；</span><span style="color: #7F848E; font-style: italic">        /* 空闲数据块总数 */</span></span><span class="line"><span style="color: #C678DD">ino_t</span><span style="color: #ABB2BF">         s_tinode；</span><span style="color: #7F848E; font-style: italic">    /* 空闲索引节点总数 */</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p></li><li><p>进程对换区：</p><ul><li>连续磁盘区域。用于是换入/换出，作为内存的扩充。</li><li>该块不属于文件系统的一部分。</li><li>有些系统，如Linux，可以以单独的一个逻辑盘作为交换区</li></ul></li></ul><h3 id="unix文件系统对空闲磁盘块的管理">UNIX文件系统对空闲磁盘块的管理</h3><ul><li>所有空闲磁盘块以多叉（50）树的方式组织。</li><li>树的每个叶子节点对应一个空闲磁盘块</li><li>树的每个中间节点存储在一个空闲磁盘块中，其内容表示下层的多（50）个磁盘块号。</li></ul><figure><img src="image-51.webp" srcset="/img/loading/loading3.gif" lazyload alt="UNIX空闲磁盘块管理"><figcaption aria-hidden="true">UNIX空闲磁盘块管理</figcaption></figure><h3 id="unix文件控制块fcb">UNIX文件控制块（FCB）</h3><ul><li>内存中的目录结构树<ul><li>必要性：<ul><li>访问一个文件时，系统要从根目录或当前目录出发，循序读取和搜索各级目录文件磁盘I节点，索引结构等，找到文件物理块号后再存取文件数据。</li><li>涉及多次磁盘操作，速度慢。</li></ul></li><li>技术思路：<ul><li>在内存中，保存磁盘上的目录结构树的副本</li><li>内存中并不是完整的副本，而是一部分：<ul><li>内存容量的限制</li><li>根据局部性原理，保存一部分就能起到很好的效果</li></ul></li></ul></li></ul></li><li>文件控制块<ul><li>文件被打开一次，就分配一个相应的文件控制块。</li><li>用于保存文件打开后产生一些动态信息。</li><li>存在的必要（为何动态信息不存放在内存索引节点中）<ul><li>内存索引节点主要存放文件相关的静态信息</li><li>便于实现一个文件同时被多个进程打开。</li></ul></li></ul><figure class="shiki c"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> file { </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> f_flag；</span><span style="color: #7F848E; font-style: italic">               /* 操作方式，如写、读、追加写等 */</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">cnt_t</span><span style="color: #ABB2BF"> f_count；</span><span style="color: #7F848E; font-style: italic">             /* 共享该file结构的进程数 */</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">union</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> inode </span><span style="color: #C678DD">*</span><span style="color: #ABB2BF">f_uinode；</span><span style="color: #7F848E; font-style: italic">/* 指向内存I节点 */</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> file  </span><span style="color: #C678DD">*</span><span style="color: #ABB2BF">f_unext；</span><span style="color: #7F848E; font-style: italic"> /* 空闲file的链接指针 */</span></span><span class="line"><span style="color: #ABB2BF">    } f_up；</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">union</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">off_t</span><span style="color: #ABB2BF"> f_off；</span><span style="color: #7F848E; font-style: italic">           /* 读写位置指针 */</span></span><span class="line"><span style="color: #ABB2BF">    } f_un；</span></span><span class="line"><span style="color: #ABB2BF">}；</span></span></code></pre></div></div></figure></li></ul><h2 id="打开文件表">打开文件表</h2><ul><li>进程的打开文件表<ul><li>每个进程都有一个打开文件表，保存该进程打开的所有文件的文件控制块。</li><li>通过该表，进程可以访问其打开的文件。</li><li>子进程继承父进程打开的文件。</li></ul></li><li>系统的打开文件表<ul><li>系统中所有进程共享一个打开文件表，保存所有打开文件的文件控制块。</li><li>通过该表，系统可以管理所有进程打开的文件。</li></ul></li></ul><h2 id="文件搜索">文件搜索</h2><ul><li>相对路径搜索</li><li>绝对路径搜索</li></ul><h2 id="虚拟文件系统">虚拟文件系统</h2><ul><li>背景和目标<ul><li>Linux需要支持多种文件系统。</li><li>屏蔽下层的具体文件系统，向上提供统一的文件服务。</li></ul></li><li>主要思路<ul><li>在具体文件系统和操作系统的文件服务接口间实现虚拟层</li><li>对下层的具体文件系统进行统一封装和细节屏蔽</li><li>对上层提供统一的文件服务接口</li></ul></li><li>核心实现：<ul><li>对一些文件系统的具体实现，如果实现与具体文件系统无关，把这些实现统一到VFS层。如：一些结构的缓冲，索引节点</li><li>当一个进程调用文件系统例程时，内核调用VFS函数(这个函数是和具体结构无关的)，并将这个调用传递给物理文件系统中的相应函数,该函数和具体的物理结构有关。</li></ul></li></ul><figure><img src="image-52.webp" srcset="/img/loading/loading3.gif" lazyload alt="VFS"><figcaption aria-hidden="true">VFS</figcaption></figure><h2 id="可靠性问题">可靠性问题</h2><ul><li>系统启动时的一致性检查</li><li>日志文件系统</li></ul><h1 id="操作系统安全">操作系统安全</h1><p>与 <em>网络空间安全导论</em> 课程笔记结合食用更佳哦。</p><p><a href="/_posts/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80" name="/img/avatar/avatar.webp" class="LinkCard">网络空间安全导论</a></p><h2 id="基本概念">基本概念</h2><ul><li>CIA<ul><li>保密性</li><li>完整性</li><li>可用性</li></ul></li><li>TCSEC：D，C1，C2，B1，B，B3，A1，A2 保护级别</li><li>GB17859－1999：《计算机信息系统安全保护等级划分准则》：用户自主，系统审计，安全标记，结构化，访问验证</li></ul><h2 id="安全威胁">安全威胁</h2><ul><li>威胁类型：<ul><li>信息泄露<ul><li>信息暴露</li><li>拦截</li><li>推断</li></ul></li><li>欺诈<ul><li>假冒用户</li><li>伪造</li><li>否认</li></ul></li><li>中断<ul><li>瘫痪</li><li>阻碍</li></ul></li><li>侵占<ul><li>侵用</li><li>占用</li></ul></li></ul></li><li>威胁主体<ul><li>入侵者<ul><li>伪装者：未经授权使用</li><li>越权者：未经授权的合法用户、经授权访问但滥用权限的合法用户</li><li>秘密使用者：逃避审计和访问控制</li></ul></li><li>恶意软件</li></ul></li></ul><h2 id="入侵者">入侵者</h2><ul><li>入侵防护<ul><li>物理层面</li><li>网络层面</li><li>操作系统层面</li><li>应用层面</li></ul></li></ul><h2 id="恶意软件">恶意软件</h2><ul><li>工作原理<ul><li>后门</li><li>逻辑炸弹</li><li>木马</li><li>移动代码</li><li>病毒</li><li>蠕虫</li><li>僵尸程序</li></ul></li><li>处理<ul><li>检测</li><li>识别</li><li>删除</li></ul></li></ul><h2 id="安全保障">安全保障</h2><ul><li>安全保障技术<ul><li>数据加密</li><li>身份认证</li><li>访问控制</li></ul></li><li>需求<ul><li>权限管理</li><li>访问控制</li><li>安全隔离</li><li>安全审计</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 操作系统原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学史</title>
      <link href="/_posts/%E6%95%B0%E5%AD%A6%E5%8F%B2/"/>
      <url>/_posts/%E6%95%B0%E5%AD%A6%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>周钢老师</em>2024-2025学年夏季学期教学内容整理，并根据个人理解与思考进行扩展和补充。</p></blockquote><h1 id="数学史">数学史</h1><h2 id="中国数学史">中国数学史</h2><h3 id="数学与文化表达">数学与文化表达</h3><ul><li>数字在语言中的应用</li><li>数字表达文化，成语：七上八下、不三不四</li><li>象征意义：十三点、二百五</li><li>用数学来造字：三表多、森表示多木</li></ul><h3 id="数学与哲学思想">数学与哲学思想</h3><ul><li>道家：道生一，一生二，二生三，三生万物<ul><li><span class="math inline">0 → 1 → 2 → 3 → ⋯ → ∞</span></li></ul></li><li>儒家：虚无生太极，太极生两仪，两仪生四象，四象生八卦<ul><li><span class="math inline">0 → 2<sup>0</sup> → 2<sup>1</sup> → 2<sup>2</sup> → 2<sup>3</sup> → ⋯</span></li></ul></li><li>佛教</li></ul><h3 id="历代数学">历代数学</h3><h4 id="秦朝">秦朝</h4><ul><li>户籍制度：统计学管理国家</li><li>秦始皇重视数学：官员必须懂数学才能管理好国家</li><li>通过数学计算战争规模和后勤需求。</li><li>长城和陵墓的建设</li></ul><h4 id="汉朝">汉朝</h4><ul><li>《九章算术》：古代数学的经典著作<ul><li>方程求解</li><li>统计学</li><li>几何学</li><li>代数方程</li></ul></li></ul><h4 id="隋朝">隋朝</h4><ul><li>发明科举</li><li>隋炀帝重视数学</li><li>国子监算学</li><li>通过数学规划大运河</li></ul><h4 id="唐朝">唐朝</h4><ul><li>唐太宗李世民重视数学</li><li>隋唐时代国子监算学的教科书，史称《算经十书》</li><li>十部书的名称是：<ul><li>《周髀算经》、《九章算术》、《海岛算经》、《张丘建算经》、《夏侯阳算经》、《五经算术》、《缉古算经》、《缀术》、《五曹算经》、《孙子算经》</li></ul></li><li>杰出数学家：李淳风、僧一行</li></ul><h4 id="宋朝">宋朝</h4><ul><li>古代数学顶峰</li><li>主要成就：<ul><li>《算经十书》的注释和发展</li><li>《九章算术》的推广和应用</li><li>数学教育的普及</li></ul></li><li>纸牌娱乐中的数学：休闲产生文化<ul><li>扑克</li><li>麻将</li></ul></li><li>四大杰出数学家：<ul><li>秦九韶：同余运算、快速运算</li><li>李冶：同余运算、不定方程</li><li>杨辉：杨辉三角（帕斯卡、牛顿）、组合数学</li><li>朱世杰：数论、代数方程<ul><li>热衷办学</li><li>吴文俊自称其学生</li></ul></li></ul></li></ul><h4 id="元朝">元朝</h4><ul><li>《四元玉鉴》：代数方程的研究</li><li>《九章算术》的注释和发展</li></ul><h4 id="明朝">明朝</h4><ul><li>徐光启：数学家、天文学家<ul><li>《几何原本》：欧几里得几何的介绍<ul><li>欧氏几何：传教士传入</li></ul></li><li>徐家汇：徐光启逃难携家人来到上海</li></ul></li><li>朱世杰：《算学启蒙》</li></ul><h4 id="清朝">清朝</h4><ul><li>康熙：<ul><li>《御制数理精蕴》</li><li>十六岁亲政，每日朗诵欧氏几何</li><li>个人热爱数学</li></ul></li><li>钦天正：天文学、历法、数学</li><li>周培公：比例地图<ul><li>模拟图 ≠ 比例图</li></ul></li><li>莱布尼茨<ul><li>八卦与二进制</li><li>与康熙书信往来，关系密切</li></ul></li><li>清末：不重视数学</li><li>教育<ul><li>北洋公学、南洋公学</li><li>南开大学</li></ul></li></ul><h3 id="近代数学家">近代数学家</h3><ul><li><strong>华罗庚</strong><ul><li>中专毕业后自学成才</li><li>拼命发论文、在国际刊物发表论文后欣喜若狂：“和别人在同个起点，只是晚了点”</li><li>“不太会做人”、比较强势、人缘不太好</li><li>发文章倡议海外留学生回国建设新中国、主持中国的数学发展</li><li>与苏联数学家关系友好</li><li>华罗庚与苏家驹<ul><li>苏家驹写了一篇“一元五次方程的公式解”论文，华罗庚试图模仿，发现行列式作分母未验证非零，写了反驳文</li></ul></li><li>华罗庚与姜立夫<ul><li>姜立夫向熊庆来推荐华罗庚</li><li>在恩人姜立夫由中央研究院院士转中科院院士时投了反对票</li></ul></li><li>华罗庚与熊庆来<ul><li>姜立夫推荐华罗庚给熊庆来</li><li>熊庆来求贤若渴，邀请华罗庚去清华</li></ul></li><li>华罗庚与杨武之<ul><li>杨武之：<ul><li>杨振宁父亲</li><li>熊庆来之后的清华数学系系主任</li><li>与华罗庚关系密切，辅导华罗庚</li></ul></li><li>华罗庚师从陈武之，但是鲜少提及</li></ul></li><li>华罗庚与维纳<ul><li>维纳：现代控制论之父<ul><li>用线性代数解状态方程：一阶微分方程组</li><li>对应的经典控制论：函数分析、解高阶方程</li></ul></li><li>华罗庚让维纳帮自己给哈代写推荐信</li></ul></li><li>华罗庚与陈省身&amp;吴文俊<ul><li>华罗庚和两人关系不好</li><li>陈省身<ul><li>国民党中央研究院数学所代理所长</li><li>解放战争时仓皇出逃美国</li></ul></li><li>吴文俊<ul><li>拜访陈省身</li><li>从学平面几何到公费留学</li><li>响应华罗庚号召回国</li></ul></li></ul></li><li>华罗庚与哈代<ul><li>华罗庚想出国跟随哈代学习，于是给陈立夫写信<ul><li>陈立夫：<ul><li>哥哥陈果夫、叔叔陈其美</li><li>中统头子（中统对内、军统对外）</li><li>为官清廉</li></ul></li><li>陈立夫资助华罗庚出国</li></ul></li><li>陈省身劝阻：跟随哈代学习难以取得更高成就</li></ul></li><li>华罗庚与丘成桐<ul><li>华罗庚很尊敬丘成桐<ul><li>丘成桐年纪小，但华罗庚在信中称他“成桐兄”</li></ul></li><li>丘成桐：<ul><li>清华大学丘班</li><li>老师：陈省身</li></ul></li></ul></li></ul></li><li><strong>朱公谨</strong>：师从柯朗</li><li>三胡：<ul><li>胡敦复</li><li>胡刚复</li><li>胡明复：宣扬科学意识，创办报纸进行科普</li></ul></li><li><strong>苏步青</strong><ul><li>做了三万多道高等数学题</li><li>负责中科院数学研究所筹备工作<ul><li>第一任所长是华罗庚</li></ul></li></ul></li><li><strong>王湘浩</strong><ul><li>北京大学教授、吉林大学数学系主任</li><li>与华罗庚关系好</li><li>公认吴文俊强于王湘浩</li></ul></li><li><strong>吴文俊</strong><ul><li>面对华罗庚的发难，吴文俊拿王湘浩当挡箭牌</li><li>评价老师陈省身时，引用杨振宁“千古存心事，欧高黎嘉陈”</li><li>法国国家博士<ul><li>法国国家博士比法国博士含金量高得多</li></ul></li><li>“大满贯”：<ul><li>国家自然科学奖</li><li>尖端科学技术奖</li><li>邵逸夫科学奖</li></ul></li></ul></li><li><strong>陈省身</strong><ul><li>应用数学比纯数学难</li><li>代表美国分钱</li><li>一生三个所：<ul><li>国民党中央研究院数学研究所</li><li>美国国家数学科学研究所</li><li>南开大学陈省身数学研究所</li></ul></li></ul></li></ul><div class="note note-info">            <ul><li><strong>北派</strong>：华罗庚、丘成桐、王虹、吴文俊<ul><li>题做的少、论文发得多</li></ul></li><li><strong>南派</strong>：苏步青、陈建功、……<ul><li>题做的多、论文发得少</li></ul></li></ul>          </div><h2 id="西方数学史">西方数学史</h2><h3 id="漫谈">漫谈</h3><ul><li><p>中国数学与西方数学对比</p><ul><li>中国数学的发展：<ol type="1"><li>治国平天下（务实）</li><li>数学（运筹、术数）</li><li>中国文化</li><li>人工智能基础</li></ol></li><li>西方数学的发展：<ol type="1"><li>有闲</li><li>地位&amp;辩论<ul><li>辩论：<ul><li>辩题：寻找有用的题目<ul><li>七大圣贤之首泰利斯：东游记（古埃及、古巴比伦）</li></ul></li><li>规则：亚里士多德发明形式逻辑</li></ul></li><li>大奴隶主辩不过小奴隶主</li></ul></li><li>学习</li><li>头尾分析<ul><li>字母化</li><li>数学</li><li>科学</li></ul></li></ol></li></ul><p></p><div class="note note-info">            <ul><li>西方的数学是纯数学——精神产物</li><li>中国的数学是应用数学——实用产物、物质产物</li></ul>          </div><p></p></li><li><p>区分：科学、宗教、迷信</p><ul><li>科学与宗教体系相似：<ul><li>都是头尾分析<ul><li>科学：可实验——头</li><li>宗教：信仰——头</li></ul></li></ul></li><li><span class="math inline">∑</span> 理论 <span class="math inline">≠</span> 科学</li><li>实验事实与宗教理论不一致时：<ul><li>科学：修正理论</li><li>迷信：反对事实</li></ul></li></ul></li><li><p>两种方法：</p><ul><li>汇集多数案例：MBA（案例分析法）</li><li>由少数案例推出剩余案例：Science（科学方法）</li></ul></li><li><p>理科与工科</p><ul><li>工科提出问题</li><li>理科解决问题</li></ul></li></ul><h3 id="古希腊数学家">古希腊数学家</h3><h4 id="泰利斯thales泰勒斯">泰利斯（Thales）/泰勒斯</h4><ul><li>七大圣贤之首</li><li>东游记：<ul><li>古埃及：向埃及人学习观察洪水，指导避难</li><li>古巴比伦</li></ul></li><li>几何学的奠基人：从几何图形到测量金字塔</li><li>代数、表格：转道巴比伦途中所学</li><li>把数学带回古希腊</li><li>轶事：<ul><li>数学挣钱：泰利斯是商人，预言气候干旱，提前收购水果卖出高价</li></ul></li><li>发源地 <span class="math inline">≠</span> 光大地<ul><li>数学发源于古埃及、古巴比伦</li><li>光大于古希腊</li></ul></li><li>有闲才能有文化</li></ul><h4 id="柏拉图plato">柏拉图（Plato）</h4><ul><li>坚持：苏格拉底和柏拉图的甩手的故事<ul><li>苏格拉底的学生</li></ul></li><li>理想主义者</li><li>数学：真、善、美<ul><li>真：真理——证实明天<ul><li>亚里士多德用三段论证明</li></ul></li></ul></li><li>数学与实验结果不一致时：相信数学</li><li>柏拉图学院：“学院” → “University”<ul><li>有兴趣者聚在一起</li><li>定时定点</li><li>分类：“类” → “学科”</li><li>不懂数学者不得入内</li><li>对应中国的书院</li></ul></li></ul><h4 id="亚里士多德aristotle">亚里士多德（Aristotle）</h4><ul><li>柏拉图的学生、亚历山大大帝的老师</li><li>形式逻辑：三段论</li><li>集大成者、百科全书式人物</li><li>重要观点：“精英悲哀”</li><li>提出：科学、技术、艺术学</li><li>想象得到一些结果：被伽利略批判</li><li>形而上学 &amp; 形而下学</li></ul><h4 id="欧几里得euclid">欧几里得（Euclid）</h4><ul><li>欧氏几何之父、纯粹数学家</li><li>亚氏理论的具象化 → 头尾分析法 → 《几何原本》<ul><li>《几何原本》：天下第一书</li></ul></li><li>检验神童的标志：科学的样板</li><li>欧几里得算法：求最大公约数</li><li>做研究：小头大尾</li></ul><h4 id="阿基米德archimedes">阿基米德（Archimedes）</h4><ul><li>数学之神：无从考证</li><li>应用数学祖师爷</li><li>数学：小众文化</li><li>研究内容：<ul><li>微积分雏形：缺少极限概念，但其思想实质却伸展到17世纪趋于成熟的无穷小分析领域里去，预告了微积分的诞生。</li><li>二次曲线</li><li>切线</li><li>力学</li></ul></li></ul><h4 id="毕达哥拉斯pythagoras">毕达哥拉斯（Pythagoras）</h4><ul><li>泰利斯的关门弟子</li><li>数学与音乐的关系</li><li>毕达哥拉斯学派</li><li>万物皆数、用数算命</li><li>定义自然数：自然物 → 自然数</li><li>成果不署名</li></ul><h3 id="古埃及古巴比伦古希腊数学点滴">古埃及、古巴比伦、古希腊数学点滴</h3><ul><li><strong>古埃及</strong><ul><li>纸草纸文化<ul><li>只有两张保存，价值连城<ul><li>莱茵德纸草纸</li><li>车尔尼雪夫纸草纸</li></ul></li></ul></li><li>有许多数列、倒数<ul><li>会用来进行计算</li></ul></li></ul></li><li><strong>古巴比伦</strong><ul><li>泥板文化<ul><li>城墙就是图书馆</li><li>考古发掘300多块，涉及数学的有50多块</li></ul></li><li>有各种数学用表</li><li>60进制</li><li>著名藏品：普林顿泥板<ul><li>公元前100年</li><li>收藏号：322号</li><li>美国哥伦比亚大学图书馆</li></ul></li></ul></li><li><strong>古希腊</strong><ul><li>最高境界：推理</li><li>先驱：泰利斯</li><li>三个时期：<ul><li>毕达哥拉斯时期<ul><li>自由教育、自由研究、无功利</li><li>两个脱离<ul><li>脱离了经济生活：纯推理</li><li>脱离了从属地位</li></ul></li><li>第一次数学危机：无理数</li></ul></li><li>柏拉图时期<ul><li>知识套路：小成本学习法</li><li>形成证明</li><li>几何三大难题<ul><li>倍平方问题</li><li>角的三等分问题</li><li>圆 <span class="math inline">↔︎</span> 方</li></ul></li></ul></li><li>亚历山大时期<ul><li>提供文化</li><li>共享知识</li><li>后期产生三位伟人<ul><li>欧几里得</li><li>阿普罗尼亚斯</li><li>阿基米德</li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="十七世纪代表性法国数学家">十七世纪代表性法国数学家</h3><h4 id="帕斯卡blaise-pascal">帕斯卡（Blaise Pascal）</h4><ul><li>评价：<ul><li>神童：16岁著书写出“圆锥曲线理论”</li><li>残疾：同华罗庚</li><li>天才</li><li>单相思</li></ul></li><li>古典概率创始人</li><li>帕斯卡定理：上帝不喜欢真空</li><li>计算机祖师爷：</li><li>宗教信仰：29岁后献身宗教，试图证明上帝存在<ul><li>与他类似：康德、叔本华、牛顿</li><li>康德是黑格尔老师、黑格尔是马克思老师、马克思是毛泽东老师</li></ul></li><li>哲学家、散文家</li></ul><h4 id="笛卡尔rené-descartes">笛卡尔（René Descartes）</h4><ul><li>从小体弱多病</li><li>善于观察：笛卡尔坐标系<ul><li>观察蜘蛛</li></ul></li><li>《方法论》附录：解析几何</li><li>创立解析几何</li><li>哲学家：我思故我在</li><li>以太论：涡动力学</li></ul><h4 id="费马pierre-de-fermat费尔马">费马（Pierre de Fermat）/费尔马</h4><ul><li>方法解<ul><li>独立于笛卡儿发现解析几何的基本原理</li></ul></li><li>喜欢买旧书和研究旧书<ul><li>阿拉伯的书：有些是从古希腊抢来的书</li></ul></li><li>费马大定理：<span class="math inline"><em>x</em><sup><em>n</em></sup> + <em>y</em><sup><em>n</em></sup> = <em>z</em><sup><em>n</em></sup></span>，<span class="math inline"><em>n</em> &gt; 2</span> 无整数解<ul><li>作眉批：去世后儿子整理出书</li><li>称自己已经用“奇妙的想法证出来”，但在页边的空白处写不下<ul><li>因此有时称为费马猜想而非定理</li></ul></li><li>无数数学家尝试证明该命题但都以失败告终直到三百多年后才被证明</li></ul></li><li>用水平切线找极值点</li></ul><h3 id="漫谈交大">漫谈：交大</h3><blockquote><p>怎么刚刚讲着法国数学家，突然就跳到交大了（</p></blockquote><div class="note note-info">            <ul><li>交大历任校长轶事<ul><li>范绪箕</li><li>朱物华</li><li>翁史烈</li><li>谢绳武</li><li>张杰</li><li>林忠钦</li><li>丁奎岭</li></ul></li></ul>          </div><div class="note note-info">            <ul><li>保护成果<ul><li>前提：<ul><li>要发论文</li><li>不能被剽窃</li></ul></li><li>方法：<ul><li>只给结论不给推导过程<ul><li>注意到、显然、容易得到、不难得出</li></ul></li><li>只给成果不给方法</li></ul></li></ul></li><li>“公开的专利都是不挣钱的”</li></ul>          </div><h3 id="十七世纪末至十八世纪初的伟大数学家">十七世纪末至十八世纪初的伟大数学家</h3><ul><li>关于微积分的争吵：<ul><li><strong>为国家利益而争吵</strong></li><li>各方争吵：<ul><li>意大利：阿基米德</li><li>德国：开普勒</li><li>法国：费尔马</li><li>英国：巴罗（牛顿的老师）</li></ul></li><li>达成共识：牛顿和莱布尼茨</li></ul></li></ul><h4 id="巴罗isaac-barrow">巴罗（Isaac Barrow）</h4><ul><li>牛顿的老师</li><li>发现微积分的基本定理<ul><li>研究微积分需要承认勾股定理：<span class="math inline">ds<sup>2</sup> = dx<sup>2</sup> + dy<sup>2</sup></span></li></ul></li></ul><h4 id="牛顿isaac-newton">牛顿（Isaac Newton）</h4><ul><li>物理学家、数学家、天文学家</li><li>小时候“笨”：小时候在墙上留下大小不同的洞给不同动物走<ul><li>普通人角度：笨</li><li>科学家角度：聪明（分类思想）</li></ul></li><li>早年研究概率论：想挣钱</li><li>研究力学：<ul><li>经典力学的奠基人：牛顿三大定律</li><li>发现万有引力定律</li><li>《自然哲学的数学原理》：经典力学的奠基之作</li></ul></li><li>研究天体</li><li>发明“流数法”，即<strong>增量分析法</strong> → 微积分的创始人之一<ul><li>明天 = 今天 + 增量</li><li>增量 = <span class="math inline">∑</span> 小增量</li></ul></li><li>研究光学：光的色散现象</li><li>英国皇家给牛顿官职：造币厂厂长</li><li>人物关系：<ul><li>死对头：胡克<ul><li>死后手稿被牛顿销毁</li></ul></li><li>好朋友：哈雷</li><li>最得意的学生：库兹<ul><li>最早提出最小二乘法，但由于没有用武之地而被遗忘</li></ul></li><li>追随者：泰勒、麦克劳林</li></ul></li><li>增量思维和存量思维<ul><li>在经济学上：边际分析</li></ul></li><li>去世后葬礼非常隆重</li></ul><h4 id="莱布尼茨gottfried-wilhelm-leibniz">莱布尼茨（Gottfried WilhelmLeibniz）</h4><ul><li>德国哲学家、数学家</li><li>百科全书式人物</li><li>“文科生”：原本不学数学</li><li>好奇心强、好学</li><li>微积分的创始人之一<ul><li>莱布尼茨符号：<span class="math inline">∫</span>（积分符号）和 <span class="math inline">dx</span>（微分符号）</li></ul></li><li>数理逻辑：一生被卷入争吵，为避免争吵，发明“争吵的数学”</li><li>建议成立“科学院”</li><li>欣赏对手：很欣赏牛顿，英雄惜英雄</li></ul><div class="note note-info">            <ul><li>数学的三大革命<ul><li>欧几里得：<span class="math inline">∑</span> 数学 → 头尾数学</li><li>莱布尼茨：学数学不需要问为什么，遵守规则即可</li><li>委托（人工智能化）</li></ul></li></ul>          </div><h4 id="欧拉leonhard-euler">欧拉（Leonhard Euler）</h4><ul><li>瑞士数学家、物理学家</li><li>对数学具有宗教式的狂热，被誉为18世纪最伟大的数学家<ul><li>进入人类前二十位数学家</li></ul></li><li>研究领域：<ul><li>数论</li><li>图论</li><li>拓扑学</li><li>复变函数</li><li>微分方程</li><li>数学物理学</li></ul></li><li>欧拉公式：<span class="math inline"><em>e</em><sup><em>i</em><em>π</em></sup> + 1 = 0</span></li><li>人物关系<ul><li>父亲：神职人员，热爱数学，但希望欧拉学习神学</li><li>老师：约翰·伯努利很欣赏欧拉，帮他说服父亲</li><li>德皇的老师，不想参加舞会，想辞职<ul><li>德皇提出条件：推荐一个顾问，水平与他相当，且会跳舞</li><li>于是推荐拉格朗日，德皇很满意</li></ul></li><li>全欧洲数学家的老师</li></ul></li><li>离开德国后，前往俄国（圣彼得堡）<ul><li>叶卡捷琳娜一世（俄国女皇）安排欧拉进了圣彼得堡大学艺术系，而非数学系</li><li>叶卡捷琳娜二世对欧拉非常欣赏和照顾</li><li>奠定圣彼得堡大学数学系的基础，产生许多杰出数学家<ul><li>切比雪夫</li><li>马尔可夫</li><li>坎托罗维奇</li></ul></li></ul></li><li>记忆力超群，能复述家里的书</li><li>论文多</li></ul><h4 id="拉格朗日joseph-louis-lagrange">拉格朗日（Joseph-LouisLagrange）</h4><ul><li>意大利数学家、物理学家，终生在法国</li><li>埃菲尔铁塔上的人物</li><li>研究领域：<ul><li>数论</li><li>泛函</li><li>解析力学</li><li>微分方程</li><li>变分法</li></ul></li><li>成就：<ul><li>拉格朗日乘数法：求函数极值的条件</li><li>拉格朗日插值公式：多项式插值的基础</li></ul></li><li>傲慢：“比牛顿还牛”</li><li>最重要工作：承认“第一原理”<ul><li>上帝以能量最低的方式创造世界</li><li>《分析力学》：天下第三书 <div class="note note-info">            <ul><li>天下第零书：《圣经》</li><li>天下第一书：《几何原本》</li><li>天下第二书：《自然哲学的数学原理》</li><li>天下第三书：《分析力学》</li></ul>          </div></li></ul></li><li>倒在“一元五次方程的公式解”上<ul><li>在犹豫中死亡</li><li>给后人留下解决的路径</li></ul></li></ul><h4 id="高斯carl-friedrich-gauss">高斯（Carl Friedrich Gauss）</h4><ul><li>德国数学家、物理学家、天文学家</li><li>被誉为“数学王子”，数学 + 文化的典范</li><li>研究领域：<ul><li>数论</li><li>代数</li><li>几何</li><li>天文学</li><li>电磁学</li></ul></li><li>成就：<ul><li>高斯定理：电场的散度与电荷密度成正比</li><li>高斯曲率：描述曲面的弯曲程度</li><li>高斯消元法：线性方程组求解方法</li><li>高斯-勒让德算法：数值积分方法</li><li>高斯-马尔可夫定理：最小二乘估计的有效性</li></ul></li><li>经历：<ul><li>父亲在铁路工作，家里很多孩子，经济拮据</li><li>欧拉是家里唯一的男孩，母亲重男轻女，坚持让欧拉上学</li><li>上小学时，高斯求和：<span class="math inline">$\sum_{i=1}^{n} i =\frac{n(n+1)}{2}$</span></li><li>上大学时，高斯犯难：文学和数学都很好，不知道该选哪个<ul><li>世界难题：用圆规直尺作正十七边形</li><li>高斯尝试证明，成功了，于是决定读数学</li><li>恋乡情结：于是去哥廷根大学读书</li><li>大一借了43本书，多数为文学书<ul><li>理由：“功夫在外不在内”</li></ul></li></ul></li></ul></li><li>喜欢钱<ul><li>股票投资</li><li>简朴节约</li><li>天文台兼职</li><li>金融数学第一人：正态分布</li><li>钞票人物</li></ul></li><li>博士论文：<span class="math inline"><em>P</em><sub><em>n</em></sub>(<em>x</em>) = 0</span>在复数域有<span class="math inline"><em>n</em></span>个根<ul><li>一生给出7个证明</li></ul></li><li>学生：黎曼、狄利克雷</li></ul><h4 id="黎曼bernhard-riemann">黎曼（Bernhard Riemann）</h4><ul><li>德国数学家</li><li>研究领域：<ul><li>数论</li><li>复变函数</li><li>微分几何</li><li>拓扑学</li></ul></li><li>成就：<ul><li>黎曼猜想：关于素数分布的猜想</li><li>黎曼积分：对函数进行积分的定义</li><li>黎曼曲率张量：描述曲面的弯曲性质</li></ul></li><li>经历：<ul><li>家境贫寒，兄弟姐妹多</li><li>喜欢生小孩，所以一直很穷，但仍坚守数学</li><li>结合勤工俭学与数学研究</li><li>毕业后留校，高斯去世后接任教职，进行就职演讲</li><li>恰逢法国数学大奖</li><li>早年拖垮了身体，因此英年早逝<ul><li>去世后，因爱因斯坦的相对论而被闻名</li><li>黎曼几何：可以做相对论基础</li></ul></li></ul></li></ul><h3 id="二十世纪初德国哥廷根大学数学三剑客">二十世纪初德国哥廷根大学“数学三剑客”</h3><h4 id="克莱因felix-klein">克莱因（Felix Klein）</h4><ul><li>德国数学家</li><li>数学+管理第一人</li><li>哥廷根大学数学系院长</li><li>研究领域：<ul><li>几何学</li><li>代数</li><li>数学教育</li></ul></li><li>成就：<ul><li>克莱因瓶：一种非定向的拓扑空间</li><li>克莱因四元数：一种代数结构</li><li>克莱因群：描述对称性的群</li></ul></li><li>学生：恩格尔（恩格尔系数）</li><li>会赚钱</li><li>力排众议聘请年轻的希尔伯特</li><li>主张：<ul><li>强调“理工结合”</li><li>扩张</li><li>数学是几何</li></ul></li></ul><h4 id="闵可夫斯基hermann-minkowski">闵可夫斯基（HermannMinkowski）</h4><ul><li>德国数学家（德国？俄国？）</li><li>犹太人，是家里最小的</li><li>年龄比希尔伯特小，插班和希尔伯特同班</li><li>哥廷根大学数学系教授<ul><li>上课，教“拓扑学”，出了洋相：四色问题</li></ul></li><li>学生：爱因斯坦<ul><li>在学校里，爱因斯坦经常逃课</li><li>爱因斯坦发表相对论时，闵可夫斯基帮他整理理论依据，找到黎曼的论文</li><li>闵可夫斯基在外讲学宣传爱因斯坦相对论时，突发阑尾炎，去世</li></ul></li><li>研究领域：<ul><li>数论</li><li>几何学</li><li>物理学</li></ul></li><li>“数学是科学的语言”</li></ul><h4 id="希尔伯特david-hilbert">希尔伯特（David Hilbert）</h4><ul><li>德国数学家</li><li>哥廷根大学数学系教授</li><li>研究领域：<ul><li>数学基础</li><li>数论</li><li>代数</li><li>几何</li></ul></li><li>成就：<ul><li>希尔伯特空间：无限维向量空间</li><li>希尔伯特问题：23个未解决的数学问题</li><li>希尔伯特基：线性代数中的基概念</li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-2357ccb7" role="button" aria-expanded="false" aria-controls="collapse-2357ccb7">        <div class="fold-arrow">▶</div>希尔伯特的23个问题      </div>      <div class="fold-collapse collapse" id="collapse-2357ccb7">        <div class="fold-content">          <ol type="1"><li>康托尔的连续统基数问题</li><li>算术公理的相容性</li><li>两个等底等高的四面体体积相等的证明</li><li>直线作为两点间最短距离问题</li><li>李群的连续变换群的局部同构与整体同构问题（连续群的解析解）</li><li>物理公理的数学处理</li><li>某些数的无理性与超越性</li><li>素数问题（含黎曼猜想、哥德巴赫猜想、孪生素数问题等）</li><li>任意数域中最一般的互反律的证明（推广二次互反律）</li><li>丢番图方程的可解性（判断整系数方程是否有整数解的算法）</li><li>系数为任意代数数的二次型问题</li><li>阿贝尔域上的克罗内克定理推广到任意代数有理域</li><li>不可能用只有两个变数的函数解一般的七次方程</li><li>证明某类完全函数系的有限性（代数不变量理论）</li><li>舒伯特计数演算的严格基础（枚举几何基础）</li><li>代数曲线和曲面的拓扑问题</li><li>正定形式的平方和表示（正定有理函数表为有理函数平方和）</li><li>由全等多面体构造空间（空间的tiling问题）</li><li>正则变分问题的解是否一定解析</li><li>一般边值问题（椭圆型微分方程边值问题）</li><li>具有给定单值群的线性微分方程解的存在性（黎曼问题）</li><li>用自守函数一致化解析关系（黎曼曲面单值化）</li><li>变分法的进一步发展</li></ol>        </div>      </div>    </div><ul><li>20世纪初，世界上出现许多协会<ul><li>ICM：国际数学家大会（数学界的奥运会）<ul><li>1897年成立于瑞士苏黎世</li><li>每四年举办一次</li><li>颁发两个奖：<ul><li>菲尔兹奖</li><li>纳瓦林纳奖</li></ul></li><li>会上报告的时长与身份相符</li><li>ICM最值得纪念的日子：1900年8月6日，38岁的希尔伯特在报告中提出著名的“23个问题”，深刻地影响了整个世界</li></ul></li></ul></li></ul><div class="note note-info">            <ul><li>世界数学强国：<ul><li>提出问题给后人做</li><li>做的人因此成名</li></ul></li><li>区别大师<ul><li>大师：教授你会但是不会思考的东西</li><li>小师：教授你不会的东西</li></ul></li></ul>          </div><h3 id="漫谈菲尔兹奖">漫谈：菲尔兹奖</h3><ul><li>一个具有理想主义色彩的奖项</li><li>数学界的“诺贝尔奖”</li><li>中立：不署国名</li><li>1932年没奖、1936年首次颁奖</li><li>每次获奖人数不多于4人，年龄不超过40岁</li><li>获奖：一个奖章、1000美元左右奖金</li><li>轶事：<ul><li>设奖原因——奇怪的野史小故事</li><li>瓦尔拉斯与费马大定理<ul><li>瓦尔拉斯囊括了四大奖项</li><li>传奇人物</li></ul></li><li>吴文俊：搞数学年龄要小，搞文学艺术年龄要大</li><li>数学家与经济学家：相互讽刺</li></ul></li></ul><h3 id="漫谈wolf奖">漫谈：Wolf奖</h3><ul><li>数学终身成就奖</li><li>比菲尔兹奖晚44年（1976年成立）</li><li>主要捐款人：R.Wolf.<ul><li>从废渣中炼铁，致富</li><li>成立基金会，理事由以色列官员担任</li></ul></li><li>获奖领域：<strong>数学</strong>、物理、化学、医学、农业、艺术</li><li>国内著名Wolf学者：<ul><li>陈省身</li><li>吴健雄（物理）</li><li>丘成桐</li><li>袁隆平（农业）</li><li>徐甜甜（建筑）</li><li>何顺（化学）</li></ul></li><li>陈省身：1984年获奖</li></ul><figure><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="人物关系"><figcaption aria-hidden="true">人物关系</figcaption></figure>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>人物关系      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">graph TD;</span></span><span class="line"><span style="color: #abb2bf">    A[杨武之]</span></span><span class="line"><span style="color: #abb2bf">    E[华罗庚]</span></span><span class="line"><span style="color: #abb2bf">    B[陈省身]</span></span><span class="line"><span style="color: #abb2bf">    C[丘成桐]</span></span><span class="line"><span style="color: #abb2bf">    D[杨振宁]</span></span><span class="line"><span style="color: #abb2bf">    F[杜致礼]</span></span><span class="line"><span style="color: #abb2bf">    G[杜聿明]</span></span><span class="line"><span style="color: #abb2bf">    H[穆藕初]</span></span><span class="line"><span style="color: #abb2bf">    I[马相伯]</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf">    A --&gt;|亲传弟子| E</span></span><span class="line"><span style="color: #abb2bf">    A --&gt;|记名弟子| B</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|师生| C</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|西南联大 师生| D</span></span><span class="line"><span style="color: #abb2bf">    A --&gt;|父子| D</span></span><span class="line"><span style="color: #abb2bf">    F --&gt;|父女| G</span></span><span class="line"><span style="color: #abb2bf">    G --&gt;|第一任夫人| D</span></span><span class="line"><span style="color: #abb2bf">    H --&gt;|1945年穆藕初奖学金| D</span></span><span class="line"><span style="color: #abb2bf">    H --&gt;|好友| I</span></span></code></pre></div></div></figure>        </div>      </div>    </div><h3 id="漫谈艾米诺特讲座">漫谈：艾米·诺特讲座</h3><ul><li>艾米·诺特<ul><li>女性，为了学习数学客服社会歧视</li><li>希尔伯特扶持<ul><li>以希尔伯特的名义，在哥廷根大学讲授数学课程。</li></ul></li><li>被希特勒迫害：祖上有犹太血统</li></ul></li><li>随着女权运动的发展，艾米·诺特讲座成为女性数学家的重要平台</li><li>胡和生：首位于2002年北京ICM大会上作“艾米·诺特讲座”的华人女性数学家<ul><li>丈夫：谷超豪<ul><li>中科院夫妻院士</li></ul></li><li>老师：苏步青<ul><li>研究生：浙江大学</li><li>本科：交大数学系</li></ul></li></ul></li></ul><h2 id="中国近代著名数学家">中国近代著名数学家</h2><ul><li>2002年之前的ICM学者：<ul><li>华罗庚</li><li>吴文俊</li><li>陈景润</li><li>张恭庆</li><li>马志明</li><li>冯刚</li></ul></li></ul><h3 id="华罗庚">华罗庚</h3><!-- 见[中国数学史-近代数学家-华罗庚](#近代数学家) --><p><a href="#近代数学家" name="https://file.scholarin.cn/files?fastdfspath=group2/M01/74/40/CgMLEGKhvCuANbF4AABaEeKW4fY5076630" class="LinkCard">中国数学史-近代数学家-华罗庚</a></p><figure><img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="人物关系"><figcaption aria-hidden="true">人物关系</figcaption></figure>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>人物关系      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">graph TD;</span></span><span class="line"><span style="color: #abb2bf">    A[杨武之]</span></span><span class="line"><span style="color: #abb2bf">    B[华罗庚]</span></span><span class="line"><span style="color: #abb2bf">    C[陈省身]</span></span><span class="line"><span style="color: #abb2bf">    D[丘成桐]</span></span><span class="line"><span style="color: #abb2bf">    E[陈景润]</span></span><span class="line"><span style="color: #abb2bf">    F[王元]</span></span><span class="line"><span style="color: #abb2bf">    G[潘承洞]</span></span><span class="line"><span style="color: #abb2bf">    H[熊庆来]</span></span><span class="line"><span style="color: #abb2bf">    I[吴文俊]</span></span><span class="line"><span style="color: #abb2bf">    J[苏步青]</span></span><span class="line"><span style="color: #abb2bf">    K[柯召]</span></span><span class="line"><span style="color: #abb2bf">    L[林家翘]</span></span><span class="line"><span style="color: #abb2bf">    M[许宝騄]</span></span><span class="line"><span style="color: #abb2bf">    N[赵访熊]</span></span><span class="line"><span style="color: #abb2bf">    O[维纳]</span></span><span class="line"><span style="color: #abb2bf">    P[哈代]</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf">    H --&gt;|亲传弟子| B</span></span><span class="line"><span style="color: #abb2bf">    A --&gt;|西南联大同事| B</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|导师| E</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|导师| F</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|导师| G</span></span><span class="line"><span style="color: #abb2bf">    C --&gt;|西南联大同事| B</span></span><span class="line"><span style="color: #abb2bf">    C --&gt;|导师| D</span></span><span class="line"><span style="color: #abb2bf">    J --&gt;|早期影响| B</span></span><span class="line"><span style="color: #abb2bf">    K --&gt;|清华同事| B</span></span><span class="line"><span style="color: #abb2bf">    L --&gt;|清华同事| B</span></span><span class="line"><span style="color: #abb2bf">    M --&gt;|清华同事| B</span></span><span class="line"><span style="color: #abb2bf">    N --&gt;|清华同事| B</span></span><span class="line"><span style="color: #abb2bf">    O --&gt;|普林斯顿访问学者| B</span></span><span class="line"><span style="color: #abb2bf">    P --&gt;|导师| B</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|中国科学院数学所| E</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|中国科学院数学所| F</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|中国科学院数学所| G</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|学术合作| I</span></span><span class="line"><span style="color: #abb2bf">    C --&gt;|西南联大同事| A</span></span><span class="line"><span style="color: #abb2bf">    A --&gt;|导师| C</span></span><span class="line"><span style="color: #abb2bf">    C --&gt;|学术合作| I</span></span><span class="line"><span style="color: #abb2bf">    J --&gt;|浙江大学同事| C</span></span><span class="line"><span style="color: #abb2bf">    K --&gt;|中英庚款同学| C</span></span><span class="line"><span style="color: #abb2bf">    L --&gt;|西南联大同学| C</span></span><span class="line"><span style="color: #abb2bf">    M --&gt;|牛津大学同学| C</span></span><span class="line"><span style="color: #abb2bf">    O --&gt;|麻省理工学院同事| C</span></span><span class="line"><span style="color: #abb2bf">    P --&gt;|学术合作| M</span></span></code></pre></div></div></figure>        </div>      </div>    </div><h3 id="陈景润">陈景润</h3><ul><li>数学家、物理学家</li><li>研究领域：<ul><li>数论</li><li>解析数论</li><li>组合数学</li></ul></li><li>成就：<ul><li>解决了著名的“哥德巴赫猜想”中的一个重要问题<ul><li>证明了每个充分大的偶数都可以表示为一个素数和一个不超过两个素数的乘积之和，即“陈氏定理”</li></ul></li><li>在数论和组合数学领域发表了多篇重要论文</li></ul></li><li>区分陈景润的<strong>物质</strong>&amp;<strong>精神</strong><ul><li>物质上：<ul><li>早年受排挤</li><li>从厦门大学数学系提前毕业，去中学教书<ul><li>不善言辞，加之福建口音重，不受欢迎</li></ul></li><li>独自研究数论，后来去中科院中关村</li><li>在一个小隔间里攀登数学高峰</li><li>成果发表于科学通报，毛主席赏识，大力宣传陈景润</li><li>节约<ul><li>生活过于节俭，导致身体不好</li><li>研究经费节约</li></ul></li><li>疗养院：海军医院<ul><li>由昆：分配来照顾陈景润的护士<ul><li>陈景润喜欢上由昆</li><li>申请结婚，分一套房</li></ul></li></ul></li><li>希望儿子学数学，结果发现没天赋，但是儿子咬牙坚持</li><li>徐迟：崇敬陈景润，写了《哥德巴赫猜想》一书</li><li>晚年陈景润得了帕金森综合征，六十多岁就逝世了</li></ul></li><li>精神上：<ul><li>忘我的科学精神</li><li>本土发展</li><li>跨世纪人才<ul><li>十年磨一剑：宝刀 or 菜刀？</li></ul></li><li>丘成桐认为陈景润不伟大</li></ul></li></ul></li></ul><h3 id="冯康">冯康</h3><ul><li>中国近代科学计算之父</li><li>我国十三位首席科学家之一</li><li>研究领域：<ul><li>数值分析</li><li>计算数学</li><li>差分方程</li></ul></li><li>成就：<ul><li>发展了数值分析和计算数学的理论与方法</li><li>在差分方程和数值积分方面做出了重要贡献</li></ul></li><li>家里兄弟姐妹都了不起<ul><li>弟弟：冯端，凝聚态物理学家、为纳米材料学家，十三位首席科学家之一</li><li>哥哥：中山大学工程师</li><li>姐姐：冯慧<ul><li>姐夫：叶笃正，中国大气物理学创始人</li></ul></li></ul></li><li>表面不用功，但是成绩好</li><li>苏州中学毕业</li><li>第一名考进重庆中央大学电机系<ul><li>读“科学”（胡明复，交大），喜欢“数学”</li><li>申请转系被拒绝，于是两个专业一起学</li><li>大三得了肺结核，回家养病，奇迹康复</li></ul></li><li>毕业后担任复旦（震旦）大学数学物理系助教<ul><li>后来又担任清华大学物理系及数学系助教</li></ul></li><li>尊重华罗庚<ul><li>进入中国科学院计算技术研究所工作</li><li>进入苏联斯捷克洛夫数学研究所进修<ul><li>导师：庞特里亚金（盲人）</li></ul></li><li>华罗庚指派任务：组建中科院计算中心</li></ul></li><li>冯康在解决大型水坝计算问题时，总结了“数学方法”，发文：<ul><li>《基于变分原理的差分格式》</li><li>有限元法<ul><li>国家自然科学奖二等奖</li></ul></li><li>发了一篇中文一篇英文，因此倒大霉：批斗、改造<ul><li>平反后成为中科院院士</li></ul></li></ul></li><li>提出哈密顿系统的辛几何算法<ul><li>国家自然科学奖一等奖</li></ul></li><li>去世后追悼会上悼文称他为“国际知名数学家”<ul><li>弟弟冯端不满：“知名”评价太低</li><li>美国庆祝数学会成立100周年时，P.D.Lax在演讲中提到有限元方法，称冯康为“国际著名数学家”</li><li>中科院补救：中国科学报一年内每期都要刊登冯康的悼文</li></ul></li></ul><h3 id="张恭庆">张恭庆</h3><ul><li>中国科学院院士</li><li>研究领域：和陈省身相似<ul><li>微分几何</li></ul></li><li>中学：上海市南洋模范中学</li><li>拔青苗：四年毕业</li><li>北大数学系十大神童之尾<ul><li>之首：张景中</li></ul></li><li>刻苦，英文好，因此被借调校核工业</li><li>改革开放后，赴美进修：柯朗数学研究所</li><li>“大陆数学实力第一”</li></ul><p><img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload alt="人物关系">     </p><div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ae3e036" role="button" aria-expanded="false" aria-controls="collapse-6ae3e036">        <div class="fold-arrow">▶</div>人物关系      </div>      <div class="fold-collapse collapse" id="collapse-6ae3e036">        <div class="fold-content">          <figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">graph LR;</span></span><span class="line"><span style="color: #abb2bf">    A[陈省身]</span></span><span class="line"><span style="color: #abb2bf">    B[丘成桐]</span></span><span class="line"><span style="color: #abb2bf">    C[张恭庆]</span></span><span class="line"><span style="color: #abb2bf">    D[田刚]</span></span><span class="line"><span style="color: #abb2bf">    E[韦东奕]</span></span><span class="line"><span style="color: #abb2bf">    F[李骏]</span></span><span class="line"><span style="color: #abb2bf">    G[吴文俊]</span></span><span class="line"><span style="color: #abb2bf">    H[熊庆来]</span></span><span class="line"><span style="color: #abb2bf">    J[张广厚]</span></span><span class="line"><span style="color: #abb2bf">    I[杨乐]</span></span><span class="line"><span style="color: #abb2bf">    K[文兰]</span></span><span class="line"><span style="color: #abb2bf"></span></span><span class="line"><span style="color: #abb2bf">    A --&gt;|弟子| B</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|有矛盾| C</span></span><span class="line"><span style="color: #abb2bf">    A --&gt;|记名弟子| C</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|学生| F</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|学生| D</span></span><span class="line"><span style="color: #abb2bf">    C --&gt;|学生| D</span></span><span class="line"><span style="color: #abb2bf">    D --&gt;|学生| E</span></span><span class="line"><span style="color: #abb2bf">    C --&gt;|朋友| G</span></span><span class="line"><span style="color: #abb2bf">    B --&gt;|朋友| I</span></span><span class="line"><span style="color: #abb2bf">    C --&gt;|同学| I</span></span><span class="line"><span style="color: #abb2bf">    H --&gt; |学生| I</span></span><span class="line"><span style="color: #abb2bf">    H --&gt; |学生| J</span></span><span class="line"><span style="color: #abb2bf">    G --&gt;|有矛盾| I</span></span><span class="line"><span style="color: #abb2bf">    J --&gt; |搭档，后闹掰| I</span></span><span class="line"><span style="color: #abb2bf">    C --&gt;|内弟| K</span></span></code></pre></div></div></figure>        </div>      </div>    </div><p></p><h3 id="马志明">马志明</h3><ul><li>中科院院士</li><li>研究领域：<ul><li>随机数学</li><li>概率论</li></ul></li><li>重庆人</li><li>毕业后去工厂劳动，业余学数学<ul><li>工农兵大学学生</li><li>恢复高考后不承认工农兵大学，视为专科学历</li></ul></li><li>1978年恢复高考，考上王寿仁的研究生<ul><li>王寿仁：研究随机数学</li><li>随机数学研究领域冷门：被派出国进修</li></ul></li><li>为人好</li></ul><div class="note note-info">            <ul><li>中国数学三大奖<ul><li>陈省身奖：</li><li>华罗庚奖</li><li>钟家庆奖</li></ul></li></ul>          </div><h3 id="吴文俊">吴文俊</h3><ul><li>交大数学系期间，遇到武崇文老师</li><li>回国后，与华罗庚一起</li><li>缺资料研究，下放工厂，思考“机器证明”<ul><li>现在的“人工智能”</li></ul></li><li>证明中的“机证史”<ul><li>机器证明史<ul><li>即“人工智能”</li></ul></li><li>东方：吴文俊<ul><li>理想：<ul><li>马克思：任何学科都可以数学化</li><li>笛卡尔：任何数学问题都可以代数化</li><li>吴文俊：任何代数问题都可以转化为多项式问题</li><li>古人思考：任何多项式问题都可以通过简单动作完成 → 机器化</li></ul></li><li>吴氏方法原理：<ul><li>命题能写作多项式形式<ul><li>命题：已知 &amp; 求证</li><li>已知条件都可以写作多项式形式</li></ul></li><li>消元法</li><li>辗转相除法<ul><li>若最后 <span class="math inline"><em>R</em> = 0</span>，则命题成立，反之若 <span class="math inline"><em>R</em> ≠ 0</span>，则命题不成立</li></ul></li><li>机器证明理论成立！</li></ul></li></ul></li><li>西方：另一条路</li></ul></li><li>学生：周成青<ul><li>在中科院上过吴文俊的机器证明课</li><li>赴美读博，上到另一门机器证明课，用吴文俊课上的笔记完成作业<ul><li>被教授发现，与吴文俊交流</li><li>吴文俊闻名美国</li></ul></li></ul></li></ul><h2 id="证明史计算式与求解史">证明史、计算式与求解史</h2><h3 id="求解史">求解史</h3><ul><li>一元一次方程：<ul><li>古希腊、两河流域文明：无刻度的圆规加直尺作出的图形</li></ul></li><li>一元二次方程：<ul><li>部分可解，如 <span class="math inline"><em>x</em><sup>2</sup> + 3<em>x</em> + 2 = 0</span></li><li>部分解不出，如 <span class="math inline"><em>x</em><sup>2</sup> + 1 = 0</span></li><li>韦达：形式解<ul><li>对于 <span class="math inline"><em>a</em><em>x</em><sup>2</sup> + <em>b</em><em>x</em> + <em>c</em> = 0</span>，有根<span class="math inline">$x_\pm=\frac{-b\pm\sqrt{b^2-4ac}}{2a}$</span></li><li>根<ul><li>正根：有自然意义</li><li>负根：没有自然意义</li><li>复数：“魔鬼”</li></ul></li></ul></li></ul></li><li>一元三次方程：<ul><li>无人能解出公式解</li><li>意大利：流行打擂</li><li>塔尔塔塔利亚（真名：丰塔纳）：<ul><li>条件：<span class="math inline"><em>b</em><sup>2</sup> + <em>c</em><sup>2</sup> ≠ 0</span>且 <span class="math inline"><em>b</em><em>c</em> = 0</span> 则有解</li><li>打擂天下无敌，但坚决不收徒</li></ul></li><li>卡尔达诺<ul><li>医生</li><li>天才，要拜师塔尔塔塔利亚，被拒绝，最终成功</li><li>找了个天才学生到乡下潜心研究，成功得到无条件的一元三次方程公式解</li><li>卡尔达诺公式：<ul><li>将一般三次方程 <span class="math inline"><em>y</em><sup>3</sup> + <em>a</em><em>y</em><sup>2</sup> + <em>b</em><em>y</em> + <em>c</em> = 0</span>经过代换 <span class="math inline"><em>y</em> = <em>x</em> − <em>a</em>/3</span> 化为<span class="math inline"><em>x</em><sup>3</sup> + <em>p</em><em>x</em> + <em>q</em> = 0</span>的形式<ul><li><span class="math inline">$u=\sqrt[3]{-\frac{q}{2}+\sqrt{\left(\frac{q}{2}\right)^2+\left(\frac{p}{3}\right)^3}}$</span></li><li><span class="math inline">$v=\sqrt[3]{-\frac{q}{2}-\sqrt{\left(\frac{q}{2}\right)^2+\left(\frac{p}{3}\right)^3}}$</span></li><li><span class="math inline">$w=\frac{-1+\sqrt{3}i}{2}$</span></li></ul></li><li>则 <span class="math inline"><em>x</em></span> 的三个根为<ul><li><span class="math inline"><em>x</em><sub>1</sub> = <em>u</em> + <em>v</em></span></li><li><span class="math inline"><em>x</em><sub>2</sub> = <em>u</em><em>w</em> + <em>v</em><em>w</em><sup>2</sup></span></li><li><span class="math inline"><em>x</em><sub>3</sub> = <em>u</em><em>w</em><sup>2</sup> + <em>v</em><em>w</em></span></li></ul></li></ul></li><li>出书：《大术》（又叫《大法》）<ul><li>引发塔尔塔塔利亚不满，发起挑战却一败涂地，最终郁郁而终</li><li>卡尔达诺辩解：“不是掠美者”</li><li>后人评价：卡尔达诺不是“掠美者”，《大术》即使除去一元三次方程和一元四次方程，仍是一本伟大的书</li></ul></li></ul></li></ul></li><li>一元四次方程：<ul><li>也被卡尔达诺和学生费拉里解决</li><li>费拉里：天才，卡尔达诺的学生</li></ul></li><li>一元五次方程：<ul><li>万人坑</li><li>“英雄”<ul><li>阿贝尔（Abel）<ul><li>挪威数学家</li><li>政府出款到法国游学，见到了柯西（Cauchy）<ul><li>阿贝尔严谨，柯西则草率</li><li>与柯西矛盾大，纠柯西的错：<ul><li>一致连续 &amp; 一致收敛</li></ul></li></ul></li><li>钱花完后回挪威，得了肺炎，27岁就去世了</li><li>评价：那个时代的“阿基米德”</li></ul></li><li>伽罗华（Galois）<ul><li>考大学时面试，嫌弃题目太简单，结果被考官刷了</li><li>与人决斗，决斗前一晚写下“伽罗华遗书”，其中包含了他对一元五次方程的研究成果，托付给好朋友发布<ul><li>决斗而死，享年21岁</li></ul></li><li>新数学体系：群论<ul><li>开创了近世代数</li><li>可解决一元五次方程、一元六次方程……</li></ul></li><li>评价：人类前二十位数学家</li></ul></li><li>雅各比（Jacobi）<ul><li>德国数学家</li><li>相对前两者长寿，享年四十多岁</li><li>三人都住在法国巴黎，却没有见过面</li></ul></li></ul></li></ul></li><li>二元方程</li><li>多元方程</li><li>偏微分方程（PDE）</li><li>随机PDE方程（B-S方程）</li><li>金融</li><li>湍流</li></ul><h3 id="计算式">计算式</h3><ul><li>手算（境界）</li><li>石头算</li><li>比例规</li><li>算盘（中国）</li><li>计算尺</li><li>计算器</li><li>机械计算机</li><li>电子计算机</li></ul><h4 id="计算机史">计算机史</h4><ul><li>库卡勒<ul><li>考古祖宗</li><li>开普勒：好朋友</li></ul></li><li>帕斯卡<ul><li>遗传祖宗</li><li>发明机器：加减法</li></ul></li><li>莱布尼茨<ul><li>机器：加减乘除</li><li>引入梯形轴</li></ul></li><li>托马斯<ul><li>法国人</li><li>1820年：手摇计算机</li><li>历经一百多年：打字机</li></ul></li><li>巴贝奇<ul><li>英国</li><li>超世代的传奇人物</li><li>“数学史科学之眼、也是工程之手”</li><li>悲剧人物</li><li>1834年：发明差分机</li><li>事迹被编为舞台剧</li><li>支持的人数极少（<span class="math inline"> ≤ 3</span>）：儿子、拜伦的女儿、墨索里尼手下的一个军官</li></ul></li><li>霍列瑞斯<ul><li>美国</li><li>1884年：统计机</li><li>1896年：创立IBM公司</li></ul></li><li>楚泽<ul><li>几点计算机</li><li>清华订购</li><li>维纳：好朋友<ul><li>现代控制论</li></ul></li></ul></li><li>图灵<ul><li>英国</li><li>1936年：理想计算机</li><li>同性恋</li><li>氰化钾中毒而死</li><li>消息传到美国，美国计算机界震惊<ul><li>ACM大赛，设图灵奖</li></ul></li></ul></li><li>莫里希 &amp; 埃克特<ul><li>研究弹道</li><li>卡内基·梅隆大学</li></ul></li><li>冯诺依曼<ul><li>冯诺依曼架构</li><li>数据与代码分离</li></ul></li></ul><h3 id="证明史">证明史</h3><ul><li>起源于古希腊</li><li>演绎证明：真理是什么<ul><li>柏拉图</li><li>亚里士多德</li><li>欧几里得</li></ul></li><li>归纳证明<ul><li>不完全归纳</li><li>完全归纳：需要可操作<ul><li>发明数学归纳法</li></ul></li></ul></li><li>线性组合为证明<ul><li>吴文俊</li></ul></li><li>举例为证明<ul><li>张景中</li><li>证法（可读性）</li></ul></li></ul><h4 id="机器证明史">机器证明史</h4><ul><li>证明史 → 统计证明 → 人工智能</li><li>设想阶段<ul><li>1950年，塔斯基：许多初等几何问题，都可以机器化</li><li>Hilbert：许多数学问题，其证明都可以机械化</li></ul></li><li>实验阶段<ul><li>卡内基大学、兰德公司<ul><li>1956年，尝试机证：罗素的《数学原理》第二章，共56个结论，证明了36结论</li><li>开创世界上第一个人工智能专业</li><li>1961年，通过改进方法，成功证明《数学定理》第二章全部56个结论</li></ul></li><li>王浩<ul><li>美籍华人</li><li>中学：山东济南一中</li><li>师从金岳霖，学习逻辑学，后到约翰霍普金斯大学进修</li><li>九分钟机证《数学原理》中的所有定理</li></ul></li><li>1976年起，流行“机证悲观论”<ul><li>只能证明已有知识，无法创新</li></ul></li><li>周成清让西方机器证明界看到“吴氏方法”<ul><li>有许多应用</li></ul></li></ul></li></ul><p><a href="#吴文俊" name="https://ts2.tc.mm.bing.net/th/id/OIP-C.i_QiY8asoaPIoYAECoJ72gHaJr?w=231&amp;h=300&amp;c=10&amp;rs=1&amp;bgcl=fffffe&amp;r=0&amp;o=6&amp;dpr=1.5&amp;pid=23.1" class="LinkCard">中国近代著名数学家-吴文俊-机器证明史</a></p><h2 id="数学史上的三大危机">数学史上的三大危机</h2><ul><li>背景：数学的发展史是一部血泪史<ul><li>矩阵</li><li>玻尔兹曼：统计力学</li><li>康托尔：集合论</li><li>巴贝奇</li><li>古诺</li><li>勒贝格：实数理论</li></ul></li><li>三大危机<ul><li>无理数</li><li>无穷小</li><li>集合论</li></ul></li></ul><h3 id="第三危机罗素悖论与集合论">第三危机：罗素悖论与集合论</h3><ul><li>罗素悖论：19世纪末，康托尔的集合论引发了关于集合的自指问题，导致了数学基础的重大危机。<ul><li>罗素：理发师悖论</li><li>康托尔：建立一一对应关系<ul><li>集合：有限 &amp; 无限</li></ul></li></ul></li><li>面对悖论：数学界大乱，持悲观态度<ul><li>希尔伯特（德）：“如果数学都失灵了，那我们去哪里寻求真理”</li><li>庞加莱（法）：“围墙做成之前，羊群里已经混入了狼”</li><li>克莱因（德）：科学 <span class="math inline">≠</span> 艺术</li></ul></li><li>数学界出现许多派别<ul><li>逻辑主义：罗素、弗雷格<ul><li>{数学} <span class="math inline">∈</span>{逻辑}，而逻辑是可以胡说八道的</li><li>口号：我们不知道</li></ul></li><li>直觉主义：布劳威尔（不动点理论）、克罗内克<ul><li>数学的可解不是逻辑，而是有限步的感觉与构造</li><li>每一步可以检验</li><li>主张构造性解（公式解）</li><li>口号：只有自然数是真的，是上帝创造的，其他都是人造的</li></ul></li><li>形式主义：希尔伯特<ul><li>拔高了欧几里得几何</li><li>希尔伯特医生坚持用“形式主义”改造数学<ul><li>1922年，希尔伯特发表《数学的逻辑基础》，史称“希尔伯特纲领”/“希尔伯特计划”</li><li>奋斗了二十余年，写了9本书</li><li>1927年，访问汉堡时，希尔伯特宣称：“人生目标就是一劳永逸地消除任何对数学基础可靠性的怀疑”</li></ul></li><li>特点：头（讲究直觉主义） <span class="math inline">→</span>尾（讲究逻辑主义）</li><li>口号：我们知道</li><li>《论数学原理和有关系统中的形式不可判定命题》<ul><li>1931年，哥德尔发表了《不完全性定理》，证明了希尔伯特纲领的失败</li><li>哥德尔：数学的基础是逻辑，但逻辑不能完全化</li><li>希尔伯特纲领的失败，导致数学界陷入深深的危机</li></ul></li></ul></li></ul></li></ul><h1 id="期末考试">期末考试</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f3d6fb6" role="button" aria-expanded="false" aria-controls="collapse-8f3d6fb6">        <div class="fold-arrow">▶</div>开卷考试题库      </div>      <div class="fold-collapse collapse" id="collapse-8f3d6fb6">        <div class="fold-content">          <ol type="1"><li>希尔伯特的二十三个问题</li><li>谈数学家与数学事件（事迹+感想）<ul><li>马骁</li><li>中科大：华罗庚数学科技英才班</li><li>Zaher Hani</li><li>斯隆奖</li><li>塞勒姆奖</li><li>王艺霖</li><li>Fredrik Viklund</li><li>Emmanuel Ullmo</li><li>法国高等科学研究所</li><li>郑乐隽</li><li>Maryam Mirzakhani 新领域奖</li><li>潘略</li><li>詹大鹏</li><li>望月新一</li><li>加藤文元</li><li>李超（柯朗所）</li><li>大卫·本兹维</li><li>梅松 与 统计+人工智能</li><li>陈麟 与 数学界四大期刊（影响因子3.5-4.8）</li><li>Andrea Montanari</li><li>位学鑫</li><li>16世纪意大利数学家帕乔利</li><li>亚马逊研究奖</li><li>西蒙斯 及 西蒙斯学者奖</li><li>阿瑟·凯莱（英国）</li><li>Dirichlet</li><li>肖梁（北大）</li><li>保罗·潘勒韦（法国）</li></ul></li></ol>        </div>      </div>    </div><h2 id="希尔伯特的二十三个问题">希尔伯特的二十三个问题</h2><ol type="1"><li>康托尔的连续统基数问题</li><li>算术公理的相容性</li><li>两个等底等高的四面体体积相等的证明</li><li>直线作为两点间最短距离问题</li><li>李群的连续变换群的局部同构与整体同构问题（连续群的解析解）</li><li>物理公理的数学处理</li><li>某些数的无理性与超越性</li><li>素数问题（含黎曼猜想、哥德巴赫猜想、孪生素数问题等）</li><li>任意数域中最一般的互反律的证明（推广二次互反律）</li><li>丢番图方程的可解性（判断整系数方程是否有整数解的算法）</li><li>系数为任意代数数的二次型问题</li><li>阿贝尔域上的克罗内克定理推广到任意代数有理域</li><li>不可能用只有两个变数的函数解一般的七次方程</li><li>证明某类完全函数系的有限性（代数不变量理论）</li><li>舒伯特计数演算的严格基础（枚举几何基础）</li><li>代数曲线和曲面的拓扑问题</li><li>正定形式的平方和表示（正定有理函数表为有理函数平方和）</li><li>由全等多面体构造空间（空间的tiling问题）</li><li>正则变分问题的解是否一定解析</li><li>一般边值问题（椭圆型微分方程边值问题）</li><li>具有给定单值群的线性微分方程解的存在性（黎曼问题）</li><li>用自守函数一致化解析关系（黎曼曲面单值化）</li><li>变分法的进一步发展</li></ol><h2 id="数学家与数学事件">数学家与数学事件</h2>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dc196ccd" role="button" aria-expanded="false" aria-controls="collapse-dc196ccd">        <div class="fold-arrow">▶</div>马骁      </div>      <div class="fold-collapse collapse" id="collapse-dc196ccd">        <div class="fold-content">          <ul><li>2014年考入中国科学技术大学少年班学院，2015年被华罗庚数学科技英才班录取，2023年获普林斯顿大学博士学位，现为密歇根大学DonaldJ.Lewis助理教授。主要研究领域为分析学与动力学理论，聚焦数学物理中的核心问题。</li><li>2025年4月，他与芝加哥大学邓煜教授、密歇根大学ZaherHani教授合作，在希尔伯特第六问题的研究中取得重要进展：在两个特定假设之下，解决了希尔伯特第六问题——一个是只考虑硬球散射系统；另一个是只考虑玻尔兹曼的动力学理论。</li><li>感想：马骁的成就展示了年轻数学家的潜力和对数学基础问题的深入研究。他的工作不仅推动了分析学与动力学理论的发展，也为希尔伯特第六问题的解决提供了新的视角和方法。他的成果使他成为菲尔兹奖的有力竞争者，彰显了年轻一代数学家的创新能力和学术贡献。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9d925894" role="button" aria-expanded="false" aria-controls="collapse-9d925894">        <div class="fold-arrow">▶</div>中科大：华罗庚数学科技英才班      </div>      <div class="fold-collapse collapse" id="collapse-9d925894">        <div class="fold-content">          <ul><li>是由高校与中国科学院数学与系统科学研究院联合创办的数学拔尖人才培养项目，旨在通过科教融合模式培育数学领域精英人才，入选教育部“基础学科拔尖学生培养计划”。班级采用“3+1”培养机制，前三学年高校学习基础课程，第四学年进入科研院所实践，课程涵盖数学、统计学等学科，并融入荣誉课程体系。实行小班教学、个性化导师制，配置院士及杰出学者资源，同时建立动态选拔与退出机制。注重国际化学术交流，定期组织师生赴国内外高校开展科研合作与访学。该项目始于2009年中国科学技术大学与中科院数学院的合作，2024年与同济大学签约成立新的华罗庚数学科技英才班。</li><li>感想：华罗庚数学科技英才班的成立和发展，体现了中国在数学教育和人才培养方面的前瞻性和创新性。通过与中科院数学院的合作，该项目不仅为学生提供了优质的教育资源，还促进了学术界与科研界的紧密联系。这样的培养模式有助于发掘和培养未来的数学精英，为国家和社会的发展做出贡献。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-ce04ff4d" role="button" aria-expanded="false" aria-controls="collapse-ce04ff4d">        <div class="fold-arrow">▶</div>Zaher Hani      </div>      <div class="fold-collapse collapse" id="collapse-ce04ff4d">        <div class="fold-content">          <ul><li>ZaherHani是一位密歇根大学的数学教授。他在数学领域尤其是非线性偏微分方程和希尔伯特第六问题的研究上取得了显著成就。2007年，获得美国贝鲁特大学数学学士学位；2008年，获得加州大学洛杉矶分校（UCLA）硕士学位；2011年，在UCLA完成博士论文，师从陶哲轩。2011年至2014年，担任纽约大学库朗数学科学研究所库朗讲师兼西蒙斯研究员；2014年至2018年，在佐治亚理工学院担任助理教授；2018年起，担任密歇根大学数学教授。</li><li>主要研究非线性偏微分方程（PDE）的数学分析，以及它与统计物理和湍流理论的联系，具体涉及量子物理、海洋学、大气科学、等离子体理论、非线性光学和广义相对论等多个领域。</li><li>观察他的论文，发现他与华人学者邓煜合作发表了多篇论文，2025年，他与芝加哥大学助理教授邓煜和密歇根大学研究助理教授马骁合作，完成了关于希尔伯特第六问题的论文《希尔伯特第六问题：由玻尔兹曼运动学得出流体方程》，在希尔伯特第六问题的研究中取得了重要进展。他们证明了在无限空间的设定下，玻尔兹曼对气体的描述可以从牛顿的描述中推导出来，完成了气体从微观到介观转化过程这一逻辑链，在将物理学公理化方面取得了重大进展。</li><li>感想：ZaherHani的研究展示了数学分析在物理学中的重要性，尤其是在理解复杂系统和现象方面。他的工作不仅推动了偏微分方程的研究，也为统计物理学和湍流理论提供了新的视角和方法，彰显了数学与物理的深刻联系。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-bc86d58b" role="button" aria-expanded="false" aria-controls="collapse-bc86d58b">        <div class="fold-arrow">▶</div>斯隆奖（Sloan Research Fellowship）      </div>      <div class="fold-collapse collapse" id="collapse-bc86d58b">        <div class="fold-content">          <ul><li>斯隆研究奖于1955年设立，每年颁发一次，由斯隆基金会管理，奖金7.5万美元，该奖项旨在支持和奖励处于职业早期阶段的杰出科学家和学者，被称为“诺奖风向标”。授予学科领域有：化学、分子生物学、计算机科学、经济学、数学、神经科学、物理学和海洋科学。</li><li>截止 2025 年 2 月，已有 58 位斯隆奖得主获得诺贝尔奖，17位获得数学界“诺贝尔奖”菲尔兹奖，72 位获得美国国家科学奖章。今年入选 2025年度斯隆研究奖的华人学者共计 28 人，占比约22.2%，包括我校李一璇校友、北京大学数学科学学院的位学鑫、李超、潘略、连宸、梅松。</li><li>感想：斯隆奖的设立和发展，体现了对年轻科学家和学者的重视与支持。通过提供资金和资源，该奖项为他们的研究和学术发展创造了良好的环境，激励更多的年轻人投身科学事业。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-0a3a367f" role="button" aria-expanded="false" aria-controls="collapse-0a3a367f">        <div class="fold-arrow">▶</div>塞勒姆奖（Salem Prize）      </div>      <div class="fold-collapse collapse" id="collapse-0a3a367f">        <div class="fold-content">          <ul><li>塞勒姆奖于1968年设立，每年颁奖一次，用以纪念拉斐尔·塞勒姆。拉斐尔·塞勒姆是一位数学家，因其对傅里叶级数和数论之间联系的深入研究以及概率方法在这些领域的开创性应用而闻名，在法国调和分析的发展中发挥了重要作用。因此，塞勒姆奖旨在表彰在调和分析、傅里叶分析、数论等领域做出杰出贡献的年轻数学家，获奖者中有许多人后来也成为菲尔兹奖得主。2024年，塞勒姆奖授予了两位数学家，其中一名为中国数学家王艺霖，成为塞勒姆奖首位女性华人得主。</li><li>感想：塞勒姆奖的设立和发展，体现了对调和分析和数论领域杰出贡献的认可与鼓励。王艺霖作为首位女性华人得主，不仅为她个人的学术成就增添了光彩，也为更多女性数学家树立了榜样，激励她们在科学研究中追求卓越。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-3535e68a" role="button" aria-expanded="false" aria-controls="collapse-3535e68a">        <div class="fold-arrow">▶</div>王艺霖      </div>      <div class="fold-collapse collapse" id="collapse-3535e68a">        <div class="fold-content">          <ul><li>1991年出生的王艺霖成长于中国上海。她初中起就读于上海外国语大学附属中学，学习法语，高一时去法国交流。参加法国教育部招生选拔时，没有进行数学竞赛的培训，因此勉强及格，但是使用法语答题，且面试时自信，成功被录取。2011年考入巴黎高等师范学院，后前往巴黎第六大学学习几何，获得了基础数学硕士学位；前往巴黎第十一大学继续学习，获得了概率与统计硕士学位。</li><li>2024年，她因在复分析、概率和数学物理之间建立深层新颖的联系而荣获塞勒姆奖，特别是在Teichmuller 理论和 Schramm-Loewner演化理论方面。作为该奖项首位女性华人得主，在她之前仅有陶哲轩和詹大鹏这两位华人数学家摘得这一奖项。在接受媒体采访时，自称自己“只是一个普通人”。</li><li>不仅要取得最佳结果，还要实现最优雅的证明。</li><li>感想：王艺霖的成就展示了女性在数学领域的卓越贡献和潜力。她的研究不仅将复分析、概率和数学物理之间建立了新的联系，也为女性数学家树立了榜样。她的谦逊态度和对学术的热爱，激励着更多年轻人投身科学研究。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6cb6958f" role="button" aria-expanded="false" aria-controls="collapse-6cb6958f">        <div class="fold-arrow">▶</div>Fredrik Viklund      </div>      <div class="fold-collapse collapse" id="collapse-6cb6958f">        <div class="fold-content">          <ul><li>FredrikViklund曾是哥伦比亚大学的西蒙斯研究员和里特助理教授，之后在乌普萨拉大学担任副教授。目前，他是瑞典皇家理工学院的数学教授。他是瓦伦堡学者，受到戈兰・古斯塔夫松基金会的支持，还获得了瓦伦堡学院研究员的长期资助，这使他能够专注于具有挑战性和趣味性的数学问题研究，并聘请更多的博士生和博士后推动研究进展。他从KTH 获得博士学位，并在 2010-2013 年在哥伦比亚大学担任 Simons 研究员和J.F.Ritt 助理教授。</li><li>他的主要兴趣领域是复分析、概率和数学物理学，也对计算机科学和应用数学的某些方面感兴趣，致力于开发新的数学方法来更精确地描述量子场论中随机波动的场。他还对施Schramm-LoewnerEvolution曲线进行了研究，与美国麻省理工学院的研究人员合作，探索了 SLE曲线的随机世界与 Weil-Petersson 曲线的确定性世界之间的数学关系。</li><li>2024年，他与王艺霖合作，基于SLE和更广泛的随机共形几何的结果，证明了关于通用泰希米勒空间的新结果。</li><li>感想：FredrikViklund的研究展示了数学在物理学和计算机科学中的应用潜力。他与王艺霖的合作成果，进一步推动了随机共形几何领域的发展，为理解复杂系统提供了新的视角和方法。他的工作激励着更多年轻数学家探索跨学科的研究领域。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-448cf81d" role="button" aria-expanded="false" aria-controls="collapse-448cf81d">        <div class="fold-arrow">▶</div>Emmanuel Ullmo      </div>      <div class="fold-collapse collapse" id="collapse-448cf81d">        <div class="fold-content">          <ul><li>EmmanuelUllmo是一位法国数学家，现任法国高等科学研究所（IHES）所长。他1985年毕业于卡尚高等师范学校，1992年在巴黎第十一大学获得数学科学博士学位。他曾在巴西纯数学与应用数学研究所（IMPA）工作18个月，在美国普林斯顿大学任职两年，在中国清华大学访问六个月。2001年起担任巴黎第十一大学教授，2007年至2010年担任奥赛数学系主任和专家委员会主席。2002年至2006年是埃米尔·博雷尔中心科学委员会成员，2006年起成为《数学发明》杂志编辑委员会成员，并在2008年至2014年担任两位主编之一。</li><li>他与Chris Daw和AlexanderGorodnik合作证明了局部对称空间的最大Satake紧化上的齐次测度空间是紧的。与GregorioBaldi合作证明了复仿射空间的单位球被非算术格商的最大全测地子簇集合的有限性。</li><li>2002年被邀请在北京市举行的国际数学家大会上发言，2003年至2008年成为法国大学学院成员，2006年获得巴黎科学院埃利·嘉当奖。他指导的学生陈柯于2010年获首届新世界数学奖（博士论文银奖），并在顶级数学杂志发表多篇论文。</li><li>作为IHES所长，Ullmo积极推动国际学术合作。2023年，他向武汉大学代表团介绍了IHES的情况，并表示支持双方学者在数学领域加强合作，共同举办学术会议，培养顶尖科研人才。</li><li>感想：EmmanuelUllmo的成就展示了他在数学领域的深厚造诣和对学术界的贡献。他在IHES的领导下，推动了国际学术合作，为数学研究提供了良好的平台。他的工作不仅促进了数学的发展，也为年轻学者提供了宝贵的指导和支持。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-47787c85" role="button" aria-expanded="false" aria-controls="collapse-47787c85">        <div class="fold-arrow">▶</div>法国高等科学研究所（IHES）      </div>      <div class="fold-collapse collapse" id="collapse-47787c85">        <div class="fold-content">          <ul><li>法国高等科学研究所（Institut des Hautes EtudesScientifiques，IHES）是一所专注于数学、理论物理及相关领域前沿研究的学术机构。1958年，俄罗斯商人及数学家莱昂·莫查内创建了IHES，他从普林斯顿高等研究所吸取灵感，希望建设一所比肩普林斯顿高等研究所的欧洲研究院。1962年，莫查内买下了巴黎郊区Bures- sur - Yvette的Bois -Marie小镇的一部分土地，包括10公顷的森林和一座小山，自此IHES一直坐落于此。</li><li>截至2025年，IHES有主任1名，数学领域常任教授5位，物理学常任教授3位，另有4位是法国国家科学研究中心资助的研究人员。此外，每年还有约200名访问学者前来交流合作，访问时间平均为两个月。自成立以来，IHES已有8位数学常任教授获得菲尔兹奖，3位数学教授荣获阿贝尔奖。IHES的“访问学者项目”为全球研究人员提供了自由交流的平台，许多知名物理学家和数学家都曾作为受邀研究员访问过该所，包括默里·盖尔曼（MurrayGell - Mann）、阿尔弗雷德·卡斯特勒（AlfredKastler）、陈省身等。常任教授们会邀请领域内的同行展开合作研究项目，访问学者也能与研究所的人员进行深入的学术讨论。</li><li>2025年9月1日，中国数学家王虹将正式就任IHES数学终身教授，她将延续该院在分析与几何学领域的卓越传统，为研究所的发展注入新的活力。</li><li>感想：IHES作为欧洲顶尖的数学和物理研究机构，汇聚了众多杰出学者和研究人员。它不仅为学术界提供了一个高水平的交流平台，也推动了数学和物理学的前沿研究。王虹的加入将进一步增强IHES在全球数学界的影响力，为未来的研究开辟新的方向。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-2a70670f" role="button" aria-expanded="false" aria-controls="collapse-2a70670f">        <div class="fold-arrow">▶</div>郑乐隽      </div>      <div class="fold-collapse collapse" id="collapse-2a70670f">        <div class="fold-content">          <ul><li>郑乐隽（EugeniaCheng）是一位华裔女性数学家。她是剑桥大学数学博士，现任美国芝加哥艺术学院常驻科学家。她曾在英国曼彻斯特大学、剑桥大学、美国芝加哥大学和法国尼斯大学任教。</li><li>郑乐隽将“消除世界上所有人对数学的恐惧”视为终身奋斗的事业。她认为人们对数学的惧怕源于对原理、公式的畏难情绪以及缺乏想象力的解释。为此，她撰写了《超越无穷大》《数学思维》《逻辑的力量》《数学的逻辑》等多部数学科普畅销书。其中，《数学的逻辑》一书通过简单问题帮助读者重新理解数学原理和公式，揭示数学的本质逻辑。她的科普作品被英国《卫报》授予“科学与自然类新秀作者”奖。此外，她在YouTube上的演讲视频浏览量超过100万次，曾在电视节目上“烘焙π”，用小提琴“演奏”函数，以独特方式传播数学知识。</li><li>作为纯数学家，郑乐隽在数学领域有深入研究，她是伦敦城市大学纯数学荣誉客座研究员。其研究方向可能涉及范畴论等抽象数学领域，不过具体的学术研究成果尚未有广泛公开的详细报道。</li><li>感想：郑乐隽的工作不仅在学术界取得了成就，更在普及数学知识方面做出了重要贡献。她通过通俗易懂的方式，帮助人们克服对数学的恐惧，激发了更多人对数学的兴趣和热爱。她的努力为数学教育和科普事业树立了榜样。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-040231a3" role="button" aria-expanded="false" aria-controls="collapse-040231a3">        <div class="fold-arrow">▶</div>Maryam Mirzakhani 新领域奖      </div>      <div class="fold-collapse collapse" id="collapse-040231a3">        <div class="fold-content">          <ul><li>Maryam Mirzakhani新前沿奖（Maryam Mirzakhani New FrontiersPrize）是科学突破奖（BreakthroughPrize）的子奖项之一，该奖项由突破奖基金会于2019年设立，以已故伊朗数学家、菲尔兹奖首位女性得主MaryamMirzakhani的名字命名，旨在表彰和激励旨最近获得博士学位并取得重要成果的女性数学家。奖金每人5万美元，该奖项可由多人共同获得，候选人的博士论文必须作为提名的一部分提交，且需提供不超过10篇来自指定学术出版数据库的引用文献。</li><li>2025年，斯坦福大学的李思颖（Si YingLee）获奖，用于表彰其对志村簇（Shimuravarieties）理论的贡献；波恩大学、马克斯·普朗克数学研究所的拉朱拉·斯里瓦斯塔瓦（RajulaSrivastava），用于表彰其在调和分析及解析数论领域的贡献、包括对光滑流形附近有理点计数问题的研究；加州大学伯克利分校的埃文·唐（EwinTang），用于表彰其为机器学习和线性代数开发了量子算法的经典模拟方法、并在量子数据的量子机器学习方面取得进展。</li><li>感想：MaryamMirzakhani新前沿奖的设立，旨在鼓励和支持女性数学家在学术界的发展。通过表彰年轻女性数学家的杰出贡献，该奖项不仅提升了女性在数学领域的地位，也激励更多女性投身科学研究，推动了数学学科的多样性和包容性。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-b89955b2" role="button" aria-expanded="false" aria-controls="collapse-b89955b2">        <div class="fold-arrow">▶</div>潘略      </div>      <div class="fold-collapse collapse" id="collapse-b89955b2">        <div class="fold-content">          <ul><li>潘略是一位杰出的青年数学家，现任普林斯顿大学数学系助理教授。他2009年获得CMO金牌，同年参加高考，取得北京市理科第6名，数学成绩满分，2009-2013年就读于北京大学数学科学学院，获得学士学位；2018年于普林斯顿大学获得博士学位。他从2018年起担任芝加哥大学的讲师，之后回到普林斯顿大学加入数学系，担任助理教授。</li><li>他的研究聚焦于代数数论，特别是p进朗兰兹纲领方向，研究领域包括同调、伽罗瓦和巴拿赫表示、剩余类以及不可约表示等。2020年发布了一个模形式的证明，揭示了局部解析向量与模形式和伪同调之间的关系，为研究模形式提供了新的工具。其研究成果为其他数学家证明普通阿贝尔曲面总能对应一个模形式提供了关键参考，帮助解决了模形式构造中的关键障碍。他获得了2025年斯隆研究奖。</li><li>感想：潘略的研究成果展示了他在代数数论领域的深厚造诣和创新能力。他的工作不仅推动了模形式理论的发展，也为其他数学家提供了重要的参考和工具。他的成就激励着更多年轻数学家在复杂的数学问题上不断探索和创新。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-def5b9be" role="button" aria-expanded="false" aria-controls="collapse-def5b9be">        <div class="fold-arrow">▶</div>詹大鹏      </div>      <div class="fold-collapse collapse" id="collapse-def5b9be">        <div class="fold-content">          <ul><li>詹大鹏是一位知名华人数学家。他于1996年获得南开大学学士学位，2004年获得加州理工学院博士学位。他曾是伯克利数学科学研究所的成员、加州大学洛杉矶分校纯粹与应用数学研究所的高级研究员，以及普林斯顿高等研究院的冯·诺依曼研究员。</li><li>詹大鹏的主要成就在于他在Schramm-Loewner演化（SLE）方面的杰出工作。SLE是复平面上由布朗运动驱动的具有共形不变性与马尔可夫性的单参数随机曲线族，融合现代概率论、统计物理和共形场论的精髓，是描述二维统计物理模型临界行为的强有力工具。詹大鹏在2011年因对SLE的可逆性和对偶性猜想的证明，与JulienDubédat共同获得美国塞勒姆奖。他也是继陶哲轩之后，第二位获得该奖项的华人数学家。同年，他还获得了美国斯隆研究奖中的数学奖。</li><li>感想：詹大鹏的研究成果在数学界产生了深远的影响，特别是在随机共形几何和统计物理领域。他的工作不仅推动了SLE理论的发展，也为理解复杂系统提供了新的视角和方法。他的成就激励着更多年轻数学家在跨学科研究中探索新的可能性。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-7f9d8f0f" role="button" aria-expanded="false" aria-controls="collapse-7f9d8f0f">        <div class="fold-arrow">▶</div>望月新一      </div>      <div class="fold-collapse collapse" id="collapse-7f9d8f0f">        <div class="fold-content">          <ul><li>望月新一1969年3月29日出生于日本东京，是日本京都大学教授。他在数学领域取得了诸多重要成果，尤其是在abc猜想的证明方面备受关注。他16岁时成为普林斯顿大学数学系本科生，后直接进入博士阶段学习，导师是证明了莫德尔猜想的法尔廷斯。1992年，他在普林斯顿大学取得博士学位后回到日本，任职于数理解析研究所。1996年，晋升为京都大学副教授，2002年取得教授职称。他曾获得日本数学会秋季奖、首届日本学术征信会奖、日本学院奖章等荣誉。</li><li>2012年8月30日，望月新一在自己的网站上发布了一篇超过600页的论文，提出跨视宇Teichmüller理论（IUT理论），并声称能够证明abc猜想。该理论使用了一套全新的数学语言，开辟了超脱于现代数学的新范式，引起数学界轰动，但因内容艰深，很长时间内很少有数学家能够理解。2020年4月3日，望月新一的两位同事召开新闻发布会宣布，其关于abc猜想的证明被《数理解析研究所公刊》接收、即将正式发表，不过学界对此仍存在争议。接收这些论文的期刊是《数理解析研究所公刊》（PRIMS）——正如期刊名字所揭示的那样，这个学术期刊的主办单位正是望月新一任职的京都大学，而该期刊的主编，正是望月新一本人</li><li>ABC猜想也被称作厄斯特勒-马瑟猜想，是数论中的一个重要猜想，提出于1985年。它涉及到整数的加法和乘法之间的深刻关系，具体表述为：对于任意正整数a、b、c，如果满足a+ b =c且a、b、c互质，则存在一个常数K，使得c的素因子个数不超过K乘以log(max(a,b, c))。</li><li>感想：望月新一的研究成果在数学界引起了广泛关注和讨论。他的IUT理论为abc猜想提供了新的视角和方法，尽管其内容复杂难解，但其创新性和深度无疑推动了数论和代数几何的发展。如果他的证明最终得到广泛认可，将对数学界产生深远的影响；如若只是哗众取宠，则不免让人感到失望。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-c00ddb7d" role="button" aria-expanded="false" aria-controls="collapse-c00ddb7d">        <div class="fold-arrow">▶</div>加藤文元      </div>      <div class="fold-collapse collapse" id="collapse-c00ddb7d">        <div class="fold-content">          <ul><li>加藤文元是一位日本数学家、科普作家。1968年生于宫城县。他本科毕业于京都大学理学部，后在该校理学研究科数学及数学解析系完成博士课程。他曾担任京都大学研究生院副教授和熊本大学教授，还在德国马克斯·普朗克研究所担任过研究员，并在法国雷恩大学和巴黎第六大学任客座教授。目前是东京工业大学理学部数学科教授。</li><li>作为望月新一的深交挚友，加藤文元对望月新一的IUT理论有深入研究。他从2015年开始与望月新一每月通过Zoom或Skype交流，帮助新一代数学家学习IUT理论，据他估计，2023年世界上熟悉IUT理论的人不到10人。2017年，他在“第四届近现代数学史与数学教育国际会议”上作了“扎里斯基-黎曼空间的历史”的综述报告，分析了黎曼、扎里斯基对该理论的不同贡献。</li><li>他著有《将空间与宇宙联系起来的数学：IUT理论的影响》《加洛阿：天才数学家的生活》《用数学的语言看宇宙：望月新一的IUT理论》等书。其中《用数学的语言看宇宙：望月新一的IUT理论》是解读IUT理论的通俗读物，由望月新一亲自作序推荐。他还主编了《你想知道的数学》《和孩子一起轻松学习儿童数学》等书籍。他的作品获得过日本“八重洲书店大奖”，是第一本获得此奖项（大众读物奖）的数学类读物。</li><li>感想：加藤文元在推动IUT理论的普及和理解方面做出了重要贡献。他的努力不仅帮助了新一代数学家学习这一复杂的理论，也为数学界提供了更多的视角和思考。他的著作和研究为数学教育和科普事业树立了榜样。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9b5a1bbc" role="button" aria-expanded="false" aria-controls="collapse-9b5a1bbc">        <div class="fold-arrow">▶</div>李超      </div>      <div class="fold-collapse collapse" id="collapse-9b5a1bbc">        <div class="fold-content">          <ul><li>李超是一位几何分析领域的杰出青年数学家。他2009-2013年就读于北京大学数学科学学院，获得学士学位，后于斯坦福大学获得博士学位，现任纽约大学柯朗数学科学研究所助理教授，师从RickSchoen和BrianWhite。李超致力于几何分析领域的前沿研究，尤其在极小曲面理论、正标量曲率流形的拓扑分类及高维流形刚性等方面取得了突破性成果。他在《ActaMathematica》《Annals of Mathematics》《InventionesMathematicae》等顶尖期刊发表多篇论文。此外，他还获得了2025年斯隆研究奖。近年来，他通过多场专题学术报告系统展示了与OtisChodosh合作的研究成果，包括解决4-5维非球面流形正标量曲率难题和稳定伯恩斯坦问题等突破性进展。</li><li>李超有以下重要研究成果。高维流形分类：2022年与O.Chodosh合作证明4-5维闭合非球面流形上正标量曲率度量的存在性定理，推进了高维流形分类研究；稳定伯恩斯坦定理：2022年提出R^4空间中稳定各向异性最小超曲面的伯恩斯坦定理，解决了该问题的维度限制；有限莫尔斯指数结构：建立具有有限莫尔斯指数最小超曲面的系统性结构理论，为相关领域提供新的分析框架。</li><li>感想：李超的研究成果展示了他在几何分析领域的深厚造诣和创新能力。他的工作不仅推动了极小曲面理论和正标量曲率流形的研究，也为高维流形分类提供了新的视角和方法。他的成就激励着更多年轻数学家在复杂的数学问题上不断探索和创新。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-117dc6b4" role="button" aria-expanded="false" aria-controls="collapse-117dc6b4">        <div class="fold-arrow">▶</div>大卫·本兹维      </div>      <div class="fold-collapse collapse" id="collapse-117dc6b4">        <div class="fold-content">          <ul><li>大卫·本兹维（DavidBen-Zvi）是一位美国数学家。他1974年6月19日出生，目前是德克萨斯大学奥斯汀分校数学系的教授，担任该校的数学讲席教授。他的研究兴趣集中在表示论、代数几何和数学物理的交叉领域。其近期工作的主要主题是表示论与规范理论的相互作用，探索几何表示论（特别是几何朗兰兹纲领）与同伦代数（导出代数几何）中的新工具以及物理学（拓扑场论和超对称规范理论）中的组织结构之间的相互作用。他与导师爱德华·弗伦克尔（EdwardFrenkel）共同撰写了《顶点代数与代数曲线》（Vertex Algebras and AlgebraicCurves）一书。</li><li>2012年，他当选为美国数学学会会士。2011年至2013年，他获得德克萨斯大学总统协会百年教学奖学金。</li><li>感想：大卫·本兹维的研究成果在数学界产生了深远的影响，特别是在表示论和代数几何的交叉领域。他的工作不仅推动了几何表示论的发展，也为理解复杂系统提供了新的视角和方法。他的成就激励着更多年轻数学家在跨学科研究中探索新的可能性。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-4db09b9d" role="button" aria-expanded="false" aria-controls="collapse-4db09b9d">        <div class="fold-arrow">▶</div>梅松 与 统计+人工智能      </div>      <div class="fold-collapse collapse" id="collapse-4db09b9d">        <div class="fold-content">          <ul><li>梅松是加州大学伯克利分校统计系和电气工程与计算机科学系的助理教授，在统计与人工智能交叉领域具有显著影响力。他本科毕业于北京大学数学科学学院（2010级），后于斯坦福大学获得博士学位，导师为信息论与机器学习专家AndreaMontanari。2025年，他因在生成模型、深度学习理论等方向的开创性工作，获得斯隆研究奖，成为该领域备受瞩目的青年学者。</li><li>梅松的研究聚焦于统计理论与人工智能的深度融合，尤其在生成模型（如语言模型、扩散模型）的理论基础、深度学习的优化动力学、强化学习的样本效率等方向取得了系统性成果，体现了统计学在人工智能理论构建中的核心作用。除斯隆研究奖外，梅松还获得多项重要资助与认可：2024年，他因“深度学习与大规模AI模型的理论基础”研究获得美国国家科学基金会（NSF）职业奖（NSFCareer Award）；同年，他获得谷歌研究学者奖（Google Research ScholarAward）和亚马逊研究奖（Amazon ResearchAward），支持其在生成模型和强化学习领域的前沿探索；他的工作被国际学术界广泛关注，例如其提出的“负偏好优化”（NegativePreferenceOptimization）方法，为大语言模型（LLM）的有效遗忘（unlearning）提供了理论解决方案，相关预印本于2024年4月上线。</li><li>梅松的研究横跨统计学、计算机科学、信息论等多个领域。他通过高维统计推断与量子机器学习算法的结合，探索了复杂系统中的不确定性量化问题，为AI模型的鲁棒性提供了理论支撑。例如，他在《Transformers作为统计学家》一文中，将Transformer架构与统计推断理论结合，证明了其在上下文学习中的可证明性，这一成果为理解和设计高效AI模型提供了新范式。</li><li>感想：梅松的研究展示了统计学在人工智能领域的重要性和潜力。他通过将统计理论与深度学习、生成模型等前沿技术相结合，为AI模型的理论基础提供了坚实支撑。他的工作不仅推动了统计学的发展，也为人工智能的实际应用提供了新的视角和方法。他的成就告诉我们，统计学不仅是数据分析的工具，更是理解和设计智能系统的核心理论基础。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-4541d8fe" role="button" aria-expanded="false" aria-controls="collapse-4541d8fe">        <div class="fold-arrow">▶</div>陈麟      </div>      <div class="fold-collapse collapse" id="collapse-4541d8fe">        <div class="fold-content">          <ul><li>陈麟是清华大学丘成桐数学科学中心的助理教授。他在代数几何领域，尤其是几何朗兰兹纲领研究方面成果显著。陈麟12岁进入中国数学奥林匹克（CMO）竞赛并获得满分，15岁进入国家队并参加国际数学奥林匹克（IMO）竞赛取得金牌。2012年至2016年，陈麟在北京大学获得学士学位，2016年至2021年于哈佛大学取得博士学位，2021年至2023年，他在普林斯顿高等研究院担任博士后，2023年起至今，在清华大学丘成桐数学科学中心担任助理教授。</li><li>2023年，他凭借论文“Nearby Cycles and Dualities in GeometricLanglandsProgram”荣获世界华人数学家联盟（ICCM）博士论文奖。其论文探索了Vinberg类型渐变族上邻近闭链和几何朗兰兹纲领中多种对偶性的关系，证明了自守层的Deligne–Lusztig对偶，解决了Drinfeld–Wang和Gaitsgory提出的猜想。2024年，陈麟作为主要作者之一，参与了由DennisGaitsgory和SamRaskin领导的研究团队，成功证明了几何朗兰兹猜想。该证明由5篇论文组成，总计超过800页，被认为是朗兰兹纲领几何部分的核心突破。</li><li>感想：陈麟的研究成果展示了他在代数几何领域的深厚造诣和创新能力。他的工作不仅推动了几何朗兰兹纲领的发展，也为理解复杂的数学结构提供了新的视角和方法。他的成就激励着更多年轻数学家在代数几何和相关领域不断探索和创新。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-09036715" role="button" aria-expanded="false" aria-controls="collapse-09036715">        <div class="fold-arrow">▶</div>数学界四大期刊      </div>      <div class="fold-collapse collapse" id="collapse-09036715">        <div class="fold-content">          <ul><li>《数学年刊》（Annals of Mathematics）、《数学新进展》（InventionesMathematicae）、《数学学报》（ActaMathematica）和《美国数学会杂志》（Journal of the American MathematicalSociety）。<ul><li>Annals ofMathematics，1874年创建，四大期刊里面最老的期刊，起初由Joel E.Hendricks担任创刊主编。创刊主旨为介绍和分析纯数学及应用数学中社会感兴趣或重要的问题，特别那些在天文学、机械学和工程学中有意思的创新和发现。创办10年后因Hendricks的个人健康问题出现过停办，后又在次年3月份继续出版。继续出版的AnnalsofMathematics更换了主编，几年后期刊被带到现在的普林斯顿。该期刊的一个重要时期是1928-1958年，SolomonLefschetz担任编辑期间，努力将它经营为一个越来越有名和受人尊敬的杂志。反过来，该期刊的崛起也刺激了美国的数学，极大促进了美国数学的发展。目前由普林斯顿大学和其高等研究院联合出版，每两个月出版一刊，每年不过百篇。1998年以来，这本期刊首次出版了电子版，可喜的是，起初电子版是免费的，但不久后，情况发生改变，2003年被转移到非免费的JSTOR中存档，文章在发布5年后才可以免费使用。</li><li>InventionesMathematicae，创立于1966年，月刊。被认为是世界上最负盛名的数学期刊之一。现任主编是Camillo De Lellis (普林斯顿高等研究院)和Jean-Benoît Bost(巴黎大学)。据统计，我国数学家在这个期刊上发表的文章数量要比Annals ofMathematics多一些。</li><li>Acta Mathematica由 Gösta Mittag-Leffler于1882年在瑞典皇家科学院Mittag-Leffler研究院创办。作为季刊，每年只有很少的发文量，所以质量杠杠的。我们大陆的数学家在此期刊上的发文量屈指可数：苏步青在1951年首次在期刊发表文章。之后田刚和朱小华(2000年)、张伟平和麻小南(2014年)。田刚院士与张振雷(2016年)分别发表过文章。</li><li>Journal Of The American MathematicalSociety是美国数学协会在1988所办的期刊，是四大期刊里最年轻的期刊。作为季刊，每年文章量严格控制在32篇，发表相当困难。著名的华人数学家陶哲轩（TerenceTao）在此期刊上发表过多篇文章。</li></ul></li><li>2025年，四大期刊的影响因子分别为：Annals of Mathematics5.27，Inventiones Mathematicae 3.7，Acta Mathematica 6.81，Journal ofthe American Mathematical Society 3.14。</li><li>感想：四大期刊的设立和发展，体现了数学研究的严谨性和创新性。这些期刊不仅为数学家提供了一个展示研究成果的平台，也推动了数学学科的发展。然而，我国数学家在这些期刊上的发文量仍然较少，这反映出我国在数学研究领域的国际影响力还有待提升。希望未来能有更多优秀的中国数学家在这些顶尖期刊上发表研究成果，为全球数学界做出更大的贡献。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-20db0a73" role="button" aria-expanded="false" aria-controls="collapse-20db0a73">        <div class="fold-arrow">▶</div>Andrea Montanari      </div>      <div class="fold-collapse collapse" id="collapse-20db0a73">        <div class="fold-content">          <ul><li>AndreaMontanari是斯坦福大学统计学和数学教授。他在跨学科研究领域成果丰硕，在学术界享有很高的声誉。1997年获得意大利比萨高等师范学校物理学Laurea学位，2001年获得该校理论物理学博士学位，曾在法国巴黎高等师范学院理论物理实验室和美国伯克利数学科学研究所做博士后研究员。2002年至2010年，担任法国国家科学研究中心（CNRS）研究员。2006年加入斯坦福大学，在电气工程系和统计系任教，2021年至2023年担任斯坦福大学工程学院Robertand Barbara Kleist教授。</li><li>2006年获得CNRS理论物理铜奖，2008年获得美国国家科学基金会职业奖，2013年获得日本大川研究助成奖，2016年获得IEEE信息论协会詹姆斯·梅西奖，2020年获得法国统计学会勒·卡姆奖。他还曾获得2008年ACMSIGMETRICS最佳论文奖和2015年应用概率学会最佳出版物奖。2017年当选为IEEE会士，2020年当选为国际数理统计学会会士（IMSFellow）。此外，他还是2018年国际数学家大会报告人、2020年国际数理统计学会奖章讲座演讲人。</li><li>2024年，Andrea Montanari与Germain Kolossov、PulkitTandon合作发表了论文《Towards a statistical theory of data selectionunder weaksupervision》。该论文为数据子集选择建立了统计学基础，并揭示了当前流行的数据选择方法存在的主要缺陷。2025年，AndreaMontanari指导的学生梅松获得斯隆研究奖。</li><li>AndreaMontanari与其他机构的研究人员一起，启动了关于深度学习理论基础的合作项目。该项目由加州大学伯克利分校的研究人员领导，获得了美国国家科学基金会（NSF）和西蒙斯基金会的五年资助，旨在从理论上理解深度学习。</li><li>感想：AndreaMontanari的研究成果在统计学和数学领域产生了深远的影响。他的工作不仅推动了跨学科研究的发展，也为理解复杂系统提供了新的视角和方法。他的成就激励着更多年轻学者在统计学和人工智能等前沿领域不断探索和创新。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-1c5d02ea" role="button" aria-expanded="false" aria-controls="collapse-1c5d02ea">        <div class="fold-arrow">▶</div>位学鑫      </div>      <div class="fold-collapse collapse" id="collapse-1c5d02ea">        <div class="fold-content">          <ul><li>位学鑫是德克萨斯大学奥斯汀分校神经科学系助理教授。2005年至2009年，位学鑫就读于北京大学数学科学学院，获得学士学位。之后，他于宾夕法尼亚大学获得心理学博士学位，之后在哥伦比亚大学理论神经科学中心和统计系从事博士后研究。他聚焦于计算神经科学、感知与认知机制、脑科学与AI双向启发等，曾获LouisB. Flexner神经科学优秀论文奖，在《NatureNeuroscience》《PNAS》《NeurIPS》等顶刊或会议发表论文20余篇。2025年，位学鑫获得斯隆研究奖。</li><li>感想：位学鑫的研究展示了计算神经科学在理解人类感知和认知机制方面的重要性。他的工作不仅推动了神经科学与人工智能的交叉研究，也为理解复杂的脑功能提供了新的视角和方法。他的成就激励着更多年轻科学家在跨学科研究中探索新的可能性。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-0db5b446" role="button" aria-expanded="false" aria-controls="collapse-0db5b446">        <div class="fold-arrow">▶</div>卢卡・帕乔利      </div>      <div class="fold-collapse collapse" id="collapse-0db5b446">        <div class="fold-content">          <ul><li>16世纪意大利数学家，被誉为“现代会计之父”，在数学、会计学、文艺复兴时期的科学传播等领域均有深远影响。并非原创性数学家，但擅长整合与传播当时的数学知识，尤其注重将理论与实际应用结合。他强调数学的实用性，其著作不仅面向学者，也为商人、工匠、建筑师等提供了计算工具，推动了数学从象牙塔走向社会实践。他在多个大学（如帕多瓦大学）讲授数学，培养了一批学生，进一步传播了他的学术思想。</li><li>早年曾在威尼斯担任富商家庭的家庭教师，后进入 Franciscan修道院，系统学习神学与科学，一生游走于意大利各城邦（如米兰、佛罗伦萨、罗马等），与达・芬奇等文艺复兴巨匠有密切交往。</li><li>1500年左右，帕乔利在米兰与达・芬奇合作，达・芬奇为帕乔利的另一著作《神圣比例》（DeDivina Proportione，1509 年）绘制插图。该书研究了 “黄金比例”（ DivineProportion）在几何、艺术与建筑中的应用，达・芬奇的插画（如正多面体的立体图）精准展现了数学与艺术的融合，成为文艺复兴时期跨学科研究的典范。</li><li>著有《算术、几何、比及比例概要》，其中第三部分“计算与记录要论”（Particularis de Computis etScripturis）系统阐述了复式记账法（double-entrybookkeeping）的原理与方法，包括会计科目设置、日记账与总账的登记规则、试算平衡等核心概念。该书首次将意大利商人实践中形成的记账方法上升为理论体系，被视为现代会计学的奠基之作，极大推动了商业财务管理的规范化，为资本主义经济的发展提供了关键工具。</li><li>感想：卢卡・帕乔利的研究成果在数学和会计学领域产生了深远的影响。他的工作不仅推动了数学与实际应用的结合，也为现代会计学的发展奠定了基础。他的成就激励着更多学者在跨学科研究中探索新的可能性。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-1008dbb9" role="button" aria-expanded="false" aria-controls="collapse-1008dbb9">        <div class="fold-arrow">▶</div>亚马逊研究奖      </div>      <div class="fold-collapse collapse" id="collapse-1008dbb9">        <div class="fold-content">          <ul><li>亚马逊研究奖（Amazon ResearchAwards，ARA）是亚马逊于2015年设立的奖项，涉及应用机器学习、自动推理、计算机视觉、人工智能公平性、机器学习算法与理论、自然语言处理、机器人、安全、可持续发展等多个与亚马逊业务相关的领域，旨在为多个学科研究主题的学术研究人员提供支持，促进相关领域的研究发展。奖项以一次性无限制赠款的形式提供给首席研究员所在的学术机构或组织，包括现金和AWS促销积分。现金资助金额平均可达10万美元，AWS促销积分在5万至25万美元之间。获奖者可以公开访问300多个亚马逊公共数据集，并使用亚马逊的AI/ML服务和工具。此外，获奖者还将与亚马逊专家建立联系，获得咨询和建议，并可参加亚马逊举办的活动、培训课程等。</li><li>2025年，共有70位学者获奖，来自10个国家的44所大学，其中有不少华人的身影。</li><li>感想：亚马逊研究奖的设立，体现了科技公司对学术研究的重视和支持。通过资助学术界的研究人员，亚马逊不仅推动了相关领域的技术进步，也促进了学术界与工业界的合作。这种合作模式有助于将前沿研究成果转化为实际应用，为社会带来更多创新和便利。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6a5733a9" role="button" aria-expanded="false" aria-controls="collapse-6a5733a9">        <div class="fold-arrow">▶</div>西蒙斯 及 西蒙斯学者奖      </div>      <div class="fold-collapse collapse" id="collapse-6a5733a9">        <div class="fold-content">          <ul><li>西蒙斯是美国著名的数学家、投资家和慈善家，被誉为“量化之王”，2024年逝世。他1958年毕业于麻省理工学院数学系，1961年获得加州大学伯克利分校数学博士学位，同年被聘为哈佛大学数学系教授。1974年，他与华裔数学家陈省身联合发表了论文《典型群和几何不变式》，创立了陈-西蒙斯定理，该定理对理论物理学具有重要意义，被广泛应用到从超引力到黑洞的各大领域。他还帮助杨振宁建立了杨-米尔斯理论。1976年，西蒙斯赢得了美国数学协会的奥斯瓦尔德·维布伦几何学奖，以表彰他在多元平面面积最小化研究的突破性成果。</li><li>1978年，西蒙斯开设私人投资基金Limroy。1982年，他创立了文艺复兴科技公司，并于1988年3月带领该公司推出了大奖章基金，开始从主观交易转型到量化交易。西蒙斯开创了使用数学模型和算法来做出投资决策的先河，从1988年到2019年，大奖章基金年化收益率为39%，打败了巴菲特和索罗斯。2008年度，西蒙斯排名《阿尔法》杂志“第八届全球对冲基金经理收入年度排行榜”的第一名。</li><li>1994年，西蒙斯夫妇成立了西蒙斯基金会，专门援助教育及医疗方面的科学研究计划。2003年，西蒙斯基金会旗下创办了西蒙斯自闭症研究中心。2004年，西蒙斯投入2500万美元创办了“为了美国数学”项目，两年后又增资至5000万美元。西蒙斯夫妇向数百个慈善事业捐赠了数十亿美元，2022年1月，西蒙斯入选《福布斯》公布的美国25位最慷慨的捐赠者名单。</li><li>西蒙斯学者奖是由西蒙斯基金会设立的奖项。西蒙斯基金会由西蒙斯及其妻子玛里琳于1994年成立，专门为教育、卫生、自然科学研究领域提供资助。该奖项旨在奖励数学、物理、天体物理和计算机科学领域的杰出研究者。基金会每年从美国、加拿大、英国和爱尔兰的科研机构所提名的候选人中评选出西蒙斯学者。每位西蒙斯学者可获得为期5年、总额50万美元的研究资金，并依据获奖者的研究影响力，可续延5年。获奖者可自由支配资金以进行长期的原创性工作和解决相关领域的根本性问题。在2019-2023年间，在数学领域，共有5位华（国）人学者获得过西蒙斯学者奖，其中除了本科毕业于中国科技大学的陈秀雄教授外，另外4位本科均毕业于北大数院。</li><li>感想：西蒙斯学者奖的设立，体现了对数学和相关领域研究的重视和支持。通过资助杰出研究者，西蒙斯基金会不仅推动了科学研究的发展，也激励了更多年轻学者在数学、物理和计算机科学等领域不断探索和创新。西蒙斯本人作为一位成功的投资家和慈善家，他的成就和贡献为学术界树立了榜样。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-33de3d83" role="button" aria-expanded="false" aria-controls="collapse-33de3d83">        <div class="fold-arrow">▶</div>阿瑟·凯莱（英国）      </div>      <div class="fold-collapse collapse" id="collapse-33de3d83">        <div class="fold-content">          <ul><li>阿瑟·凯莱是19世纪英国最具影响力的数学家之一，在代数、几何、矩阵理论等领域有开创性贡献，被誉为“19世纪最全面的数学家”之一。</li><li>他自幼展现出数学天赋，14岁进入伦敦国王学院学习，后进入剑桥大学三一学院，1842年以优异成绩毕业并留校任教。因剑桥大学当时的教职规定（需担任圣职），凯莱于1846年转行成为律师，在伦敦从事法律工作长达14年。但在此期间，他从未中断数学研究，与另一位数学家詹姆斯·约瑟夫·西尔维斯特合作频繁，两人共同推动了19世纪英国代数学的复兴。</li><li>凯莱是矩阵理论的主要创始人之一。1858年，他发表论文《矩阵论的研究报告》，首次系统定义了矩阵的运算规则（如加法、乘法、逆矩阵等），并证明了矩阵的基本性质。他提出了凯莱-哈密顿定理，即“每个方阵都满足其自身的特征方程”，这一定理成为线性代数的核心定理之一，对后续量子力学、工程学等领域的发展有深远影响。凯莱规范了许多数学符号的使用，例如矩阵的表示方法（用大写字母表示矩阵）沿用至今。</li><li>他与西尔维斯特共同创立了代数不变量理论，研究代数表达式在变量变换下保持不变的性质，使该领域从零散研究上升为系统理论。这一理论不仅推动了抽象代数的发展，还为相对论中的张量分析提供了早期数学基础。</li><li>在几何学方面，凯莱将代数方法引入几何研究，提出“射影几何是所有几何的基础”的观点，认为欧氏几何、非欧几何等都可视为射影几何的特例。这一思想统一了19世纪的几何学研究，影响了希尔伯特等后续数学家。他还研究了高维空间几何、曲线与曲面理论，为微分几何的发展提供了代数工具。</li><li>在群论领域，凯莱最早给出了有限群的抽象定义，并证明了“凯莱定理”（每个有限群都同构于某个置换群的子群），为群论的公理化奠定了基础。</li><li>凯莱一生发表了超过900篇论文，涵盖数学的几乎所有分支，是历史上论文数量最多的数学家之一（仅次于欧拉）。</li><li>感想：阿瑟·凯莱的研究成果在数学史上具有重要地位，他的工作不仅推动了代数、几何和矩阵理论的发展，也为后续数学家的研究提供了坚实基础。他的成就激励着更多数学家在抽象代数和几何学等领域不断探索和创新。凯莱的跨学科研究方法和对数学符号的规范化使用，为现代数学的发展奠定了重要基础。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-be1c3261" role="button" aria-expanded="false" aria-controls="collapse-be1c3261">        <div class="fold-arrow">▶</div>Dirichlet      </div>      <div class="fold-collapse collapse" id="collapse-be1c3261">        <div class="fold-content">          <ul><li>狄利克雷是19世纪德国杰出的数学家，在数论、分析学、数学物理等领域有开创性贡献，被誉为“现代数论的创始人之一”。</li><li>狄利克雷出生于德国迪伦，父亲是邮政局长。他自幼对数学展现出浓厚兴趣，16岁时前往巴黎求学，师从法国数学家约瑟夫·拉格朗日、皮埃尔-西蒙·拉普拉斯等大师，接触到当时欧洲最前沿的数学研究。1855年高斯去世后，他接替高斯担任哥廷根大学数学教授，直至去世。他与德国数学界联系紧密，是“柏林学派”的核心成员之一，与雅可比、黎曼等数学家交往密切，对19世纪德国数学的崛起起到重要推动作用。</li><li>1837年，他证明了“狄利克雷定理”——对于任意两个互质的正整数<span class="math inline"><em>a</em></span>和<span class="math inline"><em>d</em></span>，算术级数<span class="math inline"><em>a</em>, <em>a</em> + <em>d</em>, <em>a</em> + 2<em>d</em>, …</span>中包含无穷多个质数。这是数论史上的里程碑，首次将分析学工具（如L函数）引入数论，开创了“解析数论”这一重要分支。他深入研究了高斯的《算术研究》，并为其撰写了清晰的注释，推动了高斯数论思想的传播；提出了“狄利克雷特征”（一种用于简化数论问题的函数），成为解析数论的核心工具；还在二次型理论、丢番图方程等领域有重要成果。</li><li>狄利克雷是最早给出“函数”严格定义的数学家之一。1837年，他提出：“如果对于给定区间内的每一个<span class="math inline"><em>x</em></span>值，都有一个唯一的<span class="math inline"><em>y</em></span>值与之对应，那么<span class="math inline"><em>y</em></span>就是<span class="math inline"><em>x</em></span>的函数，无论这种对应关系是通过公式、图像还是表格定义的。”这一定义摆脱了对“表达式”的依赖，为现代函数概念奠定了基础。</li><li>他研究了傅里叶级数的收敛条件，给出了首个严格的收敛判别准则（狄利克雷判别法），证明了具有有限个极值点和跳跃点的函数的傅里叶级数收敛于该函数本身，推动了傅里叶分析的严谨化。</li><li>他构造了著名的“狄利克雷函数”——<span class="math inline"><em>D</em>(<em>x</em>) = 1</span>（若<span class="math inline"><em>x</em></span>是有理数），<span class="math inline"><em>D</em>(<em>x</em>) = 0</span>（若<span class="math inline"><em>x</em></span>是无理数）。这个函数处处不连续、不可导，却能清晰地说明“函数不必有解析表达式”，挑战了当时对函数的直观理解，促进了实变函数论的发展。</li><li>狄利克雷在数学物理领域也有重要贡献，尤其在热传导理论中提出了“狄利克雷边界条件”——即给定物理系统边界上的函数值（如温度），这是偏微分方程研究中最基本的边界条件之一，至今仍被广泛应用于物理学和工程学。</li><li>感想：狄利克雷以严谨的逻辑和开创性的方法著称，他的研究不仅解决了当时的诸多难题，更重塑了数学的研究范式，是19世纪数学史上不可或缺的关键人物。狄利克雷的工作连接了数论与分析学，为现代数学的多个分支奠定了基础。他的学生包括黎曼等著名数学家，其思想直接影响了19世纪后期的数学发展。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-25dd47d1" role="button" aria-expanded="false" aria-controls="collapse-25dd47d1">        <div class="fold-arrow">▶</div>肖梁（北大）      </div>      <div class="fold-collapse collapse" id="collapse-25dd47d1">        <div class="fold-content">          <ul><li>肖梁是北京大学数学科学学院及北京国际数学研究中心教授、博士生导师、代数与数论教研室主任，也是数学奥林匹克国家队领队和教练。肖梁是北京人，小学四年级进入人大附中华罗庚学校。2001年，高三的他以满分成绩获得第42届国际数学奥林匹克竞赛金牌，随后被保送至北京大学，2019年起在北京大学任教。</li><li>他的主要研究领域是数论和算术代数几何，在朗兰兹纲领的几何以及p进方面的若干问题中取得研究进展。他在《美国数学会杂志》（Journalof American Mathematical Society）、《数学发明》（InventionesMathematicae）、《杜克数学杂志》（Duke MathematicalJournal）等国际顶尖或一流数学期刊发表多篇研究论文，曾获美国自然科学基金会CAREER奖，还入选了多个重要的国家级人才项目。他积极参与学术交流活动，与田一超、DavidHelm、朱歆文等学者合作，共同在志村簇的几何、Tate猜想等方面开展研究，并取得了重要成果，如构造了不同志村簇的特殊纤维之间的上同调式对应等。</li><li>感想：肖梁的成就不仅体现在他的研究成果上，还在于他对学生的培养和对数学教育的贡献。他的经历激励着更多年轻学者追求卓越，探索数学的奥秘。</li></ul>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-75547b37" role="button" aria-expanded="false" aria-controls="collapse-75547b37">        <div class="fold-arrow">▶</div>保罗·潘勒韦（法国）      </div>      <div class="fold-collapse collapse" id="collapse-75547b37">        <div class="fold-content">          <ul><li>保罗·潘勒韦是19世纪末至20世纪初法国著名的数学家、政治家，在数学领域尤其是微分方程研究中成就卓著，同时在政界也担任过重要职务。</li><li>潘勒韦出生于法国巴黎一个普通家庭，父亲是铁匠。他自幼展现出卓越的数学天赋，先后就读于巴黎高等师范学院和巴黎综合理工学院，师从法国数学家夏尔·埃尔米特（CharlesHermite）等名师，25岁时便获得巴黎大学博士学位。</li><li>潘勒韦的数学研究主要集中在微分方程和分析学领域，尤其以对“无movable奇点的微分方程”的系统研究闻名，被誉为“微分方程定性理论的先驱之一”。通过系统分类，潘勒韦发现了6类具有重要意义的二阶非线性微分方程，它们的解无法用初等函数（如指数函数、三角函数）或椭圆函数表示，而是一类新的“超越函数”，被称为“潘勒韦超越函数”。这6类方程后来被命名为潘勒韦方程，成为微分方程理论中的核心研究对象，至今仍在数学物理、量子力学等领域有广泛应用。</li><li>在复分析领域，他研究了解析函数的奇点分布和延拓问题，与同事埃米尔·皮卡合作，深化了对复平面上函数行为的理解。</li><li>他还涉足数学物理领域，研究过弹性力学、流体力学中的微分方程问题，试图用数学工具解决实际物理现象。</li><li>潘勒韦在学术生涯之外，积极投身法国政治，尤其在第一次世界大战前后扮演了重要角色：以激进社会党成员身份当选法国国民议会议员，关注教育、劳工等社会问题，推动了多项教育改革法案，主张普及科学教育。第一次世界大战期间，他两度出任法国总理，同时兼任陆军部长，致力于协调战时军事资源，推动对德作战的战略调整。尽管任期短暂，但他在战时危机中展现了务实的领导能力。此外，他还担任过法国教育部长、财政部长等职，始终强调科学与工业的结合，推动法国在数学、工程等领域的发展。</li><li>感想：潘勒韦的研究成果在微分方程和复分析领域具有重要地位，他的工作不仅推动了数学理论的发展，也为实际应用提供了新的工具。他在政界的经历则体现了学者参与公共事务的责任感，展现了“文理兼通”的典范。潘勒韦的成就激励着更多数学家在理论与实践之间架起桥梁，为社会进步贡献智慧。</li></ul>        </div>      </div>    </div>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 数学史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git对文件名大小写不敏感的解决方法</title>
      <link href="/_posts/Git%E5%AF%B9%E6%96%87%E4%BB%B6%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/_posts/Git%E5%AF%B9%E6%96%87%E4%BB%B6%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="问题的发现">问题的发现</h1><p>半小时前，我修改完博客上的《Fluid主题美化》的文章，熟练地执行了Hexo三连后，期待满满地打开浏览器准备查看效果，结果却发现页面的某些组件没有正确显示，然而执行<code>Hexo s</code>命令打开的本地预览页面却一切正常。这是怎么一回事？</p><p><a href="/_posts/Fluid主题美化1-0/" name="/img/avatar/avatar.webp" class="LinkCard">Fluid主题美化1.0</a></p><h1 id="问题的排查">问题的排查</h1><p>我首先注意到的是文章中的链接卡片没有被正常渲染，于是首先使用浏览器的开发者工具检查了页面，发现链接卡片成功读取了css样式，但却没有加载js脚本，于是我怀疑是我在修改上一篇文章时，由于调整了<code>linkcard.js</code> ，将其拆分为 <code>LinkCard.js</code> 和<code>LinkCard.css</code>两个文件，同时为了规范化文件名，调整了大小写的格式，这才导致了问题。</p><p>接着我检查本地执行 <code>Hexo cl &amp;&amp; Hexo g</code> 后生成的<code>public/js</code> 目录，发现确实存在 <code>LinkCard.js</code>文件，这也同样印证了此前在本地预览页面时一切正常的结论</p><p>于是我打开博客的Github仓库，却惊讶地发现 <code>js</code>目录下的文件名仍然是 <code>linkcard.js</code>，这就解释了为什么在GithubPages上预览时无法加载js脚本。</p><p>再看看其他被我修改过文件名的文件，无一例外，Github仓库上的文件名都没有被正确更新！原来这就是造成这一切的罪魁祸首！经过搜索，我确定了问题的根源：Git对文件名的大小写变更不敏感，在只修改文件名大小写时，Git不会将其视为一次变更，因此不会提交到仓库中。</p><h1 id="解决方法">解决方法</h1><p>为了解决这个问题，我需要强制Git识别文件名的大小写变更。笨办法是将出现问题的文件修改为其他名称，添加一次后再修改回原来的名称，并再次添加到暂存区，但这样的方法还是太不优雅了，也无法保证下次不会再遇到这个问题。</p><p>因此我们可以设置Git的配置选项来强制它对文件名的大小写变更敏感。具体步骤如下：</p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">config</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--global</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">core.ignorecase</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span></span></code></pre></div></div></figure><p>接着还需要将暂存区中原本的文件移除，然后再重新添加以及提交修改：</p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">rm</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--cached</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-r</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.</span></span></code></pre></div></div></figure><p></p><p>如果不这样做，你就会发现远程仓库将会同时出现大小写不同的两个甚至多个文件，进一步造成混乱。</p><p>至此，问题就解决了！现在你可以放心地修改文件名的大小写，而不必担心Git会忽略这些变更。</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fluid主题美化</title>
      <link href="/_posts/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
      <url>/_posts/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[# 前言上一篇博客提到过，我在Fluid、Solitude、Matery、ShokaX等一众主题中选择了Fluid主题，但对于其他主体内置的一些功能，我还是十分眼馋的。那怎么办呢，当然是自己进行美化了。当然，作为一个新手，大部分美化都是参考其他博客的经验进行的，部分自己摸索的美化方式也比较粗糙，不够优雅，参考需谨慎。在开始配置主题以及美化前，建议将 `themes/fluid/_config.yml` 文件复制到根目录下，并改名为 `_config.fluid.yml`，后续修改均在 `_config.fluid.yml` 文件中进行，此处的配置会覆盖主题内置的 `_config.yml` 文件中的配置，这样可以避免在主题更新时丢失配置。# 黑暗模式下修改加粗字体和斜体样式由于个人习惯在黑暗模式下阅读，且发现Fluid主题在黑暗模式下加粗字体和并不明显，相比之下Matery主题修改了加粗字体的颜色，深得我心，于是决定对Fluid主题进行类似的修改。{% fold info @此方式已被弃用，改用无侵入的方法实现 %}首先在博客根目录下的 `_config.fluid.yml` 文件对 `color` 进行修改，增加以下内容```yamlcolor：  # 原有内容，下面是新加的  # 文章正文加粗/斜体字体色  # Color of post text  my-post_text_color: "#2c3e50"  my-post_text_color_dark: "#feeed6"```接着需要修改 `themes/fluid/source/css/_pages/_base/base.styl` 文件，在 `body` 选择器下添加以下内容```stylusbody  // 原有内容，下面是新加的  strong    color var(--my-post-text-color)  em    color var(--my-post-text-color)```修改 `themes/fluid/source/css/_pages/_base/color-schema.styl` 文件，分别在 `:root` 和 `dark-colors` 下增加以下内容```stylus:root  --my-post-text-color $my-post-text-colordark-colors()  --my-post-text-color $my-post-text-color-dark```然后修改 `themes/fluid/source/css/_variables/base.styl` 文件，在 `post` 注释处增加以下内容```stylus// post$my-post-text-color = theme-config("color.my_post_text_color", "#2c3a46")$my-post-text-color-dark = theme-config("color.my_post_text_color_dark", "#feeed6")```{% endfold %}首先在 `source/css/` 目录下新建一个 `StrongInDark.css` 文件（如果不存在该目录则需要先创建），代码如下：```css:root {  --my-post-text-color: #2c3e50;}[data-user-color-scheme="dark"] {  --my-post-text-color: #feeed6;}.page-content strong, .post-content strong {    color: var(--my-post-text-color);}.page-content em, .post-content em {    color: var(--my-post-text-color);}```并在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/StrongInDark.css```至此，黑暗模式下加粗字体和斜体样式的修改就完成了。# 博客标题霓虹灯效样式{% fold info @此方式已被弃用，改用无侵入的方法实现 %}由于我对Fluid的各种设置不太了解，导致我在上一步修改加粗字体和斜体样式后，博客的标题也被修改了颜色，因此我又单独调整了博客标题的颜色。首先在 `themes/fluid/source/css/_pages/_base/_widget/header.styl` 文件中进行修改，追加以下内容```stylus.navbar-title  outline none  --c lightseagreen  text-shadow 0 0 10px var(--c),0 0 20px var(--c),0 0 40px var(--c),0 0 80px var(--c),0 0 160px var(--c)  animation animate 5s linear infinite  color var(--navbar_text_color)@keyframes animate{  to{      filter: hue-rotate(360deg)  }}```其中 `color var(--navbar_text_color)` 是为了将博客标题的颜色恢复为我们在 `_config.fluid.yml` 文件中设置的颜色。{% endfold %}标题的霓虹灯效果是参考KEVIN'S BLOG的实现并进行修改。<a href="https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/" name="https://static.kevinchu.top/blog/assets/img/avatar_03.jpg" class="LinkCard">Hexo博客Fluid主题魔改记录</a>首先在 `source/css/` 目录下新建一个 `TitleNeon.css` 文件（如果不存在该目录则需要先创建），代码如下：```css.navbar-title {  outline: none;  --c: lightseagreen;  text-shadow: 0 0 10px var(--c), 0 0 20px var(--c), 0 0 40px var(--c), 0 0 80px var(--c), 0 0 160px var(--c);  animation: animate 5s linear infinite;}@keyframes animate{  to{      filter: hue-rotate(360deg);  }}```然后在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/TitleNeon.css```当然，为了使博客标题的霓虹灯效果生效，还是不可避免的需要对主题文件进行修改。需要修改的是 `themes/fluid/layout/_partials/header/navigation.ejs` 文件，在最前面几行找到对应导航栏标题的标签内容进行修改即可：```diff-<strong><%= theme.navbar.blog_title || config.title %></strong>+<strong class="navbar-title"><%= theme.navbar.blog_title || config.title %></strong>```至此，博客标题的霓虹灯效果就完成了。# 标题颜色渐变样式实现标题颜色渐变效果的代码同样参考了的是EmoryHuang's Blog的实现并进行修改。<a href="https://emoryhuang.cn/blog/1729600336.html" name="https://emoryhuang.cn/img/friend_404.gif" class="LinkCard">EmoryHuang's Blog</a>在 `source/css/` 目录下新建一个 `TitleGradient.css` 文件（如果不存在该目录则需要先创建），代码如下：```css#subtitle {    background: linear-gradient(-45deg, #0f76c1, #3a8dc0, #80d2ef, #ffffff);    -webkit-background-clip: text;    background-clip: text;    -webkit-text-fill-color: transparent;}```并在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/TitleGradient.css```# 修改滚动条样式原本页面右侧的滚动条和默认代码块、行间公式的滚动条样式都比较朴素，因此我参考了EmoryHuang's Blog的代码并进行了一些修改，为滚动条添加了样式。在 `source/css/` 目录下新建一个 `ScrollBar.css` 文件（如果不存在该目录则需要先创建），代码如下：```css::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #679ed9;    background-image: -webkit-linear-gradient( 45deg, rgba(255, 255, 255, 0.4) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.4) 50%, rgba(255, 255, 255, 0.4) 75%, transparent 75%, transparent);    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #7095da;}```并在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/ScrollBar.css```# 使用 Mac 风格代码块样式{% fold info @此方式已被弃用，博主采用另一种方式实现 %}原本的代码块风格比较朴素，因此我参考KEVIN'S BLOG的代码块样式，修改为MAC风格。<a href="https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/" name="https://static.kevinchu.top/blog/assets/img/avatar_03.jpg" class="LinkCard">Hexo博客Fluid主题魔改记录</a>在 `source/css/` 目录下新建一个 `MacPanel.styl` 文件，内容如下：```stylus.highlight    background: #21252b    border-radius: 5px    box-shadow: 0 10px 30px 0 rgba(0, 0, 0, .4)    padding-top: 30px    &::before      background: #fc625d      border-radius: 50%      box-shadow: 20px 0 #fdbc40, 40px 0 #35cd4b      content: ' '      height: 12px      left: 12px      margin-top: -20px      position: absolute      width: 12px```并在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/MacPanel```{% endfold %}起初我使用的是上面被折叠的方式，但是在写这篇文章时发现存在一个问题：代码块不具备折叠功能！这导致了一旦插入长代码，就会占用大量页面空间，既不美观也不方便阅读。因此，我参考了4rozeN的实现方法，将渲染器更换为 Hexo Shiki Plugin。此处感谢4rozeN的答疑解惑。<a href="https://4rozen.github.io/archives/Hexo/41513.html" name="https://4rozen.github.io/img/avatar/avatar.jpg" class="LinkCard">Hexo 博客 Fluid 主题实现代码折叠和文字遮盖效果</a>Hexo Shiki Plugin是一个Hexo插件，仓库地址见下方。<a href="https://github.com/nova1751/hexo-shiki-plugin/" name="https://avatars.githubusercontent.com/u/97817985?v=4" class="LinkCard">Hexo Shiki Plugin</a>具体安装额和使用方法如下：1. 在博客根目录下执行以下命令安装插件：    ```bash    npm install hexo-shiki-plugin --save    ```2. 修改博客根目录下的 `_config.yml` 文件：    ```yaml    syntax_highlighter: # 留空    highlight:      enable: false    prismjs:      enable: false    shiki:      theme: one-dark-pro # highlight-theme：one-dark-pro / github-light / github-dark / material-theme-palenight      line_number: true # whether to show the line_number      beautify: true # whether to add highlight tool true or false      highlight_copy: true # copy button      highlight_lang: true # show the code language      highlight_height_limit: 360 # code-block max height,unit: px      is_highlight_shrink: false # true: shrink the code blocks / false: expand the code blocks | none: expand code blocks and hide the button      copy: # copy message        success: 'Copy Success'        error: 'Copy Error'        no_support: 'Browser Not Support'```3. 修改 `_config.fluid.yml` 文件，修改 `code` 中的 `highlight` 部分：```yamlcode:  copy_btn: false  language:enable: false  highlight:enable: false```4. 在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容以引入font-awesome图标库：```yamlcustom_css:  - https://lib.baomitu.com/font-awesome/6.1.2/css/all.min.css```5. 此时我发现折叠代码下方的折叠按钮很不明显，因此在 `source/css/` 目录下新建一个 `CodeBlock.css` 文件（如果不存在该目录则需要先创建），代码如下：```css.markdown-body code,.markdown-body pre {  font-family: "JetBrains Mono", "Fira Code", "Noto Sans SC", "Source Code Pro", monospace !important;  line-height: 1 !important;}/* 以下样式给 shiki 代码块使用 */.code-expand-btn i {  color: #ffffff !important; /* 展开或隐藏代码块的按钮颜色 */}:root {  --hlnumber-color: #a5a5a5 !important; /* 行号颜色 */  --hl-bg: #1f1f1f !important; /* 代码块背景颜色 */  --hlnumber-bg: #1f1f1f !important; /* 行号背景颜色 */  --hlexpand-bg: linear-gradient(180deg, rgba(255, 255, 255, 0.1), rgba(40, 44, 52, 0.9));}pre code {  color: #b9b9b9; /* 没有颜色方案的代码语言的表现色 */}```并在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/CodeBlock.css```# 修改行内代码样式这个功能实现起来非常简单，只需要在 `source/css/` 目录下新建一个 `CodeInLine.css` 文件（如果不存在该目录则需要先创建），代码如下：```css.markdown-body code, .markdown-body pre {  font-family: "JetBrains Mono", "Fira Code", "Noto Sans SC", "Source Code Pro", monospace !important;  line-height: 1 !important;  color: #E05B35;}```并在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/CodeInLine.css```# 文章界面背景毛玻璃样式谁知道我到底有多喜欢毛玻璃！因此我又为文章界面添加了毛玻璃样式，这部分参考的是4rozeN的博客，并进行了部分修改。<a href="https://4rozen.github.io/archives/Hexo/60191.html" name="https://4rozen.github.io/img/avatar/avatar.jpg" class="LinkCard">Hexo fluid 全屏背景图随日夜模式切换以及正文底页毛玻璃效果</a>首先在 `source/css/` 目录下新建一个 `FrostedGlassBg.css` 文件（如果不存在该目录则需要先创建），代码如下：```css#board {  -webkit-backdrop-filter: blur(15px);  backdrop-filter: blur(15px);}```然后修改 `_config.fluid.yml` 文件的中的主面板背景色```diff-board_color: "#ffffff"-board_color_dark: "#151722"+board_color:  "#ffffff80"+board_color_dark: "#15172280"```当然，也需要在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/FrostedGlassBg.css```这样我们就实现了文章界面的毛玻璃样式。4rozeN在博客中还实现了背景图全屏显示以及随日夜模式切换的效果，但由于我个人认为这样或许会使得显示比较杂乱，因此暂时未加入此功能。# 链接卡片样式在Fluid主题中，没有内置的链接卡片样式，因此参照丁丁の店的处理方式，并进行了一些修改和优化，为链接添加了卡片样式，使其背景颜色能跟随主题的日夜模式切换，且鼠标悬停时有放大效果。<a href="https://blog.butanediol.me/2020/06/03/Hexo%20改良版知乎外链卡片/" name="https://blog.butanediol.me/media/avatar.png" class="LinkCard">Hexo 改良版知乎“外链卡片”</a>{% fold info @此方式已被弃用，改用样式与功能分离的方法实现 %}在 `source/js/` 目录下新建一个 `LinkCard.js` 文件（如果不存在该目录则需要先创建），代码如下：```javascriptwindow.onload = function () {    function isDarkMode() {        const htmlElement = document.documentElement;        const userScheme = htmlElement.getAttribute('data-user-color-scheme');        const defaultScheme = htmlElement.getAttribute('data-default-color-scheme');                // 如果用户手动设置了主题，优先使用用户设置        if (userScheme) {            return userScheme === 'dark';        }                // 否则使用默认主题设置        if (defaultScheme) {            return defaultScheme === 'dark';        }                // 如果都没有设置，检查系统偏好        return window.matchMedia('(prefers-color-scheme: dark)').matches;    }        // 监听主题切换，动态更新卡片背景色    function updateLinkCardStyle() {        setTimeout(() => {            const style = document.getElementById('LinkCardStyle');            if (style) {                const color = isDarkMode() ? '#242a38' : '#eeefef';                style.innerHTML = style.innerHTML.replace(                    /(\.LinkCard-content\s*\{[^}]*background-color:\s*)(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}|rgba?\([^)]+\));/,                    `$1${color};`                );            }        }, 60);    }    // 监听自定义事件和系统主题变化    const observer = new MutationObserver(updateLinkCardStyle);    observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-user-color-scheme', 'data-default-color-scheme'] });    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateLinkCardStyle);    var LinkCards = document.getElementsByClassName('LinkCard');    for (var i = 0; i < LinkCards.length; i++) {        if (!document.getElementById('LinkCardStyle')) {            var style = document.createElement('style');            style.id = 'LinkCardStyle';            const color = isDarkMode() ? '#242a38' : '#eeefef';            style.innerHTML = `            .LinkCard, .LinkCard:hover {                text-decoration: none;                border: none !important;                color: inherit !important;            }            .LinkCard {                position: relative;                display: block;                margin: 1em auto;                width: 60%;                box-sizing: border-box;                border-radius: 12px;                max-width: 100%;                overflow: hidden;                color: inherit;                text-decoration: none;            }            .ztext { word-break: break-word; line-height: 1.6; }            .LinkCard-content {                position: relative;                display: flex;                align-items: center;                justify-content: space-between;                padding: 12px;                border-radius: inherit;                background-color: ${color};            }            .LinkCard-text { overflow: hidden; }            .LinkCard-title {                display: -webkit-box;                -webkit-line-clamp: 2;                overflow: hidden;                text-overflow: ellipsis;                max-height: calc(16px * 1.25 * 2);                font-size: 16px;                font-weight: 500;                line-height: 1.25;                color: inherit;            }            .LinkCard-meta {                display: flex;                margin-top: 4px;                font-size: 14px;                line-height: 20px;                color: #999;                white-space: nowrap;            }            .LinkCard-imageCell {                margin-left: 8px;                border-radius: 6px;            }            .LinkCard-image {                display: block;                width: 60px;                height: auto;                border-radius: inherit;                margin-bottom: 0 !important;            }            `;            document.head.appendChild(style);        }        // 截断链接        var truncateLink = function(url, maxLength) {            if (url.length <= maxLength) return url;            return url.slice(0, maxLength) + '...';        };        var LinkCard = LinkCards[i];        var link = LinkCard.href;        var title = LinkCard.innerText;        var logourl = LinkCard.name;        var displayLink = truncateLink(link, 32);        LinkCard.innerHTML =            `<span class="LinkCard-content">                <span class="LinkCard-text">                    <span class="LinkCard-title">${title}</span>                    <span class="LinkCard-meta">                        <span style="display:inline-flex;align-items:center">                            <svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17">                                <path d="M6.77 17.23c-.905-.904-.94-2.333-.08-3.193l3.059-3.06-1.192-1.19-3.059 3.058c-1.489 1.489-1.427 3.954.138 5.519s4.03 1.627 5.519.138l3.059-3.059-1.192-1.192-3.059 3.06c-.86.86-2.289.824-3.193-.08zm3.016-8.673l1.192 1.192 3.059-3.06c.86-.86 2.289-.824 3.193.08.905.905.94 2.334.08 3.194l-3.059 3.06 1.192 1.19 3.059-3.058c1.489-1.489 1.427-3.954-.138-5.519s-4.03-1.627-5.519-.138L9.786 8.557zm-1.023 6.68c.33.33.863.343 1.177.029l5.34-5.34c.314-.314.3-.846-.03-1.176-.33-.33-.862-.344-1.176-.03l-5.34 5.34c-.314.314-.3.846.03 1.177z" fill-rule="evenodd"></path>                            </svg>                        </span>                        <a href="${link}" title="${link}" style="color:inherit;text-decoration:none;">${displayLink}</a>                    </span>                </span>                <span class="LinkCard-imageCell">                    <img class="LinkCard-image" alt="logo" src="${logourl}">                </span>            </span>`;    }}```然后在 `_config.fluid.yml` 文件的 `custom_js` 部分添加以下内容：```yamlcustom_js:  - /js/LinkCard.js```{% endfold %}为了实现样式与功能分离，并为链接卡片添加鼠标悬浮时的效果，我将该博主的代码进行了修改：在 `source/css/` 目录下新建一个 `LinkCard.css` 文件（如果不存在该目录则需要先创建），代码如下：```css:root {  --linkcard-bg-color: #eeefef;}[data-user-color-scheme="dark"] {  --linkcard-bg-color: #242a38;}.LinkCard, .LinkCard:hover {    text-decoration: none;    border: none !important;    color: inherit !important;}.LinkCard {    position: relative;    display: block;    margin: 1em auto;    width: 60%;    box-sizing: border-box;    border-radius: 12px;    max-width: 100%;    overflow: hidden;    color: inherit;    text-decoration: none;    background: var(--linkcard-bg-color);    transition: transform 0.4s ease-in;}.ztext { word-break: break-word; line-height: 1.6; }.LinkCard-content {    position: relative;    display: flex;    align-items: center;    justify-content: space-between;    padding: 12px;    border-radius: inherit;    background-color: var(--linkcard-bg-color);}.LinkCard-text { overflow: hidden; }.LinkCard-title {    display: -webkit-box;    -webkit-line-clamp: 2;    line-clamp: 2;    overflow: hidden;    text-overflow: ellipsis;    max-height: calc(16px * 1.25 * 2);    font-size: 16px;    font-weight: 500;    line-height: 1.25;    color: inherit;}.LinkCard-meta {    display: flex;    margin-top: 4px;    font-size: 14px;    line-height: 20px;    color: #999;    white-space: nowrap;}.LinkCard-imageCell {    margin-left: 8px;    border-radius: 6px;}.LinkCard-image {    display: block;    width: 60px !important;    height: auto !important;    border-radius: inherit;    margin-bottom: 0 !important;}.LinkCard:hover {    transform: translate3d(0, -2px, 0);    box-shadow: 0 0 16px 0 rgba(34, 135, 250, 0.8);}```然后还需要在 `source/js/` 目录下新建一个 `LinkCard.js` 文件（如果不存在该目录则需要先创建），代码如下：```javascriptwindow.onload = function () {    var LinkCards = document.getElementsByClassName('LinkCard');    for (var i = 0; i < LinkCards.length; i++) {        // 截断链接        var truncateLink = function(url, maxLength) {            if (url.length <= maxLength) return url;            return url.slice(0, maxLength) + '...';        };        var LinkCard = LinkCards[i];        var link = LinkCard.href;        var title = LinkCard.innerText;        // 如果没有指定logo地址，则使用默认的loading图片        var logourl = LinkCard.name ? LinkCard.name : '/img/loading/loading1.gif';        var displayLink = truncateLink(link, 32);        LinkCard.innerHTML =            `<span class="LinkCard-content">                <span class="LinkCard-text">                    <span class="LinkCard-title">${title}</span>                    <span class="LinkCard-meta">                        <span style="display:inline-flex;align-items:center">                            <svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17">                                <path d="M6.77 17.23c-.905-.904-.94-2.333-.08-3.193l3.059-3.06-1.192-1.19-3.059 3.058c-1.489 1.489-1.427 3.954.138 5.519s4.03 1.627 5.519.138l3.059-3.059-1.192-1.192-3.059 3.06c-.86.86-2.289.824-3.193-.08zm3.016-8.673l1.192 1.192 3.059-3.06c.86-.86 2.289-.824 3.193.08.905.905.94 2.334.08 3.194l-3.059 3.06 1.192 1.19 3.059-3.058c1.489-1.489 1.427-3.954-.138-5.519s-4.03-1.627-5.519-.138L9.786 8.557zm-1.023 6.68c.33.33.863.343 1.177.029l5.34-5.34c.314-.314.3-.846-.03-1.176-.33-.33-.862-.344-1.176-.03l-5.34 5.34c-.314.314-.3.846.03 1.177z" fill-rule="evenodd"></path>                            </svg>                        </span>                        <a href="${link}" title="${link}" style="color:inherit;text-decoration:none;">${displayLink}</a>                    </span>                </span>                <span class="LinkCard-imageCell">                    <img class="LinkCard-image" alt="logo" src="${logourl}" onerror="this.src='/img/loading/loading1.gif'">                </span>            </span>`; // 如果获取指定logo地址失败，则使用默认的loading图片    }}```并在 `_config.fluid.yml` 文件的 `custom_css` 和 `custom_js` 部分添加以下内容：```yamlcustom_css:  - /css/LinkCard.csscustom_js:  - /js/LinkCard.js```使用时只需在文章中添加以下内容即可：```markdown<a href="" name="" class="LinkCard">标题</a>```其中:- `href` 是链接地址，不填就只会收获一张空卡片哦- `name` 是链接的logo地址，若不指定或留空，则使用脚本中指定的默认logo地址（记得手动调整哦）- `class` 处为链接卡片的样式类名，必须为 `LinkCard`，否则无法应用样式。- `标题` 处为连接卡片显示的标题。同时在使用中我还发现了一个“特性”：对于外部链接，点击链接卡片中的标题时，浏览器会在新的标签页中打开链接，而点击连接卡片中的链接地址时，则会在当前标签页中打开链接；而对于内部链接，则始终在当前标签页中打开链接。（奇怪的知识增加了.jpg）# 统一文章图片宽度在发了若干篇文章后，我发现由于我笔记中插入的图片分辨率不一致，导致在文章列表中呈现出来的图片宽度不统一，观感较差。为了解决这个问题，我在 `source/css/` 目录下新建一个 `UnifyImgWidth.css` 文件（如果不存在该目录则需要先创建），强制统一文章图片的宽度。```css.markdown-body p > img,.markdown-body p > a > img,.markdown-body figure > img,.markdown-body figure > a > img {  width: 70%; /* 强制宽度为页面的70% */  height: auto; /* 保持图片比例 */  display: block;   margin-left: auto;   margin-right: auto; /* 图片居中 */}.page-content img, .post-content img {  width: 70%; /* 强制宽度为页面的70% */  height: auto; /* 保持图片比例 */  display: block;   margin-left: auto;   margin-right: auto; /* 图片居中 */}```并在 `_config.fluid.yml` 文件的 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/UnifyImgWidth.css```# 首页文章滑入动效在Fluid主题中，首页文章列表的文章卡片是静态显示的，没有任何动效。为了让首页看起来更有活力，我参考QingShang的博客为文章卡片添加了滑入动效。<a href="https://qingshaner.com/Hexo%20fluid主题首页添加文章滑入动画/" name="https://qingshaner.oss-cn-hangzhou.aliyuncs.com/images/202205021359396.jpg" class="LinkCard">Hexo fluid主题首页添加文章滑入动画</a>在 `source/js/` 目录下新建一个 `ScrollAnimation.js` 文件（如果不存在该目录则需要先创建），代码如下：```javascriptconst cards = document.querySelectorAll('.index-card')if (cards.length) {    document.querySelector('.row').setAttribute('style', 'overflow: hidden;')    const coefficient = document.documentElement.clientWidth > 768 ? .5 : .3    const origin = document.documentElement.clientHeight - cards[0].getBoundingClientRect().height * coefficient    function throttle(fn, wait) {        let timer = null;        return function () {            const context = this;            const args = arguments;            if (!timer) {                timer = setTimeout(function () {                    fn.apply(context, args);                    timer = null;                }, wait)            }        }    }    function handle() {        cards.forEach(card => {            card.setAttribute('style', `--state: ${(card.getBoundingClientRect().top - origin) < 0 ? 1 : 0};`)        })    }    document.addEventListener("scroll", throttle(handle, 100));}```接着在 `source/css/`目录下新建一个 `ScrollAnimation.css` 文件（如果不存在该目录则需要先创建），代码如下：```css.index-card {  transition: all 0.5s;  transform: scale(calc(1.5 - 0.5 * var(--state)));  opacity: var(--state);  margin-bottom: 2rem;}.index-img img {  margin: 20px 0;}```并在 `_config.fluid.yml` 中载入，在 `custom_js` 和 `custom_css` 部分添加以下内容：```yamlcustom_js:  - /js/ScrollAnimation.jscustom_css:  - /css/ScrollAnimation.css```# 首页文章图片悬浮鼠标悬停动效在实现首页文章滑入动效后，我又参照Hugo@kkl's的博客为首页文章图片添加了鼠标悬停动效<a href="https://zhangkeliang0627.github.io/2024/07/31/关于Fluid主题拓展的N种配置/README/" name="https://hugokkl.oss-cn-shenzhen.aliyuncs.com/blog/sys/avatar.png" class="LinkCard">关于Fluid主题拓展的N种配置</a>在 `source/css/` 目录下新建一个 `IndexImgHover.css` 文件（如果不存在该目录则需要先创建），代码如下：```css.index-img {  /* 动画时间 */  transition: .4s;}.index-card:hover .index-img {  /* 放大倍数 */  transform: scale(1.05);}```并在 `_config.fluid.yml` 中载入，在 `custom_css` 部分添加以下内容：```yamlcustom_css:  - /css/IndexImgHover.css```至此，首页文章图片的动效就完成了。当然，你也可以借助浏览器开发者工具选取其他样式，并仿照这个方法进行修改。如修改“关于”页的头像与“标签页”的标签：```css.about-avatar img {  transition: .4s;}.about-avatar:hover img {  transform: scale(1.05);}.tagcloud a {  transition: .6s;}.tagcloud a:hover {  transform: scale(1.05);}```# 彩虹加载动效由于我的博客使用Github Pages托管，因此在加载时偶尔会花费较长时间，这时页面各种效果加载的速度往往并不一致，大大影响了观感。因此，我参考Emberffの小破站，为博客添加了彩虹加载动效。<a href="https://blog.emb42.com/2024/10/04/Hexo-Fluid%E8%83%8C%E6%99%AF%E5%9B%BA%E5%AE%9A%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/" name="https://blog.emb42.com/img/avatar.png" class="LinkCard">Hexo Fluid背景固定以及添加加载动画</a>在 `source/js/` 目录下新建一个 `RainbowLoading.js` 文件（如果不存在该目录则需要先创建），代码如下：```javascriptfunction loadScript(url, callback) {    const script = document.createElement('script');    script.type = 'text/javascript';    script.src = url;    script.onload = function() {        callback();    };    document.head.appendChild(script);}// 加载 jQueryloadScript('https://code.jquery.com/jquery-3.6.0.min.js', function() {    $(function(){        $("#loader-container").fadeOut(560);    });});```然后在 `source/css/` 目录下新建一个 `RainbowLoading.css` 文件（如果不存在该目录则需要先创建），代码如下：```css#loader-container {   position: fixed; /* 或 absolute，根据需求 */   top: 0;   left: 0;   right: 0;   bottom: 0;   z-index: 99999; /* 确保在最上层 */   display: flex;   justify-content: center;   align-items: center;   background: rgba(0, 0, 0, 0.7); /* 可选：添加背景以增加可见性 */}.loader,.loader-inner,.loader-line-wrap,.loader-line {    position: absolute; /* 或 fixed，根据需要选择 */    z-index: 99999; /* 确保在最上层 */}.loader {   background: #000;   background: radial-gradient(#222, #000);   bottom: 0;   left: 0;   overflow: hidden;   position: fixed;   right: 0;   top: 0;   z-index: 99999;}.loader-inner {   bottom: 0;   height: 60px;   left: 0;   margin: auto;   position: absolute;   right: 0;   top: 0;   width: 100px;}.loader-line-wrap {   animation:      spin 2000ms cubic-bezier(.175, .885, .32, 1.275) infinite  ;   box-sizing: border-box;   height: 50px;   left: 0;   overflow: hidden;   position: absolute;   top: 0;   transform-origin: 50% 100%;   width: 100px;}.loader-line {   border: 4px solid transparent;   border-radius: 100%;   box-sizing: border-box;   height: 100px;   left: 0;   margin: 0 auto;   position: absolute;   right: 0;   top: 0;   width: 100px;}.loader-line-wrap:nth-child(1) { animation-delay: -50ms; }.loader-line-wrap:nth-child(2) { animation-delay: -100ms; }.loader-line-wrap:nth-child(3) { animation-delay: -150ms; }.loader-line-wrap:nth-child(4) { animation-delay: -200ms; }.loader-line-wrap:nth-child(5) { animation-delay: -250ms; }.loader-line-wrap:nth-child(1) .loader-line {   border-color: hsl(0, 80%, 60%);   height: 90px;   width: 90px;   top: 7px;}.loader-line-wrap:nth-child(2) .loader-line {   border-color: hsl(60, 80%, 60%);   height: 76px;   width: 76px;   top: 14px;}.loader-line-wrap:nth-child(3) .loader-line {   border-color: hsl(120, 80%, 60%);   height: 62px;   width: 62px;   top: 21px;}.loader-line-wrap:nth-child(4) .loader-line {   border-color: hsl(180, 80%, 60%);   height: 48px;   width: 48px;   top: 28px;}.loader-line-wrap:nth-child(5) .loader-line {   border-color: hsl(240, 80%, 60%);   height: 34px;   width: 34px;   top: 35px;}@keyframes spin {   0%, 15% {     transform: rotate(0);  }  100% {     transform: rotate(360deg);  }}```然后还需要在 `source/html/` 目录下新建一个 `RainbowLoading.html` 文件（如果不存在该目录则需要先创建），代码如下：```html<div id="loader-container">     <div id="loader" class="loader"></div>    <div class="loader-inner">        <div class="loader-line-wrap">            <div class="loader-line"></div>        </div>        <div class="loader-line-wrap">            <div class="loader-line"></div>        </div>        <div class="loader-line-wrap">            <div class="loader-line"></div>        </div>        <div class="loader-line-wrap">            <div class="loader-line"></div>        </div>        <div class="loader-line-wrap">            <div class="loader-line"></div>        </div>    </div></div><script src="/js/RainbowLoading.js" type="text/javascript"></script><link href="/css/RainbowLoading.css" type="text/css" rel="stylesheet"/>```{% fold info @注：由于在html中已经引入了相关的js和css文件，因此这一步可省略 %}然后在 `_config.fluid.yml` 文件的 `custom_js` 和 `custom_css` 部分添加以下内容：```yamlcustom_js:  - /js/RainbowLoading.jscustom_css:  - /css/RainbowLoading.css```{% endfold %}在这之后，还需要使用Hexo的注入功能来将加载动画的HTML代码注入到页面中。我们需要在博客根目录下新建 `scripts/` 目录，然后在该目录下新建一个 `injector.js` 文件，代码如下：```javascript// 注入彩虹加载动画hexo.extend.filter.register('theme_inject', function(injects) {  injects.bodyBegin.file('loader', 'source/html/RainbowLoading.html');});```Hexo注入器的使用可以参考Fluid主题的用户手册。<a href="https://hexo.fluid-dev.com/docs/advance/#hexo-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81" name="https://hexo.fluid-dev.com/docs/fluid_hexo.png" class="LinkCard">Hexo 注入代码</a># 背景动态线条动效但是，现在我又觉得纯色的界面有些单调了，于是我为背景加上了动态线条的效果。参考EmoryHuang's Blog的代码并进行一定修改。在 `source/js/` 目录下新建一个 `DynamicLine.js` 文件（如果不存在该目录则需要先创建），代码如下：```javascript(function() {    // 检测深色模式的辅助函数 - 直接检查data-user-color-scheme属性    function isDarkMode() {        const htmlElement = document.documentElement;        const userScheme = htmlElement.getAttribute('data-user-color-scheme');        const defaultScheme = htmlElement.getAttribute('data-default-color-scheme');        // 如果用户手动设置了主题，优先使用用户设置        if (userScheme) {            return userScheme === 'dark';        }        // 否则使用默认主题设置        if (defaultScheme) {            return defaultScheme === 'dark';        }        // 如果都没有设置，检查系统偏好        return window.matchMedia('(prefers-color-scheme: dark)').matches;    }    // 获取元素属性的辅助函数    function getAttr(el, attr, defaultValue) {        return el.getAttribute(attr) || defaultValue;    }    // 获取标签元素的辅助函数    function getTags(tag) {        return document.getElementsByTagName(tag);    }    // 获取配置信息，根据深色模式设置不同的线条颜色    function getConfig() {        var scripts = getTags("script");        var lastScript = scripts[scripts.length - 1];        // 根据深色模式状态设置线条颜色        const lineColor = isDarkMode() ? "255,255,255" : "0,0,0";        return {            l: scripts.length,            z: getAttr(lastScript, "zIndex", -1),            o: getAttr(lastScript, "opacity", 0.5),            c: getAttr(lastScript, "color", lineColor),            n: getAttr(lastScript, "count", 99)        };    }    // 设置Canvas尺寸    function setCanvasSize() {        width = canvas.width = window.innerWidth ||            document.documentElement.clientWidth ||            document.body.clientWidth;        height = canvas.height = window.innerHeight ||            document.documentElement.clientHeight ||            document.body.clientHeight;    }    // 绘制函数    function draw() {        ctx.clearRect(0, 0, width, height);        var allPoints = [mouse].concat(points);        points.forEach(function(p) {            p.x += p.xa;            p.y += p.ya;            p.xa *= (p.x > width || p.x < 0) ? -1 : 1;            p.ya *= (p.y > height || p.y < 0) ? -1 : 1;            ctx.fillRect(p.x - 0.5, p.y - 0.5, 1, 1);            for (var v = 0; v < allPoints.length; v++) {                var q = allPoints[v];                if (p !== q && q.x !== null && q.y !== null) {                    var dx = p.x - q.x;                    var dy = p.y - q.y;                    var dist = dx * dx + dy * dy;                    if (dist < q.max) {                        if (q === mouse && dist >= q.max / 2) {                            p.x -= 0.03 * dx;                            p.y -= 0.03 * dy;                        }                        var ratio = (q.max - dist) / q.max;                        ctx.beginPath();                        ctx.lineWidth = ratio / 2;                        ctx.strokeStyle = "rgba(" + config.c + "," + (ratio + 0.2) + ")";                        ctx.moveTo(p.x, p.y);                        ctx.lineTo(q.x, q.y);                        ctx.stroke();                    }                }            }            allPoints.splice(allPoints.indexOf(p), 1);        });        animation(draw);    }    // 主题变化时更新Canvas配置    function updateCanvasTheme() {        const newColor = isDarkMode() ? "255,255,255" : "0,0,0";        if (config.c !== newColor) {            config.c = newColor;            console.log("主题已切换，线条颜色更新为:", newColor === "255,255,255" ? "白色" : "黑色");        }    }    var canvas = document.createElement("canvas"),        config = getConfig(),        canvasId = "c_n" + config.l,        ctx = canvas.getContext("2d"),        width, height,        animation = window.requestAnimationFrame ||            window.webkitRequestAnimationFrame ||            window.mozRequestAnimationFrame ||            window.oRequestAnimationFrame ||            window.msRequestAnimationFrame ||            function(fn) { window.setTimeout(fn, 1000 / 45); },        random = Math.random,        mouse = { x: null, y: null, max: 20000 };    canvas.id = canvasId;    canvas.style.cssText =        "position:fixed;top:0;left:0;z-index:" + config.z + ";opacity:" + config.o;    getTags("body")[0].appendChild(canvas);    setCanvasSize();    window.onresize = setCanvasSize;    window.onmousemove = function(e) {        e = e || window.event;        mouse.x = e.clientX;        mouse.y = e.clientY;    };    window.onmouseout = function() {        mouse.x = null;        mouse.y = null;    };    var points = [];    for (var i = 0; i < config.n; i++) {        var x = random() * width,            y = random() * height,            xa = 2 * random() - 1,            ya = 2 * random() - 1;        points.push({ x: x, y: y, xa: xa, ya: ya, max: 6000 });    }    // 初始设置线条颜色    updateCanvasTheme();    // 监听data-user-color-scheme和data-default-color-scheme属性变化    if (window.MutationObserver) {        new MutationObserver(updateCanvasTheme).observe(document.documentElement, {            attributes: true,            attributeFilter: ['data-user-color-scheme', 'data-default-color-scheme']        });    }    // 监听系统主题变化    if (window.matchMedia) {        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', updateCanvasTheme);    }    setTimeout(function() {        draw();    }, 100);})();```并在 `_config.fluid.yml` 文件的 `custom_js` 部分添加以下内容：```yamlcustom_js:  - /js/DynamicLine.js```这样，在博客加载时就会自动添加动态线条效果。# 标签页根据焦点切换显示在浏览其他人的博客时，我发现有些博客在我切换出标签页时，顶栏会呈现出挽留的效果，然而我实在不知道应该用什么关键词检索相关代码，因此只能自行查阅资料来实现。最终我了解到这样的效果是通过页面可见性事件 `visibilitychange` 监听来实现的。在 `source/js/` 目录下新建一个 `TabDisplay.js` 文件（如果不存在该目录则需要先创建），代码如下：```javascriptjQuery(document).ready(function() {    var b, c, a = document.title;    var welcomeTimer = null;    function d() {        if (document[b]) {            document.title = " 你去哪啦(๑•́ ₃ •̀๑) ";            if (welcomeTimer) {                clearTimeout(welcomeTimer);                welcomeTimer = null;            }        } else {            document.title = " 你回来啦(*^▽^*) ";            welcomeTimer = setTimeout(function() {                document.title = a;            }, 2000);        }    }    if (typeof document.hidden !== "undefined") {        b = "hidden";        c = "visibilitychange";    } else if (typeof document.mozHidden !== "undefined") {        b = "mozHidden";        c = "mozvisibilitychange";    } else if (typeof document.webkitHidden !== "undefined") {        b = "webkitHidden";        c = "webkitvisibilitychange";    }    if ((typeof document.addEventListener !== "undefined" || typeof document[b] !== "undefined") && c) {        document.addEventListener(c, d, false);    }});```并在 `_config.fluid.yml` 文件的 `custom_js` 部分添加以下内容：```yamlcustom_js:  - /js/TabDisplay.js```# 总结至此，我的博客就完成了当前所有的美化效果！最终，`_config.fluid.yml` 文件的 `custom_js` 和 `custom_css` 部分如下所示：```yaml# 指定自定义 .js 文件路径，支持列表；路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js# Specify the path of your custom js file, support list. The path is relative to the source directory, such as `/js/custom.js` corresponding to the directory `source/js/custom.js`custom_js:  - /js/DynamicLine.js # 动态线条  - /js/LinkCard.js # 链接卡片效果  - /js/ScrollAnimation.js # 首页文章滑入动画  - /js/TabDisplay.js # 标签页根据焦点切换显示# 指定自定义 .css 文件路径，用法和 custom_js 相同# The usage is the same as custom_jscustom_css:  - /css/CodeBlock.css # 代码折叠  - /css/CodeInLine.css # 行内代码样式  - /css/FrostedGlassBg.css # 文章界面毛玻璃  - /css/IndexImgHover.css # 首页文章封面图片悬浮效果  - /css/LinkCard.css # 链接卡片效果  - /css/ScrollAnimation.css # 首页文章滑入动画  - /css/ScrollBar.css # 滚动条颜色  - /css/StrongInDark.css # 强化暗色模式加粗字体  - /css/TitleGradient.css # 文章标题颜色渐变效果  - /css/TitleNeon.css # 博客标题霓虹灯效  - /css/UnifyImgWidth.css # 统一文章图片宽度  - https://lib.baomitu.com/font-awesome/6.1.2/css/all.min.css # Font Awesome 图标库```具体的代码可以参考我的博客仓库中的 `js` 和 `css` 目录。<a href="https://github.com/youyeyejie/youyeyejie.github.io" name="/img/avatar/avatar.webp" class="LinkCard">GitHub 仓库</a>]]></content>
      
      
      <categories>
          
          <category> Hexo Blog Building </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Fluid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>且以群词 注解我这座荒山</title>
      <link href="/_posts/%E4%B8%94%E4%BB%A5%E7%BE%A4%E8%AF%8D-%E6%B3%A8%E8%A7%A3%E6%88%91%E8%BF%99%E5%BA%A7%E8%8D%92%E5%B1%B1/"/>
      <url>/_posts/%E4%B8%94%E4%BB%A5%E7%BE%A4%E8%AF%8D-%E6%B3%A8%E8%A7%A3%E6%88%91%E8%BF%99%E5%BA%A7%E8%8D%92%E5%B1%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="本站的由来">本站的由来</h1><p>每个人建立自己博客的原因都不尽相同，有的是为了与他人分享知识和情绪，有的是为了记录自己的学习、工作与生活，有的是为了展现自己的能力。相比之下，我的理由就显得有些出人意料了——我只是觉得有个属于自己的博客挺酷的。</p><p>最初打动我的其实是Boar酱的图库，毕竟作为同样一个喜欢摄影的人，我也希望有一个属于自己的网站来展示我的摄影作品。但是苦于技术力有限，我始终只敢远观。于是，我将眼光放在了无需自己从零开始手搓，而是可以站在前人的肩膀上，使用现成的框架和主题来搭建的博客上。</p><p><a href="https://gallery.boar.osaka/" class="LinkCard">Boar’sGallery</a></p><p>除此之外，Teruteru的博客也给了我很大的帮助和启发。事实上，过去的我并不十分热衷于记录和分享，但一次又一次在期末周借助Teruteru的学习笔记进行复习迎接考试的过程中，我逐渐意识到记录和分享的重要性。于是，我决定建立一个属于自己的博客，记录我的学习和生活点滴。</p><p><a href="https://teruteru.space/" name="https://teruteru.space/img/teruteru.jpg" class="LinkCard">Teruteru的学习笔记</a></p><h1 id="本站的搭建">本站的搭建</h1><p>在了解了主流的博客搭建方式后，我选择了Hexo作为我的博客框架。Hexo是一个基于Node.js的静态博客框架，具有快速和简洁的特点，且其社区活跃度高、文档完善，也易于学习和使用。相比于动态博客系统，Hexo的静态页面生成方式使得博客加载速度更快，也不必自行注册域名和购买服务器，极大降低了我的学习成本与维护成本。除此之外，Hexo还拥有丰富的主题和插件生态系统，可以满足我对博客外观和功能的各种需求。</p><p>在选择主流的Hexo作为博客框架之后，面临的第一个问题就是选择一个合适的主题。在一番比较后，Fluid、Solitude、Matery、ShokaX等主题“入围”了我的初步选择。Fluid主题兼顾简洁和美观、文档最为完善，对于在网站开发方面经验为零的我来说最为友好，且我的“博客启蒙”——Teruteru的博客就是基于Fluid主题搭建的，因此我最终选择了Fluid主题。</p><h1 id="本站的内容">本站的内容</h1><p>在短期内，我将陆续整理过去两年的部分笔记，并将其发布到本站上。而在此之后，也即接下来的很长一段时间内，本站主要发布的都将是我在学习过程中留下的笔记，未来或许会进一步分享更多的内容。此外，本站也会记录我对这个博客进行搭建和美化的过程，为其他想要搭建Hexo博客的朋友提供一些参考和帮助。</p><p>正如标题所说，本站是我博客的起点：人生缓缓，自有答案，且以群词，注解我这座荒山。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo Blog Building </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Fluid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象代数</title>
      <link href="/_posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
      <url>/_posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章基于<a href="https://teruteru.space/2024/02/21/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/">Teruteru的学习笔记</a>进行整理，针对2024-2025 学年春季学期教学内容进行修改。</p></blockquote><h1 id="解题范式">解题范式</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-93269758" role="button" aria-expanded="false" aria-controls="collapse-93269758">        <div class="fold-arrow">▶</div>解题范式      </div>      <div class="fold-collapse collapse" id="collapse-93269758">        <div class="fold-content">          <h2 id="证明相等">证明相等</h2><p>两个集合 <span class="math inline"><em>A</em>, <em>B</em></span>相等：</p><ol type="1"><li>证明 <span class="math inline"><em>A</em> ⊆ <em>B</em></span></li><li>证明 <span class="math inline"><em>B</em> ⊆ <em>A</em></span></li></ol><p>两个数 <span class="math inline"><em>a</em>, <em>b</em></span>相等：</p><ol type="1"><li>证明 <span class="math inline"><em>a</em> ∣ <em>b</em></span></li><li>证明 <span class="math inline"><em>b</em> ∣ <em>a</em></span></li></ol><h2 id="等价关系">等价关系</h2><p>若要证明 <span class="math inline">∼</span> 是一个等价关系：</p><ol type="1"><li>证明 <strong>反身性</strong></li><li>证明 <strong>对称性</strong></li><li>证明 <strong>传递性</strong></li></ol><h2 id="代数运算">代数运算</h2><p>若要证明集合 <span class="math inline"><em>A</em></span> 中的运算<span class="math inline">⋅</span> 是一个代数运算：</p><ol type="1"><li>证明 <strong>封闭性</strong></li><li>证明 <strong>唯一性</strong> （通常显然）</li></ol><h2 id="群">群</h2><p>若要证明集合 <span class="math inline"><em>A</em></span> 关于运算<span class="math inline">⋅</span> 构成一个群：</p><ol type="1"><li>证明 <span class="math inline">⋅</span> 是<strong>代数运算</strong></li><li>证明 <strong>结合律</strong> （左右结合律）</li><li>证明 <strong>单位元</strong> <span class="math inline"><em>e</em></span> 存在（左右单位元）</li><li>证明 <strong>逆元</strong> 存在（左右逆元）</li></ol><h2 id="子群">子群</h2><p>若要证明群 <span class="math inline"><em>G</em></span> 的子集 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，即 <span class="math inline"><em>H</em> &lt; <em>G</em></span>：</p><ul><li>定义：<ol type="1"><li><span class="math inline"><em>H</em></span> 在群的运算下封闭</li><li><span class="math inline"><em>H</em></span> 有单位元</li><li><span class="math inline"><em>H</em></span> 中每个元素都有逆元</li></ol></li><li>定理1：<ol type="1"><li>证明 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的 <strong>非空</strong> 子集</li><li>对任意 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>H</em></span>，证明<span class="math inline"><em>a</em><em>b</em> ∈ <em>H</em></span></li><li>对任意 <span class="math inline"><em>a</em> ∈ <em>H</em></span>，证明 <span class="math inline"><em>a</em><sup>−1</sup> ∈ <em>H</em></span></li></ol></li><li>定理2：<ol type="1"><li>证明 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的 <strong>非空</strong> 子集</li><li>对任意 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>H</em></span>，证明<span class="math inline"><em>a</em><em>b</em><sup>−1</sup> ∈ <em>H</em></span></li></ol></li></ul><h2 id="正规子群">正规子群</h2><p>若要证明群 <span class="math inline"><em>G</em></span> 的子群 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，即 <span class="math inline"><em>H</em> ⊲ <em>G</em></span>，则下面几个条件等价</p><ol type="1"><li><span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群</li><li><span class="math inline">∀<em>g</em> ∈ <em>G</em></span>，<span class="math inline"><em>g</em><em>H</em> = <em>H</em><em>g</em></span></li><li><span class="math inline">∀<em>g</em> ∈ <em>G</em></span>，<span class="math inline"><em>g</em><em>H</em><em>g</em><sup>−1</sup> = <em>H</em></span></li><li><span class="math inline">∀<em>g</em> ∈ <em>G</em></span>，<span class="math inline"><em>g</em><em>H</em><em>g</em><sup>−1</sup> ⊆ <em>H</em></span></li><li><span class="math inline">∀<em>g</em> ∈ <em>G</em></span>，<span class="math inline"><em>h</em> ∈ <em>H</em></span>，则 <span class="math inline"><em>g</em><em>h</em><em>g</em><sup>−1</sup> ∈ <em>H</em></span></li></ol><h2 id="群同态">群同态</h2><p>若要证明两个群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 同态：</p><ol type="1"><li>建立群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>映射</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明由<span class="math inline"><em>x</em> = <em>y</em></span> 可推出 <span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>ϕ</em>(<em>y</em>)</span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明<span class="math inline"><em>ϕ</em>(<em>x</em><em>y</em>) = <em>ϕ</em>(<em>x</em>)<em>ϕ</em>(<em>y</em>)</span></li></ul></li><li>若还能证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满射</strong>，则 <span class="math inline"><em>ϕ</em></span> 是<span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满同态映射</strong></li><li>若还能证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>单射</strong>，则 <span class="math inline"><em>ϕ</em></span> 是<span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>单同态映射</strong></li></ol><h2 id="群同构">群同构</h2><p>若要证明两个群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 同构：</p><ol type="1"><li>构造群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>映射</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明由<span class="math inline"><em>x</em> = <em>y</em></span> 可推出 <span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>ϕ</em>(<em>y</em>)</span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>单射</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明由<span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>ϕ</em>(<em>y</em>)</span>可推出 <span class="math inline"><em>x</em> = <em>y</em></span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满射</strong><ul><li>即对 <span class="math inline">∀<em>x</em><sup>′</sup> ∈ <em>G</em><sup>′</sup></span>，证明存在（构造）<span class="math inline"><em>x</em> ∈ <em>G</em></span>，使 <span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>x</em><sup>′</sup></span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明<span class="math inline"><em>ϕ</em>(<em>x</em><em>y</em>) = <em>ϕ</em>(<em>x</em>)<em>ϕ</em>(<em>y</em>)</span></li></ul></li></ol><p>若要证明 <span class="math inline"><em>G</em>/<em>K</em> ≅ <em>G</em><sup>′</sup></span>，即<span class="math inline"><em>G</em>/<em>K</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 同构：</p><ol type="1"><li>建立群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素之间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>映射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong> <span class="math display"><em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span></li><li>综上 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满同态映射</strong></li><li>计算同态的 <strong>核</strong> <span class="math inline">Ker <em>ϕ</em></span>，使得 <span class="math inline"><em>K</em> = Ker <em>ϕ</em></span></li><li>应用 <strong>群同态基本定理</strong> 得 <span class="math inline"><em>G</em>/Ker <em>ϕ</em> ≅ <em>G</em><sup>′</sup></span></li></ol><h2 id="环">环</h2><p>若要证明 <span class="math inline"><em>R</em></span> 是一个环：</p><ol type="1"><li>证明 <strong>加法封闭</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> + <em>y</em> ∈ <em>R</em></span></li></ul></li><li>证明加法满足 <strong>加法结合律</strong> 和<strong>加法交换律</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em>, <em>z</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> + <em>y</em> = <em>y</em> + <em>x</em></span>，<span class="math inline"><em>x</em> + (<em>y</em> + <em>z</em>) = (<em>x</em> + <em>y</em>) + <em>z</em></span></li></ul></li><li>找到加法 <strong>零元</strong><ul><li><span class="math inline">∃0 ∈ <em>R</em>, ∀<em>x</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> + 0 = <em>x</em></span></li></ul></li><li>找到加法 <strong>负元</strong><ul><li><span class="math inline">∀<em>x</em> ∈ <em>R</em>, ∃−<em>x</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> + (−<em>x</em>) = 0</span></li></ul></li><li>证明 <strong>乘法封闭</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> ⋅ <em>y</em> ∈ <em>R</em></span></li></ul></li><li>证明乘法满足 <strong>结合律</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em>, <em>z</em> ∈ <em>R</em></span>：<span class="math inline">(<em>x</em> ⋅ <em>y</em>) ⋅ <em>z</em> = <em>x</em> ⋅ (<em>y</em> ⋅ <em>z</em>)</span></li></ul></li><li>证明乘法对加法满足 <strong>两个分配律</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em>, <em>z</em> ∈ <em>R</em></span><span class="math display">$$ \begin{array}{c} x\cdot (y + z) = x\cdot y +x\cdot z\\\ (y+z)\cdot x = y\cdot x + z\cdot x \end{array}$$</span></li></ul></li><li>综上可得 <span class="math inline"><em>R</em></span> 是一个环</li><li>如果 <span class="math inline"><em>R</em></span>的乘法满足交换律，则 <span class="math inline"><em>R</em></span> 是一个<strong>交换环</strong></li><li>如果 <span class="math inline"><em>R</em></span> 的乘法有单位元，则<span class="math inline"><em>R</em></span> 是一个有<strong>单位元</strong> 的环</li></ol><p>其中，1 - 4 即证明 <span class="math inline">(<em>R</em>, +)</span>是一个 <strong>加法交换群</strong>，5 - 7 即证明 <span class="math inline"><em>R</em></span> 还具有乘法代数运算。</p><h2 id="整环">整环</h2><p>若要证明 <span class="math inline"><em>R</em></span> 是一个整环：</p><ol type="1"><li>证明 <span class="math inline"><em>R</em></span> 是一个<strong>交换环</strong></li><li>证明 <span class="math inline"><em>R</em></span> 中有<strong>单位元</strong> 且单位元不为零元</li><li>证明 <span class="math inline"><em>R</em></span> 中没有<strong>零因子</strong><ul><li>即对 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>R</em></span>，如果<span class="math inline"><em>a</em> ⋅ <em>b</em> = 0</span>，则 <span class="math inline"><em>a</em> = 0</span> 或 <span class="math inline"><em>b</em> = 0</span></li></ul></li></ol><h2 id="域">域</h2><p>若要证明 <span class="math inline"><em>F</em></span> 是一个域：</p><ol type="1"><li>证明 <span class="math inline"><em>F</em></span> 是一个<strong>交换环</strong></li><li>证明 <span class="math inline"><em>F</em></span> 中有<strong>单位元</strong> 且单位元不为零元</li><li>证明 <span class="math inline"><em>F</em></span> 中每个<strong>非零元都可逆</strong><ul><li>即对 <span class="math inline">∀<em>a</em> ∈ <em>F</em></span> 且<span class="math inline"><em>a</em> ≠ 0</span>，存在 <span class="math inline"><em>b</em> ∈ <em>F</em></span> 使得 <span class="math inline"><em>a</em> ⋅ <em>b</em> = 1</span></li></ul></li></ol><h2 id="子环">子环</h2><p>若要证明环 <span class="math inline"><em>R</em></span> 的子集 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的子环：</p><ul><li>定理1：<ol type="1"><li>证明 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>非空子集</strong>（通常显然）</li><li>证明 <span class="math inline">(<em>S</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的<strong>加法子群</strong></li><li><span class="math inline"><em>S</em></span> 关于 <span class="math inline"><em>R</em></span> 的 <strong>乘法封闭</strong>，即对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>S</em></span>，有 <span class="math inline"><em>a</em><em>b</em> ∈ <em>S</em></span></li></ol></li><li>定理2：<ol type="1"><li>证明 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>非空子集</strong>（通常显然）</li><li>证明 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>S</em></span>，有<span class="math inline"><em>a</em> − <em>b</em> ∈ <em>S</em></span>（<strong>减法封闭</strong>）</li><li>证明 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>S</em></span>，有<span class="math inline"><em>a</em><em>b</em> ∈ <em>S</em></span>（<strong>乘法封闭</strong>）</li></ol></li></ul><h2 id="理想">理想</h2><p>若要证明环 <span class="math inline"><em>R</em></span> 的子集 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的理想：</p><ol type="1"><li>证明 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>非空子集</strong>（通常显然）</li><li>证明 <span class="math inline">∀<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub> ∈ <em>I</em></span>，<span class="math inline"><em>r</em><sub>1</sub> − <em>r</em><sub>2</sub> ∈ <em>I</em></span>（<strong>减法封闭</strong>）</li><li>证明 <span class="math inline">∀<em>r</em> ∈ <em>I</em></span>，<span class="math inline"><em>s</em> ∈ <em>R</em></span>，<span class="math inline"><em>r</em><em>s</em>, <em>s</em><em>r</em> ∈ <em>I</em></span>（<strong>乘法吸收</strong>）</li></ol><h2 id="环同态">环同态</h2><p>若要证明 <span class="math inline"><em>ϕ</em> : <em>R</em> → <em>R</em><sup>′</sup></span>是一个同态映射：</p><ol type="1"><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>映射</strong><ul><li>即对 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>R</em></span>，证明由<span class="math inline"><em>a</em> = <em>b</em></span> 可推出 <span class="math inline"><em>ϕ</em>(<em>a</em>) = <em>ϕ</em>(<em>b</em>)</span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong><ul><li>即对 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>R</em></span>，证明<ol type="1"><li><span class="math inline"><em>ϕ</em>(<em>a</em> + <em>b</em>) = <em>ϕ</em>(<em>a</em>) + <em>ϕ</em>(<em>b</em>)</span>（<strong>加法保持</strong>）</li><li><span class="math inline"><em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span>（<strong>乘法保持</strong>）</li></ol></li></ul></li><li>若还能证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满射</strong>，则 <span class="math inline"><em>ϕ</em></span> 是<span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满同态映射</strong></li><li>若还能证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>单射</strong>，则 <span class="math inline"><em>ϕ</em></span> 是<span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>单同态映射</strong></li></ol><h2 id="环同构">环同构</h2><p>若要证明环 <span class="math inline"><em>R</em></span> 与环 <span class="math inline"><em>R</em><sup>′</sup></span> 同构：</p><ol type="1"><li>构造环 <span class="math inline"><em>R</em></span> 与环 <span class="math inline"><em>R</em><sup>′</sup></span> 的元素间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>映射</strong><ul><li>即对 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>R</em></span>，证明由<span class="math inline"><em>a</em> = <em>b</em></span> 可推出 <span class="math inline"><em>ϕ</em>(<em>a</em>) = <em>ϕ</em>(<em>b</em>)</span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>单射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong></li></ol><p>若要证明 <span class="math inline"><em>R</em>/<em>I</em> ≅ <em>R</em><sup>′</sup></span>，即<span class="math inline"><em>R</em>/<em>I</em></span> 与 <span class="math inline"><em>R</em><sup>′</sup></span> 同构：</p><ol type="1"><li>建立环 <span class="math inline"><em>R</em></span> 与环 <span class="math inline"><em>R</em><sup>′</sup></span> 的元素之间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>映射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong> <span class="math display"><em>ϕ</em>(<em>a</em> + <em>b</em>) = <em>ϕ</em>(<em>a</em>) + <em>ϕ</em>(<em>b</em>),  <em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span></li><li>综上 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满同态映射</strong></li><li>计算同态的 <strong>核</strong> <span class="math inline">Ker <em>ϕ</em></span>，使得 <span class="math inline"><em>I</em> = Ker <em>ϕ</em></span></li><li>应用 <strong>环同态基本定理</strong> 得 <span class="math inline"><em>R</em>/Ker <em>ϕ</em> ≅ <em>R</em><sup>′</sup></span></li></ol><h2 id="素理想">素理想</h2><p>若要证明交换环 <span class="math inline"><em>R</em></span> 的理想<span class="math inline"><em>P</em></span> 是素理想：</p><ol type="1"><li>证明 <span class="math inline"><em>P</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>真理想</strong></li><li>证明对任意 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，如果<span class="math inline"><em>a</em><em>b</em> ∈ <em>P</em></span>，则<span class="math inline"><em>a</em> ∈ <em>P</em></span> 或 <span class="math inline"><em>b</em> ∈ <em>P</em></span></li></ol><h2 id="极大理想">极大理想</h2><p>若要证明交换环 <span class="math inline"><em>R</em></span> 的理想<span class="math inline"><em>I</em></span> 是极大理想：</p><ol type="1"><li>证明 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>真理想</strong></li><li>设 <span class="math inline"><em>J</em></span> 是 <span class="math inline"><em>R</em></span> 的任意理想，且 <span class="math inline"><em>I</em> ⊊ <em>J</em> ⊆ <em>R</em></span>（左右夹击）</li><li>任取 <span class="math inline"><em>x</em> ∈ <em>J</em></span> 且<span class="math inline"><em>x</em> ∉ <em>I</em></span></li><li>根据 <span class="math inline"><em>x</em> ∉ <em>I</em></span>，获取约束条件，如不整除、互素等</li><li>构造 <span class="math inline">1 = ⋯ ∈ <em>J</em></span></li><li>因此 <span class="math inline"><em>J</em> = <em>R</em></span></li><li>故 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的极大理想</li></ol><p>若要证明交换环 <span class="math inline"><em>R</em></span> 的理想<span class="math inline"><em>I</em></span> 是唯一极大理想：</p><ol type="1"><li>证明 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>真理想</strong></li><li>设 <span class="math inline"><em>J</em></span> 是 <span class="math inline"><em>R</em></span> 的任意 <strong>不包含于</strong><span class="math inline"><em>I</em></span> 的理想</li><li>任取 <span class="math inline"><em>x</em> ∈ <em>J</em></span> 且<span class="math inline"><em>x</em> ∉ <em>I</em></span></li><li>根据 <span class="math inline"><em>x</em> ∉ <em>I</em></span>，获取约束条件，如不整除、互素等</li><li>构造 <span class="math inline">1 = ⋯ ∈ <em>J</em></span></li><li>因此 <span class="math inline"><em>J</em> = <em>R</em></span></li><li>故 <span class="math inline"><em>R</em></span> 的所有真理想都包含于<span class="math inline"><em>I</em></span>，即 <span class="math inline"><em>I</em></span> 是唯一极大理想</li></ol><h2 id="特征">特征</h2><p>若要证明 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline"><em>n</em></span>，<span class="math inline"><em>n</em> ≠ 0</span>：<br>- 方法一： 1. 给出正整数 <span class="math inline"><em>n</em></span>，使得 <span class="math inline">∀<em>a</em> ∈ <em>R</em>, <em>n</em><em>a</em> = 0</span>（存在<span class="math inline"><em>n</em></span>） 2. 证明 <span class="math inline">∀<em>k</em>, 1 ≤ <em>k</em> &lt; <em>n</em>, ∃<em>b</em> ∈ <em>R</em>, <em>k</em><em>b</em> ≠ 0</span>（没有比<span class="math inline"><em>n</em></span> 更小的）</p><ul><li>方法二：（若 <span class="math inline"><em>R</em></span> 有单位元）<ol type="1"><li>找出 <span class="math inline"><em>R</em></span> 的单位元 <span class="math inline"><em>e</em></span></li><li>计算 <span class="math inline"><em>e</em></span> 关于加法的阶 <span class="math inline"><em>n</em></span></li><li>特征 <span class="math inline">Char <em>R</em> = <em>n</em></span></li></ol></li></ul><p>若要证明 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline"><em>n</em> = 0</span>： - 证明 <span class="math inline"><em>R</em></span> 的单位元 <span class="math inline"><em>e</em></span> 关于加法的阶为无穷大</p>        </div>      </div>    </div><h1 id="第一章-群">第一章 群</h1><h2 id="等价关系与集合的分类">等价关系与集合的分类</h2><h3 id="二元关系">二元关系</h3><p>设 <span class="math inline"><em>S</em></span> 是一个<strong>非空集合</strong> ，<span class="math inline">ℛ</span> 是关于<span class="math inline"><em>S</em></span> 的元素的一个条件。如果对<span class="math inline"><em>S</em></span> 中 <strong>任意</strong>一个 <strong>有序</strong> 元素对<span class="math inline">(<em>a</em>, <em>b</em>)</span>，我们总能<strong>确定</strong><span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 是否满足条件 <span class="math inline">ℛ</span>，就称 <span class="math inline">ℛ</span> 是<span class="math inline"><em>S</em></span>的一个<strong>关系</strong>。如果 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 满足条件 <span class="math inline">ℛ</span>，则称 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 有关系 <span class="math inline">ℛ</span>，记作 <span class="math inline"><em>a</em>ℛ<em>b</em></span>；否则称 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 无关系 <span class="math inline">ℛ</span>。</p><ul><li>关系 <span class="math inline">ℛ</span>也称为<strong>二元关系</strong>。</li><li>注意 <span class="math inline">ℛ</span>的确定性，“总能”表示忽略验证所需的时间和复杂度</li></ul><h3 id="等价关系">等价关系</h3><p>设 <span class="math inline">ℛ</span> 是非空集合 <span class="math inline"><em>S</em></span> 的一个关系，如果 <span class="math inline">ℛ</span> 满足</p><ul><li>反身性，即对任意的 <span class="math inline"><em>a</em> ∈ <em>S</em></span>，有 <span class="math inline"><em>a</em>ℛ<em>a</em></span></li><li>对称性，即若 <span class="math inline"><em>a</em>ℛ<em>b</em></span>，则 <span class="math inline"><em>b</em>ℛ<em>a</em></span></li><li>传递性，即若 <span class="math inline"><em>a</em>ℛ<em>b</em></span>，且 <span class="math inline"><em>b</em>ℛ<em>c</em></span>，则 <span class="math inline"><em>a</em>ℛ<em>c</em></span></li></ul><p>则称 <span class="math inline">ℛ</span> 是 <span class="math inline"><em>S</em></span> 的一个<strong>等价关系</strong>，并且如果 <span class="math inline"><em>a</em>ℛ<em>b</em></span>，则称<span class="math inline"><em>a</em></span> 等价于 <span class="math inline"><em>b</em></span>，记作 <span class="math inline"><em>a</em> ∼ <em>b</em></span></p><ul><li>注意可能存在孤立元素，即存在 <span class="math inline"><em>a</em></span>，对于任意 <span class="math inline"><em>b</em></span>，<span class="math inline"><em>a</em> ≁ <em>b</em></span>。</li><li>不能根据传递性和对称性推出自反性。（反例：<span class="math inline"><em>a</em></span> 可以是孤立元素且没有自反性）</li></ul><h3 id="等价类">等价类</h3><p>如果是集合 <span class="math inline"><em>S</em></span>的一个等价关系，对 <span class="math inline"><em>a</em> ∈ <em>S</em></span>，令 <span class="math display">[<em>a</em>] = {<em>x</em> ∈ <em>S</em> ∣ <em>x</em> ∼ <em>a</em>}</span></p><p>称子集 <span class="math inline">[<em>a</em>]</span> 为 <span class="math inline"><em>S</em></span> 的一个<strong>等价类</strong>。<span class="math inline"><em>S</em></span> 的全体等价类的集合称为集合<span class="math inline"><em>S</em></span>在等价关系下的<strong>商集</strong> ，记 <span class="math inline"><em>S</em>/∼</span></p><h3 id="同余关系与剩余类">同余关系与剩余类</h3><p>设 <span class="math inline"><em>m</em></span> 是正整数，在整数集<span class="math inline"><strong>Z</strong></span> 中，规定</p><p><span class="math display"><em>a</em>ℛ<em>b</em> ⇔ <em>m</em> ∣ <em>a</em> − <em>b</em>,  ∀<em>a</em>, <em>b</em> ∈ <strong>Z</strong></span></p><p>则</p><ul><li>对任意整数 <span class="math inline"><em>a</em></span>，有 <span class="math inline"><em>m</em> ∣ <em>a</em> − <em>a</em></span></li><li>若 <span class="math inline"><em>m</em> ∣ <em>a</em> − <em>b</em></span>，则<span class="math inline"><em>m</em> ∣ <em>b</em> − <em>a</em></span></li><li>若 <span class="math inline"><em>m</em> ∣ <em>a</em> − <em>b</em></span>，<span class="math inline"><em>m</em> ∣ <em>b</em> − <em>c</em></span>，则<span class="math inline"><em>m</em> ∣ <em>a</em> − <em>c</em></span></li></ul><p>所以 <span class="math inline">ℛ</span> 是 <span class="math inline">ℤ</span> 的一个等价关系。显然 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 等价当且仅当 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 被 <span class="math inline"><em>m</em></span>除有相同的余数，因此称这个关系为<strong>同余关系</strong> ，并记作 <span class="math inline"><em>a</em> ≡ <em>b</em>(&nbsp;mod &nbsp;<em>m</em>)</span></p><p>设 <span class="math inline"><em>a</em> ∈ ℤ</span>，则</p><p><span class="math display">$$\begin{aligned}{[a]} &amp; =\{x \in \mathbb{Z} \mid x \equiv a \quad(\bmod m)\} \\&amp; =\{x \in \mathbb{Z} \mid m| x-a\} \\&amp; =\{a+m z \mid z \in \mathbb{Z}\}\end{aligned}$$</span></p><p><span class="math inline">[<em>a</em>]</span> 称为整数集 <span class="math inline">ℤ</span> 的一个（与 <span class="math inline"><em>a</em></span> 同余的）<strong>模 m剩余类</strong> ，在数论中，<span class="math inline">[<em>a</em>]</span> 常记作 <span class="math inline"><em>ā</em></span>，而相应的商集称为 <span class="math inline">ℤ</span> 的模 m 剩余类集，记作 <span class="math inline">ℤ<sub><em>m</em></sub></span><br>由 <span class="math display"><em>ā</em> = <em>b̄</em> ⇔ <em>m</em> ∣ <em>a</em> − <em>b</em></span></p><p>易得 <span class="math display">$$\begin{array}{l}\overline{0}=\{\cdots,-2 m,-m,0,m,2 m,\cdots\},\\\overline{1}=\{\cdots,-2 m+1,-m+1,1,m+1,2 m+1,\cdots\},\\\cdots \cdots \\\overline{m-1}=\{\cdots,-2 m-1,-m-1,-1,m-1,2 m-1,\cdots\}\end{array}$$</span></p><p>是模 <span class="math inline"><em>m</em></span>的全体不同的剩余类，所以 <span class="math display">$$\mathbb{Z}_{m}=\{\overline{0},\overline{1},\overline{2},\cdots,\overline{m-1}\}$$</span></p><h3 id="分类">分类</h3><p>如果非空集合 <span class="math inline"><em>S</em></span>是它的某些两两不相交的非空子集的并，则称这些子集为集合 <span class="math inline"><em>S</em></span> 的一种<strong>分类</strong>，其中每个子集称为 <span class="math inline"><em>S</em></span>一个<strong>类</strong> 。如果 <span class="math inline"><em>S</em></span> 的子集族 <span class="math inline">{<em>S</em><sub><em>i</em></sub> ∣ <em>i</em> ∈ <em>I</em>}</span>构成 <span class="math inline"><em>S</em></span> 的一种分类，则记作<span class="math inline">𝒫 = {<em>S</em><sub><em>i</em></sub> ∣ <em>i</em> ∈ <em>I</em>}</span>由此定义可知，集合 <span class="math inline"><em>S</em></span> 的子集族<span class="math inline">{<em>S</em><sub><em>i</em></sub> ∣ <em>i</em> ∈ <em>I</em>}</span>构成 <span class="math inline"><em>S</em></span> 的一种分类当且仅当</p><ul><li><span class="math inline"><em>S</em> = ⋃<sub><em>i</em> ∈ <em>I</em></sub><em>S</em><sub><em>i</em></sub></span></li><li><span class="math inline"><em>S</em><sub><em>i</em></sub> ∩ <em>S</em><sub><em>j</em></sub> = ⌀</span>，<span class="math inline"><em>i</em> ≠ <em>j</em></span></li></ul><p>第一个条件说明 <span class="math inline">{<em>S</em><sub><em>i</em></sub>}</span> 这些子集<strong>无遗漏地包含</strong> 了 <span class="math inline"><em>S</em></span>的全部元素，第二个条件说明两个不同的子集无公共元素，从而 <span class="math inline"><em>S</em></span> 的元素属于且仅属于一个子集</p><ul><li>这表明，<span class="math inline"><em>S</em></span>的一个分类必须满足 <strong>不漏不重</strong> 的原则</li></ul><h3 id="分类与等价关系的关系">分类与等价关系的关系</h3><ul><li>集合 <span class="math inline"><em>S</em></span>的任何一个等价关系都确定了 <span class="math inline"><em>S</em></span>的一种分类，且其中每一个类都是集合 <span class="math inline"><em>S</em></span> 的一个等价类。</li><li>反之，集合 <span class="math inline"><em>S</em></span>的任何一种分类也都给出了集合 <span class="math inline"><em>S</em></span>的一个等价关系，且相应的等价类就是原分类中的那些类。</li><li>也就是说，一个集合的分类可以通过等价关系来描述；另一方面，等价关系也可以用集合的分类来表示</li></ul><h3 id="等价关系数目">等价关系数目</h3><p>如果用 <span class="math inline"><em>B</em>(<em>n</em>)</span>表示一个具有 <span class="math inline"><em>n</em></span>个元素的集合上的不同等价关系的个数，则有下列的递推公式：</p><p><span class="math display">$$ B(n+1)=\sum_{k=0}^{n}\mathrm{C}_{n}^{k} B(k),\quad n \geqslant 1$$</span></p><p>其中 <span class="math inline">C<sub><em>n</em></sub><sup><em>k</em></sup></span>为二项式系数，并规定 <span class="math inline"><em>B</em>(0) = 1, <em>B</em>(1) = 1</span></p><p>怎么理解：这个递推公式的含义是，划分具有 <span class="math inline"><em>n</em> + 1</span> 个元素的集合时，考虑第 <span class="math inline"><em>n</em> + 1</span> 个元素，若其自成一类，则剩余<span class="math inline"><em>n</em></span> 个元素的划分方式就是 <span class="math inline"><em>B</em>(<em>n</em>)</span>；若其从剩余 <span class="math inline"><em>n</em></span> 个元素中选出 <span class="math inline">1</span> 个元素与之同类，则有 <span class="math inline">C<sub><em>n</em></sub><sup>1</sup></span>种选择方式，剩余 <span class="math inline"><em>n</em> − 1</span>个元素的划分方式就是 <span class="math inline"><em>B</em>(<em>n</em> − 1)</span>，共有 <span class="math inline">C<sub><em>n</em></sub><sup>1</sup><em>B</em>(<em>n</em> − 1)</span>种划分方式；以此类推，若其从剩余 <span class="math inline"><em>n</em></span> 个元素中选出 <span class="math inline"><em>k</em></span> 个元素与之同类，则有 <span class="math inline">C<sub><em>n</em></sub><sup><em>k</em></sup><em>B</em>(<em>k</em>)</span>种划分方式。所有这些情况加起来就是 <span class="math inline"><em>B</em>(<em>n</em> + 1)</span></p><h2 id="群的概念">群的概念</h2><h3 id="代数运算">代数运算</h3><p>设 <span class="math inline"><em>A</em></span> 是一个非空集合，若对<span class="math inline"><em>A</em></span> 中任意两个元素 <span class="math inline"><em>a</em>, <em>b</em></span>，通过某个法则“<span class="math inline">⋅</span>”，有 <span class="math inline"><em>A</em></span> 中唯一确定的元素 <span class="math inline"><em>c</em></span> 与之对应，则称法则“<span class="math inline">⋅</span>”为集合 <span class="math inline"><em>A</em></span> 上的一个<strong>代数运算</strong>。元素 <span class="math inline"><em>c</em></span> 是 <span class="math inline"><em>a</em>, <em>b</em></span> 通过运算“<span class="math inline">⋅</span>” 作用的结果，将此结果记为 <span class="math inline"><em>a</em> ⋅ <em>b</em> = <em>c</em></span></p><p>换句话说代数运算满足封闭性和唯一性：</p><ul><li><span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>A</em></span>，<span class="math inline"><em>a</em> ⋅ <em>b</em> ∈ <em>A</em></span></li><li>若 <span class="math inline"><em>a</em><sub>1</sub> ⋅ <em>b</em><sub>1</sub> = <em>c</em><sub>1</sub></span>，<span class="math inline"><em>a</em><sub>2</sub> ⋅ <em>b</em><sub>2</sub> = <em>c</em><sub>2</sub></span>，<span class="math inline"><em>a</em><sub>1</sub> = <em>a</em><sub>2</sub></span>，<span class="math inline"><em>b</em><sub>1</sub> = <em>b</em><sub>2</sub></span>，则必有<span class="math inline"><em>c</em><sub>1</sub> = <em>c</em><sub>2</sub></span></li></ul><h3 id="群的定义">群的定义</h3><p>设 <span class="math inline"><em>G</em></span> 是一个非空集合，“<span class="math inline">⋅</span>”是 <span class="math inline"><em>G</em></span> 上的一个代数运算，即</p><ul><li>(G0) 对所有的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em> ⋅ <em>b</em> ∈ <em>G</em></span>。</li></ul><p>如果 <span class="math inline"><em>G</em></span> 的运算还满足</p><ul><li>(G1) 结合律，即对所有的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>G</em></span>，有<span class="math inline">(<em>a</em> ⋅ <em>b</em>) ⋅ <em>c</em> = <em>a</em> ⋅ (<em>b</em> ⋅ <em>c</em>)</span></li><li>(G2) <span class="math inline"><em>G</em></span> 中有元素 <span class="math inline"><em>e</em></span>，使对每个 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>e</em> ⋅ <em>a</em> = <em>a</em> ⋅ <em>e</em> = <em>a</em></span></li><li>(G3) 对 <span class="math inline"><em>G</em></span> 中每个元素 <span class="math inline"><em>a</em></span>，存在元素 <span class="math inline"><em>b</em> ∈ <em>G</em></span>，使 <span class="math inline"><em>a</em> ⋅ <em>b</em> = <em>b</em> ⋅ <em>a</em> = <em>e</em></span></li></ul><p>则称 <span class="math inline"><em>G</em></span> 关于运算“<span class="math inline">⋅</span>”构成一个<strong>群</strong> ，记作 <span class="math inline">(<em>G</em>, ⋅)</span>。在不致引起混淆的情况下，也称<span class="math inline"><em>G</em></span> 为群。</p><ul><li><p>(G2) 中的元素 <span class="math inline"><em>e</em></span> 称为群<span class="math inline"><em>G</em></span> 的<strong>单位元</strong>或恒等元；</p></li><li><p>(G3) 中的元素 <span class="math inline"><em>b</em></span> 称为<span class="math inline"><em>a</em></span>的<strong>逆元</strong></p></li><li><p>群 <span class="math inline"><em>G</em></span> 的单位元 <span class="math inline"><em>e</em></span>和每个元素的逆元都是唯一的</p></li><li><p><span class="math inline"><em>G</em></span> 中元素 <span class="math inline"><em>a</em></span> 的唯一的逆元通常记作 <span class="math inline"><em>a</em><sup>−1</sup></span></p></li><li><p>如果群 <span class="math inline"><em>G</em></span>的运算还满足交换律，即对任意的 <span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em> ⋅ <em>b</em> = <em>b</em> ⋅ <em>a</em></span>，则称<span class="math inline"><em>G</em></span> 是一个<strong>交换群</strong> 或 <strong>阿贝尔群</strong></p></li><li><p>群 <span class="math inline"><em>G</em></span> 中元素的个数称为群<span class="math inline"><em>G</em></span> 的 <strong>阶</strong>，记为 <span class="math inline">|<em>G</em>|</span>。如果 <span class="math inline">|<em>G</em>|</span> 是有限数，则称 <span class="math inline"><em>G</em></span> 为 <strong>有限群</strong>，否则称 <span class="math inline"><em>G</em></span> 为<strong>无限群</strong></p></li><li><p>当群 <span class="math inline"><em>G</em></span>的运算用加号“+”表示时，通常将 <span class="math inline"><em>G</em></span> 的单位元记作 <span class="math inline">0</span>，并称 <span class="math inline">0</span> 为<span class="math inline"><em>G</em></span> 的 <strong>零元</strong>；将 <span class="math inline"><em>a</em> ∈ <em>G</em></span> 的逆元记作<span class="math inline">−<em>a</em></span>，并称 <span class="math inline">−<em>a</em></span> 为 <span class="math inline"><em>a</em></span> 的 <strong>负元</strong></p></li><li><p>习惯上，只有当群为交换群时，才用“+”来表示群的运算，并称这个运算为加法，把运算的结果叫做和，同时称这样的群为<strong>加群</strong></p></li><li><p>相应地，将不是加群的群称为 <strong>乘群</strong>，并把乘群的运算叫做乘法，运算的结果叫做积。在运算过程中，乘群的运算符号通常省略不写</p></li><li><p>今后，如不作特别声明，<strong>总假定群的运算是乘法</strong></p></li></ul><h3 id="群表">群表</h3><p>形如下表的表通常称为群的 <strong>乘法表</strong> ，也称<strong>群表</strong> 或<strong>凯莱表</strong>。人们常用群表来表示有限群的运算</p><table><thead><tr><th><span class="math inline">∘</span></th><th><span class="math inline"><em>e</em></span></th><th><span class="math inline">⋯</span></th><th><span class="math inline"><em>b</em></span></th><th><span class="math inline">⋯</span></th></tr></thead><tbody><tr><td><span class="math inline"><em>e</em></span></td><td><span class="math inline"><em>e</em></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><em>b</em></span></td><td><span class="math inline">⋯</span></td></tr><tr><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋱</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋱</span></td></tr><tr><td><span class="math inline"><em>a</em></span></td><td><span class="math inline"><em>a</em></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><em>a</em> ∘ <em>b</em></span></td><td><span class="math inline">⋯</span></td></tr></tbody></table><p>在一个群表中，</p><ul><li>表的左上角列出了群的运算符号（有时省略）</li><li>表的最上面一行则依次列出群的所有元素（通常单位元列在最前面）</li><li>表的最左列按同样的次序列出群的所有元素</li><li>表中的其余部分则是最左列的元素和最上面一行的元素的乘积</li><li>注意，在乘积 <span class="math inline"><em>a</em> ∘ <em>b</em></span> 中，左边的因子 <span class="math inline"><em>a</em></span> 是左列上的元素，右边的因子 <span class="math inline"><em>b</em></span> 是最上面一行的元素</li><li>由群表很容易确定一个元素的逆元素</li><li>如果一个群的群表是对称的，则可以肯定，这个群一定是交换群</li></ul><h3 id="群的性质">群的性质</h3><p>设 <span class="math inline"><em>G</em></span> 为群，则有</p><ul><li>群 <span class="math inline"><em>G</em></span> 的单位元是唯一的</li><li>群 <span class="math inline"><em>G</em></span>的每个元素的逆元是唯一的</li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline">(<em>a</em><sup>−1</sup>)<sup>−1</sup> = <em>a</em></span></li><li>对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，有 <span class="math inline">(<em>a</em><em>b</em>)<sup>−1</sup> = <em>b</em><sup>−1</sup><em>a</em><sup>−1</sup></span></li><li>在群中消去律成立，即设 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>G</em></span>，如果<span class="math inline"><em>a</em><em>b</em> = <em>a</em><em>c</em></span>，或<span class="math inline"><em>b</em><em>a</em> = <em>c</em><em>a</em></span>，则<span class="math inline"><em>b</em> = <em>c</em></span></li></ul><p>设 <span class="math inline"><em>G</em></span> 是群，那么对任意的<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，方程</p><p><span class="math display"><em>a</em><em>x</em> = <em>b</em>  及  <em>y</em><em>a</em> = <em>b</em></span></p><p>在 <span class="math inline"><em>G</em></span> 中都有唯一解</p><h3 id="方幂">方幂</h3><p>群的定义中的结合律表明，群中三个元素 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em></span>的乘积与运算的顺序无关，因此可以简单地写成：<span class="math inline"><em>a</em><em>b</em><em>c</em></span>。进一步可知，在群<span class="math inline"><em>G</em></span> 中，任意 <span class="math inline"><em>k</em></span> 个元素 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>k</em></sub></span>的乘积与运算的顺序无关，因此可以写成 <span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>2</sub>⋯<em>a</em><sub><em>k</em></sub></span>。据此，可以定义群的元素的<strong>方幂</strong>：</p><h4 id="乘群">乘群</h4><p>对任意的正整数 <span class="math inline"><em>n</em></span>，定义<span class="math display">$$a^{n}=\underbrace{a \cdot a \cdots a}_{n \text{个} a}$$</span></p><p>再约定 <span class="math display">$$\begin{aligned}a^{0} &amp; =e,\\a^{-n} &amp; =\left(a^{-1}\right)^{n} \quad(n \text{为正整数}),\end{aligned}$$</span></p><p>则 <span class="math inline"><em>a</em><sup><em>n</em></sup></span>对任意整数 <span class="math inline"><em>n</em></span>都有意义，并且不难证明，对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，<span class="math inline"><em>m</em>, <em>n</em> ∈ <strong>Z</strong></span>，有下列的指数法则：</p><ul><li><span class="math inline"><em>a</em><sup><em>n</em></sup> ⋅ <em>a</em><sup><em>m</em></sup> = <em>a</em><sup><em>n</em> + <em>m</em></sup></span></li><li><span class="math inline">(<em>a</em><sup><em>n</em></sup>)<sup><em>m</em></sup> = <em>a</em><sup><em>n</em><em>m</em></sup></span></li><li>如果 <span class="math inline"><em>G</em></span> 是交换群，则 <span class="math inline">(<em>a</em><em>b</em>)<sup><em>n</em></sup> = <em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span></li></ul><h4 id="加群">加群</h4><p>当 <span class="math inline"><em>G</em></span>是加群时，元素的方幂则应改写为倍数</p><p><span class="math display">$$\begin{aligned}n a=\underbrace{a+a+\cdots+a}_{n \text{个} a}\\0 a=0,\\(-n) a=n(-a)\end{aligned}$$</span></p><p>相应地，指数法则变为倍数法则，</p><ul><li><span class="math inline"><em>n</em><em>a</em> + <em>m</em><em>a</em> = (<em>n</em> + <em>m</em>)<em>a</em></span></li><li><span class="math inline"><em>m</em>(<em>n</em><em>a</em>) = (<em>m</em><em>n</em>)<em>a</em></span></li><li><span class="math inline"><em>n</em>(<em>a</em> + <em>b</em>) = <em>n</em><em>a</em> + <em>n</em><em>b</em></span></li></ul><p>因为加群是交换群，所以第三条总是成立的</p><h3 id="群的判定">群的判定</h3><ul><li><p>设 <span class="math inline"><em>G</em></span>是一个具有代数运算的非空集合，则 <span class="math inline"><em>G</em></span>关于所给的运算构成群的<strong>充分必要条件</strong> 是</p><ul><li><span class="math inline"><em>G</em></span> 的运算满足结合律</li><li><span class="math inline"><em>G</em></span> 中有一个元素 <span class="math inline"><em>e</em></span>（称为 <span class="math inline"><em>G</em></span> 的左单位元），使对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>e</em><em>a</em> = <em>a</em></span></li><li>对 <span class="math inline"><em>G</em></span> 的每一个元素 <span class="math inline"><em>a</em></span>，存在 <span class="math inline"><em>a</em><sup>′</sup> ∈ <em>G</em></span>（称为<span class="math inline"><em>a</em></span> 的左逆元），使 <span class="math inline"><em>a</em><sup>′</sup><em>a</em> = <em>e</em></span>。这里<span class="math inline"><em>e</em></span> 是 <span class="math inline"><em>G</em></span> 的左单位元</li></ul><p>换句话说，一个具有乘法运算的非空集合 <span class="math inline"><em>G</em></span>，只要满足结合律，有左单位元，每个元素有左逆元，就构成一个群。同理可证，一个具有乘法运算的非空集合 <span class="math inline"><em>G</em></span>，如果满足结合律，有右单位元，且<span class="math inline"><em>G</em></span> 中每个元素有右逆元，则 <span class="math inline"><em>G</em></span> 也构成群</p></li><li><p>设 <span class="math inline"><em>G</em></span>是一个具有乘法运算且满足结合律的非空集合，则 <span class="math inline"><em>G</em></span> 构成群的<strong>充分必要条件</strong> 是对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，方程<span class="math display"><em>a</em><em>x</em> = <em>b</em>  与  <em>y</em><em>a</em> = <em>b</em></span></p><p>在 <span class="math inline"><em>G</em></span> 中都有解</p></li><li><p>设 <span class="math inline"><em>G</em></span>是一个具有乘法运算的非空 <strong>有限</strong> 集合，如果 <span class="math inline"><em>G</em></span> 满足结合律，且两个消去律成立，则<span class="math inline"><em>G</em></span> 构成群</p><ul><li>要注意的是，如果没有有限的条件，一个具有代数运算的集合，仅仅满足结合律和两个消去律，并不一定构成群</li></ul></li></ul><h3 id="常用例子">常用例子</h3><ul><li>整数集 <span class="math inline"><strong>Z</strong></span>关于数的加法构成群，这个群称为整数加群</li><li>全体非零有理数的集合 <span class="math inline"><strong>Q</strong><sup>*</sup></span>关于数的乘法构成交换群</li><li>全体非零实数的集合 <span class="math inline"><strong>R</strong><sup>*</sup></span>关于数的乘法也构成交换群</li><li>全体非零复数的集合 <span class="math inline"><strong>C</strong><sup>*</sup></span>关于数的乘法也构成交换群</li><li>全体 <span class="math inline"><em>n</em></span> 次单位根组成的集合<span class="math display">$$  \begin{aligned} U_{n}  &amp; =\left\{x \in \mathbf{C} \mid x^{n}=1\right\} \\  &amp; =\left\{\left.\cos \frac{2 k \pi}{n}+i \sin \frac{2 k \pi}{n}\right\rvert\,k=0,1,2,\cdots,n-1\right\}  \end{aligned}  $$</span> 关于数的乘法构成一个 <span class="math inline"><em>n</em></span> 阶交换群，通常称这个群为 <strong>n次单位根群</strong></li><li>设 <span class="math inline"><em>m</em></span> 是大于 <span class="math inline">1</span> 的正整数，记 <span class="math display">$$  \mathbf{Z}_{m}=\{\overline{0},\overline{1},\overline{2},\cdots,\overline{m-1}\}  $$</span> 则 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>关于剩余类的加法构成加群，这个群称为 <span class="math inline"><strong>Z</strong></span> 的模 <span class="math inline"><em>m</em></span> 剩余类加群</li><li>设 <span class="math inline"><em>m</em></span> 是大于 <span class="math inline">1</span> 的正整数，记 <span class="math display"><em>U</em>(<em>m</em>) = {<em>ā</em> ∈ <strong>Z</strong><sub><em>m</em></sub> ∣ (<em>a</em>, <em>m</em>) = 1}</span>则 <span class="math inline"><em>U</em>(<em>m</em>)</span>关于剩余类的乘法构成群，群 <span class="math inline">(<em>U</em>(<em>m</em>), ⋅)</span> 称为 <span class="math inline"><strong>Z</strong></span> 的模 <span class="math inline"><em>m</em></span>单位群，显然这是一个交换群，不一定是循环群。当 <span class="math inline"><em>p</em></span> 为素数时，<span class="math inline"><em>U</em>(<em>p</em>)</span> 常记作 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>，易知<span class="math display">$$  \mathbf{Z}_{p}^{*}=\{\overline{1},\overline{2},\cdots,\overline{p-1}\}  $$</span> 这是一个循环群，<span class="math inline"><em>U</em>(<em>m</em>)</span> 的阶等于欧拉函数 <span class="math inline"><em>ϕ</em>(<em>m</em>)</span></li></ul><h2 id="子群">子群</h2><h3 id="子群的定义">子群的定义</h3><p>设 <span class="math inline"><em>G</em></span> 是一个群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的一个非空子集。如果 <span class="math inline"><em>H</em></span> 关于 <span class="math inline"><em>G</em></span> 的运算也构成群，则称 <span class="math inline"><em>H</em></span> 为 <span class="math inline"><em>G</em></span> 的一个<strong>子群</strong> ，记作<span class="math inline"><em>H</em> &lt; <em>G</em></span></p><ul><li><p>对任意群 <span class="math inline"><em>G</em></span>，<span class="math inline"><em>G</em></span> 本身以及只含单位元 <span class="math inline"><em>e</em></span> 的子集 <span class="math inline"><em>H</em> = {<em>e</em>}</span> 是 <span class="math inline"><em>G</em></span> 的子群，这两个子群称为 <span class="math inline"><em>G</em></span> 的 <strong>平凡子群</strong> 。群<span class="math inline"><em>G</em></span> 的其他子群称为 <span class="math inline"><em>G</em></span> 的<strong>非平凡子群</strong></p></li><li><p>群 <span class="math inline"><em>G</em></span>的不等于它自身的子群称为 <span class="math inline"><em>G</em></span> 的<strong>真子群</strong></p></li><li><p>设 <span class="math inline"><em>m</em></span> 是一个整数，令<span class="math display"><em>H</em> = {<em>m</em><em>z</em> ∣ <em>z</em> ∈ <strong>Z</strong>}</span></p><p>则 <span class="math inline"><em>H</em></span> 为整数加群 <span class="math inline"><strong>Z</strong></span> 的子群。这个群称为由 <span class="math inline"><em>m</em></span> 所 <strong>生成的子群</strong>，常记作 <span class="math inline"><em>m</em><strong>Z</strong></span>或 <span class="math inline">⟨<em>m</em>⟩</span></p></li></ul><h3 id="子群的判定">子群的判定</h3><ul><li>由于群 <span class="math inline"><em>G</em></span>的运算满足结合律，所以结合律在 <span class="math inline"><em>G</em></span> 的任何关于 <span class="math inline"><em>G</em></span> 的运算封闭的非空子集 <span class="math inline"><em>H</em></span>上都成立。于是，由群的定义知，如果群 <span class="math inline"><em>G</em></span> 的非空子集 <span class="math inline"><em>H</em></span> 满足下列条件，则 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的子群：<ul><li><span class="math inline"><em>H</em></span> 在群的运算下封闭</li><li><span class="math inline"><em>H</em></span> 有单位元</li><li><span class="math inline"><em>H</em></span>包含它的每个元素的逆元</li></ul></li><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的 <strong>非空子集</strong> ，则<span class="math inline"><em>H</em></span> 成为群 <span class="math inline"><em>G</em></span> 的子群的<strong>充分必要条件</strong> 是<ul><li>对任意 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>H</em></span>，有 <span class="math inline"><em>a</em><em>b</em> ∈ <em>H</em></span></li><li>对任意 <span class="math inline"><em>a</em> ∈ <em>H</em></span>，有<span class="math inline"><em>a</em><sup>−1</sup> ∈ <em>H</em></span></li></ul></li><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的 <strong>非空子集</strong> ，则<span class="math inline"><em>H</em></span> 成为 <span class="math inline"><em>G</em></span> 的子群的<strong>充分必要条件</strong> 是<ul><li>对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>H</em></span>，有 <span class="math inline"><em>a</em><em>b</em><sup>−1</sup> ∈ <em>H</em></span></li></ul></li></ul><h3 id="子群的性质">子群的性质</h3><ul><li><p>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，则</p><ul><li>群 <span class="math inline"><em>G</em></span> 的单位元 <span class="math inline"><em>e</em></span> 是 <span class="math inline"><em>H</em></span> 的单位元；</li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>H</em></span>，<span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>G</em></span> 中的逆元 <span class="math inline"><em>a</em><sup>−1</sup></span> 就是 <span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>H</em></span> 中的逆元</li></ul></li><li><p>设 <span class="math inline"><em>G</em></span> 为群，记 <span class="math display"><em>C</em>(<em>G</em>) = {<em>g</em> ∈ <em>G</em> ∣ <em>g</em><em>x</em> = <em>x</em><em>g</em>, ∀<em>x</em> ∈ <em>G</em>}</span></p><p>则 <span class="math inline"><em>C</em>(<em>G</em>)</span> 是 <span class="math inline"><em>G</em></span> 的子群。称 <span class="math inline"><em>C</em>(<em>G</em>)</span> 为 <span class="math inline"><em>G</em></span> 的<strong>中心</strong>。</p></li><li><p>设 <span class="math inline"><em>a</em></span> 是群 <span class="math inline"><em>G</em></span> 的元素，定义 <span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>G</em></span> 中的 <strong>中心化子</strong> 为<span class="math display"><em>C</em>(<em>a</em>) = {<em>g</em> ∈ <em>G</em> ∣ <em>g</em><em>a</em> = <em>a</em><em>g</em>}</span></p><p>则 <span class="math inline"><em>C</em>(<em>a</em>)</span> 是 <span class="math inline"><em>G</em></span> 的子群，且满足 <span class="math display"><em>C</em>(<em>G</em>) = ⋂<sub><em>a</em> ∈ <em>G</em></sub><em>C</em>(<em>a</em>)</span></p></li><li><p>群 <span class="math inline"><em>G</em></span> 的任意两个子群的<strong>交</strong> 集 <strong>一定</strong> 是 <span class="math inline"><em>G</em></span> 的子群</p></li><li><p>群 <span class="math inline"><em>G</em></span> 的任意两个子群的<strong>并</strong> 集 <strong>不一定</strong> 是 <span class="math inline"><em>G</em></span> 的子群</p></li></ul><h3 id="生成子群">生成子群</h3><h4 id="生成子群的定义">生成子群的定义</h4><p>设 <span class="math inline"><em>S</em></span> 是群 <span class="math inline"><em>G</em></span> 的一个非空子集，令 <span class="math inline"><em>M</em></span> 表示 <span class="math inline"><em>G</em></span> 中所有包含 <span class="math inline"><em>S</em></span> 的子群所组成的集合，即 <span class="math display"><em>M</em> = {<em>H</em> &lt; <em>G</em> ∣ <em>S</em> ⊆ <em>H</em>}</span></p><p>本身显然包含 <span class="math inline"><em>S</em></span>，所以 <span class="math inline"><em>G</em> ∈ <em>M</em></span>，从而 <span class="math inline"><em>M</em></span> 非空。令 <span class="math display"><em>K</em> = ⋂<sub><em>H</em> ∈ <em>M</em></sub><em>H</em></span></p><p>则 <span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，称 <span class="math inline"><em>K</em></span> 为群 <span class="math inline"><em>G</em></span> 的由子集 <span class="math inline"><em>S</em></span>所生成的子群，简称<strong>生成子群</strong> ，记作 <span class="math inline">⟨<em>S</em>⟩</span>，即 <span class="math display">⟨<em>S</em>⟩ = ⋂<sub><em>S</em> ⊆ <em>H</em> &lt; <em>G</em></sub><em>H</em></span></p><p>子集 <span class="math inline"><em>S</em></span> 称为 <span class="math inline">⟨<em>S</em>⟩</span>的<strong>生成元组</strong></p><p>如果 <span class="math inline"><em>S</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>r</em></sub>}</span>为有限集，则记</p><p><span class="math display">⟨<em>S</em>⟩ = ⟨<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>r</em></sub>⟩</span></p><h4 id="生成子群的性质">生成子群的性质</h4><p>设 <span class="math inline"><em>S</em></span> 是群 <span class="math inline"><em>G</em></span> 的非空子集，则</p><ul><li><span class="math inline">⟨<em>S</em>⟩</span> 是 <span class="math inline"><em>G</em></span> 的包含 <span class="math inline"><em>S</em></span> 的最小子群</li><li><span class="math inline">⟨<em>S</em>⟩ = {<em>a</em><sub>1</sub><sup><em>l</em><sub>1</sub></sup><em>a</em><sub>2</sub><sup><em>l</em><sub>2</sub></sup>⋯<em>a</em><sub><em>k</em></sub><sup><em>l</em><sub><em>k</em></sub></sup> ∣ <em>a</em><sub><em>i</em></sub> ∈ <em>S</em>, <em>l</em><sub><em>i</em></sub> = ±1, <em>k</em> ∈ <strong>N</strong>}</span></li></ul><p><strong>特别注意</strong> ：上式中的 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>k</em></sub></span>可以取重复的值。若我们用不重复的 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>k</em></sub></span>来表示，那么这个乘法式子可能是无限长（因为不一定有交换律），不太好表示了。</p><h4 id="特例">特例</h4><ul><li><p>当 <span class="math inline"><em>S</em></span> 只包含群 <span class="math inline"><em>G</em></span> 的一个元素 <span class="math inline"><em>a</em></span> 时，由于 <span class="math display">$$  a^{l_{1}} a^{l_{2}} \cdots a^{l_{k}}=a^{\sum_{i=1}^{k} l_{i}}  $$</span> 所以 <span class="math display">⟨<em>a</em>⟩ = {<em>a</em><sup><em>r</em></sup> ∣ <em>r</em> ∈ <strong>Z</strong>}</span></p><p>这种由一个元素 <span class="math inline"><em>a</em></span>生成的子群称为由 <span class="math inline"><em>a</em></span> 生成的<strong>循环群</strong></p></li><li><p>当 <span class="math inline"><em>S</em></span> 只包含群 <span class="math inline"><em>G</em></span> 的两个元素 <span class="math inline"><em>a</em>, <em>b</em></span>，且 <span class="math inline"><em>a</em><em>b</em> = <em>b</em><em>a</em></span>，则<span class="math display">⟨<em>a</em>, <em>b</em>⟩ = {<em>a</em><sup><em>m</em></sup><em>b</em><sup><em>n</em></sup> ∣ <em>m</em>, <em>n</em> ∈ <strong>Z</strong>}</span></p></li></ul><h2 id="群的同构">群的同构</h2><h3 id="同构的定义">同构的定义</h3><p>设 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 是两个群，<span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的一一对应，使 <span class="math display"><em>ϕ</em>(<em>a</em> ⋅ <em>b</em>) = <em>ϕ</em>(<em>a</em>) ⋅ <em>ϕ</em>(<em>b</em>),  ∀<em>a</em>, <em>b</em> ∈ <em>G</em>,</span></p><p>则称 <span class="math inline"><em>ϕ</em></span> 为群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的一个<strong>同构映射</strong> ，简称<strong>同构</strong> ，并称群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> <strong>同构</strong>，记作 <span class="math display"><em>ϕ</em>: <em>G</em> ≅ <em>G</em><sup>′</sup></span></p><ul><li>群 <span class="math inline"><em>G</em></span>到它自身的同构映射称为群 <span class="math inline"><em>G</em></span>的<strong>自同构</strong> ，恒等同构是自同构</li><li>同构映射一定是可逆变换（双射），且其逆映射也是同构映射</li><li>同构的群之间可以有不止一个同构映射</li><li>在群同构的定义中，虽然使用了同一个符号“ <span class="math inline">⋅</span> ”表示群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span>的运算，但事实上，<span class="math inline"><em>a</em> ⋅ <em>b</em></span> 与 <span class="math inline"><em>ϕ</em>(<em>a</em>) ⋅ <em>ϕ</em>(<em>b</em>)</span>分别是在群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span>中进行的运算，一般来说它们是不相同的</li></ul><h3 id="证明两个群同构的步骤">证明两个群同构的步骤</h3><ol type="1"><li>构造群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的映射</li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>单映射</strong> 。即对任意的 <span class="math inline"><em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明由<span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>ϕ</em>(<em>y</em>)</span>可推出 <span class="math inline"><em>x</em> = <em>y</em></span></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>满映射</strong> 。即对任意的 <span class="math inline"><em>x</em><sup>′</sup> ∈ <em>G</em><sup>′</sup></span>，证明存在<span class="math inline"><em>x</em> ∈ <em>G</em></span>，使 <span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>x</em><sup>′</sup></span></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong> 。即对任意的 <span class="math inline"><em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明<span class="math inline"><em>ϕ</em>(<em>x</em><em>y</em>) = <em>ϕ</em>(<em>x</em>)<em>ϕ</em>(<em>y</em>)</span></li></ol><h3 id="同构的性质">同构的性质</h3><ul><li>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的同构映射，<span class="math inline"><em>e</em></span> 与 <span class="math inline"><em>e</em><sup>′</sup></span> 分别是 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 的单位元，<span class="math inline"><em>a</em></span> 是 <span class="math inline"><em>G</em></span> 的任一元素，则<ul><li><span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span></li><li><span class="math inline"><em>ϕ</em>(<em>a</em><sup>−1</sup>) = (<em>ϕ</em>(<em>a</em>))<sup>−1</sup></span></li><li><span class="math inline"><em>ϕ</em></span> 是可逆映射，且 <span class="math inline"><em>ϕ</em></span> 的逆映射 <span class="math inline"><em>ϕ</em><sup>−1</sup></span> 是群 <span class="math inline"><em>G</em><sup>′</sup></span> 到群 <span class="math inline"><em>G</em></span> 的同构映射</li></ul></li><li>设群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 同构<ul><li>如果 <span class="math inline"><em>G</em></span> 是交换群（Abel群），则 <span class="math inline"><em>G</em><sup>′</sup></span>也是交换群</li><li>如果 <span class="math inline"><em>G</em></span> 是有限群，则 <span class="math inline"><em>G</em><sup>′</sup></span> 也是有限群，且 <span class="math inline">|<em>G</em>| = |<em>G</em><sup>′</sup>|</span></li></ul></li><li>群的同构是一个等价关系，即对群 <span class="math inline"><em>G</em>, <em>G</em><sup>′</sup>, <em>G</em><sup>′′</sup></span><ul><li>反身性：<span class="math inline"><em>G</em> ≅ <em>G</em></span></li><li>对称性：若 <span class="math inline"><em>G</em> ≅ <em>G</em><sup>′</sup></span>，则 <span class="math inline"><em>G</em><sup>′</sup> ≅ <em>G</em></span></li><li>传递性：若 <span class="math inline"><em>G</em> ≅ <em>G</em><sup>′</sup></span>，<span class="math inline"><em>G</em><sup>′</sup> ≅ <em>G</em><sup>′′</sup></span>，则<span class="math inline"><em>G</em> ≅ <em>G</em><sup>′′</sup></span></li><li><strong>注意</strong>：同构关系是等价关系，映射不是等价关系！</li></ul></li></ul><h3 id="变换群">变换群</h3><h4 id="变换群的定义">变换群的定义</h4><p>非空集合 <span class="math inline"><em>X</em></span>的全体可逆变换关于变换的合成所构成的群 <span class="math inline"><em>S</em><sub><em>x</em></sub></span> 称为集合<span class="math inline"><em>X</em></span> 的<strong>对称群</strong>，<span class="math inline"><em>S</em><sub><em>x</em></sub></span>的任一子群称为 <span class="math inline"><em>X</em></span>的一个<strong>变换群</strong>。</p><h4 id="凯莱定理">凯莱定理</h4><p><strong>每一个群都同构于一个变换群。</strong></p><p>证明凯莱定理，需要先构造一个变换群，如对于群 <span class="math inline"><em>G</em></span>，<span class="math inline"><em>a</em> ∈ <em>G</em></span>，定义变换 <span class="math inline"><em>ϕ</em><sub><em>a</em></sub></span> 为 <span class="math display"><em>ϕ</em><sub><em>a</em></sub>(<em>x</em>) = <em>a</em><em>x</em>  (<em>x</em> ∈ <em>G</em>)</span></p><p>则 <span class="math inline"><em>ϕ</em><sub><em>a</em></sub></span>是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em></span> 的一个变换。令 <span class="math display"><em>G</em><sub><em>l</em></sub> = {<em>ϕ</em><sub><em>a</em></sub> ∣ <em>a</em> ∈ <em>G</em>}</span></p><p>则可以证明 <span class="math inline"><em>G</em><sub><em>l</em></sub></span> 是对称群<span class="math inline"><em>S</em><sub><em>G</em></sub></span>的一个子群，即 <span class="math inline"><em>G</em><sub><em>l</em></sub></span> 是群 <span class="math inline"><em>G</em></span> 的一个变换群。又可以证明 <span class="math inline"><em>G</em><sub><em>l</em></sub> ≅ <em>G</em></span>，即群<span class="math inline"><em>G</em></span> 同构于它的变换群 <span class="math inline"><em>G</em><sub><em>l</em></sub></span></p><p>变换群 <span class="math inline"><em>G</em><sub><em>l</em></sub></span> 称为 群 <span class="math inline"><em>G</em></span> 的<strong>左正则表示</strong>，变换 <span class="math inline"><em>ϕ</em><sub><em>a</em></sub></span> 称为群 <span class="math inline"><em>G</em></span> 由元素 <span class="math inline"><em>a</em></span> 所定义的<strong>左平移</strong>。</p><h2 id="循环群">循环群</h2><h3 id="群的阶">群的阶</h3><h4 id="阶的定义">阶的定义</h4><p>设 <span class="math inline"><em>G</em></span> 是一个群，<span class="math inline"><em>e</em></span> 是 <span class="math inline"><em>G</em></span> 的单位元，<span class="math inline"><em>a</em> ∈ <em>G</em></span>。如果存在正整数 <span class="math inline"><em>r</em></span>，使 <span class="math inline"><em>a</em><sup><em>r</em></sup> = <em>e</em></span>，则称<span class="math inline"><em>a</em></span> 是 <strong>有限阶</strong>的，否则称 <span class="math inline"><em>a</em></span>是<strong>无限阶</strong> 的。使 <span class="math inline"><em>a</em><sup><em>r</em></sup> = <em>e</em></span><strong>的最小正整数</strong> <span class="math inline"><em>r</em></span> 称为元素 <span class="math inline"><em>a</em></span> 的<strong>阶</strong> ，记作 <span class="math inline">ord <em>a</em> = <em>r</em></span>。如果 <span class="math inline"><em>a</em></span> 是无限阶的，则记作 <span class="math inline">ord <em>a</em> = ∞</span>。</p><ul><li>在任何一个群中，单位元的阶总是 <span class="math inline">1</span></li><li>在整数加群 <span class="math inline"><strong>Z</strong></span>中，除零元 <span class="math inline">0</span>外，每个元素都是无限阶的</li></ul><h4 id="阶的性质">阶的性质</h4><ul><li><p>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>e</em></span> 为 <span class="math inline"><em>G</em></span> 的单位元</p><ul><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline">ord <em>a</em> = ord <em>a</em><sup>−1</sup></span></li><li>设 <span class="math inline">ord <em>a</em> = <em>n</em></span>，如果有 <span class="math inline"><em>m</em> ∈ <strong>Z</strong></span>，使 <span class="math inline"><em>a</em><sup><em>m</em></sup> = <em>e</em></span>，则<span class="math inline"><em>n</em> ∣ <em>m</em></span></li><li>设 <span class="math inline">ord <em>a</em> = <em>n</em></span>，则对任意的 <span class="math inline"><em>m</em> ∈ <strong>Z</strong></span>，<span class="math inline">$\operatorname{ord}a^{m}=\frac{n}{(n,m)}$</span></li><li>设 <span class="math inline">ord <em>a</em> = <em>n</em></span>，<span class="math inline">ord <em>b</em> = <em>m</em></span>，如果 <span class="math inline"><em>a</em><em>b</em> = <em>b</em><em>a</em></span>，且<span class="math inline">gcd (<em>n</em>, <em>m</em>) = 1</span>，则<span class="math inline">ord (<em>a</em><em>b</em>) = <em>m</em><em>n</em></span></li></ul><p>其中 <span class="math inline">(<em>n</em>, <em>m</em>)</span> 与<span class="math inline">gcd (<em>n</em>, <em>m</em>)</span> 表示 <span class="math inline"><em>n</em></span> 与 <span class="math inline"><em>m</em></span> 的最大公约数</p></li><li><p>设 <span class="math inline"><em>G</em></span>是一个有限群，<span class="math inline">|<em>G</em>| = <em>n</em></span>，则对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，<span class="math inline"><em>a</em></span> 是有限阶的，且 <span class="math inline">ord <em>a</em> ∣ |<em>G</em>|</span>，即有限群的任何一个元素的阶都是群阶数的因子。</p></li></ul><h3 id="循环群-1">循环群</h3><h4 id="循环群的定义">循环群的定义</h4><p>设 <span class="math inline"><em>G</em></span> 是群，如果存在 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，使得 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span>（a的生成子群），则称 <span class="math inline"><em>G</em></span> 为一个<strong>循环群</strong> ，并称 <span class="math inline"><em>a</em></span> 为 <span class="math inline"><em>G</em></span> 的一个 <strong>生成元</strong>。当 <span class="math inline"><em>G</em></span> 的元素个数无限时，称<span class="math inline"><em>G</em></span> 为<strong>无限循环群</strong> ；当 <span class="math inline"><em>G</em></span> 的元素个数为 <span class="math inline"><em>n</em></span> 时，称 <span class="math inline"><em>G</em></span> 为 <strong>n阶循环群</strong>。</p><ul><li>整数加群 <span class="math inline"><strong>Z</strong></span>是无限循环群</li><li>设 <span class="math inline"><em>m</em></span> 为正整数，则模 <span class="math inline"><em>m</em></span> 剩余类加群 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span> 是<span class="math inline"><em>m</em></span> 阶循环群</li><li><span class="math inline"><em>n</em></span> 次单位根群 <span class="math inline"><em>U</em><sub><em>n</em></sub></span> 是一个 <span class="math inline"><em>n</em></span> 阶循环群</li></ul><p>由循环群的定义可知：</p><ul><li><span class="math inline">⟨<em>a</em>⟩ = ⟨<em>a</em><sup>−1</sup>⟩</span></li><li>如果 <span class="math inline"><em>G</em></span> 是循环群，则 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩ ⇔ |<em>G</em>| = ord <em>a</em></span>，即<span class="math inline"><em>G</em></span> 的阶等于 <span class="math inline"><em>a</em></span> 的阶</li><li>如果 <span class="math inline"><em>G</em></span> 是无限循环群，则<span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>−1</sup>, <em>a</em><sup>2</sup>, <em>a</em><sup>−2</sup>, ⋯}</span>，且对<span class="math inline"><em>k</em>, <em>l</em> ∈ <strong>Z</strong></span>，有$a^{k} = a^{l} k = l $</li><li>如果 <span class="math inline"><em>G</em></span> 是 <span class="math inline"><em>n</em></span> 阶循环群，则 <span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>, ⋯, <em>a</em><sup><em>n</em> − 1</sup>}</span>，且对<span class="math inline"><em>k</em>, <em>l</em> ∈ <strong>Z</strong></span>，有<span class="math inline"><em>a</em><sup><em>k</em></sup> = <em>a</em><sup><em>l</em></sup> ⇔ <em>k</em> ≡ <em>l</em>(&nbsp;mod &nbsp;<em>n</em>)</span></li></ul><h4 id="循环群的性质">循环群的性质</h4><ul><li><p>设 <span class="math inline"><em>p</em></span> 为素数，则 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>是 <span class="math inline"><em>p</em> − 1</span> 阶循环群。对于循环群<span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>，如果<span class="math inline"><em>ā</em></span> 是 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>的生成元，则称数 <span class="math inline"><em>a</em></span> 是 <span class="math inline"><strong>Z</strong></span> 的一个<strong>模 p原根</strong></p></li><li><p>设 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span>为循环群，则</p><ul><li>如果 <span class="math inline">|<em>G</em>| = ∞</span>，则 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>a</em><sup>−1</sup></span> 是 <span class="math inline"><em>G</em></span> 的两个仅有的生成元</li><li>如果 <span class="math inline">|<em>G</em>| = <em>n</em></span>，则<span class="math inline"><em>G</em></span> 恰有 <span class="math inline"><em>ϕ</em>(<em>n</em>)</span> 个生成元，且 <span class="math inline"><em>a</em><sup><em>r</em></sup></span> 是 <span class="math inline"><em>G</em></span> 的生成元的充分必要条件是 <span class="math inline">(<em>n</em>, <em>r</em>) = 1</span>，其中，<span class="math inline"><em>ϕ</em>(<em>n</em>)</span> 是欧拉函数</li></ul></li><li><p>原根判定定理：设 <span class="math inline"><em>m</em> ≥ 3</span>，<span class="math inline">(<em>g</em>, <em>m</em>) = 1</span>，则 <span class="math inline"><em>g</em></span> 是模 <span class="math inline"><em>m</em></span> 的原根的充要条件是，对于 <span class="math inline"><em>φ</em>(<em>m</em>)</span> 的每个素因数 <span class="math inline"><em>p</em></span>，都有 <span class="math inline">$g^{\frac{\varphi(m)}{p}} \not \equiv 1(\bmodm)$</span></p></li><li><p>循环群的任一子群也是循环群</p></li><li><p>设 <span class="math inline">ord <em>a</em> = <em>n</em></span>，<span class="math inline"><em>r</em></span> 是任一整数。如果 <span class="math inline">(<em>n</em>, <em>r</em>) = <em>d</em></span>，则<span class="math display">⟨<em>a</em><sup><em>r</em></sup>⟩ = ⟨<em>a</em><sup><em>d</em></sup>⟩</span></p></li><li><p>设 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span>为循环群，</p><ul><li>如果 <span class="math inline">|<em>G</em>| = ∞</span>，则 <span class="math inline"><em>G</em></span> 的全部子群为<span class="math display">{⟨<em>a</em><sup><em>d</em></sup>⟩ ∣ <em>d</em> = 0, 1, 2, ⋯}</span></li><li>如果 <span class="math inline">|<em>G</em>| = <em>n</em></span>，则<span class="math inline"><em>G</em></span> 的全部子群为<span class="math display">{⟨<em>a</em><sup><em>d</em></sup>⟩ ∣ <em>d</em>为<em>n</em>的正因子}</span></li></ul></li></ul><h4 id="循环群的结构定理">循环群的结构定理</h4><p>设 <span class="math inline"><em>G</em></span> 为循环群</p><ul><li>如果 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span>是无限循环群，则 <span class="math inline"><em>G</em> ≅ (<strong>Z</strong>, +)</span></li><li>如果 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span> 是<span class="math inline"><em>n</em></span> 阶循环群，则 <span class="math inline"><em>G</em> ≅ (<strong>Z</strong><sub><em>n</em></sub>, +)</span></li></ul><h2 id="置换群与对称群">置换群与对称群</h2><p>前面提到非空集合的全体可逆变换关于映射的合成构成集合 <span class="math inline"><em>X</em></span> 的对称群 <span class="math inline"><em>S</em><sub><em>X</em></sub></span>，并且把 <span class="math inline"><em>S</em><sub><em>X</em></sub></span>的任一子群叫做 <span class="math inline"><em>X</em></span>的一个变换群。如果 <span class="math inline"><em>X</em></span> 是由<span class="math inline"><em>n</em></span>个元素组成的有限集合，则通常把的一个可逆变换叫做一个 <span class="math inline"><em>n</em></span> 阶置换，称 <span class="math inline"><em>S</em><sub><em>X</em></sub></span> 为 <strong>n次对称群</strong> ，并把 <span class="math inline"><em>S</em><sub><em>X</em></sub></span> 记作 <span class="math inline"><em>S</em><sub><em>n</em></sub></span>（因为集合<span class="math inline"><em>X</em></span>有哪些元素与群的特性无关），同时称 <span class="math inline"><em>S</em><sub><em>n</em></sub></span>的子群为<strong>置换群</strong> 。</p><ul><li>定理：<strong>每一个有限群都同构于一个置换群</strong></li></ul><h3 id="置换">置换</h3><p>由于集合 <span class="math inline"><em>X</em></span>的元素本身与我们所讨论的问题无关，所以可不妨记 <span class="math display"><em>X</em> = {1, 2, 3, ⋯, <em>n</em>}</span></p><p>设 <span class="math inline"><em>σ</em></span> 为 <span class="math inline"><em>X</em></span> 的任一置换，如果 <span class="math inline"><em>σ</em></span> 把 <span class="math inline">1</span> 映成 <span class="math inline"><em>k</em><sub>1</sub></span>，<span class="math inline">2</span> 映成 <span class="math inline"><em>k</em><sub>2</sub></span>，……，<span class="math inline"><em>n</em></span> 映成 <span class="math inline"><em>k</em><sub><em>n</em></sub></span>，则可以把这个置换记作<span class="math display">$$\sigma=\left(\begin{array}{ccccc}1 &amp; 2 &amp; 3 &amp; \cdots &amp; n \\k_{1} &amp; k_{2} &amp; k_{3} &amp; \cdots &amp; k_{n}\end{array}\right)$$</span></p><p>如果固定第一行元素的次序，则第二行就是 <span class="math inline">1, 2, ⋯, <em>n</em></span> 的一个排列，且<strong>每一个置换都唯一对应了一个这样的排列</strong> 。反之，每一个<span class="math inline"><em>n</em></span>阶排列也可按上式得到唯一的一个 <span class="math inline"><em>n</em></span> 阶置换 。由于 <span class="math inline"><em>n</em></span> 个数共有 <span class="math inline"><em>n</em>!</span> 个 <span class="math inline"><em>n</em></span> 阶排列，所以 <span class="math inline"><em>n</em></span> 个元素的集合共有 <span class="math inline"><em>n</em>!</span> 个 <span class="math inline"><em>n</em></span> 阶置换。换句话说，<span class="math inline"><em>n</em></span> 次对称群 <span class="math inline"><em>S</em><sub><em>n</em></sub></span> 的阶是 <span class="math inline"><em>n</em>!</span>，即 <span class="math inline">|<em>S</em><sub><em>n</em></sub>| = <em>n</em>!</span>。</p><h4 id="置换的合成">置换的合成</h4><p>置换的乘法习惯上总是按<strong>从右到左</strong>的顺序进行的。在本教材中，总是按从右到左的顺序计算置换的乘法。</p><p>两个置换 <span class="math inline"><em>σ</em>, <em>τ</em></span>的乘积 <span class="math inline"><em>σ</em> ⋅ <em>τ</em></span>是按通常映射合成的法则进行的，即 <span class="math display">(<em>σ</em> ⋅ <em>τ</em>)(<em>i</em>) = <em>σ</em>(<em>τ</em>(<em>i</em>)),  <em>i</em> = 1, 2, ⋯, <em>n</em></span></p><p>它是先用 <span class="math inline"><em>τ</em></span> 作用于 <span class="math inline"><em>i</em></span>，再用 <span class="math inline"><em>σ</em></span> 作用于 <span class="math inline"><em>τ</em>(<em>i</em>)</span></p><ul><li>当 <span class="math inline"><em>n</em> ≥ 3</span> 时，<span class="math inline"><em>S</em><sub><em>n</em></sub></span>都不是交换群</li></ul><h4 id="置换的性质">置换的性质</h4><p>设置换 <span class="math display">$$\tau=\left(\begin{array}{cccc}1 &amp; 2 &amp; \cdots &amp; n \\k_{1} &amp; k_{2} &amp; \cdots &amp; k_{n}\end{array}\right)$$</span></p><p>则对任一 <span class="math inline"><em>n</em></span> 阶置换 <span class="math inline"><em>σ</em></span>， <span class="math display">$$\sigma \tau \sigma^{-1}=\left(\begin{array}{cccc}\sigma(1) &amp; \sigma(2) &amp; \cdots &amp; \sigma(n) \\\sigma\left(k_{1}\right) &amp; \sigma\left(k_{2}\right) &amp; \cdots&amp; \sigma\left(k_{n}\right)\end{array}\right)$$</span></p><h3 id="轮换">轮换</h3><p>设 <span class="math inline"><em>σ</em></span> 是一个 <span class="math inline"><em>n</em></span> 阶置换，如果存在 <span class="math inline">1</span> 到 <span class="math inline"><em>n</em></span> 中的 <span class="math inline"><em>r</em></span> 个不同的数 <span class="math inline"><em>i</em><sub>1</sub>, <em>i</em><sub>2</sub>, ⋯, <em>i</em><sub><em>r</em></sub></span>，使<span class="math display"><em>σ</em>(<em>i</em><sub>1</sub>) = <em>i</em><sub>2</sub>, <em>σ</em>(<em>i</em><sub>2</sub>) = <em>i</em><sub>3</sub>, ⋯, <em>σ</em>(<em>i</em><sub><em>r</em> − 1</sub>) = <em>i</em><sub><em>r</em></sub>, <em>σ</em>(<em>i</em><sub><em>r</em></sub>) = <em>i</em><sub>1</sub></span></p><p>并且 <span class="math inline"><em>σ</em></span>保持其余的元素不变，则称 <span class="math inline"><em>σ</em></span>是一个长度为 <span class="math inline"><em>r</em></span> 的<strong>轮换</strong> ，简称 <span class="math inline"><em>r</em></span>轮换，记作 <span class="math display"><em>σ</em> = (<em>i</em><sub>1</sub><em>i</em><sub>2</sub>⋯<em>i</em><sub><em>r</em></sub>)</span></p><ul><li>2 轮换称为 <strong>对换</strong></li><li>1 轮换就是 <strong>恒等置换</strong>，并且显然有 <span class="math inline">(1) = (2) = ⋯ = (<em>n</em>)</span></li><li>轮换的表示一般不是唯一的 <span class="math inline">.</span>例如，置换 <span class="math display">$$  \sigma=\left(\begin{array}{ccccccc}  1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 \\\  2 &amp; 4 &amp; 3 &amp; 6 &amp; 5 &amp; 1 &amp; 7  \end{array}\right)  $$</span> 可分别表示为 <span class="math display">$$  \begin{aligned}  \sigma &amp; =\left(\begin{array}{llll} 1 &amp; 2 &amp; 4 &amp; 6\end{array}\right) \\  &amp; =\left(\begin{array}{llll} 2 &amp; 4 &amp; 6 &amp; 1\end{array}\right) \\  &amp; =\left(\begin{array}{llll} 4 &amp; 6 &amp; 1 &amp; 2\end{array}\right) \\  &amp; =\left(\begin{array}{llll} 6 &amp; 1 &amp; 2 &amp; 4\end{array}\right) \\  \end{aligned}  $$</span></li></ul><h4 id="轮换的性质">轮换的性质</h4><ul><li><p>设 <span class="math inline"><em>σ</em> = (<em>i</em><sub>1</sub><em>i</em><sub>2</sub>⋯<em>i</em><sub><em>r</em></sub>)</span>与 <span class="math inline"><em>τ</em> = (<em>j</em><sub>1</sub><em>j</em><sub>2</sub>⋯<em>j</em><sub><em>s</em></sub>)</span>是两个轮换，如果 <span class="math display"><em>i</em><sub><em>k</em></sub> ≠ <em>j</em><sub><em>l</em></sub>,  <em>k</em> = 1, 2, ⋯, <em>r</em>; <em>l</em> = 1, 2, ⋯, <em>s</em></span></p><p>则称 <span class="math inline"><em>σ</em></span> 与 <span class="math inline"><em>τ</em></span> 为两个 <strong>不相交</strong>的轮换</p><ul><li>任何两个不相交轮换的乘积是可以交换的</li><li>一个置换不一定就是轮换，但是每一个置换可表为一些不相交轮换的乘积</li><li>将一个置换分解为不相交轮换的乘积，如果不考虑因子的次序和乘积中 <span class="math inline">1</span> 轮换的个数，则这个分解式是唯一的</li></ul></li><li><p>对于轮换的乘积，容易证明下面一些有用的等式： <span class="math display">$$  \begin{array}{l}  (k\ l)(k\ a \cdots b)(l\ c \cdots d)=(k\ a \cdots b\ l\ c \cdots d) \\  (k\ l)(k\ a \cdots b\ l\ c \cdots d)=(k\ a \cdots b)(l\ c \cdots d)\\  (k\ c \cdots d)(k\ a \cdots b)=(k\ a \cdots b\ c \cdots d)\\  (k\ l\ c \cdots d)(k\ l\ a \cdots b)=(k\ c \cdots d)(l\ a \cdots b) \\  (l\ k\ c \cdots d)(k\ l\ a \cdots b)=(k)(l\ a \cdots b\ c \cdots d) \\  \end{array}  $$</span></p><ul><li>其中 <span class="math inline"><em>a</em>, ⋯, <em>b</em>, <em>c</em>, ⋯, <em>d</em>, <em>k</em>, <em>l</em></span>为互不相同的正整数</li><li>注意置换是从右到左</li></ul></li><li><p>如果 <span class="math inline"><em>σ</em></span> 是一个 <span class="math inline"><em>r</em></span> 轮换，则 <span class="math inline">ord <em>σ</em> = <em>r</em></span></p></li><li><p>如果 <span class="math inline"><em>σ</em></span>是一些不相交轮换的乘积 <span class="math display"><em>σ</em> = <em>σ</em><sub>1</sub><em>σ</em><sub>2</sub>⋯<em>σ</em><sub><em>s</em></sub></span></p><p>其中 <span class="math inline"><em>σ</em><sub><em>i</em></sub></span>是 <span class="math inline"><em>r</em><sub><em>i</em></sub></span>轮换，则 <span class="math inline">ord <em>σ</em> = [<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, ⋯, <em>r</em><sub><em>s</em></sub>]</span></p></li><li><p>每个置换都可表为对换的乘积</p></li><li><p>将一个置换表为对换的乘积，表法一般不唯一</p></li><li><p>将一个置换表为对换的乘积，所用对换个数的奇偶性是唯一的。可表成偶数个对换的乘积的置换叫<strong>偶置换</strong>，可表成奇数个对换的乘积的置换叫<strong>奇置换</strong></p><ul><li>任何两个偶（奇）置换之积是偶置换</li><li>一个偶置换与一个奇置换之积是奇置换</li><li>一个偶（奇）置换的逆置换仍是一个偶（奇）置换</li><li>当 <span class="math inline"><em>n</em> &gt; 1</span> 时，在全体<span class="math inline"><em>n</em></span> 阶置换中，奇置换与偶置换各有<span class="math inline">$\frac{n!}{2}$</span> 个</li><li>在 <span class="math inline"><em>S</em><sub><em>n</em></sub></span>中，全体偶置换构成 <span class="math inline"><em>S</em><sub><em>n</em></sub></span> 的子群，称为<strong>n 次交代群</strong> ，记作 <span class="math inline"><em>A</em><sub><em>n</em></sub></span></li></ul></li></ul><h2 id="子群的陪集">子群的陪集</h2><h3 id="子集的运算">子集的运算</h3><h4 id="乘积">乘积</h4><p>设 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 是群 <span class="math inline"><em>G</em></span> 的两个非空子集，称集合 <span class="math display"><em>A</em><em>B</em> = {<em>a</em><em>b</em> ∣ <em>a</em> ∈ <em>A</em>, <em>b</em> ∈ <em>B</em>}</span></p><p>为群的子集 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 的 <strong>乘积</strong> 。 如果<span class="math inline"><em>g</em></span> 为群 <span class="math inline"><em>G</em></span> 的一个元素，<span class="math inline"><em>A</em> = {<em>g</em>}</span>，则 <span class="math inline"><em>A</em><em>B</em></span> 与 <span class="math inline"><em>B</em><em>A</em></span> 分别简记为 <span class="math display"><em>g</em><em>B</em> = {<em>g</em><em>b</em> ∣ <em>b</em> ∈ <em>B</em>}  和  <em>B</em><em>g</em> = {<em>b</em><em>g</em> ∣ <em>b</em> ∈ <em>B</em>}</span></p><h4 id="和">和</h4><p>当 <span class="math inline"><em>G</em></span>为加群时，上述记号应相应地改为 <span class="math display">$$\begin{aligned}A+B &amp; =\{a+b \mid a \in A,b \in B\},\\g+A &amp; =\{g+a \mid a \in A\},\\A+g &amp; =\{a+g \mid a \in A\}\end{aligned}$$</span></p><p>并称 <span class="math inline"><em>A</em> + <em>B</em></span> 为<span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 的<strong>和</strong></p><h4 id="简单性质">简单性质</h4><ul><li>“和”有交换律 <span class="math display"><em>A</em> + <em>B</em> = <em>B</em> + <em>A</em>,  <em>g</em> + <em>A</em> = <em>A</em> + <em>g</em></span></li><li>当群 <span class="math inline"><em>G</em></span> 不是交换群时，<span class="math inline"><em>A</em><em>B</em></span> 与 <span class="math inline"><em>B</em><em>A</em></span> 一般是不相同的；即使<span class="math inline"><em>A</em><em>B</em> = <em>B</em><em>A</em></span>，也并不意味着对任意的<span class="math inline"><em>a</em> ∈ <em>A</em></span>，<span class="math inline"><em>b</em> ∈ <em>B</em></span>，一定有 <span class="math inline"><em>a</em><em>b</em> = <em>b</em><em>a</em></span>，<span class="math inline"><em>A</em><em>B</em> = <em>B</em><em>A</em></span>的意思是，对任意的 <span class="math inline"><em>a</em> ∈ <em>A</em>, <em>b</em> ∈ <em>B</em></span>，存在<span class="math inline"><em>a</em><sup>′</sup> ∈ <em>A</em>, <em>b</em><sup>′</sup> ∈ <em>B</em></span>，使<span class="math inline"><em>a</em><em>b</em> = <em>b</em><sup>′</sup><em>a</em><sup>′</sup></span></li><li>由 <span class="math inline"><em>A</em><em>B</em> = <em>A</em><em>C</em></span>，一般不能推出<span class="math inline"><em>B</em> = <em>C</em></span></li><li>设 <span class="math inline"><em>A</em>, <em>B</em>, <em>C</em></span> 是群 <span class="math inline"><em>G</em></span> 的非空子集，<span class="math inline"><em>g</em></span> 是群 <span class="math inline"><em>G</em></span> 的一个元素，则<ul><li><span class="math inline"><em>A</em>(<em>B</em><em>C</em>) = (<em>A</em><em>B</em>)<em>C</em></span></li><li>如果 <span class="math inline"><em>g</em><em>A</em> = <em>g</em><em>B</em></span>或 <span class="math inline"><em>A</em><em>g</em> = <em>B</em><em>g</em></span>，则<span class="math inline"><em>A</em> = <em>B</em></span></li><li>如果 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的子群，则 <span class="math inline"><em>H</em> ⋅ <em>H</em> = <em>H</em></span></li><li>如果 <span class="math inline"><em>A</em>, <em>B</em></span> 是群<span class="math inline"><em>G</em></span> 的两个子群，则 <span class="math inline"><em>A</em><em>B</em></span> 也是群 <span class="math inline"><em>G</em></span> 的子群的充分必要条件是 <span class="math inline"><em>A</em><em>B</em> = <em>B</em><em>A</em></span></li></ul></li></ul><h3 id="陪集">陪集</h3><h4 id="陪集的定义">陪集的定义</h4><p>设 <span class="math inline"><em>G</em></span> 是群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群。对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，群 <span class="math inline"><em>G</em></span> 的子集 <span class="math display"><em>a</em><em>H</em> = {<em>a</em><em>h</em> ∣ <em>h</em> ∈ <em>H</em>}  与<em>H</em><em>a</em> = {<em>h</em><em>a</em> ∣ <em>h</em> ∈ <em>H</em>}</span></p><p>分别称为 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的 <strong>左陪集</strong> 和<strong>右陪集</strong></p><ul><li><span class="math inline"><em>H</em></span> 的一个陪集<strong>一般</strong> 不是 <span class="math inline"><em>G</em></span>的子群</li><li><span class="math inline"><em>G</em></span> 的两个不同的元素<strong>可能</strong> 生成 <span class="math inline"><em>H</em></span>的同一个左陪集</li><li><span class="math inline"><em>H</em></span> 的一个左陪集 <span class="math inline"><em>a</em><em>H</em></span> <strong>一般</strong>不等于相应的右陪集 <span class="math inline"><em>H</em><em>a</em></span></li></ul><h4 id="陪集的性质">陪集的性质</h4><p>设 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的子群，<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，则</p><ul><li><span class="math inline"><em>a</em> ∈ <em>a</em><em>H</em></span></li><li><span class="math inline"><em>a</em><em>H</em> = <em>H</em></span>的充分必要条件是 <span class="math inline"><em>a</em> ∈ <em>H</em></span></li><li><span class="math inline"><em>a</em><em>H</em></span>为子群的充分必要条件是 <span class="math inline"><em>a</em> ∈ <em>H</em></span></li><li><span class="math inline"><em>a</em><em>H</em> = <em>b</em><em>H</em></span>的充分必要条件是 <span class="math inline"><em>a</em><sup>−1</sup><em>b</em> ∈ <em>H</em></span></li><li><span class="math inline"><em>a</em><em>H</em></span> 与 <span class="math inline"><em>b</em><em>H</em></span>或者完全相同，或者无公共元素</li><li><span class="math inline">|<em>a</em><em>H</em>| = |<em>b</em><em>H</em>|</span></li></ul><p>由此定理可以知道，群 <span class="math inline"><em>G</em></span>可表示成子群 <span class="math inline"><em>H</em></span>的一些互不相交的左陪集之并。因此，群 <span class="math inline"><em>G</em></span> 的子群 <span class="math inline"><em>H</em></span> 的全体左陪集的集合组成群 <span class="math inline"><em>G</em></span> 的一个分类，即 <span class="math display"><em>G</em> = ⋃<sub><em>g</em><sub><em>i</em></sub> ∈ <em>G</em></sub><em>g</em><sub><em>i</em></sub><em>H</em></span></p><p>其中 <span class="math inline"><em>g</em><sub><em>i</em></sub></span>取遍 <span class="math inline"><em>H</em></span>的不同陪集的代表元素。特别地，如果 <span class="math inline"><em>G</em></span> 为有限群，则 <span class="math display">$$|G|=\sum_{i=1}^{t}\left|g_{i} H\right|=\sum_{i=1}^{t}|H|=t|H|$$</span></p><p>其中 <span class="math inline"><em>t</em></span> 为 <span class="math inline"><em>H</em></span> 的不同左陪集的个数</p><h4 id="左陪集与右陪集">左陪集与右陪集</h4><p>相应的结论对右陪集也成立，特别地： <span class="math display"><em>H</em><em>a</em> = <em>H</em><em>b</em> ⇔ <em>b</em><em>a</em><sup>−1</sup> ∈ <em>H</em></span></p><p>用 <span class="math inline"><em>G</em>/<em>H</em></span> 与 <span class="math inline"><em>H</em> ∖ <em>G</em></span> 分别表示 <span class="math inline"><em>H</em></span>的全体左陪集和全体右陪集组成的集合，即 <span class="math display">$$\begin{aligned}G / H=\{g H \mid g \in G\} \\H \backslash G=\{H g \mid g \in G\}\end{aligned}$$</span></p><p>则两者间有下述关系 <span class="math display">$$\begin{aligned}\phi: \quad G / H &amp; \longrightarrow H \backslash G,\\a H &amp; \longmapsto H a^{-1}\end{aligned}$$</span></p><p>是 <span class="math inline"><em>G</em>/<em>H</em></span> 到 <span class="math inline"><em>H</em> ∖ <em>G</em></span>的<strong>一一对应</strong></p><h3 id="拉格朗日定理">拉格朗日定理</h3><ul><li><p>设 <span class="math inline"><em>G</em></span> 是群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群。称子群 <span class="math inline"><em>H</em></span> 在群 <span class="math inline"><em>G</em></span>中的左陪集或右陪集的个数（有限或无限）为 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的 <strong>指数</strong>，记作<span class="math inline">[<em>G</em> : <em>H</em>]</span></p></li><li><p><strong>拉格朗日定理</strong>：设 <span class="math inline"><em>G</em></span> 是一个有限群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，则 <span class="math display">|<em>G</em>| = |<em>H</em>|[<em>G</em> : <em>H</em>]</span></p><ul><li>拉格朗日定理说明，有限群 <span class="math inline"><em>G</em></span>的子群 <span class="math inline"><em>H</em></span> 的阶数与它在 <span class="math inline"><em>G</em></span> 中的指数，都是群 <span class="math inline"><em>G</em></span> 的阶数的因子<br></li><li>设 <span class="math inline"><em>G</em></span> 是有限群，则 <span class="math inline"><em>G</em></span> 中每一个元素的阶都是 <span class="math inline">|<em>G</em>|</span> 的因子</li><li>设 <span class="math inline"><em>G</em></span> 为有限群，<span class="math inline">|<em>G</em>| = <em>n</em></span>，则对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em><sup><em>n</em></sup> = <em>e</em></span><ul><li>应用到模 <span class="math inline"><em>p</em></span> 单位群 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>（<span class="math inline"><em>p</em></span> 是素数），可以得到<strong>费马小定理</strong>：设 <span class="math inline"><em>p</em></span> 为素数，则对任意一个与 <span class="math inline"><em>p</em></span> 互素的整数 <span class="math inline"><em>a</em></span>，有 <span class="math display"><em>a</em><sup><em>p</em> − 1</sup> ≡ 1  (&nbsp;mod &nbsp;<em>p</em>)</span></li></ul></li><li>应用拉格朗日定理，可以推测在一个有限群中，可能有怎样阶数的子群与元素，只是一种可能性，不能仅仅依据这种可能性，就断定这样的子群或元素一定存在</li></ul></li></ul><h3 id="各阶群的结构">各阶群的结构</h3><ul><li>一阶群是循环群：<span class="math inline"><em>G</em> = {<em>e</em>}</span></li><li>二阶群是循环群：<span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>} = ⟨<em>a</em>⟩</span></li><li>三阶群是循环群：<span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>} = ⟨<em>a</em>⟩</span></li><li>四阶群是循环群或克莱因四元群：<ul><li><span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>, <em>a</em><sup>3</sup>} = ⟨<em>a</em>⟩</span></li><li><span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>b</em>, <em>a</em><em>b</em>}</span>，<span class="math inline"><em>a</em><em>b</em> = <em>b</em><em>a</em></span>，<span class="math inline"><em>a</em><sup>2</sup> = <em>b</em><sup>2</sup> = <em>e</em></span></li></ul></li><li>五阶群是循环群：<span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>, <em>a</em><sup>3</sup>, <em>a</em><sup>4</sup>} = ⟨<em>a</em>⟩</span></li><li>六阶群是循环群或三次对称群<ul><li><span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>, <em>a</em><sup>3</sup>, <em>a</em><sup>4</sup>, <em>a</em><sup>5</sup>} = ⟨<em>a</em>⟩</span></li><li><span class="math inline"><em>G</em> ≅ <em>S</em><sub>3</sub> = {(1), (1&nbsp;2), (1&nbsp;3), (2&nbsp;3), (1&nbsp;2&nbsp;3), (1&nbsp;3&nbsp;2)}</span></li></ul></li></ul><h2 id="正规子群与商群">正规子群与商群</h2><h3 id="正规子群">正规子群</h3><h4 id="正规子群的定义">正规子群的定义</h4><p>设 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的子群，如果对每个 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，都有 <span class="math inline"><em>a</em><em>H</em> = <em>H</em><em>a</em></span>，则称<span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的一个 <strong>正规子群</strong>或 <strong>不变子群</strong> ，记作 <span class="math inline"><em>H</em> ⊲ <em>G</em></span></p><ul><li>条件 <span class="math inline"><em>a</em><em>H</em> = <em>H</em><em>a</em></span>仅仅表示两个集合 <span class="math inline"><em>a</em><em>H</em></span>与 <span class="math inline"><em>H</em><em>a</em></span>相等，即对任意的 <span class="math inline"><em>h</em> ∈ <em>H</em></span>，存在 <span class="math inline"><em>h</em><sup>′</sup> ∈ <em>H</em></span>，使 <span class="math inline"><em>a</em><em>h</em> = <em>h</em><sup>′</sup><em>a</em></span>；不可推出<span class="math inline"><em>a</em><em>h</em> = <em>h</em><em>a</em></span>对 <span class="math inline"><em>H</em></span> 中所有的元素 <span class="math inline"><em>h</em></span> 都成立</li><li>群 <span class="math inline"><em>G</em></span> 的单位元群 <span class="math inline">{<em>e</em>}</span> 和群 <span class="math inline"><em>G</em></span> 本身都是 <span class="math inline"><em>G</em></span> 的正规子群，这两个正规子群称为<span class="math inline"><em>G</em></span> 的<strong>平凡正规子群</strong></li><li>如果群 <span class="math inline"><em>G</em></span>只有平凡的正规子群，且 <span class="math inline"><em>G</em> ≠ <em>e</em></span>，则称 <span class="math inline"><em>G</em></span> 为 <strong>单群</strong></li></ul><h4 id="正规子群的性质">正规子群的性质</h4><ul><li>如果 <span class="math inline"><em>G</em></span> 是<strong>交换群</strong> ，则 <span class="math inline"><em>G</em></span>的一切子群都是 <span class="math inline"><em>G</em></span>的正规子群</li><li>设 <span class="math inline"><em>H</em>, <em>K</em></span> 都是<span class="math inline"><em>G</em></span> 的子群，如果 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群且 <span class="math inline"><em>H</em> ⊆ <em>K</em></span>，则 <span class="math inline"><em>H</em></span> 也是 <span class="math inline"><em>K</em></span> 的正规子群</li><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，如果 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的指数 <span class="math inline">[<em>G</em> : <em>H</em>] = 2</span>，则 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群</li><li>若 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>K</em></span> 的正规子群，<span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，<span class="math inline"><em>H</em></span> 不一定是 <span class="math inline"><em>G</em></span>的正规子群（正规子群没有传递性）</li></ul><h4 id="正规子群的判定">正规子群的判定</h4><ul><li>设 <span class="math inline"><em>G</em></span> 是群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，则下列四个条件等价：<ul><li><span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群</li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em><em>H</em><em>a</em><sup>−1</sup> = <em>H</em></span></li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em><em>H</em><em>a</em><sup>−1</sup> ⊆ <em>H</em></span></li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，<span class="math inline"><em>h</em> ∈ <em>H</em></span>，有 <span class="math inline"><em>a</em><em>h</em><em>a</em><sup>−1</sup> ∈ <em>H</em></span></li></ul></li><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em><sub>1</sub></span>，<span class="math inline"><em>H</em><sub>2</sub></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，则 <span class="math display"><em>H</em><sub>1</sub> ∩ <em>H</em><sub>2</sub>与<em>H</em><sub>1</sub><em>H</em><sub>2</sub></span>都是 <span class="math inline"><em>G</em></span> 的正规子群<ul><li>事实上，前面提到，两个子群的交一定是子群，而两个子群的合成要是子群的充分必要条件是可交换。而只要其中一个子群是正规子群，那么就是可交换的</li></ul></li></ul><h3 id="商群">商群</h3><h4 id="陪集的乘法">陪集的乘法</h4><p>正规子群的基本特点是：它的每一个左陪集与相应的右陪集完全一致。因此，对于群<span class="math inline"><em>G</em></span> 的正规子群 <span class="math inline"><em>H</em></span>，可不必区分它的左陪集 <span class="math inline"><em>a</em><em>H</em></span> 与右陪集 <span class="math inline"><em>H</em><em>a</em></span>，而直接称 <span class="math inline"><em>a</em><em>H</em></span> 或 <span class="math inline"><em>H</em><em>a</em></span>为它的一个<strong>陪集</strong> 。用 <span class="math inline"><em>G</em>/<em>H</em></span>表示它的所有陪集组成的集合，即 <span class="math display"><em>G</em>/<em>H</em> = {<em>a</em><em>H</em> ∣ <em>a</em> ∈ <em>G</em>}</span></p><p>下面规定 <span class="math inline"><em>G</em>/<em>H</em></span>的运算，以使 <span class="math inline"><em>G</em>/<em>H</em></span>关于给定的运算构成群。</p><p>对任意的 <span class="math inline"><em>a</em><em>H</em>, <em>b</em><em>H</em> ∈ <em>G</em>/<em>H</em></span>，规定：<span class="math display">(<em>a</em><em>H</em>) ⋅ (<em>b</em><em>H</em>) = (<em>a</em><em>b</em>)<em>H</em></span></p><p>设 <span class="math inline"><em>a</em><sup>′</sup><em>H</em> = <em>a</em><em>H</em></span>，<span class="math inline"><em>b</em><sup>′</sup><em>H</em> = <em>b</em><em>H</em></span>，则<span class="math display">$$\begin{aligned}a^{\prime} H \cdot b^{\prime} H &amp; =\left(a^{\prime}b^{\prime}\right) H=a^{\prime}\left(b^{\prime} H\right)=a^{\prime}(bH)=a^{\prime}(H b) \\&amp; =\left(a^{\prime} H\right) b=(a H) b=a(H b)=(a b) H\\\&amp; =a H \cdot b H\end{aligned}$$</span></p><p>所以 <span class="math inline"><em>H</em></span> 的任意两个陪集 <span class="math inline"><em>a</em><em>H</em></span> 与 <span class="math inline"><em>b</em><em>H</em></span>的乘积是唯一确定的，并且与 <span class="math inline"><em>a</em></span>与 <span class="math inline"><em>b</em></span>的选择无关，所以上述乘法是 <span class="math inline"><em>G</em>/<em>H</em></span> 的一个代数运算。</p><h4 id="商群的定义">商群的定义</h4><p>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群。<span class="math inline"><em>H</em></span> 的所有陪集 <span class="math inline"><em>G</em>/<em>H</em></span> 关于陪集的乘法 <span class="math inline"><em>a</em><em>H</em> ⋅ <em>b</em><em>H</em> = (<em>a</em><em>b</em>)<em>H</em></span>构成的群称为群 <span class="math inline"><em>G</em></span> 关于子群<span class="math inline"><em>H</em></span>的<strong>商群</strong>，仍记作 <span class="math inline"><em>G</em>/<em>H</em></span>，即 <span class="math display"><em>G</em>/<em>H</em> = {<em>a</em><em>H</em> ∣ <em>a</em> ∈ <em>G</em>}</span></p><ul><li>商群 <span class="math inline"><em>G</em>/<em>H</em></span>的单位元是 <span class="math inline"><em>e</em><em>H</em>( = <em>H</em>)</span></li><li><span class="math inline"><em>a</em><em>H</em></span> 在 <span class="math inline"><em>G</em>/<em>H</em></span> 中的逆元是 <span class="math inline"><em>a</em><sup>−1</sup><em>H</em></span></li></ul><h4 id="商群的性质">商群的性质</h4><ul><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的任一子群。如果 <span class="math inline"><em>G</em></span> 是交换群，则商群 <span class="math inline"><em>G</em>/<em>H</em></span> 也是交换群。由于 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的指数<span class="math inline">[<em>G</em> : <em>H</em>]</span> 就是 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的陪集的个数，所以 <span class="math inline">|<em>G</em>/<em>H</em>| = [<em>G</em> : <em>H</em>]</span>。特别地，当<span class="math inline"><em>G</em></span> 是有限群时 <span class="math display">$$  |G / H|=[G:H]=\frac{|G|}{|H|}  $$</span><ul><li>有限群 <span class="math inline"><em>G</em></span> 的商群的阶是群<span class="math inline"><em>G</em></span> 的阶数的因子。</li></ul></li><li><span class="math inline"><strong>Z</strong></span> 关于 <span class="math inline">⟨<em>m</em>⟩</span> 的商群 <span class="math inline"><strong>Z</strong>/⟨<em>m</em>⟩</span> 就是 <span class="math inline"><strong>Z</strong></span> 关于模 <span class="math inline"><em>m</em></span> 的剩余类加群 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>，因此有<span class="math display"><strong>Z</strong>/⟨<em>m</em>⟩ = <strong>Z</strong><sub><em>m</em></sub></span></li></ul><h2 id="群的同态与同态基本定理">群的同态与同态基本定理</h2><h3 id="群同态">群同态</h3><h4 id="群同态定义">群同态定义</h4><p>设 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 是两个群，<span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的映射。如果对任意的<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span> 有<span class="math display"><em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span></p><p>则称 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的一个<strong>同态映射</strong> ，简称<strong>同态</strong></p><ul><li><p>当同态映射 <span class="math inline"><em>ϕ</em></span>是满射时，称 <span class="math inline"><em>ϕ</em></span> 为群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>满同态</strong></p></li><li><p>当同态映射 <span class="math inline"><em>ϕ</em></span>是单射时，称 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>单同态</strong></p></li><li><p>群的同构映射一定是既单且满的同态映射；反之，当群 <span class="math inline"><em>G</em></span> 到群 <span class="math inline"><em>G</em><sup>′</sup></span> 的同态映射 <span class="math inline"><em>ϕ</em></span> 既是单同态又是满同态时，<span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的同构映射</p></li><li><p>在上式中，虽然用同一个记号“<span class="math inline">⋅</span>”来表示群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span>的运算，但这不表示等式两边的运算 <span class="math inline"><em>a</em><em>b</em></span> 与 <span class="math inline"><em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span>是一样的，而是分别表示群 <span class="math inline"><em>G</em></span>与群 <span class="math inline"><em>G</em><sup>′</sup></span>的运算。</p></li><li><p><strong>自然同态</strong>：设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，对商群 <span class="math inline"><em>G</em>/<em>H</em></span>，令 <span class="math display">$$  \begin{aligned}  \eta:G &amp; \longrightarrow G / H,\\  a &amp; \longrightarrow a H,  \end{aligned}  $$</span></p><p>则 <span class="math inline"><em>η</em></span> 是满映射，且对任意<span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em> ∈ <em>G</em></span>，有 <span class="math display"><em>η</em>(<em>a</em><em>b</em>) = (<em>a</em><em>b</em>)<em>H</em> = <em>a</em><em>H</em> ⋅ <em>b</em><em>H</em> = <em>η</em>(<em>a</em>)<em>η</em>(<em>b</em>)</span></p><p>所以 <span class="math inline"><em>η</em></span> 是 <span class="math inline"><em>G</em></span> 到它的商群 <span class="math inline"><em>G</em>/<em>H</em></span>的同态映射。通常称这样的同态映射为自然同态。</p></li></ul><h4 id="群同态的性质">群同态的性质</h4><p>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到群 <span class="math inline"><em>G</em><sup>′</sup></span> 的同态映射，<span class="math inline"><em>e</em></span> 与 <span class="math inline"><em>e</em><sup>′</sup></span> 分别是 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 的单位元，<span class="math inline"><em>a</em> ∈ <em>G</em></span>，则</p><ul><li><span class="math inline"><em>ϕ</em></span> 将 <span class="math inline"><em>G</em></span> 的单位元映到 <span class="math inline"><em>G</em><sup>′</sup></span> 的单位元，即 <span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span></li><li><span class="math inline"><em>ϕ</em></span> 将 <span class="math inline"><em>a</em></span> 的逆元映到 <span class="math inline"><em>ϕ</em>(<em>a</em>)</span> 的逆元，即 <span class="math inline"><em>ϕ</em>(<em>a</em><sup>−1</sup>) = (<em>ϕ</em>(<em>a</em>))<sup>−1</sup></span></li><li>设 <span class="math inline"><em>n</em></span> 是任一整数，则 <span class="math inline"><em>ϕ</em>(<em>a</em><sup><em>n</em></sup>) = (<em>ϕ</em>(<em>a</em>))<sup><em>n</em></sup></span></li><li>如果 <span class="math inline">ord <em>a</em></span> 有限，则 <span class="math inline">ord <em>ϕ</em>(<em>a</em>) ∣ ord <em>a</em></span></li></ul><h4 id="象和原象">象和原象</h4><ul><li><p>设 <span class="math inline"><em>ϕ</em></span> 为群 <span class="math inline"><em>G</em></span> 到群 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>映射</strong> ，<span class="math inline"><em>A</em>, <em>B</em></span> 分别为 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 的非空子集，记 <span class="math display">$$  \begin{aligned}  \phi(A) &amp; =\{\phi(x) \mid x \in A\},\\  \phi^{-1}(B) &amp; =\{x \in G \mid \phi(x) \in B\}  \end{aligned}  $$</span></p><p>则 <span class="math inline"><em>ϕ</em>(<em>A</em>)</span> 与 <span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>B</em>)</span> 分别是<span class="math inline"><em>G</em><sup>′</sup></span> 与 <span class="math inline"><em>G</em></span> 的非空子集。<span class="math inline"><em>ϕ</em>(<em>A</em>)</span> 与 <span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>B</em>)</span>分别称为子集 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 在 <span class="math inline"><em>ϕ</em></span> 下的<strong>象</strong>与<strong>原象</strong></p><ul><li>注意，<span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>B</em>)</span>仅仅是一个集合的记号，并不表示映射 <span class="math inline"><em>ϕ</em></span> 是可逆的</li></ul></li><li><p>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>同态映射</strong> ，<span class="math inline"><em>H</em></span> 与 <span class="math inline"><em>K</em></span> 分别是 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 的子群，则</p><ul><li><span class="math inline"><em>ϕ</em>(<em>H</em>)</span> 是 <span class="math inline"><em>G</em><sup>′</sup></span> 的子群</li><li><span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>K</em>)</span>是 <span class="math inline"><em>G</em></span> 的子群</li><li>如果 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，则 <span class="math inline"><em>ϕ</em>(<em>H</em>)</span> 是 <span class="math inline"><em>ϕ</em>(<em>G</em>)</span> 的正规子群</li><li>如果 <span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em><sup>′</sup></span> 的正规子群，则 <span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>K</em>)</span> 是 <span class="math inline"><em>G</em></span> 的正规子群</li></ul></li></ul><h4 id="核">核</h4><p>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的同态映射，<span class="math inline"><em>e</em><sup>′</sup></span> 是 <span class="math inline"><em>G</em><sup>′</sup></span> 的单位元，则称 <span class="math inline"><em>e</em><sup>′</sup></span> 在 <span class="math inline"><em>G</em></span> 中的原象 <span class="math display"><em>ϕ</em><sup>−1</sup>({<em>e</em><sup>′</sup>}) = {<em>a</em> ∈ <em>G</em> ∣ <em>ϕ</em>(<em>a</em>) = <em>e</em><sup>′</sup>}</span></p><p>为同态映射 <span class="math inline"><em>ϕ</em></span>的<strong>核</strong> ，记作 <span class="math inline">Ker <em>ϕ</em></span></p><h3 id="群同态基本定理">群同态基本定理</h3><p>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到群 <span class="math inline"><em>G</em><sup>′</sup></span> 的满同态，<span class="math inline"><em>K</em> = Ker <em>ϕ</em></span>，则 <span class="math display"><em>G</em>/<em>K</em> ≅ <em>G</em><sup>′</sup></span></p><p>应用群同态基本定理证明群的同构，一般有以下五个步骤：</p><ol type="1"><li>建立群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素之间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>映射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满映射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>同态映射</strong>，即证明保持运算</li><li>计算同态的 <strong>核</strong> <span class="math inline">Ker <em>ϕ</em></span></li><li>应用群同态基本定理得 <span class="math inline"><em>G</em>/Ker <em>ϕ</em> ≅ <em>G</em><sup>′</sup></span></li></ol><h3 id="第二同构定理">第二同构定理</h3><p>设 <span class="math inline"><em>H</em></span> 为 <span class="math inline"><em>G</em></span> 的子群，<span class="math inline"><em>K</em></span> 为 <span class="math inline"><em>G</em></span> 的正规子群，则 <span class="math inline"><em>H</em> ∩ <em>K</em></span> 是 <span class="math inline"><em>H</em></span> 的正规子群且 <span class="math display"><em>H</em>/(<em>H</em> ∩ <em>K</em>) ≅ <em>H</em><em>K</em>/<em>K</em></span></p><h3 id="第三同构定理">第三同构定理</h3><p>设 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的正规子群，<span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，且 <span class="math inline"><em>K</em> ⊆ <em>H</em></span>，则 <span class="math display">(<em>G</em>/<em>K</em>)/(<em>H</em>/<em>K</em>) ≅ <em>G</em>/<em>H</em></span></p><h2 id="群的直积">群的直积</h2><h3 id="外直积">外直积</h3><h4 id="外直积的定义">外直积的定义</h4><p>设 <span class="math inline"><em>G</em><sub>1</sub>, <em>G</em><sub>2</sub></span>是两个群，构造集合 <span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 的卡氏积 <span class="math display"><em>G</em> = {(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>) ∣ <em>a</em><sub>1</sub> ∈ <em>G</em><sub>1</sub>, <em>a</em><sub>2</sub> ∈ <em>G</em><sub>2</sub>}</span></p><p>并在 <span class="math inline"><em>G</em></span> 中定义乘法运算 <span class="math display">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>) ⋅ (<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>) = (<em>a</em><sub>1</sub><em>b</em><sub>1</sub>, <em>a</em><sub>2</sub><em>b</em><sub>2</sub>),  (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>), (<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>) ∈ <em>G</em></span></p><p>则 <span class="math inline"><em>G</em></span>关于上述定义的乘法构成群，称为群 <span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span>的<strong>外直积</strong> ，记作 <span class="math inline"><em>G</em> = <em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span></p><ul><li>如果 <span class="math inline"><em>e</em><sub>1</sub>, <em>e</em><sub>2</sub></span>分别是群 <span class="math inline"><em>G</em><sub>1</sub></span> 和<span class="math inline"><em>G</em><sub>2</sub></span> 的单位元，则<span class="math inline">(<em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>)</span>是 <span class="math inline"><em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>的单位元</li><li>设 <span class="math inline">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>) ∈ <em>G</em></span>，则<span class="math inline">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>)<sup>−1</sup> = (<em>a</em><sub>1</sub><sup>−1</sup>, <em>a</em><sub>2</sub><sup>−1</sup>)</span></li><li>当 <span class="math inline"><em>G</em><sub>1</sub></span> 和 <span class="math inline"><em>G</em><sub>2</sub></span> 都是加群时，<span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 的外直积也可记作 <span class="math inline"><em>G</em><sub>1</sub> ⊕ <em>G</em><sub>2</sub></span></li></ul><h4 id="外直积的性质">外直积的性质</h4><ul><li><p>设 <span class="math inline"><em>G</em> = <em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>是群 <span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 的外直积，则</p><ul><li><span class="math inline"><em>G</em></span> 是有限群的充分必要条件是<span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 都是有限群。</li><li>当 <span class="math inline"><em>G</em></span> 是有限群时，有 <span class="math display">|<em>G</em>| = |<em>G</em><sub>1</sub>| ⋅ |<em>G</em><sub>2</sub>|</span></li><li><span class="math inline"><em>G</em></span> 是交换群的充分必要条件是<span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 都是交换群</li><li><span class="math inline"><em>G</em><sub>1</sub> × <em>G</em><sub>2</sub> ≅ <em>G</em><sub>2</sub> × <em>G</em><sub>1</sub></span></li></ul></li><li><p>设 <span class="math inline"><em>G</em><sub>1</sub></span>，<span class="math inline"><em>G</em><sub>2</sub></span> 是两个群，<span class="math inline"><em>a</em></span> 和 <span class="math inline"><em>b</em></span> 分别是 <span class="math inline"><em>G</em><sub>1</sub></span> 和 <span class="math inline"><em>G</em><sub>2</sub></span> 中的有限阶元素，则对于<span class="math inline">(<em>a</em>, <em>b</em>) ∈ <em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>，有<span class="math display">ord (<em>a</em>, <em>b</em>) = [ord <em>a</em>, ord <em>b</em>]</span></p></li><li><p>设 <span class="math inline"><em>G</em><sub>1</sub></span> 和<span class="math inline"><em>G</em><sub>2</sub></span> 分别是 <span class="math inline"><em>m</em></span> 阶及 <span class="math inline"><em>n</em></span> 阶的循环群，则 <span class="math inline"><em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>是循环群的充要条件是 <span class="math inline">(<em>m</em>, <em>n</em>) = 1</span></p></li></ul><h3 id="内直积">内直积</h3><h4 id="内直积的定义">内直积的定义</h4><p>设 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 是群 <span class="math inline"><em>G</em></span> 的正规子群。如果群 <span class="math inline"><em>G</em></span> 满足条件 <span class="math display"><em>G</em> = <em>H</em><em>K</em>,  <em>H</em> ∩ <em>K</em> = {<em>e</em>}</span></p><p>则称 <span class="math inline"><em>G</em></span> 是 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 的<strong>内直积</strong></p><h4 id="内直积的判定">内直积的判定</h4><p>设 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，则 <span class="math inline"><em>G</em></span> 是 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 的内直积的充分必要条件是 <span class="math inline"><em>G</em></span> 满足如下两个条件：</p><ul><li><span class="math inline"><em>G</em></span> 中每个元素可唯一地表为<span class="math inline"><em>h</em><em>k</em></span> 的形式，其中 <span class="math inline"><em>h</em> ∈ <em>H</em></span>，<span class="math inline"><em>k</em> ∈ <em>K</em></span></li><li><span class="math inline"><em>H</em></span> 中每个元素与 <span class="math inline"><em>K</em></span> 中任意元素可交换，即：对任意 <span class="math inline"><em>h</em> ∈ <em>H</em></span>，<span class="math inline"><em>k</em> ∈ <em>K</em></span>，有 <span class="math inline"><em>h</em><em>k</em> = <em>k</em><em>h</em></span></li></ul><h3 id="内外直积的关系">内外直积的关系</h3><p>如果群 <span class="math inline"><em>G</em></span> 是正规子群 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 的内直积，则 <span class="math inline"><em>H</em> × <em>K</em> ≅ <em>G</em></span></p><p>反之，如果群 <span class="math inline"><em>G</em> = <em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>，则存在<span class="math inline"><em>G</em></span> 的正规子群 <span class="math inline"><em>G</em><sub>1</sub><sup>′</sup></span> 和 <span class="math inline"><em>G</em><sub>2</sub><sup>′</sup></span>，且 <span class="math inline"><em>G</em><sub><em>i</em></sub><sup>′</sup></span>与 <span class="math inline"><em>G</em><sub><em>i</em></sub></span> 同构<span class="math inline">(<em>i</em> = 1, 2)</span>，使得 <span class="math inline"><em>G</em></span> 是 <span class="math inline"><em>G</em><sub>1</sub><sup>′</sup></span> 与 <span class="math inline"><em>G</em><sub>2</sub><sup>′</sup></span>的内直积</p><ul><li>从本定理中可看到，内外直积的概念本质上是一致的，所以有时可不对内外直积加以区分，而统称为群的直积</li></ul><h3 id="多个群的直积">多个群的直积</h3><ul><li><p>设 <span class="math inline"><em>G</em><sub>1</sub>, <em>G</em><sub>2</sub>, ⋯, <em>G</em><sub><em>n</em></sub></span>是有限多个群。构造集合 <span class="math display"><em>G</em> = {(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>) ∣ <em>a</em><sub><em>i</em></sub> ∈ <em>G</em><sub><em>i</em></sub>, <em>i</em> = 1, 2, ⋯, <em>n</em>}</span></p><p>并在 <span class="math inline"><em>G</em></span> 中定义运算 <span class="math display">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>) ⋅ (<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>n</em></sub>) = (<em>a</em><sub>1</sub><em>b</em><sub>1</sub>, <em>a</em><sub>2</sub><em>b</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub><em>b</em><sub><em>n</em></sub>)</span></p><p>则 <span class="math inline"><em>G</em></span>关于上述运算构成群，称为群 <span class="math inline"><em>G</em><sub>1</sub>, <em>G</em><sub>2</sub>, ⋯, <em>G</em><sub><em>n</em></sub></span>的外直积</p></li><li><p>设 <span class="math inline"><em>H</em><sub>1</sub>, <em>H</em><sub>2</sub>, ⋯, <em>H</em><sub><em>n</em></sub></span>是群 <span class="math inline"><em>G</em></span>的有限多个正规子群。如果 <span class="math inline"><em>G</em></span>满足以下两个条件，就称 <span class="math inline"><em>G</em></span> 是<span class="math inline"><em>H</em><sub>1</sub>, <em>H</em><sub>2</sub>, ⋯, <em>H</em><sub><em>n</em></sub></span>的内直积：</p><ul><li><span class="math inline"><em>G</em> = <em>H</em><sub>1</sub><em>H</em><sub>2</sub>⋯<em>H</em><sub><em>n</em></sub> = {<em>h</em><sub>1</sub><em>h</em><sub>2</sub>⋯<em>h</em><sub><em>n</em></sub> ∣ <em>h</em><sub><em>i</em></sub> ∈ <em>H</em><sub><em>i</em></sub>}</span></li><li><span class="math inline">(<em>H</em><sub>1</sub><em>H</em><sub>2</sub>⋯<em>H</em><sub><em>i</em></sub>) ∩ <em>H</em><sub><em>i</em> + 1</sub> = {<em>e</em>}, <em>i</em> = 1, 2, ⋯, <em>n</em> − 1</span>（任意两个交起来都是单位群）</li></ul></li><li><p>对于多个群的直积，如果群 <span class="math inline"><em>G</em></span> 是有限多个子群 <span class="math inline"><em>H</em><sub>1</sub>, <em>H</em><sub>2</sub>, ⋯, <em>H</em><sub><em>n</em></sub></span>的内直积，则 <span class="math inline"><em>G</em></span> 同构于 <span class="math inline"><em>H</em><sub>1</sub>, <em>H</em><sub>2</sub>, ⋯, <em>H</em><sub><em>n</em></sub></span>的外直积</p></li></ul><h1 id="第二章-环">第二章 环</h1><h2 id="环的定义和基本性质">环的定义和基本性质</h2><h3 id="环的定义">环的定义</h3><p>设 <span class="math inline"><em>R</em></span> 是一个非空集合，如果在<span class="math inline"><em>R</em></span> 上定义了两数运算“<span class="math inline">+</span>”（称为加法）和“<span class="math inline">⋅</span>”（称为乘法），并且满足</p><ul><li>(R1) <span class="math inline"><em>R</em></span>关于加法构成一个<strong>交换群</strong></li><li>(R2) 乘法结合律成立，即对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，有<span class="math display">(<em>a</em> ⋅ <em>b</em>) ⋅ <em>c</em> = <em>a</em> ⋅ (<em>b</em> ⋅ <em>c</em>)</span></li><li>(R3) 乘法对加法的两个分配律成立，即对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，有<span class="math display">$$  \begin{aligned}  a\cdot (b + c) = a\cdot b + a\cdot c\\  (b+c)\cdot a = b\cdot a + c\cdot a  \end{aligned}  $$</span></li></ul><p>则称 <span class="math inline">(<em>R</em>, +, ⋅)</span>为一个<strong>环</strong> ，或简称 <span class="math inline"><em>R</em></span> 为环</p><ul><li>由环的定义知 <span class="math inline">(<em>R</em>, +)</span>是一个交换群，称为环的加法群。与前两章中关于加群的记号一样，<span class="math inline"><em>R</em></span> 的加法单位元常用 0 表示，称为环<span class="math inline"><em>R</em></span> 的 <strong>零元</strong>，环<span class="math inline"><em>R</em></span> 的元素 <span class="math inline"><em>a</em></span> 的加法逆元称为 <span class="math inline"><em>a</em></span> 的 <strong>负元</strong> ，记作<span class="math inline">−<em>a</em></span>，由群的性质可知，<span class="math inline"><em>R</em></span>的零元及每个元素的负元都是唯一的</li><li>如果环 <span class="math inline"><em>R</em></span>的乘法还满足交换律，则称为<strong>交换环</strong></li><li>如果环中存在元素 <span class="math inline"><em>e</em></span>，使对任意的 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，有 <span class="math display"><em>a</em><em>e</em> = <em>e</em><em>a</em> = <em>a</em></span>则称 <span class="math inline"><em>R</em></span>是一个有单位元的环，并称 <span class="math inline"><em>e</em></span> 为<span class="math inline"><em>R</em></span> 的<strong>单位元</strong>（注意：环的单位元是乘法单位元）</li><li>一个环<strong>不一定有单位元</strong>，如果环有单位元，则单位元是唯一的</li><li>设环 <span class="math inline"><em>R</em></span>是有单位元的环，<span class="math inline"><em>a</em> ∈ <em>R</em></span>，如果存在 <span class="math inline"><em>b</em> ∈ <em>R</em></span>，使 <span class="math display"><em>a</em><em>b</em> = <em>b</em><em>a</em> = <em>e</em></span>则称 <span class="math inline"><em>a</em></span> 是 <span class="math inline"><em>R</em></span> 的一个 <strong>可逆元</strong>或<strong>单位</strong> ，并称 <span class="math inline"><em>b</em></span> 为 <span class="math inline"><em>a</em></span> 的 <strong>逆元</strong> ，记作<span class="math inline"><em>a</em><sup>−1</sup></span></li><li>环的一个元素不一定是可逆的，如果 <span class="math inline"><em>a</em></span> 可逆则 <span class="math inline"><em>a</em></span> 的逆元是唯一的</li><li>对于一个有单位元的环 <span class="math inline"><em>R</em></span>，其所有可逆元组成的集合关于环<span class="math inline"><em>R</em></span> 的乘法构成群。这个群称为环<span class="math inline"><em>R</em></span> 的 <strong>单位群</strong>，记作 <span class="math inline"><em>U</em>(<em>R</em>)</span></li><li>设 <span class="math inline"><em>R</em> = {0}</span>，规定 <span class="math inline">0 + 0 = 0 ⋅ 0 = 0</span>，则 <span class="math inline"><em>R</em></span>构成环称为<strong>零环</strong>，零环是唯一的一个有单位元且单位元等于零元，并且零元也可逆的环</li><li>今后，如无特别声明，凡提到有单位元的环时我们总假定这个环不是零环，因此环的单位元也就不等于零元</li></ul><h3 id="常见的环">常见的环</h3><ul><li><p>整数集 <span class="math inline">ℤ</span>、有理数集 <span class="math inline">ℚ</span>、实数集 <span class="math inline">ℝ</span>、复数集 <span class="math inline">ℂ</span>对于通常数的加法与乘法构成有单位元 <span class="math inline">1</span>的交换环，分别称为<strong>整数环、有理数域、实数域、复数域</strong>、它们的单位群分别是 <span class="math inline">{1, −1}</span>、<span class="math inline">ℚ<sup>*</sup></span>、<span class="math inline">ℝ<sup>*</sup></span> 和 <span class="math inline">ℂ<sup>*</sup></span></p></li><li><p>数域 <span class="math inline"><em>F</em></span> 上全体 <span class="math inline"><em>n</em>(<em>n</em> &gt; 1)</span> 阶方阵 <span class="math inline"><em>M</em><sub><em>n</em></sub>(<em>F</em>)</span>的集合关于矩阵的加法与乘法构成一个有单位元 <span class="math inline"><em>E</em></span>（单位矩阵）的非交换环，称为数域<span class="math inline"><em>F</em></span> 上的 <span class="math inline"><em>n</em></span> 阶全矩阵环，这个环的单位群是 <span class="math inline"><em>G</em><em>L</em><sub><em>n</em></sub>(<em>F</em>)</span></p></li><li><p>设 <span class="math inline"><em>m</em></span> 为大于 <span class="math inline">1</span> 的正整数，则 <span class="math inline">ℤ</span> 的模 <span class="math inline"><em>m</em></span> 剩余类集 <span class="math display">$$  Z_m=\{\overline{0},\overline{1},\overline{2},\cdots,\overline{m-1}\}  $$</span> 关于剩余类的加法和乘法构成有单位元的交换环，称为<strong>模 m剩余类环</strong> ，这个环的单位群是 <span class="math inline">$U(m) =\{\overline{x} \mid 1 \leq x &lt; m, (x,m)=1\}$</span></p></li><li><p>设 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, ⋯, <em>R</em><sub><em>n</em></sub></span>为 <span class="math inline"><em>n</em></span> 个环。令 <span class="math display"><em>R</em> = <em>R</em><sub>1</sub> ⊕ <em>R</em><sub>2</sub> ⊕ ⋯ ⊕ <em>R</em><sub><em>n</em></sub> = {(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>) ∣ <em>a</em><sub><em>i</em></sub> ∈ <em>R</em><sub><em>i</em></sub>, <em>i</em> = 1, 2, ⋯；<em>n</em>}</span></p><p>对任意的 <span class="math inline">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>), (<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>n</em></sub>) ∈ <em>R</em></span>，规定<span class="math display">$$  \begin{aligned}  \left(a_{1},a_{2},\cdots,a_{n}\right)+\left(b_{1},b_{2},\cdots,b_{n}\right)&amp; =\left(a_{1}+b_{1},a_{2}+b_{2},\cdots,a_{n}+b_{n}\right),\\  \left(a_{1},a_{2},\cdots,a_{n}\right)\cdot\left(b_{1},b_{2},\cdots,b_{n}\right) &amp; =\left(a_{1}b_{1},a_{2} b_{2},\cdots,a_{n} b_{n}\right)  \end{aligned}  $$</span></p><p>则 <span class="math inline"><em>R</em></span>关于上面所定义的加法与乘法构成一个环。这个环称为环 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, ⋯, <em>R</em><sub><em>n</em></sub></span>的<strong>直和</strong></p><ul><li><span class="math inline"><em>R</em></span>有单位元的充分必要条件是每个 <span class="math inline"><em>R</em><sub><em>i</em></sub></span>都有单位元</li><li><span class="math inline"><em>R</em></span>是交换环的充分必要条件是每个 <span class="math inline"><em>R</em><sub><em>i</em></sub></span>都是交换环</li></ul></li></ul><h3 id="环的性质">环的性质</h3><ul><li><p>设 <span class="math inline"><em>R</em></span> 是一个环，<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，则</p><ul><li><span class="math inline"><em>a</em> ⋅ 0 = 0 ⋅ <em>a</em> = 0</span></li><li><span class="math inline">−(−<em>a</em>) = <em>a</em></span></li><li><span class="math inline"><em>a</em> ⋅ (−<em>b</em>) = (−<em>a</em>) ⋅ <em>b</em> = −<em>a</em><em>b</em></span></li><li><span class="math inline">(−<em>a</em>) ⋅ (−<em>b</em>) = <em>a</em><em>b</em></span></li></ul></li><li><p>利用负元的概念，可以定义环 <span class="math inline"><em>R</em></span> 的减法“<span class="math inline">−</span>”，即对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，令 <span class="math display"><em>a</em> − <em>b</em> = <em>a</em> + (−<em>b</em>)</span></p></li><li><p><strong>移项法则</strong>：对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，有以下移项法则：<span class="math display"><em>a</em> + <em>b</em> = <em>c</em> ⇔ <em>a</em> = <em>c</em> − <em>b</em></span></p><p>乘法对于减法还满足分配律，即对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，有<span class="math display">$$  \begin{aligned}  a(b-c)=a b-a c \\  (b-c) a=b a-c a  \end{aligned}  $$</span></p></li><li><p><strong>倍数法则</strong>：对任意的 <span class="math inline"><em>m</em>, <em>n</em> ∈ <strong>Z</strong></span>，<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，</p><ul><li><span class="math inline"><em>m</em><em>a</em> + <em>n</em><em>a</em> = (<em>m</em> + <em>n</em>)<em>a</em></span></li><li><span class="math inline"><em>m</em>(<em>a</em> + <em>b</em>) = <em>m</em><em>a</em> + <em>m</em><em>b</em></span></li><li><span class="math inline"><em>m</em>(<em>n</em><em>a</em>) = (<em>m</em><em>n</em>)<em>a</em> = <em>n</em>(<em>m</em><em>a</em>)</span></li><li><span class="math inline"><em>m</em>(<em>a</em><em>b</em>) = (<em>m</em><em>a</em>)<em>b</em> = <em>a</em>(<em>m</em><em>b</em>)</span></li></ul></li><li><p><strong>指数法则</strong>：对任意的 <span class="math inline"><em>m</em>, <em>n</em> ∈ <strong>N</strong></span>，<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，</p><ul><li><span class="math inline">(<em>a</em><sup><em>m</em></sup>)<sup><em>n</em></sup> = <em>a</em><sup><em>m</em><em>n</em></sup></span></li><li><span class="math inline"><em>a</em><sup><em>m</em></sup> ⋅ <em>a</em><sup><em>n</em></sup> = <em>a</em><sup><em>m</em> + <em>n</em></sup></span></li><li>如果 <span class="math inline"><em>R</em></span> 的元素 <span class="math inline"><em>a</em></span> 是不可逆的，则 <span class="math inline"><em>a</em><sup>0</sup></span> 与 <span class="math inline"><em>a</em><sup>−<em>n</em></sup>(<em>n</em> &gt; 0)</span>通常是没有意义的</li><li>当 <span class="math inline"><em>a</em><em>b</em> ≠ <em>b</em><em>a</em></span>时，等式 <span class="math inline">(<em>a</em> ⋅ <em>b</em>)<sup><em>n</em></sup> = <em>a</em><sup><em>n</em></sup> ⋅ <em>b</em><sup><em>n</em></sup></span>一般也不成立</li></ul></li><li><p><strong>广义分配律</strong>： 设 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，则对 <span class="math inline"><em>b</em><sub><em>i</em></sub> ∈ <em>R</em>(<em>i</em> = 1, 2, ⋯, <em>n</em>)</span>，有<span class="math display">$$  a\left(\sum_{i=1}^{n} b_{i}\right)=\sum_{i=1}^{n} a  b_{i},\quad\left(\sum_{i=1}^{n} b_{i}\right) a=\sum_{i=1}^{n} b_{i} a  $$</span></p><p>设 <span class="math inline"><em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub> ∈ <em>R</em>(<em>i</em> = 1, 2, ⋯, <em>n</em></span>；<span class="math inline"><em>j</em> = 1, 2, ⋯, <em>m</em>)</span>，则 <span class="math display">$$  \left(\sum_{i=1}^{n} a_{i}\right)\left(\sum_{j=1}^{m}b_{j}\right)=\sum_{i=1}^{n} \sum_{j=1}^{m} a_{i} b_{j}  $$</span></p></li></ul><h3 id="子环的定义">子环的定义</h3><p>设 <span class="math inline">(<em>R</em>, +, ⋅)</span>是一个环，<span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的一个非空子集。如果 <span class="math inline"><em>S</em></span> 关于 <span class="math inline"><em>R</em></span> 的运算构成环，则称 <span class="math inline"><em>S</em></span> 为 <span class="math inline"><em>R</em></span> 的一个<strong>子环</strong> ，记作<span class="math inline"><em>S</em> &lt; <em>R</em></span></p><ul><li>如果 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的子环，则 <span class="math inline">(<em>S</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的子加群</li><li><span class="math inline"><em>R</em></span> 的零元 <span class="math inline">0</span> 就是 <span class="math inline"><em>S</em></span> 的零元</li><li><span class="math inline"><em>S</em></span> 中元素 <span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>R</em></span> 中的负元 <span class="math inline">−<em>a</em></span> 就是 <span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>S</em></span> 中的负元</li><li>环 <span class="math inline"><em>R</em></span>本身以及由单独一个零元 <span class="math inline">{0}</span>所构成的集合关于 <span class="math inline"><em>R</em></span>的运算显然都构成 <span class="math inline"><em>R</em></span>的子环，这两个子环称为环 <span class="math inline"><em>R</em></span>的<strong>平凡子环</strong></li><li>即使一个环有单位元，其子环也可能没有单位元</li><li>即使一个环没有单位元，其子环也可能有单位元</li></ul><h3 id="子环的判定">子环的判定</h3><ul><li>设 <span class="math inline"><em>R</em></span> 是一个环，<span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的一个非空子集，则 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的子环的充分必要条件是<ul><li><span class="math inline">(<em>S</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的加法子群</li><li><span class="math inline"><em>S</em></span> 关于 <span class="math inline"><em>R</em></span> 的乘法封闭，即对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>S</em></span>，有 <span class="math inline"><em>a</em><em>b</em> ∈ <em>S</em></span></li></ul></li><li>设 <span class="math inline"><em>R</em></span> 是一个环，<span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的一个非空子集，则 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的子环的充分必要条件是<ul><li>对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>S</em></span>，<span class="math inline"><em>a</em> − <em>b</em> ∈ <em>S</em></span></li><li>对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>S</em></span>，<span class="math inline"><em>a</em><em>b</em> ∈ <em>S</em></span></li></ul></li><li>这就是说，环 <span class="math inline"><em>R</em></span> 的子环<span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span>的关于减法与乘法封闭的非空子集</li></ul><h3 id="中心">中心</h3><p>设 <span class="math inline"><em>R</em></span> 为环，则 <span class="math display"><em>C</em>(<em>R</em>) = {<em>r</em> ∈ <em>R</em> ∣ <em>r</em><em>s</em> = <em>s</em><em>r</em>, ∀<em>s</em> ∈ <em>R</em>}</span></p><p>为 <span class="math inline"><em>R</em></span>的一个子环，这个子环称为 <span class="math inline"><em>R</em></span> 的<strong>中心</strong></p><h2 id="整环和域">整环和域</h2><h3 id="零因子">零因子</h3><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em></span> 为 <span class="math inline"><em>R</em></span> 的两个<strong>非零元素</strong>，如果 <span class="math display"><em>a</em> ⋅ <em>b</em> = 0</span></p><p>则称 <span class="math inline"><em>a</em></span> 为 <span class="math inline"><em>R</em></span> 的一个<strong>左零因子</strong>，<span class="math inline"><em>b</em></span> 为 <span class="math inline"><em>R</em></span>的一个<strong>右零因子</strong></p><ul><li>左零因子与右零因子统称为<strong>零因子</strong></li><li>在一个有零因子的环中，右零因子不一定是左零因子，左零因子也不一定是右零因子</li><li>如果一个环有左零因子，也就一定有右零因子，反之亦然</li><li>如果一个环没有左零因子，当然也就没有右零因子，从而也就没有零因子</li><li>一个没有零因子的环称为<strong>无零因子环</strong></li><li>在一个无零因子的环中，两个消去律成立，即对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，<span class="math inline"><em>c</em> ≠ 0</span>，如果 <span class="math inline"><em>a</em><em>c</em> = <em>b</em><em>c</em></span>或 <span class="math inline"><em>c</em><em>a</em> = <em>c</em><em>b</em></span>，则<span class="math inline"><em>a</em> = <em>b</em></span></li><li>如果环 <span class="math inline"><em>R</em></span>中两个消去律有一个成立，则 <span class="math inline"><em>R</em></span>必是无零因子环，从而另一个消去律也成立</li></ul><h3 id="整环">整环</h3><p>一个 <strong>无零因子</strong> 的，有 <strong>单位元</strong> <span class="math inline"><em>e</em> ≠ 0</span> 的 <strong>交换环</strong><span class="math inline"><em>R</em></span> 称为<strong>整环</strong></p><ul><li><p>整数环 <span class="math inline"><strong>Z</strong></span>，高斯整环 <span class="math inline"><strong>Z</strong>[i]</span>，模 <span class="math inline"><em>m</em></span> 剩余类环 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>，数域<span class="math inline"><strong>F</strong></span> 上的一元多项式环<span class="math inline"><strong>F</strong>[<em>x</em>]</span>都是整环。</p></li><li><p>全体形如 <span class="math display"><strong>Z</strong>[i] = {<em>a</em> + <em>b</em>i ∣ <em>a</em>, <em>b</em> ∈ <strong>Z</strong>}</span></p><p>的复数关于通常数的运算构成一个整环，环 <span class="math inline"><strong>Z</strong>[i]</span> 称为<strong>高斯整环</strong>，单位群为 <span class="math inline"><strong>Z</strong>[i]<sup>×</sup> = {1, −1, i, −i}</span></p></li><li><p>类似地可以证明，对任一无平方因子的整数 <span class="math inline"><em>d</em>(<em>d</em> ≠ 1)</span>，数集 <span class="math display">$$  \mathbf{Z}[\sqrt{d}]=\{a+b \sqrt{d} \mid a,b \in \mathbf{Z}\}  $$</span></p><p>也是整环</p></li></ul><h3 id="域">域</h3><p>设 <span class="math inline"><em>F</em></span> 是一个有<strong>单位元</strong> <span class="math inline">1<sub><em>F</em></sub> ≠ 0</span> 的<strong>交换环</strong>。如果 <span class="math inline"><em>F</em></span> 中<strong>每个非零元都可逆</strong>，则称 <span class="math inline"><em>F</em></span> 是一个<strong>域</strong></p><ul><li>由于可逆元一定不是零因子，所以 <strong>每个域都是整环</strong></li><li>整环却不一定是域，如整数环 <span class="math inline"><strong>Z</strong></span>，高斯整环 <span class="math inline"><strong>Z</strong>[i]</span> 都不是域</li><li><span class="math inline">Q</span>，<span class="math inline">R</span>，<span class="math inline">C</span>都是域，分别称为有理数域、实数域和复数域</li><li>设 <span class="math inline"><em>p</em></span> 是一个素数，则模<span class="math inline"><em>p</em></span> 剩余类环 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub></span>是一个含 有 <span class="math inline"><em>p</em></span>个元素的域，称为<strong>素数域</strong></li></ul><h2 id="理想和商环">理想和商环</h2><h3 id="理想的定义">理想的定义</h3><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的非空子集，如果 <span class="math inline"><em>I</em></span> 满足</p><ul><li>对任意的 <span class="math inline"><em>r</em><sub>1</sub></span>，<span class="math inline"><em>r</em><sub>2</sub> ∈ <em>I</em></span>，<span class="math inline"><em>r</em><sub>1</sub> − <em>r</em><sub>2</sub> ∈ <em>I</em></span></li><li>对任意的 <span class="math inline"><em>r</em> ∈ <em>I</em></span>，<span class="math inline"><em>s</em> ∈ <em>R</em></span>，<span class="math inline"><em>r</em><em>s</em>, <em>s</em><em>r</em> ∈ <em>I</em></span></li></ul><p>则称 <span class="math inline"><em>I</em></span> 为环 <span class="math inline"><em>R</em></span> 的一个<strong>理想</strong> ，记作<span class="math inline"><em>I</em> ⊲ <em>R</em></span>。又如果 <span class="math inline"><em>I</em> ⊊ <em>R</em></span>，则称 <span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的 <strong>真理想</strong></p><ul><li>如果 <span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>I</em></span> 必为 <span class="math inline"><em>R</em></span> 的子环</li><li><span class="math inline">{0}</span> 与 <span class="math inline"><em>R</em></span> 本身显然都是 <span class="math inline"><em>R</em></span> 的理想，这两个理想称为 <span class="math inline"><em>R</em></span> 的 <strong>平凡理想</strong></li><li><span class="math inline">ℤ</span> 的所有理想是 <span class="math inline">{<em>d</em>Z ∣ <em>d</em> ∈ ℤ, <em>d</em> ≥ 0}</span></li><li><span class="math inline">ℤ<sub><em>m</em></sub></span> 的所有理想是<span class="math inline">{<em>d</em>Z<sub><em>m</em></sub> ∣ <em>d</em> = 0或 <em>d</em> ∣ <em>m</em>}</span></li></ul><h3 id="理想的运算">理想的运算</h3><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>I</em></span>，<span class="math inline"><em>J</em></span> 都是 <span class="math inline"><em>R</em></span> 的理想，集合 <span class="math display"><em>I</em> + <em>J</em> = {<em>a</em> + <em>b</em> ∣ <em>a</em> ∈ <em>I</em>, <em>b</em> ∈ <em>J</em>}  与  <em>I</em> ∩ <em>J</em></span></p><p>分别称为理想 <span class="math inline"><em>I</em></span> 与 <span class="math inline"><em>J</em></span> 的<strong>和</strong>与<strong>交</strong></p><ul><li>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>I</em></span>，<span class="math inline"><em>J</em></span> 都是 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>I</em></span> 与 <span class="math inline"><em>J</em></span> 的和与交都是 <span class="math inline"><em>R</em></span> 的理想</li><li>环 <span class="math inline"><em>R</em></span> 的任意<strong>有限</strong> 多个理想的和还是 <span class="math inline"><em>R</em></span> 的理想</li><li>环 <span class="math inline"><em>R</em></span>的任意（<strong>有限或无限</strong> ）多个理想的交还是 <span class="math inline"><em>R</em></span> 的理想</li></ul><h3 id="主理想">主理想</h3><p>设 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，考察<span class="math inline"><em>R</em></span> 中含有元素 <span class="math inline"><em>a</em></span> 的全部理想的集合 <span class="math display"><em>Σ</em> = {<em>I</em> ⊲ <em>R</em> ∣ <em>a</em> ∈ <em>I</em>}</span></p><p>因为 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，且<span class="math inline"><em>R</em> ⊲ <em>R</em></span>，所以 <span class="math inline"><em>R</em> ∈ <em>Σ</em></span>，从而 <span class="math inline"><em>Σ</em></span> 非空。令 <span class="math display">⟨<em>a</em>⟩ = ⋂<sub><em>I</em> ∈ <em>Σ</em></sub><em>I</em></span></p><p>则 <span class="math inline">⟨<em>a</em>⟩</span> 为 <span class="math inline"><em>R</em></span> 的一个理想，这个理想称为 <span class="math inline"><em>R</em></span> 的由 <span class="math inline"><em>a</em></span> 生成的 <strong>主理想</strong></p><ul><li>因为 <span class="math inline"><em>a</em> ∈ <em>I</em>(<em>I</em> ∈ <em>Σ</em>)</span>，所以<span class="math inline"><em>a</em> ∈ ⟨<em>a</em>⟩</span>，从而 <span class="math inline">⟨<em>a</em>⟩ ∈ <em>Σ</em></span></li><li>我们看到：一方面，<span class="math inline">⟨<em>a</em>⟩</span>是包含 <span class="math inline"><em>a</em></span>的理想；另一方面，<span class="math inline">⟨<em>a</em>⟩</span>是所有包含 <span class="math inline"><em>a</em></span> 的理想的交，所以<span class="math inline">⟨<em>a</em>⟩</span> 是 <span class="math inline"><em>R</em></span> 的包含 <span class="math inline"><em>a</em></span> 的最小理想</li></ul><h4 id="主理想的构成">主理想的构成</h4><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>a</em> ∈ <em>R</em></span>，则</p><ul><li>一般地 <span class="math display">$$\langlea\rangle=\left\{\sum_{i=1}^{n} x_{i} a y_{i}+x a+a y+m a \midx_{i},y_{i},x,y \in R,\,n \in \mathbf{N},\,m \in\mathbf{Z}\right\}$$</span></li><li>如果 <span class="math inline"><em>R</em></span> 是有单位元的环，则<span class="math display">$$ \langle a\rangle=\left\{\sum_{i=1}^{n}x_{i} a y_{i} \mid x_{i},y_{i} \in R,\,n \in\mathbf{N}\right\}$$</span></li><li>如果 <span class="math inline"><em>R</em></span> 是交换环，则 <span class="math display">⟨<em>a</em>⟩ = {<em>x</em><em>a</em> + <em>m</em><em>a</em> ∣ <em>x</em> ∈ <em>R</em>, <em>m</em> ∈ <strong>Z</strong>}；</span></li><li>如果 <span class="math inline"><em>R</em></span>是有单位元的交换环，则 <span class="math display">⟨<em>a</em>⟩ = <em>a</em><em>R</em> = {<em>a</em><em>r</em> ∣ <em>r</em> ∈ <em>R</em>}</span></li></ul><p>则有</p><ul><li>整数环 <span class="math inline"><strong>Z</strong></span>的每个理想都是主理想</li><li>模 <span class="math inline"><em>m</em></span> 剩余类环 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>的每个理想都是主理想</li></ul><h3 id="多元理想">多元理想</h3><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub> ∈ <em>R</em></span>，则<span class="math inline">⟨<em>a</em><sub>1</sub>⟩, ⟨<em>a</em><sub>2</sub>⟩, ⋯, ⟨<em>a</em><sub><em>s</em></sub>⟩</span>都是 <span class="math inline"><em>R</em></span> 的理想。令</p><p><span class="math display">⟨<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub>⟩ = ⟨<em>a</em><sub>1</sub>⟩ + ⟨<em>a</em><sub>2</sub>⟩ + ⋯ + ⟨<em>a</em><sub><em>s</em></sub>⟩</span></p><p>则 <span class="math inline">⟨<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub>⟩</span>为 <span class="math inline"><em>R</em></span> 的理想，称为 <span class="math inline"><em>R</em></span> 的由 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub></span>生成的理想。易知，<span class="math inline">⟨<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub>⟩</span>是 <span class="math inline"><em>R</em></span> 的含 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub></span>的最小理想</p><h3 id="商环">商环</h3><p>设 <span class="math inline"><em>R</em></span> 是一个环，<span class="math inline"><em>I</em></span> 是环 <span class="math inline"><em>R</em></span> 的一个理想，则 <span class="math inline">(<em>I</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的子加群，从而 <span class="math inline">(<em>I</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的正规子群，于是有商群：<span class="math display">$$R / I=\{\overline{x}=x+I \mid x \in R\}$$</span></p><p>其加法运算定义为 <span class="math display">$$\overline{x}+\overline{y}=\overline{x+y},\quad x,y \in R$$</span></p><p>定义 <span class="math inline"><em>R</em>/<em>I</em></span> 的乘法：<span class="math display">$$\overline{x} \cdot \overline{y}=\overline{x y},\quad x,y \in R$$</span></p><p>称环 <span class="math inline"><em>R</em>/<em>I</em></span> 为环<span class="math inline"><em>R</em></span> 关于它的理想 <span class="math inline"><em>I</em></span> 的<strong>商环</strong></p><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的理想，则</p><ul><li><span class="math inline">$\overline{0}=I$</span> 为 <span class="math inline"><em>R</em>/<em>I</em></span> 的零元</li><li>如果 <span class="math inline"><em>R</em></span> 有单位元 <span class="math inline"><em>e</em></span>，且 <span class="math inline"><em>e</em> ∉ <em>I</em></span>，则 <span class="math inline"><em>ē</em> = <em>e</em> + <em>I</em></span> 为 <span class="math inline"><em>R</em>/<em>I</em></span> 的单位元</li><li>如果 <span class="math inline"><em>R</em></span> 是交换环，则 <span class="math inline"><em>R</em>/<em>I</em></span> 也是交换环</li></ul><h2 id="环的同态">环的同态</h2><h3 id="环同态的定义">环同态的定义</h3><p>设 <span class="math inline"><em>R</em></span> 和 <span class="math inline"><em>R</em><sup>′</sup></span> 为两个环，<span class="math inline"><em>ϕ</em></span> 是集合 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的映射。如果对任意的<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，有</p><ul><li><span class="math inline"><em>ϕ</em>(<em>a</em> + <em>b</em>) = <em>ϕ</em>(<em>a</em>) + <em>ϕ</em>(<em>b</em>)</span></li><li><span class="math inline"><em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span></li></ul><p>则称 <span class="math inline"><em>ϕ</em></span> 为环 <span class="math inline"><em>R</em></span> 到环 <span class="math inline"><em>R</em><sup>′</sup></span>的一个<strong>同态映射</strong> ，简称<strong>同态</strong></p><ul><li>环同态就是环之间保持运算的映射</li><li>如果 <span class="math inline"><em>ϕ</em></span> 是单映射，则称<span class="math inline"><em>ϕ</em></span> 为单同态</li><li>如果 <span class="math inline"><em>ϕ</em></span> 是满映射，则称<span class="math inline"><em>ϕ</em></span> 为满同态</li><li>如果 <span class="math inline"><em>ϕ</em></span>既是单同态，又是满同态，则称 <span class="math inline"><em>ϕ</em></span>为<strong>同构</strong> ，此时，称环 <span class="math inline"><em>R</em></span> 与 <span class="math inline"><em>R</em><sup>′</sup></span> <strong>同构</strong>，记作 <span class="math inline"><em>ϕ</em> : <em>R</em> ≅ <em>R</em><sup>′</sup></span></li><li>与群的相应概念类似，环的同构是环之间的一个等价关系，并且从环的观点来看，同构的环有完全相同的代数性质</li></ul><h4 id="零同态">零同态</h4><p>设 <span class="math inline"><em>R</em></span> 与 <span class="math inline"><em>R</em><sup>′</sup></span> 是两个环，对任意的<span class="math inline"><em>a</em> ∈ <em>R</em></span>，令 <span class="math display">$$\begin{aligned}\phi: R &amp;\longrightarrow R^{\prime},\\\ a &amp;\longmapsto 0\end{aligned}$$</span></p><p>则对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>， <span class="math display">$$\begin{aligned}\phi(a+b) &amp; =0=\phi(a)+\phi(b),\\\phi(a b) &amp; =0=\phi(a) \phi(b)\end{aligned}$$</span></p><p>所以 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span>的一个同态，这个同态称为 <strong>零同态</strong></p><h4 id="自然同态">自然同态</h4><p>设 <span class="math inline"><em>R</em></span> 是环，<span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的理想。对任意的 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，令</p><p><span class="math display">$$\begin{aligned}\eta:R &amp; \longrightarrow R / I,\\a &amp; \longmapsto \bar{a}\end{aligned}$$</span></p><p>则 <span class="math inline"><em>η</em></span> 为 <span class="math inline"><em>R</em></span> 到它的商环 <span class="math inline"><em>R</em>/<em>I</em></span> 的满映射。又对任意的<span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em> ∈ <em>R</em></span>，</p><p><span class="math display">$$\begin{aligned}\eta(a+b) &amp;=\overline{a+b}=\bar{a}+\bar{b}=\eta(a)+\eta(b),\\\eta(a b) &amp; =\overline{a b}=\bar{a} \bar{b}=\eta(a) \eta(b)\end{aligned}$$</span></p><p>所以 <span class="math inline"><em>η</em></span> 为 <span class="math inline"><em>R</em></span> 到它的商环 <span class="math inline"><em>R</em>/<em>I</em></span>的一个<strong>满同态</strong>，这个同态称为<strong>自然同态</strong></p><h3 id="环同态的性质">环同态的性质</h3><ul><li><p>设 <span class="math inline"><em>ϕ</em></span> 是环 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的同态，则对任意的<span class="math inline"><em>a</em> ∈ <em>R</em></span></p><ul><li><span class="math inline"><em>ϕ</em>(0<sub><em>R</em></sub>) = 0<sub><em>R</em><sup>′</sup></sub></span></li><li><span class="math inline"><em>ϕ</em>(<em>n</em><em>a</em>) = <em>n</em><em>ϕ</em>(<em>a</em>),  ∀<em>n</em> ∈ <strong>Z</strong></span></li><li><span class="math inline"><em>ϕ</em>(<em>a</em><sup><em>n</em></sup>) = (<em>ϕ</em>(<em>a</em>))<sup><em>n</em></sup>,  ∀<em>n</em> ∈ <strong>N</strong></span></li></ul></li><li><p>设 <span class="math inline"><em>R</em></span> 与 <span class="math inline"><em>R</em><sup>′</sup></span>都是有单位元的环，<span class="math inline"><em>e</em></span> 与 <span class="math inline"><em>e</em><sup>′</sup></span>分别是它们的单位元，<span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的环同态</p><ul><li>如果 <span class="math inline"><em>ϕ</em></span> 是满同态，则 <span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span></li><li>如果 <span class="math inline"><em>R</em><sup>′</sup></span>为无零因子环，且 <span class="math inline"><em>ϕ</em>(<em>e</em>) ≠ 0</span>，则 <span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span></li><li>如果 <span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span>，则对<span class="math inline"><em>R</em></span> 的任一单位 <span class="math inline"><em>u</em></span>，<span class="math inline"><em>ϕ</em>(<em>u</em>)</span> 是 <span class="math inline"><em>R</em><sup>′</sup></span> 的单位，且 <span class="math inline">(<em>ϕ</em>(<em>u</em>))<sup>−1</sup> = <em>ϕ</em>(<em>u</em><sup>−1</sup>)</span></li></ul></li></ul><h3 id="核-1">核</h3><p>设 <span class="math inline"><em>ϕ</em></span> 为环 <span class="math inline"><em>R</em></span> 到环 <span class="math inline"><em>R</em><sup>′</sup></span> 的同态映射，称集合<span class="math display"><em>K</em> = {<em>a</em> ∈ <em>R</em> ∣ <em>ϕ</em>(<em>a</em>) = 0}</span></p><p>为环同态 <span class="math inline"><em>ϕ</em></span>的<strong>核</strong> ，记作 <span class="math inline">Ker <em>ϕ</em></span>，且 <span class="math inline">Ker <em>ϕ</em></span> 为 <span class="math inline"><em>R</em></span> 的理想。</p><h3 id="环同态基本定理">环同态基本定理</h3><p>设 <span class="math inline"><em>ϕ</em></span> 是环 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的满同态，则有环同构<span class="math display"><em>ϕ̃</em> : <em>R</em>/Ker <em>ϕ</em> ≅ <em>R</em><sup>′</sup></span></p><h3 id="环的第二同构定理">环的第二同构定理</h3><p>设 <span class="math inline"><em>S</em></span> 为 <span class="math inline"><em>R</em></span> 的子环，<span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>S</em> ∩ <em>I</em></span> 是 <span class="math inline"><em>S</em></span> 的理想且 <span class="math display"><em>S</em>/(<em>S</em> ∩ <em>I</em>) ≅ (<em>S</em> + <em>I</em>)/<em>I</em></span></p><h3 id="环的第三同构定理">环的第三同构定理</h3><p>设 <span class="math inline"><em>R</em></span> 是环，<span class="math inline"><em>I</em></span> 和 <span class="math inline"><em>J</em></span> 都是 <span class="math inline"><em>R</em></span> 的理想，且 <span class="math inline"><em>I</em> ⊆ <em>J</em></span>。则有环同构 <span class="math display">(<em>R</em>/<em>I</em>)/(<em>J</em>/<em>I</em>) ≅ <em>R</em>/<em>J</em></span></p><h2 id="素理想和极大理想">素理想和极大理想</h2><h3 id="素理想">素理想</h3><p>设 <span class="math inline"><em>R</em></span> 是一个交换环，<span class="math inline"><em>P</em></span> 是 <span class="math inline"><em>R</em></span> 的真理想。如果对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，由 <span class="math inline"><em>a</em><em>b</em> ∈ <em>P</em></span>，可推出<span class="math inline"><em>a</em> ∈ <em>P</em></span> 或 <span class="math inline"><em>b</em> ∈ <em>P</em></span>，则称 <span class="math inline"><em>P</em></span> 为 <span class="math inline"><em>R</em></span> 的一个<strong>素理想</strong></p><ul><li><span class="math inline"><strong>Z</strong></span> 的全部素理想为<span class="math display">⟨<em>p</em>⟩  以及  {0}</span></li><li>设 <span class="math inline"><em>R</em></span> 是有单位元 <span class="math inline"><em>e</em> ≠ 0</span> 的交换环，<span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的素理想的充分必要条件是 <span class="math inline"><em>R</em>/<em>I</em></span> 是整环</li></ul><h3 id="极大理想">极大理想</h3><p>设 <span class="math inline"><em>R</em></span> 是一个交换环，<span class="math inline"><em>M</em></span> 是 <span class="math inline"><em>R</em></span> 的真理想。如果对 <span class="math inline"><em>R</em></span> 的任一包含 <span class="math inline"><em>M</em></span> 的理想 <span class="math inline"><em>N</em></span>，必有 <span class="math inline"><em>N</em> = <em>M</em></span> 或 <span class="math inline"><em>N</em> = <em>R</em></span>，则称 <span class="math inline"><em>M</em></span> 为 <span class="math inline"><em>R</em></span>的一个<strong>极大理想</strong></p><ul><li><p>设 <span class="math inline"><em>R</em></span> 是有单位元 <span class="math inline"><em>e</em></span> 的交换环，<span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的极大理想的充分必要条件是 <span class="math inline"><em>R</em>/<em>I</em></span> 是域</p></li><li><p>设 <span class="math inline"><em>R</em></span>是一个有单位元的交换环，则 <span class="math inline"><em>R</em></span>的每个极大理想都是素理想</p><ul><li>若没有单位元，则不一定成立</li><li>素理想不一定是极大理想</li></ul></li></ul><h3 id="中国剩余定理">中国剩余定理</h3><p>如果 <span class="math inline"><em>I</em></span> 和 <span class="math inline"><em>J</em></span> 是包含单位元 <span class="math inline">1</span> 的交换环 <span class="math inline"><em>R</em></span> 的两个理想，满足 <span class="math inline"><em>I</em> + <em>J</em> = <em>R</em></span>，则有</p><ol type="1"><li><span class="math inline"><em>I</em> ∩ <em>J</em> = <em>I</em><em>J</em></span></li><li><span class="math inline"><em>R</em>/<em>I</em><em>J</em> ≅ <em>R</em>/<em>I</em> × <em>R</em>/<em>J</em></span></li></ol><h2 id="环的特征与素域">环的特征与素域</h2><h3 id="特征">特征</h3><h4 id="特征的定义">特征的定义</h4><p>设 <span class="math inline"><em>R</em></span>为环，如果存在最小的正整数 <span class="math inline"><em>n</em></span>，使得对所有的 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，有 <span class="math inline"><em>n</em><em>a</em> = 0</span>，则称 <span class="math inline"><em>n</em></span> 为环 <span class="math inline"><em>R</em></span> 的 <strong>特征</strong>。如果这样的正整数不存在，则称环 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline">0</span>。环 <span class="math inline"><em>R</em></span> 的特征记作 <span class="math inline">Char <em>R</em></span>。</p><ul><li><span class="math inline"><strong>Z</strong>, <strong>Q</strong>, <strong>R</strong>, <strong>C</strong></span>的特征都等于 <span class="math inline">0</span></li><li>一般地，如果 <span class="math inline"><em>R</em></span>是一个数环，则 <span class="math inline">Char <em>R</em> = 0</span></li><li>设 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span> 是模<span class="math inline"><em>m</em></span> 剩余类环，则对每个 <span class="math inline"><em>n̄</em> ∈ <strong>Z</strong><sub><em>m</em></sub></span>，有<span class="math display">$$  m \bar{n}=\overline{m n}=\overline{0}  $$</span> 而对于任何正整数 <span class="math inline"><em>k</em> &lt; <em>m</em></span>，有 <span class="math display">$$  k \overline{1}=\bar{k} \neq \overline{0}  $$</span> 所以 <span class="math inline">Char <strong>Z</strong><sub><em>m</em></sub> = <em>m</em></span></li><li>对于 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>上的一元多项式环 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub>[<em>x</em>]</span>，也有<span class="math inline">Char <strong>Z</strong><sub><em>m</em></sub>[<em>x</em>] = <em>m</em></span></li><li>一个有限环的特征是一个正整数</li></ul><h4 id="特征的性质">特征的性质</h4><ul><li><p>设 <span class="math inline"><em>R</em></span> 是有单位元 <span class="math inline"><em>e</em></span> 的环，如果 <span class="math inline"><em>e</em></span> 关于加法的阶为无穷大，那么 <span class="math inline"><em>R</em></span> 的特征等于 <span class="math inline">0</span>。如果 <span class="math inline"><em>e</em></span> 关于加法的阶等于 <span class="math inline"><em>n</em></span>，那么 <span class="math inline">Char <em>R</em> = <em>n</em></span>。</p></li><li><p>整环的特征是 <span class="math inline">0</span>或者是一个素数，域同理。</p></li><li><p>设 <span class="math inline"><em>R</em></span> 是有单位元 <span class="math inline"><em>e</em></span> 的环，则映射 <span class="math display">$$  \begin{aligned}  \phi:\mathbf{Z} &amp; \longrightarrow R,\\  n &amp; \longmapsto n e  \end{aligned}  $$</span></p><p>是环 <span class="math inline"><strong>Z</strong></span> 到 <span class="math inline"><em>R</em></span> 的同态</p></li><li><p>设 <span class="math inline"><em>R</em></span> 是有单位元的环</p><ul><li>如果 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline"><em>n</em> &gt; 0</span>，则 <span class="math inline"><em>R</em></span> 包含一个与 <span class="math inline"><strong>Z</strong><sub><em>n</em></sub></span>同构的子环 <span class="math inline"><em>R</em><sup>′</sup> = {<em>m</em><em>e</em> ∣ <em>m</em> ∈ <strong>Z</strong>}</span></li><li>如果 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline">0</span>，则 <span class="math inline"><em>R</em></span> 包含一个与 <span class="math inline"><strong>Z</strong></span> 同构的子环 <span class="math inline"><em>R</em><sup>′</sup> = {<em>m</em><em>e</em> ∣ <em>m</em> ∈ <strong>Z</strong>}</span></li></ul></li><li><p>设 <span class="math inline"><em>F</em></span> 是域</p><ul><li>如果 <span class="math inline"><em>F</em></span> 的特征是 <span class="math inline">0</span>，则 <span class="math inline"><em>F</em></span> 包含一个与有理数域 <span class="math inline"><strong>Q</strong></span> 同构的子域</li><li>如果 <span class="math inline"><em>F</em></span> 的特征是素数 <span class="math inline"><em>p</em></span>，则 <span class="math inline"><em>F</em></span> 包含一个与模 <span class="math inline"><em>p</em></span> 剩余类环 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub></span>同构的子域</li></ul></li></ul><h3 id="素域">素域</h3><ul><li><p>一个域 <span class="math inline"><em>F</em></span>如果不含任何真子域，则称 <span class="math inline"><em>F</em></span>是一个<strong>素域</strong></p></li><li><p>设 <span class="math inline"><em>F</em></span> 是个域</p><ul><li>如果 <span class="math inline">Char <em>F</em> = 0</span>，那么<span class="math inline"><em>F</em></span> 包含一个与 <span class="math inline"><strong>Q</strong></span> 同构的素域</li><li>如果 <span class="math inline">Char <em>F</em> = <em>p</em> &gt; 0</span>，那么<span class="math inline"><em>F</em></span> 包含一个与 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub></span>同构的素域</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 数学 </category>
          
          <category> 信安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 抽象代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马克思主义基本原理</title>
      <link href="/_posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/_posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="导论">导论</h1><h2 id="一什么是马克思主义">一、什么是马克思主义</h2><ul><li>马克思主义是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系，是关于自然、社会和人类思维发展一般规律的学说，是关于社会主义必然代替资本主义、最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，是无产阶级政党和社会主义国家的指导思想，是指引人们创造美好生活的行动指南。</li><li>马克思主义理论体系基本组成部分：<strong>马克思主义哲学、马克思主义政治经济学、科学社会主义</strong>。</li></ul><h2 id="二马克思主义的创立与发展">二、马克思主义的创立与发展</h2><ul><li>马克思主义产生于19世纪40年代，创始人是<strong>马克思和恩格斯</strong>。</li><li><strong>德国古典哲学、英国古典政治经济学、英法空想社会主义</strong>为马克思主义的创立提供了直接的理论来源。</li><li>《<strong>德意志意识形态</strong>》首次系统阐述了历史唯物主义的基本观点，实现了历史观上的伟大变革。</li><li>1848年3月《<strong>共产党宣言</strong>》发表，标志着马克思主义的公开问世。</li><li>《<strong>资本论</strong>》系统阐述了剩余价值学说，揭示了资本主义生产关系的秘密。</li><li><strong>唯物史观</strong>和<strong>剩余价值学说</strong>是马克思一生的两个伟大发现。</li><li>列宁深刻分析了19世纪末20世纪初世界历史条件的变化，认为资本主义发达国家已经发展到帝国主义阶段，经济政治发展的不平衡已成为资本主义发展的绝对规律。</li><li>1917年，列宁和布尔什维克党领导俄国工人阶级和革命人民夺取了十月社会主义革命的胜利，使社会主义从理想开始变为现实，从而开创了世界历史的新纪元。</li><li>列宁把马克思主义基本原理与俄国实际相结合，创立了列宁主义，把马克思主义发展到一个新的历史阶段。</li></ul><h2 id="三马克思主义的基本特征">三、马克思主义的基本特征</h2><ul><li>科学性、人民性、实践性、发展性</li><li>马克思主义的世界观和方法论基础：辩证唯物主义和历史唯物主义</li><li>马克思主义的政治立场：人民至上</li><li>马克思主义的基本特征：科学性与革命性的统一。革命性是马克思主义的内在品质，是人民性、实践性、发展性的应有之义和必然要求</li></ul><h2 id="四马克思主义的当代价值不考">四、马克思主义的当代价值（不考）</h2><h2 id="五自觉学习和运用马克思主义不考">五、自觉学习和运用马克思主义（不考）</h2><h1 id="第一章-世界的物质性及其发展规律">第一章世界的物质性及其发展规律</h1><h2 id="第一节-世界的多样性与物质统一性">第一节世界的多样性与物质统一性</h2><ol type="1"><li>哲学基本问题<ul><li>一是存在和思维、物质和意识谁为本原的问题，即何者为第一性的问题。<strong>划分唯物主义和唯心主义</strong></li><li>二是存在和思维、物质和意识是否具有同一性的问题，即思维能否正确地反映存在、人能否认识或彻底认识世界的问题。<strong>划分可知论和不可知论</strong></li></ul></li><li>唯物主义<ul><li>古代朴素唯物主义：合理性和进步性</li><li>近代形而上学唯物主义：直观性和朴素性</li></ul></li><li>马克思主义的物质范畴具有丰富而深刻的理论意义<ul><li>第一，坚持了<strong>唯物主义一元论</strong>，同唯心主义一元论和二元论划清了界限。</li><li>第二，坚持了<strong>能动的反映论和可知论</strong>，批判了不可知论。</li><li>第三，体现了<strong>唯物论和辩证法的统一</strong>，克服了形而上学唯物主义的缺陷。</li><li>第四，体现了<strong>唯物主义自然观与历史观的统一</strong>，为彻底的唯物主义奠定了理论基础。</li></ul></li><li>马克思主义的物质观<ol type="1"><li>物质的存在方式<ul><li>物质是指不依赖于人的意识又能为人的意识所反映的客观实在。</li><li><strong>客观实在性</strong>是物质的唯一特性。</li><li>物质的<strong>根本属性是运动</strong>。运动是标志一切事物和现象的变化及其过程的哲学范畴。</li><li>物质世界的运动是绝对的，而物质在运动过程中有暂时的静止。</li><li>相对静止是物质运动在一定条件下的稳定状态。</li><li>时间和空间是运动着的物质的基本存在形式：<ul><li>时间是物质运动的持续性、顺序性，特点是一维性。</li><li>空间是物质运动的广延性、伸张性，特点是三维性。</li></ul></li></ul></li><li>物质世界的<strong>二重化</strong>：人的实践活动是自然界与人类社会、客观世界与主观世界相分化的关键，也是他们相统一的关键。<ul><li>自然界和人类社会<ul><li>区别：自然界中一切自发产生；人类社会是人有目的的实践的结果。</li><li>联系：自然界中有“人化自然”；社会中有自然物质和自然力的运用，物质生产本身也是人与自然的物质能量的交换。</li></ul></li><li>客观世界与主观世界<ul><li>区别：客观世界不依赖于思想意识而存在，包括自然界和人类社会。主观世界是人的头脑反映和把握物质世界的精神活动的总和。</li><li>联系：主观世界是对客观世界的反映，并反作用于客观世界。</li></ul></li></ul></li></ol></li><li>物质与意识的辩证关系<ol type="1"><li><strong>物质决定意识</strong>：<ul><li>起源：意识是自然界长期发展的产物。意识是社会历史的产物，劳动在意识的产生和发展中起着决定性作用。</li><li>本质：意识是人脑的机能和属性，是物质世界的主观映象。意识在内容上是客观的，在形式上是主观的，是客观内容和主观形式的统一。</li></ul></li><li>意识对物质具有反作用：意识的能动作用：<ul><li>意识具有目的性和计划性。</li><li>意识具有创造性。</li><li>意识具有指导实践改造客观世界的作用。</li><li>意识具有调控人的行为和生理活动的作用。</li></ul></li><li><strong>主观能动性和客观规律性的辩证统一</strong><ul><li>主观能动性与客观规律性的辩证关系：<ul><li>尊重客观规律是正确发挥主观能动性的前提。</li><li>只有充分发挥主观能动性，才能正确认识和利用客观规律。</li></ul></li><li>正确发挥人的主观能动性的前提和条件：<ul><li>第一，从实际出发是正确发挥人的主观能动性的前提。</li><li>第二，实践是正确发挥人的主观能动性的根本途径。</li><li>第三，正确发挥人的主观能动性，还要依赖于一定的物质条件和物质手段。</li></ul></li><li>坚持遵循客观规律与发挥主观能动性相统一，要求充分发扬历史主动精神。</li></ul></li><li>意识与人工智能<ul><li>人工智能不可能取代或超越人类<ul><li>人类意识是<strong>知情意的统一</strong>，而人工智能只能是人类的理性智能的模拟和扩展，不具备情感、信念、意志等人类意识形式。</li><li><strong>社会性</strong>是人的意识所固有的本质属性，而人工智能不可能真正具备人类的社会属性。</li><li>人类的<strong>自然语言</strong>是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义上的能力。</li><li>人工智能能够获得人类意识中可以化约为数字信号的内容，但是人脑中总有许多东西无法被化约。</li></ul></li></ul></li></ol></li><li>世界的物质统一性：世界的统一性在于他的物质性，世界统一于物质。<ul><li>第一，自然界是物质的。</li><li>第二，人类社会本质上是生产实践基础上形成的物质体系。</li><li>第三，人的意识统一于物质。</li></ul></li></ol><h2 id="第二节-事物的普遍联系和变化发展">第二节事物的普遍联系和变化发展</h2><ol type="1"><li><strong>联系和发展的观点是唯物辩证法的总观点</strong>，集中体现了唯物辩证法的总特征。</li><li>联系是指事物内部各要素之间和事物之间相互影响、相互制约和相互作用的关系。</li><li>联系的特点：<ul><li>首先，联系具有<strong>客观性</strong>。</li><li>其次，联系具有<strong>普遍性</strong>。<ul><li>其一，任何事物内部的不同部分和要素之间都是相互联系的。</li><li>其二，任何事物都不能孤立存在，都同其他事物处于一定的联系之中。</li><li>其三，整个世界是相互联系的统一整体。</li></ul></li><li>再次，联系具有<strong>多样性</strong>。<ul><li>直接联系与间接联系</li><li>内部联系与外部联系</li><li>本质联系与非本质联系</li><li>必然联系与偶然联系</li></ul></li><li>最后，联系具有<strong>条件性</strong>。</li></ul></li><li><strong>发展的实质</strong>：物质世界的发展，特别是人类社会的发展，其实质是新事物的产生和旧事物的灭亡。新事物是指合乎历史前进方向、具有远大前途的东西；旧事物是指丧失历史必然性、日趋灭亡的东西。在新陈代谢的发展过程中，新事物是不可战胜的。新事物在本质上优越于旧事物，具有强大生命力。</li><li>唯物辩证法揭示了事物变化发展的一般规律，即<strong>对立统一规律、量变质变规律和否定之否定规律</strong>，其中对立统一规律是根本规律，是唯物辩证法的实质和核心。</li><li>对立统一规律<ol type="1"><li>矛盾的同一性和斗争性<ul><li>矛盾的含义：矛盾是反映事物内部和事物之间<strong>对立统一</strong>关系的哲学范畴。对立和统一分别体现了矛盾的两种基本属性。</li><li>矛盾的<strong>同一性</strong>是指矛盾着的对立面相互依存、相互贯通的性质和趋势。</li><li>矛盾的同一性的含义：<ul><li>一是矛盾着的对立面相互依存、互为存在的前提，并共处于一个统一体中。</li><li>二是矛盾着的对立面相互贯通，在一定条件下可以相互转化。</li></ul></li><li>矛盾的<strong>斗争性</strong>是矛盾着的对立面之间相互排斥、相互分离的性质和趋势。</li><li>矛盾可以分为<strong>对抗性矛盾和非对抗性矛盾</strong>两种基本形式。</li><li>矛盾的同一性和斗争性相互联结、相辅相成。</li><li>矛盾的同一性在事物发展中的作用：<ul><li>第一，同一性是事物存在和发展的前提。</li><li>第二，同一性使矛盾双方相互吸取有利于自身的因素，在相互作用中各自得到发展。</li><li>第三，同一性规定着事物转化的可能和发展的趋势。</li></ul></li><li>矛盾的斗争性在事物发展中的作用：<ul><li>第一，矛盾双方的斗争促进矛盾双方力量的变化，造成双方力量发展的不平衡，为对立面的转化、事物的质变创造条件。</li><li>第二，矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过渡的决定性力量。</li></ul></li><li>矛盾的同一性和斗争性辩证关系原理要求我们在观察和处理问题时，必须善于把二者结合起来，在斗争性中把握同一性，在同一性中把握斗争性。运用矛盾的同一性和斗争性辩证关系原理指导实践，要正确把握和谐对事物发展的作用，还要大力发扬斗争精神。</li></ul></li><li>矛盾的普遍性和特殊性<ul><li>矛盾的<strong>普遍性</strong>：矛盾存在于一切事物中，存在于一切事物发展过程的始终</li><li>矛盾的<strong>特殊性</strong>：各个具体事物的矛盾、每一个矛盾的各个方面在发展的不同阶段上各有其特点。<ul><li>一是<strong>不同事物的矛盾</strong>各有其特点。</li><li>二是同一事物的矛盾在<strong>不同发展过程和发展阶段</strong>各有不同特点。</li><li>三是构成事物的诸多矛盾以及每一矛盾的<strong>不同方面</strong>各有不同的性质、地位和作用。</li></ul></li><li>把主要矛盾和次要矛盾、矛盾的主要方面和次要方面的辩证关系运用到实际工作中，就是要坚持“两点论”和“重点论”的统一。<ul><li>“<strong>两点论</strong>”是指在分析事物的矛盾时，不仅要看到矛盾双方的<strong>对立</strong>，而且要看到矛盾双方的<strong>统一</strong>；不仅要看到矛盾体系中存在<strong>主要矛盾</strong>、<strong>矛盾的主要方面</strong>，而且要看到<strong>次要矛盾</strong>、<strong>矛盾的次要方面</strong>。</li><li>“<strong>重点论</strong>”是指要着重把握主要矛盾、矛盾的主要方面，并以此作为解决问题的出发点。</li></ul></li><li>矛盾普遍性与矛盾特殊性是辩证统一的关系。矛盾的普遍性即矛盾的共性，矛盾的特殊性即矛盾的个性。</li><li>矛盾的共性和个性、绝对和相对的道理，是关于事物矛盾问题的精髓。</li><li>矛盾的普遍性和特殊性辩证关系原理是马克思主义基本原理同各国实际相结合的哲学基础，也是建设中国特色社会主义的哲学基础。</li></ul></li></ol></li><li>量变质变规律<ul><li>量变质变规律体现了事物发展的渐进性和飞跃性的统一。</li><li>质：一事物区别于其他事物的内在规定性。</li><li>量：事物的规模、程度、速度等可以用数量关系表示的规定性。</li><li>度：保持事物质的稳定性的数量界限。</li><li>量变：事物数量的增减和组成要素排列次序的变动，是保持事物的质的相对稳定性的不显著变化，体现了事物发展渐进过程的连续性。</li><li>质变：事物性质的根本变化，是事物由一种质态向另一种质态的飞跃，体现了事物发展渐进过程和连续性的中断。</li><li>量变和质变的辩证关系：<ul><li>第一，量变是质变的<strong>必要准备</strong>。</li><li>第二，质变是量变的<strong>必然结果</strong>。</li><li>第三，量变和质变是<strong>相互渗透</strong>的。</li></ul></li><li>量变质变规律的方法论意义：<ul><li>一方面，当事物的发展处在量变阶段时，要踏踏实实做好日常工作，为未来重大改变做准备；</li><li>另一方面，当质变来临的时候，要果断地、不失时机地抓住机遇，促成质变，使工作迈上新台阶。</li></ul></li></ul></li><li>否定之否定规律<ul><li>否定之否定规律揭示了事物发展的前进性和曲折性的统一。</li><li>肯定因素是维持现存事物存在的因素，否定因素是促使现存事物灭亡的因素。</li><li>辩证否定观（否定的深刻内涵）：<ul><li>第一，否定是<strong>事物的自我否定、自我发展</strong>，是事物内部矛盾运动的结果。</li><li>第二，否定是<strong>事物发展的环节</strong>，是旧事物向新事物的转变，是从旧质到新质的飞跃。</li><li>第三，否定是<strong>新旧事物联系的环节</strong>，新事物孕育产生于旧事物。</li><li>第四，辩证否定的实质是“<strong>扬弃</strong>”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素。</li></ul></li><li>否定之否定：肯定→否定→否定之否定<ul><li>第一次否定使矛盾得到初步解决，而处于否定阶段的事物仍然具有片面性。</li><li>第二次否定实现了对立面的统一，使矛盾得到根本解决。</li></ul></li><li>事物的发展呈现出周期性，不同周期的交替使事物的发展呈现出波浪式前进或螺旋式上升的总趋势。</li></ul></li><li>内容与形式<ul><li>内容指构成事物的一切要素的总和，形式指把诸要素统一起来的结构或表现内容的方式。</li><li>任何事物都是内容与形式的统一。<ul><li>一方面，内容是事物存在的基础，对形式具有决定作用。</li><li>另一方面，形式对内容具有反作用。</li></ul></li></ul></li><li>本质与现象<ul><li>本质是事物的根本性质，是构成事物的诸要素之间的内在联系。</li><li>现象是事物的外部联系和表面特征，是事物本质的外在表现。现象可以区分为真象和假象。</li></ul></li><li>原因与结果<ul><li>在事物的普遍联系中，引起某种现象的现象就是原因，被某种现象引起的现象就是结果。</li></ul></li><li>必然与偶然<ul><li>必然是指事物联系与发展中确定不移的趋势，在一定条件下具有不可避免性。</li><li>偶然是指事物联系与发展中不确定的趋势。</li></ul></li><li>现实与可能<ul><li>现实是指相互联系着的实际存在的事物的综合。</li><li>可能是指包含在事物中、预示事物发展前途的种种趋势。</li></ul></li></ol><h2 id="第三节-唯物辩证法是认识世界和改造世界的根本方法不考">第三节唯物辩证法是认识世界和改造世界的根本方法（不考）</h2><h1 id="第二章-实践与认识及其发展规律">第二章实践与认识及其发展规律</h1><h2 id="第一节-实践与认识">第一节 实践与认识</h2><ol type="1"><li>科学实践观及其意义<ul><li>第一，克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础。</li><li>第二，揭示了实践对认识的决定作用，为能动的、革命的反映论的创立奠定了科学的理论基础。</li><li>第三，在人类思想史上第一次揭示了社会生活的实践本质，为唯物史观的创立奠定了科学的理论基础。</li><li>第四，为人们能动地认识世界和改造世界提供了基本的思想方法和工作方法。</li></ul></li><li>实践的本质：<strong>实践是人类能动地改造世界的社会性的物质活动</strong>。</li><li>实践的基本特征：<strong>客观实在性、自觉能动性、社会历史性</strong>。</li><li>实践的基本结构：<ul><li>第一，<strong>实践主体</strong>，指具有一定的主体能力、从事现实社会实践活动的人。<ul><li>能力：自然能力、精神能力（知识性因素、非知识性因素）。</li><li>基本形态：个体主体、群体主体、人类主体。</li></ul></li><li>第二，<strong>实践客体</strong>，指实践活动所指向的对象。<ul><li>是否为实践所创造：天然客体和人工客体；</li><li>自然界与人类社会两个领域相区分：自然客体与社会客体；</li><li>物质性和精神性相区分：物质性客体和精神性客体。</li></ul></li><li>第三，<strong>实践中介</strong>。<ul><li>子系统：物质性工具系统、语言符号工具系统。</li></ul></li></ul></li><li>实践的主体和客体相互作用的关系：<strong>实践关系</strong>（最根本的关系）、认识关系、价值关系。</li><li>主体和客体相互作用：双向运动<ul><li><strong>主体客体化</strong>：人通过实践使自己的本质力量作用于客体，使其按照主体的需要发生结构和功能上的变化，形成了世界上本来不存在的对象物。</li><li><strong>客体主体化</strong>：客体从客观对象的存在形式转化为主体生命结构的因素或主体本质力量的因素，客体失去客体性的形式，变成主体的一部分。</li></ul></li><li>实践的形式：<ul><li>一是<strong>物质生产实践</strong>。（最基本的实践活动）（制约其他两种实践并受其产生能动的反作用）</li><li>二是社会政治实践。</li><li>三是科学文化实践。</li><li>四是虚拟实践。</li></ul></li><li>实践对认识的决定作用：<ul><li>第一，实践是认识的<strong>来源</strong>。</li><li>第二，实践是认识<strong>发展的动力</strong>。</li><li>第三，实践是认识的<strong>目的</strong>。</li><li>第四，实践是<strong>检验</strong>认识真理性的唯一标准。</li></ul></li><li>认识是主体在实践基础上对客体的能动反映，这是辩证唯物主义认识论对认识本质的科学回答。</li><li>不同的认识路线：<ul><li>唯物主义反映论：<strong>从物到感觉和思想</strong><ul><li>旧唯物主义：离开实践考察认识问题，因而不了解实践对认识的决定作用；离开辩证法来考察认识问题，因而把复杂的认识过程简单化，把认识运动凝固化，把多方面的认识要素片面化。</li><li><strong>辩证唯物主义认识论是建立在实践基础上的能动的反映论</strong>。</li></ul></li><li>唯心主义先验论：<strong>从思想和感觉到物</strong></li></ul></li><li>辩证唯物主义认识论特点：<ul><li>一是把实践的观点引入认识论。</li><li>二是把辩证法应用于反映论考察认识的发展过程。</li></ul></li><li>反映和创造不是人类认识的两种不同的本质，而是同一本质的两个不同的方面。<ul><li>其一，创造离不开反映，创造存在于反映之中，创造过程是在相互联系的多个方面的反映基础上实现的。</li><li>其二，反映也离不开创造，反映是在创造过程中实现的。</li></ul></li><li>人们认识事物的过程，是一个<strong>从实践到认识，再从认识到实践</strong>的过程。<ul><li>认识运动的第一次飞跃：从实践到认识，从生动的直观到抽象的思维，由感性认识能动地飞跃到理性认识<ul><li>感性认识包括感觉、知觉、表象。</li><li>理性认识包括概念、判断、推理。</li><li>感性认识和理性认识的关系是辩证统一的：<ul><li>第一，理性认识依赖于感性认识。</li><li>第二，感性认识有待于发展和深化为理性认识。</li><li>第三，感性认识和理性认识相互渗透、相互包含。</li></ul></li></ul></li><li>认识运动的第二次飞跃：从认识到实践<ul><li>必要性和重要性：<ul><li>第一，认识世界的目的是改造世界。</li><li>第二，认识的真理性只有在实践中才能得到检验和发展。</li></ul></li></ul></li></ul></li></ol><h2 id="第二节-真理与价值">第二节 真理与价值</h2><ol type="1"><li>真理<ol type="1"><li><strong>客观性（本质属性）</strong>：对客观事物及其规律的正确反映，包含着不依赖于人和人的意识的客观内容。<ul><li>真理的客观性决定了真理的一元性，即在同一条件下对于特定的认识客体的真理性认识只有一个。</li><li>真理是<strong>内容上的一元性与形式上的多样性</strong>的统一。</li></ul></li><li>真理的<strong>绝对性和相对性</strong><ul><li>真理的绝对性：真理主客观统一的确定性和发展的无限性。</li><li>真理的相对性：人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的、不完善的。</li><li>真理的绝对性和相对性辩证统一。真理的绝对性与相对性根源于人类认识世界能力的无限性与有限性、绝对性与相对性的矛盾。</li></ul></li><li>真理与谬误<ul><li>谬误指同客观事物及其发展规律相违背的认识，是对客观事物及其发展规律的歪曲反映。</li><li>真理与谬误既对立又统一：<ul><li>第一，真理与谬误相互对立。真理和谬误有着原则界线。</li><li>第二，真理与谬误的对立又是相对的，它们在一定条件下能够相互转化。首先，真理在一定条件下会转化为谬误。其次，谬误在一定条件下能够向真理转化。</li></ul></li><li>真理和谬误的对立统一关系表明，真理总是同谬误相比较而存在、相斗争而发展的。</li></ul></li></ol></li><li><strong>实践是检验真理的唯一标准</strong>，是由真理的本性和实践的特点所决定的。<ul><li>第一，从真理的本性看，真理是人们对客观事物及其发展规律的正确反映，它的本性在于主观和客观相符合。</li><li>第二，从实践的特点来看，<strong>实践具有直接现实性</strong>。</li></ul></li><li>实践标准是确定性与不确定性的统一。<ul><li>实践标准的确定性即绝对性，是指实践作为检验真理标准的唯一性、归根到底性、最终性，由实践标准的客观性和唯一性所决定。</li><li>实践标准的不确定性即相对性，是指实践作为检验真理标准的条件性。</li></ul></li><li>价值是<strong>反映主客体之间意义关系</strong>的哲学范畴，是客体对个人群体乃至整个社会的生活和活动所具有的意义。价值离不开主体的需要和客体的特性，既有主体性特征又有客观基础。</li><li>价值的基本特征：<ul><li>第一，价值的<strong>主体性</strong>：指价值直接与主体相联系，始终以主体为中心。</li><li>第二，价值的<strong>客观性</strong>：指在一定条件下客体对于主体的意义不依赖于主体的主观意识而存在。</li><li>第三，价值的<strong>多维性</strong>：指每个主体的价值关系具有多样性，同一客体相对于主体的不同需要会产生不同的价值。</li><li>第四，价值的<strong>社会历史性</strong>：指价值关系随着社会历史的发展、主客体的不断变化而变化，具有历史性和阶段性。</li></ul></li><li>价值评价：<ul><li>第一，评价以主客体之间的价值关系为认识对象。</li><li>第二，评价结果与评价主体直接相关。</li><li>第三，评价结果的正确与否依赖于对客体状况和主体需要的认识。</li><li>第四，价值评价有科学和非科学之别。</li></ul></li><li><strong>价值观是人们关于价值本质的认识以及对人和事物评价标准、评价原则和评价方法的观点的体系。</strong></li><li>任何成功的实践都是真理尺度和价值尺度的统一，是合规律性和合目的性的统一。</li></ol><h2 id="第三节-认识世界和改造世界">第三节 认识世界和改造世界</h2><ol type="1"><li>认识世界和改造世界史相互依赖、相互制约的辩证统一关系<ul><li>一方面，认识世界有助于改造世界。正确认识世界是有效改造世界的必要前提；</li><li>另一方面，人们只有在改造世界的实践中才能不断地深化、拓展对世界的正确认识。</li></ul></li><li>改造客观世界和改造主观世界是辩证统一的。</li><li>自由是表示人的活动状态的范畴，是指人在活动中通过认识和利用必然所表现出的自然自觉的状态。</li><li>自由的条件：<ul><li><strong>认识条件</strong>：即要有对客观事物的正确认识，最主要的是对客观事物运动发展规律性、必然性的正确认识。</li><li><strong>实践条件</strong>：即能够将获得的规律性认识运用于指导实践，实现改造世界的目的，才是真正的自由。</li></ul></li><li>认识必然和争取自由，是人类认识世界和改造世界的根本目标，是一个历史性的过程。</li><li><strong>一切从实际出发</strong>，就是要把客观存在的事物作为观察和处理问题的根本出发点，这是<strong>马克思主义认识论的根本要求和具体体现</strong>。</li><li><strong>思想路线</strong>的基本内涵：一切从实际出发，理论联系实际，实事求是，在实践中检验和发展真理。<strong>核心是实事求是</strong>。</li></ol><h1 id="第三章-人类社会及其发展规律">第三章 人类社会及其发展规律</h1><h2 id="第一节-人类社会的存在与发展">第一节 人类社会的存在与发展</h2><ol type="1"><li><strong>社会存在与社会意识的关系问题，是社会历史观的基本问题。</strong></li><li>两种根本对立的历史观：唯心史观和唯物史观</li><li>社会存在是指社会物质生活条件，是社会生活的<strong>物质方面</strong>，主要包括自然地理环境、人口因素和物质生产方式。<ul><li><strong>物质生产方式是社会存在和发展的基础及决定力量，生产方式是社会历史发展的决定力量</strong>。</li><li>自然地理环境是指与人类社会所处的地理位置相联系的自然条件的总和，是人类社会生存和发展的永恒的、必要的条件。</li><li>人口是由人类社会的一切有生命的个人构成的总和。</li><li>物质生产方式是指人们为获取物质生活资料而进行的生产活动的方式，是生产力和生产关系的统一体。</li></ul></li><li>社会意识是社会存在的反映，是社会生活的<strong>精神方面</strong>。<ul><li>根据不同的主体，分为个体意识（个体社会实践的产物）和群体意识（群体实践的产物）。</li><li>根据不同的层次，分为社会心理（以感性认识为主）和社会意识形式（以理性认识为主）。</li><li>社会意识形式以社会心理为基础，并对社会心理起指导和影响作用。</li><li>社会意识形式：<ol type="1"><li>意识形态<ul><li><strong>政治法律思想</strong>：在意识形态中居核心地位，发挥主导作用。</li><li>道德：历史性、继承性</li><li>艺术</li><li>宗教：自然压迫和社会压迫的产物。</li><li>哲学：世界观和方法论的统一。</li></ul></li><li>非意识形态：自然科学、语言学、形式逻辑</li></ol></li></ul></li><li><strong>社会存在和社会意识是辩证统一的</strong>：<ul><li>社会存在<strong>决定</strong>社会意识，社会意识是社会存在的<strong>反映</strong>，并<strong>反作用</strong>于社会存在。</li><li>社会存在是社会意识内容的<strong>客观来源</strong>，社会意识是社会物质生活过程及其条件的<strong>主观反映</strong>。</li><li>社会意识既依赖于社会存在，又有其相对独立性：<ul><li>一是社会意识与社会存在发展具有不完全同步性和不平衡性。</li><li>二是社会意识内部各种形式之间存在相互影响且各自具有历史继承性。</li><li>三是社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现。</li></ul></li></ul></li><li>社会存在和社会意识辩证关系原理的重要意义：<ul><li>社会存在和社会意识辩证关系原理对于我们树立科学的历史观、正确认识社会历史具有重要意义。</li><li>社会存在和社会意识辩证关系原理对于推进社会发展包括社会文化建设具有重要指导意义。</li></ul></li><li><strong>生产力与生产关系、经济基础与上层建筑之间的矛盾，是人类社会基本矛盾</strong>。<ul><li>生产力与生产关系矛盾运动的规律、经济基础与上层建筑矛盾运动的规律，是<strong>人类社会发展的基本规律</strong>。</li></ul></li><li>生产力与生产关系的矛盾运动及其规律<ol type="1"><li><strong>生产力</strong>：<strong>是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量</strong>。<ul><li>生产力是人类社会生活和全部历史的物质基础。</li><li>生产力具有<strong>客观现实性和社会历史性</strong>。</li><li>生产力基本要素：<ul><li><strong>劳动资料</strong>：也称为劳动手段，是人们在劳动过程中所运用的物质资料或物质条件，其中最重要的是<strong>生产工具</strong>。“各种经济时代的区别，不在于生产什么，而在于怎样生产，用什么劳动资料生产。”</li><li><strong>劳动对象</strong>：是现实生产的必要前提，它从一个侧面反映和体现了生产力的发展水平。</li><li><strong>劳动者</strong>：是具有一定生产经验、劳动技能和知识，能够运用一定生产资料作用于劳动对象，从事生产实践活动的人。劳动者是生产力中最活跃的因素，在生产力中起<strong>主导作用</strong>。劳动者一般包括体力劳动者和脑力劳动者。</li></ul></li><li><strong>科学技术是先进生产力的集中体现和主要标志，是第一生产力。</strong></li></ul></li><li><strong>生产关系</strong>：<strong>是人们在物质生产过程中形成的不以人的意志为转移的经济关系</strong>。<ul><li><strong>生产关系是社会关系中最基本的关系</strong>，政治关系、家庭关系、宗教关条等其他社会关系，都受生产关系的支配和制约。</li><li>生产关系包括<strong>生产资料所有制关系（最基本）、生产中人与人的关系、产品分配关系</strong>。</li><li>生产关系基本类型：<ul><li>以生产资料公有制为基础的生产关系</li><li>以生产资料私有制为基础的生产关系</li></ul></li></ul></li><li>生产力与生产关系的相互关系：<ul><li>第一，<strong>生产力决定生产关系</strong>。</li><li>第二，<strong>生产关系对生产力具有能动的反作用</strong>。<ul><li>当生产关系适合生产力发展的客观要求时，对生产力的发展起推动作用；</li><li>当生产关系不适合生产力发展的客观要求时就会阻碍生产力的发展。</li></ul></li><li>生产关系一定要适合生产力状况的规律是社会形态发展的普遍规律：生产关系对于生产力总是从基本相适合到基本不相适合，再到基本相适合；与此相适应，生产关系也总是从相对稳定到新旧更替，再到相对稳定。</li></ul></li><li>生产力与生产关系矛盾运动规律具有极为重要的理论意义和现实意义：<ul><li>第一，这一原理在人类思想史上彻底否定了单纯以道德作为评判历史功过是非标准的思想体系，第一次科学地确立了<strong>生产力发展是“社会进步的最高标准”</strong>，并且把生产领域生产关系矛盾运动的规律作为判断时代变革的客观依据。</li><li>第二，生产力与生产关系矛盾运动规律是马克思主义政党制定路线、方针和政策的重要依据。</li></ul></li></ol></li><li>经济基础与上层建筑的矛盾运动及其规律<ol type="1"><li><strong>经济基础</strong>：是指<strong>由社会一定发展阶段的生产力所决定的生产关系的总和</strong>。<ul><li>其一，社会发展中往往有多种生产关系，但决定社会性质的是其中占支配地位的生产关系。</li><li>其二，经济基础与经济体制具有内在联系：经济体制是社会基本经济制度所采取的组织形式和管理形式。</li></ul></li><li><strong>上层建筑</strong>：是<strong>建立在一定经济基础之上的意识形态以及相应的制度、组织和设施</strong>。<ul><li>上层建筑的构成：<ul><li><strong>意识形态</strong>（观念上层建筑）：政治法律思想、道德、艺术、宗教、哲学</li><li><strong>政治法律制度及设施和政治组织</strong>（政治上层建筑）：国家制度、立法司法制度、行政制度；国家政权机构、政党、军队、法庭、监狱等等。</li></ul></li><li>观念上层建筑和政治上层建筑的关系：政治上层建筑是在一定意识形态指导下建立起来的，是统治阶级意志的体现；政治上层建筑一旦形成，就成为一种现实的力量，影响并制约着人们的思想理论观点。</li><li>在整个上层建筑中，<strong>政治居主导地位，国家政权是核心地位</strong>。<ul><li>国家不是从来就有的，它是社会发展到一定历史阶段的产物</li><li>国家是阶级矛盾不可调和的产物</li><li>国家的实质是一个阶级统治另一个阶级的工具</li></ul></li><li><strong>国体</strong>是指社会各阶级在国家中的地位，它表明国家政权掌握在哪个阶级手里，哪个阶级是统治阶级，哪个阶级是被统治阶级，这是决定国家阶级性质的方面。（我国的国体是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家）</li><li><strong>政体</strong>是指统治阶级实现其阶级统治的具体组织形式，也就是政权构成形式。它表明统治阶级采取什么样的形式去组织自己的政权，实现自己的统治。（我国的政体是人民代表大会制度）</li><li>国体和政体的关系：一般来说。<strong>国体决定政体，政体服从于国体</strong>；政体为国体服务，并对保证国家的性质起重要作用。</li></ul></li><li>经济基础与上层建筑是辩证统一的：<ul><li>首先，<strong>经济基础决定上层建筑</strong>。</li><li>其次，<strong>上层建筑对经济基础具有反作用</strong>。</li></ul></li><li>经济基础与上层建筑相互作用构成二者的矛盾运动。</li><li>经济基础和上层建筑之间的内在联系构成了上层建筑一定要适合经济基础状况的规律。</li></ol></li><li>交往：指在一定历史条件下的现实的个人、群体、阶级、民族、国家之间在物质和精神上的相互往来、相互作用、彼此联系的活动。<ol type="1"><li>交往分为：<ul><li>物质交往：是指人们在物质生产实践中发生的交往，物质产品是其交往内容。</li><li>精神交往：是指一定的历史条件下，人们在涉及思想、意识、观念、情感和情绪等精神性的领域中进行的交往。</li></ul></li><li>交往对社会生活有着重要的影响：<ul><li>第一，促进生产力的发展。</li><li>第二，促进社会关系的进步。</li><li>第三，促进文化的发展与传播。</li><li>第四，促进人的全面发展。</li></ul></li></ol></li><li>世界历史的形成与发展<ul><li>生产方式的发展变革是世界历史形成和发展的基础。</li><li>普遍交往是世界历史的基本特征。</li></ul></li><li>社会进步与人发展<ol type="1"><li>社会进步表现：<ul><li>一是社会形态从低级到高级的发展。</li><li>二是同一社会形态内部的发展。</li></ul></li><li>社会进步作用：<ul><li>社会进步促进<strong>人的发展</strong>。<ul><li>人的发展：人的依赖关系占统治地位的阶段、以物的依赖关系为基础的人的独立性的阶段、自由个性的阶段。</li></ul></li><li>社会进步推动<strong>人类解放</strong>。</li></ul></li><li>社会形态是关于社会运动的具体形式、发展阶段和不同质态的范畴，是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体。<ul><li>社会形态包括社会的经济形态、政治形态和意识形态，是三者的历史的、具体的统一。经济形态是社会形态的基础。</li></ul></li></ol></li><li>社会形态更替的<strong>统一性</strong>和<strong>多样性</strong>：<ul><li>原始社会、奴隶社会、封建社会、资本主义社会、共产主义社会五种社会形态的依次更替，是社会历史运动的一般过程和一般规律，表现了社会形态更替的统一性。</li><li>就某一国家或民族的社会发展的历程而言，社会形态的更替具有种种复杂情况和特点，体现了社会形态更替形式的多样性。</li></ul></li><li>社会形态更替的<strong>必然性</strong>与<strong>选择性</strong>：<ul><li>社会形态发展的统一性与多样性，根源于社会发展的客观必然性与人们的历史选择性相统一的过程。</li><li>人们的历史选择性：<ul><li>第一，社会发展的必然性造成了一定历史阶段社会发展的基本趋势，为人们的历史选择提供了基础、范围和可能性空间。</li><li>第二，社会形态更替的过程也是一个主观能动性和客观规律性相统一的过程。</li><li>第三，人们的历史选择性归根结底是人民群众的选择性。</li></ul></li></ul></li><li>文明：是人类创造的所有物质成果、精神成果和制度成果的总和，是标志社会进步程度的范畴，反映了人类社会实践的积极成果。</li></ol><h2 id="第二节-社会历史发展的动力">第二节 社会历史发展的动力</h2><ol type="1"><li><strong>社会基本矛盾是社会发展的根本动力</strong><ul><li>生产力和生产关系、经济基础和上层建筑的矛盾是社会基本矛盾。</li><li>社会基本矛盾在历史发展中的作用：<ul><li>首先，生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量。</li><li>其次，社会基本矛盾特别是生产力和生产关系的矛盾，决定着社会中其他矛盾的存在和发展。</li><li>最后，社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展。</li></ul></li></ul></li><li>社会基本结构<ol type="1"><li>经济结构<ul><li>广义：生产方式，包含生产力和生产关系。</li><li>狭义：经济关系或经济制度。</li></ul></li><li>政治结构：政治上层建筑</li><li>观念结构：观念上层建筑</li></ol></li><li>社会基本矛盾是其他一切社会矛盾的根源，规定和制约着社会主要矛盾的存在和发展，<strong>社会主要矛盾是社会基本矛盾的具体体现</strong>。<ul><li>社会主要矛盾不是一成不变的，它在一定条件下会发生转变化：<ul><li>一是社会主要矛盾双方的内容发生变化；</li><li>二是矛盾地位发生变化。</li></ul></li></ul></li><li><strong>阶级斗争是阶级社会发展的直接动力</strong>。<ul><li>阶级斗争是阶级利益根本冲突的对抗阶级之间的对立和斗争。</li><li>阶级斗争根源于阶级之间物质利益的根本对立，根源于社会经济关系的冲突。</li><li>阶级斗争的推动作用突出表现在社会形态的更替中（推翻反动阶级）。也表现在统一社会形态的量变过程中（反动统治阶级做出某些让步）。</li></ul></li><li>革命或狭义的社会革命，是阶级斗争的最高形式，其实质是革命阶级推翻反动阶级的统治，用新的社会制度代替旧的社会制度。根源于社会基本矛盾的尖锐化。<ul><li>革命对社会发展的作用：<ul><li>革命是实现社会形态更替的重要手段和决定性环节。</li><li>革命能充分发挥人民群众创造历史的积极性和伟大作用。</li><li>革命斗争能够极大地教育和锻炼包括革命阶级在内的广大人民群众。</li></ul></li></ul></li><li><strong>马克思主义的阶级分析方法</strong>是认识阶级社会的科学方法。<ul><li>在认识和处理矛盾时，要严格区分阶级矛盾和非阶级矛盾、对抗阶级之间的矛盾和非对抗阶级之间的矛盾，以及敌我矛盾和人民内部矛盾。</li></ul></li><li>革命和改革区别：<ul><li>社会革命：适用于解决现存的<strong>社会基本制度</strong>问题，把生产力从已经不能容纳它的旧的生产关系解放出来。</li><li>改革：改革适用于解决现存的<strong>社会体制</strong>存在的问题，在不改变社会基本制度的前提下，对生产关系和上层建筑的某些方面和环节进行变革，从而促进生产力发展和社会进步。</li></ul></li><li><strong>科技革命是推动经济和社会发展的强大杠杆</strong>。<ul><li>每次科技革命，都不同程度地引起了生产方式、生活方式和思维方式的深刻变化和社会的巨大变化：<ul><li>首先，对生产方式产生了深刻影响。<ul><li>其一，改变了社会生产力的构成要素。</li><li>其二，改变了人们的劳动形式。</li><li>其三，改变了社会经济结构，特别是导致产业结构发生变革。</li></ul></li><li>其次，对生活方式产生了巨大影响。</li><li>最后，促进了思维方式的变革。</li></ul></li></ul></li><li>文化在社会发展中的作用：<ul><li>第一，文化为社会发展提供思想指引。</li><li>第二，文化为社会发展提供精神动力。</li><li>第三，文化为社会发展提供凝聚力量。</li></ul></li></ol><h2 id="第三节-人民群众在历史发展中的作用">第三节人民群众在历史发展中的作用</h2><ol type="1"><li>唯物史观和唯心史观在历史创造者问题上根本对立：<ul><li>唯心史观：<strong>英雄史观</strong></li><li>唯物史观：<strong>群众史观</strong></li></ul></li><li>英雄史观产生的原因：<ul><li>认识根源上：人们停留在历史的表象上，把活跃在历史前台的少数英雄人物的作用尤其是他们意识的作用加以夸大人并绝对化。</li><li>社会历史根源上：英雄史观的产生同社会生产力水平较低，大多数人从事物质资料的生产活动，少数人从事政治统治、垄断精神生活有关。</li><li>阶级根源上：剥削阶级的思想家为了维护本阶级的利益，需要宣扬唯心史观。</li></ul></li><li>唯物史观在考察历史创造者问题时坚持了几点原则：<ul><li>首先，唯物史观立足于<strong>现实的人及其本质</strong>来把握历史的创造者</li><li>其次，唯物史观立足于<strong>整体的社会历史过程</strong>来探究历史创造者问题</li><li>再次，唯物史观从<strong>社会历史发展的必然性</strong>入手来考察和说明历史创造者及其活动</li><li>最后，唯物史观从<strong>人与历史关系的不同层次</strong>上考察人们历史活动的作用及其性质</li></ul></li><li><strong>人民群众是历史的创造者</strong>。<ul><li>人民群众在创造历史过程中的决定作用：<ul><li>人民群众是社会<strong>物质</strong>财富的创造者。</li><li>人民群众是社会<strong>精神</strong>财富的创造者。</li><li>人民群众是社会<strong>变革</strong>的决定力量。</li></ul></li><li>人民群众创造历史的作用同社会基本矛盾运动推动社会前进的过程相一致。</li><li>人民群众创造历史的活动要受到一定社会历史条件的制约：<ul><li>经济条件对于人民群众的创造活动有着首要的、决定性的影响。</li><li>政治条件对人民群众的创造活动也具有直接的影响。</li><li>精神文化条件也是制约人民群众创造活动的重要因素。</li></ul></li></ul></li><li>无产阶级政党的群众路线<ul><li><strong>马克思主义群众观点</strong>：<ul><li>坚信人民群众自己解放自己的观点</li><li>全心全意为人民服务的观点</li><li>一切向人民群众负责的观点</li><li>虚心向人民群众学习的观点</li></ul></li><li><strong>群众路线是我们党的生命线和根本工作路线</strong>，也是我们党的优良传统。</li><li>群众路线是群众观点的具体应用，即<strong>一切为了群众，一切依靠群众，从群众中来，到群众中去</strong>。</li><li>群众路线的实质，就在于充分相信群众，坚决依靠群众，密切联系群众，全心全意为人民群众服务。</li><li>群众路线重要方面：<ul><li>一是领导和群众相结合，</li><li>二是一般号召和个别指导相结合。</li></ul></li></ul></li><li>群众、阶级、政党、领袖的关系：<ul><li>首先，群众是划分为阶级的。</li><li>其次，阶级通常是由政党领导的。</li><li>最后，政党是由领袖来主持的。</li></ul></li></ol><h1 id="第四章-资本主义的本质及其规律">第四章资本主义的本质及其规律</h1><h2 id="第一节-商品经济和价值规律">第一节 商品经济和价值规律</h2><ol type="1"><li>商品经济发展：<ul><li>简单商品经济：以生产资料私有制和个体劳动为基础</li><li>发达商品经济/资本主义商品经济：以生产资料私有制和雇佣劳动为基础。</li><li>商品经济是以交换为目的而进行生产的经济形式，是一定社会历史条件的产物。</li><li>商品经济产生的社会历史条件：<ul><li>一是存在社会分工。</li><li>二是生产资料和劳动产品属于不同的所有者。</li></ul></li></ul></li><li>商品是用来交换的能够满足人们某种需要的劳动产品，具有使用价值和价值两个因素，是使用价值和价值的矛盾统一体，<ul><li><strong>使用价值</strong>：是指商品能满足人们某种需要的有用性，反映的是人与自然之间的物质关系，是商品的<strong>自然属性</strong>，是<strong>一切劳动产品所共有的属性</strong>。<ul><li><strong>使用价值构成社会财富的物质内容</strong>。</li><li><strong>使用价值是交换价值的物质承担者</strong>。</li><li><strong>使用价值是价值的物质承担者</strong>。</li></ul></li><li><strong>交换价值</strong>：首先表现为一种使用价值同另一种使用价值相交换的量的关系或比例。决定商品交换的比例的，不是商品的使用价值，而是价值。</li><li><strong>价值</strong>：是凝结在商品中的无差别的一般人类劳动，即人类脑力和体力的耗费。<strong>价值是商品所特有的社会属性</strong>。<ul><li>价值是交换价值的基础，交换价值是价值的表现形式。</li></ul></li><li>商品的价值和使用价值是对立统一的关系：<ul><li>对立性：商品的使用价值和价值是相互排斥的，二者不可兼得。</li><li>统一性：商品必须同时具有使用价值和价值两个因素。使用价值是价值的物质承担者；价值寓于使用价值之中。</li></ul></li></ul></li><li>劳动的二重性：生产商品的劳动可区分为<strong>具体劳动和抽象劳动</strong>。<ul><li>具体劳动是指生产一定使用价值的具体形式的劳动，马克思也称之为有用劳动。</li><li>抽象劳动是指撇开一切具体形式的、无差别的一般人类劳动，即人的体力和脑力消耗。</li><li>生产商品的具体劳动形成商品的使用价值，抽象劳动形成商品的价值。</li><li><strong>劳动的二重性决定了商品的二因素</strong>。</li><li>具体劳动和抽象劳动也是对立统一的关系：<ul><li>一方面，具体劳动和抽象劳动不是各自独立存在的两种劳动或两次劳动，它们在时间上和空间上是统一的，是商品生产者的同一劳动过程的不可分割的两个方面</li><li>另一方面，具体劳动所反映的是人与自然的关系，它是<strong>劳动的自然属性</strong>，而抽象劳动所反映的是商品生产者的社会关系，它是<strong>劳动的社会属性</strong>。</li></ul></li></ul></li><li>商品价值量的决定<ul><li>商品的价值包括质的规定与量的规定两个方面：<ul><li>价值的<strong>质</strong>的规定回答的是价值的实体是什么。</li><li>价值的<strong>量</strong>的规定则回答价值的大小由什么决定和怎样决定。</li></ul></li><li>商品的价值是凝结在商品中的劳动，价值量是由生产商品所耗费的劳动量决定的，而劳动量则按照劳动时间来计量。</li><li><strong>决定商品价值量的是社会必要劳动时间</strong>。</li><li>社会必要劳动时间是在现有的社会正常的生产条件下，在社会平均的劳动熟练程度和劳动强度下制造某种使用价值所需要的劳动时间。</li></ul></li><li>货币是在长期交换过程中形成的固定充当一般等价物的商品。<ul><li><strong>货币职能</strong>：价值尺度、流通手段、贮藏手段、支付手段、世界货币</li><li><strong>价值尺度和流通手段是最基本的职能</strong>。</li><li>商品转换为货币为“商品的惊险的跳跃”。</li></ul></li><li><strong>价值规律</strong>：商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行。<ul><li>价值规律是商品生产和商品交换的基本规律。</li><li>在商品经济中，价值规律的表现形式是，商品的价格围绕商品的价值自发波动。</li><li>价值规律在市场配置资源过程中的作用表现在：<ul><li>第一，自发地调节生产资料和劳动力在社会各生产部门之间的分配比例。</li><li>第二，自发地刺激社会生产力的发展。</li><li>第三，自发地调节社会收入的分配。</li></ul></li><li>价值规律在对经济活动进行自发调节时，会产生一些消极的后果：<ul><li>其一，导致社会资源浪费。</li><li>其二，阻碍技术进步。</li><li>其三，导致收入两极分化。</li></ul></li></ul></li><li><strong>商品经济的基本矛盾，即私有制经济基础之上私人劳动和社会劳动的矛盾</strong>。<ul><li>私人劳动和社会劳动的矛盾构成私有制商品经济的基本矛盾，这一矛盾贯穿商品经济发展过程的始终，决定着商品经济的各种内在矛盾及其发展趋势：<ul><li>首先，私人劳动和社会劳动的矛盾决定着商品经济的本质及其发展过程。</li><li>其次，私人劳动和社会劳动的矛盾，是商品经济的其他一切矛盾的基础。</li><li>最后，私人劳动和社会劳动的矛盾决定着商品生产者的命运。</li></ul></li><li>私有制商品经济条件下商品世界的拜物教性质的产生的必然性：<ul><li>其一，劳动产品只有采取商品的形式才能进行交换，人类劳动的等同性只有采取同质的价值形式才能在交换中体现出来。</li><li>其二，劳动量只有采取价值量这一物的形式才能进行计算和比较。</li><li>其三，生产者的劳动关系的社会性质只有采取商品之间即物与物之间相交换的形式才能间接地表现出来，这就使人与人之间一定的社会关系被物与物的关系所掩盖，具有了拜物教性质。</li></ul></li></ul></li><li><strong>马克思劳动价值论</strong>的理论和实践意义：<ul><li>第一，马克思劳动价值论扬弃了英国古典政治经济学的观点，为剩余价值论的创立奠定了基础。</li><li>第二，马克思劳动价值论揭示了私有制条件下商品经济的基本矛盾，为从物与物的关系背后揭示人与人的关系提供了理论依据。</li><li>第三，马克思劳动价值论揭示了商品经济的一般规律，对理解社会主义市场经济具有指导意义。</li></ul></li><li>深化对马克思劳动价值论的认识<ul><li>第一，深化对创造价值的劳动的认识，对生产性劳动作出新的界定。</li><li>第二，深化对科技人员、经营管理人员在社会生产和价值创造中所起到的作用的认识。</li><li>第三，深化对价值创造和价值分配关系的认识。</li></ul></li></ol><h2 id="第二节-资本主义经济制度">第二节 资本主义经济制度</h2><ol type="1"><li>简单商品公式和资本总公式<ul><li>简单商品公式：W-G-W，W 代表商品，G代表流通中的货币，表明商品流通的目的是获得使用价值。</li><li><strong>资本总公式</strong>：G-W-G’，G代表作为资本的货币，G’代表价值增殖后的货币，表明资本运动的一般目的是价值增值。</li></ul></li><li>劳动力的使用即劳动。<ul><li>劳动力成为商品，要具备两个基本条件：<ul><li>第一，劳动者是自由人，能够把自己的劳动力当作自己的商品来支配；</li><li>第二，劳动者没有任何生产资料，没有生活资料来源，因而不得不依靠出卖劳动力为生。</li></ul></li><li><strong>劳动力成为商品，标志着简单商品生产发展到资本主义商品生产的新阶段</strong>。</li><li><strong>劳动力商品的价值</strong> =劳动者自己及其家属所需要的生活资料的价值（历史和道德的因素）<ul><li>维持劳动者本人生存所必需的生活资料的价值</li><li>维持劳动者家属的生存所必需的生活资料的价值</li><li>劳动者接受教育和训练所支出的费用</li></ul></li><li><strong>劳动力商品的使用价值是价值的源泉</strong>，在消费过程中能够创造新的价值，并且这个新的价值比劳动力本身的价值更大。</li></ul></li><li>资本是可以带来剩余价值的价值。剩余价值是由雇佣工人的剩余劳动创造的。<ul><li>资本主义生产过程具有二重性：<ul><li>一方面是生产物质资料的<strong>劳动过程</strong>；</li><li>另一方面是生产剩余价值的过程，即<strong>价值增殖过程</strong>。</li><li>资本主义生产过程是劳动过程和价值增殖过程的统一。</li></ul></li><li>生产物质资料的劳动过程的基本要素：劳动者的劳动、劳动对象、劳动资料。</li><li>资本主义劳动过程特点：<ul><li>其一，工人在资本家的监督下劳动，他们的劳动隶属于资本家；</li><li>其二，劳动的成果或者产品全部归资本家所有。</li></ul></li><li>剩余价值就是雇佣工人在剩余劳动时间内创造的、被资本家无偿占有的超过劳动力价值的那部分新价值。</li></ul></li><li>资本主义生产的直接目的和决定性动机，就是无休止地采取各种方法获取尽可能多的剩余价值。这样一种不以人的意志为转移的客观必然性，就是<strong>剩余价值规律</strong>。<ul><li>根据资本在剩余价值生产中所起的不同作用，资本划分为：<ul><li>不变资本（C）：以生产资料形态存在的资本。原有价值转移，不发生增值。</li><li>可变资本（V）：用来购买劳动力的那部分资本。原有价值增值，产生剩余价值。</li></ul></li><li><strong>商品价值构成公式</strong>：W = C + V + M<ul><li>其中，C为不变资本，V为可变资本，M为剩余价值。</li></ul></li><li><strong>剩余价值率</strong>：M’ = M / V = 剩余价值 / 可变资本 =剩余劳动 / 必要劳动 = 剩余劳动时间 / 必要劳动时间</li></ul></li><li>生产剩余价值的两种基本方法：绝对剩余价值生产和相对剩余价值生产。<ul><li><strong>绝对剩余价值</strong>：<strong>指在必要劳动时间不变的条件下，由于延长劳动日的长度和提高劳动强度而生产的剩余价值。</strong></li><li><strong>相对剩余价值</strong>：<strong>指在工作日长度不变的条件下，通过缩短必要劳动时间而相对延长剩余劳动时间生产的剩余价值。</strong><ul><li><strong>相对剩余价值的生产是整个社会劳动生产率普遍提高的结果</strong>。全社会劳动生产率的提高是资本家追逐超额剩余价值的结果。</li><li>超额剩余价值是指企业由于提高劳动生产率而使商品的个别价值低于社会价值的差额。</li></ul></li></ul></li><li>把剩余价值转化为资本，或者说，<strong>剩余价值的资本化，就是资本积累</strong>。<ul><li><strong>资本主义简单再生产</strong>：资本家瓜分到剩余价值后，如果将其完全用于个人消费，则生产就在原有规模的基础上重复进行。<ul><li>资本主义简单再生产，不仅生产商品，不仅生产剩余价值，而且还生产和再生产资本关系本身：一方面是资本家，另一方面是雇佣工人。</li><li>资本主义简单再生产，就其实质而言，是物质资料再生产和资本主义生产关系再生产的统一。</li></ul></li><li><strong>资本主义的扩大再生产</strong>：资本家获得无偿占有的剩余价值后，并不是将其完全用于个人消费，而是将一部分转化为资本，用以购买追加的生产资料和劳动力，使生产在扩大的规模上重复进行。<ul><li><strong>资本积累是资本主义扩大再生产的源泉</strong>。资本积累的本质，就是<strong>资本家不断地利用无偿占有的工人创造的剩余价值来扩大自已的资本规模</strong>，从而进一步扩大和加强对工人的剥削和统治。</li></ul></li></ul></li><li>资本的构成：<ul><li>资本的<strong>技术构成</strong>：由生产的技术水平决定的生产资料和劳动力之间的比例叫做资本的技术构成。</li><li>资本的<strong>价值构成</strong>：从价值上看，资本可以分为不变资本和可变资本，这两部分资本价值之间的比例，叫做资本的价值构成。</li><li>资本的<strong>有机构成</strong>：一般来说，资本的技术构成决定资本的价值构成，技术构成的变化往往会引起价值构成的变化，而价值构成的变化通常反映着技术构成的变化。这种由资本的技术构成决定并反映技术构成变化的资本价值构成，叫做资本的有机构成。</li></ul></li><li>资本积聚是指个别资本通过剩余价值的资本化来增大资本的总量。<ul><li>资本积累是资本积聚的基础，资本积聚是资本积累的直接结果。</li><li>资本集中是指个别资本通过结合而形成的资本。</li><li>相对过剩人口形式：流动的过剩人口、潜在的过剩人口、停滞的过剩人口。</li></ul></li><li>资本循环周转<ul><li>产业资本的循环过程：<ul><li>第一个阶段：<strong>购买阶段</strong>，即生产资料和劳动力的购买阶段，产业资本执行<strong>货币资本</strong>的职能。</li><li>第二个阶段：<strong>生产阶段</strong>，即生产资料与劳动力按比例结合在一起从事资本主义生产的阶段，产业资本执行<strong>生产资本</strong>的职能。</li><li>第三个阶段：<strong>售卖阶段</strong>，即商品资本向货币资本的转化阶段，产业资本执行<strong>商品资本</strong>的职能。</li></ul></li><li>产业资本的运动基本前提条件：<ul><li>一是产业资本的三种职能形式必须在空间上并存。</li><li>二是产业资本的三种职能必须在时间上继起。</li></ul></li><li>产业资本的连续循环是流通过程和生产过程的统一，也是它的三种职能形式循环，即货币资本循环、生产资本循环和商品资本循环的统一。</li></ul></li><li>社会资本再生产的核心问题：社会总产品的实现问题，即社会总产品的价值补偿和实物补偿问题。<ul><li>社会生产两大部类：<ul><li>第一部类（I）由生产生产资料的部门所构成，其产品进入生产消费领域；</li><li>第二部类（II）由生产消费资料的部门所构成，其产品进入生活消费领域。</li></ul></li><li>社会总产品在实物上得到替换，在价值上实现补偿，客观上就要求两大部类内部各个产业部门之间和两大部类之间保持一定的比例关系。</li></ul></li><li><strong>马克思剩余价值论</strong>的意义：<ul><li>马克思通过分析剩余价值的生产、积累、流通以及分配，揭示了剩余价值的运动规律及其作用，创立了剩余价值理论。</li><li>剩余价值论深刻揭露了资本主义生产关系的剥削本质，阐明了资产阶级与无产阶级之间阶级斗争的经济根源，指出了无产阶级革命的历史必然性。</li><li>剩余价值论是马克思主义经济学说的核心内容和基石，是无产阶级反对资产阶级、揭示资本主义制度剥削本质的锐利武器。</li><li>由于唯物史观和剩余价值理论的发现，社会主义由空想变为科学。</li></ul></li><li><strong>资本主义基本矛盾：生产社会化和生产资料的私人占有之间的矛盾</strong>。<ul><li>生产过剩是资本主义经济危机的本质特征。</li><li>资本主义经济危机具有周期性，这是由资本主义基本矛盾运动的阶段性决定的。</li><li>社会资本再生产周期：危机（基本阶段）、萧条、复苏、高涨。</li></ul></li></ol><h2 id="第三节-资本主义上层建筑不考">第三节资本主义上层建筑（不考）</h2><h1 id="第五章-资本主义的发展及其趋势">第五章资本主义的发展及其趋势</h1><h2 id="第一节-垄断资本主义的形成与发展">第一节垄断资本主义的形成与发展</h2><ol type="1"><li>自由竞争引起生产集中和资本集中，生产集中和资本集中发展到一定阶段必然引起垄断，这是资本主义发展的客观规律。<ul><li>垄断是指少数资本主义大企业为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制。</li><li>垄断组织是指在一个或几个经济部门中占据垄断地位的大企业联合。</li></ul></li><li>垄断产生的原因：<ul><li>第一，当生产集中发展到相当高的程度，极少数企业就会联合起来，操纵和控制本部门的生产和销售，实行垄断，以获得高额利润。</li><li>第二，企业规模巨大，形成对竞争的限制，也会产生垄断。</li><li>第三，激烈的竞争、给竞争各方带来的损失越来越严重，为了避免两败俱伤，企业之间会达成妥协，联合起来，实行垄断。</li></ul></li><li>垄断是在自由竞争中形成的，是作为自由竞争的对立面产生的。但是，垄断并不能消除竞争，反而使竞争变得更加复杂和激烈。垄断条件下竞争的特点：<ul><li>第一，垄断没有消除产生竞争的经济条件。</li><li>第二，垄断必须通过竞争来维持。</li><li>第三，社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产全部包下来。</li></ul></li><li><strong>金融资本</strong>是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本。<ul><li><strong>金融寡头</strong>是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团。</li><li>金融寡头在经济领域中的统治主要是通过“<strong>参与制</strong>”实现的。</li><li>金融寡头对国家机器的控制，主要是通过同政府的“<strong>个人联合</strong>”来实现的。</li></ul></li><li>垄断资本的实质在于获取垄断利润。<ul><li>垄断利润是垄断资本家凭借其在社会生产和流通中的垄断地位而获得的超过平均利润的高额利润。</li><li>垄断资本所获得的高额利润，归根到底来自无产阶级和其他劳动人民所创造的剩余价值。</li></ul></li><li>国家垄断资本主义的形成和发展不是偶然的，它是科技进步和生产社会化程度进一步提高的产物，是资本主义基本矛盾进一步尖锐化的必然结果。<ul><li>首先，社会生产力的发展，要求资本主义生产资料在更大范围内被支配，从而促进了国家垄断资本主义的产生。</li><li>其次，经济波动和经济危机的深化，要求国家垄断资本主义的产生。</li><li>最后，缓和社会矛盾，协调利益关系，要求国家垄断资本主义的产生。</li><li>国家垄断资本主义的主要形式：<ul><li>第一种是国家所有并直接经营的企业；</li><li>第二种是国家与私人共有、合营企业；</li><li>第三种是国家通过多种形式参与私人垄断资本的再生产过程；</li><li>第四种是宏观调节：宏观调节主要是国家运用财政政策、货币政策等经济手段，对社会总供给和总需求进行调节，以实现经济快速增长、充分就业、物价稳定和国际收支平衡的基本目标。</li><li>第五种是微观规制：微观规制则主要是国家运用法律手段规范市场秩序，限制垄断，保护竞争，维护社会公众的合法权益。</li></ul></li><li>国家垄断资本主义对资本主义经济发展产生的积极作用：<ul><li>首先，国家垄断资本主义的出现在一定程度上有利于社会生产力的发展。</li><li>其次，资本主义国家凌驾于私人垄断资本之上，代表整个垄断资产阶级的利益，调节经济过程和经济活动，这在一定范围内突破了私人垄断资本的狭隘界限。</li><li>再次，通过国家的收入再分配手段，劳动人民生活水平有所改善和提高。</li><li>最后，在国家垄断资本主义的参与和干预下，各主要资本主义国家的农业、工业、商业、通信业及交通运输业的现代化水平迅速提高，社会生产和社会生活的面貌改观，加快了国民经济的现代化进程。</li></ul></li><li>国家垄断资本主义并没有根本改变垄断资本主义的性质。<strong>国家垄断资本主义在本质上是资产阶级国家力量同垄断组织力量结合在一起的垄断资本主义</strong>。它在一定程度上促进生产力发展的同时，却加大了对劳动人民的剥削和掠夺，更好地保证了垄断资产阶级获得高额垄断利润，更有利于维护资本主义制度。</li></ul></li><li>金融自由化和金融创新是金融垄断资本形成的重要条件。</li><li>垄断资本向世界范围扩展<ol type="1"><li>垄断资本向世界范围扩展的原因：<ul><li>首先，将国内过剩的资本输出，以便在国外谋求高额利润</li><li>其次，部分技术转移，获取垄断优势，进而谋取高额利润</li><li>再次，争夺商品销售市场</li><li>最后，确保原材料和能源的可靠来源</li><li>垄断资本向世界范围扩展的形式：<ul><li>从输出的形式来看；<ul><li><strong>借贷资本输出</strong>：由资本主义国家的政府、银行、企业把资本贷给其他国家的政府、银行或企业。</li><li><strong>生产资本输出</strong>：在国外直接投资，独立创办企业，与国外资本合营，或者收购国外已有的企业。</li><li><strong>商品资本输出</strong>：把商品卖到世界各地，不断扩大市场，获取高额利润。</li></ul></li><li>从输出的主体来看：私人资本输出、国家资本输出。</li></ul></li></ul></li><li>垄断资本向世界范围扩展带来的影响：<ul><li>对资本输出国的影响：<ul><li>积极作用：<ul><li>资本输出为其带来了巨额利润，加速了资本积累，增强了垄断资本的实力</li><li>带动和扩大了商品输出，巩固和扩大了垄断资本的销售市场和投资场所</li><li>大大改善了国际收支状况</li><li>对发展中国家的经济命脉形成控制，进一步巩固和扩大了垄断优势地位</li></ul></li><li>消极作用：<ul><li>资本输出国可能出现产业空心化</li><li>资本输出国与发展中国家及其他发达国家之间的矛盾会加深</li></ul></li></ul></li><li>对资本输入国(主要是发展中国家)的影响：<ul><li>积极作用：<ul><li>吸收了经济发展所需要的资金，为经济发展创造了条件。</li><li>引进了比较先进的机器设备和工艺技术，同时培训了一批适应现代化生产需要的技术人员、熟练工人和经营管理人员。</li><li>利用外资技术，建立一批现代工业，改造老企业和旧设备，优化了产业结构</li><li>利用外资扩大生产，增加产品产量，提高产品质量，扩大出口，促进了对外贸易发展</li><li>推动了经济发展，增加就业机会，提高了收入水平。</li></ul></li><li>消极作用：<ul><li>付出了较大的经济代价以及环境污染、能源资源消耗的代价</li><li>产业调整与布局有可能受制于外资的投资战略</li><li>外来资本和跨国公司投资增加，冲击本国的民族工业，并影响到国民经济的控制器</li><li>债务负担加重，影响经济的持续稳定发展</li><li>对国际资本的依赖性增强，容易受到国际经济波动的影响。</li></ul></li></ul></li></ul></li></ol></li><li>列宁根据他所处时代的实践曾指出，<strong>资本主义发展到垄断资本主义，进而发展到帝国主义</strong>，便具有五个基本特征：<ul><li>垄断组织在经济生活中起决定作用；</li><li>在金融资本的基础上形成金融寡头的统治；</li><li>资本输出有了特别重要的意义；</li><li>瓜分世界的资本家国际垄断同盟已经形成；</li><li>最大资本主义列强已把世界上的领土分割完毕。<ul><li>这些特征集中体现了帝国主义的实质，即垄断资本凭借垄断地位，获取高额垄断利润。</li></ul></li></ul></li><li><strong>经济全球化</strong>是指国际经济发展中的这样一种趋势，即在生产不断发展、科技加速进步、社会分工和国际分工不断深化、生产的社会化和国际化程度不断提高的情况下，世界各国、各地区的经济活动越来越超出一国和地区的范围而相互紧密地联系在一起。<ul><li>经济全球化的表现：<strong>生产全球化</strong>、<strong>贸易全球化</strong>、<strong>金融全球化</strong></li><li>经济全球化的动因：<ul><li>首先，科学技术的进步和生产力的发展为经济全球化提供了坚实的物质推动力基础和根本的推动力。</li><li>其次，跨国公司的发展为经济全球化提供了适宜的企业组织形式。</li><li>最后，各国经济体制的变革和国际经济组织的发展是经济全球化的体制与组织保障。</li></ul></li><li>经济全球化的影响：<ul><li>发达资本主义国家是经济全球化的主要受益者。</li><li>经济全球化对发展中国家也具有积极的影响。<ul><li>第一，经济全球化为发展中国家提供了先进技术和管理经验。</li><li>第二，经济全球化为发展中国家提供更多的就业机会。</li><li>第三，经济全球化推动发展中国家国际贸易发展。</li></ul></li><li><strong>经济全球化是一把双刃剑</strong>。<ul><li>第一，发达国家与发展中国家在经济全球化过程中的地位和收益不平等、不平衡。</li><li>第二，加剧了发展中国家资源短缺和环境污染恶化。</li><li>第三，一定程度上增加了经济风险。</li></ul></li></ul></li></ul></li></ol><h2 id="第二节-正确认识当代资本主义的新变化">第二节正确认识当代资本主义的新变化</h2><ol type="1"><li>当代资本主义的新变化：<ul><li>生产资料所有制的变化：<ul><li>国家资本所有制形成并发挥重要作用；</li><li>法人资本所有制崛起并成为居主导地位的资本所有制形式。</li></ul></li><li>劳资关系和分配关系的变化：资本家及其代理人采取的缓和劳资关系的激励制度主要有：<ul><li>其一，职工参与决策；</li><li>其二，终身雇佣；</li><li>其三，职工持股。</li></ul></li><li>社会阶级、阶层结构的变化：<ul><li>一是传统的资本家的地位和作用已经发生很大变化。</li><li>二是高级职业经理成为大公司经营活动的实际控制者。</li><li>三是知识型和服务型劳动者的数重不断增加，劳动方式发生了新变化。</li></ul></li><li>经济调节机制和经济危机形态的变化</li><li>政治制度的变化：<ul><li>首先，政治制度出现多元化的趋势，公民权利有所扩大。</li><li>其次，重视并加强法制建设。</li><li>最后，改良主义政党在政治舞台上的影响日益扩大，成为战后西方资本主义国家政治生活中非常引人注目的现象。</li></ul></li></ul></li><li>当代资本主义发生新变化的原因是多方面的，最主要的有：<ul><li>首先，<strong>科学技术</strong>革命和生产力的发展，是资本主义变化的根本推动力量。</li><li>其次，<strong>工人阶级</strong>争取自身权力和利益斗争的作用，是推动资本主义变化的重要力量。</li><li>再次，<strong>社会主义制度初步显示的优越性</strong>对资本主义产生了一定影响。</li><li>最后，主张<strong>改良主义的政党</strong>对资本主义制度的改革，也对资本主义的变化发挥了重要作用。</li></ul></li><li>当代资本主义变化的新特征：<ul><li>第一，科技创新加速了资本主义生产方式的变化：<ul><li>产业结构的调整：形成了以去工业化、经济虚拟化、金融化为主要特征的产业结构模式，一般制造业占比逐渐下降：</li><li>生产组织和劳动形式的变化：以数据的生产、管理、服务等在线化和智能化为主的数字劳动在生产中的地位愈加突出。</li><li>新经济形态的出现：数字经济、智能经济、共享经济。</li></ul></li><li>第二，国际金融垄断资本主义影响日益显现。<ul><li>金融垄断寡头化。</li><li>金融垄断国际化。</li><li>经济虚拟化、产业空心化。</li></ul></li><li>第三，社会阶级层级结构呈现复杂性、多样化。<ul><li>资产阶级内部结构日趋复杂<ul><li>最高层是极少数国际垄断寡头阶层。</li><li>第二层是与前者相联合，以能源、军工、高科技利益集团为主体的国际金融–产业垄断寡头阶层</li><li>占据各产业垄断地位的产业垄断资本家阶层</li><li>由经理资本家、食利者阶层、中小企业资本家构成的一般资本家阶层</li></ul></li><li>工人人阶级内部也逐渐分化<ul><li>“知识工人”数量和增长速度超过“非知识工人”，</li><li>工人阶级内部因技能、收入等方面的差异逐渐分化。</li></ul></li></ul></li><li>第四，发达资本主义国家凭借经济、科技、文化传播等超级优势，在世界范围推行霸权主义和强权政治。</li></ul></li></ol><h2 id="第三节-资本主义的历史地位和发展趋势">第三节资本主义的历史地位和发展趋势</h2><ol type="1"><li>资本主义的历史地位：<ul><li>与封建社会相比，资本主义显示了巨大的历史进步性：<ul><li>资本主义将科学技术转变为强大的生产力。</li><li>资本追求剩余价值的内在动力和竞争的外在压力推动了社会生产力的迅速发展。</li><li>资本主义的意识形态和政治制度作为上层建筑在战胜封建社会自给自足的小生产的生产方式，保护、促进和完善资本主义生产方式方面起着重要作用，从而推动了社会生产力的迅速展，促进了社会进步。</li></ul></li><li>然而，资本主义的历史进步性并不能掩盖其自身的局限性，其表现是：<ul><li>资本主义的基本矛盾阻碍社会生产力的发展。</li><li>资本主义制度下财富占有两极分化，引发经济危机。</li><li>资产阶级支配和控制资本主义经济和政治的发展和运行，不断激化社会矛盾和冲突。</li></ul></li></ul></li><li><strong>资本主义的内在矛盾决定了资本主义必然被社会主义所代替</strong>：<ul><li>资本主义基本矛盾“包含着现代的一切冲突的萌芽”</li><li>资本积累推动资本主义基本矛盾不断激化并最终否定资本主义自身。</li><li>国家垄断资本主义是资本社会化的更高形式，将成为社会主义的前奏。</li><li>资本主义社会存在着资产阶级和无产阶级两大阶级之间的矛盾和斗争。</li></ul></li></ol><h1 id="第六章-社会主义的发展及其规律">第六章社会主义的发展及其规律</h1><h2 id="第一节-社会主义五百年的历史进程">第一节社会主义五百年的历史进程</h2><ol type="1"><li>社会主义从空想到科学<ul><li>空想社会主义发展阶段：<ul><li>16-17世纪的<strong>早期空想社会主义</strong></li><li>18世纪的<strong>空想平均共产主义</strong></li><li>19世纪初期<strong>批判的空想社会主义</strong></li></ul></li><li>开山之作：1516年托马斯·莫尔所的《乌托邦》</li><li>空想社会主义理论的<strong>意义</strong>：<ul><li>空想社会主义对资本主义旧制度的辛辣批判，包含着许多集中要害的见解；对社会主义新制度的描绘，闪烁着天才的火花。</li><li>作为一种批判、否定资本主义的思潮，空想社会主义是早期无产阶级意识和利益的先声，反映了早期无产阶级迫切要求改造现存社会、建立理想的新社会的愿望。</li><li>空想社会主义“提供了启发工人觉悟的极为宝责的饲料”，但是不具备科学的和实践的品格。</li></ul></li><li>空想社会主义的<strong>局限性</strong>：<ul><li>没有指出社会发展的真正出路。</li><li>没有阐明资本主义雇佣制的本质。</li><li>没有发现资本主义发展规律。</li><li>没有找到成为新社会的创造者的社会力量。</li></ul></li><li>科学社会主义：<strong>唯物史观和剩余价值学说</strong></li></ul></li><li>马克思、恩格斯在<strong>揭示人类社会发展一般规律和资本主义发展特殊规律</strong>的基础上，科学论证了<strong>社会主义代替资本主义的历史必然性</strong>，阐明了<strong>无产阶级的历史使命</strong>，提出了<strong>无产阶级革命斗争的战略策略</strong>，科学预见了未来社会的<strong>基本特征</strong>，提出了<strong>从资本主义社会向共产主义社会过渡时期的理论</strong>，创立了<strong>科学社会主义学说</strong>，从根本上超越了空想社会主义，实现了社会主义从空想到科学的伟大飞跃。</li><li>社会主义在中国焕发出蓬勃生机<ul><li>中国共产党领导的社会主义事业经过了从夺取新民主主义革命伟大胜利到完成社会主义革命和推进社会主义建设、进行改革开放和社会主义现代化建设、开创中国特色社会主义新时代的发展过程，在百年奋斗中不断发展壮大，在21世纪焕发出蓬勃生机。</li><li>邓小平：“把马克思主义的普遍真理同我国的具体实际结合起来，走自己的道路，建设有中国特色的社会主义，这就是我们总结长期历史经验得出的基本结论。”</li><li>科学社会主义在中国的成功实践和理论发展，使世界范围内社会主义和资本主义两种社会制度、两种意识形态的历史演进及其较量，发生了有利于社会主义的重大转变。中国特色社会主义高高举起科学社会主义旗帜，向世界表明科学社会主义在21世纪的中国焕发出新的蓬勃生机，突出展现了社会主义的优越性。</li></ul></li></ol><h2 id="第二节-科学社会主义的基本原则不考">第二节科学社会主义的基本原则（不考）</h2><h2 id="第三节-在实践中探索社会主义的发展规律">第三节在实践中探索社会主义的发展规律</h2><ol type="1"><li>社会主义建设过程的长期性<ul><li>第一，<strong>生产力发展状况</strong>的制约。</li><li>第二，<strong>经济基础和上层建筑发展状况</strong>的制约。</li><li>第三，<strong>国际环境</strong>的严峻挑战。</li><li>第四，马克思主义执政党<strong>对社会主义发展道路的探索和对社会主义建设规律的认识</strong>，需要一个长期的过程。</li></ul></li></ol><h1 id="第七章-共产主义崇高理想及其最终实现">第七章共产主义崇高理想及其最终实现</h1><h2 id="第一节-展望未来共产主义新社会">第一节展望未来共产主义新社会</h2><ol type="1"><li>预见未来社会的方法论原则<ul><li>在揭示人类社会发展一般规律的基础上指明社会发展的方向</li><li>在剖析资本主义社会旧世界中阐发未来新世界的特点</li><li>在社会主义社会发展中不断深化对未来共产主义社会的认识</li><li>立足于揭示未来社会的一般特征，而不作详尽的细节描绘</li></ul></li><li>共产主义社会的基本特征<ul><li>物质财富极大丰富，消费资料按需分配</li><li>社会关系高度和谐，人们精神境界极大提高<ul><li><strong>阶级</strong>将会消亡。</li><li><strong>国家</strong>将会消亡。</li><li><strong>战争</strong>将不复存在。</li><li><strong>三大差别</strong>消失：由于社会生产力的巨大发展，工业与农业、城市与乡村、脑力劳动与体力劳动的差别将归于消失。</li><li>不仅社会是和谐的，而且<strong>社会与自然</strong>之间也将达成和谐。</li><li>人们的<strong>精神境界</strong>将得到极大提高。</li></ul></li><li>实现每个人自由而全面的发展，人类从必然王国向自由王国的飞跃。<ul><li><strong>实现人的自由而全面的发展，是马克思主义追求的根本价值目标，也是共产主义社会的根本特征。</strong><ul><li>旧式分工的消除为人的自由而全面的发展创造条件。</li><li>自由时间的延长为人的自由而全面的发展提供了广阔的前景。</li><li>劳动不再是单纯的谋生手段，而成为“生活的第一需要”。</li></ul></li></ul></li></ul></li></ol><h2 id="第二节-实现共产主义是历史发展的必然趋势不考">第二节实现共产主义是历史发展的必然趋势（不考）</h2><h2 id="第三节-共产主义远大理想和中国特色社会主义共同理想不考">第三节共产主义远大理想和中国特色社会主义共同理想（不考）</h2>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 红课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 马原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/_posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/_posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>胡易坤老师</em> 2024-2025学年春季学期教学内容进行整理，部分图片来自胡老师的PPT，若有侵权请联系删除。</p></blockquote><h1 id="quick-links">Quick Links</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5b4e0fea" role="button" aria-expanded="false" aria-controls="collapse-5b4e0fea">        <div class="fold-arrow">▶</div>考点跳转链接      </div>      <div class="fold-collapse collapse" id="collapse-5b4e0fea">        <div class="fold-content">          <ul><li><a href="#conversion-regex----nfa">Regex to NFA</a></li><li><a href="#conversion-nfa----dfa">NFA to DFA</a></li><li><a href="#dfa-simplification">DFA Simplification</a></li></ul><hr><ul><li><a href="#top-down-parsing">Top-Down Parsing</a><ul><li><a href="#recursive-descent-parsing">Recursive-DescentParsing</a></li><li><a href="#predictive-parsing">Predictive Parsing</a><ul><li><a href="#ll1-parsing">LL(1) Parsing</a></li></ul></li></ul></li><li><a href="#bottom-up-parsing">Bottom-Up Parsing</a><ul><li><a href="#shift-reduce-parsing-移位归约解析">Shift-ReduceParsing</a></li><li><a href="#operator-precedence-parsing-运算符优先解析">OPP</a></li><li><a href="#lr-parsing">LR Parsing</a><ul><li><a href="#lr0-parsing">LR(0) Parsing</a></li><li><a href="#slr1-parsing">SLR(1) Parsing</a></li><li><a href="#lr1-parsing">LR(1) Parsing</a></li><li><a href="#lalr1-parsing">LALR(1) Parsing</a></li></ul></li></ul></li></ul><hr><ul><li><a href="#first-and-follow">FIRST and FOLLOW</a></li><li><a href="#leading-and-trailing">LEADING and TRAILING</a></li><li><a href="#closure-and-goto">CLOSURE and GOTO</a></li><li><a href="#lr1s-closure-and-goto">LR(1)’s CLOSURE and GOTO</a></li></ul>        </div>      </div>    </div><h1 id="quick-check">Quick Check</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-fea42ee7" role="button" aria-expanded="false" aria-controls="collapse-fea42ee7">        <div class="fold-arrow">▶</div>各类文法与解析方法      </div>      <div class="fold-collapse collapse" id="collapse-fea42ee7">        <div class="fold-content">          <ul><li><strong>LL(1) Grammar</strong><ul><li>L: 从左到右扫描输入；L：最左派生；1：提前看一个输入符号</li><li>无左递归和左因子</li><li><span class="math inline"><strong>A</strong> → <strong>α</strong>&nbsp;|&nbsp;<strong>β</strong></span>表示两个不同的产生式，则<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>和 <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>是互不相交的集合<ul><li>二者不会同时派生以<span class="math inline"><strong>a</strong></span>开头的字符串</li><li>至多一个<span class="math inline"><strong>α</strong></span>和<span class="math inline"><strong>β</strong></span>可以派生空字符串</li></ul></li><li>如果<span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>，则<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>和<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>是互不相交的集合</li></ul></li><li><strong>LL(1) Parsing</strong><ul><li>提取左因子</li><li>消除直接左递归</li><li>计算<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong></span>和<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong></span></li><li>构造预测分析表（列为终结符，行为非终结符）</li><li>从Start Symbol开始预测/或使用栈和输入缓冲区进行预测分析<ul><li>查表（最左侧非终结符，最左侧未匹配输入符号）作为派生的产生式进行派生</li><li>若使用栈和输入缓冲区，则<ul><li>若栈顶符号为终结符且与输入符号匹配，则出栈并将输入指针后移</li><li>若栈顶符号为非终结符，则查表（栈顶符号，输入指针对应符号）得到派生的产生式，将栈顶符号出栈并将产生式右侧符号逆序入栈</li><li>直到栈为空，输入指针指向<span class="math inline">$</span>，则接受输入</li></ul></li></ul></li></ul></li><li><strong>OG Grammar（算符文法）</strong><ul><li>任意生成式不含两个相邻的非终结符</li><li>不含空生成式</li></ul></li><li><strong>OPP Grammar（算符优先文法）</strong><ul><li>首先满足OG Grammar的要求</li><li>任意两个终结符号对（有序）之间一定满足唯一的优先级关系</li></ul></li><li><strong>OPP Parsing</strong><ul><li>计算<span class="math inline"><strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong></span>和<span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong></span></li><li>构造优先级关系表</li><li>使用栈和输入缓冲区进行运算符优先解析/或使用优先级爬升法<ul><li>若栈顶终结符号优先级 &lt;· / =· 输入符号优先级，则移进</li><li>若栈顶终结符号优先级 &gt;· 输入符号优先级，则归约</li></ul></li></ul></li><li><strong>LR(0) Grammar</strong><ul><li>L:从左到右扫描输入；R：最右派生，最左归约；0：提前看一个输入符号</li><li>任一项集的状态转移不含归约-归约或移进-归约冲突</li></ul></li><li><strong>LR(0) Parsing</strong><ul><li>扩展文法</li><li>通过<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>和<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong></span>构造LR(0)项集族</li><li>构造LR(0)分析表（列为输入符号，行为状态）</li><li>使用栈和输入缓冲区进行LR(0)解析<ul><li>查表，（栈顶，输入符号）为s n，则移进并push状态n到栈顶，</li><li>若为rm，则用第m条产生式进行归约，pop栈顶的符号数目等于产生式右侧符号数目，查（栈顶符号，产生式左侧符号）为n，则push状态n到栈顶</li><li>若为ACCEPT，则接受输入</li></ul></li></ul></li><li><strong>SLR(1) Grammar</strong><ul><li>任一项集的状态转移不含归约-归约或移进-归约冲突<ul><li>LR(0)项目集中存在归约-归约冲突时，两个<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong></span>集的交集为空</li><li>LR(0)项目集中存在移进-归约冲突时，移进的终结符号不在归约的<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong></span>集中</li></ul></li></ul></li><li><strong>SLR(1) Parsing</strong><ul><li>扩展文法、构造集族同LR(0)</li><li>构造SLR(1)分析表时：<ul><li>对<span class="math inline"><strong>A</strong> → <strong>β</strong>⋅</span>归约时, 只对<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>中的终结符进行归约</li><li>对<span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong><sup><strong>′</strong></sup></span>赋值ACCEPT时, 只对<span class="math inline">$</span>接受</li></ul></li><li>使用栈和输入缓冲区进行SLR(1)解析</li></ul></li><li><strong>LR(1) Grammar</strong><ul><li>L:从左到右扫描输入；R：最右派生，最左归约；1：提前看一个输入符号</li><li>LR(1)的项由两部分组成：LR(0)的项和一个lookahead符号</li><li>任一项集的状态转移不含归约-归约或移进-归约冲突<ul><li>无归约-归约冲突：同一状态下如果有多个归约，则前瞻符号不相交</li><li>无移进-归约冲突：同一状态下如果同时有移进和归约，则移进的终结符号不在归约的前瞻符号中</li></ul></li></ul></li><li><strong>LR(1) Parsing</strong><ul><li>扩展文法</li><li>通过<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>和<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong></span>构造LR(1)项集族</li><li>构造LR(1)分析表时：<ul><li>对<span class="math inline">[<strong>A</strong> → <strong>β</strong>⋅, <em>a</em>]</span>归约时, 只对<span class="math inline"><strong>a</strong></span>进行归约</li><li>对<span class="math inline">[<strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅, $]</span>赋值ACCEPT时, 只对<span class="math inline">$</span>接受</li></ul></li><li>使用栈和输入缓冲区进行LR(1)解析</li></ul></li><li><strong>LALR(1) Grammar</strong><ul><li>LA: LookAhead；L:从左到右扫描输入；R：最右派生，最左归约；1：提前看一个输入符号</li><li>LALR(1)的项集族是LR(1)的项集族的同心集合并</li><li>任一项集的状态转移不含归约-归约或移进-归约冲突</li></ul></li><li><strong>LALR(1) Parsing</strong><ul><li>扩展文法、构造集族同LR(0)作为心</li><li>对每个状态的初始项的心，用占位符#作为前瞻符号，通过闭包计算自发生成的前瞻符号和传递关系</li><li>对于传递关系，保留每个状态的内核项，构造传播表</li><li>根据传播表和自发生成的前瞻符号，通过若干轮传播得到每个心最终对应的前瞻符号，得到归约内核项的[心，前瞻符号(若干个)]对</li><li>构造LALR(1)分析表，与LR(1)相同</li><li>使用栈和输入缓冲区进行LALR(1)解析</li></ul></li></ul>        </div>      </div>    </div><h1 id="ch1-intro">Ch1 Intro</h1><h2 id="编译流程">编译流程</h2><p><img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>解释器 vs.&nbsp;编译器 (Interpreter vs.&nbsp;Compiler)<ul><li>解释器方便错误诊断 (Error Diagnosis)</li><li>编译器得到的代码更加高效 <img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h3 id="编译器">编译器</h3><p><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>前端：词法分析(Lexical Analysis)、语法分析(SyntaxAnalysis)、语义分析(Semantic Analysis)、中间代码生成(Intermediate CodeGeneration)</li><li>后端：代码优化(Optimization)、目标代码生成(Code Generation)</li></ul><h2 id="词法分析lexical-analysis">词法分析：Lexical Analysis</h2><ul><li>Lexical Analysis: Scanning （词法分析：扫描）<ul><li>Lexical Analyzer: Scanner （词法分析器：扫描器）</li><li>Recognize Words (Lexemes) -&gt; Tokens &amp; Symbol Table（识别单词（词素）-&gt; 生成标记和符号表）</li><li>Token: &lt;token-name, attribute-value (opt.)&gt;<ul><li>token-name: id, number, keywords, operators, etc.（标记名：标识符、数字、关键字、运算符等）</li><li>attribute-value: a pointer to the symbol table（属性值：指向符号表的指针）</li></ul></li></ul></li></ul><h2 id="语法分析syntax-analysis">语法分析：Syntax Analysis</h2><ul><li>Syntax Analysis: Parsing （语法分析：解析）<ul><li>Syntax Analyzer: Parser （语法分析器：解析器）</li><li>Produce the Grammatical Structure （生成语法结构）<ul><li>The Relationships among Tokens （标记之间的关系）</li><li>Tree-like Intermediate Representation （树状中间表示）</li></ul></li><li>Parse Tree （解析树）<ul><li>Parser generates the Parse Tree, from which produces the Syntax Tree（解析器生成解析树，从中生成语法树）</li></ul></li><li>Syntax Tree: Simplified Parse Tree （语法树：简化的解析树）<ul><li>Interior Node: Operation （内部节点：操作）</li><li>Children: Arguments of the Operation （子节点：操作的参数）</li></ul></li></ul></li></ul><h2 id="词法分析-vs.-语法分析">词法分析 vs.&nbsp;语法分析</h2><ul><li>做着相似的事情：处理字符串</li><li>词法分析 (Scanning)：拆分字符串成Lexemes，并抽象成Tokens</li><li>语法分析 (Parsing)：整理Tokens的逻辑关系</li></ul><h2 id="语义分析semantic-analysis">语义分析：Semantic Analysis</h2><ul><li>Semantic Analysis （语义分析）<ul><li>computing additional info needed for compilation（计算编译所需的附加信息）<ul><li>which is not regarded as syntax （这些信息不被视为语法）</li></ul></li><li>checking source code semantic consistency with the languagedefinition （检查源代码与语言定义的语义一致性）<ul><li>Type Checking （类型检查）</li></ul></li></ul></li></ul><h2 id="中间代码生成intermediate-code-generation">中间代码生成：IntermediateCode Generation</h2><ul><li>Intermediate Code Generation （中间代码生成）<ul><li>Intermediate Representations (IR), e.g., Syntax Tree, etc.（中间表示，例如语法树等）</li><li>Low-level or Machine-like IR （低级或类似机器的中间表示）<ul><li>LLVM-IR (LLVM, Clang), Gimple (GCC), etc.（LLVM-IR（LLVM，Clang），Gimple（GCC）等）</li><li>Three-address Code, with at Most Three Operands per Instruction（三地址码，每条指令最多三个操作数）</li><li>Static Single Assignment (SSA) （静态单赋值）<ul><li>Every variable is only assigned (defined) once and defined beforeused. （每个变量只能被赋值（定义）一次，并且在使用前必须定义。）</li></ul></li></ul></li></ul></li></ul><h2 id="优化optimization">优化：Optimization</h2><ul><li>Optimization （优化）<ul><li>Improve the IR for Better Target Code（改进中间表示以生成更好的目标代码）</li><li>Better: Faster, Smaller, Greener （更好：更快、更小、更环保）</li></ul></li></ul><h2 id="目标代码生成target-code-generation">目标代码生成：Target CodeGeneration</h2><ul><li>Target Code Generation （目标代码生成）<ul><li>Instruction Selection （指令选择）<ul><li>RISC vs.&nbsp;CISC<ul><li>RISC: Reduced Instruction Set Computer （精简指令集计算机）</li><li>CISC: Complex Instruction Set Computer （复杂指令集计算机）</li></ul></li><li>Intel Manual: &gt; 6000 Pages （英特尔手册：超过6000页）</li></ul></li><li>Register Allocation （寄存器分配）<ul><li>Graph Coloring Problem （图着色问题）</li></ul></li><li>Evaluation Order （计算顺序）<ul><li>Arrange the Computation Order for Less Register Occupation（安排计算顺序以减少寄存器占用）</li><li>NPC (Non-Polynomial Complete) Problem （非多项式完全问题）</li></ul></li></ul></li></ul><h1 id="ch2-syntax-definition">Ch2 Syntax Definition</h1><h2 id="文法的定义definition-of-grammars">文法的定义：Definition ofGrammars</h2><h3 id="定义">定义</h3><ul><li>Grammar: a Set of Rules to Describe a Language.</li><li>Language: a Sorted Set of Strings over some fixed Alphabet.</li><li>关系：Grammar Abstracts the Language to Cover All Its Strings.（文法是对语言的抽象，覆盖了语言的所有字符串）</li><li>∅: Empty Language (Set of Strings)</li><li>𝜺: Empty String (Set of Symbols)</li></ul><h3 id="组成">组成</h3><ul><li>Grammar G[S] = (VN, VT, P, S)<ul><li>VT: A set of Terminal Symbols (终结符)<ul><li>Atomic: 基本符号，不可再分</li></ul></li><li>VN : A set of Non-terminals (非终结符)<ul><li>A Non-terminal: a set of strings of Terminals</li></ul></li><li>P: A set of Productions (生成式、规则)<ul><li>A Non-terminal, an Arrow, a sequence of Terminals and/orNon-terminals</li></ul></li><li>S: A Start Symbol (开始符)<ul><li>A Non-terminal</li></ul></li></ul></li></ul><h2 id="推导derivations">推导：Derivations</h2><h3 id="定义-1">定义</h3><ul><li>A Grammar derives strings by beginning with the <strong>StartSymbol</strong> and repeatedly replacing a <strong>Non-terminal</strong>with <strong>Terminals</strong> via its <strong>Productions</strong>.（文法通过从开始符开始，反复用生成式将非终结符替换为终结符来派生字符串）<ul><li>推导（Derivation）：反复根据生成规则用终结符替换非终结符</li><li>归约（Reduction）：推导的反过程</li></ul></li></ul><h3 id="语法分析syntax-analysis-parsing">语法分析（Syntax Analysis,Parsing）</h3><ul><li>given a sequence of Terminals, figure out Whether it can be Derivedfrom the Grammar and How if possible.（给定一个终结符序列，判断它是否可以由文法推导而来，如果可以，推导过程是什么）</li><li>一个语言可能有多个文法描述，而一个文法只会派生一个唯一语言</li></ul><h2 id="文法的二义性ambiguity">文法的二义性：Ambiguity</h2><h3 id="定义-2">定义</h3><ul><li>语法树（Parse Tree）: A Graphical Representation of a Derivationwithout the Order of Applying Productions.（语法树是一个图形表示，表示了一个推导过程，但不考虑生成式应用的顺序）</li><li>二义性（Ambiguity）: When Parsing, given a sequence of Terminals, aGrammar is Ambiguous if there are more than one Parse Tree for theDerivation.（二义性是指一个文法可以产生多棵语法树） ### Fix theGrammar</li><li>Example:<ul><li>stmt -&gt; if expr then stmt | if expr then stmt else stmt |other</li><li>if E1 then if E2 then S1 else S2</li></ul></li><li>Match each else with the <strong>closest unmatched then</strong><ul><li>the statement appearing between a then and an else must be“matched”</li><li>the interior statement must not end with an unmatched (open)then</li></ul></li><li>Listing All Cases then Tidying Them Up<ul><li>if expr then matched_stmt</li><li>if expr then open_stmt</li><li>if expr then matched_stmt else matched_stmt</li><li>if expr then matched_stmt else open_stmt</li><li>so that:<ul><li>matched_stmt -&gt; if expr then matched_stmt else matched_stmt |other</li><li>open_stmt -&gt; if expr then matched_stmt | if expr then open_stmt |if expr then matched_stmt else open_stm</li></ul></li><li>finally:<ul><li>stmt -&gt; matched_stmt | open_stmt</li><li>matched_stmt -&gt; if expr then matched_stmt else matched_stmt |other</li><li>open_stmt -&gt; if expr then stmt | if expr then matched_stmt elseopen_stmt</li></ul></li></ul></li></ul><h2 id="文法和语言的分类classes-of-languages">文法和语言的分类：Classesof Languages</h2><p><img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>范围由 Type 0 到 Type 3 逐渐缩小</li></ul><h1 id="ch3-scanning">Ch3 Scanning</h1><h2 id="词法分析lexical-analysis-1">词法分析：Lexical Analysis</h2><h3 id="token-pattern-and-lexemes">Token, Pattern, and Lexemes</h3><ul><li>The Analysis Partitions Input String into Substrings.（分析将输入字符串划分为子字符串。） <img src="image-4.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>Token</strong>: &lt;token-name, attribute-value(opt.)&gt;<ul><li>token-name: the role of lexical unit （词法单元的角色）<ul><li>often refer to Token by its token-name</li></ul></li><li>attribute-value: any info associated to the Token（与Token相关的任何信息）<ul><li>Generally, it has only ONE value: a pointer to the Symbol Table（通常只有一个值：指向符号表的指针）<ul><li>In practice, the value of a constant can be stored as the attribute.（在实践中，常量的值可以作为属性存储。）<ul><li>constant: strings, numbers （常量：字符串、数字）</li></ul></li></ul></li></ul></li></ul></li><li><strong>Pattern</strong>: description of the form lexemes of a tokenmay （描述词法单元的形式）<ul><li>regular expression: , ?, *, +, …</li></ul></li><li><strong>Lexeme</strong>: a sequence of characters matches a token’spattern （与模式匹配的字符序列）<ul><li>Token vs.&nbsp;Lexeme: Class vs.&nbsp;Instance in C++</li></ul></li></ul><p><img src="image-7.webp" srcset="/img/loading/loading3.gif" lazyload></p><h2 id="specification-of-tokens">Specification of Tokens</h2><h3 id="strings-and-languages">Strings and Languages</h3><ul><li>String: a finite sequence of Symbols from an Alphabet（字符串：来自字母表的有限符号序列）</li><li>Language: any countable set of Strings（语言：任何可数的字符串集合）</li><li>Terms for Parts of a String s （字符串s的部分术语）:<ul><li>prefix：前缀<ul><li>any string obtained by removing zero or more symbols from the end ofs</li></ul></li><li>suffix：后缀<ul><li>any string obtained by removing zero or more symbols from thebeginning of s</li></ul></li><li>substring：子串<ul><li>any string obtained by removing any prefix or any suffix from s（去掉前缀或后缀）</li></ul></li><li>subsequence：子序列<ul><li>any string obtained by removing zero or more not necessarilyconsecutive position of s （不一定连续的位置）</li></ul></li></ul></li></ul><h3 id="operations-on-languages">Operations on Languages</h3><ul><li><strong>Union</strong>: （并集）<ul><li><span class="math inline"><em>L</em><sub>1</sub> ∪ <em>L</em><sub>2</sub> = {<em>x</em>|<em>x</em> ∈ <em>L</em><sub>1</sub>  <em>o</em><em>r</em>  <em>x</em> ∈ <em>L</em><sub>2</sub>}</span></li></ul></li><li><strong>Concatenation</strong>: （连接）<ul><li><span class="math inline"><em>L</em><sub>1</sub><em>L</em><sub>2</sub> = {<em>x</em><em>y</em>|<em>x</em> ∈ <em>L</em><sub>1</sub>  <em>a</em><em>n</em><em>d</em>  <em>y</em> ∈ <em>L</em><sub>2</sub>}</span></li></ul></li><li><strong>Kleene closure</strong>: （星闭包）<ul><li><span class="math inline">$L^* = \bigcup_{1=0}^\infty L^i \\= {𝜖} ∪L ∪ L^2 ∪ L^3 ∪ ... \\= \{x | x = x_1x_2...x_n, n ≥ 0, xi ∈L\}$</span></li><li>𝜖 is the empty string</li></ul></li><li><strong>Positive closure</strong>: （正闭包）<ul><li><span class="math inline">$L^+ = \bigcup_{1=1}^\infty L^i \\= LL^*\\= \{x | x = x_1x_2...x_n, n ≥ 1, xi ∈ L\}$</span></li></ul></li></ul><h3 id="regular-expressions">Regular Expressions</h3><h4 id="定义-3">定义</h4><ul><li><strong>Regular Expression (Regex)</strong>: a way to describePatterns of Tokens of a programming language.（正则表达式：描述编程语言的词法单元模式的一种方式）<ul><li>Each Regular Expression r denotes a Language L<span class="math inline">(<em>r</em>)</span>.（每个正则表达式r表示一个语言L<span class="math inline">(<em>r</em>)</span>）<ul><li>Regular Language, Type-3 Language</li></ul></li><li>The Regular Expressions are built recursively out of smaller ones,using the rules. （正则表达式是用规则递归构建的）</li></ul></li></ul><h4 id="语法">语法</h4><ul><li><strong>BASIS</strong> （基础）<ul><li>𝜀 is a regular expression, and L(𝜀) = {𝜀}, the empty set.（空字符）</li><li>a is a symbol in a set Σ, then a is a regular expression, and L(a) ={a}. （集合中的字符）</li></ul></li><li><strong>INDUCTION</strong> （归纳）：Suppose <span class="math inline"><em>r</em></span> and <span class="math inline"><em>s</em></span> are expressions denoting <span class="math inline"><em>L</em>(<em>r</em>)</span> and <span class="math inline"><em>L</em>(<em>s</em>)</span><ul><li><span class="math inline"><em>r</em>|<em>s</em></span> : a regularexpression denoting <span class="math inline"><em>L</em>(<em>r</em>) ∪ <em>L</em>(<em>s</em>)</span></li><li><span class="math inline"><em>r</em><em>s</em></span> : a regularexpression denoting <span class="math inline"><em>L</em>(<em>r</em>)<em>L</em>(<em>s</em>)</span></li><li><span class="math inline"><em>r</em><sup>*</sup></span> : a regularexpression denoting <span class="math inline">(<em>L</em>(<em>r</em>))<sup>*</sup></span></li><li><span class="math inline">(<em>r</em>)</span> : a regular expressiondenoting <span class="math inline"><em>L</em>(<em>r</em>)</span><ul><li>We can add additional brackets around expressions.（我们可以在表达式周围添加额外的括号。）</li></ul></li></ul></li><li><strong>定律</strong>： <img src="image-6.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="regular-definitions">Regular Definitions</h3><ul><li><strong>Regular Definition</strong>: a set of productions withnon-terminals derived by regular expressions.（正则定义：一组通过正则表达式派生的非终结符的产生式）</li></ul><h3 id="extensions-of-regex">Extensions of Regex</h3><ul><li><span class="math inline">+</span> : one or more instances<ul><li><span class="math inline"><em>r</em><sup>*</sup></span> = <span class="math inline"><em>r</em><sup>+</sup></span> | 𝜖</li><li><span class="math inline"><em>r</em><sup>+</sup></span> = <span class="math inline"><em>r</em><em>r</em><sup>*</sup></span> = <span class="math inline"><em>r</em><sup>*</sup><em>r</em></span></li></ul></li><li><span class="math inline">?</span> : zero or one instance<ul><li><span class="math inline"><em>r</em>?</span> = <span class="math inline"><em>r</em></span> | 𝜖</li></ul></li><li><span class="math inline">[  ]</span> : character classes<ul><li><span class="math inline">[<em>a</em><em>b</em><em>c</em>]</span> =<span class="math inline"><em>a</em></span> | <span class="math inline"><em>b</em></span> | <span class="math inline"><em>c</em></span></li><li><span class="math inline">[<em>a</em> − <em>z</em>]</span> = <span class="math inline"><em>a</em></span> | <span class="math inline"><em>b</em></span> | … | <span class="math inline"><em>z</em></span></li></ul></li></ul><h3 id="regular-language-grammar-and-regex">Regular Language / Grammar,and Regex</h3><p><img src="image-5.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li><strong>Regular Expression</strong> <span class="math inline"><em>r</em></span> denotes a Language <span class="math inline"><em>L</em>(<em>r</em>)</span>.<ul><li>Regular Language is Type-3 Language （正则语言是类型3语言）</li><li>Regular Language is that denoted by Regular Expressions.（正则语言是由正则表达式表示的）</li></ul></li><li><strong>Regular Grammar</strong> is the grammar describes a RegularLanguage.<ul><li>with the production form of <span class="math inline"><strong>A</strong> → <em>α</em></span> or <span class="math inline"><strong>A</strong> → <em>α</em><strong>B</strong></span></li></ul></li></ul><h2 id="recognition-of-tokens">Recognition of Tokens</h2><h3 id="input-buffer">Input Buffer</h3><p><img src="image-8.webp" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="transition-diagrams">Transition Diagrams</h3><ul><li><strong>Transition Diagram = Nodes + Edges</strong>, a Flowchart（状态流程图 = 节点 + 边）<ul><li><strong>Nodes</strong>: <strong>states, conditions</strong> thatcould occur when looking for a lexeme that matches one pattern.（节点：状态）<ul><li><strong>States</strong>: Circles （状态：圆圈）</li><li><strong>Start State</strong>: Arrowhead, Beginning of a Pattern（起始状态：箭头，开始）</li><li><strong>End State(s)</strong>: <strong>Double Circles</strong>, Endof a Pattern （终止状态：双圆圈，结束）</li></ul></li><li><strong>Edge</strong>: <strong>actions</strong>, taken to transitfrom one State to Another. （边：动作）<ul><li>labeled by a Symbol or a set of Symbols for matching（标记为符号或符号集以进行匹配）</li></ul></li><li><strong>Deterministic</strong>: at most ONE edge out of a givenstate with a given label. （确定性：在给定状态下，最多有一条边）</li></ul></li><li><strong>Example</strong>: <img src="image-51.webp" srcset="/img/loading/loading3.gif" lazyload><ul><li>*<strong>(Retract)</strong>: A Token has been accepted while anotherchar has been read which must be unread.（回退：一个Token已经被接受，而另一个不应读取字符已经被读取，必须回退）</li></ul></li></ul><h3 id="reserved-words-保留字">Reserved Words （保留字）</h3><ul><li>Keywords look like Identifiers.<ul><li>if, then, …</li></ul></li><li>Add reserved words into symbol table initially.（在符号表中添加保留字）</li><li>Create <strong>separate transition diagrams</strong> for eachkeyword. （为每个关键字创建单独的转换图）<ul><li>thenextone</li><li><img src="image-52.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h2 id="有穷自动机finite-automata">有穷自动机：Finite Automata</h2><h3 id="finite-automata">Finite Automata</h3><ul><li><strong>What</strong>: an Abstract Machine that can be in exactlyone of a Finite number of States at any given time.（有限自动机：在任何给定时间只能处于有限数量的状态之一的抽象机器）<ul><li>Finite Automation = Finite-state Automation (FSA, plural: automata)（有限自动机 = 有限状态自动机）<ul><li>Finite-state Machine (FSM), or simply State Machine（有限状态机，或简单地称为状态机）</li></ul></li><li>changes from one state to another according to Inputs, calledTransition （根据输入，从一个状态变化到另一个状态，称为转换）</li></ul></li><li><strong>Why</strong>: used as the Recognizer for Scanning,identifying Tokens （用于扫描的识别器，识别token）</li><li><strong>How</strong>: answers “YES” or “NO” about each input String（如何：对每个输入字符串回答“是”或“否”）<ul><li>determines whether the String is valid for the given Grammar（确定字符串是否符合给定的语法）</li></ul></li></ul><h3 id="dfa-vs.-nfa">DFA vs.&nbsp;NFA</h3><ul><li>FA: <strong>Deterministic (DFA) or Non-deterministic(NFA)</strong></li><li><strong>DFA</strong>: have <strong>exactly/at most oneaction</strong> for each input symbol （每个输入符号有一个动作）<ul><li>can be represented with a Transition Diagram</li><li>Recognition with DFA: Faster, may take More Space（识别DFA：更快，可能占用更多空间）</li><li>complex to represent Regex, but more Precise, widely used（复杂表示正则表达式，但更精确，广泛使用）</li></ul></li><li><strong>NFA</strong>: can have <strong>multiple actions</strong> forthe same input symbol （同一输入符号可以有多个动作）<ul><li>can be represented with a Transition Graph</li><li>Recognition with NFA: Slower, may take Less Space（识别NFA：较慢，可能占用更少的空间）</li><li>simply represents Regex, but less Precise（简单表示正则表达式，但不够精确）</li></ul></li><li><strong>Example</strong>: <img src="image-9.webp" srcset="/img/loading/loading3.gif" lazyload></li><li>Lexical Analysis <strong>Workflow</strong> with FA:<ul><li>Regex -&gt; NFA -&gt; DFA</li><li>Regex -&gt; DFA</li></ul></li></ul><h3 id="nondeterministic-finite-automata-nfa">Nondeterministic FiniteAutomata (NFA)</h3><ul><li><strong>An NFA M = <span class="math inline"><strong>(</strong><strong>S</strong><strong>,</strong> <strong>𝜮</strong><strong>,</strong> <strong>m</strong><strong>o</strong><strong>v</strong><strong>e</strong><strong>,</strong> <strong>𝒔</strong><sub><strong>0</strong></sub><strong>,</strong> <strong>F</strong><strong>)</strong></span></strong>consists of:<ul><li><span class="math inline"><strong>S</strong></span>: a finite set ofStates （有限状态集）</li><li><span class="math inline"><strong>𝜮</strong></span>: the InputAlphabet, excluding 𝜖 （不包含𝜖的输入符号集合）</li><li><span class="math inline"><strong>m</strong><strong>o</strong><strong>v</strong><strong>e</strong></span>,a Transition Function （转换函数）<ul><li>move(State, Symbol) = set of Next States</li><li>move: <span class="math inline"><em>𝑆</em> × (<em>Σ</em> ∪ {<em>𝜖</em>}) ⟶ <em>ℙ</em>(<em>𝑆</em>)</span></li></ul></li><li><span class="math inline"><strong>s</strong><sub><strong>0</strong></sub> ∈ <strong>S</strong></span>,the Start State (or Initial State) （起始状态）</li><li><span class="math inline"><strong>F</strong> ⊆ <strong>S</strong></span>, aset of Accepting States (or Final States) （终止状态）</li></ul></li><li>An NFA accepts Input String <span class="math inline"><em>s</em></span> iff<ul><li>there exists some path in the Transition Graph from the Start Stateto one Accepting State, （存在一条路径从起始状态到一个接受状态）</li><li>such that symbols along the path spell out <span class="math inline"><em>s</em></span> （路径上的符号拼写出<span class="math inline"><em>s</em></span>）</li></ul></li><li><strong>Transition Tables</strong>：<strong>rows</strong> forStates, <strong>columns</strong> for Input Symbols and 𝝐<ul><li>Example: <img src="image-10.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h3 id="deterministic-finite-automata-dfa">Deterministic Finite Automata(DFA)</h3><ul><li><strong>What</strong>: a Special Case of an NFA, where<ul><li>there are <strong>no moves</strong> on symbol 𝜖, and</li><li>for each state s and input symbol a, there is <strong>ExactlyONE</strong> edge out of s labeled by a.（每个状态s和输入符号a，恰好有一条边出s标记为a）<ul><li><strong>COMPLETE</strong>: It defines from each state a transitionfor each input symbol. （完整：它定义了从每个状态到每个输入符号的转换）<ul><li>Transition function is a total function.</li></ul></li><li><strong>Local Automation</strong>: DFA not necessarily complete (…At Most ONE edge …) （局部自动机：DFA不一定是完全图）<ul><li>Transition function is a partial function.</li></ul></li></ul></li></ul></li></ul><h2 id="algorithm-for-simulation">Algorithm for Simulation</h2><h3 id="conversion-nfa-dfa">Conversion: NFA –&gt; DFA</h3><ul><li><strong>Subset Construction</strong> （子集构造）<ul><li>removing 𝜖-transitions</li><li>combining multiple NFA’s states into ONE constructed DFA’s state（将多个NFA的状态组合成一个构造的DFA的状态，即：等势点合并）</li></ul></li><li><strong>Definitions</strong>:<ul><li><strong>𝜖-closure(s)</strong>:<ul><li>s: some State</li><li>= Set of NFA <strong>States</strong> reached by state s via𝜖-transitions, including s itself.（NFA中可以通过若干个空变换到达的状态的集合）</li></ul></li><li><strong>𝜖-closure(T)</strong>:<ul><li>T: set of <strong>States</strong></li><li>= <span class="math inline">∪<sub><em>s</em> ∈ <em>T</em></sub></span>𝜖-closure(s)</li></ul></li><li><strong>move(T, a)</strong>:<ul><li>T: set of States</li><li>a: Input Symbol</li><li>= NFA’s <strong>States</strong> reached by 𝑠 ∈ 𝑇 on a.</li></ul></li></ul></li><li><strong>Algorithm Subset Construction</strong><ul><li>Input: the start State <strong>s0</strong> and the TransitionDiagram of NFA <strong>N</strong>.</li><li>Output: Transition Graph of DFA <strong>Dtran</strong><figure class="shiki java"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">add 𝝐</span><span style="color: #56B6C2">-</span><span style="color: #61AFEF">closure</span><span style="color: #E06C75">(s0) into Dstates </span><span style="color: #7F848E; font-style: italic">//将初始状态s0的𝝐闭包加入Dstates</span></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">Dstates</span><span style="color: #E06C75"> has unsearched state S) { </span><span style="color: #7F848E; font-style: italic">//当Dstates有未搜索的状态S时</span></span><span class="line"><span style="color: #E06C75">    tag </span><span style="color: #E5C07B">S</span><span style="color: #E06C75"> as searched </span><span style="color: #7F848E; font-style: italic">//将S标记为已搜索</span></span><span class="line"><span style="color: #E06C75">    foreach input symbol a { </span><span style="color: #7F848E; font-style: italic">//对每个输入符号a</span></span><span class="line"><span style="color: #E06C75">        U </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> 𝝐</span><span style="color: #56B6C2">-</span><span style="color: #61AFEF">closure</span><span style="color: #E06C75">(</span><span style="color: #61AFEF">move</span><span style="color: #E06C75">(S</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a)) </span><span style="color: #7F848E; font-style: italic">//设U为S进行a动作后状态S'的𝝐闭包</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">U</span><span style="color: #E06C75"> is </span><span style="color: #C678DD">new</span><span style="color: #E06C75"> to Dstates) { </span><span style="color: #7F848E; font-style: italic">//如果U是Dstates中的新状态</span></span><span class="line"><span style="color: #E06C75">            add </span><span style="color: #E5C07B">U</span><span style="color: #E06C75"> into </span><span style="color: #E5C07B">Dstates</span><span style="color: #E06C75"> as unsearched </span><span style="color: #7F848E; font-style: italic">//将U加入Dstates并标记为未搜索</span></span><span class="line"><span style="color: #E06C75">        }</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #61AFEF">Dtran</span><span style="color: #E06C75">(S</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a) </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> U </span><span style="color: #7F848E; font-style: italic">//将Dtran(S, a)设为U</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">}</span></span></code></pre></div></div></figure></li><li><strong>最后得到的Dtran是一个DFA的转换表</strong>，Dstates是DFA的状态集合。</li></ul></li><li><strong>Algorithm 𝜖-closure(T) Computation</strong>:<ul><li>上一步中<code>U = 𝝐-closure(move(S, a))</code>的实现逻辑：</li><li>Input: the State Set T</li><li>Output: 𝜖-closure(T) <figure class="shiki java"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">push all states in </span><span style="color: #E5C07B">T</span><span style="color: #E06C75"> onto Stack </span><span style="color: #7F848E; font-style: italic">//将T中的所有状态压入栈中</span></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">Stack</span><span style="color: #E06C75"> is not empty) { </span><span style="color: #7F848E; font-style: italic">//当栈不为空时</span></span><span class="line"><span style="color: #E06C75">    s </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> </span><span style="color: #E5C07B">Stack</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">()</span><span style="color: #E06C75"> </span><span style="color: #7F848E; font-style: italic">//弹出栈顶元素s</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #61AFEF">foreach</span><span style="color: #E06C75"> (state u reached by s via 𝜖) { </span><span style="color: #7F848E; font-style: italic">//对于每个s通过𝜖能达到的状态u</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (u is not in 𝜖</span><span style="color: #56B6C2">-</span><span style="color: #61AFEF">closure</span><span style="color: #E06C75">(T)) { </span><span style="color: #7F848E; font-style: italic">//如果u不在T的𝜖闭包中</span></span><span class="line"><span style="color: #E06C75">            add u into 𝜖</span><span style="color: #56B6C2">-</span><span style="color: #61AFEF">closure</span><span style="color: #E06C75">(T) </span><span style="color: #7F848E; font-style: italic">// 将其加入T的𝜖闭包</span></span><span class="line"><span style="color: #E06C75">            </span><span style="color: #E5C07B">Stack</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(u)</span><span style="color: #E06C75"> </span><span style="color: #7F848E; font-style: italic">//将u压入栈中</span></span><span class="line"><span style="color: #E06C75">        }</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">}</span></span></code></pre></div></div></figure></li></ul></li><li><strong>Example</strong>: <img src="image-11.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="conversion-regex-nfa">Conversion: Regex –&gt; NFA</h3><ul><li>McNaughton-Yamada-Thompson Algorithm</li><li>Regex’s Definition:<ul><li><strong>BASIS</strong>: <img src="image-12.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>INDUCTION</strong>: <img src="image-13.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>Example</strong>: <img src="image-14.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h2 id="workflow">Workflow</h2><ul><li>The <strong>Workflow</strong> of Lexical Analyzer<ul><li>Regex –&gt; NFA Construction</li><li>NFA –&gt; DFA Construction</li><li>Simulating DFA to Recognize Tokens</li></ul></li><li>Convert Regex Directly into DFA: PASS</li><li><strong>DFA Simplification</strong>: Minimizing the Number ofStates</li></ul><h2 id="dfa-simplification">DFA Simplification</h2><ul><li><strong>What and Why</strong>:<ul><li><strong>no REDUNDANT states</strong> （无冗余状态）<ul><li>REDUNDANCE: the states that NO accepted input string’s path passesthrough （没有路径到达终止状态的状态）</li><li>(in the transition graph)</li></ul></li><li><strong>no EQUIVALENT states</strong> （无等效状态）<ul><li>EQUIVALENCE: states with the SAME side effects（具有相同副作用的状态）</li><li>(making the states indistinguishable)</li></ul></li><li><strong>Distinguish States via Input String</strong>（通过输入字符串区分状态）<ul><li>State: s, t</li><li>String: x</li><li>x distinguishes s from t,<ul><li>if one state can reach an accepting state via x, while the othercannot. （如果一个状态可以通过x到达终止状态，而另一个状态不能）</li></ul></li><li>s is distinguishable from t,<ul><li>if there is some string distinguishes them.（存在一些字符串可以区分它们）</li></ul></li><li>Unify Indistinguishable States into One.（将不可区分的状态合并为一个）</li></ul></li></ul></li><li><strong>How</strong>：<ol type="1"><li>Start with the initial partition <span class="math inline"><strong>Π</strong></span> with two groups, the<strong>accepting</strong> and <strong>non-accepting</strong> states ofthe DFA. （将DFA的接受状态和非接受状态分为两个组）</li><li>Let <span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub> <strong>:=</strong> <strong>Π</strong></span>.Then, for each group <span class="math inline"><strong>G</strong></span>of <span class="math inline"><strong>Π</strong></span>: （初始时令<span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub> <strong>=</strong> <strong>Π</strong></span>，然后对于每个组G）<ul><li>For each input symbol <span class="math inline"><strong>a</strong></span>, states <span class="math inline"><strong>s</strong>, <strong>t</strong></span> in<span class="math inline"><strong>G</strong></span> are partitioned ifthey transit to different groups of <span class="math inline"><strong>Π</strong></span> via <span class="math inline"><strong>a</strong></span>;（对于每个输入符号a，如果状态s和t通过a转移到不同的组，则他们被划分为不同的组）</li><li>Replace <span class="math inline"><strong>G</strong></span> in <span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub></span>by the new subgroups. （用新的子组替换<span class="math inline"><strong>G</strong></span>）</li></ul></li><li>If <span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub> ≠ <strong>Π</strong></span>,<span class="math inline"><strong>Π</strong> <strong>:</strong>  <strong>=</strong> <strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub></span>and repeat Step 2, Step 4 otherwise. （如果<span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub> ≠ <strong>Π</strong></span>，则令<span class="math inline"><strong>Π</strong> <strong>:</strong>  <strong>=</strong> <strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub></span>并重复步骤2，否则跳到步骤4）</li><li>Aggregate the transitions among groups. （将组之间的转换聚合）</li><li>The resulting DFA is the minimized DFA.（得到的DFA是最小化的DFA）</li></ol></li><li><strong>Example</strong>:<img src="image-15.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h1 id="ch4-parsing">Ch4 Parsing</h1><h2 id="词法分析lexical-analysis-2">词法分析：Lexical Analysis</h2><h3 id="parser">Parser</h3><ul><li><strong>What</strong>: Given Tokens, Parsing Verifies whether theToken Names Can Be Generated by the Grammar for the Source Language.（给定tokens，解析会验证token名称是否可以由源语言的语法生成）</li><li><strong>Why</strong>: We expect the Parser<ul><li>to <strong>report Syntax Errors</strong> （报告语法错误）</li><li>to recover from Errors to continue following processes.（从错误中恢复以继续后续过程）</li></ul></li><li><strong>How</strong>: Derivation or Reduction<ul><li><strong>Top-down</strong> and <strong>Bottom-up</strong>Parsing</li></ul></li></ul><p><img src="image-16.webp" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="compiler-errors">Compiler Errors</h3><ul><li>Lexical Errors<ul><li>The string does not match the pattern of any token.（字符串与任何token的模式不匹配）</li></ul></li><li>Syntactic Errors<ul><li>The string does not meet the requirements of the grammar.（字符串不符合语法要求）</li></ul></li><li>Semantic Errors: Type Mismatching （语义错误：类型不匹配）</li></ul><h3 id="error-recovery-strategies">Error-Recovery Strategies</h3><ul><li><strong>Panic-Mode Recovery</strong><ul><li>Discarding input symbols one at a time until meeting synchronizingtokens （丢弃输入符号，直到遇到同步tokens）<ul><li>synchronizing tokens, e.g.&nbsp;“;”, “}”, etc., decided by designers</li></ul></li><li>simple, but may cause more errors</li></ul></li><li><strong>Phrase-Level Recovery</strong><ul><li>Local Correction on Input, allowing the parser to continue（允许解析器继续）<ul><li>e.g., “,” → “;”, delete/insert “;”</li><li>designers’ responsibility</li></ul></li><li>helpless if error occurs before the point of detection</li></ul></li><li><strong>Error Productions</strong><ul><li>augmenting grammar with productions generating erroneous constructs（用产生错误构造的产生式扩充语法）</li><li>relying on designers</li></ul></li><li><strong>Global Correction</strong><ul><li>choosing a minimal sequence of changes for a globally least-costcorrection （选择一系列最小的变化，以实现全局最低成本的修正）</li><li>costly, yardstick? should defined by designers</li></ul></li></ul><h2 id="context-free-grammar-cfg">Context-Free Grammar (CFG)</h2><h3 id="definition">Definition</h3><ul><li>A <strong>Context-Free Grammar</strong> consists of:<ul><li>Terminals</li><li>Non-terminals</li><li>Start Symbol</li><li>Productions: <span class="math inline"><strong>A</strong> → <strong>α</strong></span><ul><li>Header / Left Side → Body / Right Side<ul><li>Header: A <strong>Non-terminal</strong></li><li>Body: <strong>zero or more Terminals or Non-terminals</strong></li></ul></li><li><span class="math inline"><strong>V</strong><sub><strong>N</strong></sub> → (<strong>V</strong><sub><strong>T</strong></sub>|<strong>V</strong><sub><strong>N</strong></sub>)<sup>*</sup></span></li></ul></li></ul></li></ul><h3 id="derivation">Derivation</h3><ul><li><p><strong>What</strong>: Beginning with the Start Symbol, replace aNon-terminal by the body of one of its Production.（从起始符号开始，用其产生式的右侧替换非终结符）</p></li><li><p><strong>Why</strong>:</p><ul><li>corresponding to <strong>Top-down</strong> Construction of a ParseTree （对应于自顶向下构造解析树）</li><li>helpful for Bottom-up Parsing</li></ul></li><li><p><strong>How</strong>:</p><ul><li>$$ : derive in one step</li><li>$ $ : derive in zero or more steps<ul><li><span class="math inline">$\alpha \overset{*}{\Rightarrow}\alpha$</span></li><li>if <span class="math inline">$\alpha \overset{*}{\Rightarrow}\beta$</span> and <span class="math inline">$\beta\overset{*}{\Rightarrow} \gamma$</span>, then <span class="math inline">$\alpha \overset{*}{\Rightarrow} \gamma$</span></li></ul></li><li>$ $ : derive in one or more steps</li></ul></li><li><p><span class="math inline">$\mathbf{S} \overset{*}{\Rightarrow}\alpha$</span></p><ul><li><span class="math inline"><em>α</em></span> is a <strong>SententialForm</strong> of S. （<span class="math inline"><em>α</em></span>是S的一个句子形式）</li><li><span class="math inline"><em>α</em></span> may contain<strong>Terminals</strong>, <strong>Non-terminals</strong>, or may be<strong>Empty</strong>.</li><li>Sentence: a Sentential Form without Non-terminals.（没有非终结符的句子形式）</li></ul></li><li><p>What is a <strong>Language</strong>?</p><ul><li><span class="math inline"><em>L</em>(<em>G</em>)</span>: set ofSentences generated by the Grammar <span class="math inline"><em>G</em></span></li><li>A string of terminals $ L(G) $ if and only if $ $ is a Sentence of $G $ (or $ S $).</li></ul></li><li><p><strong>Example</strong>: <img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload></p></li><li><p><strong>Leftmost Derivation</strong>: the Leftmost Non-terminalis always replaced at first （最左边的非终结符总是第一个被替换）</p><ul><li>$ $</li></ul></li><li><p><strong>Rightmost Derivation</strong>: $ $</p></li><li><p><strong>Parse Trees and Derivations</strong></p><ul><li>What: A Graphical Representation of a Derivation （派生的图形表示）<ul><li>filtering out the order in which productions applied to replacenon-terminals （过滤出应用于替换非终结符的产生式的顺序）</li></ul></li><li><strong>Example</strong>： <img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h2 id="top-down-parsing">Top-Down Parsing</h2><ul><li><strong>What</strong>: Create the Parse Tree from Top to Bottom（从上到下创建解析树）<ul><li>from root to leaves （从根到叶）</li></ul></li><li><strong>Why</strong>: for Parsing</li><li><strong>How</strong>: Derive an Input String in the<strong>Leftmost</strong> Manner （以最左边的方式派生输入字符串）<ul><li>consistent with string scanning （与字符串扫描一致）</li><li><strong>Key</strong>: determine the production to be applied for anon-terminal （确定要应用于非终结符的产生式）</li><li><strong>Recursive-Descent Parsing</strong><ul><li>require <strong>backtracking</strong> to find right production（需要回溯以找到正确的产生式）</li><li>general, but inefficient</li></ul></li><li><strong>Predictive Parsing</strong><ul><li>a special case of Recursive-Descent Parsing</li><li>no backtracking, choosing by <strong>looking ahead</strong> at inputsymbols （无需回溯，通过提前查看输入符号进行选择）</li></ul></li></ul></li></ul><h3 id="recursive-descent-parsing">Recursive-Descent Parsing</h3><figure class="shiki java"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">void</span><span style="color: #E06C75"> </span><span style="color: #61AFEF">A</span><span style="color: #E06C75">() {</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #7F848E; font-style: italic">// Choose an A-production, A --&gt; X1 X2 ...Xk;</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">for</span><span style="color: #E06C75"> (i </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> </span><span style="color: #D19A66">1</span><span style="color: #E06C75"> to k) {</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">Xi</span><span style="color: #E06C75"> is a non</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">terminal)</span></span><span class="line"><span style="color: #E06C75">            call </span><span style="color: #61AFEF">Xi</span><span style="color: #E06C75">()</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">Xi</span><span style="color: #E06C75"> equals the current input symbol a)</span></span><span class="line"><span style="color: #E06C75">            advance the input to the next symbol</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> </span><span style="color: #ABB2BF">...</span><span style="color: #E06C75"> </span><span style="color: #7F848E; font-style: italic">// an error has occurred</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">}</span></span></code></pre></div></div></figure><ul><li>Example: <img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="left-recursion-左递归">Left Recursion （左递归）</h4><ul><li><strong>What</strong>: The Grammar has a non-terminal A such thatthere exists a derivation <span class="math inline">$\mathbf{A}\overset{+}{\Rightarrow} \mathbf{A} \alpha$</span>（文法有一个非终结符A，使得存在一个派生<span class="math inline">$\mathbf{A} \overset{+}{\Rightarrow} \mathbf{A}\alpha$</span>）</li><li><strong>Why</strong>: Recursive-Descent Parsing cannot handle LeftRecursion. （递归下降解析无法处理左递归）</li><li><strong>How</strong>: Transform the grammar to <strong>eliminateLeft Recursion</strong>. （转换文法以消除左递归）<ul><li>==<strong>Immediate Elimination</strong>: <span class="math inline"><strong>A</strong> → <strong>A</strong><em>α</em>|<em>β</em>   ⇒ <strong>A</strong> → <em>β</em><strong>A</strong><sup><strong>′</strong></sup>, <strong>A</strong><sup><strong>′</strong></sup> → <em>α</em><strong>A</strong><sup><strong>′</strong></sup>|<em>𝝐</em></span>==</li><li>$ _1 | | _m &nbsp;| &nbsp;_1 | | _n &nbsp; (_1 | | _n) , (_1 | | _m) | $</li></ul></li><li><strong>Example</strong>: <img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="left-recursion-elimination-消除左递归">Left RecursionElimination （消除左递归）</h4><ul><li><strong>INPUT</strong>: Grammar G without Cycles or 𝝐-productions（无循环或𝝐产生式的文法）<ul><li>Cycle: <span class="math inline">$\mathbf{A}\overset{+}{\Rightarrow} \mathbf{A}$</span></li><li>𝝐-production: <span class="math inline"><strong>A</strong> → <em>ϵ</em></span></li></ul></li><li><strong>OUTPUT</strong>: Equivalent Grammar <strong>without LeftRecursions</strong> （没有左递归的等效文法）</li><li><strong>Steps</strong>: <figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">supposing</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">there</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">are</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">the</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Non</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">terminals</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">with</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Order</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">A1</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">A2</span><span style="color: #ABB2BF">..., </span><span style="color: #E06C75">An</span></span><span class="line"><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">from</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">to</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">n</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">j</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">from</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">to</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">replace</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">each</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Ai</span><span style="color: #ABB2BF"> → </span><span style="color: #E06C75">Aj𝛾</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">by</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Ai</span><span style="color: #ABB2BF"> → </span><span style="color: #E06C75">𝛿1𝛾</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">𝛿2𝛾</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> ... </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">𝛿𝑘𝛾</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">where</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">Aj</span><span style="color: #ABB2BF">  → </span><span style="color: #E06C75">𝛿1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">𝛿2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> ... </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">𝛿𝑘</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">are</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">all</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">current</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Aj</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">productions</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">eliminate</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">the</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Immediate</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Left</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Recursion</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">among</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">the</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Ai</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">productions</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure></li><li><strong>Example</strong>: <img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="predictive-parsing">Predictive Parsing</h3><ul><li><strong>What</strong>: recursive-descent parsers needing nobacktracking （不需要回溯的递归下降解析器）<ul><li>can be constructed for LL(k) grammar （可以为LL(k)文法构造）<ul><li><strong>L</strong>: scanning input <strong>from Left toright</strong></li><li><strong>L</strong>: producing a <strong>Leftmostderivation</strong></li><li><strong>k</strong>: using <strong>k input symbols</strong> oflookahead at each step to make decision</li></ul></li></ul></li><li><strong>Why</strong>: a unique production to apply, or none to use(error)</li><li><strong>Example: LL(1)</strong><ul><li>stmt → <strong>i</strong>f (expr) stmt else stmt |<strong>w</strong>hile (expr) stmt | <strong>{</strong> stmt_list}</li></ul></li><li><strong>How</strong>: FIRST and FOLLOW<ul><li>assist in choosing which production to apply, based on the nextinput symbol （根据下一个输入符号选择应用哪个产生式）</li></ul></li></ul><h4 id="first-and-follow">FIRST and FOLLOW</h4><ul><li><strong>FIRST</strong>: the set of terminals that begin stringsderived from a non-terminal or a string of grammar symbols.（从非终结符或语法符号字符串派生的字符串开始的终结符集合）<ul><li><strong>FIRST(𝜶)</strong>: what the first symbol would be for 𝜶</li><li><strong>𝜶</strong>: string of grammar symbols</li><li><strong>return</strong>: set of terminals that begin strings derivedfrom 𝜶<ul><li>first symbols of strings derived from 𝜶</li></ul></li><li><strong>HOW</strong>：<ul><li>if <span class="math inline"><strong>X</strong></span> is aterminal, then <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong> = {<strong>X</strong>}</span></li><li>if <span class="math inline"><strong>X</strong></span> is anon-terminal, and <span class="math inline"><strong>X</strong> → <strong>Y</strong><sub><strong>1</strong></sub><strong>Y</strong><sub><strong>2</strong></sub>…<strong>Y</strong><sub><strong>k</strong></sub></span><ul><li>add all <strong>non-𝝐</strong> symbols of <span class="math inline"><strong>Y</strong><sub><strong>1</strong></sub></span>to <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong></span></li><li>add all <strong>non-𝝐</strong> symbols of <span class="math inline"><strong>Y</strong><sub><strong>2</strong></sub></span>to <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong></span>,if <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>1</strong></sub><strong>)</strong></span></li><li>···</li><li>add all <strong>non-𝝐</strong> symbols of <span class="math inline"><strong>Y</strong><sub><strong>k</strong></sub></span>to <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong></span>,if <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>1</strong></sub><strong>)</strong></span>and <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>2</strong></sub><strong>)</strong></span>and ··· and <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>k</strong> <strong>−</strong> <strong>1</strong></sub><strong>)</strong></span></li><li>add <strong>𝝐</strong> to <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong></span>,if <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>1</strong></sub><strong>)</strong></span>and <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>2</strong></sub><strong>)</strong></span>and ··· and <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>k</strong></sub><strong>)</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>FOLLOW</strong>: the set of terminals that can appearimmediately to the right of a non-terminal in some sentential form.（在某些句子形式中，可以出现在非终结符右侧的终结符集合）<ul><li><strong>FOLLOW(N)</strong>: what is the next symbol of N</li><li><strong>N</strong>: a non-terminal</li><li><strong>return</strong>: set of terminals can appear immediatelyafter N in a sentential form</li><li><strong>HOW</strong>:<ul><li>place <strong>$</strong> in <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>S</strong><strong>)</strong></span><ul><li><strong>S</strong>: start symbol</li><li><strong>$</strong>: input right end-marker</li></ul></li><li>for each production <span class="math inline"><strong>M</strong> → <em>α</em><strong>N</strong><em>β</em></span><ul><li>add all symbols in <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>to <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>N</strong><strong>)</strong></span>,except 𝝐</li><li>if <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>,add all symbols in <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>M</strong><strong>)</strong></span>to <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>N</strong><strong>)</strong></span></li></ul></li><li>for each production <span class="math inline"><strong>M</strong> → <em>α</em><strong>N</strong></span><ul><li>add all symbols in <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>M</strong><strong>)</strong></span>to <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>N</strong><strong>)</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-23.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h4 id="ll1-grammar">LL(1) Grammar</h4><ul><li><strong>What</strong>: Any <span class="math inline"><strong>A</strong> → <strong>α</strong>&nbsp;|&nbsp;<strong>β</strong></span>Represents two Distinct Productions （<span class="math inline"><strong>A</strong> → <strong>α</strong>&nbsp;|&nbsp;<strong>β</strong></span>表示两个不同的产生式）<ul><li><span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>and <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>are disjoint sets.（二者是互不相交的集合）<ul><li>For no terminal <span class="math inline"><strong>a</strong></span>,do both <span class="math inline"><strong>α</strong></span> and <span class="math inline"><strong>β</strong></span> derive strings beginningwith <span class="math inline"><strong>a</strong></span>.（二者不会同时派生以<span class="math inline"><strong>a</strong></span>开头的字符串）</li><li>At most one of <span class="math inline"><strong>α</strong></span>and <span class="math inline"><strong>β</strong></span> can derive theempty string. （至多一个<span class="math inline"><strong>α</strong></span>和<span class="math inline"><strong>β</strong></span>可以派生空字符串）</li></ul></li><li>If <span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>,then <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>and <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>are disjoint sets. （如果<span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>，则<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>和<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>是互不相交的集合）</li></ul></li><li><strong>Why</strong>: Proper Production is Selected by Looking<strong>ONLY</strong> at the Next Input Symbol.（通过仅查看下一个输入符号来选择适当的产生式）</li><li><strong>How</strong>: By Parsing Table, a Two-Dimensional Array<ul><li><span class="math inline"><strong>M</strong><strong>[</strong><strong>A</strong><strong>,</strong> <strong>a</strong><strong>]</strong> = <strong>α</strong></span>,when deriving <span class="math inline"><strong>A</strong></span>, apply<span class="math inline"><strong>A</strong> → <strong>α</strong></span>if coming up with <span class="math inline"><strong>a</strong></span>.（当派生<span class="math inline"><strong>A</strong></span>时，如果出现<span class="math inline"><strong>a</strong></span>，则应用<span class="math inline"><strong>A</strong> → <strong>α</strong></span>）</li></ul></li></ul><h4 id="ll1-parsing">LL(1) Parsing</h4><ul><li><strong>Predictive Parsing Table Construction</strong><ul><li><strong>INPUT</strong>: Grammar G.</li><li><strong>OUTPUT</strong>: Parsing Table M.</li><li><strong>STEPS</strong>: For each production <span class="math inline"><strong>A</strong> → <strong>α</strong></span>:<ol type="1"><li>For each terminal <span class="math inline"><strong>a</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>,add <span class="math inline"><strong>A</strong> → <strong>α</strong></span> to<span class="math inline"><strong>M</strong><strong>[</strong><strong>A</strong><strong>,</strong> <strong>a</strong><strong>]</strong></span>.</li><li>If <span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>,then for each terminal <span class="math inline"><strong>b</strong> ∈ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>,add <span class="math inline"><strong>A</strong> → <strong>α</strong></span> to<span class="math inline"><strong>M</strong><strong>[</strong><strong>A</strong><strong>,</strong> <strong>b</strong><strong>]</strong></span>.</li><li>If <span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>and <span class="math inline"><strong>$</strong> ∈ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>,add <span class="math inline"><strong>A</strong> → <strong>α</strong></span> to<span class="math inline"><strong>M</strong><strong>[</strong><strong>A</strong><strong>,</strong> <strong>$</strong><strong>]</strong></span>.</li></ol></li><li><strong>Example</strong>: <img src="image-24.webp" srcset="/img/loading/loading3.gif" lazyload> <img src="image-25.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>Implementation</strong><ul><li>Stack-based Method, mimicking a leftmost derivation（基于栈的方法，模仿最左派生）</li></ul><img src="image-26.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="left-factoring">Left Factoring</h4><ul><li>When the decision is not clear, defer it until seeing enoughsymbols. （当决策不明确时，推迟到看到足够的符号为止）</li><li><strong>Left-Factored</strong>:<ul><li><span class="math inline"><strong>A</strong> → <strong>𝜶</strong><strong>𝜷</strong><sub><strong>1</strong></sub>|<strong>𝜶</strong><strong>𝜷</strong><sub><strong>2</strong></sub>  <em>b</em><em>y</em>  <strong>A</strong> → <strong>𝜶</strong><strong>A</strong><sup><strong>′</strong></sup>, <strong>A</strong><sup><strong>′</strong></sup> → <strong>𝜷</strong><sub><strong>1</strong></sub>|<strong>𝜷</strong><sub><strong>2</strong></sub></span></li></ul></li><li><strong>How</strong>:<ul><li>For each non-terminal <span class="math inline"><strong>A</strong></span>, find the longest commonprefix <span class="math inline"><strong>𝜶</strong></span> of itsalternatives.</li><li>If <span class="math inline"><strong>𝜶</strong></span> is not empty,replace all of the <span class="math inline"><strong>A</strong></span>-productions</li></ul></li><li><strong>Example</strong>:<ul><li><span class="math inline"><strong>A</strong> → <strong>𝜶</strong><strong>𝜷</strong><sub><strong>1</strong></sub>|<strong>𝜶</strong><strong>𝜷</strong><sub><strong>2</strong></sub>|...|<strong>𝜶</strong><strong>𝜷</strong><sub><strong>n</strong></sub>|<strong>𝜸</strong>    <em>b</em><em>y</em>    <strong>A</strong> → <strong>𝜶</strong><strong>A</strong><sup><strong>′</strong></sup>|<em>𝜸</em>, <strong>A</strong><sup><strong>′</strong></sup> → <strong>𝜷</strong><sub><strong>1</strong></sub>|<strong>𝜷</strong><sub><strong>2</strong></sub>|...|<strong>𝜷</strong><sub><strong>n</strong></sub></span></li></ul></li></ul><h4 id="non-ll1-grammar">Non-LL(1) Grammar</h4><ul><li>Non-LL(1) Grammars:<ul><li>grammars with Left Recursion （左递归的文法）</li><li>grammars not Left Factored （未左因子化的文法）</li><li>grammars with Ambiguity （歧义文法）</li></ul></li><li>Thus, before Predictive Parsing,<ul><li><strong>perform Left Factoring</strong> （左因子化）</li><li><strong>eliminate Left Recursion</strong> (prerequisite of theelimination?) （消除左递归）</li><li>remove Ambiguity （消除歧义）</li></ul></li></ul><h2 id="bottom-up-parsing">Bottom-Up Parsing</h2><ul><li><strong>What</strong>: the construction of a parse tree beginning atthe leaves and working up to the root（从叶子开始构建解析树，直到根）</li><li><strong>Why</strong>: not all grammars can be made LL(1)</li><li><strong>How</strong>: construct rightmost derivation in the reverseorder<ul><li><strong>Reduction</strong>: “Reversed Derivation”（归约：反向派生）<ul><li>from the string to the start symbol （从字符串到起始符号）</li><li>The body of a production is replaced by the non-terminal at itsheader. （用产生式的头部替换产生式的主体）</li></ul></li><li><span class="math inline">$S \overset{rm}{\Rightarrow} \gamma_0\overset{rm}{\Rightarrow} \gamma_1 \overset{rm}{\Rightarrow} \dots\overset{rm}{\Rightarrow} \gamma_n \overset{rm}{\Rightarrow}\omega$</span><ul><li>find the rightmost derivation in the reverse order: “leftmostreduction” （找到右侧派生的反向顺序：最左侧归约）</li></ul></li><li>“<strong>L</strong>eft-to-Right, <strong>R</strong>ightmostDerivation in Reverse”: <strong>LR Parsing</strong></li></ul></li><li><strong>Example</strong>： <img src="image-27.webp" srcset="/img/loading/loading3.gif" lazyload><ul><li><span class="math inline"><em>E</em> ⇒ <em>T</em> ⇒ <em>T</em> * <em>F</em> ⇒ <em>T</em> * <em>i</em><em>d</em> ⇒ <em>F</em> * <em>i</em><em>d</em> ⇒ <em>i</em><em>d</em> * <em>i</em><em>d</em></span></li></ul></li></ul><h3 id="handles">Handles</h3><ul><li><strong>What</strong>: if <span class="math inline">$\mathbf{S}\overset{*}{\Rightarrow} \mathbf{\alpha A \omega}\overset{}{\Rightarrow} \mathbf{\alpha \beta \omega}$</span>, thenproduction <span class="math inline"><strong>A</strong> <strong>→</strong> <strong>β</strong></span>in the position following <span class="math inline"><strong>α</strong></span> is a<strong>handle</strong> of <span class="math inline"><strong>α</strong><strong>β</strong><strong>ω</strong></span>.<ul><li>a substring that matches the body of a production, representing astep of reduction （与产生式的主体匹配的子字符串，表示归约的一步）</li><li>a pair of values: <strong>(production, position)</strong></li></ul></li><li><strong>Why</strong>: handle pruning for bottom-up parsing（处理底向上解析的剪枝）<ul><li>identify handles and reduce them to the appropriate leftmostnon-terminals （识别句柄并将其归约到适当的最左非终结符）</li></ul></li><li><strong>How</strong>: by using a stack to keep track of the currentposition in the input string and the corresponding production rules（使用栈来跟踪输入字符串中的当前位置和相应的产生式规则）</li><li><strong>Example</strong>： <img src="image-28.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="shift-reduce-parsing-移进归约解析">Shift-Reduce Parsing（移进归约解析）</h3><ul><li><strong>How</strong>: Stack + Input Buffer<ul><li><strong>Stack</strong>: reduced Grammar Symbols</li><li><strong>Input Buffer</strong>: rest of the String to be parsed</li></ul></li><li><strong>Actions</strong><ul><li><strong>Shift</strong>: move the next symbol onto stack</li><li><strong>Reduce</strong>: replace the handle on the top of stack</li><li><strong>Accept</strong>: announce the success of parsing</li><li><strong>Error</strong>: discover syntax errors, and call forrecovery</li></ul></li><li><strong>Example</strong>: <img src="image-29.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="operator-precedence-parsing-运算符优先解析">Operator-PrecedenceParsing （运算符优先解析）</h3><ul><li><strong>What</strong>: a shift-reduce parser handlingoperator-precedence grammar （处理运算符优先文法的移位归约解析器）<ul><li>operator-precedence grammar: a subset of LR(1) grammar（运算符优先文法：LR(1)文法的一个子集）</li><li>for each Production:<ul><li>no 𝝐 in the body （主体中没有空字符）</li><li>no two consecutive non-terminals in the body（在主体中没有两个连续的非终结符）</li></ul></li></ul></li><li><strong>Why</strong>: to handle expressions with operator precedenceand associativity （处理具有运算符优先级和结合性的表达式）</li><li><strong>How</strong>: find handles according precedence<ul><li><strong>Precedence</strong> （优先级）<ul><li><span class="math inline"><strong>a</strong> &lt; ·<strong>b</strong></span>:a’s precedence is lower than b’s</li><li><span class="math inline"><strong>a</strong> = ·<strong>b</strong></span>: …is equal to …</li><li><span class="math inline"><strong>a</strong> &gt; ·<strong>b</strong></span>:… is higher than …</li></ul></li><li><strong>Precedence Climbing Method</strong> （优先级爬升法）<ul><li>scan the input <strong>from Left to Right</strong> until &gt;· isencountered</li><li>then, scan <strong>backward</strong> until &lt;· is encountered</li><li>that between &lt;· and &gt;· is the <strong>handle</strong></li></ul></li><li><strong>Implementation with STACK</strong> (栈实现)<ul><li>let <span class="math inline"><strong>a</strong></span> be the<strong>top Terminal</strong> on the STACK （栈顶终结符）</li><li>let <span class="math inline"><strong>b</strong></span> be the INPUTSymbol under processing （正在处理的输入符号）</li><li>if <span class="math inline"><strong>a</strong> &lt; ·<em>o</em><em>r</em> = ·<strong>b</strong></span>,<strong>Shift</strong></li><li>else if <span class="math inline"><strong>a</strong> &gt; ·<strong>b</strong></span>,<strong>Reduce</strong></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-30.webp" srcset="/img/loading/loading3.gif" lazyload> <img src="image-31.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="opp-precedence-relation-construction-优先级关系构造">OPP:Precedence Relation Construction （优先级关系构造）</h3><h4 id="precedence-relation">Precedence Relation</h4><ul><li>If operator <span class="math inline"><strong>a</strong></span> hashigher precedence than <span class="math inline"><strong>b</strong></span><ul><li><span class="math inline"><strong>a</strong> &gt; ·<strong>b</strong></span></li><li><span class="math inline"><strong>b</strong> &lt; ·<strong>a</strong></span></li></ul></li><li>If <span class="math inline"><strong>a</strong></span> and <span class="math inline"><strong>b</strong></span> has equal precedence<ul><li>if left-associative, then <span class="math inline"><strong>a</strong> &gt; ·<strong>b</strong></span>and <span class="math inline"><strong>b</strong> &gt; ·<strong>a</strong></span></li><li>if right-associative, then <span class="math inline"><strong>a</strong> &lt; ·<strong>b</strong></span>and <span class="math inline"><strong>b</strong> &lt; ·<strong>a</strong></span></li></ul></li><li>For all operator <span class="math inline"><strong>a</strong></span><ul><li><span class="math inline"><strong>a</strong> &lt; ·<em>i</em><em>d</em>,  <em>i</em><em>d</em> &gt; ·<strong>a</strong></span></li><li><span class="math inline">$ &lt; ·<strong>a</strong>,  <strong>a</strong> &gt; ·$</span></li><li><span class="math inline"><strong>a</strong> &lt; ·(,  ( &lt; ·<strong>a</strong>,  <strong>a</strong> &gt; ·),  ) &gt; ·<strong>a</strong></span></li><li><span class="math inline">( = ·)</span></li></ul></li></ul><h4 id="leading-and-trailing">LEADING and TRAILING</h4><ul><li><strong>LEADING</strong>: the set of symbols that can appear at thebeginning of a string derived from a non-terminal（可以出现在从非终结符派生的字符串开头的符号集合）<ul><li><span class="math inline">$\mathbf{LEADING(Q)} = \{\mathbf{Y},\mathbf{N} \ | \ \mathbf{Q} \overset{+}{\Rightarrow} \mathbf{Y\delta} \or\  \mathbf{Q} \overset{+}{\Rightarrow} \mathbf{N Y \delta}, \mathbf{N}\in \mathbf{V_n}, \mathbf{Y} \in \mathbf{V_t}\}$</span></li><li>for <span class="math inline"><strong>Q</strong> → <strong>Y</strong><strong>δ</strong></span>or <span class="math inline"><strong>Q</strong> → <strong>N</strong><strong>Y</strong><strong>δ</strong></span>,we have:<ul><li><span class="math inline"><strong>Y</strong>, <strong>N</strong> ∈ <strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>Q</strong><strong>)</strong></span></li><li><span class="math inline"><strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>N</strong><strong>)</strong> ⊆ <strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>Q</strong><strong>)</strong></span></li></ul></li></ul></li><li><strong>TRAILING</strong>: the set of symbols that can appear at theend of a string derived from a non-terminal（可以出现在从非终结符派生的字符串末尾的符号集合）<ul><li><span class="math inline">$\mathbf{TRAILING(P)} = \{\mathbf{X},\mathbf{N} \ | \ \mathbf{P} \overset{+}{\Rightarrow} \mu \mathbf{X} \ or\ \mathbf{P} \overset{+}{\Rightarrow} \mu \mathbf{X} \mathbf{N},\mathbf{N} \in \mathbf{V_n}, \mathbf{X} \in \mathbf{V_t}\}$</span></li><li>for <span class="math inline"><strong>P</strong> → <em>μ</em><strong>X</strong></span>or <span class="math inline"><strong>P</strong> → <em>μ</em><strong>X</strong><strong>N</strong></span>,we have:<ul><li><span class="math inline"><strong>X</strong>, <strong>N</strong> ∈ <strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>P</strong><strong>)</strong></span></li><li><span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>N</strong><strong>)</strong> ⊆ <strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>P</strong><strong>)</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-32.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="constructing-precedence-relations">Constructing PrecedenceRelations</h4><ul><li><span class="math display"><strong>X</strong> = ·<strong>Y</strong></span><ul><li>if there is <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>Y</strong><strong>β</strong></span>,where <span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong></span>,<span class="math inline"><strong>α</strong>, <strong>β</strong> ∈ <strong>V</strong><sup><strong>*</strong></sup></span></li><li>or, there is <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>N</strong><strong>Y</strong><strong>β</strong></span>,where <span class="math inline"><strong>N</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub> ∪ {<strong>ϵ</strong>}</span>,<span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong><sub><strong>t</strong></sub></span><ul><li>adjacent symbols have equal precedence （相邻符号具有相等的优先级）<ul><li>at least one of them is a terminal （至少有一个是终结符）</li></ul></li><li>e.g., <span class="math inline"><strong>E</strong> + <strong>T</strong></span>,<span class="math inline"><strong>T</strong> * <strong>F</strong></span>,<span class="math inline"><strong>E</strong>+ = <strong>T</strong></span></li></ul></li></ul></li><li><span class="math display"><strong>X</strong> &lt; ·<strong>Y</strong></span><ul><li>if there is <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>Q</strong><strong>β</strong></span>,and <span class="math inline">$\mathbf{Q} \overset{+}{\Rightarrow}\mathbf{Y \delta}$</span>, where <span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong></span>,<span class="math inline"><strong>Q</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,<span class="math inline"><strong>α</strong>, <strong>β</strong>, <strong>δ</strong> ∈ <strong>V</strong><sup><strong>*</strong></sup></span></li><li>or, there is <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>Q</strong><strong>β</strong></span>,and <span class="math inline">$\mathbf{Q} \overset{+}{\Rightarrow}\mathbf{N Y \delta}$</span>, where <span class="math inline"><strong>N</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub> ∪ {<strong>ϵ</strong>}</span>,<span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong><sub><strong>t</strong></sub></span><ul><li><span class="math inline">$\mathbf{LEADING(Q)} = \{\mathbf{Y},\mathbf{N} \ | \ \mathbf{Q} \overset{+}{\Rightarrow} \mathbf{Y\delta} \or\  \mathbf{Q} \overset{+}{\Rightarrow} \mathbf{N Y \delta}\}$</span><ul><li>for <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>Q</strong><strong>β</strong></span>,we have <span class="math inline"><strong>X</strong></span> &lt;·Symbols in <span class="math inline"><strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>Q</strong><strong>)</strong></span></li></ul></li></ul></li></ul></li><li><span class="math display"><strong>X</strong> &gt; ·<strong>Y</strong></span><ul><li>if there is <span class="math inline"><strong>A</strong> → <em>α</em><strong>P</strong><strong>Y</strong><em>β</em></span>,and <span class="math inline">$\mathbf{P} \overset{+}{\Rightarrow} \mu\mathbf{X}$</span>, where <span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong></span>,<span class="math inline"><strong>P</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,<span class="math inline"><em>α</em>, <em>β</em>, <em>μ</em> ∈ <strong>V</strong><sup>*</sup></span></li><li>or, there is <span class="math inline"><strong>A</strong> → <em>α</em><strong>P</strong><strong>Y</strong><em>β</em></span>,and <span class="math inline">$\mathbf{P} \overset{+}{\Rightarrow} \mu\mathbf{X} \mathbf{N}$</span>, where <span class="math inline"><strong>N</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub> ∪ {<em>ϵ</em>}</span>,<span class="math inline"><strong>P</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,<span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong><sub><strong>T</strong></sub></span></li><li><span class="math inline">$\mathbf{TRAILING(P)} = \{\mathbf{X},\mathbf{N} \ | \ \mathbf{P} \overset{+}{\Rightarrow} \mu \mathbf{X} \\text{or} \ \mathbf{P} \overset{+}{\Rightarrow} \mu \mathbf{X}\mathbf{N}\}$</span><ul><li>for <span class="math inline"><strong>A</strong> → <em>α</em><strong>P</strong><strong>Y</strong><em>β</em></span>,we have Symbols in <span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>P</strong><strong>)</strong> &gt; ·<strong>Y</strong></span></li></ul></li></ul></li></ul><h4 id="precedence-table">Precedence Table</h4><ul><li><strong>Steps</strong>：<ul><li>for each production <span class="math inline"><strong>A</strong> → <strong>X</strong><sub><strong>1</strong></sub><strong>X</strong><sub><strong>2</strong></sub><strong>…</strong><strong>X</strong><sub><strong>k</strong></sub></span>:<ul><li>for each <span class="math inline"><strong>X</strong></span><ul><li>if <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>,then <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> = ·<strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub></span></li><li>if <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>2</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,then <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> = ·<strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>2</strong></sub></span></li><li>if <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,then <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> &lt; ·<strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub><strong>)</strong></span></li><li>if <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>,then <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> = ·<strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub></span>and <span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>X</strong><sub><strong>i</strong></sub><strong>)</strong> &gt; ·<strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub></span></li></ul></li></ul></li><li>for the Start Symbol <span class="math inline"><strong>S</strong></span>:<ul><li><span class="math inline">$ &lt; ·<strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>S</strong><strong>)</strong></span></li><li><span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>S</strong><strong>)</strong> &gt; ·$</span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-33.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="opp-some-more">OPP: Some More</h3><ul><li>Unary Minus vs.&nbsp;Binary Minus （一元负号与二元负号）</li><li>Leave It to Scanners （留给扫描器）<ul><li>return two different tokens for the two（返回两个不同的tokens）</li><li>lookahead is required （需要向前看）</li></ul></li><li>OPPs are not used often in practice （运算符优先级在实践中不常用）<ul><li>limited scenarios and applications （有限的场景和应用）</li><li>but, simple -&gt; part of a complex parsing system（但简单，是复杂解析系统的一部分）</li></ul></li></ul><h2 id="lr-parsing">LR Parsing</h2><ul><li><strong>What</strong>:<ul><li>left-to-right scanning</li><li>rightmost derivation in reverse</li></ul></li><li><strong>Why</strong><ul><li>can recognize virtually all programming languages of context-freegrammars （几乎可以识别所有上下文无关文法的编程语言）</li><li>is the most general non-backtracking shift-reduce parsing methodknown （已知的最通用的非回溯移位归约解析方法）<ul><li>yet is still efficient （仍然高效）</li></ul></li><li>can detect a syntax error as soon as possible（尽快检测语法错误）</li><li>is a proper superset of the predictive parsing（是预测解析的适当超集）</li></ul></li></ul><h3 id="lr0-parsing">LR(0) Parsing</h3><h4 id="items-and-the-lr0-automaton">Items and the LR(0) Automaton</h4><ul><li><strong>Problem</strong>: when to shift and when to reduce?<ul><li>how to decide whether that on the top of the stack is a handle?（如何判断栈顶的句柄？）</li></ul></li><li><strong>LR(0) Items</strong>: a production with a dot at someposition in its body （LR(0) 项目：在其主体的某个位置有一个点的产生式）<ul><li>prefixes of a valid production, indicating how much we have seen atthe point （有效产生式的前缀，指示我们在该点上已经看到多少）</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong><strong>Z</strong></span>yields four items（例如<span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong><strong>Z</strong></span>产生四个项）：<ul><li><span class="math inline"><strong>A</strong> → ⋅<strong>X</strong><strong>Y</strong><strong>Z</strong></span>:hope to see <span class="math inline"><strong>X</strong><strong>Y</strong><strong>Z</strong></span>next on the input</li><li><span class="math inline"><strong>A</strong> → <strong>X</strong> ⋅ <strong>Y</strong><strong>Z</strong></span>:hope to see <span class="math inline"><strong>Y</strong><strong>Z</strong></span> next onthe input</li><li><span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong> ⋅ <strong>Z</strong></span>:hope to see <span class="math inline"><strong>Z</strong></span> next onthe input</li><li><span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong><strong>Z</strong>⋅</span>:hope to see nothing next on the input</li></ul></li><li>kind of state + transition → automaton</li></ul></li><li><strong>Kernel and Non-Kernel Items</strong><ul><li><strong>Kernel Items</strong>: the Initial Item + those whose dotsare not at the left</li><li><strong>Non-Kernel Items</strong>: Otherwise</li></ul></li><li><strong>LR(0) Automaton</strong>: <strong>CLOSURE + GOTO</strong><ul><li><strong>CLOSURE</strong>: set of <strong>Items</strong>（项集的闭包）</li><li><strong>GOTO</strong>: the <strong>Transition Function</strong>（转换函数）</li></ul></li></ul><h4 id="closure-and-goto">CLOSURE and GOTO</h4><ul><li><span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>:<ul><li><span class="math inline"><strong>I</strong></span>: a set of Itemsfor a grammar <span class="math inline"><strong>G</strong></span>（文法<span class="math inline"><strong>G</strong></span>的项集）</li><li>construct by two rules:<ol type="1"><li>every Item in <span class="math inline"><strong>I</strong></span> isadded in to <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>（<span class="math inline"><strong>I</strong></span>中的每个项目都添加到<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>中）</li><li>if <span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>B</strong><strong>β</strong></span>is in <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>and <span class="math inline"><strong>B</strong> → <strong>γ</strong></span> is aproduction of <span class="math inline"><strong>G</strong></span>, thenadd <span class="math inline"><strong>B</strong> → ⋅<strong>γ</strong></span> to<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>（如果<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>B</strong><strong>β</strong></span>在<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>中，并且<span class="math inline"><strong>B</strong> → <strong>γ</strong></span>是<span class="math inline"><strong>G</strong></span>的一个产生式，则将<span class="math inline"><strong>B</strong> → ⋅<strong>γ</strong></span>添加到<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>中）</li></ol></li><li><strong>Example</strong>: <img src="image-34.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>:<ul><li><span class="math inline"><strong>I</strong></span>: a set of Itemsfor a grammar <span class="math inline"><strong>G</strong></span>（文法<span class="math inline"><strong>G</strong></span>的项集）</li><li><span class="math inline"><strong>X</strong></span>: a grammarsymbol （文法符号）</li><li>the closure of the set of items [<span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong> ⋅ <strong>β</strong></span>]such that [<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>X</strong><strong>β</strong></span>]is in <span class="math inline"><strong>I</strong></span> （<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>是<span class="math inline"><strong>I</strong></span>中所有形如[<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>X</strong><strong>β</strong></span>]的项所对应的项[<span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong> ⋅ <strong>β</strong></span>]的集合的闭包）<ul><li>the transition from the state for <span class="math inline"><strong>I</strong></span> under input <span class="math inline"><strong>X</strong></span> （在输入<span class="math inline"><strong>X</strong></span>下，<span class="math inline"><strong>I</strong></span>的状态转换）</li></ul></li><li>construct by<ol type="1"><li>for each Item <span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>X</strong><strong>β</strong></span>in <span class="math inline"><strong>I</strong></span></li><li>then every Item in <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>A</strong> <strong>→</strong> <strong>α</strong><strong>X</strong> <strong>⋅</strong> <strong>β</strong><strong>)</strong></span>is added to <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span></li></ol></li><li><strong>Example</strong>: <img src="image-35.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h4 id="automaton-construction">Automaton Construction</h4><ul><li><strong>INPUT</strong>: a grammar <span class="math inline"><strong>G</strong></span></li><li><strong>OUTPUT</strong>: a LR(0) automaton</li><li><strong>Construction</strong>:<ol type="1"><li>augment <span class="math inline"><strong>G</strong></span> to <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>by adding a new start symbol <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup></span>and production <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong></span>（通过添加新的起始符号<span class="math inline"><strong>S</strong><sup><strong>′</strong></sup></span>和产生式<span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong></span>扩展文法<span class="math inline"><strong>G</strong></span>至<span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>）</li><li><span class="math inline"><strong>C</strong></span>:= {<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>S</strong><sup><strong>′</strong></sup> <strong>→</strong> <strong>⋅</strong><strong>S</strong><strong>)</strong></span>}（先求<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>S</strong><sup><strong>′</strong></sup> <strong>→</strong> <strong>⋅</strong><strong>S</strong><strong>)</strong></span>，作为闭包的集合<span class="math inline"><strong>C</strong></span>中的第一个闭包）</li><li>repeat:<ul><li>for each Item <span class="math inline"><strong>I</strong></span> in<span class="math inline"><strong>C</strong></span> and each grammarsymbol <span class="math inline"><strong>X</strong></span> in <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>（对<span class="math inline"><strong>C</strong></span>中每个项目<span class="math inline"><strong>I</strong></span>和<span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>中的每个文法符号<span class="math inline"><strong>X</strong></span>）<ul><li>if <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>is not empty and not in <span class="math inline"><strong>C</strong></span> （如果<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>不为空且不在<span class="math inline"><strong>C</strong></span>中，注意<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>是项集<span class="math inline"><strong>I</strong></span>在输入符号<span class="math inline"><strong>X</strong></span>下的转换的闭包）<ul><li>add <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>to <span class="math inline"><strong>C</strong></span></li></ul></li></ul></li></ul></li><li>until no new Items are added to <span class="math inline"><strong>C</strong></span></li></ol></li><li><strong>Example</strong>: <img src="image-36.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="parsing-table-construction">Parsing Table Construction</h4><ul><li><strong>LR(0) Parsing Table <span class="math inline">𝕋</span></strong>:<ul><li><strong>Rows</strong>: <strong>states</strong></li><li><strong>Columns</strong>: <strong>grammar symbols</strong><ul><li><strong>terminals</strong> for <span class="math inline"><strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong></span>and <span class="math inline"><strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong></span>actions</li><li><strong>non-terminals</strong> for <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>actions</li></ul></li><li><strong>Construction</strong>: each edge <span class="math inline"><strong>X</strong></span>: <span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span>（对于每条边<span class="math inline"><strong>X</strong></span>，<span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span>为其起始和终止状态，X为文法符号）<ul><li>if <span class="math inline"><strong>X</strong></span> is a<strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong>&nbsp;<em>n</em></span>（记作s n）</li><li>if <span class="math inline"><strong>X</strong></span> is a<strong>non-terminal</strong> <span class="math inline"><strong>A</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>A</em>] = <strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong>&nbsp;<em>n</em></span>（记作n）</li><li>if <span class="math inline"><strong>A</strong> → <strong>β</strong>⋅</span> isin <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then for each <strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong>&nbsp;<strong>A</strong> → <strong>β</strong></span>（记作r n，其中n是产生式的编号，用罗马数字表示）</li><li>if <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅</span>is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then for each <strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>A</strong><strong>C</strong><strong>C</strong><strong>E</strong><strong>P</strong><strong>T</strong></span>（记作a/acc）</li></ul></li><li><img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>Example</strong>: <img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload> &gt;注：在上面的例子中，状态1、2、9均存在移进-归约冲突，因此不属于LR(0)文法。</li></ul><h4 id="alogrithm-and-implementation-算法与实现">Alogrithm andImplementation （算法与实现）</h4><ul><li><p><strong>INPUT</strong>: an input string <span class="math inline"><strong>ω</strong></span> and an LR-parsing table<span class="math inline">𝕋</span> for a grammar <span class="math inline"><strong>G</strong></span></p></li><li><p><strong>OUTPUT</strong>: if <span class="math inline"><strong>ω</strong> ∈ <strong>L</strong><strong>(</strong><strong>G</strong><strong>)</strong></span>,the reduction steps of a bottom-up parse for <span class="math inline"><strong>ω</strong></span></p></li><li><p><strong>STEPS</strong>: </p><figure class="shiki java"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">let a be the first symbol of 𝜔$ </span><span style="color: #7F848E; font-style: italic">//设a是输入字符串𝜔$的第一个符号</span></span><span class="line"><span style="color: #E06C75">push state </span><span style="color: #D19A66">0</span><span style="color: #E06C75"> onto the stack </span><span style="color: #7F848E; font-style: italic">//将状态0推入栈中</span></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #E06C75"> (</span><span style="color: #D19A66">1</span><span style="color: #E06C75">) {</span></span><span class="line"><span style="color: #E06C75">    let s be the state on top of the stack </span><span style="color: #7F848E; font-style: italic">//设s是栈顶的状态</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">ACTION</span><span style="color: #E06C75">[s</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a] </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> shift t) { </span><span style="color: #7F848E; font-style: italic">//如果ACTION[s, a] = shift t</span></span><span class="line"><span style="color: #E06C75">        push t onto the stack </span><span style="color: #7F848E; font-style: italic">//将t推入栈中</span></span><span class="line"><span style="color: #E06C75">        let a be the next input symbol </span><span style="color: #7F848E; font-style: italic">//设a是下一个输入符号</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">ACTION</span><span style="color: #E06C75">[s</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a] </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> reduce A→𝛽) { </span><span style="color: #7F848E; font-style: italic">//如果ACTION[s, a] = reduce A→𝛽</span></span><span class="line"><span style="color: #E06C75">        pop </span><span style="color: #56B6C2">|</span><span style="color: #E06C75">𝛽</span><span style="color: #56B6C2">|</span><span style="color: #E06C75"> symbols off the stack </span><span style="color: #7F848E; font-style: italic">//从栈中弹出|𝛽|（𝛽包含的符号数）个状态</span></span><span class="line"><span style="color: #E06C75">        let t be the top of the stack now </span><span style="color: #7F848E; font-style: italic">//设t是栈顶的状态</span></span><span class="line"><span style="color: #E06C75">        push </span><span style="color: #E5C07B">GOTO</span><span style="color: #E06C75">[t</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> A] onto the stack </span><span style="color: #7F848E; font-style: italic">//将GOTO[t, A]推入栈中</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">ACTION</span><span style="color: #E06C75">[s</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a] </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> accept) </span><span style="color: #C678DD">break</span><span style="color: #E06C75"> </span><span style="color: #7F848E; font-style: italic">//如果ACTION[s, a] = accept，则结束</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> call error</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">handling routine</span></span><span class="line"><span style="color: #E06C75">}</span></span></code></pre></div></div></figure><p></p></li><li><p><strong>Example</strong>: <img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload></p></li></ul><h4 id="lr0-conflicts">LR(0) Conflicts</h4><ul><li><strong>Reduce-Reduce Conflicts</strong>:<ul><li>state has two reduce items</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>α</strong>⋅</span> and<span class="math inline"><strong>B</strong> → <strong>β</strong>⋅</span></li></ul></li><li><strong>Shift-Reduce Conflicts</strong>:<ul><li>state has a reduce item and a shift item</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>k</strong><strong>γ</strong></span>and <span class="math inline"><strong>B</strong> → <strong>β</strong>⋅</span></li></ul></li><li>To avoid conflicts: <strong>SLR(1) Parsing</strong></li></ul><h3 id="slr1-parsing">SLR(1) Parsing</h3><h4 id="parsing-table-construction-1">Parsing Table Construction</h4><ul><li><strong>LR(0) Parsing Table</strong> <span class="math inline">𝕋</span> <span class="math inline">⇒</span><strong>SLR(1) Parsing Table</strong> <span class="math inline">𝕋</span><ul><li><strong>Rows</strong>: <strong>states</strong></li><li><strong>Columns</strong>: <strong>grammar symbols</strong><ul><li><strong>terminals</strong> for <span class="math inline"><strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong></span>and <span class="math inline"><strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong></span>actions</li><li><strong>non-terminals</strong> for <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>actions</li></ul></li><li><strong>Construction</strong>: each edge <span class="math inline"><strong>X</strong></span>: <span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span><ul><li>if <span class="math inline"><strong>X</strong></span> is a<strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline"><strong>X</strong></span> is a<strong>non-terminal</strong> <span class="math inline"><strong>A</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>A</em>] = <strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline"><strong>A</strong> → <strong>β</strong>⋅</span> isin <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then for each <strong>terminal</strong> <span class="math inline"><strong>a</strong> ∈ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>,<span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong>&nbsp;<strong>A</strong> → <strong>β</strong></span>（只对<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>中的终结符进行归约）</li><li>if <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅</span>is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, $] = <strong>A</strong><strong>C</strong><strong>C</strong><strong>E</strong><strong>P</strong><strong>T</strong></span>（只对$进行归约）</li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="slr1-conflicts">SLR(1) Conflicts</h4><ul><li><strong>Reduce-Reduce Conflicts</strong>:<ul><li>state has two reduce items</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>α</strong>⋅</span> and<span class="math inline"><strong>B</strong> → <strong>β</strong>⋅</span><ul><li>if <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong> ∩ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>B</strong><strong>)</strong> = ∅</span>,safe for SLR(1) （如果<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong> ∩ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>B</strong><strong>)</strong> = ∅</span>，则SLR(1)安全）</li></ul></li></ul></li><li><strong>Shift-Reduce Conflicts</strong>:<ul><li>state has a reduce item and a shift item</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>k</strong><strong>γ</strong></span>and <span class="math inline"><strong>B</strong> → <strong>β</strong>⋅</span><ul><li>if <span class="math inline"><strong>k</strong> ∉ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>B</strong><strong>)</strong></span>,safe for SLR(1) （如果<span class="math inline"><strong>k</strong> ∉ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>B</strong><strong>)</strong></span>，则SLR(1)安全）</li></ul></li></ul></li></ul><h3 id="lr1-parsing">LR(1) Parsing</h3><ul><li><strong>How</strong>: check the <strong>immediate</strong> followingsymbols of non-terminals for reduction（检查非终结符的直接后续符号以进行归约）</li><li><strong>LR(1) Item</strong> = [<strong>LR(0) Item</strong>,<strong>Following Symbol</strong>]<ul><li>e.g.&nbsp;<span class="math inline">[<strong>A</strong> → <strong>X</strong><strong>Y</strong> ⋅ <strong>Z</strong>, <strong>a</strong>]</span></li><li>where <span class="math inline"><strong>a</strong></span> is thefollowing <strong>terminal</strong> symbol of <span class="math inline"><strong>A</strong></span> （<span class="math inline"><strong>a</strong></span>是<span class="math inline"><strong>A</strong></span>的后续终结符）</li><li>when <span class="math inline"><strong>Z</strong></span> is notempty, the same as LR(0) Item （当<span class="math inline"><strong>Z</strong></span>不为空时，与LR(0)项相同）</li><li>otherwise, <span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong> ⋅ <strong>Z</strong></span>is applied only when the next input symbol is <span class="math inline"><strong>a</strong></span>（否则，只有在下一个输入符号为<span class="math inline"><strong>a</strong></span>时才应用<span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong> ⋅ <strong>Z</strong></span>）<ul><li>instead of SLR(1)’s ALL <span class="math inline"><strong>A</strong></span>’s following symbols, letalong LR(0)’s ALL terminal symbols （而不是SLR(1)的所有<span class="math inline"><strong>A</strong></span>的后续符号，甚至LR(0)的所有终结符）</li></ul></li></ul></li></ul><h4 id="lr1s-closure-and-goto">LR(1)’s CLOSURE and GOTO</h4><ul><li><strong>LR(1)’s <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span></strong><ul><li>every Item in <span class="math inline"><strong>I</strong></span> isadded in to <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span></li><li>repeat:<ul><li>if <span class="math inline">[<strong>A</strong> → <strong>α</strong> ⋅ <strong>B</strong><strong>β</strong>, <strong>a</strong>]</span>is in <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>and <span class="math inline"><strong>B</strong> → <strong>γ</strong></span> is aproduction of <span class="math inline"><strong>G</strong></span>, thenfor each terminal <span class="math inline"><strong>b</strong></span> in<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>a</strong><strong>)</strong></span>,add <span class="math inline">[<strong>B</strong> → ⋅<strong>γ</strong>, <strong>b</strong>]</span>into <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span></li><li>until no more new Items can be added into <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span></li></ul></li><li>only reduce <span class="math inline"><strong>B</strong></span> whenit is followed by that in <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>a</strong><strong>)</strong></span>（仅在后面跟着<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>a</strong><strong>)</strong></span>中的项时才归约<span class="math inline"><strong>B</strong></span>）</li></ul></li><li><strong>LR(1)’s <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>B</strong><strong>)</strong></span></strong><ul><li>if <span class="math inline">[<strong>A</strong> → <strong>α</strong> ⋅ <strong>B</strong><strong>β</strong>, <strong>a</strong>]</span>in <span class="math inline"><strong>I</strong></span></li><li>then every Item in <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>{</strong><strong>[</strong><strong>A</strong> <strong>→</strong> <strong>α</strong><strong>B</strong> <strong>⋅</strong> <strong>β</strong><strong>,</strong> <strong>a</strong><strong>]</strong><strong>}</strong><strong>)</strong></span>is in <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>B</strong><strong>)</strong></span><ul><li><span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>B</strong><strong>)</strong> ⊇ <strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>{</strong><strong>[</strong><strong>A</strong> <strong>→</strong> <strong>α</strong><strong>B</strong> <strong>⋅</strong> <strong>β</strong><strong>,</strong> <strong>a</strong><strong>]</strong><strong>}</strong><strong>)</strong></span><ul><li></li></ul></li><li><strong>Those of Kernel Items inherited from the previousstate</strong> （从前一个状态继承的内核项）</li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-41.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="automaton-construction-1">Automaton Construction</h4><ul><li><strong>INPUT</strong>: a grammar <span class="math inline"><strong>G</strong></span></li><li><strong>OUTPUT</strong>: a LR(1) automaton</li><li><strong>Construction</strong>:<ol type="1"><li>augment <span class="math inline"><strong>G</strong></span> to <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>by adding a new start symbol <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup></span>and production <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong></span>（扩展文法）</li><li><span class="math inline"><strong>C</strong></span>:= {<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>[</strong><strong>S</strong><sup><strong>′</strong></sup> <strong>→</strong> <strong>⋅</strong><strong>S</strong><strong>,</strong> <strong>$</strong><strong>]</strong><strong>)</strong></span>}（初始化项集C）</li><li>repeat:<ul><li>for each Item <span class="math inline"><strong>I</strong></span> in<span class="math inline"><strong>C</strong></span> and each grammarsymbol <span class="math inline"><strong>X</strong></span> in <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span><ul><li>if <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>is not empty and not in <span class="math inline"><strong>C</strong></span><ul><li>add <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>to <span class="math inline"><strong>C</strong></span></li></ul></li></ul></li></ul></li><li>until no new Items are added to <span class="math inline"><strong>C</strong></span></li></ol></li><li><strong>Example</strong>:<ol type="1"><li><strong>Example</strong>: <img src="image-42.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>Exercise</strong>: <img src="image-44.webp" srcset="/img/loading/loading3.gif" lazyload></li></ol></li></ul><h4 id="parsing-table-construction-2">Parsing Table Construction</h4><ul><li><strong>LR(1) Parsing Table <span class="math inline">𝕋</span></strong>:<ul><li><strong>Rows</strong>: <strong>states</strong></li><li><strong>Columns</strong>: <strong>grammar symbols</strong><ul><li><strong>terminals</strong> for <span class="math inline"><strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong></span>and <span class="math inline"><strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong></span>actions</li><li><strong>non-terminals</strong> for <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>actions</li></ul></li><li><strong>Construction</strong>: each edge <span class="math inline"><strong>X</strong></span>: <span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span><ul><li>if <span class="math inline"><strong>X</strong></span> is a<strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline"><strong>X</strong></span> is a<strong>non-terminal</strong> <span class="math inline"><strong>A</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>A</em>] = <strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline">[<strong>A</strong> → <strong>β</strong>⋅, <strong>a</strong>]</span>(the kernel) is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong>&nbsp;<strong>A</strong> → <strong>β</strong></span></li><li>if <span class="math inline">[<strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅, $]</span>is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, $] = <strong>A</strong><strong>C</strong><strong>C</strong><strong>E</strong><strong>P</strong><strong>T</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-43.webp" srcset="/img/loading/loading3.gif" lazyload> &gt;注：上表中<span class="math inline">[11, <em>i</em><em>d</em>]</span>应为<span class="math inline"><em>s</em>12</span>，即<span class="math inline">𝕋[11, <em>i</em><em>d</em>] = <em>s</em>12</span>。</li></ul><h3 id="lalr1-parsing">LALR(1) Parsing</h3><ul><li><strong>What</strong>: <strong>L</strong>ook <strong>A</strong>head<strong>LR(1)</strong></li><li><strong>Why</strong>: smaller parsing table than<strong>LR(1)</strong> for practice（比LR(1)小的解析表）<ul><li>equal to <strong>SLR(1)</strong> in state number（与SLR(1)状态数相等）<ul><li>e.g.&nbsp;In C, serveral hundred for SLR(1), serverals of thousands forLR(1)</li></ul></li><li>more powerful than <strong>SLR(1)</strong> in processing moregrammars （比SLR(1)更强大，能处理更多文法）</li></ul></li><li><strong>How</strong>: combine <strong>Items</strong> with the same<strong>Production Set</strong> in LR(1)（将LR(1)中具有相同产生式集的项（同心集）组合在一起）<ul><li>e.g.&nbsp;<span class="math inline">[<strong>A</strong> → <strong>α</strong>⋅, <strong>a</strong>]</span>and <span class="math inline">[<strong>A</strong> → <strong>α</strong>⋅, <strong>b</strong>]</span>are combined into one state</li></ul></li><li>Compared to <strong>LR(1)</strong>: <img src="image-45.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="automaton-construction-2">Automaton Construction</h4><ul><li><strong>INPUT</strong>: a grammar <span class="math inline"><strong>G</strong></span></li><li><strong>OUTPUT</strong>: a LALR(1) automaton</li><li><strong>Construction</strong>:<ol type="1"><li>Construct <strong>LR(0)</strong> items as <strong>LALR(1)</strong>items’ cores for the grammar <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>，thenremove the non-kernel items （为文法<span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>构造LR(0)项作为LALR(1)项的核心，然后删除非核心项）</li><li>For each kernal items <span class="math inline"><strong>K</strong></span> in <span class="math inline"><strong>I</strong><sub><strong>i</strong></sub></span>and each grammar symbol <span class="math inline"><strong>X</strong></span> in <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>,calculate the lookahead symbols’ <strong>INIT</strong> and<strong>PROPAGATION</strong>. （对于每个项集<span class="math inline"><strong>I</strong><sub><strong>i</strong></sub></span>中的核心项<span class="math inline"><strong>K</strong></span>和文法符号<span class="math inline"><strong>X</strong></span>，计算前瞻符号的初始值和传播）<ul><li>For each item <span class="math inline">(<strong>A</strong> → <strong>α</strong> ⋅ <strong>β</strong>)</span>in <span class="math inline"><strong>K</strong></span><ul><li><span class="math inline"><strong>J</strong> := {<strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>[</strong><strong>A</strong> <strong>→</strong> <strong>α</strong> <strong>⋅</strong> <strong>β</strong><strong>,</strong> <strong>#</strong><strong>]</strong><strong>)</strong>}</span>（初始化<span class="math inline"><strong>J</strong></span>）</li><li>if <span class="math inline">[<strong>B</strong> <strong>→</strong> <strong>γ</strong> <strong>⋅</strong> <strong>X</strong><strong>δ</strong><strong>,</strong> <strong>a</strong>]</span>in <span class="math inline"><strong>J</strong></span> and <span class="math inline"><strong>a</strong> <strong>≠</strong> <strong>#</strong></span>,then <span class="math inline"><strong>B</strong> <strong>→</strong> <strong>γ</strong><strong>X</strong> <strong>⋅</strong> <strong>δ</strong></span>in <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><sub><strong>i</strong></sub><strong>,</strong> <strong>X</strong><strong>)</strong></span>has a <strong>SELF-generated</strong> lookahead symbol <span class="math inline"><strong>a</strong></span> （<span class="math inline"><strong>J</strong></span>中的项若出现不为#的前瞻符号，则它是自发生成的）</li><li>if <span class="math inline">[<strong>B</strong> <strong>→</strong> <strong>γ</strong> <strong>⋅</strong> <strong>X</strong><strong>δ</strong><strong>,</strong> <strong>#</strong>]</span>in <span class="math inline"><strong>J</strong></span>, then lookaheadsymbols are <strong>propagated</strong> from <span class="math inline"><strong>A</strong> <strong>→</strong> <strong>α</strong> <strong>⋅</strong> <strong>β</strong></span>to <span class="math inline"><strong>B</strong> <strong>→</strong> <strong>γ</strong><strong>X</strong> <strong>⋅</strong> <strong>δ</strong></span>in <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><sub><strong>i</strong></sub><strong>,</strong> <strong>X</strong><strong>)</strong></span>.（<span class="math inline"><strong>J</strong></span>中的项若出现#的前瞻符号，则该项会传播前瞻符号）</li></ul></li><li>Specifically, <span class="math inline"><strong>$</strong></span> in<span class="math inline"><strong>[</strong><strong>S</strong><sup><strong>′</strong></sup> <strong>→</strong> <strong>S</strong><strong>⋅</strong><strong>,</strong> <strong>$</strong><strong>]</strong></span>is SELF-generated.</li></ul></li><li>Construct the <span class="math inline"><strong>F</strong><strong>R</strong><strong>O</strong><strong>M</strong> <strong>−</strong> <strong>T</strong><strong>O</strong></span>table base on <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>for the kernel items to show the propagation of lookahead symbols（为核心项构建<span class="math inline"><strong>F</strong><strong>R</strong><strong>O</strong><strong>M</strong> <strong>−</strong> <strong>T</strong><strong>O</strong></span>表，以显示前瞻符号的传播）<ul><li>in step 2, we calculate <strong>propagated</strong>relationships.</li></ul></li><li>Propagate the lookahead symbols according to the <span class="math inline"><strong>F</strong><strong>R</strong><strong>O</strong><strong>M</strong> <strong>−</strong> <strong>T</strong><strong>O</strong></span>relationships until the fixed point achieved （根据<span class="math inline"><strong>F</strong><strong>R</strong><strong>O</strong><strong>M</strong> <strong>−</strong> <strong>T</strong><strong>O</strong></span>关系传播前瞻符号，直到达到不变点）<ul><li>in step 2, we calculate <strong>self-generated</strong> lookaheadsymbols.</li></ul></li></ol></li><li><strong>Example</strong>: <img src="image-54.webp" srcset="/img/loading/loading3.gif" lazyload> <img src="image-46.webp" srcset="/img/loading/loading3.gif" lazyload> &gt;注：上右表中，前瞻符号在传播时，每一行的前瞻符号可以向右填满右侧列，最右一列是最终结果</li></ul><h4 id="parsing-table-construction-3">Parsing Table Construction</h4><ul><li>the same as <strong>LR(1)</strong> method</li><li><strong>LALR(1) Parsing Table <span class="math inline">𝕋</span></strong>:<ul><li><strong>Rows</strong>: <strong>states</strong></li><li><strong>Columns</strong>: <strong>grammar symbols</strong><ul><li><strong>terminals</strong> for <span class="math inline"><strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong></span>and <span class="math inline"><strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong></span>actions</li><li><strong>non-terminals</strong> for <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>actions</li></ul></li><li><strong>Construction</strong>: each edge <span class="math inline"><strong>X</strong></span>: <span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span><ul><li>if <span class="math inline"><strong>X</strong></span> is a<strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline"><strong>X</strong></span> is a<strong>non-terminal</strong> <span class="math inline"><strong>A</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>A</em>] = <strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline">[<strong>A</strong> → <strong>β</strong>⋅, <strong>a</strong>]</span>(the kernel) is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong>&nbsp;<strong>A</strong> → <strong>β</strong></span></li><li>if <span class="math inline">[<strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅, $]</span>is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, $] = <strong>A</strong><strong>C</strong><strong>C</strong><strong>E</strong><strong>P</strong><strong>T</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-53.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="capabilities-vs.-conflicts">Capabilities vs.&nbsp;Conflicts</h4><ul><li>LALR never introduces new SHIFT-REDUCE conflicts:<ul><li><strong>SHIFT does not depend on lookaheads</strong></li></ul></li><li><strong>Example</strong>: <img src="image-47.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="summary">Summary</h3><ul><li><strong>LR(0)</strong>, <strong>SLR(1)</strong>,<strong>LR(1)</strong>, <strong>LALR(1)</strong><ul><li>all working in <strong>SHIFT-REDUCE</strong> mode</li><li>only different in Parsing Tables</li></ul></li><li><strong>Parsing Tables - Capabilities</strong><ul><li>LR(0) &lt; SLR(1) &lt; LALR(1) &lt; LR(1)</li><li>LR(0): Items</li><li>SLR(1): Items with FOLLOW</li><li>LALR(1): Items Combined from SLR(1) and LR(1)</li><li>LR(1): Items with Subset of FOLLOW</li></ul><img src="image-48.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h2 id="using-ambiguous-grammars">Using Ambiguous Grammars</h2><ul><li>In Theory: grammar for LR parsing tables should be unambiguous（在理论上：LR解析表的文法应该是无歧义的）</li><li>For ambiguous grammars:<ul><li>there will be conflicts</li><li>add new information/restrictions to resolve ambiguity（添加新信息/限制以解决歧义）<ul><li>precedence, associativity, etc.</li><li>get LR tables without conflicts</li></ul></li></ul></li><li>Why embracing ambiguous grammars?<ul><li>some are much natural, the unambiguous one can be very complex（有些是非常自然的，无歧义的可能非常复杂）</li><li>isolate common syntactic constructs for special-case optimizations（隔离常见的语法结构以进行特殊情况优化）</li></ul></li><li>Example: <img src="image-49.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h2 id="summary-1">Summary</h2><p><img src="image-50.webp" srcset="/img/loading/loading3.gif" lazyload></p>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量子力学</title>
      <link href="/_posts/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"/>
      <url>/_posts/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文章基于<a href="https://teruteru.space/2023/02/24/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%AC%94%E8%AE%B0/">Teruteru的学习笔记</a>进行整理，针对2024-2025 学年春季学期教学内容进行修改。</p></blockquote><h1 id="量子力学基础">量子力学基础</h1><h2 id="热辐射">热辐射</h2><ul><li>任何固体或液体都是由分子、原子构成的，由于热运动发射各种电磁波，称为<strong>热辐射</strong>。</li><li>物体向周围辐射的能量称为<strong>辐射能</strong> 。</li><li>实验表明，热辐射具有<strong>连续的辐射谱</strong></li><li>热辐射的电磁波的波长、强度与物体的温度有关，还与物体的性质表面形状有关。一般温度越高，所发射电磁波的能量越大，在光谱分布中，强度向较短波长转移。</li><li>这说明同一物体的热辐射谱在不同波长区域分布不均匀，温度越高，光谱中最大辐射对应的波长越短，同时辐射总能量增加。</li><li>加热一物体，若物体所吸收的能量等于在同一时间内辐射的能量，则物体的温度恒定。这种温度不变的热辐射称之为<strong>平衡热辐射</strong>。</li></ul><h3 id="单色辐出度">单色辐出度</h3><p>单位时间内，从物体表面单位面积上发射波长为 <span class="math inline"><em>λ</em> ∼ <em>λ</em> + d<em>λ</em></span>的辐射能<span class="math inline">d<em>E</em><sub><em>λ</em></sub></span>，与波长间隔成正比，<span class="math inline">d<em>E</em><sub><em>λ</em></sub></span> 与 <span class="math inline">d<em>λ</em></span>的比值称为<strong>单色辐出度</strong> 。单色辐出度用 <span class="math inline"><em>M</em>(<em>λ</em>, <em>T</em>)</span> 表示，即<span class="math display">$$\begin{aligned}M(\lambda,T)=\frac{\mathrm{d} E_{\lambda}}{\mathrm{d} \lambda}\\M(\mu,T)=\frac{\mathrm{d} E_{\mu}}{\mathrm{d} \mu}\end{aligned}$$</span></p><ul><li>热辐射实验表明，<span class="math inline"><em>M</em>(<em>λ</em>, <em>T</em>)</span>与辐射物体的 <strong>温度</strong> 和辐射的 <strong>波长</strong>有关，是 <span class="math inline"><em>λ</em></span> 和 <span class="math inline"><em>T</em></span> 的函数。</li><li>单色辐出度表示在单位时间内从物体表面单位面积内发射的波长在 <span class="math inline"><em>λ</em></span> 附近窄带辐射功率密度。</li><li>单色辐出度反映了物体在不同温度下辐射能按波长分布的情况，它的单位是<span class="math inline">W/m<sup>3</sup></span>。</li></ul><h3 id="总辐出度">总辐出度</h3><p>单位时间内，从物体表面单位面积上所发射的各种波长的总辐射能称为物体的<strong>总辐出度</strong>。显然，对于一个给定的物体，总辐出度只是温度的函数，常用 <span class="math inline"><em>M</em>(<em>T</em>)</span> 表示，单位是 <span class="math inline">W/m<sup>2</sup></span>。在一定温度 <span class="math inline"><em>T</em></span>时，物体的总辐出度与单色辐出度的关系为 <span class="math display">$$\begin{aligned}M(T)&amp;=\int_{0}^{\infty} M(\lambda,T) \mathrm{d} \lambda\\&amp;=\int_{0}^{\infty} M(\nu,T) \mathrm{d} \nu \\\end{aligned}$$</span></p><p>上式表明，在相同温度下，不同物体的 <span class="math inline"><em>M</em>(<em>λ</em>, <em>T</em>)</span>不同，相应的 <span class="math inline"><em>M</em>(<em>T</em>)</span>值也不同。 <span class="math display">$$\begin{aligned}&amp;\int_{0}^{\infty}M_{\nu}\left(T\right)\text{d}\nu=M_{\nu}\left(T\right)\text{d}\left(\frac{c}{\lambda}\right)=\int_{\infty}^{0}-\frac{c}{\lambda^{2}}M_{\nu}(T)\text{d}\lambda=-\int_{0}^{\infty}M_{\lambda}\left(T\right)\text{d}\lambda\\&amp;\RightarrowM_{\lambda}\left(T\right)=M_{\nu}\left(T\right)\frac{c}{\lambda^{2}}\\\end{aligned}$$</span></p><h3 id="吸收比">吸收比</h3><p>任一物体向周围发射辐射能的同时，也吸收周围物体的辐射能。当辐射从外界入射到不透明物体时，一部分能量吸收，一部分能量反射，如果物体透明，还有一部分能量透射。吸收能量与入射能量之比称为物体的<strong>吸收比</strong>，用<span class="math inline"><em>a</em>(<em>T</em>)</span> 表示，在波长为<span class="math inline"><em>λ</em> ∼ <em>λ</em> + d<em>λ</em></span>范围内的吸收比称为<strong>单色吸收比</strong> ，用 <span class="math inline"><em>a</em>(<em>λ</em>, <em>T</em>)</span> 表示。定义吸收比 <span class="math display">$$a(T)=\frac{E^{\text {吸收 }}}{E^{\text {入射 }}}$$</span></p><p>单色吸收比 <span class="math display">$$a(\lambda, T)=\frac{E_{\lambda}^{\text {吸收 }}}{E_{\lambda}^{\text{入射 }}}$$</span></p><ul><li>如果物体在任意温度下，对任何波长的辐射吸收比都等于 <span class="math inline">1</span>，则该物体称为<strong>绝对黑体</strong>，简称<strong>黑体</strong> 。</li></ul><h3 id="反射比">反射比</h3><p>同理定义反射比 <span class="math display">$$r(T)=\frac{E^{\text {反射 }}}{E^{\text {入射 }}}$$</span></p><p>单色反射比 <span class="math display">$$r(\lambda, T)=\frac{E_{\lambda}^{\text {反射 }}}{E_{\lambda}^{\text{入射 }}}$$</span></p><p>对于不透明物体，<span class="math inline"><em>a</em>(<em>λ</em>, <em>T</em>) + <em>r</em>(<em>λ</em>, <em>T</em>) = 1</span></p><h2 id="基尔霍夫辐射定律">基尔霍夫辐射定律</h2><p>基尔霍夫从理论上提出了物体的辐出度与吸收比关系的重要定律：在相同的温度下，不同物体对相同波长的单色辐出度与单色吸收比之间的<strong>比值都相等</strong>，并等于该温度下黑体对同一波长的单色辐出度。可以表示为<span class="math display">$$\frac{M_{1}(\lambda,T)}{a_{1}(\lambda,T)}=\frac{M_{2}(\lambda,T)}{a_{2}(\lambda,T)}=\cdots=M_{0}(\lambda,T)$$</span></p><p>式中，<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>)</span>是<strong>黑体单色辐出度</strong> 。</p><ul><li>基尔霍夫辐射定律说明好的发射体一定也是好的吸收体。黑体是<strong>完全</strong> 吸收体，也是理想的发射体。</li><li>带小孔的封闭空腔体可以视为绝对黑体的模型，空腔内电磁辐射为黑体辐射。</li></ul><h2 id="斯特藩-玻耳兹曼定律">斯特藩-玻耳兹曼定律</h2><p>实验证明，黑体的总辐出度与温度的四次方成正比，即 <span class="math display"><em>M</em><sub>0</sub>(<em>T</em>) = <em>σ</em><em>T</em><sup>4</sup></span></p><ul><li>式中，<span class="math inline"><em>σ</em> = 5.67 × 10<sup>−8</sup>&nbsp;W/(m<sup>2</sup> ⋅ K<sup>4</sup>)</span>称为 Stefen 恒量。</li><li>总辐出度随着绝对温度的升高而快速增加。</li></ul><h2 id="维恩位移定律">维恩位移定律</h2><p>单色辐出度的峰值波长 <span class="math inline"><em>λ</em><sub>m</sub></span> 满足维恩位移定律，即<span class="math display"><em>λ</em><sub>m</sub><em>T</em> = <em>b</em></span></p><ul><li>式中，<span class="math inline"><em>b</em> = 2.897 × 10<sup>−3</sup>&nbsp;m ⋅ K</span>称为 Wien 常数。</li><li>随着温度的增加，热辐射的峰值波长向短波移动。</li></ul><h2 id="普朗克黑体辐射公式">普朗克黑体辐射公式</h2><p>1900 年，普朗克给出了黑体辐射满足实验结果的公式： <span class="math display">$$\begin{aligned}M_{0}(\lambda,T)=2 \pi h c^{2} \lambda^{-5} \frac{1}{\mathrm{e}^{h c /k_{\mathrm{B}} T \lambda}-1}\\M_{0}(\nu,T)=\frac{2\pi\nu^2}{c^2}\frac{h\nu}{\mathrm{e}^{h \nu /k_{\mathrm{B}} T }-1}\end{aligned}$$</span></p><ul><li>式中，<ul><li><span class="math inline"><em>c</em> = 3.0 × 10<sup>8</sup>m ⋅ s<sup>−1</sup></span>是光速</li><li><span class="math inline"><em>k</em><sub>B</sub> = 1.38 × 10<sup>−23</sup>J ⋅ K<sup>−1</sup></span>是玻尔兹曼常量</li><li><span class="math inline"><em>h</em> = 6.626 × 10<sup>−34</sup>J ⋅ s = 4.136 × 10<sup>−15</sup>eV ⋅ s</span>是普朗克常量，是一个普适常量。</li></ul></li><li>无论是短波还是长波，普朗克公式的计算结果都与实验结果一致。从理论上推导该公式时，普朗克采用了当时物理认识上一个非同寻常的假设：谐振子能量值只取某个最小能量的整数倍，即<span class="math display"><em>ε</em>, 2<em>ε</em>, 3<em>ε</em>, ⋯, <em>n</em><em>ε</em></span>式中，<span class="math inline"><em>n</em></span>为正整数，称为<strong>量子数</strong> 。对于频率为 <span class="math inline"><em>ν</em></span> 的谐振子，最小能量是 <span class="math inline"><em>ε</em> = <em>h</em><em>ν</em></span>。在辐射或吸收能量时，振子从这些状态中的一个状态跃迁到另一个状态，即振子只能跳跃式地辐射或吸收能量。</li><li>由普朗克公式可导出其他所有热辐射公式： <span class="math display">$$  M_{0}(\nu, T)=\frac{2 \pi \nu^{2}}{c^{2}} \frac{h \nu}{e^{h \nu / kT}-1}\left\{\begin{array}{l} \text { 积分 } \rightarrow M=\sigma T^{4}\\ \text { 求导 } \rightarrow T \lambda_{m}=b \\ \text { 低频 }\rightarrow M_{\nu}(T)=\frac{2 \pi \nu^{2}}{c^{2}} k T \\ \text { 高频 }\rightarrow M_{\nu}(T)=\alpha \nu^{3} e^{-\beta \nu / T}\end{array}\right.  $$</span></li></ul><h3 id="普朗克公式频率波长转换">普朗克公式频率波长转换</h3><p><span class="math display">$$\begin{aligned}&amp;M_0(\lambda)=\int_{0}^{\infty} M_{0}(\lambda, T) d\lambda=\int_{0}^{\infty} M_{0}(\nu, T) d \nu \\\Rightarrow &amp;\int_{0}^{\infty} M_{0}(\lambda,T) d\lambda=\int_{\infty}^{0} M_{0}(\nu,T)\left(-\frac{c}{\lambda^{2}}\right) d \lambda \\\Rightarrow &amp;M_{0}(\lambda, T)=M_{0}(\nu, T) \frac{c}{\lambda^{2}}\end{aligned}$$</span></p><h3 id="维恩公式">维恩公式</h3><p>当波长很短或温度较低时，普朗克公式可近似写成 <span class="math display">$$\begin{aligned}M_{0}(\lambda,T)=2 \pi h c^{2} \lambda^{-5} \mathrm{e}^{-h c /k_{\mathrm{B}} T \lambda} \\M_{0}(\nu,T)=\alpha \nu^{3} e^{-\beta \nu / T}\end{aligned}$$</span></p><p>这就是维恩公式。将黑体空腔壁分子或原子当成线性谐振子，维恩用经典热力学物理证明了<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>) = <em>c</em><sup>5</sup><em>λ</em><sup>−5</sup><em>ϕ</em>(<em>λ</em>, <em>T</em>)</span>，假设黑体辐射能谱与麦克斯韦速率分布相类似，可得出公式<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>) = <em>C</em><sub>1</sub><em>λ</em><sup>−5</sup>e<sup>−<em>C</em><sub>2</sub>/<em>T</em><em>λ</em></sup></span>，其中<span class="math inline"><em>C</em><sub>1</sub></span> 和 <span class="math inline"><em>C</em><sub>2</sub></span>是两个常数。通过对比可知，<span class="math inline"><em>C</em><sub>1</sub> = 2<em>π</em><em>h</em><em>c</em><sup>2</sup></span>，<span class="math inline"><em>C</em><sub>2</sub> = <em>h</em><em>c</em>/<em>k</em><sub>B</sub></span>。</p><h3 id="瑞利-金斯公式">瑞利-金斯公式</h3><p>当波长较长或温度较高时，普朗克公式可近似写成 <span class="math display">$$\begin{aligned}M_{0}(\lambda,T)=2 \pi k_{\mathrm{B}} c \lambda^{-4} T \\M_{0}(\nu,T)=\frac{2 \pi \nu^{2}}{c^{2}} k T\end{aligned}$$</span></p><p>这就是瑞利-金斯公式。瑞利和金斯从能量均分定律出发，每个谐振子自由度的平均能量等于<span class="math inline"><em>k</em><sub>B</sub><em>T</em></span>，从而得到了理论公式<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>) = <em>C</em><sub>3</sub><em>λ</em><sup>−4</sup><em>T</em></span>。当波长很长时，计算结果与实验结果相符，但在短波紫外区方面，随着波长趋向于零而<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>)</span>趋向于无穷大，则计算结果与实验数据不吻合，这一结果被称为“<strong>紫外灾难</strong>”。</p><h2 id="光电效应">光电效应</h2><h3 id="实验模型">实验模型</h3><p>当光照射在金属表面上，使电子从金属中脱出的现象，称作<strong>光电效应</strong>。</p><p><img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload></p><p>上图所示为研究光电效应的实验装置。在抽成真空的容器中，<span class="math inline"><em>K</em></span> 是阴极，<span class="math inline"><em>A</em></span> 是阳极。当光通过石英窗照射到金属板<span class="math inline"><em>K</em></span>上时，金属板释放电子，这种电子称为光电子。如果在 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>K</em></span>两端加上电势差，则电子在加速电场的作用下，飞向阳极 <span class="math inline"><em>A</em></span>，电路中出现电流，成为光电流，电流计可测出这个光电流。</p><h3 id="基本参数">基本参数</h3><h4 id="饱和电流">饱和电流</h4><p>实验表明，当入射光强度不变，加速电势差 <span class="math inline"><em>U</em> = <em>U</em><sub><em>A</em></sub> − <em>U</em><sub><em>K</em></sub></span>越大，光电流 <span class="math inline"><em>I</em></span>也越大，当电势差增大到一定值时，光电流达到饱和值，此时的光电流称为<strong>饱和电流</strong>。若改变入射光强，<strong>饱和电流的大小与入射光强成正比</strong>，说明从阴极逸出的电子数全部飞到阳极，单位时间从金属表面逸出的电子数与入射光强成正比。</p><h4 id="遏制电势差">遏制电势差</h4><p>当 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>K</em></span>两极的电势差为零时，光电流不为零，这说明从金属表面逸出的电子有初始动能；当负电势差不大时，尽管存在电场阻碍，但依然有部分电子可能到达阳极；如果负电势差足够大，从阴极表面逸出的具有最大速度的电子也不能到达<span class="math inline">A</span> 极，则光电流变为零。只有改变电压<span class="math inline"><em>U</em> = −<em>U</em><sub>0</sub></span>时，光电流为零，<span class="math inline"><em>U</em><sub>0</sub></span>称为<strong>遏制电势差</strong>。光电子从表面逸出的最大初速度 <span class="math inline"><em>v</em><sub>m</sub></span> 满足 <span class="math display">$$\frac{1}{2} m v_{\mathrm{m}}^{2}=e U_{0}$$</span></p><p>式中，<span class="math inline"><em>e</em></span> 和 <span class="math inline"><em>m</em></span>分别为电子电荷量和质量。<strong>最大初动能与入射光的强度无关。</strong></p><h4 id="红限频率">红限频率</h4><p>实验发现，改变入射光的频率，遏止电势差与入射光的频率之间具有线性关系，即<span class="math display"><em>U</em><sub>0</sub> = <em>K</em><em>ν</em> − <em>U</em><sub>1</sub></span></p><p>式中，<span class="math inline"><em>K</em></span>是不随金属种类变化的普适恒量；<span class="math inline"><em>U</em><sub>1</sub></span> 随金属种类不同而变化。<span class="math display">$$\frac{1}{2} m v_{\mathrm{m}}^{2}=e K \nu-e U_{1}$$</span></p><p>光电子从金属表面逸出时的最大初动能随着入射光的频率线性增加。电子初动能必须是正的，光照射金属逸出电子的条件是光的频率<span class="math inline"><em>ν</em> ≥ <em>U</em><sub>1</sub>/<em>K</em></span>。令<span class="math inline"><em>ν</em><sub>0</sub> = <em>U</em><sub>1</sub>/<em>K</em></span>，<span class="math inline"><em>ν</em><sub>0</sub></span>称为光电效应的<strong>红限频率</strong>。这意味着无论光的强度多大，当入射光的频率小于<span class="math inline"><em>ν</em><sub>0</sub></span>时，都不会发生光电效应。</p><p><img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload></p><h4 id="弛豫时间">弛豫时间</h4><p>实验证明，无论入射光的强度如何，入射光照射到金属释放电子几乎是瞬时的，弛豫时间不超过<span class="math inline">1 × 10<sup>−9</sup>s</span></p><h3 id="爱因斯坦光子理论">爱因斯坦光子理论</h3><ul><li>爱因斯坦认为光的能量以颗粒形式在空间传播，这种颗粒形式的光能量称为<strong>光量子</strong>或<strong>光子</strong> ，一束光就是以光速运动的<strong>光子流</strong>。</li><li>每个光子的能量是 <span class="math inline"><em>ε</em> = <em>h</em><em>ν</em></span>，不同频率的光子具有不同的能量，光的能流密度<span class="math inline"><em>S</em></span>决定于单位时间内通过该单位面积的光子数 <span class="math inline"><em>N</em></span>。频率为 <span class="math inline"><em>ν</em></span> 的单色光的能流密度 <span class="math inline"><em>S</em> = <em>N</em><em>h</em><em>ν</em></span>。</li><li>光电效应的解释如下：当金属中一个电子从入射光中吸收一个频率为 <span class="math inline"><em>ν</em></span> 的光子后，就获得能量 <span class="math inline"><em>h</em><em>ν</em></span>，如果 <span class="math inline"><em>h</em><em>ν</em></span>大于电子从金属表面逸出所需的逸出功 <span class="math inline"><em>A</em></span>，那么这个电子就可以从金属中飞出。根据能量守恒定律，则有爱因斯坦光电效应方程<span class="math display">$$ h \nu=\frac{1}{2} mv_{\mathrm{m}}^{2}+A$$</span> 式中，<span class="math inline">$\frac{1}{2} m v_{\mathrm{m}}^{2}$</span>是光电子的<strong>最大初动能</strong> 。</li><li>如果出射电子动能为零，<span class="math inline"><em>ν</em><sub>0</sub> = <em>A</em>/<em>h</em></span>，这表明频率为<span class="math inline"><em>ν</em><sub>0</sub></span>的光子具有发射光电子的最小能量。如果光子频率低于红限频率 <span class="math inline"><em>ν</em><sub>0</sub></span>，不管有多少光子，单个光子都没有足够的能量去发射光电子，所以当光电子吸收的能量全部消耗于电子的逸出功时，入射光的频率对应于红限频率。</li><li>当光子频率大于红限频率 <span class="math inline"><em>ν</em><sub>0</sub></span>，光的强度增加时，光子数目增大，单位时间内发射的光电子数目也将增大，这说明了饱和电流与光的强度之间的正比关系。另外，当光子能量被电子全部吸收后，不需要积累能量的时间，这说明了光电效应发生的瞬时性。</li></ul><h3 id="光的波粒二象性">光的波粒二象性</h3><p><strong>光子本性是波粒二象性</strong>。光子不仅具有能量，还具有质量、动量等一般粒子共有的特性。光子质量可由爱因斯坦质能关系得到，表示为<span class="math display">$$m=\frac{\varepsilon}{c^{2}}=\frac{h \nu}{c^{2}}$$</span></p><p>光子质量是由光子能量决定的。光子的动量为 <span class="math display">$$p=m c=\frac{h \nu}{c}=\frac{h}{\lambda}$$</span></p><p>由于光子有动量，光照射到物体上时，就对物体表面施加了压力，这就是<strong>光压</strong>，这已被实验所证实。光的波动理论已被光的干涉和衍射实验所证实，而光子理论成功解释了光电效应，并且能解释光的波动理论无法解释的其他现象。因此<strong>光既有波动性又有粒子性</strong>，光具有双重性质，即光的<strong>波粒二象性</strong>。光子的能量和动量是描述粒子性的，而频率和波长是描述波动性的。</p><h2 id="康普顿效应">康普顿效应</h2><p>康普顿研究了 <span class="math inline"><em>X</em></span>射线经物质散射的实验，为光子的粒子性概念提供了有力证据。<span class="math inline"><em>X</em></span> 射线源发出一束波长为 <span class="math inline"><em>λ</em><sub>0</sub></span> 的 <span class="math inline"><em>X</em></span>射线，照射到一块石墨上。经石墨散射后，散射的 <span class="math inline">X</span>射线的波长和强度可以由晶体和探测器所组成的摄谱仪来测定。改变散射角 <span class="math inline"><em>θ</em></span>，再进行同样的测量。康普顿发现：</p><ul><li>散射光谱中除了有与入射波长 <span class="math inline"><em>λ</em><sub>0</sub></span> 相同的射线，还有波长<span class="math inline"><em>λ</em> &gt; <em>λ</em><sub>0</sub></span>的射线，这种改变波长的散射称为<strong>康普顿效应</strong> 。</li><li>波长差 <span class="math inline"><em>Δ</em><em>λ</em> = <em>λ</em> − <em>λ</em><sub>0</sub></span>随着散射角的改变而改变。散射角<strong>增大</strong>时，波长差也随着<strong>增加</strong>，而且随着散射角的增大，<strong>原波长的谱线强度减小</strong>，而<strong>新波长的谱线强度增大</strong> 。</li><li>在<strong>同一散射角</strong>下，对于所有散射物质，<strong>波长差都相同</strong>，但原波长的谱线强度随着散射物质的原子序数的增大而<strong>增加</strong>，新波长的谱线强度随之<strong>减小</strong> 。</li></ul><h3 id="解释">解释</h3><ul><li>一个光子和散射体中的一个自由电子或束缚微弱电子（原子的外层电子）发生碰撞后，从散射体射出光子的方向就是康普顿散射的方向</li><li>电子吸收一个光子能量后，发射一个散射光子，电子同时受到反冲而获得一定的能量和动量。在碰撞过程中，动量和能量守恒，入射光子的能量一部分给了电子，因此<strong>散射光子能量比入射光子能量低</strong></li><li>又根据光子满足的关系 <span class="math inline"><em>E</em> = <em>h</em><em>ν</em></span>，则<strong>散射光的频率小于入射光的频率</strong>，意味着<strong>散射光的波长大于入射光的波长</strong>。如果光子与原子中束缚很紧的电子（原子的内层电子）碰撞，光子将与整个原子做弹性碰撞。因为原子的质量比光子的质量大很多，<strong>散射光的能量不会显著减小</strong>，从而散射光的频率也不会发生显著变化，康普顿移动非常小，所以实验散射线中有与入射光波长相同的射线。</li></ul><h3 id="计算">计算</h3><p>我们利用能量守恒和动量守恒定律来定量解释散射光子的波长改变。一个光子与一个自由电子碰撞，电子一开始处于静止状态，如下图所示。<br><img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>频率为 <span class="math inline"><em>ν</em><sub>0</sub></span>的一束光沿着 <span class="math inline"><em>x</em></span>方向照射物体表面，具有能量 <span class="math inline"><em>h</em><em>ν</em><sub>0</sub></span> 和动量 <span class="math inline">$\frac{h \nu_{0}}{c}$</span>的光子与电子碰撞后被散射，之后光子与原入射光子方向成 <span class="math inline"><em>θ</em></span> 角，散射光子能量为 <span class="math inline"><em>h</em><em>ν</em></span>，动量为 <span class="math inline">$\frac{h \nu}{c}$</span>。</li><li>同时，反冲电子获得一个与光速差不多的速率并沿着某一角度 <span class="math inline"><em>φ</em></span> 飞出，电子能量从静止时的 <span class="math inline"><em>m</em><sub>e</sub><em>c</em><sup>2</sup></span>变成了 <span class="math inline"><em>m</em><em>c</em><sup>2</sup></span>，动量变为<span class="math inline"><em>m</em><em>v</em></span>，其中 <span class="math inline">$m=\frac{m_{\mathrm{e}}}{\sqrt{1-v^{2} /c^{2}}}$</span>，即电子动能要用相对论公式表示。</li><li>根据碰撞中遵守能量守恒和动量守恒定律，有<span class="math display"><em>h</em><em>ν</em><sub>0</sub> = <em>h</em><em>ν</em> + (<em>m</em> − <em>m</em><sub>e</sub>)<em>c</em><sup>2</sup></span></li><li><span class="math inline"><em>x</em></span> 方向的动量守恒方程写为<span class="math display">$$ \frac{h \nu_{0}}{c}=\frac{h \nu}{c} \cos\theta+m v \cos \varphi$$</span></li><li><span class="math inline"><em>y</em></span> 方向的动量守恒方程写为<span class="math display">$$ 0=\frac{h \nu}{c} \sin \theta-m v \sin\varphi$$</span></li><li>利用 <span class="math inline">$p=\frac{h\nu}{c}=\frac{h}{\lambda}$</span> 关系，求得 <span class="math display">$$ \Delta\lambda=\lambda-\lambda_{0}=\frac{h}{m_{\mathrm{e}} c}(1-\cos \theta)=2\lambda_{\mathrm{c}} \sin ^{2} \frac{\theta}{2}$$</span> 式中，<span class="math inline">$\lambda_{\mathrm{c}}=\frac{h}{m_{\mathrm{e}}c}=2.43 \times 10^{-12} \mathrm{~m}$</span>，<span class="math inline"><em>λ</em><sub>c</sub></span>称为电子的<strong>康普顿波长</strong> 。</li></ul><p>上式说明波长差 <span class="math inline"><em>Δ</em><em>λ</em></span>与散射物质以及入射光的波长无关，<strong>仅决定于散射方向</strong>，<span class="math inline"><em>Δ</em><em>λ</em></span>随着散射角度的增大而增大，计算得到的理论值与实验结果相符。这不仅有力地证实了光子理论，说明了光子的粒子性（有质量、能量、动量的光量子），整个散射过程是单个光子与个别电子的碰撞；还说明在微观过程中，微观粒子的相互作用也严格遵守了能量守恒和动量守恒定律。正如在空腔辐射和光电效应中，康普顿效应中的普朗克常量起着主要作用，揭示了光具有粒子性。可以这么说，光电效应揭示了光子能量与频率的关系，而康普顿效应则进一步揭示了光子动量与波长的关系。</p><h3 id="解题方法">解题方法</h3><ol type="1"><li>若只涉及到波长差和散射角，则使用 <span class="math display">$$\Delta \lambda=2 \lambda_{\mathrm{c}} \sin ^{2} \frac{\theta}{2}$$</span> 得出答案</li><li>若涉及到能量、动量，则列出康普顿效应方程组 <span class="math display">$$ \left\{\begin{array}{l} h \nu_{0}=h\nu+\left(m-m_{\mathrm{e}}\right) c^{2}\\ \frac{h \nu_{0}}{c}=\frac{h\nu}{c} \cos \theta+m v \cos \varphi\\ 0=\frac{h \nu}{c} \sin \theta-m v\sin \varphi \end{array}\right.$$</span>并加上题目条件（通常是两个方程），联立求解</li></ol><h2 id="卢瑟福原子模型">卢瑟福原子模型</h2><p>卢瑟福根据 <span class="math inline"><em>α</em></span>粒子散射实验结果在理论上提出原子的有核模型，即原子的正电荷以及几乎全部的质量集中在原子中心很小的区域中，形成原子核，带负电的电子围绕原子核旋转，类似于太阳系中行星绕太阳旋转一样，但原子核与电子之间服从库仑定律。此模型很好地解释了<span class="math inline"><em>α</em></span>粒子的大角度偏转，但也遇到了几个困难：</p><ul><li>缺乏合理表征原子大小的量</li><li>原子的稳定性问题</li><li>无法解释原子光谱</li></ul><h2 id="玻尔原子理论">玻尔原子理论</h2><h3 id="氢原子光谱">氢原子光谱</h3><p>在 <span class="math inline">1888</span>年瑞典物理学家、数学家里德伯将巴尔末公式表示为更一般化的形式，即里德伯公式：<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{m^{2}}-\frac{1}{n^{2}}\right)\quad(m=1,2,3,\cdots;n=m+1,m+2,m+3,\cdots)$$</span></p><p>式中</p><ul><li><span class="math inline"><em>ν̃</em> = <em>λ</em><sup>−1</sup></span>为波长的倒数，称为<strong>波数</strong></li><li><span class="math inline"><em>m</em> = 1, 2, 3, ⋯</span> 为整数</li><li><span class="math inline"><em>n</em> = <em>m</em> + 1, <em>m</em> + 2, <em>m</em> + 3, ⋯</span>亦为整数</li><li><span class="math inline"><em>R</em> = 1.096776 × 10<sup>7</sup>&nbsp;m<sup>−1</sup></span>为<strong>里德伯恒量</strong></li><li>给定 <span class="math inline"><em>m</em></span> 后，<span class="math inline"><em>n</em></span> 取不同值对应不同谱线系<ul><li>当 <span class="math inline"><em>m</em> = 2</span>，里德伯公式变为巴尔末公式，所对应的谱线系称为<strong>巴尔末系</strong>。</li><li>当 <span class="math inline"><em>m</em> = 1</span> 时里德伯公式变为<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{1^{2}}-\frac{1}{n^{2}}\right)\quad(n=2,3,4,\cdots)$$</span> 对应的谱线系在紫外区，由赖曼在 <span class="math inline">1914</span> 年发现，称为<strong>赖曼系</strong>。</li><li>当 <span class="math inline"><em>m</em> = 3</span>的光谱线位于红外线区，由帕邢在 <span class="math inline">1908</span>年发现，称为<strong>帕邢系</strong> ：<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{3^{2}}-\frac{1}{n^{2}}\right)\quad(n=4,5,6,\cdots)$$</span></li><li>当 <span class="math inline"><em>m</em> = 4</span>的光谱线位于近红外区，称为<strong>布拉开系</strong> ：<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{4^{2}}-\frac{1}{n^{2}}\right)\quad(n=5,6,7,\cdots)$$</span></li><li>当 <span class="math inline"><em>m</em> = 5</span>的光谱线位于远红外区，称为<strong>普丰德系</strong> ：<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{5^{2}}-\frac{1}{n^{2}}\right)\quad(n=6,7,8,\cdots)$$</span></li><li>当 <span class="math inline"><em>m</em> = 6</span>的光谱线位于远红外区，称为<strong>汉弗莱系</strong> 。</li></ul></li></ul><h3 id="玻尔半径">玻尔半径</h3><p><span class="math display">$$a=\frac{\varepsilon_0 h^2}{\pi m_e e^2}\approx 0.05 \mathrm{~nm}$$</span></p><h3 id="玻尔理论">玻尔理论</h3><p>玻尔在得知原子线状光谱的规律后，提出了革命性的理论。该理论包括两条基本假设：</p><ul><li>原子能够且只能稳定处于与一些分立的能量相对应的状态上，这些状态称为<strong>定态</strong>。原子处于定态中，<strong>不发射</strong> 也<strong>不吸收</strong>电磁辐射。（注意：若吸收光子跃迁，光子能量必须等于能级能量差；若用粒子轰击则不需要）</li><li>当原子从一个定态跃迁到另一个定态时，以发射或吸收特定频率 <span class="math inline"><em>ν</em></span>的光子与电磁场交换能量（分立定态的能量值称为<strong>能级</strong>，两个定态能量分别对应能级 <span class="math inline"><em>E</em><sub><em>n</em></sub></span>、<span class="math inline"><em>E</em><sub><em>m</em></sub></span>，假设 <span class="math inline"><em>E</em><sub><em>n</em></sub> &gt; <em>E</em><sub><em>m</em></sub></span>），且满足<span class="math display"><em>h</em><em>ν</em> = <em>E</em><sub><em>n</em></sub> − <em>E</em><sub><em>m</em></sub></span>这是频率条件。</li><li>结论：<span class="math display">$$\nu=\frac{E_{n}-E_{m}}{h}=\frac{m e^{4}}{8 \varepsilon_{0}^{2}h^{3}}\left(\frac{1}{m^{2}}-\frac{1}{n^{2}}\right)$$</span></li></ul><h3 id="玻尔角动量量子化条件">玻尔角动量量子化条件</h3><p>为了将原子分立能级确定下来，玻尔提出对应原理，即在大量子数极限情况下，量子体系的行为将趋于与经典系统相同。根据对应原理，玻尔提出质量为<span class="math inline"><em>m</em><sub>e</sub></span>的电子绕质子做半径为 <span class="math inline"><em>r</em></span>的圆周运动，电子角动量满足量子化条件： <span class="math display">$$L=n \frac{h}{2 \pi}=n \hbar,n=1,2,3,\cdots$$</span></p><p>式中，<span class="math inline"><em>n</em></span>为正整数，称为<strong>量子数</strong> ；<span class="math inline">ℏ = <em>h</em>/2<em>π</em></span>为<strong>约化普朗克常量</strong> 。</p><h3 id="索末菲量子化条件">索末菲量子化条件</h3><p>索末菲后来把玻尔角动量量子化条件推广为 <span class="math display">∮<em>p</em>&nbsp;d<em>q</em> = <em>n</em><em>h</em></span></p><p>式中，<span class="math inline"><em>q</em></span>是电子的广义坐标；<span class="math inline"><em>p</em></span>是广义动量；积分沿着电子轨道运行一周。</p><h3 id="玻尔半径-1">玻尔半径</h3><p>电子受到氢原子的带正电质子的库仑引力作用，由牛顿定律得 <span class="math display">$$\frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{r^{2}}=m_{\mathrm{e}}\frac{v^{2}}{r}$$</span></p><p>根据角动量量子化条件 <span class="math inline"><em>L</em> = <em>m</em><sub>e</sub><em>v</em><em>r</em> = <em>n</em>ℏ</span>，消去式<span class="math inline">(1 − 27)</span> 中的 <span class="math inline"><em>v</em></span>，得 <span class="math display">$$r_{n}=\frac{4 \pi \varepsilon_{0} \hbar^{2}}{m_{\mathrm{e}} e^{2}} n^{2}= \frac{\varepsilon_{0} h^{2}}{\pi m_{\mathrm{e}} e^{2}} n^{2}$$</span></p><p>这就是原子中第 <span class="math inline"><em>n</em></span>个稳定轨道的半径。<span class="math inline"><em>n</em></span>只能取正整数，轨道是分立的。当 <span class="math inline"><em>n</em> = 1</span>，给出 <span class="math inline"><em>r</em><sub>1</sub> = 0.529<em>Å</em></span>，这是氢原子的<strong>核外电子最小轨道半径</strong>，称为<strong>玻尔半径</strong> 。</p><h3 id="电子能量">电子能量</h3><p>当电子在半径为 <span class="math inline"><em>r</em><sub><em>n</em></sub></span>的轨道上，氢原子系统的能量等于电子质子系统的静电势能与电子的动能之和，如以电子无穷远处静电势能为零，则<span class="math display">$$E_{n}=-\frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{r_{n}}+\frac{1}{2}m_{\mathrm{e}} v_{n}^{2}=-\frac{1}{8 \pi \varepsilon_{0}}\frac{e^{2}}{r_{n}}$$</span></p><p>代入得到 <span class="math display">$$E_{n}=-\frac{m_{e} e^{4}}{8 \varepsilon_{0}^{2} h^{2}}\frac{1}{n^{2}}=-\frac{13.6}{n^2}\mathrm{eV}$$</span></p><p>该式表示电子在第 <span class="math inline"><em>n</em></span>个稳定轨道运动时氢原子系统的能量。</p><ul><li>氢原子能量是不连续的，这就是<strong>能量量子化</strong> 。</li><li>以 <span class="math inline"><em>n</em> = 1</span> 代入式 <span class="math inline">(1 − 29)</span> 得 <span class="math inline"><em>E</em><sub><em>n</em></sub> = −13.6eV</span>，这是氢原子的最低能级，称为<strong>基态能级</strong>。</li><li>若定义基态能级的能量为零，将氢原子基态电子移动到无限远时所需要的能量就是氢原子<strong>电离能</strong>。</li><li>对于 <span class="math inline"><em>n</em> &gt; 1</span>的各稳定态，其能量大于基态能量，随着量子数 <span class="math inline"><em>n</em></span>的增大而增大，能量间隔减小，这种状态称为<strong>激发态</strong> 。</li><li>当 <span class="math inline"><em>n</em> → ∞</span> 时，<span class="math inline"><em>r</em><sub><em>n</em></sub> → ∞</span>，<span class="math inline"><em>E</em><sub><em>n</em></sub> → 0</span>，能级趋于连续。<span class="math inline"><em>E</em> &gt; 0</span>时，原子处于<strong>电离状态</strong> ，能量可连续变化。</li><li>里德伯常量的理论值：<span class="math display">$$R_{\mathrm{H}}=\frac{m_{e} e^{4}}{8 \varepsilon_{0}^{2} h^{3}c}=1.0973731 \times 10^{7} \mathrm{~m}^{-1}$$</span>它与实验值符合得很好。</li></ul><h3 id="玻尔理论的局限性">玻尔理论的局限性</h3><p>玻尔理论存在的问题和局限性后来被逐渐揭示。首先，该理论无法解释复杂原子的光谱，例如氦原子光谱。其次，玻尔理论无法系统地计算光谱线的相对强度，即便是氢原子的光谱线强度；也不能处理非束缚态问题，例如散射问题。最后，从理论体系上看，玻尔理论与经典力学不相容，如角动量量子化、能量量子化等，但这些结果并没有揭示出不连续的本质。量子力学就是在克服这些困难和局限性的过程中逐渐发展成一个完整的理论体系。</p><h1 id="量子力学入门">量子力学入门</h1><h2 id="物质波">物质波</h2><p>德布罗意认为光有波粒二象性，物质或许也有波粒二象性。他提出物质波假说：一个能量为<span class="math inline"><em>E</em></span>、动量为 <span class="math inline"><em>p</em></span> 的粒子具有波动性，波长 <span class="math inline"><em>λ</em></span> 和频率 <span class="math inline"><em>ν</em></span> 分别与粒子的动量和能量成正比，即<span class="math display">$$\lambda=\frac{h}{p},\nu=\frac{E}{h}$$</span></p><p>这与光的波粒二象性的关系相同。</p><ul><li>上式把波的概念与粒子的概念联系起来。第一个关系称为<strong>德布罗意关系</strong>。这种与实物粒子相联系的波称为<strong>德布罗意波</strong>，或称为<strong>物质波</strong> 。</li><li>由于 <span class="math inline"><em>h</em></span>很小，通常实物粒子波长非常短，波动性无法表现。但是在原子世界中，就显现出微观粒子的波动性。</li></ul><h3 id="微观波粒二象性粒子属性转换">微观波粒二象性粒子属性转换</h3><table><thead><tr><th>物理量</th><th>波动性</th><th>粒子性</th></tr></thead><tbody><tr><td>波长 <span class="math inline"><em>λ</em></span></td><td><span class="math inline"><em>h</em>/<em>p</em></span></td><td><span class="math inline"><em>v</em>/<em>ν</em></span></td></tr><tr><td>频率 <span class="math inline"><em>ν</em></span></td><td><span class="math inline"><em>E</em>/<em>h</em></span></td><td><span class="math inline"><em>v</em>/<em>λ</em></span></td></tr><tr><td>动量 <span class="math inline"><em>p</em></span></td><td><span class="math inline"><em>h</em>/<em>λ</em></span></td><td><span class="math inline"><em>m</em><em>v</em></span> = <span class="math inline">$\sqrt{2 m E}$</span></td></tr><tr><td>能量 <span class="math inline"><em>E</em></span></td><td><span class="math inline"><em>h</em><em>ν</em></span></td><td><span class="math inline">$\frac{1}{2}mv^2 = \frac{p^2}{2m}$</span></td></tr></tbody></table><h3 id="相对论公式">相对论公式</h3><p><span class="math display">$$\begin{aligned}E &amp;= E_0 + E_k = m_0 c^2 + E_k \\E^2 &amp;= E_0^2 + p^2 c^2 = m_0^2 c^4 + p^2 c^2 \\\Rightarrow p &amp;= \frac{1}{c} \sqrt{E^2 - E_0^2} \\&amp;= \frac{1}{c} \sqrt{(E_0 + E_k)^2 - E_0^2} \\&amp;= \frac{1}{c} \sqrt{E_k^2 + 2 E_0 E_k} \\&amp;= \frac{1}{c} \sqrt{E_k^2 + 2 m_0 c^2 E_k} \\\Rightarrow \lambda &amp;= \frac{h}{p} = \frac{h c}{\sqrt{E_k^2 + 2 E_0E_k}} \\&amp;= \frac{h c}{\sqrt{E_k^2 + 2 m_0 c^2 E_k}} \\\end{aligned}$$</span></p><h3 id="革末实验">革末实验</h3><p>晶体的X射线衍射实验中，同一晶面上相邻原子散射的光波的光程差等于零，它们相干加强,反射给出强度最大的方向。一组晶面，可实现多光束相干叠加。若要在该方向上不同晶面上原子散射光相干加强,满足布拉格公式： <span class="math display"><em>δ</em> = 2<em>d</em>sin <em>θ</em> = <em>k</em><em>λ</em></span></p><p>式中，<span class="math inline"><em>δ</em></span> 为光程差，<span class="math inline"><em>d</em></span> 为晶面间距，<span class="math inline"><em>θ</em></span> 为入射角，<span class="math inline"><em>k</em></span> 为整数。</p><h2 id="不确定度关系">不确定度关系</h2><p>在经典力学中，一个粒子的位置和动量可以同时确定，而且知道了某一时刻粒子的位置和动量，原则上可以预言以后任意时刻粒子的位置和动量。然后，微观粒子的衍射实验已经表明微观粒子有明显的波性。粒子位置是不确定的，出现在某区域，例如出现在b<span class="math inline"><em>Δ</em><em>x</em><em>Δ</em><em>y</em><em>Δ</em><em>z</em></span>范围内，可以称 <span class="math inline"><em>Δ</em><em>x</em></span>、<span class="math inline"><em>Δ</em><em>y</em></span>、<span class="math inline"><em>Δ</em><em>z</em></span>为粒子<strong>位置不确定量</strong>。粒子的动量、角动量等力学量也是如此。由 <span class="math inline">$p=\frac{h}{\lambda}$</span> 算出动量的可能范围<span class="math inline"><em>Δ</em><em>p</em></span>，<span class="math inline"><em>Δ</em><em>p</em></span> 就是动量不确定量。<br>海森伯发现物理量的不确定量受到普朗克常量支配。他在 <span class="math inline">1927</span>年提出了微观粒子的位置和动量两者的不确定量满足 <span class="math display">$$\Delta x \Delta p_{x} \geqslant \frac{\hbar}{2},\quad \Delta y \Deltap_{y} \geqslant \frac{\hbar}{2},\quad \Delta z \Delta p_{z} \geqslant\frac{\hbar}{2}$$</span></p><p>上式称为位置和动量的<strong>不确定度关系</strong>。它的物理意义是客观上微观粒子不可能同时具有确定的坐标位置和相应的动量，粒子的位置不确定量<span class="math inline"><em>Δ</em><em>x</em></span> 越小，动量不确定量<span class="math inline"><em>Δ</em><em>p</em><sub><em>x</em></sub></span>就越大，反之亦然。</p><p>同样，微观粒子能量和时间的不确定量满足 <span class="math display">$$\Delta E \Delta t \geqslant \frac{\hbar}{2}$$</span></p><p>上式称为时间和能量的<strong>不确定度关系</strong>。它的物理意义是客观上微观粒子不可能同时具有确定的能量和相应的时间，粒子的能量不确定量<span class="math inline"><em>Δ</em><em>E</em></span> 越小，时间不确定量<span class="math inline"><em>Δ</em><em>t</em></span>就越大，反之亦然。</p><h3 id="不确定度关系解题步骤">不确定度关系解题步骤</h3><ol type="1"><li>确定已知定值条件、已知差值条件和要求的差值</li><li>根据“微观波粒二象性粒子属性转换”，拿到相关的物理量</li><li>应用“时间和能量不确定性关系/位置和动量不确定性关系”（最多一次），得到答案</li></ol><p><img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload></p><h2 id="波函数单色平面波">波函数（单色平面波）</h2><p>既然微观粒子具有波动性，应引入描述这种波的波函数。德布罗意认为能量为<span class="math inline"><em>E</em></span>、动量大小为 <span class="math inline"><em>p</em></span> 的“自由粒子”沿 <span class="math inline"><em>x</em></span>方向运动时，对应的物质波应为“单色平面波”。即对应一列角波数和圆频率分别为<span class="math inline"><em>k</em>, <em>ω</em></span> 的单色波 <span class="math display"><em>Ψ</em>(<em>x</em>, <em>t</em>) = <em>ψ</em><sub>0</sub>e<sup>−i(<em>ω</em><em>t</em> − <em>k</em><em>x</em>)</sup></span></p><p>式中 <span class="math inline"><em>ψ</em><sub>0</sub></span>为复数（待定），可见波函数 <span class="math inline"><em>Ψ</em>(<em>x</em>, <em>t</em>)</span>为一复变函数。按德布罗意假设，可将波函数用粒子的能量和动量表示为 <span class="math display">$$\Psi(x,t)=\psi_{0} \mathrm{e}^{-\frac{i}{\hbar}(E t-p x)}$$</span></p><p>式中 <span class="math inline">ℏ = <em>h</em>/2<em>π</em></span>，称为约化普朗克常数。<br>若粒子为三维自由运动，则波函数可表示为 <span class="math display">$$\Psi(\boldsymbol{r},t)=\psi_{0} \mathrm{e}^{-\frac{i}{\hbar}(E t-p \cdotr)}$$</span></p><p>的概率密度。</p><ul><li>微观粒子物质波的波函数只能用复数形式来表达，不能用实数形式来表达</li><li>在一般情况下，粒子的波函数不是单色平面波的形式，而是空间和时间的复杂函数。</li><li>波函数既不描述粒子的形状，也不描述粒子运动的轨迹，它只给出粒子运动的概率分布。</li></ul><h3 id="波函数的统计意义">波函数的统计意义</h3><p>波函数模的平方代表在时刻 <span class="math inline"><em>t</em></span>、空间 <span class="math inline"><em>r</em></span> 处单位体积中微观粒子出现的概率，即<span class="math display"><em>ρ</em>(<strong>r</strong>, <em>t</em>) = |<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> = <em>Ψ</em>(<strong>r</strong>, <em>t</em>)<sup>*</sup><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span></p><p>为粒子的<strong>概率密度</strong> ，其中 <span class="math inline"><em>Ψ</em><sup>*</sup>(<strong>r</strong>, <em>t</em>)</span>是 <span class="math inline"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>的复共轭。波函数是不可观测量，而概率密度可观测量。由于波函数的模方具有概率的意义，故也将德布罗意波称为概率波。在体积元<span class="math inline">d<em>V</em></span> 中发现粒子的概率为 <span class="math display"><em>ρ</em>(<strong>r</strong>, <em>t</em>)d<em>V</em> = <em>Ψ</em>(<strong>r</strong>, <em>t</em>)<sup>*</sup><em>Ψ</em>(<strong>r</strong>, <em>t</em>)d<em>V</em> = |<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup>&nbsp;d<em>V</em></span></p><h3 id="性质">性质</h3><ul><li>连续性</li><li>有限性</li><li>单值性</li></ul><h3 id="归一化条件">归一化条件</h3><p>由于在全空间一定能找到粒子，故概率密度在全空间积分为 <span class="math inline">1</span>，即 <span class="math display">∫<sub><em>Ω</em></sub><em>Ψ</em><sup>*</sup>(<strong>r</strong>, <em>t</em>)<em>Ψ</em>(<strong>r</strong>, <em>t</em>)d<em>V</em> = 1</span></p><p>式中 <span class="math inline"><em>Ω</em></span>表示全空间区域，称该式为波函数的归一化条件。</p><h3 id="波粒二象性">波粒二象性</h3><p>量子力学中微观粒子的“粒子性”和“波动性”含义与经典粒子和经典波的不同</p><ul><li>“粒子性”主要指微观粒子的整体性和不可分性，粒子没有确定的轨道；</li><li>“波动性”主要指描述微观粒子状态的波函数是可以叠加的，像经典波一样可以出现“干涉”“衍射”等现象。但与经典的波不同，波函数并不对应真实物理量的波动。</li><li>“波粒二象性”是指微观粒子可显示出“波动”和“粒子”两种不同属性。在一些情况下，微观粒子突出显示出其粒子特性，而在另一些情况下，则突出显示出波动特性。</li></ul><h3 id="动量概率分布">动量概率分布</h3><p><span class="math display">$$\begin{aligned}\Phi(\vec p,t) = \int_\infty\Psi(\vecr,t)\sqrt{\frac{1}{(2\pi\hbar)^3}}e^{-i\ \vec p\cdot \vec r/\hbar}\mathrm{d}x\mathrm{d}y\mathrm{d}z \\\Psi(\vec r,t) = \int_\infty\Phi(\vecp,t)\sqrt{\frac{1}{(2\pi\hbar)^3}}e^{i\ \vec p\cdot \vec r/\hbar}\mathrm{d}p_x\mathrm{d}p_y\mathrm{d}p_z\end{aligned}$$</span></p><p>我们发现，由于 <span class="math inline">$\Psi(\vec{r_{}},t)$</span>和 <span class="math inline">$\Phi(\vec{p_{}},t)$</span>可以唯一地互相求出，也就意味着它们包含了同样多的信息。既然 <span class="math inline">$\Psi(\vec{r_{}},t)$</span> 描述了体系的状态，那么<span class="math inline">$\Phi(\vec{p_{}},t)$</span>也描写了体系的状态。<span class="math inline">$\Phi(\vec{p_{}},t)$</span>的物理意义是动量概率振幅，即 <span class="math inline">$|\Phi(\vec{p_{}},t)|^{2}$</span>代表动量概率密度。</p><h1 id="量子力学深入">量子力学深入</h1><h2 id="物理量与算符">物理量与算符</h2><ul><li>由于微观客体的运动具有统计规律性（表现为概率波），测量一个与微观运动相关的物理量时，一般就不像在经典的宏观物理中那样具有确定值。例如，一个电子的位置在经典物理中是完全可以确定的，无论是理论计算还是实验方法，均可以测定它。但是电子具有波粒二象性，位置一般不确定，按照统计规律分布于空间，因而只能表达为电子的平均位置。</li><li>设电子处于 <span class="math inline"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>，<span class="math inline"><strong>r</strong></span> ： <span class="math inline">(<em>x</em>, <em>y</em>, <em>z</em>)</span>表示其位置，则在 <span class="math inline"><em>t</em></span>时刻，电子的位置在 <span class="math inline"><em>x</em> → <em>x</em> + d<em>x</em>, <em>y</em> → <em>y</em> + d<em>y</em>, <em>z</em> → <em>z</em> + d<em>z</em></span>之间的概率正比于 <span class="math inline">|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup>&nbsp;d<em>x</em>&nbsp;d<em>y</em>&nbsp;d<em>z</em></span>，因此电子的平均位置用<span class="math inline">⟨<strong>r</strong>⟩</span> 表示为 <span class="math display">$$ \langle\boldsymbol{r}\rangle=\frac{\iiint\boldsymbol{r}|\Psi(\boldsymbol{r},t)|^{2} \mathrm{~d} x \mathrm{~d} y\mathrm{~d} z}{\iiint|\Psi(\boldsymbol{r},t)|^{2} \mathrm{~d} x\mathrm{~d} y \mathrm{~d} z}$$</span> 如果 <span class="math inline"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>是归一化的，则 <span class="math inline">∭|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup>&nbsp;d<em>x</em>&nbsp;d<em>y</em>&nbsp;d<em>z</em> = 1</span>，于是<span class="math display">⟨<strong>r</strong>⟩ = ∭<strong>r</strong>|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup>&nbsp;d<em>x</em>&nbsp;d<em>y</em>&nbsp;d<em>z</em></span></li><li>人们发现，各个力学量在量子力学中都表现为作用于波函数的某种算符，如动量算符、角动量算符、能量算符、自旋算符等。因此，作为量子力学基本假设之一而提出：<strong>每一个力学量（不限于经典的力学量，如自旋）都与一个算符相对应。算符对波函数的作用就是把一个波函数（态）变换为另一个波函数（态）。</strong></li><li>设有某种运算 <span class="math inline"><em>F̂</em></span>，把某一函数<span class="math inline"><em>Ψ</em></span> 变成另一函数 <span class="math inline"><em>ϕ</em></span> ：<span class="math display"><em>F̂</em><em>Ψ</em> = <em>ϕ</em></span>式中，<span class="math inline"><em>F̂</em></span>称为<strong>算符</strong>。</li></ul><h3 id="线性算符">线性算符</h3><p>设任意两个函数 <span class="math inline"><em>ϕ</em><sub>1</sub>, <em>ϕ</em><sub>2</sub></span>，<span class="math inline"><em>F̂</em></span> 满足 <span class="math display"><em>F̂</em>(<em>c</em><sub>1</sub><em>ϕ</em><sub>1</sub> + <em>c</em><sub>2</sub><em>ϕ</em><sub>2</sub>) = <em>c</em><sub>1</sub><em>F̂</em><em>ϕ</em><sub>1</sub> + <em>c</em><sub>2</sub><em>F̂</em><em>ϕ</em><sub>2</sub></span></p><p>式中，<span class="math inline"><em>c</em><sub>1</sub>, <em>c</em><sub>2</sub></span>为任意常数；<span class="math inline"><em>F̂</em></span>称为线性算符。显然，<span class="math inline">$\frac{\partial}{\partialx}$</span> 和 <span class="math inline"><em>x</em></span> 为线性算符，而<span class="math inline">$\sqrt{ }$</span>就不是。量子力学中只讨论线性算符。</p><h3 id="算符相等">算符相等</h3><p>对任意 <span class="math inline"><em>ϕ</em><sub>1</sub></span>，若<span class="math display"><em>F̂</em><em>ϕ</em><sub>1</sub> = <em>Ĝ</em><em>ϕ</em><sub>1</sub></span></p><p>则称两个算符相等，即 <span class="math inline"><em>F̂</em> = <em>Ĝ</em></span>。</p><h3 id="算符加法">算符加法</h3><p>对任意 <span class="math inline"><em>ϕ</em></span>，若 <span class="math display">(<em>F̂</em> + <em>Ĝ</em>)<em>ϕ</em> = <em>F̂</em><em>ϕ</em> + <em>Ĝ</em><em>ϕ</em> = (<em>Ĝ</em> + <em>F̂</em>)<em>ϕ</em></span></p><p>则称 <span class="math inline"><em>F̂</em> + <em>Ĝ</em></span> 为算符<span class="math inline"><em>F̂</em></span> 和 <span class="math inline"><em>Ĝ</em></span> 之和，且满足 <span class="math inline"><em>F̂</em> + <em>Ĝ</em> = <em>Ĝ</em> + <em>F̂</em></span>。</p><h3 id="算符的乘法">算符的乘法</h3><p>两个算符相乘，<span class="math inline">(<em>F̂</em><em>Ĝ</em>)<em>ϕ</em> = <em>F̂</em>(<em>Ĝ</em><em>ϕ</em>)</span>，满足分配律和结合律：<span class="math display">$$\begin{aligned}&amp;(\hat{F}+\hat{G}) \hat{R}=\hat{F} \hat{R}+\hat{G} \hat{R}\\&amp;\hat{F} \hat{G} \hat{R}=(\hat{F} \hat{G}) \hat{R}=\hat{F}(\hat{G}\hat{R})\end{aligned}$$</span></p><h3 id="乘法交换律与对易性">乘法交换律与对易性</h3><p>算符乘法交换律一般不成立，即 <span class="math display">$$\begin{aligned}&amp;\hat{F} \hat{G} \neq \hat{G} \hat{F} \\&amp;\hat{F} \hat{G}-\hat{G} \hat{F} \equiv[\hat{F},\hat{G}] \neq 0\end{aligned}$$</span></p><ul><li>式中，<span class="math inline">[  ]</span>称为<strong>对易括号</strong> ，例如 <span class="math inline"><em>F̂</em> = <em>x</em></span>，<span class="math inline">$\hat{G}=\hat{p}_{x}=-\mathrm{i} \hbar\frac{\partial}{\partial x}$</span>，有 <span class="math inline">[<em>x</em>, <em>p̂</em><sub><em>x</em></sub>] = iℏ</span>。</li><li>经典物理中的位置和动量等力学量都是数值变量，<span class="math inline"><em>x</em><em>p</em><sub><em>x</em></sub></span> 与<span class="math inline"><em>p</em><sub><em>x</em></sub><em>x</em></span>并无不同，而在量子力学中，力学量之间的运算是算符的运算，<span class="math inline"><em>x</em><em>p̂</em><sub><em>x</em></sub></span> 和<span class="math inline"><em>p̂</em><sub><em>x</em></sub><em>x</em></span>作用于波函数会得到不一样的结果，即 <span class="math inline"><em>x</em><em>p̂</em><sub><em>x</em></sub> ≠ <em>p̂</em><sub><em>x</em></sub><em>x</em></span>，也就是说，<span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>p̂</em><sub><em>x</em></sub></span> 不对易。</li><li>若 <span class="math inline"><em>F̂</em><em>Ĝ</em> − <em>Ĝ</em><em>F̂</em> ≡ [<em>F̂</em>, <em>Ĝ</em>] = 0</span>，则说明<span class="math inline"><em>F̂</em></span>、<span class="math inline"><em>Ĝ</em></span> 是<strong>彼此对易</strong>的。例如 <span class="math inline"><em>x</em><em>y</em> − <em>y</em><em>x</em> ≡ [<em>x</em>, <em>y</em>] = 0</span>。</li><li>不难验证 <span class="math display">$$\begin{array}{c}{[\hat{F},\hat{G}]=-[\hat{G},\hat{F}]} \\{[\hat{F},\hat{G}+\hat{R}]=[\hat{F},\hat{G}]+[\hat{F},\hat{R}]} \\{[\hat{F},\hat{G} \hat{R}]=[\hat{F},\hat{G}]\hat{R}+\hat{G}[\hat{F},\hat{R}]} \\{[\hat{G} \hat{R},\hat{F}]=[\hat{G},\hat{F}]\hat{R}+\hat{G}[\hat{R},\hat{F}]} \\{[\hat{F},[\hat{G},\hat{R}]]+[\hat{G},[\hat{R},\hat{F}]]+[\hat{R},[\hat{F},\hat{G}]]=0}\end{array}$$</span></li></ul><h3 id="厄密算符">厄密算符</h3><p>若线性算符 <span class="math inline"><em>F̂</em></span> 满足 <span class="math display">∭<em>ψ</em><sup>*</sup><em>F̂</em><em>φ</em>d<em>τ</em> = ∭(<em>F̂</em><em>ψ</em>)<sup>*</sup><em>φ</em>d<em>τ</em></span></p><p>则 <span class="math inline"><em>F̂</em></span>称为<strong>自厄（厄密）算符</strong> ，其中 <span class="math inline"><em>ψ</em></span>、<span class="math inline"><em>φ</em></span>是任意两个波函数（模平方可积函数）。例如 <span class="math inline"><em>x</em></span>、<span class="math inline"><em>p̂</em><sub><em>x</em></sub></span>为厄密算符。</p><p>厄密算符的本征值为实数，若 <span class="math inline"><em>F̂</em><em>ψ</em> = <em>λ</em><em>ψ</em></span>，则<span class="math inline"><em>λ</em></span> 是实数。 <span class="math display">$$\begin{aligned}&amp;\iint \psi^{*} \hat{F} \psi \mathrm{d} \tau =\iint(\hat{F}\psi)^{*} \psi \mathrm{d} \tau =\lambda^{*} \iint \psi^{*} \psi\mathrm{d} \tau \\&amp;\iint \psi^{*} \hat{F} \psi \mathrm{d} \tau =\lambda \iint \psi^{*}\psi \mathrm{d} \tau \\&amp;\therefore \lambda=\lambda^{*}\end{aligned}$$</span></p><h3 id="线性厄密算符">线性厄密算符</h3><p>与 <strong>力学量</strong> 对应的算符是<strong>线性厄密算符</strong>，在任何状态下，厄密算符所代表的力学量平均值都是实数，即 <span class="math display">⟨<em>Â</em>⟩ = ∬<em>ψ</em><sup>*</sup><em>Â</em><em>ψ</em>d<em>τ</em> = 实数</span></p><p>取上式的复数共轭 <span class="math display">$$\begin{aligned}\langle\hat{A}\rangle^{*} &amp;= \iint (\psi^{*} \hat{A} \psi)^{*}\mathrm{d} \tau = \iint \psi (\hat{A} \psi)^{*} \mathrm{d} \tau \\&amp;=\iint (\hat{A} \psi)^{*} \psi \mathrm{d} \tau = \iint \psi^{*}\hat{A} \psi \mathrm{d} \tau = \langle\hat{A}\rangle\end{aligned}$$</span></p><p>这也是力学量的<strong>平均值</strong> 。</p><h2 id="算符与本征方程">算符与本征方程</h2><h3 id="定义">定义</h3><ul><li>量子力学中，算符作用在一个函数（态）上，得到另一个函数（态）。</li><li>任何一个力学量均对应一个算符，算符的<strong>本征值</strong>就是力学量的可能取值，这就是<strong>力学量算符表示假设</strong> 。</li></ul><h3 id="狄拉克符号">狄拉克符号</h3><p>下面用<strong>狄拉克符号</strong> 来表示波函数。</p><p>这里引入 <span class="math inline">|<em>x</em>⟩</span>表示波函数，<span class="math inline">|<em>x</em>⟩</span>称为<strong>右矢</strong> ，而 <span class="math inline">⟨<em>x</em>|</span> 称为<strong>左矢</strong> ，符号<span class="math inline">⟨<em>x</em> ∣ <em>y</em>⟩</span> 表示 <span class="math inline">⟨<em>x</em>|</span> 与 <span class="math inline">|<em>y</em>⟩</span> 的<strong>内积</strong>。内积满足 <span class="math inline">⟨<em>x</em> ∣ <em>y</em>⟩ = ⟨<em>y</em> ∣ <em>x</em>⟩<sup>*</sup></span>，<span class="math inline">⟨<em>x</em> ∣ <em>x</em>⟩ = ⟨<em>x</em> ∣ <em>x</em>⟩<sup>*</sup>=</span>实数。<br>波函数 <span class="math inline">|<em>x</em>⟩</span>表示某本征态，波函数 <span class="math inline">|<em>y</em>⟩</span>表示另一本征态，则波函数 <span class="math inline">|<em>ψ</em>⟩</span>应由 <span class="math inline">|<em>x</em>⟩</span> 和 <span class="math inline">|<em>y</em>⟩</span> 组合来表示 <span class="math display">|<em>ψ</em>⟩ = <em>C</em><sub>1</sub>|<em>x</em>⟩ + <em>C</em><sub>2</sub>|<em>y</em>⟩</span></p><h3 id="态基">态基</h3><p>正如普通矢量空间中通常选取正交坐标轴和单位基矢，在量子态矢空间通常选取的态基<span class="math inline">|<em>e</em><sub><em>i</em></sub>⟩(<em>i</em> = 1, 2, 3, ⋯)</span>满足正交归一条件 <span class="math display">$$\left\langle e_{i} \mid e_{j}\right\rangle=\delta_{i j}\equiv\left\{\begin{array}{ll} 1,&amp; i=j \\ 0,&amp; i \neq j\end{array}\right.$$</span></p><p>式中，<span class="math inline"><em>δ</em><sub><em>i</em><em>j</em></sub></span>称为<strong>克罗内克符号</strong> 。任何态矢 <span class="math inline"><em>ψ</em></span>的线性叠加可以表示为基矢的线性叠加，即 <span class="math inline"><em>ψ</em> = ∑<sub><em>i</em></sub><em>C</em><sub><em>i</em></sub>|<em>e</em><sub><em>i</em></sub>⟩</span>。</p><h3 id="正交">正交</h3><p>当两个函数 <span class="math inline"><em>ψ</em><sub>1</sub></span> 和<span class="math inline"><em>ψ</em><sub>2</sub></span> 满足下列关系：<span class="math display">∫<em>ψ</em><sub>1</sub><sup>*</sup><em>ψ</em><sub>2</sub>&nbsp;d<em>τ</em> = ⟨<em>ψ</em><sub>1</sub> ∣ <em>ψ</em><sub>2</sub>⟩ = 0</span></p><p>式中变量在全部区域积分为零，则称两函数<strong>相互正交</strong>。<span class="math inline">⟨<em>ψ</em><sub>1</sub> ∣ <em>ψ</em><sub>2</sub>⟩</span>称为两个函数的<strong>内积</strong> 。</p><h3 id="本征值本征态">本征值、本征态</h3><p>实验测量的结果只有有限种，把可能的测量值称为波函数的<strong>本征值</strong>，而把相应的波函数 <span class="math inline">|<em>x</em>⟩</span> 和<span class="math inline">|<em>y</em>⟩</span>表示的态称为<strong>本征态</strong>，两个波函数则称为对应力学量的<strong>本征函数</strong> 。<br>对于任意本征态 <span class="math inline">|<em>χ</em>⟩</span>，有 <span class="math display">|<em>χ</em>⟩ = |<em>x</em>⟩⟨<em>x</em> ∣ <em>χ</em>⟩ + |<em>y</em>⟩⟨<em>y</em> ∣ <em>χ</em>⟩ = ∑<sub><em>i</em></sub>|<em>e</em><sub><em>i</em></sub>⟩⟨<em>e</em><sub><em>i</em></sub> ∣ <em>χ</em>⟩</span></p><p>式中，<span class="math inline">⟨<em>e</em><sub><em>i</em></sub> ∣ <em>χ</em>⟩</span>是处于 <span class="math inline">|<em>χ</em>⟩</span> 的光子处在 <span class="math inline">|<em>e</em><sub><em>i</em></sub>⟩</span>基的概率幅，则 <span class="math inline">|⟨<em>e</em><sub><em>i</em></sub> ∣ <em>χ</em>⟩|<sup>2</sup></span>为该光子处在 <span class="math inline">|<em>e</em><sub><em>i</em></sub>⟩</span>基的概率，且有 <span class="math inline">∑<sub><em>i</em></sub>|<em>e</em><sub><em>i</em></sub>⟩⟨<em>e</em><sub><em>i</em></sub>| = 1</span>，称为<strong>恒等变化算符</strong>。</p><h3 id="本征方程">本征方程</h3><ul><li>人们从实验事实总结出量子力学的另一基本假设：<strong>在任何状态下测一个力学量，单次测量的结果必是这个力学量的某一本征值，而经过测量后，原先的状态转变为与这个特殊本征值相应的本征态。</strong>如果在这个本征态下测量同一力学量，测得的当然是同一本征值。力学量的本征态具有一个重要的基本特性，即在本征态下测量这个力学量，测量值是确定的。一般的态总可以表示为本征态的叠加，这也是本征态的一个重要和基本的特性。</li><li>若算符 <span class="math inline"><em>F̂</em></span> 作用于某个函数<span class="math inline"><em>u</em></span> 有 <span class="math display"><em>F̂</em><em>u</em> = <em>λ</em><em>u</em></span>所得结果是一常数 <span class="math inline"><em>λ</em></span> 与 <span class="math inline"><em>u</em></span> 的乘积，则 <span class="math inline"><em>λ</em></span> 称为算符的<strong>本征值</strong>，<span class="math inline"><em>u</em></span>称为算符的<strong>本征函数</strong> 。</li><li>一般而言，对应于不同的本征值，算符有不同的本征函数。为了强调本征值与本征函数的关系，我们说<span class="math inline"><em>u</em></span> 是算符 <span class="math inline"><em>F</em></span> 属于本征值 <span class="math inline"><em>λ</em></span>的本征函数。本征值方程的解不仅取决于算符的本身性质，还取决于函数所满足的边界条件。</li><li>算符 <span class="math inline"><em>F̂</em></span>的本征方程的本征值数目可以是有限的，也可以是无限的。本征值的分布可以是分立的，也可以是连续的。这些都由算符的性质和本征函数满足的边界条件决定。算符本征值的集合称为<strong>本征值谱</strong> 。如果本征值是一些分立值，则称这些本征值组成<strong>分立谱</strong> ；如果本征值是连续分布的，则称这些本征值组成<strong>连续谱</strong> 。</li><li>对于一个本征值，若只有一个本征函数，则称为 <strong>无简并</strong>。若同一本征值，对应 <span class="math inline"><em>f</em></span> 个<strong>线性无关</strong> 本征函数，则该本征值 <strong>有简并</strong>，<strong>简并度</strong> 为 <span class="math inline"><em>f</em></span>。对应同一本征值的 <span class="math inline"><em>f</em></span> 个本征函数的任意线性组合，有 <span class="math display"><em>F̂</em>(<em>C</em><sub>1</sub><em>u</em><sub>1</sub> + <em>C</em><sub>2</sub><em>u</em><sub>2</sub> + ⋯ + <em>C</em><sub><em>f</em></sub><em>u</em><sub><em>f</em></sub>) = <em>λ</em>(<em>C</em><sub>1</sub><em>u</em><sub>1</sub> + <em>C</em><sub>2</sub><em>u</em><sub>2</sub> + ⋯ + <em>C</em><sub><em>f</em></sub><em>u</em><sub><em>f</em></sub>)</span>其中 <span class="math inline"><em>C</em><sub><em>i</em></sub>(<em>i</em> = 1, 2, ⋯, <em>f</em>)</span>是系数。所以仍为 <span class="math inline"><em>F̂</em></span>的本征函数，本征值不变。</li><li>如果 <span class="math inline"><em>F̂</em></span>是<strong>厄密算符</strong> ，它的本征值是<strong>实数</strong> 。设<span class="math inline"><em>λ</em></span> 和 <span class="math inline"><em>ψ</em></span> 表示 <span class="math inline"><em>F̂</em></span>的一个特征值和相应的本征函数，满足本征方程，以 <span class="math inline"><em>ψ</em><sup>*</sup></span>左乘本征方程，并对全空间积分，得到 <span class="math display">∫<em>ψ</em><sup>*</sup><em>F̂</em><em>ψ</em>d<em>τ</em> = <em>λ</em>∫<em>ψ</em><sup>*</sup><em>ψ</em>d<em>τ</em></span>而 <span class="math display">∫(<em>F̂</em><em>ψ</em>)<sup>*</sup><em>ψ</em>d<em>τ</em> = <em>λ</em><sup>*</sup>∫<em>ψ</em><sup>*</sup><em>ψ</em>d<em>τ</em></span>由此得到 <span class="math display"><em>λ</em> = <em>λ</em><sup>*</sup></span> 所以<span class="math inline"><em>λ</em></span> 是实数。</li></ul><h3 id="常用算符">常用算符</h3><ul><li>坐标算符 <span class="math display">$$\hat{\boldsymbol{r}}=\boldsymbol{r}$$</span></li><li>动量算符 <span class="math display">$$\hat{\boldsymbol{p}}=-\mathrm{i} \hbar \boldsymbol{\nabla}$$</span></li><li>动能算符 <span class="math display">$$\hat{E}_{\mathrm{k}}=\frac{\hat{\boldsymbol{p}} \cdot\hat{\boldsymbol{p}}}{2 m}=\frac{-\hbar^{2} \boldsymbol{\nabla}^{2}}{2m}$$</span></li><li>哈密顿算符（能量算符）<span class="math display">$$\hat{H}=\frac{\hat{\boldsymbol{p}}^{2}}{2 m}+U(\boldsymbol{r}) =\frac{-\hbar^{2} \boldsymbol{\nabla}^{2}}{2 m} +U(\boldsymbol{r})$$</span></li><li>角动量算符 <span class="math display">$$ \begin{array}{l}\hat{L}_{x}=y \hat{p}_{z}-z \hat{p}_{y} \\ \hat{L}_{y}=z \hat{p}_{x}-x\hat{p}_{z} \\ \hat{L}_{z}=x \hat{p}_{y}-y \hat{p}_{x} \\\end{array}$$</span></li><li>角动量矢量算符 <span class="math display">$$\hat{\boldsymbol{L}}=\hat{\boldsymbol{r}} \times\hat{\boldsymbol{p}}=\left|\begin{array}{ccc} \boldsymbol{i} &amp;\boldsymbol{j} &amp; \boldsymbol{k} \\ x &amp; y &amp; x \\ \hat{p}_{x}&amp; \hat{p}_{y} &amp; \hat{p}_{z} \end{array}\right|$$</span></li><li>角动量的平方算符 <span class="math display">$$\hat{L}^{2}=\hat{\boldsymbol{L}} \cdot\hat{\boldsymbol{L}}=\hat{L}_{x}^{2}+\hat{L}_{y}^{2}+\hat{L}_{z}^{2}$$</span></li><li>角动量在不同坐标下<ul><li>直角坐标系 <span class="math display">$$  \begin{array}{c}  \hat{L}_{x}=-\mathrm{i} \hbar\left(y \frac{\partial}{\partial z}-z\frac{\partial}{\partial y}\right) \\  \hat{L}_{y}=-\mathrm{i} \hbar\left(z \frac{\partial}{\partial x}-x\frac{\partial}{\partial z}\right) \\ \hat{L}_{z}=-\mathrm{i}\hbar\left(x \frac{\partial}{\partial y}-y \frac{\partial}{\partialx}\right) \\  \hat{L}^{2}=-\hbar^{2}\left[\left(y \frac{\partial}{\partial z}-z\frac{\partial}{\partial y}\right)^{2}+\left(z \frac{\partial}{\partialx}-x \frac{\partial}{\partial z}\right)^{2}+\left(x\frac{\partial}{\partial y}-y \frac{\partial}{\partialx}\right)^{2}\right] \\  \end{array}  $$</span></li><li>球坐标系 <span class="math display">$$  \begin{array}{c}  \hat{L}^{2}=-\hbar^{2}\left[\frac{1}{\sin \theta}\frac{\partial}{\partial \theta}\left(\sin \theta\frac{\partial}{\partial \theta}\right)+\frac{1}{\sin ^{2} \theta}\frac{\partial^{2}}{\partial \phi^{2}}\right] \\  \hat{L}_{x}=\mathrm{i} \hbar\left(\sin \phi \frac{\partial}{\partial\theta}+\cot \theta \cos \phi \frac{\partial}{\partial \phi}\right) \\  \hat{L}_{y}=\mathrm{i} \hbar\left(-\cos \phi \frac{\partial}{\partial\theta}+\cot \theta \sin \phi \frac{\partial}{\partial \phi}\right) \\  \hat{L}_{z}=-\mathrm{i} \hbar \frac{\partial}{\partial \phi} \\  \end{array}  $$</span></li></ul></li></ul><h2 id="力学量算符的性质">力学量算符的性质</h2><ul><li><p>厄密算符本征函数的正交性。两个不同本征值的本征函数总是正交的，有简并时，属于同一本征值的本征函数可以不正交，但可以通过线性组合的方法使之正交化。</p></li><li><p>厄密算符本征函数的完备性。厄密算符 <span class="math inline"><em>F̂</em></span> 所对应的一组本征函数 <span class="math inline"><em>u</em><sub>1</sub>, <em>u</em><sub>2</sub>, ⋯, <em>u</em><sub><em>n</em></sub></span>是完备的。即对任意模平方可积函数 <span class="math inline"><em>ψ</em></span>，可表示为 <span class="math display"><em>ψ</em> = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub><em>u</em><sub><em>l</em></sub> = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub>|<em>u</em><sub><em>l</em></sub>⟩</span></p><p>式中，<span class="math inline"><em>C</em><sub><em>l</em></sub></span>为展开系数。这里假定本征值是分立的，即量子化的，因而叠加表现为求和。如果全体本征函数都是非简并的，上式展开系数可以利用本征函数的正交性求出<span class="math inline">(</span> 假定所有本征函数都是归一化的 <span class="math inline">)</span>，做内积 <span class="math display">⟨<em>u</em><sub><em>n</em></sub> ∣ <em>ψ</em>⟩ = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub>⟨<em>u</em><sub><em>n</em></sub> ∣ <em>u</em><sub><em>l</em></sub>⟩ = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub><em>δ</em><sub><em>n</em><em>l</em></sub> = <em>C</em><sub><em>n</em></sub></span>因此 <span class="math display"><em>ψ</em> = ∑<sub><em>l</em></sub>⟨<em>u</em><sub><em>l</em></sub> ∣ <em>ψ</em>⟩<em>u</em><sub><em>l</em></sub> = ∑<sub><em>l</em></sub>⟨<em>u</em><sub><em>l</em></sub> ∣ <em>ψ</em>⟩|<em>u</em><sub><em>l</em></sub>⟩ = ∑<sub><em>l</em></sub>|<em>u</em><sub><em>l</em></sub>⟩⟨<em>u</em><sub><em>l</em></sub> ∣ <em>ψ</em>⟩</span>这种展开与傅里叶展开类似，因此称为广义傅里叶展开。如果本征值是连续的，则展开系数是积分形式。关于这种展开系数的物理意义，在讨论平面波叠加时已经提到。现在的展开虽然是普遍的，物理意义仍与之前相似。设 <span class="math inline"><em>u</em><sub><em>l</em></sub></span>是力学量 <span class="math inline"><em>F̂</em></span>的本征态，相应本征值为 <span class="math inline"><em>λ</em><sub><em>l</em></sub></span>，则式 <span class="math inline">(1 − 131)</span> 中展开系数 <span class="math inline"><em>C</em><sub><em>l</em></sub> = ⟨<em>u</em><sub><em>ι</em></sub> ∣ <em>ψ</em>⟩</span>的模方 <span class="math display">|<em>C</em><sub><em>l</em></sub>|<sup>2</sup> = |⟨<em>u</em><sub><em>l</em></sub> ∣ <em>ψ</em>⟩|<sup>2</sup></span>正比于在 <span class="math inline"><em>ψ</em></span> 下测得力学量 <span class="math inline"><em>F̂</em></span> 的值为 <span class="math inline"><em>λ</em><sub><em>l</em></sub></span>的概率。这一结论从下面可以得到：假定 <span class="math inline"><em>ψ</em></span> 是归一化的，则在 <span class="math inline"><em>ψ</em></span> 态中，力学量的平均值 <span class="math display">$$  \begin{aligned}  \langle\hat{F}\rangle &amp; =\langle\psi|\hat{F}|\psi\rangle=\sum_{l,m} C_{m}^{*} C_{l}\left\langle u_{m}|\hat{F}|u_{l}\right\rangle \\  &amp; =\sum_{l,m} C_{m}^{*} C_{l} \lambda_{l}\delta_{m,l}=\sum_{l}\left|C_{l}\right|{ }^{2} \lambda_{l}  \end{aligned}  $$</span> 如果波函数随着时间变化，则展开系数 <span class="math inline"><em>C</em><sub><em>l</em></sub></span>也是时间的函数，即 <span class="math display"><em>ψ</em>(<em>t</em>) = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub>(<em>t</em>)<em>u</em><sub><em>l</em></sub></span>这种情况下，测得概率 <span class="math inline">|<em>C</em><sub><em>l</em></sub>(<em>t</em>)|<sup>2</sup></span>将随着时间变化。我们将在双态系统中具体讨论。若 <span class="math inline"><em>ψ</em></span> 已经归一化，则 <span class="math display">$$  \begin{aligned}  1 &amp; =\int \psi^{*} \psi \mathrm{d} \tau \\  &amp; =\sum_{m,l} C_{m}^{*} C_{l}\left\langle u_{m} \midu_{l}\right\rangle \\  &amp; =\sum_{m,l} C_{m}^{*} C_{l}\delta_{m,l}=\sum_{l}\left|C_{l}\right|^{2}  \end{aligned}  $$</span> 所得结果是归一化条件，就是总的概率等于 <span class="math inline">1</span>。</p></li><li><p>由此可见，测量力学量 <span class="math inline"><em>F̂</em></span>测得的可能值必定是 <span class="math inline"><em>F̂</em></span>的本征值中的一个。系统状态发生改变，从 <span class="math inline"><em>ψ</em></span> 变成了某一个本征态 <span class="math inline"><em>u</em><sub><em>l</em></sub></span>，称为波包坍缩。对处于同一状态<span class="math inline"><em>ψ</em></span> 的大量体系 <span class="math inline">(</span> 纯系统 <span class="math inline">)</span>进行测量，每次可能给出不同测量值，但测量的平均值 <span class="math inline">(</span> 期待值 <span class="math inline">)</span>为 <span class="math inline">∑<sub><em>l</em></sub>|<em>C</em><sub><em>l</em></sub>|<sup>2</sup><em>λ</em><sub><em>l</em></sub></span>。测量有确定值的条件：当体系处于<span class="math inline"><em>F̂</em></span> 某一本征态时，即初态 <span class="math inline"><em>ψ</em> = <em>u</em><sub><em>l</em></sub></span>，测量后依然处在<span class="math inline"><em>u</em><sub><em>l</em></sub></span>，测量值为<span class="math inline"><em>λ</em><sub><em>l</em></sub></span>，测量前后状态不变。</p></li></ul><h2 id="常用算符的对易性质">常用算符的对易性质</h2><h3 id="动量与位置算符">动量与位置算符</h3><p><span class="math display">$$\begin{array}{c}\left[x,\hat{p}_{x}\right] = \left[y,\hat{p}_{y}\right] =\left[z,\hat{p}_{z}\right] = \mathrm{i} \hbar \\\left[x,\hat{p}_{y}\right] = \left[x,\hat{p}_{z}\right]=0,\cdots\end{array}$$</span></p><p>对任意函数 <span class="math inline"><em>F</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，有<span class="math display">$$\begin{aligned}\left[\hat{p}_{x},F\right]=-\mathrm{i} \hbar \frac{\partial F}{\partialx} \\\left[\hat{p}_{y},F\right]=-\mathrm{i} \hbar \frac{\partial F}{\partialy} \\\left[\hat{p}_{z},F\right]=-\mathrm{i} \hbar \frac{\partial F}{\partialz}\end{aligned}$$</span></p><p>即 <span class="math display">$$[\hat{\boldsymbol{p}},F]=-\mathrm{i} \hbar \nabla F$$</span></p><h3 id="角动量算符">角动量算符</h3><p><span class="math display">$$\begin{array}{l}{\left[\hat{L}_{x},\hat{L}_{y}\right]=\mathrm{i} \hbar\hat{L}_{z}} \\{\left[\hat{L}_{y},\hat{L}_{z}\right]=\mathrm{i} \hbar \hat{L}_{x}} \\{\left[\hat{L}_{z},\hat{L}_{x}\right]=\mathrm{i} \hbar \hat{L}_{y}} \\{\left[\hat{L}_{x},x\right]=0,\left[\hat{L}_{x},y\right]=\mathrm{i}\hbar z,\left[\hat{L}_{x},z\right]=-\mathrm{i} \hbar y} \\{\left[\hat{L}_{y},x\right]=-\mathrm{i} \hbarz,\left[\hat{L}_{y},y\right]=0,\left[\hat{L}_{y},z\right]=\mathrm{i}\hbar x}\\{\left[\hat{L}_{z},x\right]=\mathrm{i} \hbary,\left[\hat{L}_{z},y\right]=-\mathrm{i} \hbarx,\left[\hat{L}_{z},z\right]=0}\end{array}$$</span></p><p>可表示为 <span class="math display">$$\begin{aligned}\left[\hat{L}_{i},r_{j}\right]=\mathrm{i} \hbar \varepsilon_{i j k}r_{k}\\\left[\hat{L}_{i},\hat{L}_{j}\right]=\mathrm{i} \hbar \varepsilon_{i jk} \hat{L}_{k}\end{aligned}$$</span></p><p>式中，<span class="math inline"><em>ε</em><sub><em>i</em><em>j</em><em>k</em></sub></span>是<strong>反对称张量</strong>，<span class="math inline"><em>ε</em><sub>123</sub> = <em>ε</em><sub>231</sub> = <em>ε</em><sub>312</sub> = 1</span>，<span class="math inline"><em>ε</em><sub>213</sub> = <em>ε</em><sub>132</sub> = <em>ε</em><sub>321</sub> = −1</span>。同理，可证明角动量算符与动量算符之间的关系，有 <span class="math display">[<em>L̂</em><sub><em>i</em></sub>, <em>p̂</em><sub><em>j</em></sub>] = iℏ<em>ε</em><sub><em>i</em><em>j</em><em>k</em></sub><em>p̂</em><sub><em>k</em></sub></span></p><h3 id="角动量平方算符">角动量平方算符</h3><p><span class="math display">$$\left[\hat{\vec{L_{}}}^{2},\hat{L}_{x}\right]=\left[\hat{\vec{L_{}}}^{2},\hat{L}_{y}\right]=\left[\hat{\vec{L_{}}}^{2}, \hat{L}_{z}\right]=0$$</span></p><h2 id="不同力学量同时有确定值的条件">不同力学量同时有确定值的条件</h2><ul><li><p>在经典物理学中，在任何状态下测量多个物理量都能得到确定的结果。</p></li><li><p>在量子力学中，系统遵循波粒二象性规律，测量力学量不一定都能得到确定的数值。</p></li><li><p>在量子力学中，只有在一个力学量的本征态下测量该力学量，才能得到确定值。因此，当两个力学量具有共同的本征态，测量这两个力学量均得到确定值。</p></li><li><p>两个力学量 <strong>具有共同本征态</strong>满足的条件是代表这两个力学量的两个算符 <span class="math inline"><em>F̂</em></span> 和 <span class="math inline"><em>Ĝ</em></span> 可以<strong>对易</strong>，即<span class="math display"><em>F̂</em><em>Ĝ</em> − <em>Ĝ</em><em>F̂</em> ≡ [<em>F̂</em>, <em>Ĝ</em>] = 0</span></p></li><li><p>如果一组算符有共同的本征函数，而且这些本征函数组成完全系，则这组算符中<strong>任何</strong> 一个算符与所有其他算符 <strong>对易</strong>。例如动量算符 <span class="math inline"><em>p̂</em><sub><em>x</em></sub></span>、<span class="math inline"><em>p̂</em><sub><em>y</em></sub></span>、<span class="math inline"><em>p̂</em><sub><em>z</em></sub></span>相互对易，所以它们有共同的本征函数 <span class="math inline"><em>ψ</em><sub>P</sub></span>，在这个状态中，这三个算符具有确定值<span class="math inline"><em>p</em><sub><em>x</em></sub></span>、<span class="math inline"><em>p</em><sub><em>y</em></sub></span>、<span class="math inline"><em>p</em><sub><em>z</em></sub></span>。</p></li><li><p>两个力学量 <span class="math inline"><em>Â</em></span>、<span class="math inline"><em>B̂</em></span>，若彼此不对易，<span class="math inline">[<em>Â</em>, <em>B̂</em>] ≠ 0</span>，则一般不能同时有确定值。在任一量子态中，其测量值的不确定程度满足不确定度关系：<span class="math display">$$  \Delta A \Delta B \geqslant\frac{1}{2}|\langle[\hat{A},\hat{B}]\rangle|  $$</span></p><p>其中</p><p><span class="math display">$$  \begin{array}{l}  (\Delta A)^{2}=\int \psi^{*}(\hat{A}-\langle\hat{A}\rangle)^{2} \psi\mathrm{d}\tau=\left\langle\psi\left|(\hat{A}-\langle\hat{A}\rangle)^{2}\right|\psi\right\rangle=\overline{(\hat{A}-\langle\hat{A}\rangle)^{2}} \\  (\Delta B)^{2}=\int \psi^{*}(\hat{B}-\langle\hat{B}\rangle)^{2} \psi\mathrm{d}\tau=\left\langle\psi\left|(\hat{B}-\langle\hat{B}\rangle)^{2}\right|\psi\right\rangle=\overline{(\hat{B}-\langle\hat{B}\rangle)^{2}}  \end{array}  $$</span></p><p>式中，<span class="math inline"><em>Δ</em><em>A</em></span>、<span class="math inline"><em>Δ</em><em>B</em></span> 分别是力学量 <span class="math inline"><em>Â</em></span>、<span class="math inline"><em>B̂</em></span>的方均根偏差，代表它们的不确定程度。上式说明两个线性厄密算符方均根偏差乘积存在的下限。<span class="math inline">⟨<em>Ĉ</em>⟩</span> 是算符 <span class="math inline"><em>Ĉ</em></span>在给定量子态的平均值，在特定的量子态 <span class="math inline">|<em>ϕ</em>⟩</span>，当 <span class="math inline">⟨<em>Ĉ</em>⟩ = 0</span> 时，<span class="math inline"><em>Δ</em><em>A</em><em>Δ</em><em>B</em> = 0</span>。</p></li><li><p>对于两个不对易算符：位置 <span class="math inline"><em>x</em></span> 和动量 <span class="math inline"><em>p̂</em><sub><em>x</em></sub></span>，<span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>p</em><sub><em>x</em></sub></span>的不确定程度用它们的方均偏差表示，为 <span class="math display">$$  \begin{aligned}  &amp;(\Delta x)^{2}=\overline{(x-\langlex\rangle)^{2}}=\overline{x^{2}-2 x\langle x\rangle+\langlex\rangle^{2}}=\overline{x^{2}}-\langle x\rangle^{2}\\  &amp;(\Deltap_{x})^{2}=\overline{\left(\hat{p}_{x}-\left\langle\hat{p}_{x}\right\rangle\right)^{2}}=\overline{\hat{p}_{x}^{2}}-\left\langle\hat{p}_{x}\right\rangle^{2}  \end{aligned}  $$</span></p></li></ul><h2 id="态叠加原理">态叠加原理</h2><p>设 <span class="math inline"><em>Ψ</em><sub>1</sub>(<em>x</em>, <em>t</em>)</span>是描述粒子运动的一个态，<span class="math inline"><em>Ψ</em><sub>2</sub>(<em>x</em>, <em>t</em>)</span>也是描述粒子运动的一个态，则它们的线性叠加 <span class="math display"><em>Ψ</em>(<em>x</em>, <em>t</em>) = <em>c</em><sub>1</sub><em>Ψ</em><sub>1</sub>(<em>x</em>, <em>t</em>) + <em>c</em><sub>2</sub><em>Ψ</em><sub>2</sub>(<em>x</em>, <em>t</em>)</span></p><p>也是描述粒子运动的一个态，这是物质波所满足的态叠加原理。</p><p>叠加原理可以写成 <span class="math inline"><em>n</em></span>个波函数的线性组合 <span class="math display"><em>Ψ</em> = ∑<sub><em>n</em></sub><em>c</em><sub><em>n</em></sub><em>Ψ</em><sub><em>n</em></sub></span></p><p>这导致了量子力学的一个重要概念（也即我们之后解决量子力学问题的一个重要方法）：对于一个指定的量子体系，如果找到了它的完备的基本状态（所有可能的基本状态），例如<span class="math display">{<em>Ψ</em><sub>1</sub>, <em>Ψ</em><sub>2</sub>, ⋯, <em>Ψ</em><sub><em>n</em></sub>}</span></p><p>那么任何状态就都可以由这些基本状态叠加而得到（通过线性组合可以互相求出）。</p><h2 id="波函数坍缩">波函数坍缩</h2><p>若粒子处在叠加态 <span class="math display"><em>Ψ</em> = ∑<sub><em>i</em></sub><em>C</em><sub><em>i</em></sub><em>φ</em><sub><em>i</em></sub></span></p><p>上，其中 <span class="math inline"><em>φ</em><sub><em>i</em></sub></span> 为某算符<span class="math inline"><em>F̂</em></span> 的本征态，对应的本征值为<span class="math inline"><em>λ</em><sub><em>i</em></sub></span>。现在问对力学量<span class="math inline"><em>F</em></span> 进行测量，测量结果如何 <span class="math inline">?</span>这涉及量子力学的另一个假设：测量结果可能出现本征值中的任一个，出现 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 的概率为<span class="math inline">|<em>C</em><sub><em>i</em></sub>|<sup>2</sup></span>。也就是说，测量会对叠加态<span class="math inline"><em>Ψ</em></span> 产生严重干扰，测量会使波函数<span class="math inline"><em>Ψ</em></span> 向本征态 <span class="math inline"><em>φ</em><sub><em>i</em></sub></span>突变，造成波函数塌缩。<span class="math inline"><em>Ψ</em></span>向哪个本征态塌缩完全是随机的、不可逆的、非局域的，但塌缩的概率是确定的，等于<span class="math inline">|<em>C</em><sub><em>i</em></sub>|<sup>2</sup></span>。关于波函数的塌缩目前尚末完全了解。</p><h2 id="薛定谔方程">薛定谔方程</h2><h3 id="自由粒子的薛定谔方程">自由粒子的薛定谔方程</h3><p><span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\Psi(x,t)=-\frac{\hbar^{2}}{2 m} \frac{\partial^{2}}{\partial x^{2}}\Psi(x,t)$$</span></p><p>这就是自由粒子波函数满足的波动方程，可以称为<strong>自由粒子的薛定谔方程</strong>。</p><h3 id="含时薛定谔方程">含时薛定谔方程</h3><p>对非自由粒子（例如势场中的粒子），粒子的能量为 <span class="math display">$$E=\frac{p_{x}^{2}}{2 m}+U(x,t)$$</span></p><p>令能量算符或<strong>哈密顿算符</strong> <span class="math display">$$\widehat{H}=-\frac{\hbar^{2}}{2 m} \frac{\partial^{2}}{\partialx^{2}}+U(x,t)$$</span></p><p>则有 <span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t} \Psi(x,t)=\hat{H} \Psi(x,t)$$</span></p><p>称上式为<strong>含时薛定谔方程</strong>。进一步将一维势场推广到三维势场 <span class="math inline"><em>U</em>(<strong>r</strong>, <em>t</em>)</span>中，三维运动粒子的能量为 <span class="math display">$$E=\frac{p_{x}^{2}+p_{y}^{2}+p_{z}^{2}}{2 m}+U(\boldsymbol{r},t)$$</span></p><p>对应的哈密顿算符取如下形式 <span class="math display">$$\hat{H}=-\frac{\hbar^{2}}{2 m}\left(\frac{\partial^{2}}{\partialx^{2}}+\frac{\partial^{2}}{\partial y^{2}}+\frac{\partial^{2}}{\partialz^{2}}\right)+U(\boldsymbol{r},t)=-\frac{\hbar^{2}}{2 m}\nabla^{2}+U(\boldsymbol{r},t)$$</span></p><p>式中 <span class="math inline">$\boldsymbol{\nabla}=\frac{\partial}{\partial x}\boldsymbol{i}+\frac{\partial}{\partial y} j+\frac{\partial}{\partial z}\boldsymbol{k}$</span>。最后得到三维势场中运动粒子的含时薛定谔方程为<span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\Psi(\boldsymbol{r},t)=\hat{H} \Psi(\boldsymbol{r},t)$$</span></p><h3 id="定态薛定谔方程">定态薛定谔方程</h3><p>一般情况下势函数是时间和坐标的函数，若微观粒子处在稳定的势场中，则势能函数与时间无关，称这类问题为定态问题。在定态问题中，哈密顿算符也与时间无关<span class="math display">$$\widehat{H}=-\frac{\hbar^{2}}{2 m} \nabla^{2}+U(r)$$</span></p><p>含时的薛定谔方程可用分离变量法求解，将波函数 <span class="math inline"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>分离为坐标函数和时间函数两个因子的乘积，即 <span class="math display"><em>Ψ</em>(<strong>r</strong>, <em>t</em>) ≡ <em>Φ</em>(<strong>r</strong>)<em>T</em>(<em>t</em>)</span></p><p>代入薛定谔方程中 <span class="math display">$$\mathrm{i} \hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t}\Phi(\boldsymbol{r})=[\hat{H} \Phi(\boldsymbol{r})] T(t)$$</span></p><p>两边同时除以 <span class="math inline"><em>T</em>(<em>t</em>)<em>Φ</em>(<strong>r</strong>)</span>，得到<span class="math display">$$\mathrm{i} \hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t}\frac{1}{T(t)}=\frac{1}{\Phi(\boldsymbol{r})} \hat{H}\Phi(\boldsymbol{r})$$</span></p><p>在上式中，等式左边只含变量 <span class="math inline"><em>t</em></span>，右边只含变量 <span class="math inline"><strong>r</strong></span>，若该式对任意 <span class="math inline">(<em>t</em>, <strong>r</strong>)</span>成立，等式左右两边只能是与时间和坐标均无关的常数，设该常数为 <span class="math inline"><em>E</em></span>，则有 <span class="math display">$$\begin{aligned}&amp;\mathrm{i} \hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t}=E T(t) \\&amp;\hat{H} \Phi(\boldsymbol{r})=E \Phi(\boldsymbol{r})\end{aligned}$$</span></p><p>第一个方程是关于变量为 <span class="math inline"><em>t</em></span>的微分方程，其解为 <span class="math display">$$T(t) \propto \mathrm{e}^{-\frac{i}{\hbar} E t}$$</span></p><p>是时间的振动函数。<br>第二个方程变为如下形式 <span class="math display">$$\left[-\frac{\hbar^{2}}{2 m} \nabla^{2}+U(x,y,z)\right] \Phi(x,y,z)=E\Phi(x,y,z)$$</span></p><p>是关于坐标 <span class="math inline">(<em>x</em>, <em>y</em>, <em>z</em>)</span>的二阶微分方程，称为<strong>定态薛定谔方程</strong>，又称为能量算符的本征方程。其解 <span class="math inline"><em>Φ</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>与粒子所处的外力场 <span class="math inline"><em>U</em></span>和边界条件有关。若求得该方程的解，则可将波函数表示为两部分的乘积： <span class="math display">$$\Psi(\boldsymbol{r},t)=\Phi(\boldsymbol{r}) \mathrm{e}^{-\frac{i}{\hbar}E t}$$</span></p><p>粒子概率密度 <span class="math display">$$\rho(\boldsymbol{r},t)=|\Psi(\boldsymbol{r},t)|^{2}=\left|\Phi(\boldsymbol{r})\mathrm{e}^{-\frac{i}{k} E t}\right|^{2}=|\Phi(\boldsymbol{r})|^{2}$$</span></p><p>与时间无关，只由定态波函数确定。可见定态问题最后归结为求解定态薛定谔方程。</p><h2 id="概率流密度">概率流密度</h2><p>如果粒子没有产生和湮灭现象，在随着时间演化的过程中，粒子数目保持不变，在全空间中找到它的概率之和与时间无关。</p><p>定义<strong>概率流密度</strong> <span class="math display">$$j=-\frac{\mathrm{i} \hbar}{2 m}\left(\Psi^{*} \nabla \Psi-\Psi \nabla\Psi^{*}\right)$$</span></p><p>则有 <span class="math display">$$\frac{\partial \rho}{\partial t}+\nabla \cdot \boldsymbol{j}=0$$</span></p><p>平面波波函数形式为 <span class="math display"><em>A</em><em>e</em><sup><em>i</em><em>k</em><em>x</em></sup></span></p><p>则其概率流密度为 <span class="math display">$$|A|^2\frac{\hbar k}{m}$$</span></p><p>透射系数 = 透射波的概率流密度/入射波的概率流密度； 反射系数 =反射波的概率流密度/入射波的概率流密度</p><h1 id="量子力学应用">量子力学应用</h1><h2 id="一维定态问题">一维定态问题</h2><h3 id="一维无限深方势阱">一维无限深方势阱</h3><p>金属中的电子由于金属表面势能（势垒）的束缚，被限制在一个有限的空间范围内运动。如果金属表面势垒很高，可以将金属表面看作一刚性盒子的壁。若只考虑一维运动，金属就是一维的刚性盒子，其势能函数可简化为<span class="math display">$$U(x)=\left\{\begin{array}{ll}0,&amp; 0 \leqslant x \leqslant L \\\infty,&amp; x&lt;0,x&gt;L\end{array}\right.$$</span></p><p>称为一维无限深方势阱。 一维无限深方势阻中运动的粒子的哈密顿算符为<span class="math display">$$\hat{H}=\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}},&amp; 0\leqslant x \leqslant L \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}+\infty,&amp;x&lt;0,x&gt;L\end{array}\right.$$</span></p><p>在势阱内，定态薛定谔方程 <span class="math display">$$-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{i}}(x)=E \Phi_{\mathrm{i}}(x)$$</span></p><p>令 <span class="math display">$$k^{2}=\frac{2 m E}{\hbar^{2}}$$</span></p><p>得 <span class="math display">$$\frac{\mathrm{d}^{2} \Phi_{\mathrm{i}}}{\mathrm{d} x^{2}}+k^{2}\Phi_{\mathrm{i}}=0$$</span></p><p>该方程的解为 <span class="math display"><em>Φ</em><sub>i</sub>(<em>x</em>) = <em>C</em>sin (<em>k</em><em>x</em> + <em>δ</em>)</span></p><p>待定常数 <span class="math inline"><em>C</em></span> 和 <span class="math inline"><em>δ</em></span> 由波函数的自然条件确定。<br>在势阱外， <span class="math display"><em>Φ</em><sub>e</sub>(<em>x</em>) = 0</span></p><p>利用波函数的连续性条件，阱内波函数在阱壁上也应为零，即 <span class="math display">$$\begin{array}{c} \Phi_{\mathrm{i}}(0)=\Phi_{\mathrm{e}}(0)=0 \\\Phi_{\mathrm{i}}(L)=\Phi_{\mathrm{e}}(L)=0 \end{array}$$</span></p><p>得：<span class="math inline"><em>δ</em> = 0</span>，<span class="math inline">$k=\frac{n \pi}{L}$</span>，<span class="math inline"><em>C</em></span> 由归一化条件确定。 解得波函数<span class="math display">$$\Phi_{n}(x)=\left\{\begin{array}{ll}\sqrt{\frac{2}{L}} \sin \frac{n \pi}{L} x,&amp; 0 \leqslant x \leqslantL \\0,&amp; 0&gt;x,x&gt;L \end{array}\right.$$</span></p><p>粒子的能量本征值为 <span class="math display">$$E_{n}=\frac{k^{2} \hbar^{2}}{2 m}=n^{2} E_{1}$$</span></p><p>式中 <span class="math inline">$E_{1}=\frac{\pi^{2} \hbar^{2}}{2 mL^{2}}$</span>，势阱中粒子能量取分立值，能量是量子化的，不同能量对应不同的能级，能量间隔为<span class="math display">$$\Delta E_{n}=E_{n+1}-E_{n}=(2 n+1) E_{1}=(2 n+1) \frac{\pi^{2}\hbar^{2}}{2 m L^{2}}$$</span></p><p>能级间隔与粒子的质量有关，微观粒子的质量越小，粒子的能级间隔越大，量子效应越明显。当粒子质量变大，粒子的能级间隔越小，对于宏观粒子，能级间隔趋于零，粒子的能量可以连续取值，量子效应消失。另一方面能级间隔与势阱宽度有关，势阱宽度越小，能级间隔越大，量子效应明显；势阱宽度越大，能级间隔越小，如果<span class="math inline"><em>L</em> → ∞</span>，能级间隔趋于零，粒子的能量可以连续取值，即自由粒子的能量可以取任意值。</p><p>束缚在势阱中的粒子，能量的最小值不能任意取值，有一个下限，称其为最低能量或称<strong>零点能</strong> 。对方势阱中的粒子，零点能为 <span class="math inline"><em>n</em> = 1</span> 时对应的能量为 <span class="math display">$$E_{1} = \frac{\pi^{2} \hbar^{2}}{2 m L^{2}} = \frac{h^{2}}{8 m L^{2}}$$</span></p><p>可见零点能不为零，这是粒子波动性的必然结果，是另一个量子效应。<br>利用能量动量关系将势阱中粒子的动量表示为 <span class="math display">$$p_{n}= \pm \sqrt{2 m E_{n}}= \pm n \frac{\pi \hbar}{L} = \pm n\frac{h}{2 L}$$</span></p><p>再利用德布罗意关系可将粒子的波长表示为 <span class="math display">$$\lambda_{n}=\frac{h}{\left|p_{n}\right|}=\frac{2 L}{n}$$</span></p><p>上式也可写成 <span class="math inline">$L=n\frac{\lambda_{n}}{2}$</span>，势阱宽度正好为半波长的整数倍。说明势阱中粒子的每一个能态<span class="math inline">(<em>n</em></span> 确定 <span class="math inline">)</span>对应的波函数为一个特定波长的驻波。将波函数的时间振荡因子与定态波函数相乘，得到粒子在阱内的波函数<span class="math display">$$\begin{aligned}\Psi_{n}(x,t) &amp; =\Phi_{n}(x) \mathrm{e}^{-\frac{i}{\hbar} E_{n} t}\\&amp; =\frac{1}{2 \mathrm{i}}\sqrt{\frac{2}{L}}\left[\mathrm{e}^{-\frac{i}{\hbar}\left(E_{n} t-p_{n}x\right)}-\mathrm{e}^{-\frac{i}{\hbar}\left(E_{n} t+p_{n}x\right)}\right] \\&amp; =C_{1} \mathrm{e}^{-\frac{i}{\hbar}\left(E_{n} t-p_{n}x\right)}+C_{2} \mathrm{e}^{-\frac{i}{\hbar}\left(E_{n} t+p_{n}x\right)}\end{aligned}$$</span></p><p>泡利根据上式认为，方势阱中粒子波函数为 <strong>两列平面波</strong>的叠加，这两列波的 <strong>频率相同</strong> 、<strong>波长相同</strong>，只是 <strong>传播方向相反</strong> ，叠加后形成 <strong>驻波</strong>，而且在阱壁处为 <strong>波节</strong> 。</p><h3 id="一维有限深方势阱">一维有限深方势阱</h3><p>一维有限深方势阱是指粒子被限制在一个有限深度的势阱中。势阱的势能函数为<span class="math display">$$U(x)=\left\{\begin{array}{ll}0,&amp; 0 \leqslant |x| \leqslant a \\U_{0},&amp; |x|&gt;a\end{array}\right.$$</span></p><p>粒子的哈密顿算符为 <span class="math display">$$\hat{H}=\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}},&amp; 0\leqslant |x| \leqslant a \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}+U_{0},&amp;|x|&gt;a\end{array}\right.$$</span></p><p>定态薛定谔方程为 <span class="math display">$$\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{i}}(x)=E \Phi_{\mathrm{i}}(x), &amp; 0 \leqslant |x|\leqslant a \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{e}}(x)+U_{0} \Phi_{\mathrm{e}}(x)=E \Phi_{\mathrm{e}}(x),&amp; |x|&gt;a\end{array}\right.$$</span></p><p>讨论 <span class="math inline">0 &lt; <em>E</em> &lt; <em>U</em><sub>0</sub></span>的情况，令 <span class="math display">$$k^{2}=\frac{2 m E}{\hbar^{2}}, \quad k'^{2}=\frac{2m(U_{0}-E)}{\hbar^{2}}$$</span></p><p>得到 <span class="math display">$$\left\{\begin{array}{ll}\frac{\mathrm{d}^{2} \Phi_{\mathrm{i}}}{\mathrm{d}x^{2}}+k^{2} \Phi_{\mathrm{i}}=0, &amp; 0 \leqslant x \leqslant a \\\frac{\mathrm{d}^{2} \Phi_{\mathrm{e}}}{\mathrm{d} x^{2}}-k'^{2}\Phi_{\mathrm{e}}=0, &amp; |x|&gt;a\end{array}\right.$$</span></p><p>该方程的解为 <span class="math display"><em>Φ</em><sub>i</sub>(<em>x</em>) = <em>C</em>sin (<em>k</em><em>x</em> + <em>δ</em>),  <em>Φ</em><sub>e</sub>(<em>x</em>) = <em>A</em><em>e</em><sup><em>k</em><sup>′</sup><em>x</em></sup> + <em>B</em><em>e</em><sup>−<em>k</em><sup>′</sup><em>x</em></sup></span></p><p>因为波函数在 <span class="math inline"><em>x</em> → ±∞</span>时应趋于零，所以 <span class="math inline"><em>x</em> &lt; 0</span> 时取<span class="math inline"><em>B</em> = 0</span>，<span class="math inline"><em>x</em> &gt; <em>a</em></span> 时取 <span class="math inline"><em>A</em> = 0</span>。因此波函数化为 <span class="math display">$$\Phi(x)=\left\{\begin{array}{ll}A e^{k' x}, &amp; x&lt; -a \\C \sin (k x+\delta), &amp; 0 \leqslant |x| \leqslant a \\B e^{-k' x}, &amp; x&gt;a \\\end{array}\right.$$</span></p><p>利用波函数的连续性条件，阱内波函数及一阶导数在阱壁处连续，则 <span class="math display">$$\begin{aligned}\Phi_{\mathrm{i}}(-a) &amp; =\Phi_{\mathrm{e}}(-a) \\\Phi_{\mathrm{i}}(a) &amp; =\Phi_{\mathrm{e}}(a) \\\frac{\mathrm{d} \Phi_{\mathrm{i}}}{\mathrm{d} x}\bigg|_{x=-a} &amp;=\frac{\mathrm{d} \Phi_{\mathrm{e}}}{\mathrm{d} x}\bigg|_{x=-a} \\\frac{\mathrm{d} \Phi_{\mathrm{i}}}{\mathrm{d} x}\bigg|_{x=a} &amp;=\frac{\mathrm{d} \Phi_{\mathrm{e}}}{\mathrm{d} x}\bigg|_{x=a}\end{aligned}$$</span></p><p>将波函数代入上式，得到 <span class="math display">$$\begin{aligned}&amp; A e^{-k' a}=C \sin (-k a+\delta) \\&amp; C \sin (k a+\delta)=B e^{-k' a} \\&amp; -A k' e^{-k' a}=C k \cos (-k a+\delta) \\&amp; C k \cos (k a+\delta)=-B k' e^{-k' a}\end{aligned}$$</span></p><p>则有 <span class="math display">$$\begin{aligned}&amp; k \cot (k a+\delta)=-k' \\&amp; k \cot (-k a+\delta)=k' \\\end{aligned}$$</span></p><p>则 <span class="math display">cot (<em>k</em><em>a</em> + <em>δ</em>) = −cot (−<em>k</em><em>a</em> + <em>δ</em>)</span></p><p>因此 <span class="math inline"><em>δ</em></span> 有两组解 <span class="math display">$$\delta= \left\{\begin{array}{l}n \pi\\(n + \frac{1}{2}) \pi\end{array}\right., \quad n=0,\pm 1,\pm 2,\cdots$$</span></p><p>不妨取 <span class="math inline"><em>n</em> = 0</span>，则<span class="math inline">$\delta=0 或 \frac{\pi}{2}$</span> 当 <span class="math inline"><em>δ</em> = 0</span> 时，代入上面四条等式得到 <span class="math inline"><em>A</em> = −<em>B</em></span>，波函数为奇宇称<span class="math display">$$\Phi(x)=\left\{\begin{array}{ll}A e^{k' x}, &amp; x&lt; -a \\C \sin (k x), &amp; 0 \leqslant |x| \leqslant a \\-A e^{-k' x}, &amp; x&gt;a\end{array}\right.$$</span></p><p>当 <span class="math inline">$\delta=\frac{\pi}{2}$</span>时，代入上面四条等式得到 <span class="math inline"><em>A</em> = <em>B</em></span>，波函数为偶宇称 <span class="math display">$$\Phi(x)=\left\{\begin{array}{ll}A e^{k' x}, &amp; x&lt; -a \\C \cos (k x), &amp; 0 \leqslant |x| \leqslant a \\A e^{-k' x}, &amp; x&gt;a\end{array}\right.$$</span></p><p>常数 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>C</em></span> 由归一化条件和连接条件决定。</p><p><strong>奇宇称</strong>下，<span class="math inline"><em>δ</em> = 0</span>，此时 <span class="math inline"><em>k</em>cot (<em>k</em><em>a</em>) = −<em>k</em><sup>′</sup></span>，又有<span class="math inline">$k^{2} + k'^{2} = \frac{2 m E}{\hbar^{2}} +\frac{2 m (U_{0} - E)}{\hbar^{2}} = \frac{2 mU_{0}}{\hbar^{2}}$</span>，因此令 <span class="math display">$$\begin{aligned}&amp;u=ka, \quad v=k'a&gt;0 \\&amp;u\cot u=-v \\&amp;u^{2}+v^{2}=\frac{2 m U_{0} a^{2}}{\hbar^{2}}\end{aligned}$$</span></p><p>作图求解得：当 <span class="math inline">$\frac{2 m U_{0}a^{2}}{\hbar^{2}} \geqslant \frac{\pi^2}{4}$</span>时，才有第一奇宇称的束缚态存在。</p><p><strong>偶宇称</strong>下，<span class="math inline">$\delta =\frac{\pi}{2}$</span>，此时 <span class="math inline">$k \cot (k a +\frac{\pi}{2})=k \tan(k a)=k'$</span>，又有 <span class="math inline">$k^{2} + k'^{2} = \frac{2 m E}{\hbar^{2}} + \frac{2m (U_{0} - E)}{\hbar^{2}} = \frac{2 m U_{0}}{\hbar^{2}}$</span>，因此令<span class="math display">$$\begin{aligned}&amp;u=ka, \quad v=k'a&gt;0 \\&amp;u\tan u=v \\&amp;u^{2}+v^{2}=\frac{2 m U_{0} a^{2}}{\hbar^{2}}\end{aligned}$$</span></p><p>作图求解得：无论 <span class="math inline">$\frac{2 m U_{0}a^{2}}{\hbar^{2}}$</span>的大小，均有一个偶宇称的束缚态（基态）存在。</p><p><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="一维方势垒和隧道效应">一维方势垒和隧道效应</h3><p>一维方势垒的势能函数为 <span class="math display">$$U(x)=\left\{\begin{array}{ll}U_{0},&amp; 0 \leqslant x \leqslant a \\0,&amp; x&lt;0,x&gt;a\end{array}\right.$$</span> 假设粒子的能量 <span class="math inline"><em>E</em> &lt; <em>U</em><sub>0</sub></span>，则粒子的哈密顿算符为<span class="math display">$$\hat{H}=\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}},&amp;x&lt;0,x&gt;a \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}+U_{0},&amp; 0\leqslant x \leqslant a\end{array}\right.$$</span></p><p>定态薛定谔方程为 <span class="math display">$$\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{i}}(x)=E \Phi_{\mathrm{i}}(x), &amp; x&lt;0,x&gt;a \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{e}}(x)+U_{0} \Phi_{\mathrm{e}}(x)=E \Phi_{\mathrm{e}}(x),&amp; 0 \leqslant x \leqslant a\end{array}\right.$$</span></p><p>令 <span class="math display">$$k^{2}=\frac{2 m E}{\hbar^{2}}, \quad k'^{2}=\frac{2m(U_{0}-E)}{\hbar^{2}}$$</span></p><p>得到 <span class="math display">$$\left\{\begin{array}{ll}\frac{\mathrm{d}^{2} \Phi_{\mathrm{i}}}{\mathrm{d}x^{2}}+k^{2} \Phi_{\mathrm{i}}=0, &amp; x&lt;0,x&gt;a \\\frac{\mathrm{d}^{2} \Phi_{\mathrm{e}}}{\mathrm{d} x^{2}}-k'^{2}\Phi_{\mathrm{e}}=0, &amp; 0 \leqslant x \leqslant a\end{array}\right.$$</span></p><p>该方程的解为 <span class="math display">$$\Psi(x)=\left\{\begin{array}{ll}A e^{ikx}+ A' e^{-ikx}, &amp; x&lt;0 \\B e^{k'x}+ B' e^{-k'x}, &amp; 0 \leqslant x \leqslant a \\C e^{ikx}+ C' e^{-ikx}, &amp; x&gt;a\end{array}\right.$$</span></p><p>其中，<span class="math inline"><em>e</em><sup><em>i</em><em>k</em><em>x</em></sup></span>和 <span class="math inline"><em>e</em><sup>−<em>i</em><em>k</em><em>x</em></sup></span>分别表示向右和向左传播的平面波，<span class="math inline"><em>e</em><sup><em>k</em><sup>′</sup><em>x</em></sup></span>和 <span class="math inline"><em>e</em><sup>−<em>k</em><sup>′</sup><em>x</em></sup></span>分别表示向右和向左衰减的指数波。</p><p>从物理条件考虑，<span class="math inline"><em>C</em><sup>′</sup> = 0</span>，再由波函数和一阶导数的连续性条件，得到<span class="math display">$$\begin{aligned}&amp; \Psi_1(0)=A + A' = B + B'= \Psi_2(0)\\&amp; \Psi_1'(0)=ik(A - A') = k' (B - B') = \Psi_2'(0)\\&amp; \Psi_2(a)=B e^{k'a} + B' e^{-k'a} = C e^{ika} = \Psi_3(a)\\&amp; \Psi_2'(a)=k' (B e^{k'a} - B' e^{-k'a}) = ik C e^{ika} =\Psi_3'(a)\end{aligned}$$</span></p><p>解得反射系数 <span class="math display">$$R = \left| \frac{A'}{A} \right|^2 = \frac{(k^2+k'^2)^2\sinh^2(k'a)}{(k^2+k'^2)^2 \sinh^2(k'a) + 4 k^2 k'^2}$$</span></p><p>透射系数 <span class="math display">$$T = \left| \frac{C}{A} \right|^2 = \frac{4 k^2 k'^2}{(k^2+k'^2)^2\sinh^2(k'a) + 4 k^2 k'^2}$$</span></p><p>势垒 <span class="math inline"><em>U</em><sub>0</sub></span>越高，宽度 <span class="math inline"><em>a</em></span>越大，粒子穿透的概率越小，反射系数 <span class="math inline"><em>R</em></span> 越大，透射系数 <span class="math inline"><em>T</em></span>越小，但总有一定几率穿透，这一现象称为<strong>量子隧道效应</strong>。</p><p>透射系数 <span class="math inline"><em>T</em></span> 和反射系数 <span class="math inline"><em>R</em></span> 满足 <span class="math display"><em>R</em> + <em>T</em> = 1</span></p><p>且透射系数 <span class="math inline"><em>T</em></span> 对势垒的宽度<span class="math inline"><em>a</em></span> 和粒子质量 <span class="math inline"><em>m</em></span> 的变化很敏感。</p><p>当 <span class="math inline"><em>E</em> &gt; <em>U</em><sub>0</sub></span>时，透射系数表示为 <span class="math display">$$T = \frac{4 k^2 k'^2}{(k^2-k'^2)^2 \sin^2(k'a) + 4 k^2 k'^2} = \frac{4 E(E-U_0)}{U_0^2 \sin^2(k'a) + 4 E (E-U_0)}$$</span></p><h2 id="谐振子">谐振子</h2><h3 id="定义-1">定义</h3><p>一般而言，任何一个体系在稳定平衡点附近都可以近似地用线性谐振子来表示。谐振子的势能可以表示为<span class="math display">$$V=\frac{1}{2} \mu \omega^{2} x^{2}$$</span></p><p>式中，<span class="math inline"><em>ω</em></span> 是常量；<span class="math inline"><em>μ</em></span>是谐振子的质量。这种体系为线性振子。在经典力学中，线性振子所做的运动是简谐振动。振子满足运动方程<span class="math inline"><em>x</em> = <em>A</em>cos (<em>ω</em><em>t</em> + <em>ϕ</em>)</span>，<span class="math inline"><em>A</em></span> 是振幅，<span class="math inline"><em>ϕ</em></span>是初相位，谐振子能量与振幅的平方成正比。量子理论的结果与经典力学的结果有着根本性的差异。我们用量子力学来解线性谐振子问题，求出能量和波函数。</p><h3 id="厄密方程">厄密方程</h3><p>选取适当的坐标系，则体系的薛定谔方程为 <span class="math display">$$\left(-\frac{\hbar^{2}}{2 \mu} \frac{\mathrm{d}^{2}}{\mathrm{~d}x^{2}}+\frac{1}{2} \mu \omega^{2} x^{2}\right) \psi(x)=E \psi(x)$$</span></p><p>引入无量纲参数 <span class="math inline"><em>ξ</em></span> 代替 <span class="math inline"><em>x</em></span>，即 <span class="math display">$$\xi=\alpha x,\alpha=\sqrt{\frac{\mu \omega}{\hbar}}$$</span></p><p>令 <span class="math inline">$\lambda=\frac{E}{\frac{1}{2} \hbar\omega}$</span>，把薛定谔方程改写为 <span class="math display">$$\frac{\mathrm{d}^{2}}{\mathrm{~d} \xi^{2}}\psi(\xi)+\left(\lambda-\xi^{2}\right) \psi(\xi)=0$$</span></p><p>首先求出 <span class="math inline"><em>ξ</em> → ±∞</span>时的渐进行为。当 <span class="math inline"><em>ξ</em></span>很大时，上式的解应接近 <span class="math display">$$\frac{\mathrm{d}^{2}}{\mathrm{~d} \xi^{2}} \psi(\xi)-\xi^{2} \psi(\xi)=0$$</span></p><p>其解为 <span class="math display">$$\psi(\xi) \sim \mathrm{e}^{ \pm \frac{1}{2} \xi^{2}}$$</span></p><p>满足物理边界条件的解为 <span class="math display">$$\psi(\xi) \sim \mathrm{e}^{-\frac{1}{2} \xi^{2}}$$</span></p><p>因此设 <span class="math inline">$\psi(\xi)=\mathrm{e}^{-\frac{1}{2}\xi^{2}} u(\xi)$</span>，代入式 <span class="math inline">(2 − 56)</span>，得到 <span class="math inline"><em>u</em>(<em>ξ</em>)</span> 满足方程 <span class="math display">$$\frac{\mathrm{d}^{2} u}{\mathrm{~d} \xi^{2}}-2 \xi \frac{\mathrm{d}u}{\mathrm{~d} \xi}+(\lambda-1) u=0$$</span></p><p>上式是厄密方程。</p><h3 id="方程的解">方程的解</h3><p>可采用幂级数展开求解 <span class="math display">$$\begin{aligned}u(\xi)&amp;=\sum_{k=0}^{\infty} c_{k} \xi^{k} \\u^{\prime}(\xi)&amp;=\sum_{k} c_{k} k \xi^{k-1} \\u^{\prime \prime}(\xi)&amp;=\sum_{k} c_{k} k(k-1) \xi^{k-2}\end{aligned}$$</span></p><p>所以得到 <span class="math display">$$\sum_{k=0}^{\infty} c_{k} k(k-1) \xi^{k-2}-2 \sum_{k} c_{k}k\xi^{k}+(\lambda-1) \sum_{k} c_{k} \xi^{k}=0$$</span></p><p>比较 <span class="math inline"><em>ξ</em><sup><em>j</em></sup></span>的系数 <span class="math display"><em>c</em><sub><em>j</em> + 2</sub>(<em>j</em> + 2)(<em>j</em> + 1) − 2<em>c</em><sub><em>j</em></sub><em>j</em> + (<em>λ</em> − 1)<em>c</em><sub><em>j</em></sub> = 0</span></p><p>求得 <span class="math display">$$c_{j+2}=\frac{2 j-(\lambda-1)}{(j+2)(j+1)} c_{j}$$</span></p><p>即系数递推关系式。厄密方程的解或者是偶次幂，或者是奇次幂。这两个解在<span class="math inline"><em>ξ</em></span>取有限值时都收敛。所有偶次幂系数都可以 <span class="math inline"><em>c</em><sub>0</sub></span>表示，所有奇次幂系数都可以 <span class="math inline"><em>c</em><sub>1</sub></span>表示。两个线性无关的解分别表示为 <span class="math display">$$\begin{aligned}u_{1}(\xi)&amp;=c_{0}+c_{2} \xi^{2}+c_{4} \xi^{4}+\cdots \\u_{2}(\xi)&amp;=c_{1} \xi+c_{3} \xi^{3}+c_{5} \xi^{5}+\cdots\end{aligned}$$</span></p><p>这两个解在 <span class="math inline"><em>ξ</em> → ∞</span>时取无限项时都发散，因此必须截断，所以当 <span class="math inline"><em>λ</em> − 1 = 2<em>n</em></span> 时，系数 <span class="math inline"><em>c</em><sub><em>n</em> + 2</sub>, <em>c</em><sub><em>n</em> + 4</sub>, <em>c</em><sub><em>n</em> + 6</sub>, ⋯</span>都为零。</p><h3 id="能量本征值">能量本征值</h3><p>上述要求给出的能量有一定限制，即谐振子的能量本征值为 <span class="math display">$$E_{n}=\frac{\lambda}{2} \hbar \omega=\left(n+\frac{1}{2}\right) \hbar\omega = \left(n+\frac{1}{2}\right) h \nu$$</span></p><p>可以看到，谐振子的能级是量子化且均匀分布的，相邻能级间隔是 <span class="math inline">ℏ<em>ω</em></span>。对应的能量本征函数为 <span class="math display">$$\psi_{n}(x)=N_{n} H_{n}(\xi) \mathrm{e}^{-\frac{1}{2} \xi^{2}}$$</span></p><p>式中，<span class="math inline"><em>N</em><sub><em>n</em></sub></span>为归一化常数；<span class="math inline"><em>H</em><sub><em>n</em></sub>(<em>ξ</em>)</span>为厄密多项式。</p><h3 id="波函数">波函数</h3><p>谐振子波函数表述为 <span class="math display">$$\psi_{n}(x)=\left(\frac{\mu \omega}{\pi \hbar}\right)^{\frac{1}{4}}\frac{1}{\sqrt{2^{n} n !}} H_{n}(\sqrt{\frac{\mu \omega}{\hbar}} x)\mathrm{e}^{-\frac{\mu \omega}{2 \hbar} x^{2}}$$</span></p><p>其中 <span class="math display">$$H_{n}(\xi)=(-1)^{n} \mathrm{e}^{\xi^{2}}\frac{\mathrm{d}^{n}}{\mathrm{~d} \xi^{n}} \mathrm{e}^{-\xi^{2}}$$</span></p><p>前面几项厄密多项式如下： <span class="math display">$$\begin{array}{l} H_{0}(\xi)=1 \\ H_{1}(\xi)=2 \xi \\ H_{2}(\xi)=4\xi^{2}-2 \\ H_{3}(\xi)=8 \xi^{3}-12 \xi \end{array}$$</span></p><p>三个能量最低能级的波函数如下。</p><ul><li>基态：<span class="math display">$$ \psi_{0}(x)=\left(\frac{\mu\omega}{\pi \hbar}\right)^{\frac{1}{4}} \mathrm{e}^{-\frac{\mu \omega}{2\hbar} x^{2}}$$</span></li><li>第一激发态：<span class="math display">$$\psi_{1}(x)=\left(\frac{\mu \omega}{\pi \hbar}\right)^{\frac{1}{4}}\sqrt{\frac{2 \mu \omega}{\hbar}} x \mathrm{e}^{-\frac{\mu \omega}{2\hbar} x^{2}}$$</span></li><li>第二激发态：<span class="math display">$$\psi_{2}(x)=\left(\frac{\mu \omega}{4 \pi\hbar}\right)^{\frac{1}{4}}\left(\frac{2 \mu \omega}{\hbar}x^{2}-1\right) \mathrm{e}^{-\frac{\mu \omega}{2 \hbar}x^{2}}$$</span></li></ul><h2 id="氢原子">氢原子</h2><h3 id="定义-2">定义</h3><p>氢原子是一个质子（电荷为 <span class="math inline">+<em>e</em></span>）和一个电子（电荷为 <span class="math inline">−<em>e</em></span>）组成的两体系统，二者之间存在库仑相互作用。由于质子的质量<span class="math inline">(<em>M</em>)</span> 大约是电子质量 <span class="math inline"><em>m</em><sub>e</sub></span>的两千倍，作为近似处理，可以建立以质子为坐标原点的坐标系，电子位置用球坐标<span class="math inline">(<em>r</em>, <em>θ</em>, <em>φ</em>)</span>表示。氢原子如同一个电子的陷阱，它把一个电子限定在某一区域。</p><h3 id="薛定谔方程-1">薛定谔方程</h3><p>氢原子中电子的势能为 <span class="math display">$$V(r)=-\frac{Z e^{2}}{4 \pi \varepsilon_{0} r}$$</span></p><p>式中，<span class="math inline"><em>Z</em><em>e</em></span>是原子核的电荷，对于氢原子核，<span class="math inline"><em>Z</em> = 1</span>。设原子核静止，将 <span class="math inline"><em>V</em>(<em>r</em>)</span> 代入定态薛定谔方程，得<span class="math display">$$\hat{H} \psi=\left(-\frac{\hbar^{2}}{2 m} \nabla^{2}-\frac{e^{2}}{4 \pi\varepsilon_{0} r}\right) \psi=E \psi$$</span></p><p>式中，<span class="math inline">∇<sup>2</sup></span>是拉普拉斯算符，<span class="math inline"><em>m</em></span> 是约化质量<span class="math inline"><em>M</em><em>m</em><sub><em>e</em></sub>/(<em>M</em> + <em>m</em><sub><em>e</em></sub>)</span>。由于哈密顿量有球对称性，在球坐标中讨论比较方便，拉普拉斯算符用球坐标表示为<span class="math display">$$\begin{aligned}\nabla^{2} &amp; =\frac{1}{r^{2}} \frac{\partial}{\partial r}\left(r^{2}\frac{\partial}{\partial r}\right)+\frac{1}{r^{2} \sin \theta}\frac{\partial}{\partial \theta}\left(\sin \theta\frac{\partial}{\partial \theta}\right) +\frac{1}{r^{2} \sin \theta}\frac{\partial^{2}}{\partial \varphi^{2}} \\&amp; =\frac{1}{r^{2}} \frac{\partial}{\partial r}\left(r^{2}\frac{\partial}{\partial r}\right)-\frac{L^{2}}{r^{2} \hbar^{2}}\end{aligned}$$</span></p><p>用分离变量法求解 <span class="math display">$$\hat{H}=-\frac{\hbar^{2}}{2 m r^{2}} \frac{\partial}{\partialr}\left(r^{2} \frac{\partial}{\partial r}\right)+\frac{L^{2}}{2 mr^{2}}+V(r)$$</span></p><p>式中，第一项是径向动能算符；第二项是离心势能。容易证明，<span class="math inline">$\hat{H},\hat{\boldsymbol{L}}^{2},\hat{L}_{z}$</span>三者是彼此对易的，所以三者构成力学量完全集，有一套<strong>共同本征函数</strong>。</p><p>在这套本征函数中，能量、角动量、角动量 <span class="math inline"><em>z</em></span> 分量有确定值。而 <span class="math inline"><em>L</em><sup>2</sup></span> 和 <span class="math inline"><em>L</em><sub><em>z</em></sub></span>的本征函数和本征值如下： <span class="math display">$$\begin{aligned}&amp;\hat{\mathbf{L}}^{2} Y_{l m}(\theta,\phi)=l(l+1) \hbar^{2} Y_{lm}(\theta,\phi) \\&amp;\hat{L}_{z} Y_{l m}(\theta,\phi)=m_{l} \hbar Y_{l m}(\theta,\phi)\\&amp;l=0,1,2,\cdots \\&amp;m_{l}=-l,-l+1,\cdots,+l\end{aligned}$$</span></p><p>式中，<span class="math inline"><em>l</em></span> 是角量子数；<span class="math inline"><em>m</em><sub><em>l</em></sub></span>是磁量子数。对一个确定的角量子数 <span class="math inline"><em>l</em></span>，<span class="math inline"><em>m</em><sub><em>l</em></sub></span> 可以取 <span class="math inline">2<em>l</em> + 1</span>个值。这表明角动量在空间取向只有 <span class="math inline">2<em>l</em> + 1</span> 个可能。</p><h3 id="氢原子束缚态能量本征函数">氢原子束缚态能量本征函数</h3><p>所以，氢原子束缚态能量本征函数为 <span class="math display">$$\begin{aligned}&amp;\Psi_{n l m}(r, \theta, \phi)=R_{n l}(r) Y_{l m}(\theta, \phi)\\&amp;n=1,2,3,\cdots \\&amp;l=0,1,2,\cdots,n-1 \\&amp;m_{l}=-l,-l+1,\cdots,0,\cdots,l-1,l\end{aligned}$$</span></p><p>其中，<span class="math inline"><em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)</span>是径向波函数，<span class="math inline"><em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>ϕ</em>)</span>是球谐函数，<span class="math inline"><em>n</em></span>是主量子数，<span class="math inline"><em>l</em></span>是角量子数，<span class="math inline"><em>m</em><sub><em>l</em></sub></span>是磁量子数。</p><p>哈密顿算符 <span class="math inline"><em>Ĥ</em></span> 对应本征函数<span class="math inline"><em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)</span>的本征值为 <span class="math display">$$E_{n}=-\frac{Z^{2} e^{4} m_{e}}{8 \varepsilon_{0}^{2} h^{2}n^{2}}=-\frac{e^{4} m_{e}}{8 \varepsilon_{0}^{2} h^{2}} \frac{1}{n^{2}}= -\frac{13.6 \mathrm{eV}}{n^{2}}, \quad n=1,2,3,\cdots$$</span></p><p>角动量平方算符 <span class="math inline"><em>L̂</em><sup>2</sup></span> 对应本征函数 <span class="math inline"><em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>ϕ</em>)</span>的本征值为 <span class="math display"><em>L</em><sup>2</sup> = <em>l</em>(<em>l</em> + 1)ℏ<sup>2</sup>,  <em>l</em> = 0, 1, 2, ⋯</span></p><p>则角动量大小为 <span class="math display">$$L=\sqrt{l(l+1)} \hbar, \quad l=0,1,2,\cdots$$</span></p><p>角动量的 <span class="math inline"><em>z</em></span> 分量算符 <span class="math inline"><em>L̂</em><sub><em>z</em></sub></span> 对应本征函数<span class="math inline"><em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>ϕ</em>)</span>的本征值为 <span class="math display"><em>L</em><sub><em>z</em></sub> = <em>m</em><sub><em>l</em></sub>ℏ,  <em>m</em><sub><em>l</em></sub> = −<em>l</em>, −<em>l</em> + 1, ⋯, +<em>l</em></span></p><h3 id="电子的概率分布">电子的概率分布</h3><p>按照波函数的物理解释，对于定态，<span class="math inline">|<em>ψ</em><sub><em>n</em><em>l</em><em>m</em></sub>|<sup>2</sup> = |<em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)<em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>ϕ</em>)|<sup>2</sup></span>代表电子的概率密度。概率密度乘以球坐标的体积元 <span class="math display">d<em>τ</em> = <em>r</em><sup>2</sup>sin <em>θ</em>d<em>r</em>&nbsp;d<em>θ</em>d<em>φ</em> = <em>r</em><sup>2</sup>&nbsp;d<em>r</em>&nbsp;d<em>Ω</em></span></p><p>其中 <span class="math inline">d<em>Ω</em> = sin <em>θ</em>d<em>θ</em>d<em>φ</em>, d<em>Ω</em></span>是 <span class="math inline">(<em>θ</em>, <em>φ</em>)</span>方向上的立体角元，则电子出现在体积元 <span class="math inline">d<em>τ</em></span> 中的概率密度 <span class="math display">|<em>ψ</em><sub><em>n</em><em>l</em><em>m</em></sub>|<sup>2</sup> = |<em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)<em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>φ</em>)|<sup>2</sup></span></p><p>且满足归一化条件 <span class="math display">∫|<em>ψ</em><sub><em>n</em><em>l</em><em>m</em></sub>(<em>r</em>, <em>θ</em>, <em>ϕ</em>)|<sup>2</sup><em>r</em><sup>2</sup>&nbsp;d<em>r</em>&nbsp;d<em>Ω</em> = 1</span></p><p>电子沿径向的概率密度为 <span class="math display"><em>P</em><sub><em>n</em><em>l</em></sub>(<em>r</em>) = |<em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)|<sup>2</sup><em>r</em><sup>2</sup></span></p><p>电子沿角向的概率密度为 <span class="math display"><em>P</em><sub><em>l</em><em>m</em><sub><em>l</em></sub></sub>(<em>θ</em>, <em>φ</em>) = |<em>Y</em><sub><em>l</em><em>m</em><sub><em>l</em></sub></sub>(<em>θ</em>, <em>φ</em>)|<sup>2</sup></span></p><p>定义最可几半径为电子沿径向的概率密度最大值对应的 <span class="math inline"><em>r</em></span> 值，即 <span class="math display"><em>r</em><sub><em>n</em><em>l</em></sub> = arg max<sub><em>r</em></sub><em>P</em><sub><em>n</em><em>l</em></sub>(<em>r</em>) = arg max<sub><em>r</em></sub>|<em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)|<sup>2</sup><em>r</em><sup>2</sup></span></p><p>则有 <span class="math inline"><em>r</em><sub>10</sub> = <em>a</em><sub>0</sub></span>，其中<span class="math inline"><em>a</em><sub>0</sub></span> 是玻尔半径。</p><h3 id="电子自旋角动量">电子自旋角动量</h3><p>电子自旋角动量是电子的内禀角动量，与电子的轨道角动量不同。电子自旋角动量的大小为<span class="math display">$$S=\sqrt{s(s+1)} \hbar$$</span></p><p><span class="math inline"><em>z</em></span> 分量为 <span class="math display"><em>S</em><sub><em>z</em></sub> = <em>m</em><sub><em>s</em></sub>ℏ</span></p><p>其中，<span class="math inline"><em>s</em></span> 是自旋量子数，<span class="math inline"><em>m</em><sub><em>s</em></sub></span>是自旋磁量子数，则有 <span class="math inline">2<em>s</em> + 1</span>个可能的自旋状态。对于电子，<span class="math inline">2<em>s</em> + 1 = 2</span>，即 <span class="math inline">$s=\frac{1}{2}$</span>，<span class="math inline"><em>m</em><sub><em>s</em></sub></span> 可以取 <span class="math inline">$\pm \frac{1}{2}$</span>。</p><p>所以有电子自旋角动量的大小 <span class="math display">$$S=\frac{\sqrt{3}}{2} \hbar$$</span></p><p><span class="math inline"><em>z</em></span> 分量大小为 <span class="math display">$$S_{z}=m_{s} \hbar=\pm \frac{1}{2} \hbar$$</span></p><h3 id="泡利不相容原理">泡利不相容原理</h3><ol type="1"><li>费米子和玻色子<ul><li>费米子：自旋量子数为半整数的粒子</li><li>玻色子：自旋量子数为整数的粒子</li></ul></li><li>泡利不相容原理<ul><li>不能有两个电子具有相同的四个量子数 <span class="math inline">(<em>n</em>, <em>l</em>, <em>m</em><sub><em>l</em></sub>, <em>m</em><sub><em>s</em></sub>)</span></li></ul></li><li>玻色凝聚<ul><li>玻色子不受泡利不相容原理的限制，一个单粒子态可以容纳多个玻色子</li></ul></li></ol><h3 id="原子核外电子排布">原子核外电子排布</h3><p>同一主壳层可容纳的电子数为 <span class="math inline">2<em>n</em><sup>2</sup></span>，其中 <span class="math inline"><em>n</em></span> 是主量子数。每个次壳层的电子数为<span class="math inline">2(2<em>l</em> + 1)</span>，其中 <span class="math inline"><em>l</em></span> 是角量子数。 <span class="math display">$$N_n = \sum_{l=0}^{n-1} 2(2l + 1) = 2 [1+3+5+\cdots+(2n-1)] = 2n^2$$</span></p><p>原子核外电子排布遵循以下原则：</p><ol type="1"><li><strong>能量最低原则</strong>：电子总是先填充能量最低的轨道。</li><li><strong>泡利不相容原理</strong>：每个轨道最多只能容纳两个电子，且自旋方向相反。</li><li><strong>洪特规则</strong>：在同一能级的轨道中，电子会尽量单独占据每个轨道，直到所有轨道都被占据后才会成对填充。</li><li><strong>能级顺序</strong>：电子填充的顺序遵循能级从低到高的原则，通常遵循<span class="math inline"><em>n</em> + <em>l</em></span> 规则，即先填充<span class="math inline"><em>n</em> + <em>l</em></span>值小的轨道。</li></ol><h2 id="双态系统">双态系统</h2><h3 id="薛定谔方程矩阵形式">薛定谔方程矩阵形式</h3><p>考虑一个量子系统，它的态空间是二维的，将薛定谔方程表达为矩阵形式，有<span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\left[\begin{array}{l}C_{1}\\C_{2} \end{array}\right]=\left[\begin{array}{ll} H_{11} &amp;H_{12} \\ H_{21} &amp; H_{22} \end{array}\right]\left[\begin{array}{l}C_{1} \\ C_{2} \end{array}\right]$$</span></p><p><strong>哈密顿算符</strong> 用矩阵表示。如果选取<strong>基矢</strong><span class="math inline">|<em>χ</em><sub><em>α</em></sub>⟩(<em>α</em> = ±</span>，即<span class="math inline">|<em>χ</em><sub>+</sub>⟩</span> 和 <span class="math inline">|<em>χ</em><sub>−</sub>⟩)</span>是哈密顿算符的本征矢，则 <span class="math display">$$\begin{aligned}\hat{H}\left|\chi_{+}\right\rangle=E_{1}\left|\chi_{+}\right\rangle \\\hat{H}\left|\chi_{-}\right\rangle=E_{2}\left|\chi_{-}\right\rangle\end{aligned}$$</span></p><p>以此为基的表象是<strong>能量表象</strong>。由于本征矢的正交归一性，有 <span class="math display">$$\begin{array}{c}H_{11}=\left\langle\chi_{+}|\hat{H}|\chi_{+}\right\rangle=E_{1},H_{22}=\left\langle\chi_{-}|\hat{H}|\chi_{-}\right\rangle=E_{2}\\H_{12}=\left\langle\chi_{+}|\hat{H}|\chi_{-}\right\rangle=0,H_{21}=\left\langle\chi_{-}|\hat{H}|\chi_{+}\right\rangle=0\end{array}$$</span></p><p>所以在能量表象中哈密顿矩阵是对角的： <span class="math display">$$\left[\begin{array}{ll} H_{11} &amp; H_{12} \\ H_{21} &amp; H_{22}\end{array}\right]=\left[\begin{array}{cc} E_{1} &amp; 0 \\ 0 &amp;E_{2} \end{array}\right]$$</span></p><p>在能量表象下，哈密顿矩阵是对角的，薛定谔方程有 <span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\left[\begin{array}{l} C_{+}\\ C_{-} \end{array}\right]=\left[\begin{array}{cc} E_{1} &amp; 0 \\ 0&amp; E_{2} \end{array}\right]\left[\begin{array}{l} C_{+} \\ C_{-}\end{array}\right]$$</span></p><p>由此得到 <span class="math display">$$C_{\alpha}(t)=C_{\alpha}(0) \mathrm{e}^{-\frac{i E_{\alpha} t}{h}} \quad\alpha= \pm$$</span></p><p>可见，概率幅的模方是不随时间变化的常量。如果初态是哈密顿矩阵的一个本征态<span class="math inline">|<em>χ</em><sub><em>α</em></sub>⟩</span>，则概率幅是<span class="math inline">$|\psi(t)\rangle=\mathrm{e}^{-i\frac{E_{\alpha}t}{h}}\left|\chi_{\alpha}\right\rangle$</span>，其模方是不变的，系统处于<strong>定态</strong>。</p><p>一般表象下，哈密顿矩阵不是对角化的，<span class="math inline">|<em>u</em><sub>1</sub>⟩</span> 和 <span class="math inline">|<em>u</em><sub>2</sub>⟩</span>不是哈密顿算符本征态，因而不是定态。如果系统初始处于态 <span class="math inline">|<em>u</em><sub>1</sub>⟩</span>，则这个系统有一定概率<span class="math inline"><em>P</em><sub>12</sub></span> 在 <span class="math inline"><em>t</em></span> 时刻处于态 <span class="math inline">|<em>u</em><sub>2</sub>⟩</span>。这是因为 <span class="math inline"><em>H</em><sub>12</sub></span> 和 <span class="math inline"><em>H</em><sub>21</sub></span>引起了两个态之间的跃迁。因此，可以称非对角元为耦合。</p><h3 id="氨分子的双态模型">氨分子的双态模型</h3><p>氨分子中，三个氢原子分别位于正三角形的三个顶点上，而一个氮原子则位于三角形中心偏左方，整个分子呈四面体结构。因此，氨分子内部可能产生振荡，也就是说，氮原子以三角形平面为对称面在两边来回振动。这个体系的势能<span class="math inline"><em>V</em>(<em>x</em>)</span>是氮原子与氢原子所在平面之间距离 <span class="math inline"><em>z</em></span> 的函数。</p><p>设两种结构的量子态分别是 <span class="math inline">|1⟩</span> 和<span class="math inline">|2⟩</span>，它们具有相同的能量，即<span class="math inline"><em>H</em><sub>11</sub> = <em>H</em><sub>22</sub> = <em>E</em><sub>0</sub></span>。由于氮原子穿越氢原子中央而翻转到另一侧，即穿透势垒发生量子隧穿，所以<span class="math inline"><em>H</em><sub>12</sub></span> 和 <span class="math inline"><em>H</em><sub>21</sub></span>不为零。不妨假定它们是负的实数，即 <span class="math inline"><em>H</em><sub>12</sub> = <em>H</em><sub>21</sub> = <em>A</em>(<em>A</em> &lt; 0)</span>，于是得到氨分子双态的薛定谔方程为<span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\left[\begin{array}{l}C_{1}\\ C_{2} \end{array}\right]=\left[\begin{array}{cc} E_{0} &amp; A\\ A &amp; E_{0} \end{array}\right]\left[\begin{array}{l} C_{1} \\ C_{2}\end{array}\right]$$</span></p><p>令 <span class="math inline">$C_{ \pm}=\frac{1}{\sqrt{2}}\left(C_{1}\pm C_{2}\right)$</span>，则上式变成 <span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\left[\begin{array}{l} C_{+}\\ C_{-} \end{array}\right]=\left[\begin{array}{cc} E_{0}+A &amp; 0 \\ 0&amp; E_{0}-A \end{array}\right]\left[\begin{array}{l} C_{+} \\ C_{-}\end{array}\right]$$</span></p><p>由于哈密顿矩阵是对角的，本征值 <span class="math inline"><em>E</em><sub>±</sub> = <em>E</em><sub>0</sub> ± <em>A</em></span>，对应本征矢<span class="math inline">|<em>χ</em><sub>+</sub>⟩</span> 和 <span class="math inline">|<em>χ</em><sub>−</sub>⟩</span> 为 <span class="math display">$$\left|\chi_{ \pm}\right\rangle=\frac{1}{\sqrt{2}}(|1\rangle\pm|2\rangle)$$</span></p><p>上式积分后得到 <span class="math display">$$C_{ \pm}(t)=C_{ \pm}(0) \mathrm{e}^{-\frac{i E_{ \pm} t}{h}}$$</span></p><p>式中，<span class="math inline"><em>C</em><sub>±</sub>(0)</span>是由初始条件决定的积分常量。<br>由 <span class="math inline">$C_{ \pm}=\frac{1}{\sqrt{2}}\left(C_{1} \pmC_{2}\right)$</span> 解得 <span class="math display">$$\begin{aligned}C_{1}(t) &amp;=\frac{1}{\sqrt{2}}\left[C_{+}(t)+C_{-}(t)\right] \\&amp;=\frac{1}{\sqrt{2}}\left[C_{+}(0) \mathrm{e}^{-\mathrm{i}\frac{E_{+} t}{h}}+C_{-}(0) \mathrm{e}^{-i \frac{E_{-} t}{h}}\right] \\C_{2}(t) &amp;=\frac{1}{\sqrt{2}}\left[C_{+}(t)-C_{-}(t)\right] \\&amp;=\frac{1}{\sqrt{2}}\left[C_{+}(0) \mathrm{e}^{-\mathrm{i}\frac{E_{+} t}{h}}-C_{-}(0) \mathrm{e}^{-i \frac{E_{-} t}{h}}\right]\end{aligned}$$</span></p><p>由上面各式可以看出，<span class="math inline"><em>C</em><sub>±</sub></span>是定态的概率幅，其模方不变。如果 <span class="math inline"><em>C</em><sub>−</sub>(0) = 0</span>，氨分子“ <span class="math inline"><em>L</em></span> ”或“ <span class="math inline"><em>R</em></span>”的两个状态具有相同的振幅，则氨分子具有确定的能量 <span class="math inline"><em>E</em><sub>+</sub> = <em>E</em><sub>0</sub> + <em>A</em></span>。如果初始系统处于<span class="math inline">|1⟩</span> 态，即 <span class="math display">$$\begin{aligned}C_{1}(0)&amp;=\frac{1}{\sqrt{2}}\left[C_{+}(0)+C_{-}(0)\right]=1 \\C_{2}(0)&amp;=\frac{1}{\sqrt{2}}\left[C_{+}(0)-C_{-}(0)\right]=0\end{aligned}$$</span></p><p>由此得 <span class="math display">$$C_{+}(0)=C_{-}(0)=\frac{1}{\sqrt{2}}$$</span></p><p>于是本征态 <span class="math display">$$\begin{aligned}C_{1}(t)=\mathrm{e}^{-\frac{E_{0} t}{\hbar}} \cos \frac{A t}{\hbar} \\C_{2}(t)=-\mathrm{ie}^{-\frac{E_{0} t}{\hbar}} \sin \frac{A t}{\hbar}\end{aligned}$$</span></p><p>两振幅随时间做简谐变化。它们的模方是系统分别处于态 <span class="math inline">|1⟩</span> 和 <span class="math inline">|2⟩</span>的概率。由于 <span class="math inline"><em>C</em><sub>1</sub>(<em>t</em>)</span> 和 <span class="math inline"><em>C</em><sub>2</sub>(<em>t</em>)</span>的模方随时间变化，氨分子处于两个状态的概率是时间相关的。 <span class="math display">$$\begin{aligned}P_{1}(t) &amp;=\left|C_{1}(t)\right|^{2}=\cos ^{2} \frac{A t}{\hbar}\\P_{2}(t) &amp;=\left|C_{2}(t)\right|^{2}=\sin ^{2} \frac{A t}{\hbar}\end{aligned}$$</span></p>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 量子力学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息论基础</title>
      <link href="/_posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/_posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>唐俊华老师</em> 2024-2025学年春季学期教学内容进行整理，部分图片来自唐老师的笔记，若有侵权请联系删除。</p></blockquote><h1 id="第一章-绪论">第一章 绪论</h1><h2 id="信息理论研究内容">信息理论研究内容</h2><ul><li>狭义信息论：香农信息论</li><li>一般信息论：香农+维纳</li><li>广义信息论</li></ul><h2 id="信息消息信号">信息、消息、信号</h2><ul><li><strong>信息</strong>：指各个事物运动的状态及状态变化的方式。信息是抽象的意识或知识，它是看不见、摸不到的。当由人脑的思维活动产生的一种想法仍被存储在脑子里时，它就是一种信息。<ul><li>特征：<ol type="1"><li>接收者在收到信息之前，对其内容是未知的，所以信息是新知识、新内容；</li><li>信息是能使认识主体对某一事物的未知性或不确定性减少的有用知识；</li><li>信息可以产生，也可以消失，同时信息可以被携带、存储及处理；</li><li>信息是可以量度的，信息量有多少的差别。</li></ol></li></ul></li><li><strong>消息</strong>：指包含信息的语言、文字和图像等。在通信中，消息是指担负着传送信息任务的单个符号或符号序列。这些符号包括字母、文字、数字和语言等。</li><li><strong>信号</strong>：消息的物理体现，为了在信道上传输消息，就必须把消息加载（调制）到具有某种物理特征的信号上去。信号是信息的载荷子或载体，是物理性的，如电信号、光信号等。</li></ul><h2 id="通信系统模型">通信系统模型</h2><figure><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="通信系统模型"><figcaption aria-hidden="true">通信系统模型</figcaption></figure><h1 id="第二章-信源与信息熵">第二章 信源与信息熵</h1><h2 id="信源的分类及数学模型">2.1 信源的分类及数学模型</h2><figure><img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="信源分类"><figcaption aria-hidden="true">信源分类</figcaption></figure><h3 id="无记忆的单符号">无记忆的单符号</h3><ul><li><strong>离散</strong><ul><li><p>信源输出单个符号的消息，出现的消息数是有限的，且只可能是符号集中的一种</p></li><li><p>各符号出现的概率与信源相互确定</p></li><li><p><strong>数学表示</strong>： <span class="math display">$$  \begin{bmatrix} X \\ P \end{bmatrix} =  \begin{bmatrix} a_1 &amp; a_2 &amp; \cdots &amp; a_n \\ p(a_1) &amp;p(a_2) &amp; \cdots &amp; p(a_n) \end{bmatrix}  $$</span></p><p>其中符号集 <span class="math inline"><em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span>，<span class="math inline"><em>X</em> ∈ <em>A</em></span>。显然有 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>) ≥ 0</span>，<span class="math inline">$\sum_{i = 1}^{n} p(a_i) = 1$</span>。</p></li></ul></li><li><strong>连续</strong><ul><li><p>信源输出单个符号的消息，出现的消息数是无限的</p></li><li><p><strong>数学表示</strong>： <span class="math display">$$  \begin{bmatrix} X \\ P \end{bmatrix} =  \begin{bmatrix} (a,b) \\ p_X(x) \end{bmatrix}  或  \begin{bmatrix} R \\p_X(x) \end{bmatrix}  $$</span></p><p>显然应满足 <span class="math inline"><em>p</em><sub><em>X</em></sub>(<em>x</em>) ≥ 0</span>，<span class="math inline">∫<sub><em>a</em></sub><sup><em>b</em></sup><em>p</em><sub><em>X</em></sub>(<em>x</em>)d<em>x</em> = 1</span>或 <span class="math inline">∫<sub><em>R</em></sub><em>p</em><sub><em>X</em></sub>(<em>x</em>)d<em>x</em> = 1</span>。</p></li></ul></li></ul><h3 id="无记忆的符号序列">无记忆的符号序列</h3><ul><li><p>每次发出一组含2个以上符号的符号序列来代表一个消息</p></li><li><p>需要用随机序列（或随机矢量）<span class="math inline"><strong>X</strong> = (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>l</em></sub>, ⋯, <em>X</em><sub><em>L</em></sub>)</span>来描述信源输出的消息，用联合概率分布来表示信源特性。</p></li><li><p>最简单的符号序列信源是<span class="math inline"><em>L</em></span>为2的情况，此时信源<span class="math inline"><strong>X</strong> = (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>)</span>，其信源的概率空间为：<span class="math display">$$  \begin{bmatrix} \mathbf{X} \\ P \end{bmatrix} =  \begin{bmatrix} a_1,a_1 &amp; a_1,a_2 &amp; \cdots &amp; a_n,a_n \\p(a_1,a_1) &amp; p(a_1,a_2) &amp; \cdots &amp; p(a_n,a_n) \end{bmatrix}\quad  $$</span></p><p>显然有 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>a</em><sub><em>j</em></sub>) ≥ 0</span>，<span class="math inline">$\sum_{i,j = 1}^{n} p(a_i,a_j) =1$</span>。</p></li><li><p><strong><em>无记忆</em></strong></p><ul><li>符号序列的各维相独立（<strong>有放回取球</strong>）</li><li><span class="math inline"><em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>l</em></sub>, ⋯, <em>X</em><sub><em>L</em></sub>) = <em>p</em>(<em>X</em><sub>1</sub>)<em>p</em>(<em>X</em><sub>2</sub>)⋯<em>p</em>(<em>X</em><sub><em>l</em></sub>)⋯<em>p</em>(<em>X</em><sub><em>L</em></sub>)</span></li></ul></li><li><p><strong><em>平稳</em></strong></p><ul><li>信源发出的序列的统计性质与时间的推移无关，是平稳的随机序列。</li><li>强：信源输出序列的各维概率分布都不随时间推移而发生变化</li><li>弱：信源输出序列的均值与起始时刻无关、协方差函数也与起始时刻无关而仅与时间间隔有关</li></ul></li><li><p><strong><em>独立同分布(i.i.d.)</em></strong></p><ul><li>离散、平稳、无记忆、具有相同概率空间</li><li><span class="math inline"><em>p</em>(<em>X</em><sub>1</sub>) = <em>p</em>(<em>X</em><sub>2</sub>) = ⋯ = <em>p</em>(<em>X</em><sub><em>l</em></sub>) = ⋯ = <em>p</em>(<em>X</em><sub><em>L</em></sub>)</span></li><li><span class="math inline">$p(X_1,X_2,\cdots,X_L)=\prod_{l =1}^{L}p(X_l)=[p(X)]^L$</span></li><li>其中 <span class="math inline"><em>X</em> ∈ <em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span>，<span class="math inline"><strong>X</strong></span>有<span class="math inline"><em>n</em><sup><em>L</em></sup></span>种可能性，<span class="math inline">$\sum_{i = 1}^{n^L} p(\mathbf{X}=\mathbf{X_i}) =1$</span>。</li></ul></li></ul><h3 id="有记忆的符号序列">有记忆的符号序列</h3><ul><li>信源在不同时刻发出的符号之间是相互依赖的。（<strong>不放回取球</strong>）<span class="math display">$$  \begin{align*}  p(x_1,x_2,x_3,\cdots,x_L)&amp;=p(x_L\mid x_1,x_2,x_3,\cdots,x_{L -1})p(x_1,x_2,x_3,\cdots,x_{L - 1})\\  &amp;=\cdots\\  &amp;=p(x_1)p(x_2|x_1)p(x_3|x_2,x_1)\cdots p(x_L|x_{L-1},\cdots, x_1)  \end{align*}  $$</span></li><li>表述的复杂度将随着序列长度的增加而增加。</li></ul><h4 id="马尔可夫信源">马尔可夫信源</h4><ul><li><strong>m阶马尔可夫信源</strong><ul><li>当信源的记忆长度为<span class="math inline"><em>m</em> + 1</span>时，该时刻发出的符号与前m个符号有关联性，而与更前面的符号无关<span class="math display">$$  \begin{align*}  p(x_1,x_2,x_3,\cdots,x_L)&amp;=p(x_L\mid x_1,x_2,x_3,\cdots,x_{L -1})p(x_1,x_2,x_3,\cdots,x_{L - 1})\\  &amp;=p(x_L\mid x_{L - m},\cdots,x_{L - 1})p(x_1,x_2,x_3,\cdots,x_{L -1})\\  &amp;=p(x_L\mid x_{L - m},\cdots,x_{L - 1})p(x_{L - 1}\mid x_{L - m -1},\cdots,x_{L - 2})p(x_1,x_2,x_3,\cdots,x_{L - 2})\\  &amp;=\cdots  \end{align*}  $$</span></li><li>若<span class="math inline"><em>m</em> = 1</span>，则称为<strong>一阶马尔可夫信源</strong>，有：<span class="math display"><em>p</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, ⋯, <em>x</em><sub><em>L</em></sub>) = <em>p</em>(<em>x</em><sub><em>L</em></sub> ∣ <em>x</em><sub><em>L</em> − 1</sub>)<em>p</em>(<em>x</em><sub><em>L</em> − 1</sub> ∣ <em>x</em><sub><em>L</em> − 2</sub>)⋯<em>p</em>(<em>x</em><sub>2</sub> ∣ <em>x</em><sub>1</sub>)<em>p</em>(<em>x</em><sub>1</sub>)</span></li><li><strong>齐次马尔可夫信源</strong>：条件概率与时间起点无关</li></ul></li><li><strong>状态<span class="math inline"><em>s</em><sub><em>i</em></sub></span></strong><ul><li>对于 <span class="math inline"><em>m</em></span>阶马尔可夫信源，将该时刻以前出现的 <span class="math inline"><em>m</em></span> 个符号组成的序列定义为状态 <span class="math inline"><em>s</em><sub><em>i</em></sub></span></li><li><span class="math inline"><em>s</em><sub><em>i</em></sub> = (<em>x</em><sub><em>i</em><sub>1</sub></sub>, <em>x</em><sub><em>i</em><sub>2</sub></sub>, ⋯, <em>x</em><sub><em>i</em><sub><em>m</em></sub></sub>)  <em>x</em><sub><em>i</em><sub>1</sub></sub>, <em>x</em><sub><em>i</em><sub>2</sub></sub>, ⋯, <em>x</em><sub><em>i</em><sub><em>m</em></sub></sub> ∈ <em>A</em> = (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>)</span></li><li><span class="math inline"><em>s</em><sub><em>i</em></sub></span>共有 <span class="math inline"><em>Q</em> = <em>n</em><sup><em>m</em></sup></span>种可能取值，即状态集 <span class="math inline"><em>S</em> = {<em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, ⋯, <em>s</em><sub><em>Q</em></sub>}</span></li><li>则有： <span class="math display"><em>p</em>(<em>x</em><sub><em>j</em></sub> ∣ <em>x</em><sub><em>j</em> − <em>m</em></sub>, ⋯, <em>x</em><sub><em>j</em> − 1</sub>) = <em>p</em>(<em>x</em><sub><em>j</em></sub> ∣ <em>s</em><sub><em>i</em></sub>)  <em>i</em> = 1, 2, ⋯, <em>Q</em>, <em>j</em> = 1, 2, ⋯, <em>n</em></span></li></ul></li><li><strong>状态转移概率</strong><ul><li>在时刻 <span class="math inline"><em>m</em></span> 系统处于状态<span class="math inline"><em>s</em><sub><em>i</em></sub></span>（即<span class="math inline"><em>S</em><sub><em>m</em></sub> = <em>s</em><sub><em>i</em></sub></span>）的条件下，经<span class="math inline"><em>n</em> − <em>m</em></span> 步后转移到状态<span class="math inline"><em>s</em><sub><em>j</em></sub></span> （即<span class="math inline"><em>S</em><sub><em>n</em></sub> = <em>s</em><sub><em>j</em></sub></span>）的概率用状态转移概率<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>m</em>, <em>n</em>)</span>表示：</li><li><span class="math display"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>m</em>, <em>n</em>) = <em>P</em>{<em>S</em><sub><em>n</em></sub> = <em>s</em><sub><em>j</em></sub> ∣ <em>S</em><sub><em>m</em></sub> = <em>s</em><sub><em>i</em></sub>} = <em>P</em>{<em>s</em><sub><em>j</em></sub> ∣ <em>s</em><sub><em>i</em></sub>}  <em>s</em><sub><em>i</em></sub>, <em>s</em><sub><em>j</em></sub> ∈ <em>S</em></span></li><li>性质：<ol type="1"><li><span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>m</em>, <em>n</em>) ≥ 0</span>，<span class="math inline"><em>i</em>, <em>j</em> ∈ <em>S</em></span></li><li><span class="math inline">∑<sub><em>j</em> ∈ <em>S</em></sub><em>p</em><sub><em>i</em><em>j</em></sub>(<em>m</em>, <em>n</em>) = 1</span>，<span class="math inline"><em>i</em> ∈ <em>S</em></span></li></ol></li></ul></li><li><strong>状态转移矩阵</strong><ul><li>一步转移矩阵<span class="math inline"><strong>P</strong> = {<em>p</em><sub><em>i</em><em>j</em></sub>, <em>i</em>, <em>j</em> ∈ <em>S</em>}</span><span class="math display">$$  \mathbf{P}=  \begin{bmatrix}  p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1Q} \\  p_{21} &amp; p_{22} &amp; \cdots &amp; p_{2Q} \\  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  p_{Q1} &amp; p_{Q2} &amp; \cdots &amp; p_{QQ}  \end{bmatrix}  $$</span></li><li>k步转移矩阵<span class="math inline"><strong>P</strong> = {<em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup>(<em>m</em>), <em>i</em>, <em>j</em> ∈ <em>S</em>}</span></li></ul></li><li><strong>状态图</strong><ul><li>状态转移图/马尔科夫状态图/香农线图</li><li>元素<ul><li>圆圈：状态<span class="math inline"><em>S</em><sub><em>i</em></sub></span></li><li>箭头：转移</li><li>箭头旁标数字：转移概率</li></ul></li></ul></li><li><strong>一步转移概率</strong><ul><li><span class="math inline"><em>n</em> − <em>m</em> = 1</span>时，即<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>t</em>, <em>t</em> + 1)</span>，记为<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>t</em>)</span>，<span class="math inline"><em>t</em> ≥ 0</span>，并称为基本转移概率，也可称为一步转移概率。</li><li><span class="math display">$$  p_{ij}(t)=p_{ij}(t,t + 1)=P\{S_{t + 1}=j\mid S_t =i\}\overset{齐次}{=}p_{ij}\quad i,j\in S  $$</span></li><li>性质：<ol type="1"><li><span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub> ≥ 0</span>，<span class="math inline"><em>i</em>, <em>j</em> ∈ <em>S</em></span></li><li><span class="math inline">∑<sub><em>j</em> ∈ <em>S</em></sub><em>p</em><sub><em>i</em><em>j</em></sub> = 1</span>，<span class="math inline"><em>i</em> ∈ <em>S</em></span></li></ol></li></ul></li><li><strong>k步转移概率</strong><ul><li><p><span class="math display">$$  p_{ij}^{(k)}(t)=p_{ij}(t,t + k)=P\{S_{t + k}=j\mid S_t =i\}\overset{齐次}{=}p_{ij}^{(k)}\quad i,j\in S  $$</span></p></li><li><p>切普曼 - 柯尔莫戈洛夫方程： <span class="math display"><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = ∑<sub><em>r</em></sub><em>p</em><sub><em>i</em><em>r</em></sub><sup>(<em>l</em>)</sup><em>p</em><sub><em>r</em><em>j</em></sub><sup>(<em>k</em> − <em>l</em>)</sup>  <em>l</em> &lt; <em>k</em></span></p><p>特别地，当 <span class="math inline"><em>l</em> = 1</span> 时，有<span class="math display"><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = ∑<sub><em>r</em></sub><em>p</em><sub><em>i</em><em>r</em></sub><em>p</em><sub><em>r</em><em>j</em></sub><sup>(<em>k</em> − 1)</sup> = ∑<sub><em>r</em></sub><em>p</em><sub><em>i</em><em>r</em></sub><sup>(<em>k</em> − 1)</sup><em>p</em><sub><em>r</em><em>j</em></sub> = <em>p</em><sub><em>i</em><em>j</em></sub><sup><em>k</em></sup></span></p></li><li><p>若用矩阵表示，则 <span class="math display"><strong>P</strong><sup>(<em>k</em>)</sup> = <strong>P</strong><strong>P</strong><sup>(<em>k</em> − 1)</sup> = <strong>P</strong><strong>P</strong><strong>P</strong><sup>(<em>k</em> − 2)</sup> = ⋯ = <strong>P</strong><sup><em>k</em></sup></span></p><p>其中 <span class="math inline"><strong>P</strong><sup>(<em>k</em>)</sup> = {<em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup>}</span>为k步转移概率矩阵，<span class="math inline"><strong>P</strong><sup><em>k</em></sup></span>为一步转移矩阵的k次方。</p></li><li><p>对于齐次马尔可夫链，一步转移概率完全决定了k步转移概率，引入初始概率<span class="math inline"><em>p</em><sub>0<em>i</em></sub> = <em>P</em>(<em>S</em><sub>0</sub> = <em>s</em><sub><em>i</em></sub>)</span><span class="math display">$$  \begin{align*}  P(S_{k}=s_{j})&amp;=\sum_{i}P(S_{k}=s_{j},S_{0}=s_{i})\\  &amp;=\sum_{i}P(S_{0}=s_{i})P(S_{k}=s_{j}\mid S_{0}=s_{i})\\  &amp;=\sum_{i}p_{0i}p_{ij}^{(k)}  \end{align*}  $$</span></p></li></ul></li><li><strong>马尔可夫链的稳定(稳态分布)</strong><ul><li><p><strong>定义</strong>：<span class="math inline">lim<sub><em>k</em> → ∞</sub><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = <em>W</em><sub><em>j</em></sub> = <em>P</em>(<em>S</em><sub><em>k</em></sub> = <em>s</em><sub><em>j</em></sub>)</span>，信源达到稳定状态，所有变量<span class="math inline"><em>x</em><sub><em>k</em></sub></span>的概率分布不变</p></li><li><p><strong>求取</strong>： <span class="math display">$$  \left\{  \begin{array}{l}  \mathbb{W}\mathbf{P}=\mathbb{W}\\  \sum_{i}W_j = 1  \end{array}  \right.  $$</span></p><p>其中<span class="math inline">$\mathbb{W}=\begin{bmatrix} W_1 &amp;W_2 &amp; \cdots &amp; W_Q \end{bmatrix}$</span>，<span class="math inline"><em>W</em><sub><em>j</em></sub> = lim<sub><em>k</em> → ∞</sub><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = <em>P</em>(<em>S</em><sub><em>k</em></sub> = <em>s</em><sub><em>j</em></sub>)</span></p></li><li><p><strong>条件</strong></p><ul><li>必要不充分：上式有唯一解，则<span class="math inline">lim<sub><em>k</em> → ∞</sub><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup></span>存在</li><li><strong>不可约性</strong><ul><li>对任意一对 <span class="math inline"><em>i</em></span> 和 <span class="math inline"><em>j</em></span>，都存在至少一个 <span class="math inline"><em>k</em></span>，使 <span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> &gt; 0</span>，这就是说从<span class="math inline"><em>s</em><sub><em>i</em></sub></span>开始，总有可能到达 <span class="math inline"><em>s</em><sub><em>j</em></sub></span></li><li>反之若对所有 <span class="math inline"><em>k</em></span>，<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = 0</span>，就意味着一旦出现<span class="math inline"><em>s</em><sub><em>i</em></sub></span>以后不可能到达 <span class="math inline"><em>s</em><sub><em>j</em></sub></span>，也就是不能各态遍历<ul><li>此时状态中把 <span class="math inline"><em>s</em><sub><em>j</em></sub></span>取消就成为可约的了</li></ul></li></ul></li><li><strong>非周期性</strong><ul><li>在所有 <span class="math inline"><em>p</em><sub><em>i</em><em>i</em></sub><sup>(<em>n</em>)</sup> &gt; 0</span>的 <span class="math inline"><em>n</em></span> 中没有比 1大的公因子，即从<span class="math inline"><em>s</em><sub><em>i</em></sub></span>出发回到<span class="math inline"><em>s</em><sub><em>i</em></sub></span>的步数没有大于1 的公因子</li></ul></li></ul></li><li><p><strong>例题</strong>：</p><ul><li><figure><img src="image-104.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li><li><figure><img src="image-105.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li><li><figure><img src="image-106.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li></ul></li></ul></li></ul><h3 id="时间连续幅度连续的模拟信号随机波形信源">时间连续、幅度连续的模拟信号（随机波形信源）</h3><ul><li>例如语音、图像，可看作随机过程<span class="math inline"><em>x</em>(<em>t</em>)</span> 。</li><li>通过采样、量化，可将其转换为时间离散、幅度离散的符号序列。</li><li>假设<span class="math inline"><em>x</em>(<em>t</em>)</span>频带受限，<span class="math inline"><em>f</em><sub><em>m</em></sub></span>为最高频率，根据采样定理，<strong>不失真采样频率</strong><span class="math inline"><em>f</em><sub><em>s</em></sub> ≥ 2<em>f</em><sub><em>m</em></sub></span>。若时间受限为<span class="math inline"><em>t</em><sub><em>B</em></sub></span>，则<strong>采样点数</strong>为<span class="math inline">2<em>f</em><sub><em>m</em></sub><em>t</em><sub><em>B</em></sub> = <em>L</em></span>（形成长度为<span class="math inline"><em>L</em></span>的符号序列）。</li><li>一般情况下，<span class="math inline"><em>L</em> = 2<em>f</em><sub><em>m</em></sub><em>t</em><sub><em>B</em></sub></span>维连续型随机序列是有记忆的。</li></ul><h2 id="离散信源熵和互信息">2.2 离散信源熵和互信息</h2><h3 id="自信息量">自信息量</h3><ul><li><p>信源 <span class="math inline"><em>X</em></span>，概率空间 <span class="math display">$$\begin{bmatrix} X \\ p \end{bmatrix}=\begin{bmatrix} x_1 &amp; x_2 &amp; \cdots &amp; x_n \\ p(x_1) &amp;p(x_2) &amp; \cdots &amp; p(x_n) \end{bmatrix}$$</span></p></li><li><p>定义具有概率 <span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>的符号 <span class="math inline"><em>x</em><sub><em>i</em></sub></span>的自信息量为 <span class="math display">$$I(x_i)=-\logp(x_i)=\log\frac{1}{p(x_i)}$$</span></p><ul><li>底数为 <span class="math inline">2</span>，信息量单位比特（bit）</li><li>底数为自然常数 <span class="math inline"><em>e</em></span>，单位为奈特（nat）</li><li>底数为 <span class="math inline">10</span>，单位为笛特（det）<ul><li><span class="math inline">1nat = log<sub>2</sub><em>e</em> ≈ 1.433bit</span></li><li><span class="math inline">1det = log<sub>2</sub>10 ≈ 3.322bit</span></li></ul></li><li>性质：<ol type="1"><li><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = 1</span>，<span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>) = 0</span></li><li><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = 0</span>，<span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>) = ∞</span></li><li>非负性：<span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>) ≥ 0</span></li><li>单调递减性：若 <span class="math inline"><em>p</em>(<em>x</em><sub>2</sub>) &gt; <em>p</em>(<em>x</em><sub>1</sub>)</span>则 <span class="math inline"><em>I</em>(<em>x</em><sub>2</sub>) &lt; <em>I</em>(<em>x</em><sub>1</sub>)</span></li><li>可加性：<ul><li>两符号 <span class="math inline"><em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub></span>同时出现，<span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = −log <em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span></li><li><span class="math inline"><em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub></span>相互独立，<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = <em>p</em>(<em>x</em><sub><em>i</em></sub>)<em>p</em>(<em>y</em><sub><em>j</em></sub>)</span><ul><li><span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = −log <em>p</em>(<em>x</em><sub><em>i</em></sub>)<em>p</em>(<em>y</em><sub><em>j</em></sub>) = <em>I</em>(<em>x</em><sub><em>i</em></sub>) + <em>I</em>(<em>y</em><sub><em>j</em></sub>)</span></li></ul></li><li><span class="math inline"><em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub></span>不独立，定义<strong>条件自信息量</strong> <span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>) = −log <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span><ul><li><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = <em>p</em>(<em>x</em><sub><em>i</em></sub>)<em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = <em>p</em>(<em>y</em><sub><em>j</em></sub>)<em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span></li><li><span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = <em>I</em>(<em>x</em><sub><em>i</em></sub>) + <em>I</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = <em>I</em>(<em>y</em><sub><em>j</em></sub>) + <em>I</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span></li></ul></li></ul></li></ol></li><li>单位：bit</li></ul></li><li><p>示例：<img src="image-107.webp" srcset="/img/loading/loading3.gif" lazyload alt="示例"></p></li><li><p><strong>自信息量与信源符号不确定度</strong></p><ul><li>自信息量：符号出现后，提供给收信者的信息量，<strong>是接收者获得的</strong>。</li><li>信源符号不确定度：具有某种概率的信源符号在发出之前，存在不确定度，不确定度表征了该符号的特性，<strong>是信源本身固有的</strong>。</li><li><strong>二者在数量上相等</strong></li></ul></li></ul><h3 id="离散信源熵---熵的定义">离散信源熵 - 熵的定义</h3><ul><li><p>给定概率空间 <span class="math inline">$\begin{bmatrix} X \\ p\end{bmatrix}=\begin{bmatrix} x_1 &amp; x_2 &amp; \cdots &amp; x_n \\ p(x_1) &amp;p(x_2) &amp; \cdots &amp; p(x_n) \end{bmatrix}$</span>，自信息量<span class="math inline">$I(x_i)=-\logp(x_i)=\log\frac{1}{p(x_i)}$</span></p></li><li><p><strong>信源 <span class="math inline"><em>X</em></span> 的熵<span class="math inline"><em>H</em>(<em>X</em>)</span>定义为</strong>： <span class="math display">$$H(X)\overset{数量}{=}E[I(X)]=\sum_{i}p(x_i)I(x_i)=-\sum_{i} p(x_i)\log p(x_i)$$</span> 信源 <span class="math inline"><em>X</em></span>的熵也被称为平均自信息量、总体平均不确定度。</p></li><li><p>性质：</p><ul><li><span class="math inline"><em>H</em>(<em>X</em>)</span> 非负，因为<span class="math inline">0 ≤ <em>p</em>(<em>x</em><sub><em>i</em></sub>) ≤ 1</span>，<span class="math inline">log <em>p</em>(<em>x</em><sub><em>i</em></sub>) ≤ 0</span>，所以<span class="math inline"><em>H</em>(<em>X</em>) ≥ 0</span>。</li><li>若 <span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = 0</span>，规定<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)log <em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>为 <span class="math inline">0</span>。</li><li>若 <span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = 1</span>，<span class="math inline"><em>H</em>(<em>X</em>) = 0</span>，即确定信源熵为<span class="math inline">0</span>。</li></ul></li><li><p>单位：bit/符号</p></li><li><p>例题：<img src="image-109.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h4 id="二元信源">二元信源</h4><ul><li>二元信源概率空间 <span class="math inline">$\begin{bmatrix} X \\ p\end{bmatrix}=\begin{bmatrix} 0 &amp; 1 \\ p &amp; q \end{bmatrix}$</span>，其中 <span class="math inline"><em>p</em> + <em>q</em> = 1</span></li><li>则 <span class="math inline"><em>H</em>(<em>X</em>) = −<em>p</em>log <em>p</em> − <em>q</em>log <em>q</em> = −<em>p</em>log <em>p</em> − (1 − <em>p</em>)log (1 − <em>p</em>) = <em>H</em><sub>2</sub>(<em>p</em>) = <em>H</em>(<em>p</em>)</span></li><li><figure><img src="image-108.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li>性质：<ul><li>当 <span class="math inline"><em>p</em> = 1</span> 或 <span class="math inline"><em>q</em> = 1</span>（<span class="math inline"><em>p</em> = 0</span>）时，该信源不提供任何信息，即H(0)=0。</li><li>当 <span class="math inline">$p=q=\frac{1}{2}$</span>时，符号等概率发生，熵最大，为 <span class="math inline">$H(\frac{1}{2})=1\text{bit}/\text{符号}$</span>。</li></ul></li></ul><h3 id="条件熵">条件熵</h3><ul><li><p>给定 <span class="math inline"><em>y</em><sub><em>j</em></sub></span>的条件下，<span class="math inline"><em>x</em><sub><em>i</em></sub></span>的<strong>条件自信息量</strong>为 <span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>) = −log <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span>，<strong><span class="math inline"><em>X</em></span> 集合的条件熵 <span class="math inline"><em>H</em>(<em>X</em>|<em>y</em><sub><em>j</em></sub>)</span>定义为</strong>：<span class="math display"><em>H</em>(<em>X</em>|<em>y</em><sub><em>j</em></sub>) = ∑<sub><em>i</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)<em>I</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span></p></li><li><p>给定 <span class="math inline"><em>Y</em></span>（即各个 <span class="math inline"><em>y</em><sub><em>j</em></sub></span>）条件下，<strong><span class="math inline"><em>X</em></span> 集合的条件熵 <span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span>定义为</strong>： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) = −∑<sub><em>i</em><em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)log <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span>即条件熵是联合符号集合 <span class="math inline">(<em>X</em>, <em>Y</em>)</span>上的条件自信息量的<strong>联合概率加权统计平均值</strong>。条件熵 <span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span> 表示已知<span class="math inline"><em>Y</em></span> 后，<span class="math inline"><em>X</em></span> 的不确定度。</p></li><li><p>推导： <span class="math display">$$  \begin{align*}  H(X|Y)&amp;=\sum_{j}p(y_j)H(X|y_j)\\  &amp;=\sum_{j}p(y_j)\sum_{i}p(x_i|y_j)I(x_i|y_j)\\  &amp;=\sum_{i}\sum_{j}p(y_j)p(x_i|y_j)I(x_i|y_j)\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)I(x_i|y_j)\\  &amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log p(x_i|y_j)  \end{align*}  $$</span></p></li><li><p><strong>同理</strong>，<span class="math display"><em>H</em>(<em>Y</em>|<em>X</em>) = ∑<sub><em>i</em></sub>∑<sub><em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)<em>I</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = −∑<sub><em>i</em></sub>∑<sub><em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)log <em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span></p></li></ul><h3 id="联合熵">联合熵</h3><ul><li>联合熵是联合符号集合 <span class="math inline">(<em>X</em>, <em>Y</em>)</span> 上的每个元素对 <span class="math inline">(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span>的自信息量的<strong>概率加权统计平均值</strong>，定义为：</li></ul><p><span class="math display"><em>H</em>(<em>X</em>, <em>Y</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)<em>I</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = −∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)log <em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span></p><ul><li>联合熵 <span class="math inline"><em>H</em>(<em>X</em>, <em>Y</em>)</span> 表示 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span> 同时发生的不确定度。</li><li>联合熵 <span class="math inline"><em>H</em>(<em>X</em>, <em>Y</em>)</span> 与熵 <span class="math inline"><em>H</em>(<em>X</em>)</span> 及条件熵 <span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>)</span>之间存在下列<strong>关系</strong>： <span class="math display"><em>H</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>Y</em>) + <em>H</em>(<em>X</em>|<em>Y</em>)</span><ul><li>推导： <span class="math display">$$  \begin{align*}  H(X,Y)&amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log p(x_i,y_j)\\  &amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log [p(x_i)p(y_j|x_i)]\\  &amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\logp(x_i)-\sum_{i}\sum_{j}p(x_i,y_j)\log p(y_j|x_i)\\  &amp;=-\sum_{i}p(x_i)\log p(x_i)+H(Y|X)\\  &amp;=H(X)+H(Y|X)  \end{align*}  $$</span></li><li>同理可得 <span class="math inline"><em>H</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>Y</em>) + <em>H</em>(<em>X</em>|<em>Y</em>)</span></li></ul></li><li>例题：<img src="image-110.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h3 id="互信息">互信息</h3><ul><li><p>未收到消息时，信源 <span class="math inline"><em>X</em></span>的不确定度为 <span class="math inline"><em>H</em>(<em>X</em>)</span>，收到消息 <span class="math inline"><em>Y</em></span> 后关于 <span class="math inline"><em>x</em><sub><em>i</em></sub></span> 的不确定度为<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span>。<img src="image-111.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"></p></li><li><p><strong>定义</strong>：</p><ul><li><span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span>的互信息为接收者通过通信信道接收到的信源 <span class="math inline"><em>X</em></span> 的信息量</li><li><strong>平均互信息</strong>：<span class="math display">$$I(X;Y)=H(X)-H(X|Y)=\sum_{ij}p(x_i,y_j)\log\frac{p(x_i,y_j)}{p(x_i)p(y_j)}$$</span></li></ul></li><li><p><strong>平均互信息的推导</strong></p><ul><li><p><strong>定义单符号之间的互信息</strong> <span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>; <em>y</em><sub><em>j</em></sub>)</span>为 <span class="math display">$$  \begin{align*}  I(x_i;y_j)&amp;=I(x_i)-I(x_i|y_j)\\  &amp;=\log\frac{1}{p(x_i)}-\log\frac{1}{p(x_i|y_j)}\\  &amp;=\log\frac{p(x_i|y_j)}{p(x_i)}=\log\frac{\text{后验概率}}{\text{先验概率}}  \end{align*}  $$</span></p></li><li><p>在 <span class="math inline"><em>X</em></span>集合上<strong>统计平均值，即平均条件互信息量</strong> <span class="math inline"><em>I</em>(<em>X</em>; <em>y</em><sub><em>j</em></sub>)</span>为 <span class="math display">$$  I(X;y_j)=\sum_{i}p(x_i|y_j)I(x_i;y_j)=\sum_{i}p(x_i|y_j)\log\frac{p(x_i|y_j)}{p(x_i)}  $$</span></p></li><li><p><span class="math inline"><em>I</em>(<em>X</em>; <em>y</em><sub><em>j</em></sub>)</span>在 <span class="math inline"><em>Y</em></span>集合的<strong>概率加权统计平均值，即平均互信息</strong> <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 为 <span class="math display">$$  \begin{align*}  I(X;Y)&amp;=\sum_{j}p(y_j)I(X;y_j)=\sum_{j}p(y_j)\sum_{i}p(x_i|y_j)\log\frac{p(x_i|y_j)}{p(x_i)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i|y_j)}{p(x_i)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\logp(x_i|y_j)-\sum_{i}\sum_{j}p(x_i,y_j)\log p(x_i)\\  &amp;=H(X)-H(X|Y)\\  I(X;Y)&amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i|y_j)}{p(x_i)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i|y_j)p(y_j)}{p(x_i)p(y_j)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i,y_j)}{p(x_i)p(y_j)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{p(y_j)}\\  &amp;=I(Y;X)\\  \therefore I(X;Y)&amp;=H(Y)-H(Y|X)=I(Y;X)=H(X)+H(Y)-H(X,Y)  \end{align*}  $$</span></p></li></ul></li><li><p><strong>例题</strong>：<img src="image-112.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li><li><p><strong>性质</strong>：</p><ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>I</em>(<em>Y</em>; <em>X</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>) − <em>H</em>(<em>X</em>, <em>Y</em>)</span><ul><li><figure><img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload alt="H(X，Y)"><figcaption aria-hidden="true">H(X，Y)</figcaption></figure></li></ul></li><li><span class="math inline">0 ≤ <em>I</em>(<em>X</em>; <em>Y</em>) ≤ <em>H</em>(<em>X</em>)</span>（非负性证明见<a href="#互信息的非负性">互信息的非负性</a>）</li><li><strong>若<span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span>相互独立时</strong><ul><li><span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>X</em>)</span></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) = 0</span>，对应<strong>全损离散信道</strong></li></ul></li><li><strong>若<span class="math inline"><em>Y</em></span>是由<span class="math inline"><em>X</em></span>确定的一一对应函数</strong>，即<span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = 0或1</span><ul><li><span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Y</em>|<em>X</em>) = 0</span></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) = <em>H</em>(<em>Y</em>)</span>，对应<strong>无损信道</strong></li></ul></li><li><strong>一般情况下</strong>，<span class="math inline"><em>X</em></span>与<span class="math inline"><em>Y</em></span>既非相互独立，也不是一一对应 <span class="math display">$$  \begin{align*}  I(X;Y)&amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{p(y_j)}\\  &amp;=\sum_{i}\sum_{j}p(x_i)p(y_j|x_i)\log\frac{p(y_j|x_i)}{p(y_j)}\\  p(y_j)&amp;=\sum_{i}p(x_i)p(y_j|x_i)\\  I(X;Y)&amp;=f\left[p(x_i),p(y_j|x_i)\right]  \end{align*}  $$</span><ul><li><strong>结论</strong>：（证明见<a href="#互信息的凹凸性">互信息的凹凸性</a>）<ol type="1"><li><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>一定时，<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>是 <span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span>的<span class="math inline">∪</span>型凸函数，存在极小值。</li><li><span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span>一定时，<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>是关于<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>的<span class="math inline">∩</span>型凸函数，存在极大值。</li></ol></li></ul></li></ul></li><li><p><strong>收发两端的熵关系</strong></p><ul><li>条件熵 <span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span>又可以看作由于信道上的干扰和噪声，使接收端获得 <span class="math inline"><em>Y</em></span> 后还剩余的对信源符号 <span class="math inline"><em>X</em></span>的平均不确定度，故又称为<strong>疑义度</strong>。</li><li>条件熵 <span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>)</span>可看作唯一地确定信道噪声所需要的平均信量，故又称<strong>噪声熵或散布度</strong>。</li><li><figure><img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload alt="收发两端熵关系"><figcaption aria-hidden="true">收发两端熵关系</figcaption></figure></li></ul></li></ul><h3 id="相对熵">相对熵</h3><ul><li><span class="math inline"><em>p</em>, <em>q</em></span>为同一信源两个不同的概率分布，<strong>相对熵<span class="math inline"><em>D</em>(<em>p</em>||<em>q</em>)</span>是两个随机分布之间距离的度量</strong>，<strong><span class="math inline"><em>p</em></span>相对于<span class="math inline"><em>q</em></span>的相对熵定义</strong>为： <span class="math display">$$D(p||q)=\sum_{i}p(x_{i})\log\frac{p(x_{i})}{q(x_{i})}$$</span></li><li>约定 <span class="math inline">$0\log\frac{0}{0} = 0$</span>，<span class="math inline">$0\log\frac{0}{q}=0$</span>，<span class="math inline">$p\log\frac{p}{0} = \infty$</span></li><li><strong>性质</strong>：<ul><li><p><span class="math inline"><em>D</em>(<em>p</em>||<em>q</em>) ≠ <em>D</em>(<em>q</em>||<em>p</em>)</span></p></li><li><p>互信息可定义为联合分布<span class="math inline"><em>p</em>(<em>x</em>, <em>y</em>)</span>与乘积分布<span class="math inline"><em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>)</span>之间的相对熵<span class="math display">$$I(X;Y)=\sum_{i,j}p(x_{i},y_{j})\log\frac{p(x_{i}|y_{j})}{p(x_{i})}=\sum_{i,j}p(x_{i},y_{j})\log\frac{p(x_{i},y_{j})}{p(x_{i})p(y_{j})}=D(p(x,y)||p(x)p(y))$$</span></p></li><li><p><span class="math inline"><em>D</em>(<em>p</em>||<em>q</em>) ≥ 0</span>（证明见<a href="#信息不等式相对熵的非负性">信息不等式/相对熵的非负性</a>）</p></li><li><p>信源符号 <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub></span>概率分布 <span class="math inline"><em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub></span>编码方案1：<span class="math inline">−log <em>p</em><sub>1</sub>, −log <em>p</em><sub>2</sub>, ⋯, −log <em>p</em><sub><em>n</em></sub></span>（按照码长 <span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>) = −log <em>p</em><sub><em>i</em></sub></span>进行编码） 编码方案2：<span class="math inline">−log <em>q</em><sub>1</sub>, −log <em>q</em><sub>2</sub>, ⋯, −log <em>q</em><sub><em>n</em></sub></span></p><p>编码1平均码长 <span class="math inline"><em>K</em><sub><em>p</em></sub> = −∑<sub><em>i</em></sub><em>p</em><sub><em>i</em></sub>log <em>p</em><sub><em>i</em></sub></span>编码2平均码长 <span class="math inline"><em>K</em><sub><em>q</em></sub> = −∑<sub><em>i</em></sub><em>p</em><sub><em>i</em></sub>log <em>q</em><sub><em>i</em></sub></span><span class="math display">$$K_q - K_p=\sum_{i}p_{i}\log\frac{p_{i}}{q_{i}}=D(p||q)\geq0$$</span></p><ul><li><strong>结论</strong>：按概率分布编码最短</li></ul></li></ul></li></ul><h3 id="熵相对熵与互信息的链式法则">熵、相对熵与互信息的链式法则</h3><h4 id="熵的链式法则">熵的链式法则</h4><ul><li><p><strong>熵的链式法则</strong>：</p><ul><li>设随机变量 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>服从 <span class="math inline"><em>p</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)</span>，则<span class="math display">$$H(X_1,X_2,\cdots,X_n)=\sum_{i =1}^{n}H(X_i|X_{i - 1},\cdots,X_1)$$</span></li></ul></li><li><p><strong>证明</strong>：重复利用两个随机变量情形时熵的展开法则，有<span class="math display"><em>H</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>) = <em>H</em>(<em>X</em><sub>1</sub>) + <em>H</em>(<em>X</em><sub>2</sub>|<em>X</em><sub>1</sub>)</span><span class="math display">$$  \begin{align*}  H(X_1,X_2,X_3)&amp;=H(X_1)+H(X_2,X_3|X_1)\\  &amp;=H(X_1)+H(X_2|X_1)+H(X_3|X_2,X_1)  \end{align*}  $$</span><span class="math display">$$  \begin{align*}  H(X_1,X_2,\cdots,X_n)&amp;=H(X_1)+H(X_2|X_1)+\cdots +H(X_n|X_{n -1},\cdots,X_1)\\  &amp;=\sum_{i = 1}^{n}H(X_i|X_{i - 1},\cdots,X_1)  \end{align*}  $$</span></p></li><li><p><strong>另一证明</strong>：由 <span class="math inline">$p(x_1,x_2,\cdots,x_n)=\prod_{i = 1}^{n}p(x_i|x_{i -1},\cdots,x_1)$</span>，可得 <span class="math display">$$  \begin{align*}  &amp;H(X_1,X_2,\cdots,X_n)\\  =&amp;-\sum_{x_1,x_2,\cdots,x_n}p(x_1,x_2,\cdots,x_n)\logp(x_1,x_2,\cdots,x_n)\\  =&amp;-\sum_{x_1,x_2,\cdots,x_n}p(x_1,x_2,\cdots,x_n)\log\prod_{i =1}^{n}p(x_i|x_{i - 1},\cdots,x_1)\\  =&amp;-\sum_{x_1,x_2,\cdots,x_n}\sum_{i =1}^{n}p(x_1,x_2,\cdots,x_n)\log p(x_i|x_{i - 1},\cdots,x_1)\\  =&amp;-\sum_{i =1}^{n}\sum_{x_1,x_2,\cdots,x_n}p(x_1,x_2,\cdots,x_n)\log p(x_i|x_{i -1},\cdots,x_1)\\  =&amp;\sum_{i = 1}^{n}H(X_i|X_{i - 1},\cdots,X_1)\\  \end{align*}  $$</span></p></li></ul><h4 id="互信息的链式法则">互信息的链式法则</h4><ul><li><p><strong>条件互信息定义</strong>：</p><ul><li>随机变量 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span> 在给定随机变量 <span class="math inline"><em>Z</em></span> 时的条件互信息（conditional mutualinformation）定义为 <span class="math display">$$  \begin{align*}  I(X;Y|Z)&amp;=H(X|Z)-H(X|Y,Z)\\  &amp;=E_{p(x,y,z)}\log\frac{p(X,Y|Z)}{p(X|Z)p(Y|Z)}\\  &amp;=\sum_{i}\sum_{j}\sum_{k}p(x_i,y_j,z_k)\log\frac{p(x_i,y_j|z_k)}{p(x_i|z_k)p(y_j|z_k)}\\  &amp;=\sum_{i}\sum_{j}\sum_{k}p(x_i,y_j,z_k)\log\frac{p(x_i,y_j,z_k)p(z_k)}{p(x_i,z_k)p(y_j,z_k)}  \end{align*}  $$</span></li></ul></li><li><p><strong>互信息的链式法则</strong> <span class="math display">$$I(X_1,X_2,\cdots,X_n;Y)=\sum_{i =1}^{n}I(X_i;Y|X_{i - 1},X_{i - 2},\cdots,X_1)$$</span></p></li><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  &amp;I(X_1,X_2,\cdots,X_n;Y)\\  =&amp;H(X_1,X_2,\cdots,X_n)-H(X_1,X_2,\cdots,X_n|Y)\\  =&amp;\sum_{i = 1}^{n}H(X_i|X_{i - 1},\cdots,X_1)-\sum_{i =1}^{n}H(X_i|X_{i - 1},\cdots,X_1,Y)\\  =&amp;\sum_{i = 1}^{n}I(X_i;Y|X_1,X_2,\cdots,X_{i - 1})  \end{align*}  $$</span></p></li></ul><h4 id="相对熵的链式法则">相对熵的链式法则</h4><ul><li><p><strong>条件相对熵定义</strong>：</p><ul><li>对于联合概率密度函数 <span class="math inline"><em>p</em>(<em>x</em>, <em>y</em>)</span> 和 <span class="math inline"><em>q</em>(<em>x</em>, <em>y</em>)</span>，条件相对熵（conditionalrelative entropy <span class="math inline"><em>D</em>(<em>p</em>(<em>y</em>|<em>x</em>)∥<em>q</em>(<em>y</em>|<em>x</em>))</span>）定义为条件概率密度函数<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span> 和<span class="math inline"><em>q</em>(<em>y</em>|<em>x</em>)</span>之间的平均相对熵，其中取平均是关于概率密度函数 <span class="math inline"><em>p</em>(<em>x</em>)</span> 而言的。 <span class="math display">$$  \begin{align*}  D(p(y|x)\|q(y|x))&amp;=\sum_{x}p(x)\sum_{y}p(y|x)\log\frac{p(y|x)}{q(y|x)}\\  &amp;=E_{p(x,y)}\log\frac{p(Y|X)}{q(Y|X)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{q(y_j|x_i)}  \end{align*}  $$</span></li></ul></li><li><p><strong>相对熵的链式法则</strong> <span class="math display"><em>D</em>(<em>p</em>(<em>x</em>, <em>y</em>)∥<em>q</em>(<em>x</em>, <em>y</em>)) = <em>D</em>(<em>p</em>(<em>x</em>)∥<em>q</em>(<em>x</em>)) + <em>D</em>(<em>p</em>(<em>y</em>|<em>x</em>)∥<em>q</em>(<em>y</em>|<em>x</em>))</span></p></li><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  &amp;D(p(x,y)\|q(x,y))\\  =&amp;\sum_{x}\sum_{y}p(x,y)\log\frac{p(x,y)}{q(x,y)}\\  =&amp;\sum_{x}\sum_{y}p(x,y)\log\frac{p(x)p(y|x)}{q(x)q(y|x)}\\  =&amp;\sum_{x}\sum_{y}p(x,y)\log\frac{p(x)}{q(x)}+\sum_{x}\sum_{y}p(x,y)\log\frac{p(y|x)}{q(y|x)}\\  =&amp;\sum_{x}p(x)\log\frac{p(x)}{q(x)}+\sum_{x}\sum_{y}p(x,y)\log\frac{p(y|x)}{q(y|x)}\\  =&amp;D(p(x)\|q(x))+D(p(y|x)\|q(y|x))  \end{align*}  $$</span></p></li></ul><h3 id="jensen不等式">Jensen不等式</h3><h4 id="凸函数与凹函数">凸函数与凹函数</h4><ul><li><strong>凸函数(Convex)定义</strong><ul><li>若对于任意的 <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub> ∈ (<em>a</em>, <em>b</em>)</span>及 <span class="math inline">0 ≤ <em>λ</em> ≤ 1</span>，满足 <span class="math display"><em>f</em>(<em>λ</em><em>x</em><sub>1</sub> + (1 − <em>λ</em>)<em>x</em><sub>2</sub>) ≤ <em>λ</em><em>f</em>(<em>x</em><sub>1</sub>) + (1 − <em>λ</em>)<em>f</em>(<em>x</em><sub>2</sub>)</span></li></ul>则称函数 <span class="math inline"><em>f</em>(<em>x</em>)</span> 在区间<span class="math inline">(<em>a</em>, <em>b</em>)</span>上是凸的（convex）。<ul><li>如果仅当 <span class="math inline"><em>λ</em> = 0</span> 或 <span class="math inline"><em>λ</em> = 1</span>，上式等号成立，则称函数 <span class="math inline"><em>f</em></span> 是严格凸的（strictly convex）</li><li>如果函数总是位于任何一条弦的下面，则该函数是凸的</li><li><figure><img src="image-7.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul></li><li><strong>凹函数(Concave)定义</strong><ul><li>如果 <span class="math inline">−<em>f</em></span> 为凸函数，则称函数<span class="math inline"><em>f</em></span> 是凹的</li><li>如果函数总是位于任何一条弦的上面，则该函数是凹的</li><li><figure><img src="image-113.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul></li><li><strong>定理</strong>：如果函数 <span class="math inline"><em>f</em></span>在某个区间上存在非负（正）的二阶导数，则 <span class="math inline"><em>f</em></span> 为该区间的凸函数（严格凸函数）。<ul><li><strong>证明</strong>： 根据泰勒公式，<span class="math inline">$f(x)=f(x_0)+f^{\prime}(x_0)(x -x_0)+\frac{f^{\prime\prime}(x^*)}{2}(x - x_0)^2$</span> ，其中 <span class="math inline"><em>x</em> ≤ <em>x</em><sup>*</sup> ≤ <em>x</em><sub>0</sub></span>。根据假设<span class="math inline"><em>f</em><sup>′′</sup>(<em>x</em><sup>*</sup>) ≥ 0</span>，上式末项非负。设 <span class="math inline"><em>x</em><sub>0</sub> = <em>λ</em><em>x</em><sub>1</sub> + (1 − <em>λ</em>)<em>x</em><sub>2</sub></span>，<ul><li>取 <span class="math inline"><em>x</em> = <em>x</em><sub>1</sub></span>，可得<span class="math inline"><em>f</em>(<em>x</em><sub>1</sub>) ≥ <em>f</em>(<em>x</em><sub>0</sub>) + <em>f</em><sup>′</sup>(<em>x</em><sub>0</sub>)((1 − <em>λ</em>)(<em>x</em><sub>1</sub> − <em>x</em><sub>2</sub>))</span>①；</li><li>取 <span class="math inline"><em>x</em> = <em>x</em><sub>2</sub></span>，可得<span class="math inline"><em>f</em>(<em>x</em><sub>2</sub>) ≥ <em>f</em>(<em>x</em><sub>0</sub>) + <em>f</em><sup>′</sup>(<em>x</em><sub>0</sub>)(<em>λ</em>(<em>x</em><sub>2</sub> − <em>x</em><sub>1</sub>))</span>②。</li></ul>①<span class="math inline">×<em>λ</em>+</span>②<span class="math inline">×(1 − <em>λ</em>)</span> ： <span class="math display">$$  \begin{align*}  \lambda f(x_1)+(1 - \lambda)f(x_2)&amp;\geq\lambda f(x_0)+\lambdaf^{\prime}(x_0)((1 - \lambda)(x_1 - x_2))\\  &amp;+(1 - \lambda)f(x_0)+(1 - \lambda)f^{\prime}(x_0)\lambda(x_2 -x_1)\\  &amp;=f(x_0)\\  &amp;=f(\lambda x_1+(1 - \lambda)x_2)  \end{align*}  $$</span></li></ul></li></ul><h4 id="jensen不等式-1">Jensen不等式</h4><ul><li><p><strong>Jensen不等式</strong>：若给定凸函数 <span class="math inline"><em>f</em></span> 和一个随机变量 <span class="math inline"><em>X</em></span>，则 <span class="math display"><em>E</em>(<em>f</em>(<em>X</em>)) ≥ <em>f</em>(<em>E</em>(<em>X</em>))</span></p></li><li><p>若 <span class="math inline"><em>f</em></span>是严格凸的，上式等号成立时 <span class="math inline"><em>X</em> = <em>E</em>(<em>X</em>)</span>，即 <span class="math inline"><em>X</em></span> 是个常量。</p><ul><li><strong>证明</strong>： 对于两点分布 <span class="math inline">$\begin{bmatrix}x_1&amp;x_2\\p_1&amp;p_2\end{bmatrix}$</span>，<span class="math inline"><em>f</em></span> 是凸函数，因此有<span class="math inline"><em>p</em><sub>1</sub><em>f</em>(<em>x</em><sub>1</sub>) + <em>p</em><sub>2</sub><em>f</em>(<em>x</em><sub>2</sub>) ≥ <em>f</em>(<em>p</em><sub>1</sub><em>x</em><sub>1</sub> + <em>p</em><sub>2</sub><em>x</em><sub>2</sub>)</span>，即满足<span class="math inline"><em>E</em>(<em>f</em>(<em>X</em>)) ≥ <em>f</em>(<em>E</em>(<em>X</em>))</span>假定当分布点数为 <span class="math inline"><em>k</em> − 1</span>时，定理成立，此时记 <span class="math inline">$p_i^{\prime}=\frac{p_i}{1 - p_k}$</span> <span class="math inline">(<em>i</em> = 1, 2, ⋯, <em>k</em> − 1)</span> <span class="math display">$$  \begin{align*}  \sum_{i = 1}^{k}p_if(x_i)&amp;=p_kf(x_k)+(1 - p_k)\sum_{i = 1}^{k -1}p_i^{\prime}f(x_i)\\  &amp;\geq p_kf(x_k)+(1 - p_k)f(\sum_{i = 1}^{k - 1}p_i^{\prime}x_i)\\  &amp;\geq f(p_kx_k+(1 - p_k)\sum_{i = 1}^{k - 1}p_i^{\prime}x_i)\\  &amp;=f(\sum_{i = 1}^{k}p_ix_i)  \end{align*}  $$</span><ul><li>其中，“分布点数为 <span class="math inline"><em>k</em> − 1</span>时定理成立”用于推导第二步；“<span class="math inline"><em>f</em></span>的下凸性”用于推导第三步</li></ul></li></ul></li><li><p><strong>对凹函数</strong>：</p><ul><li>若 <span class="math inline"><em>f</em>(<em>x</em>)</span>是凹函数，则有 <span class="math inline"><em>E</em>(<em>f</em>(<em>X</em>)) ≤ <em>f</em>(<em>E</em>(<em>X</em>))</span></li><li>取 <span class="math inline"><em>f</em>(<em>x</em>) = log (<em>x</em>)</span>，有 <span class="math inline"><em>E</em>[log (<em>X</em>)] ≤ log (<em>E</em>(<em>X</em>))</span></li></ul></li></ul><h4 id="信息不等式相对熵的非负性">信息不等式/相对熵的非负性</h4><ul><li><strong><a href="#相对熵">信息不等式</a></strong>：设 <span class="math inline"><em>p</em>(<em>x</em>)</span>、<span class="math inline"><em>q</em>(<em>x</em>)</span>（<span class="math inline"><em>x</em> ∈ <em>X</em></span>）为两个概率密度函数，则<span class="math display"><em>D</em>(<em>p</em>||<em>q</em>) ≥ 0</span>当且仅当对任意 <span class="math inline"><em>x</em></span>，<span class="math inline"><em>p</em>(<em>x</em>) = <em>q</em>(<em>x</em>)</span>，等号成立。<ul><li><strong>证明</strong>： 设 <span class="math inline"><em>A</em> = {<em>x</em> : <em>p</em>(<em>x</em>) &gt; 0}</span>为 <span class="math inline"><em>p</em>(<em>x</em>)</span> 的支撑集，则<span class="math display">$$  \begin{align*}  -D(p||q)&amp;=-\sum_{x\in A}p(x)\log\frac{p(x)}{q(x)}=\sum_{x\inA}p(x)\log\frac{q(x)}{p(x)}\\  &amp;\leq\log\sum_{x\in A}p(x)\frac{q(x)}{p(x)}（由Jensen不等式）\\  &amp;=\log\sum_{x\in A}q(x)\\  &amp;\leq\log\sum_{x\in X}q(x)\\  &amp;=\log1 = 0  \end{align*}  $$</span> <span class="math inline">∴ <em>D</em>(<em>p</em>||<em>q</em>) ≥ 0</span> ，当<span class="math inline"><em>p</em>(<em>x</em>) = <em>q</em>(<em>x</em>)</span>时，等号成立。</li></ul></li></ul><h4 id="互信息的非负性">互信息的非负性</h4><ul><li><strong><a href="#互信息">互信息的非负性</a></strong>：任意两个随机变量 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span>， <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) ≥ 0</span>当且仅当 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span> 相互独立，等号成立。<ul><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  I(X;Y)&amp;=\sum_{x,y}p(x,y)\log\frac{p(x|y)}{p(x)}\\  &amp;=\sum_{x,y}p(x,y)\log\frac{p(x|y)p(y)}{p(x)p(y)}\\  &amp;=\sum_{x,y}p(x,y)\log\frac{p(x,y)}{p(x)p(y)}\\  &amp;=D(p(x,y)\|p(x)p(y))\\  &amp;\geq0  \end{align*}  $$</span></li></ul></li><li><strong>推论</strong>：<ul><li><span class="math inline"><em>D</em>(<em>p</em>(<em>y</em>|<em>x</em>)∥<em>q</em>(<em>y</em>|<em>x</em>)) ≥ 0</span>，当且仅当对任意的 <span class="math inline"><em>y</em></span> 以及满足<span class="math inline"><em>p</em>(<em>x</em>) &gt; 0</span> 的 <span class="math inline"><em>x</em></span>，有 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>) = <em>q</em>(<em>y</em>|<em>x</em>)</span>，等号成立。</li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>) ≥ 0</span>，当且仅当 <span class="math inline"><em>p</em>(<em>x</em>, <em>y</em>|<em>z</em>) = <em>p</em>(<em>x</em>|<em>z</em>)<em>p</em>(<em>y</em>|<em>z</em>)</span>时，等号成立。</li></ul></li></ul><h3 id="熵的性质">熵的性质</h3><ol type="1"><li><strong>非负性</strong><ul><li><span class="math display">$$H(X)=\sum_{i}p(x_i)\log\frac{1}{p(x_i)}\geq0$$</span></li></ul></li><li><strong>确定性</strong><ul><li><span class="math display"><em>H</em>(0, 1) = <em>H</em>(1, 0, ⋯, 0) = 0</span></li><li>只要有一个事件概率为1，熵就为0。</li></ul></li><li><strong>对称性</strong><ul><li><span class="math display"><em>H</em>(<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub>) = <em>H</em>(<em>p</em><sub>2</sub>, <em>p</em><sub>1</sub>, ⋯, <em>p</em><sub><em>n</em></sub>)</span></li></ul></li><li><strong>香农辅助定理</strong><ul><li>任意n维概率矢量 <span class="math inline"><em>P</em> = (<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub>)</span>，<span class="math inline"><em>Q</em> = (<em>q</em><sub>1</sub>, <em>q</em><sub>2</sub>, ⋯, <em>q</em><sub><em>n</em></sub>)</span></li><li><span class="math display">$$H(p_1,p_2,\cdots,p_n)=\sum_{i =1}^{n}p_i\log\frac{1}{p_i}\leq\sum_{i =1}^{n}p_i\log\frac{1}{q_i}$$</span></li><li><strong>证明</strong>：<span class="math inline">$D(P\|Q)=\sum_{i}p_i\log\frac{p_i}{q_i}\geq0$</span></li></ul></li><li><strong>最大熵定理</strong><ul><li><span class="math display">$$H(X)\leqH(\frac{1}{M},\frac{1}{M},\cdots,\frac{1}{M}) = \log M$$</span></li><li><span class="math inline"><em>M</em></span>：信源符号个数</li><li>符号等概率出现时，熵最大。</li><li><strong>证明</strong>：<span class="math inline"><em>X</em></span>的两种概率分布 <span class="math inline"><em>P</em></span>、<span class="math inline"><em>u</em></span>，<span class="math inline">$u(x)=\frac{1}{M}$</span> <span class="math display">$$  \begin{align*}  D(P\|u)&amp;=\sum p(x)\log\frac{p(x)}{u(x)}\\  &amp;=\sum p(x)\log p(x)+\sum p(x)\log M\\  &amp;=-H(X)+\log M\\  &amp;\geq0\\  &amp;\therefore H(X)\leq\log M  \end{align*}  $$</span></li></ul></li><li><strong>条件熵小于无条件熵</strong><ul><li><span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>X</em>)</span></li><li><strong>证明</strong>：<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) ≥ 0</span>，<span class="math inline"><em>H</em>(<em>X</em>) ≥ <em>H</em>(<em>X</em>|<em>Y</em>)</span>。</li></ul></li><li><strong>扩展性</strong><ul><li><span class="math display">lim<sub><em>ε</em> → 0</sub><em>H</em><sub><em>n</em> + 1</sub>(<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub> − <em>ε</em>, <em>ε</em>) = <em>H</em><sub><em>n</em></sub>(<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub>)</span></li><li><span class="math display">lim<sub><em>ε</em> → 0</sub><em>ε</em>log <em>ε</em> = 0</span></li><li>信源取值增多时，若这些取值概率很小(<span class="math inline"><em>ε</em> → 0</span>)，信源熵不变。</li></ul></li><li><strong>可加性</strong><ul><li><span class="math display"><em>H</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>|<em>X</em>)</span></li><li>当 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span> 相互独立时，<span class="math inline"><em>H</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>)</span>。</li><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  H(X,Y)&amp;=\sum p(x,y)\log p(x,y)=\sum p(x,y)\log (p(x)p(y|x))\\  &amp;=\sum p(x,y)\log p(x)+\sum p(x,y)\log p(y|x)\\  &amp;=H(X)+H(Y|X)  \end{align*}  $$</span></li></ul></li><li><strong>递增性</strong><ul><li><span class="math display">$$H_{n + m - 1}(p_1,p_2,\cdots,p_{n - 1},q_1,q_2,\cdots,q_m)\\=H_n(p_1,p_2,\cdots,p_n)+p_nH_m\left(\frac{q_1}{p_n},\frac{q_2}{p_n},\cdots,\frac{q_m}{p_n}\right)$$</span></li><li>其中<span class="math inline">$\sum_{i = 1}^{n}p_i =1$</span>，<span class="math inline">$\sum_{j = 1}^{m}q_j =p_n$</span></li><li>利用上式： <span class="math display">$$  \begin{align*}  H_n(p_1,p_2,\cdots,p_n)&amp;=H_{n - 1}(p_1,p_2,\cdots,p_{n -1}+p_n)+\\  \quad &amp;(p_{n - 1}+p_n)H_2\left(\frac{p_{n - 1}}{p_{n -1}+p_n},\frac{p_n}{p_{n - 1}+p_n}\right)  \end{align*}  $$</span></li></ul></li></ol><h3 id="对数和不等式及其应用">对数和不等式及其应用</h3><h4 id="对数和不等式">对数和不等式</h4><ul><li>非负数 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub></span>，和<span class="math inline"><em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>n</em></sub></span>，约定 <span class="math inline">0log 0 = 0</span>，<span class="math inline">$a\log\frac{a}{0}=\infty$</span>，<span class="math inline">$0\log\frac{0}{b}=0$</span> <span class="math display">$$  \sum_{i = 1}^{n}a_i\log\frac{a_i}{b_i}\geq\left(\sum_{i =1}^{n}a_i\right)\log\frac{\sum_{i = 1}^{n}a_i}{\sum_{i = 1}^{n}b_i}  $$</span> 当且仅当 <span class="math inline">$\frac{a_i}{b_i}=$</span> 常数时，等号成立。<ul><li><strong>证明</strong>： 假定 <span class="math inline"><em>a</em><sub><em>i</em></sub> &gt; 0</span>，<span class="math inline"><em>b</em><sub><em>i</em></sub> &gt; 0</span>，<span class="math inline"><em>f</em>(<em>t</em>) = <em>t</em>log <em>t</em></span>是严格下凸，因为 <span class="math inline">$f^{\prime\prime}(t)=\frac{1}{t}\loge&gt;0$</span>。 因此，由Jensen不等式，有 <span class="math inline">∑<em>α</em><sub><em>i</em></sub><em>f</em>(<em>t</em><sub><em>i</em></sub>) ≥ <em>f</em>(∑<em>α</em><sub><em>i</em></sub><em>t</em><sub><em>i</em></sub>)</span>，其中<span class="math inline"><em>α</em><sub><em>i</em></sub> ≥ 0</span>，<span class="math inline">∑<em>α</em><sub><em>i</em></sub> = 1</span>。 令<span class="math inline">$\alpha_i=\frac{b_i}{\sum_{j =1}^{n}b_j}$</span> ，<span class="math inline">$t_i=\frac{a_i}{b_i}$</span> ，可得 <span class="math display">$$  \begin{align*}  \sum\frac{b_i}{\sum_{j =1}^{n}b_j}\cdot\frac{a_i}{b_i}\log\frac{a_i}{b_i}&amp;\geq\left(\sum\alpha_it_i\right)\log\left(\sum\alpha_it_i\right)\\  &amp;=\sum\left(\frac{b_i}{\sum_{j =1}^{n}b_j}\cdot\frac{a_i}{b_i}\right)\log\left(\sum\frac{b_i}{\sum_{j =1}^{n}b_j}\cdot\frac{a_i}{b_i}\right)\\  \sum_{i}a_i\log\frac{a_i}{b_i}&amp;\geq\left(\sum_{i}a_i\right)\log\left(\sum_{i}\frac{a_i}{\sum_{j= 1}^{n}b_j}\right)\\  \sum_{i}a_i\log\frac{a_i}{b_i}&amp;\geq\left(\sum_{i}a_i\right)\log\frac{\sum_{i= 1}^{n}a_i}{\sum_{i = 1}^{n}b_j}  \end{align*}  $$</span></li></ul></li></ul><h4 id="相对熵的下凸性">相对熵的下凸性</h4><ul><li><span class="math inline"><em>D</em>(<em>p</em>||<em>q</em>)</span>关于 <span class="math inline">(<em>p</em>, <em>q</em>)</span>是下凸的</li><li>即如果 <span class="math inline">(<em>p</em><sub>1</sub>, <em>q</em><sub>1</sub>)</span>，<span class="math inline">(<em>p</em><sub>2</sub>, <em>q</em><sub>2</sub>)</span>为两对概率密度函数，则对所有的 <span class="math inline">0 ≤ <em>λ</em> ≤ 1</span>，有 <span class="math display"><em>D</em>(<em>λ</em><em>p</em><sub>1</sub> + (1 − <em>λ</em>)<em>p</em><sub>2</sub>∥<em>λ</em><em>q</em><sub>1</sub> + (1 − <em>λ</em>)<em>q</em><sub>2</sub>) ≤ <em>λ</em><em>D</em>(<em>p</em><sub>1</sub>∥<em>q</em><sub>1</sub>) + (1 − <em>λ</em>)<em>D</em>(<em>p</em><sub>2</sub>∥<em>q</em><sub>2</sub>)</span><ul><li><strong>证明</strong>： 已知 <span class="math inline">$\sum_{i =1}^{n}a_i\log\frac{a_i}{b_i}\geq\left(\sum_{i =1}^{n}a_i\right)\log\frac{\sum_{i = 1}^{n}a_i}{\sum_{i =1}^{n}b_i}$</span> 令 <span class="math inline"><em>a</em><sub>1</sub> = <em>λ</em><em>p</em><sub>1</sub>(<em>x</em>)</span>，<span class="math inline"><em>b</em><sub>1</sub> = <em>λ</em><em>q</em><sub>1</sub>(<em>x</em>)</span><span class="math inline"><em>a</em><sub>2</sub> = (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>x</em>)</span>，<span class="math inline"><em>b</em><sub>2</sub> = (1 − <em>λ</em>)<em>q</em><sub>2</sub>(<em>x</em>)</span><span class="math display">$$  \begin{align*}  &amp;\quad \lambda p_1(x)\log\frac{\lambda p_1(x)}{\lambda q_1(x)}+(1- \lambda)p_2(x)\log\frac{(1 - \lambda)p_2(x)}{(1 - \lambda)q_2(x)}\\  &amp;\geq(\lambda p_1(x)+(1 - \lambda)p_2(x))\log\frac{\lambdap_1(x)+(1 - \lambda)p_2(x)}{\lambda q_1(x)+(1 - \lambda)q_2(x)}\\  &amp;\quad \sum_{x}\left[\lambda p_1(x)\log\frac{p_1(x)}{q_1(x)}+(1 -\lambda)p_2(x)\log\frac{p_2(x)}{q_2(x)}\right]\\  &amp;\geq\sum_{x}(\lambda p_1(x)+(1 - \lambda)p_2(x))\log\frac{\lambdap_1(x)+(1 - \lambda)p_2(x)}{\lambda q_1(x)+(1 - \lambda)q_2(x)}\\  &amp;\quad \lambda D(p_1\|q_1)+(1 - \lambda)D(p_2\|q_2)\\  &amp;\geq D(\lambda p_1+(1 - \lambda)p_2\|\lambda q_1+(1 -\lambda)q_2)  \end{align*}  $$</span></li></ul></li></ul><h4 id="熵的凹性">熵的凹性</h4><ul><li><span class="math inline"><em>H</em>(<em>p</em>)</span> 是关于 <span class="math inline"><em>p</em></span> 的凹函数。<ul><li><strong>证明</strong>： 均匀分布 <span class="math inline">$u(x_i)=\frac{1}{M}$</span> <span class="math display">$$  \begin{align*}  D(p\|u)&amp;=\sum_{i}p(x_i)\log\frac{p(x_i)}{u(x_i)}\\  &amp;=\sum_{i}p(x_i)\log p(x_i)-\sum_{i}p(x_i)\log u(x_i)\\  &amp;=-H(p)+\log M  \end{align*}  $$</span> <span class="math inline">∴ <em>H</em>(<em>p</em>) = log <em>M</em> − <em>D</em>(<em>p</em>∥<em>u</em>)</span>，因为<span class="math inline"><em>D</em>(<em>p</em>∥<em>u</em>)</span>是凸函数，所以 <span class="math inline"><em>H</em>(<em>p</em>)</span>是凹函数。</li></ul></li></ul><h4 id="互信息的凹凸性">互信息的凹凸性</h4><ul><li><strong><a href="#互信息">互信息的凹凸性</a></strong><ul><li>设 <span class="math inline">(<em>X</em>, <em>Y</em>) ∼ <em>p</em>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>|<em>x</em>)</span>。</li><li>如果固定 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>，则互信息<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>是关于 <span class="math inline"><em>p</em>(<em>x</em>)</span>的凹函数；</li><li>如果固定 <span class="math inline"><em>p</em>(<em>x</em>)</span>，则互信息 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是关于<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>的凸函数。</li></ul></li><li><strong>证明</strong>：<ol type="1"><li><p><strong>证明第一部分</strong> <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>Y</em>) − ∑<sub><em>x</em></sub><em>p</em>(<em>x</em>)<em>H</em>(<em>Y</em>|<em>X</em> = <em>x</em>)</span>如果固定 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>，<span class="math inline"><em>p</em>(<em>y</em>) = ∑<sub><em>x</em></sub><em>p</em>(<em>x</em>, <em>y</em>) = ∑<sub><em>x</em></sub><em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>|<em>x</em>)</span>是 <span class="math inline"><em>p</em>(<em>x</em>)</span> 的线性函数。<span class="math inline"><em>H</em>(<em>Y</em>)</span> 是关于 <span class="math inline"><em>p</em>(<em>y</em>)</span> 的凹函数，因而也是关于<span class="math inline"><em>p</em>(<em>x</em>)</span>的凹函数。上式第二项是关于 <span class="math inline"><em>p</em>(<em>x</em>)</span>的线性函数，因此它们的差仍是关于 <span class="math inline"><em>p</em>(<em>x</em>)</span> 的凹函数。</p></li><li><p><strong>证明第二部分</strong></p><ul><li><p><strong>方法1</strong>： 固定 <span class="math inline"><em>p</em>(<em>x</em>)</span>，考虑两个不同的条件分布<span class="math inline"><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)</span>和 <span class="math inline"><em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>。相应的联合分布分别为<span class="math inline"><em>p</em><sub>1</sub>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)</span>和 <span class="math inline"><em>p</em><sub>2</sub>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>，且各自的边际分布为<span class="math inline"><em>p</em>(<em>x</em>), <em>p</em><sub>1</sub>(<em>y</em>)</span>和 <span class="math inline"><em>p</em>(<em>x</em>), <em>p</em><sub>2</sub>(<em>y</em>)</span>。考虑条件分布 <span class="math display"><em>p</em><sub><em>λ</em></sub>(<em>y</em>|<em>x</em>) = <em>λ</em><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>它是 <span class="math inline"><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)</span>和 <span class="math inline"><em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>的组合，其中 <span class="math inline">0 ≤ <em>λ</em> ≤ 1</span>。相应的联合分布也是对应的两个联合分布的线性组合 <span class="math display"><em>p</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>) = <em>λ</em><em>p</em><sub>1</sub>(<em>x</em>, <em>y</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>x</em>, <em>y</em>)</span><span class="math inline"><em>Y</em></span> 的分布也是一个组合 <span class="math display"><em>p</em><sub><em>λ</em></sub>(<em>y</em>) = <em>λ</em><em>p</em><sub>1</sub>(<em>y</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>y</em>)</span>因此，如果设 <span class="math inline"><em>q</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em><sub><em>λ</em></sub>(<em>y</em>)</span>为边际分布的乘积，则有 <span class="math display"><em>q</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>) = <em>λ</em><em>q</em><sub>1</sub>(<em>x</em>, <em>y</em>) + (1 − <em>λ</em>)<em>q</em><sub>2</sub>(<em>x</em>, <em>y</em>)</span>由于互信息是联合分布和边际分布乘积的相对熵，有 <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>D</em>(<em>p</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>)∥<em>q</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>))</span>因为相对熵 <span class="math inline"><em>D</em>(<em>p</em>∥<em>q</em>)</span> 是关于<span class="math inline">(<em>p</em>, <em>q</em>)</span> 的凸函数，因此<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是<span class="math inline">(<em>p</em><sub><em>λ</em></sub>, <em>q</em><sub><em>λ</em></sub>)</span>的凸函数，由于 <span class="math inline"><em>p</em><sub><em>λ</em></sub>, <em>q</em><sub><em>λ</em></sub></span>都是 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>的线性组合，所以 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是条件分布<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>的凸函数。</p></li><li><p><strong>方法2</strong>： 设 <span class="math inline"><em>p</em>(<em>x</em>)</span> 为固定信源分布，令<span class="math inline"><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)</span>和 <span class="math inline"><em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>为两条不同信道，相应的互信息分别记为 <span class="math inline"><em>I</em>[<em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)]</span>和 <span class="math inline"><em>I</em>[<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)]</span>。令 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>) = <em>λ</em><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>，<span class="math inline">0 ≤ <em>λ</em> ≤ 1</span>，相应的互信息为 <span class="math inline"><em>I</em>[<em>p</em>(<em>y</em>|<em>x</em>)]</span><span class="math display">$$\begin{align*}①\ &amp;I[p(y|x)]-\lambda I[p_1(y|x)]-(1 - \lambda)I[p_2(y|x)]\\&amp;=\sum_{x,y}p(x,y)\log\frac{p(y|x)}{p(y)}-\sum_{x,y}\lambdap_1(x,y)\log\frac{p_1(y|x)}{p_1(y)}-\\&amp;\quad \sum_{x,y}(1 -\lambda)p_2(x,y)\log\frac{p_2(y|x)}{p_2(y)}\\&amp;=\sum_{x,y}[\lambda p_1(x,y)+(1 -\lambda)p_2(x,y)]\log\frac{p(y|x)}{p(x)}-\\&amp;\quad\sum_{x,y}\lambdap_1(x,y)\log\frac{p_1(y|x)}{p(x)}-\sum_{x,y}(1 -\lambda)p_2(x,y)\log\frac{p_2(y|x)}{p(x)}\\&amp;=\lambda\underbrace{\sum_{x,y}p_1(x,y)\log\frac{p(x|y)}{p_1(x|y)}}_{(②)}+(1 -\lambda)\underbrace{\sum_{x,y}p_2(x,y)\log\frac{p(x|y)}{p_2(x|y)}}_{(③)}\end{align*}$$</span> 应用Jensen不等式 <span class="math display">$$\begin{align*}②\\lambda\sum_{x,y}p_1(x,y)\log\frac{p(x|y)}{p_1(x|y)}&amp;\leq\lambda\log\left[\sum_{x,y}p_1(x,y)\frac{p(x|y)}{p_1(x|y)}\right]\\&amp;=\lambda\log\left[\sum_{y}p_1(y)\sum_{x}p(x|y)\right]\\&amp;=\lambda\log\left[\sum_{y}p_1(y)\sum_{x}\frac{p(x)p(y|x)}{p(y)}\right]\\&amp;=\lambda\log1 = 0\end{align*}$$</span> 同理 <span class="math inline">③ = 0</span>，则 <span class="math inline">① ≤ 0</span> <span class="math display"><em>I</em>(<em>λ</em><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)) ≤ <em>λ</em><em>I</em>[<em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)] + (1 − <em>λ</em>)<em>I</em>[<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)]</span></p></li></ul></li></ol><ul><li>由此可知，互信息 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 关于 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span> 下凸。</li></ul></li></ul><h2 id="数据处理不等式">2.3 数据处理不等式</h2><h3 id="三变量互信息">三变量互信息</h3><ul><li><strong>定义</strong>：<ol type="1"><li><strong><span class="math inline"><em>x</em><sub><em>i</em></sub></span>与符号对<span class="math inline">(<em>y</em><sub><em>j</em></sub>, <em>z</em><sub><em>k</em></sub>)</span>间的互信息量</strong><ul><li><span class="math inline">$I(x_i;y_j,z_k)=\log\frac{p(x_i|y_j,z_k)}{p(x_i)}$</span></li></ul></li><li><strong>条件互信息量</strong><ul><li><span class="math display">$$\begin{align*}I(x_i;y_j|z_k)&amp;=\log\frac{p(x_i|y_j,z_k)}{p(x_i|z_k)}=\log(\frac{p(x_i|y_j,z_k)}{p(x_i)}\frac{p(x_i)}{p(x_i|z_k)})\\&amp;=\log\frac{p(x_i|y_j,z_k)}{p(x_i)}-\log\frac{p(x_i|z_k)}{p(x_i)}\\&amp;=I(x_i;y_j,z_k)-I(x_i;z_k)\end{align*}$$</span></li><li><span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>; <em>y</em><sub><em>j</em></sub>, <em>z</em><sub><em>k</em></sub>) = <em>I</em>(<em>x</em><sub><em>i</em></sub>; <em>z</em><sub><em>k</em></sub>) + <em>I</em>(<em>x</em><sub><em>i</em></sub>; <em>y</em><sub><em>j</em></sub>|<em>z</em><sub><em>k</em></sub>)</span></li><li>对其求平均可得<ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>, <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Z</em>) + <em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>)</span></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>, <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Z</em>, <em>Y</em>) = <em>I</em>(<em>X</em>; <em>Y</em>) + <em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>)</span>①</li></ul></li></ul></li><li><strong><span class="math inline"><em>x</em><sub><em>i</em></sub>，<em>y</em><sub><em>j</em></sub></span>与符号对<span class="math inline">(<em>z</em><sub><em>k</em></sub>)</span>间的互信息量</strong><ul><li><span class="math display">$$\begin{align*}I(x_i,y_j;z_k)&amp;=\log\frac{p(x_iy_j|z_k)}{p(x_iy_j)}=\log\frac{p(x_i|z_k)p(y_j|x_iz_k)}{p(x_i)p(y_j|x_i)}\\&amp;=\log\frac{p(x_i|z_k)}{p(x_i)}+\log\frac{p(y_j|x_iz_k)}{p(y_j|x_i)}\\&amp;=I(x_i;z_k)+I(y_j;z_k|x_i)\end{align*}$$</span></li><li>对其求平均可得<ul><li><span class="math inline"><em>I</em>(<em>X</em>, <em>Y</em>; <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Z</em>) + <em>I</em>(<em>Y</em>; <em>Z</em>|<em>X</em>)</span></li><li><span class="math inline"><em>I</em>(<em>X</em>, <em>Y</em>; <em>Z</em>) = <em>I</em>(<em>Y</em>, <em>X</em>; <em>Z</em>) = <em>I</em>(<em>Y</em>; <em>Z</em>) + <em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>)</span>②</li></ul></li></ul></li></ol></li><li><strong>互信息操作</strong>：<ul><li>由①、②：<ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>) = <em>I</em>(<em>X</em>; <em>Y</em>, <em>Z</em>) − <em>I</em>(<em>X</em>; <em>Y</em>)</span><ul><li>把条件<span class="math inline"><em>Y</em></span>移到分号后面，然后减去该条件与分号前面的变量之间的互信息</li><li><span class="math inline"><em>Y</em></span>的条件下<span class="math inline"><em>X</em><em>和</em><em>Z</em></span>+ <span class="math inline"><em>X</em><em>和</em><em>Y</em></span> = <span class="math inline"><em>X</em><em>和</em>(<em>Y</em>, <em>Z</em>)</span></li></ul></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>) = <em>I</em>(<em>X</em>, <em>Y</em>; <em>Z</em>) − <em>I</em>(<em>Y</em>; <em>Z</em>)</span><ul><li>把条件<span class="math inline"><em>Y</em></span>移到分号前面，然后减去该条件与分号后面的变量之间的互信息</li></ul></li></ul></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>, <em>W</em>) = <em>I</em>(<em>X</em>; <em>Z</em>, <em>Y</em>|<em>W</em>) − <em>I</em>(<em>X</em>; <em>Y</em>|<em>W</em>) = <em>I</em>(<em>X</em>, <em>Y</em>; <em>Z</em>|<em>W</em>) − <em>I</em>(<em>Y</em>; <em>Z</em>|<em>W</em>)</span></li><li><span class="math display">$$\begin{align*}I(X;Y|Z)&amp;=\sum_{i,j,k}p(x_i,y_j,z_k)\log\frac{p(x_i|y_j,z_k)}{p(x_i|z_k)}\\&amp;=\sum_{i,j,k} p(x_i,y_j,z_k)\log p(x_i|y_j,z_k)-\sum_{i,j,k}p(x_i,y_j,z_k)\log p(x_i|z_k)\\&amp;=H(X|Z)-H(X|Y,Z)\\&amp;=H(Y|Z)-H(Y|X,Z)\\&amp;=I(Y;X|Z)\end{align*}$$</span></li></ul></li><li><strong>三变量通用信息图</strong>：<ul><li>信息图表示：<ul><li>$H/I $区域</li><li><span class="math inline">,  ⇔ ⋃</span>(并集)</li><li><span class="math inline">;  ⇔ ⋂</span>(交集)</li><li><span class="math inline">| ⇔ −</span> (减)</li></ul></li><li><figure><img src="image-4.webp" srcset="/img/loading/loading3.gif" lazyload alt="三变量通用信息图"><figcaption aria-hidden="true">三变量通用信息图</figcaption></figure></li><li>不相变的7个区域分别表示<ul><li><span class="math inline"><em>a</em><sub>1</sub> : <em>H</em>(<em>Y</em>|<em>X</em>, <em>Z</em>)</span></li><li><span class="math inline"><em>a</em><sub>2</sub> : <em>H</em>(<em>X</em>|<em>Y</em>, <em>Z</em>)</span></li><li><span class="math inline"><em>a</em><sub>3</sub> : <em>H</em>(<em>Z</em>|<em>X</em>, <em>Y</em>)</span></li><li><span class="math inline"><em>a</em><sub>4</sub> : <em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>)</span><br></li><li><span class="math inline"><em>a</em><sub>5</sub> : <em>I</em>(<em>Y</em>; <em>Z</em>|<em>X</em>)</span></li><li><span class="math inline"><em>a</em><sub>6</sub> : <em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>)</span></li><li><span class="math inline"><em>a</em><sub>7</sub> : <em>I</em>(<em>X</em>; <em>Y</em>; <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Y</em>) − <em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>)</span></li></ul></li><li>一般情况下，<span class="math inline"><em>a</em><sub>7</sub></span>可能为负，即<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>; <em>Z</em>)</span>可能小于0 。</li></ul></li><li>示例：<img src="image-114.webp" srcset="/img/loading/loading3.gif" lazyload alt="示例"></li></ul><h3 id="一阶马尔可夫链">一阶马尔可夫链</h3><h4 id="定义">定义</h4><ol type="1"><li><strong>定义（两变量独立）</strong><ul><li>两个随机变量 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span> 独立，记为 <span class="math inline"><em>X</em> ⟂ <em>Y</em></span>，有 <span class="math display"><em>p</em>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>)</span></li></ul></li><li><strong>定义（相互独立）</strong><ul><li>设 <span class="math inline"><em>n</em> ≥ 3</span>，随机变量 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>相互独立，有 <span class="math display"><em>p</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>) = <em>p</em>(<em>x</em><sub>1</sub>)<em>p</em>(<em>x</em><sub>2</sub>)⋯<em>p</em>(<em>x</em><sub><em>n</em></sub>)</span></li></ul></li><li><strong>定义（条件独立）</strong><ul><li>随机变量 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span> 和 <span class="math inline"><em>Z</em></span>，若 <span class="math inline"><em>X</em></span> 与 <span class="math inline"><em>Z</em></span> 关于 <span class="math inline"><em>Y</em></span> 条件独立，记为 <span class="math inline"><em>X</em> ⟂ <em>Z</em>|<em>Y</em></span></li><li>有 <span class="math inline"><em>p</em>(<em>x</em>, <em>y</em>, <em>z</em>)<em>p</em>(<em>y</em>) = <em>p</em>(<em>x</em>, <em>y</em>)<em>p</em>(<em>y</em>, <em>z</em>)</span>或 <span class="math inline"><em>p</em>(<em>x</em>, <em>z</em>|<em>y</em>) = <em>p</em>(<em>x</em>|<em>y</em>)<em>p</em>(<em>z</em>|<em>y</em>)</span></li><li>等价地 <span class="math display"><em>p</em>(<em>x</em>, <em>y</em>, <em>z</em>) = <em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>|<em>x</em>)<em>p</em>(<em>z</em>|<em>y</em>)</span></li></ul></li><li><strong>定义（马尔可夫链）</strong><ul><li>随机变量 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>（<span class="math inline"><em>n</em> ≥ 3</span>）构成一个马尔可夫链，记作<span class="math inline"><em>X</em><sub>1</sub> → <em>X</em><sub>2</sub> → ⋯ → <em>X</em><sub><em>n</em></sub></span>，则有<span class="math display"><em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)<em>p</em>(<em>X</em><sub>2</sub>)<em>p</em>(<em>X</em><sub>3</sub>)⋯<em>p</em>(<em>X</em><sub><em>n</em> − 1</sub>) = <em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>)<em>p</em>(<em>X</em><sub>2</sub>, <em>X</em><sub>3</sub>)⋯<em>p</em>(<em>X</em><sub><em>n</em> − 1</sub>, <em>X</em><sub><em>n</em></sub>)</span></li><li>或等价地 <span class="math display"><em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>) = <em>p</em>(<em>X</em><sub>1</sub>)<em>p</em>(<em>X</em><sub>2</sub>|<em>X</em><sub>1</sub>)<em>p</em>(<em>X</em><sub>3</sub>|<em>X</em><sub>2</sub>)⋯<em>p</em>(<em>X</em><sub><em>n</em></sub>|<em>X</em><sub><em>n</em> − 1</sub>)</span></li><li>即系统在时刻<span class="math inline"><em>n</em></span>的状态只取决于时刻<span class="math inline"><em>n</em> − 1</span>的状态，而与时刻<span class="math inline"><em>n</em> − 1</span>之前的状态无关</li><li>可见：<span class="math inline"><em>X</em> → <em>Y</em> → <em>Z</em></span> 等价于<span class="math inline"><em>X</em> ⟂ <em>Z</em>|<em>Y</em></span></li></ul></li></ol><h4 id="结论">结论</h4><ol type="1"><li><span class="math inline"><em>X</em><sub>1</sub> → <em>X</em><sub>2</sub> → ⋯ → <em>X</em><sub><em>n</em></sub></span>构成一个马尔可夫链，则有 <span class="math inline"><em>X</em><sub><em>n</em></sub> → <em>X</em><sub><em>n</em> − 1</sub> → ⋯ → <em>X</em><sub>1</sub></span>也构成一个马尔可夫链。（可由马尔可夫链定义的对称性直接得到）。</li><li><span class="math inline"><em>X</em><sub>1</sub> → <em>X</em><sub>2</sub> → ⋯ → <em>X</em><sub><em>n</em></sub></span>构成一个马尔可夫链，则有 <span class="math display">$$\begin{align*}&amp;X_1 \to X_2 \to X_3\\&amp;(X_1,X_2) \to X_3 \to X_4\\&amp;\vdots\\&amp;(X_1,X_2,\cdots,X_{n - 2}) \to X_{n - 1} \to X_n\end{align*}$$</span> 构成马尔可夫链。<ul><li><p><strong>证明</strong>：</p><p><span class="math display">$$  \begin{align*}  &amp;若X_1 \to X_2 \to X_3 \to X_4构成马尔可夫链，则有\\  &amp;p(x_1,x_2,x_3,x_4)p(x_2)p(x_3) =p(x_1,x_2)p(x_2,x_3)p(x_3,x_4)\quad ①\\  &amp;\therefore \sum_{x_4} p(x_1,x_2,x_3,x_4)p(x_2)p(x_3) = \sum_{x_4}p(x_1,x_2)p(x_2,x_3)p(x_3,x_4)\\  &amp;\therefore p(x_1,x_2,x_3)p(x_2)p(x_3) =p(x_1,x_2)p(x_2,x_3)p(x_3)\\  &amp;\therefore p(x_1,x_2,x_3)p(x_2) = p(x_1,x_2)p(x_2,x_3)\quad ②\\  &amp;\Rightarrow X_1 \to X_2 \to X_3 构成马尔可夫链\\  &amp;把②代入①得 p(x_1,x_2,x_3,x_4)p(x_2)p(x_3) =p(x_1,x_2,x_3)p(x_2)p(x_3,x_4)\\  &amp;\therefore p(x_1,x_2,x_3,x_4)p(x_3) = p(x_1,x_2,x_3)p(x_3,x_4)\\  &amp;\Rightarrow (X_1,X_2) \to X_3 \to X_4 构成马尔可夫链  \end{align*}  $$</span></p></li><li><p>例题：<img src="image-115.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul></li><li><span class="math inline"><em>X</em> → <em>Y</em> → <em>Z</em> → <em>W</em></span>构成马尔可夫链，则有<ul><li><span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>X</em>|<em>Y</em><em>Z</em>) = <em>H</em>(<em>X</em>|<em>Y</em><em>Z</em><em>W</em>)</span><ul><li><strong>证明</strong>： 由马尔可夫链性质： <span class="math display">$$  \begin{align*}  &amp;p(x,y,z)p(y) = p(x,y)p(y,z)\\  &amp;\Rightarrow \frac{p(x,y,z)}{p(y,z)} = \frac{p(x,y)}{p(y)}\\  &amp;\Rightarrow p(x|yz) = p(x|y)\\  &amp;\Rightarrow \underset{x,y}{\mathbb{E}}p(x|yz)=\underset{x,y}{\mathbb{E}} p(x|y)\\  &amp;即 H(X|YZ) = H(X|Y)  \end{align*}  $$</span> 类似地： <span class="math display">$$  \begin{align*}  &amp;p(x,y,z,w)p(y)p(z) = p(x,y)p(y,z)p(z,w)\\  &amp;\Rightarrow p(x,y,z,w) = \frac{p(x,y)}{p(y)} \cdot\frac{p(y,z)p(z,w)}{p(z)} = p(x|y) p(y,z,w)\\  &amp;\Rightarrow p(x|yzw) = p(x|y)\\  &amp;即 H(X|Y) = H(X|YZW)  \end{align*}  $$</span></li><li>注：<span class="math inline">$\frac{p(y,z)p(z,w)}{p(z)} =p(y,z,w)$</span> 由 <span class="math inline"><em>Y</em> → <em>Z</em> → <em>W</em></span>得到</li></ul></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>) = <em>H</em>(<em>X</em>|<em>Y</em>) − <em>H</em>(<em>X</em>|<em>Y</em><em>Z</em>) = 0</span></li><li><span class="math inline"><em>I</em>(<em>Y</em>; <em>W</em>|<em>Z</em>) = 0</span></li><li><span class="math inline"><em>I</em>(<em>Y</em>; <em>Z</em>) = <em>I</em>(<em>X</em><em>Y</em>; <em>Z</em>) = <em>I</em>(<em>Y</em>; <em>Z</em><em>W</em>) = <em>I</em>(<em>X</em><em>Y</em>; <em>Z</em><em>W</em>)</span><ul><li><strong>证明</strong>： <span class="math inline">$I(XY;Z) = I(Y;Z)+ I(X;Z|Y) = I(Y;Z)\\  I(Y;ZW) = I(Y;Z) + I(Y;W|Z) = I(Y;Z)$</span></li></ul></li><li><span class="math inline">$I(XY;Z|W) - I(X;Z|W) = I(Y;Z|XW) \geq 0\\  \Rightarrow I(XY;Z|W) \geq I(X;Z|W)$</span></li></ul></li></ol><h3 id="数据处理不等式-1">数据处理不等式</h3><ul><li><strong>定理</strong>：若 <span class="math inline"><em>X</em> → <em>Y</em> → <em>Z</em></span>构成马尔可夫链，则有 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) ≥ <em>I</em>(<em>X</em>; <em>Z</em>)</span>。<ul><li><strong>证明</strong>：<span class="math display">$$  \begin{align*}  &amp;\because I(X;YZ) = I(X;Y) + I(X;Z|Y)= I(X;Z) + I(X;Y|Z)\\  &amp;\therefore I(X;Y)= I(X;Z) + I(X;Y|Z) - I(X;Z|Y)\\  &amp;又\because 马尔可夫链 X \to Y \to Z 中，I(X;Z|Y) = 0 且 I(X;Y|Z)\geq 0\\  &amp;\therefore I(X;Y) \geq I(X;Z)，同理 I(Y;Z) \geq I(X;Z)  \end{align*}      $$</span></li></ul></li><li><strong>三变量马尔可夫链的信息图</strong><ul><li>对于马尔可夫链 <span class="math inline"><em>X</em> → <em>Y</em> → <em>Z</em></span>，其信息图及相关性质如下：<ul><li><figure><img src="image-5.webp" srcset="/img/loading/loading3.gif" lazyload alt="三变量马尔可夫链的信息图"><figcaption aria-hidden="true">三变量马尔可夫链的信息图</figcaption></figure></li></ul></li><li><strong>相关等式与性质</strong>：<ul><li><span class="math inline"><em>a</em><sub>1</sub></span> ：条件熵<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>X</em>|<em>Y</em>, <em>Z</em>)</span>。</li><li><span class="math inline"><em>a</em><sub>2</sub></span> ：条件互信息<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>)</span>。</li><li><span class="math inline"><em>a</em><sub>3</sub></span>：互信息<span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Y</em>; <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Y</em>) − <em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>) ≥ 0</span>。</li><li><span class="math inline"><em>a</em><sub>4</sub></span> ：条件熵<span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>, <em>Z</em>)</span>。</li><li><span class="math inline"><em>a</em><sub>5</sub></span> ：条件互信息<span class="math inline"><em>I</em>(<em>Y</em>; <em>Z</em>|<em>X</em>)</span>。</li><li><span class="math inline"><em>a</em><sub>6</sub></span> ：条件熵<span class="math inline"><em>H</em>(<em>Z</em>|<em>Y</em>) = <em>H</em>(<em>Z</em>|<em>Y</em>, <em>X</em>)</span>。</li></ul></li><li>由此可见，在马尔可夫链的信息图中，每个不相交的区域值都大于等于 0。</li></ul></li><li>例题：<img src="image-116.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h3 id="费诺不等式">费诺不等式</h3><h4 id="定义-1">定义</h4><ul><li><figure><img src="image-6.webp" srcset="/img/loading/loading3.gif" lazyload alt="定义"><figcaption aria-hidden="true">定义</figcaption></figure><ul><li>信源发出<span class="math inline"><em>X</em></span>，信宿收到<span class="math inline"><em>Y</em></span>，作出判决：认为<span class="math inline"><em>X</em></span>传出的是<span class="math inline"><em>X̂</em></span></li><li>已知 <span class="math inline"><em>p</em>(<em>X</em>, <em>Y</em>)</span>，<span class="math inline"><em>X̂</em></span> 是 <span class="math inline"><em>Y</em></span> 的函数 <span class="math display">$$  \begin{align*}  \hat{X}(y)&amp;=\arg\underset{x_{i}}{\max} p(x_{i}|y)\\  &amp;=\arg\underset{x_{i}}{\max} \frac{p(x_{i}|y)p(y)}{p(y)}\\  &amp;=\arg\underset{x_{i}}{\max} p(x_{i}, y)  \end{align*}  $$</span></li><li>设 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X̂</em></span> 取值空间同为 <span class="math inline">𝒳</span>，<span class="math inline">|𝒳|</span>表示取值个数。</li></ul></li><li><strong>定义错误概率</strong> <span class="math inline"><em>P</em><sub><em>e</em></sub> = Pr {<em>X</em> ≠ <em>X̂</em>}</span>。<ul><li>若 <span class="math inline"><em>P</em><sub><em>e</em></sub> = 0</span>，即 <span class="math inline"><em>X</em> = <em>X̂</em></span> 以概率 1 成立，<span class="math inline"><em>H</em>(<em>X</em>|<em>X̂</em>) = 0</span>。</li><li>这里讨论 <span class="math inline"><em>P</em><sub><em>e</em></sub> ≠ 0</span> 时，<span class="math inline"><em>P</em><sub><em>e</em></sub></span> 和 <span class="math inline"><em>H</em>(<em>X</em>|<em>X̂</em>)</span>之间的关系。</li></ul></li><li><strong>例题</strong>： <img src="image-117.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h4 id="费诺不等式-1">费诺不等式</h4><ul><li>设 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X̂</em></span> 取值空间同为 <span class="math inline">𝒳</span> 的随机变量，则有 <span class="math display"><em>H</em>(<em>X</em>|<em>X̂</em>) ≤ <em>H</em>(<em>P</em><sub><em>e</em></sub>) + <em>P</em><sub><em>e</em></sub>log (|𝒳|−1)</span>其中 <span class="math inline"><em>H</em>(<em>P</em><sub><em>e</em></sub>) = <em>H</em>(<em>P</em><sub><em>e</em></sub>, 1 − <em>P</em><sub><em>e</em></sub>)</span>为二元熵函数，<span class="math inline">|𝒳|</span> 为 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X̂</em></span> 的取值数量。</li><li><strong>证明1</strong>: 定义随机变量 <span class="math inline">$Z =\begin{cases}0, &amp; 若 X = \hat{X} \\ 1, &amp; 若 X \neq \hat{X}\end{cases}$</span> ，则 <span class="math inline">$P_r(Z) =\begin{cases}1 - P_e, &amp; 若 Z = 0 \\ P_e, &amp; 若 Z = 1\end{cases}$</span>，则<span class="math inline"><em>H</em>(<em>Z</em>) = <em>H</em>(<em>P</em><sub><em>e</em></sub>, 1 − <em>P</em><sub><em>e</em></sub>) = <em>H</em>(<em>P</em><sub><em>e</em></sub>)</span>由于 <span class="math inline"><em>Z</em></span> 是 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X̂</em></span> 的函数，有 <span class="math inline"><em>H</em>(<em>Z</em>|<em>X</em><em>X̂</em>) = 0</span>，则 <span class="math display">$$  \begin{align*}  H(X|\hat{X})&amp;=H(X|\hat{X})+H(Z|X\hat{X})\\  &amp;=H(XZ|\hat{X})\\  &amp;=H(Z|\hat{X})+H(X|Z\hat{X})\\  &amp;\leq H(Z)+H(X|\hat{X}Z)\\  &amp;=H(Z)+\Pr(Z = 0)H(X|\hat{X}, Z = 0)+\Pr(Z = 1)H(X|\hat{X}, Z =1)\\  &amp;=H(Z)+\Pr(Z = 1)H(X|\hat{X}, Z = 1)\\  &amp;\leq H(P_e)+P_e\log(|\mathcal{X}|-1) （其中H(X|\hat{X}, Z = 1)\leq \log(|\mathcal{X}|-1)）  \end{align*}  $$</span> 因为 <span class="math inline"><em>X</em> → <em>Y</em> → <em>X̂</em></span>构成马尔可夫链， 所以 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) ≥ <em>I</em>(<em>X</em>; <em>X̂</em>)</span>，进而 <span class="math inline"><em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) ≥ <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>X̂</em>)</span>，即 <span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>X</em>|<em>X̂</em>)</span>。</li><li><strong>证明2</strong>（不等式放缩）：见<a href="./Ch6sup_信道编码定理.md/#译码错误与信道条件的关系">译码错误与信道条件的关系</a>，其中令<span class="math inline"><em>Y</em> = <em>X̂</em></span>，<span class="math inline"><em>n</em> = |𝒳|</span></li></ul><h4 id="费诺不等式一般形式">费诺不等式（一般形式）</h4><ul><li><p>对于任何满足 <span class="math inline"><em>X</em> → <em>Y</em> → <em>X̂</em></span> 的估计量<span class="math inline"><em>X̂</em></span>，设 <span class="math inline"><em>P</em><sub><em>e</em></sub> = Pr (<em>X</em> ≠ <em>X̂</em>)</span>，有：<span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>X</em>|<em>X̂</em>) ≤ <em>H</em>(<em>P</em><sub><em>e</em></sub>) + <em>P</em><sub><em>e</em></sub>log (|𝒳|−1)</span>其中 <span class="math inline">𝒳</span> 为 <span class="math inline"><em>X</em></span> 的取值空间。</p></li><li><p>上述不等式可以减弱为： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ 1 + <em>P</em><sub><em>e</em></sub>log |𝒳|</span>或者 <span class="math display">$$P_e \geq \frac{H(X|Y) -1}{\log|\mathcal{X}|}$$</span></p></li><li><p><strong>推论</strong>：对于任意两个随机变量 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span>，设 <span class="math inline"><em>p</em> = Pr (<em>X</em> ≠ <em>Y</em>)</span>，有<span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>p</em>) + <em>p</em>log |𝒳|</span>在费诺不等式中令 <span class="math inline"><em>X̂</em> = <em>Y</em></span>，即可得到上式。</p></li></ul><h4 id="其他不等式">其他不等式</h4><ul><li><p>设 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X</em><sup>′</sup></span>为两个相互独立的随机变量，且 <span class="math inline"><em>X</em> ∼ <em>p</em>(<em>x</em>)</span>，<span class="math inline"><em>X</em><sup>′</sup> ∼ <em>r</em>(<em>x</em>)</span>，那么<span class="math inline"><em>X</em> = <em>X</em><sup>′</sup></span>的概率为 <span class="math inline">Pr (<em>X</em> = <em>X</em><sup>′</sup>) = ∑<sub><em>x</em></sub><em>p</em>(<em>x</em>)<em>r</em>(<em>x</em>)</span>，有如下不等式：</p><ol type="1"><li>如果 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X</em><sup>′</sup></span>独立同分布，具有相同的熵 <span class="math inline"><em>H</em>(<em>X</em>)</span>，则 <span class="math inline"><em>X</em> = <em>X</em><sup>′</sup></span> 的概率为<span class="math inline">Pr (<em>X</em> = <em>X</em><sup>′</sup>) = ∑<sub><em>x</em></sub><em>p</em><sup>2</sup>(<em>x</em>)</span>，且有<span class="math display">Pr (<em>X</em> = <em>X</em><sup>′</sup>) ≥ 2<sup>−<em>H</em>(<em>X</em>)</sup></span>当且仅当 <span class="math inline"><em>X</em></span>服从均匀分布，等号成立。<ul><li><strong>证明</strong>： 假定 <span class="math inline"><em>X</em> ∼ <em>p</em>(<em>x</em>)</span>，由Jensen不等式，令<span class="math inline"><em>f</em>(<em>y</em>) = 2<sup><em>y</em></sup></span>为下凸函数。 则 <span class="math inline"><em>f</em>(<em>E</em>(<em>Y</em>)) ≤ <em>E</em>(<em>f</em>(<em>Y</em>))</span>，令 <span class="math inline"><em>y</em> = log <em>p</em>(<em>x</em>)</span>，则有：<span class="math display">$$  \begin{align*}  2^{-H(X)}&amp;=2^{\sum_{x} p(x)\log p(x)}\\  &amp;\leq \sum_{x} p(x)2^{\log p(x)}\\  &amp;=\sum_{x} p(x)p(x)\\  &amp;=\sum_{x} p^2(x)\\  &amp;=\Pr(X = X')  \end{align*}  $$</span> 所以 <span class="math inline">2<sup>−<em>H</em>(<em>X</em>)</sup> ≤ Pr (<em>X</em> = <em>X</em><sup>′</sup>)</span>，当且仅当 <span class="math inline"><em>X</em></span>服从均匀分布时，Jensen不等式取等，上式等号成立。</li></ul></li><li>设 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X</em><sup>′</sup></span> 相互独立，且 <span class="math inline"><em>X</em> ∼ <em>p</em>(<em>x</em>)</span>，<span class="math inline"><em>X</em><sup>′</sup> ∼ <em>r</em>(<em>x</em>)</span>，<span class="math inline"><em>x</em>, <em>x</em><sup>′</sup> ∈ 𝒳</span>，则<span class="math display">$$\Pr(X = X') \geq 2^{-H(p)-D(p||r)}\\\Pr(X = X') \geq 2^{-H(r)-D(r||p)}$$</span><ul><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  2^{-H(p)-D(p||r)}&amp;=2^{\sum p(x)\log p(x)+\sum p(x)\log\frac{r(x)}{p(x)}}\\  &amp;=2^{\sum p(x)\log r(x)}\\  &amp;\leq \sum p(x)2^{\log r(x)}\\  &amp;=\sum p(x)r(x)\\  &amp;=\Pr(X = X')  \end{align*}  $$</span></li></ul></li></ol></li><li><p><strong>例题</strong>：<img src="image-118.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="离散序列信源的熵">2.4 离散序列信源的熵</h2><h3 id="离散无记忆信源的序列熵">离散无记忆信源的序列熵</h3><ul><li><p>随机序列<span class="math inline">$\vec{X_{}}=(X_1, X_2, \cdots,X_L)$</span>，其中<span class="math inline"><em>X</em><sub><em>l</em></sub> ∈ {<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>}</span>，<span class="math inline"><em>l</em> = 1, 2, ⋯, <em>L</em></span></p></li><li><p><span class="math inline">$p(\vec{X_{}}=\vec{x_{i}}) = p(X_1 =x_{i1}, X_2 = x_{i2}, \cdots, X_L = x_{iL})$</span>，这里<span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em><sup><em>L</em></sup></span>，<span class="math inline"><em>i</em><sub><em>l</em></sub> = 1, 2, ⋯, <em>n</em></span></p></li><li><p><strong>定义信息熵<span class="math inline">$H(\vec{X_{}})$</span>为</strong>： <span class="math display">$$  \begin{align*}  H(\vec{X_{}}) &amp;= -\sum_{i = 1}^{n^L}p(\vec{x_{i}})\logp(\vec{x_{i}})\\  &amp;=-\sum_{i_1 = 1}^{n}\sum_{i_2 = 1}^{n}\cdots\sum_{i_L =1}^{n}p(x_{i1}, x_{i2}, \cdots, x_{iL})\log p(x_{i1}, x_{i2}, \cdots,x_{iL})  \end{align*}  $$</span></p></li><li><p><span class="math display">$$\begin{align*}p(\vec{X_{}}=\vec{x_{i}})&amp;=p(x_{i1}, x_{i2}, \cdots, x_{iL})\\&amp;=p(x_{i1})p(x_{i2}|x_{i1})p(x_{i3}|x_{i1}x_{i2})\cdotsp(x_{iL}|x_{i1}x_{i2}\cdots x_{iL - 1})\\&amp;\overset{无记忆}{=}p(x_{i1})p(x_{i2})\cdots p(x_{iL})\end{align*}$$</span> 则 <span class="math display">$$\begin{align*}H(\vec{X_{}})&amp;=-\sum_{i_1 = 1}^{n}\sum_{i_2 = 1}^{n}\cdots\sum_{i_L= 1}^{n}p(x_{i1})p(x_{i2})\cdots p(x_{iL})[\log p(x_{i1})+\logp(x_{i2})\\&amp;\quad +\cdots+\log p(x_{iL})]\\&amp;=-\sum_{i_1 = 1}^{n}p(x_{i1})\sum_{i_2 =1}^{n}p(x_{i2})\cdots\sum_{i_L = 1}^{n}p(x_{iL})\log p(x_{i1}) \quad\leftarrow H(X_1)\\&amp;\quad -\sum_{i_1 = 1}^{n}p(x_{i1})\sum_{i_2 =1}^{n}p(x_{i2})\cdots\sum_{i_L = 1}^{n}p(x_{iL})\log p(x_{i2}) \quad\leftarrow H(X_2)\\&amp;\quad -\cdots\\&amp;=H(X_1)+H(X_2)+\cdots+H(X_L)\\&amp;=\sum_{l = 1}^{L}H(X_l)\end{align*}$$</span></p></li><li><p>若信源是平稳的，即<span class="math inline"><em>H</em>(<em>X</em><sub>1</sub>) = <em>H</em>(<em>X</em><sub>2</sub>) = ⋯ = <em>H</em>(<em>X</em><sub><em>L</em></sub>) = <em>H</em>(<em>X</em>)</span>，则<span class="math display">$$H(\vec{X_{}}) = L H(X)$$</span> <strong>用 <span class="math inline">$H_L(\vec{X_{}})$</span> 表示长度为 <span class="math inline"><em>L</em></span>的序列平均每个符号的熵</strong>，则 <span class="math display">$$H_L(\vec{X_{}})=\frac{1}{L}H(\vec{X_{}}) =H(X)$$</span></p></li><li><p>例题：<img src="image-119.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h3 id="离散有记忆信源的序列熵">离散有记忆信源的序列熵</h3><ul><li>长度为 <span class="math inline"><em>L</em></span> 的符号序列 <span class="math inline">$\vec{X_{}}=(X_1,X_2,\cdots,X_L)$</span> <span class="math display">$$  \begin{align*}  H(\vec{X_{}})&amp;=H(X_1,X_2,X_3,\cdots,X_L)\\  &amp;=H(X_1)+H(X_2|X_1)+H(X_3|X_1X_2)+\cdots+H(X_L|X_1X_2,\cdots,X_{L- 1})  \end{align*}  $$</span></li><li>记作 <span class="math display">$$H(\vec{X_{}}) = H(X^L)=\sum_{l =1}^{L}H(X_l|X^{l - 1})$$</span></li><li>平均每个符号的熵 <span class="math display">$$H_L(\vec{X_{}})=\frac{1}{L}H(X^L)$$</span></li><li>例题：<img src="image-120.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h3 id="离散平稳信源序列熵">离散平稳信源序列熵</h3><h4 id="定义-2">定义</h4><ul><li><strong>离散平稳信源</strong>：联合概率具有时间推移不变性。 <span class="math display"><em>p</em>{<em>X</em><sub><em>i</em>1</sub> = <em>x</em><sub>1</sub>, <em>X</em><sub><em>i</em>2</sub> = <em>x</em><sub>2</sub>, ⋯, <em>X</em><sub><em>i</em><em>L</em></sub> = <em>x</em><sub><em>L</em></sub>} = <em>p</em>{<em>X</em><sub><em>i</em>1 + <em>k</em></sub> = <em>x</em><sub>1</sub>, <em>X</em><sub><em>i</em>2 + <em>k</em></sub> = <em>x</em><sub>2</sub>, ⋯, <em>X</em><sub><em>i</em><em>L</em> + <em>k</em><em>h</em></sub> = <em>x</em><sub><em>L</em></sub>}</span></li></ul><h4 id="结论-1">结论</h4><ol type="1"><li><span class="math inline"><em>H</em>(<em>X</em><sub><em>L</em></sub>|<em>X</em><sup><em>L</em> − 1</sup>)</span>是 <span class="math inline"><em>L</em></span> 的单调非增函数<ul><li>依据：条件多的熵小于等于条件少的熵，平稳信源联合/条件概率时间推移不变</li><li><strong>证明</strong>：<span class="math display">$$  \begin{align*}  H(X_L|X_1X_2\cdots X_{L - 1})&amp;\leq H(X_L|X_2X_3\cdots X_{L - 1})\\  &amp;= H(X_{L - 1}|X_1X_2\cdots X_{L - 2}) \text{（平稳性）}\\  &amp;\leq H(X_{L - 1}|X_2\cdots X_{L - 2})\\  &amp;= H(X_{L - 2}|X_1\cdots X_{L - 3})\\  &amp;\vdots\\  &amp;\leq H(X_2|X_1)  \end{align*}  $$</span></li></ul></li><li><span class="math inline">$H_L(\vec{X_{}}) \geq H(X_L|X^{L -1})$</span><ul><li><strong>证明</strong>：<span class="math display">$$  \begin{align*}  H_L(\vec{X_{}})&amp;=\frac{1}{L}H(X_1,X_2,\cdots,X_L)\\  &amp;=\frac{1}{L}\sum_{l = 1}^{L}H(X_l|X^{l - 1})\\  &amp;=\frac{1}{L}(H(X_1)+H(X_2|X_1)+H(X_3|X_1,X_2)+\cdots+H(X_L|X_1X_2,\cdots,X_{L- 1}))\\  &amp;\geq\frac{1}{L}\cdot L\cdot H(X_L|X_1,X_2,\cdots,X_{L - 1})\\  &amp;= H(X_L|X_1,X_2,\cdots,X_{L - 1})  \end{align*}  $$</span></li></ul></li><li><span class="math inline">$H_L(\vec{X_{}})$</span> 是 <span class="math inline"><em>L</em></span> 的单调非增函数<ul><li><strong>证明</strong>：<span class="math display">$$  \begin{align*}  L H_L(\vec{X_{}})&amp;=H(X_1,X_2,\cdots,X_L)\\  &amp;=H(X_1,X_2,\cdots,X_{L - 1})+H(X_L|X_1,X_2,\cdots,X_{L - 1})\\  &amp;=(L - 1)H_{L - 1}(\vec{X_{}})+H(X_L|X_1,X_2,\cdots,X_{L - 1})\\  &amp;\leq (L - 1)H_{L - 1}(\vec{X_{}})+H_L(\vec{X_{}})\\  \therefore (L - 1)H_L(\vec{X_{}})&amp;\leq (L - 1)H_{L -1}(\vec{X_{}})\\  H_L(\vec{X_{}})&amp;\leq H_{L - 1}(\vec{X_{}})  \end{align*}  $$</span></li></ul></li><li>当 <span class="math inline"><em>L</em> → ∞</span> 时，定义<span class="math inline">$H_{\infty}(\vec{X_{}})$</span>为<strong>极限熵</strong>，有<span class="math display">$$H_{\infty}(\vec{X_{}}) \triangleq \lim_{L \to \infty}H_{L}(\vec{X_{}})=\lim_{L \to \infty} H(X_L|X_1,X_2,\cdots,X_{L - 1})$$</span><ul><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  H_{L + k}(\vec{X_{}})&amp;=\frac{1}{L + k}[H(X_1,X_2,\cdots,X_{L -1})+H(X_L|X_1X_2\cdots X_{L - 1})+\\  &amp;\quad \cdots + H(X_{L + k}|X_1X_2\cdots X_{L + k - 1})]\\  &amp;\leq\frac{1}{L + k}[H(X_1,X_2,\cdots,X_{L -1})+H(X_L|X_1X_2\cdots X_{L - 1})+\\  &amp;\quad H(X_L|X_1X_2,\cdots,X_{L - 1})+\cdots + H(X_L|X_1\cdotsX_{L - 1})]\\  &amp;=\frac{1}{L + k}H(X_1,X_2,\cdots,X_{L - 1})+\frac{k + 1}{L +k}H(X_L|X_1,X_2,\cdots,X_{L - 1})  \end{align*}  $$</span> 当 <span class="math inline"><em>k</em> → ∞</span> 时，<span class="math inline">$\lim_{k \to \infty} H_{L + k}(\vec{X_{}}) \leqH(X_L|X_1,X_2,\cdots,X_{L - 1}) \leq H_{L}(\vec{X_{}})$</span> 当 <span class="math inline"><em>L</em> → ∞</span> 时，<span class="math inline">$H_{L}(\vec{X_{}}) = H_{L +k}(\vec{X_{}})$</span>，得到 <span class="math display">$$  \lim_{L \to \infty} H_{L}(\vec{X_{}})=\lim_{L \to \infty}H(X_L|X_1,X_2,\cdots,X_{L - 1})  $$</span></p><p>若<span class="math inline"><em>H</em><sub>0</sub>(<em>X</em>)</span>为等概率无记忆信源单个符号熵，有 <span class="math display">$$  H_0(X) \geq H_1(X) \geq H_2(\vec{X_{}}) \geq H_3(\vec{X_{}}) \cdots\geq H_{\infty}(\vec{X_{}})  $$</span></p><p><strong>只有极限熵最真实地反映信源的实际情况。</strong></p></li></ul></li></ol><h3 id="马尔可夫信源的极限熵">马尔可夫信源的极限熵</h3><ul><li><p><strong>定义</strong>： <span class="math display">$$  H_{\infty}(\vec{X_{}})=\lim_{L \to \infty} H_{L}(\vec{X_{}}) = \lim_{L\to \infty} H(X_L|X_1,X_2,\cdots,X_{L - 1})  $$</span></p></li><li><p>实际常取有限长度 <span class="math inline"><em>L</em></span>下的条件熵 <span class="math inline"><em>H</em>(<em>X</em><sub><em>L</em></sub>|<em>X</em><sup><em>L</em> − 1</sup>)</span>作为 <span class="math inline">$H_{\infty}(\vec{X_{}})$</span>的近似值。</p></li><li><p><strong>m阶马尔可夫信源（齐次）的推导</strong> <span class="math display"><em>p</em>(<em>X</em><sub><em>t</em></sub>|<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>t</em> − 1</sub>) = <em>p</em>(<em>X</em><sub><em>t</em></sub>|<em>X</em><sub><em>t</em> − <em>m</em></sub>, ⋯, <em>X</em><sub><em>t</em> − 1</sub>)</span><span class="math display">$$  \begin{align*}  H_{\infty}(\vec{X_{}})&amp;=\lim_{L \to \infty}H(X_L|X_1,X_2,\cdots,X_{L - 1}) \\  &amp;= \lim_{L \to \infty} H(X_L|X_{L - m},\cdots,X_{L - 1})\\  &amp;=H(X_{m + 1}|X_1,X_2,\cdots,X_m)  \end{align*}  $$</span></p><p>对于齐次、稳定马尔可夫链，其状态 <span class="math inline"><em>s</em><sub><em>i</em></sub></span> 由 <span class="math inline">(<em>x</em><sub><em>i</em>1</sub>, <em>x</em><sub><em>i</em>2</sub>, ⋯, <em>x</em><sub><em>i</em><em>m</em></sub>)</span>唯一确定，所以 <span class="math display"><em>p</em>(<em>x</em><sub><em>i</em><sub><em>m</em> + 1</sub></sub>|<em>x</em><sub><em>i</em>1</sub>, <em>x</em><sub><em>i</em>2</sub>, ⋯, <em>x</em><sub><em>i</em><em>m</em></sub>) = <em>p</em>(<em>x</em><sub><em>i</em><sub><em>m</em> + 1</sub></sub>|<em>s</em><sub><em>i</em></sub>)</span></p><p>上式两边同时取对数，并对 <span class="math inline"><em>x</em><sub><em>i</em>1</sub>, ⋯, <em>x</em><sub><em>i</em><em>m</em></sub>, <em>x</em><sub><em>i</em><sub><em>m</em> + 1</sub></sub></span>和 <span class="math inline"><em>s</em><sub><em>i</em></sub></span>取统计平均，再取负，得到：</p><p><span class="math display">$$  \begin{align*}  \mathbf{Left}&amp;=-\sum_{i_1,\cdots,i_{m + 1}}p(x_{i1},x_{i2},\cdots,x_{im},x_{i_{m + 1}},s_i) \log p(x_{i_{m +1}}|x_{i1},x_{i2},\cdots,x_{im})\\  &amp;=-\sum_{i_1,\cdots,i_{m + 1}} p(x_{i1},\cdots,x_{i_{m + 1}}) \logp(x_{i_{m + 1}}|x_{i1},\cdots,x_{im})\\  &amp;=H(X_{m + 1}|X_1,X_2,\cdots,X_m)\\  &amp;=H_{\infty}(\vec{X_{}})\\  \mathbf{Right}&amp;=-\sum_{i_1,\cdots,i_{m + 1};i}p(x_{i1},x_{i2},\cdots,x_{i_{m + 1}},s_i) \log p(x_{i_{m + 1}}|s_i)\\  &amp;=-\sum_{i_1,\cdots,i_{m + 1};i}p(x_{i1},x_{i2},\cdots,x_{im},s_i) p(x_{i_{m +1}}|x_{i1},x_{i2},\cdots,x_{im},s_i) \log p(x_{i_{m + 1}}|s_i)\\  &amp;=-\sum_{i_{m + 1}} \sum_{i} p(s_i) p(x_{i_{m + 1}}|s_i) \logp(x_{i_{m + 1}}|s_i)\\  &amp;=\sum_{i} p(s_i) \sum_{i_{m + 1}} p(x_{i_{m + 1}}|s_i) \log\frac{1}{p(x_{i_{m + 1}}|s_i)}\\  &amp;=\sum_{i} p(s_i) H(X|s_i)  \end{align*}  $$</span></p><p><span class="math display">$$  \begin{align*}  \therefore H_{\infty}(\vec{X_{}}) &amp;= \sum_{i} p(s_i) H(X|s_i)\\  H(X|s_i)&amp;=-\sum_{j} p(x_j|s_i)\log p(x_j|s_i) \\  &amp;= -\sum_{j} p(s_j|s_i)\log p(s_j|s_i)  \end{align*}  $$</span></p></li><li><p>例题： <img src="image-10.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="连续信源的熵和互信息">2.5 连续信源的熵和互信息</h2><h3 id="微分熵连续信源熵">微分熵（连续信源熵）</h3><ul><li>详见 <strong><a href="Ch2sup_微分熵.md">第二章补充微分熵</a></strong></li><li>微分熵即连续信源熵，记作 <span class="math inline"><em>h</em>(<em>X</em>)</span> 或 <span class="math inline"><em>H</em><sub><em>c</em></sub>(<em>X</em>)</span>。</li></ul><h3 id="幅度连续的单符号信源">幅度连续的单符号信源</h3><h4 id="连续信源熵">连续信源熵</h4><ul><li><strong>定义</strong>：<ul><li>用n个离散变量逼近连续变量，概率密度函数为 <span class="math inline"><em>P</em><sub><em>X</em></sub>(<em>x</em>)</span><ul><li><figure><img src="image-8.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul></li><li>设 <span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = ∫<sub><em>a</em> + (<em>i</em> − 1)<em>Δ</em><em>x</em></sub><sup><em>a</em> + <em>i</em><em>Δ</em><em>x</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em> = <em>P</em><sub><em>X</em></sub>(<em>x</em><sub><em>i</em></sub>)<em>Δ</em><em>x</em></span></li><li>离散熵 <span class="math display">$$H_n(X)=-\sum_{i =1}^{n}p(x_i)\log p(x_i)=-\sum_{i = 1}^{n}P_X(x_i)\Delta x\log(P_X(x_i)\Delta x)$$</span></li><li>当 <span class="math inline"><em>n</em> → ∞</span>，<span class="math inline"><em>Δ</em><em>x</em> → 0</span> 时： <span class="math display"><em>H</em>(<em>X</em>) = lim<sub><em>n</em> → ∞</sub><em>H</em><sub><em>n</em></sub>(<em>X</em>) = −∫<sub><em>a</em></sub><sup><em>b</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)log <em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em> − lim<sub><em>Δ</em><em>x</em> → 0</sub>log <em>Δ</em><em>x</em>∫<sub><em>a</em></sub><sup><em>b</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em></span>其中 <span class="math inline">∫<sub><em>a</em></sub><sup><em>b</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em> = 1</span>，后一项趋于无穷大。</li><li><strong>定义连续信源熵为</strong> <span class="math display"><em>H</em><sub><em>c</em></sub>(<em>X</em>) = −∫<sub>−∞</sub><sup>∞</sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)log <em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em></span></li></ul></li><li><strong>性质</strong>：<ul><li>连续信源不确定度为无穷大，熵为无穷大，需要无限多位二进制数表示。</li><li>连续信源的熵具有相对性（只有相对意义），在取两熵之差时才具有信息的所有特征。</li></ul></li></ul><h4 id="联合熵条件熵和互信息">联合熵、条件熵和互信息</h4><ul><li><strong>联合熵</strong>： <span class="math display"><em>H</em><sub><em>c</em></sub>(<em>X</em>, <em>Y</em>) = −∫<sub>−∞</sub><sup>∞</sup>∫<sub>−∞</sub><sup>∞</sup><em>P</em><sub><em>X</em>, <em>Y</em></sub>(<em>x</em>, <em>y</em>)log <em>P</em><sub><em>X</em>, <em>Y</em></sub>(<em>x</em>, <em>y</em>)<em>d</em><em>x</em><em>d</em><em>y</em></span></li><li><strong>条件熵</strong>： <span class="math display"><em>H</em><sub><em>c</em></sub>(<em>Y</em>|<em>X</em>) = −∫<sub>−∞</sub><sup>∞</sup>∫<sub>−∞</sub><sup>∞</sup><em>P</em><sub><em>X</em>, <em>Y</em></sub>(<em>x</em>, <em>y</em>)log <em>P</em><sub><em>Y</em></sub>(<em>y</em>|<em>x</em>)<em>d</em><em>x</em><em>d</em><em>y</em></span><span class="math display"><em>H</em><sub><em>c</em></sub>(<em>X</em>, <em>Y</em>) = <em>H</em><sub><em>c</em></sub>(<em>X</em>) + <em>H</em><sub><em>c</em></sub>(<em>Y</em>|<em>X</em>) = <em>H</em><sub><em>c</em></sub>(<em>Y</em>) + <em>H</em><sub><em>c</em></sub>(<em>X</em>|<em>Y</em>)</span></li><li><strong>互信息</strong>： <span class="math display">$$  \begin{align*}  I(X;Y)=I(Y;X)&amp;=H_c(X)-H_c(X|Y)\\  &amp;=H_c(Y)-H_c(Y|X)\\  &amp;=H_c(X)+H_c(Y)-H_c(X,Y)  \end{align*}  $$</span></li></ul><h3 id="波形信源的熵">波形信源的熵</h3><ul><li>平稳随机过程通过采样变换可得到平稳随机序列，例如：<ul><li>随机过程 <span class="math inline"><em>x</em>(<em>t</em>)</span>变换为 <span class="math inline">$\vec{X_{}}(X_1, X_2, \cdots,X_L)$</span> 。</li><li>随机过程 <span class="math inline"><em>y</em>(<em>t</em>)</span>变换为 <span class="math inline">$\vec{Y_{}}(Y_1, Y_2, \cdots,Y_L)$</span> 。</li></ul></li><li><figure><img src="image-9.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li>相关熵的计算公式如下：<ul><li><span class="math inline">$H_c(\vec{X_{}}) = H_c(X_1, X_2, \cdots,X_L)=-\int_{\vec{R_{}}} P_{\vec{X_{}}}(\vec{x_{}})\logP_{\vec{X_{}}}(\vec{x_{}})d\vec{x_{}}$</span></li><li><span class="math inline">$H_c(\vec{Y_{}}|\vec{X_{}}) = H_c(Y_1,Y_2, \cdots, Y_L|X_1, X_2, \cdots,X_L)=-\int_{\vec{R_{}}}\int_{\vec{R_{}}}P_{\vec{X_{}}\vec{Y_{}}}(\vec{x_{}}, \vec{y_{}})\logP_{\vec{Y_{}}}(\vec{y_{}}|\vec{x_{}})d\vec{x_{}}d\vec{y_{}}$</span></li></ul></li><li>波形信源熵由上述各项的极限表达式（<span class="math inline"><em>L</em> → ∞</span> ）给出：<ul><li><span class="math inline">$H_c(x(t)) \triangleq \lim_{L \to \infty}H_c(\vec{X_{}})$</span></li><li><span class="math inline">$H_c(y(t)|x(t)) \triangleq \lim_{L \to\infty} H_c(\vec{Y_{}}|\vec{X_{}})$</span></li></ul></li><li>对于<strong>限频 <span class="math inline"><em>f</em><sub><em>m</em></sub></span>，限时 <span class="math inline"><em>t</em><sub><em>B</em></sub></span></strong>的平稳随机过程，可用 <span class="math inline"><em>L</em> = 2<em>f</em><sub><em>m</em></sub><em>t</em><sub><em>B</em></sub></span>随机矢量表示，且有： <span class="math display">$$  \begin{align*}  H_c(\vec{X_{}}) =&amp; H_c(X_1, X_2, \cdots, X_L)\\  =&amp;H_c(X_1)+H_c(X_2|X_1)+H_c(X_3|X_1X_2)+\\  &amp;\cdots+H_c(X_L|X_1,X_2,\cdots,X_{L - 1})\\  \leq&amp; H_c(X_1)+H_c(X_2)+\cdots + H_c(X_L)  \end{align*}  $$</span></li></ul><h3 id="最大熵定理连续信源">最大熵定理(连续信源)</h3><ol type="1"><li><strong>无限制条件时</strong>：<strong>最大熵为无穷大</strong>。</li><li><strong>限峰功率最大熵定理</strong><ul><li><strong>对于定义域为有限的随机变量 <span class="math inline"><em>X</em></span>，当它是均匀分布时，具有最大熵。</strong></li><li><span class="math inline"><em>X</em></span> 幅度取值限制在 <span class="math inline">[<em>a</em>, <em>b</em>]</span>，有 <span class="math inline">∫<sub><em>a</em></sub><sup><em>b</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em> = 1</span>。</li><li>当 <span class="math inline">$P_X(x)=\begin{cases}\frac{1}{b -a},&amp;a\leq x\leq b\\0,&amp;其他\end{cases}$</span> 时，信息熵最大，<span class="math display">$$H_c(X)=-\int_{a}^{b}\frac{1}{b -a}\log\frac{1}{b - a}dx=\log(b - a)$$</span></li></ul></li><li><strong>限平均功率最大熵定理</strong><ul><li><p><strong>对于相关矩阵一定的随机变量 <span class="math inline"><em>X</em></span>，当它是正态分布时具有最大熵。</strong></p></li><li><p>概率密度函数 <span class="math inline">$P_X(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x -\mu)^2}{2\sigma^2}}$</span></p><ul><li>其中 <span class="math inline"><em>μ</em></span> 为均值，<span class="math inline"><em>σ</em><sup>2</sup></span> 为方差，<span class="math inline"><em>σ</em><sup>2</sup> = ∫(<em>x</em> − <em>μ</em>)<sup>2</sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em></span>。</li></ul></li><li><p>信息熵 <span class="math inline"><em>H</em><sub><em>c</em></sub>(<em>X</em>)</span>的计算过程如下： <span class="math display">$$\begin{align*}H_c(X)&amp;=-\int_{-\infty}^{+\infty}P_X(x)\log P_X(x)dx\\&amp;=E[-\log P_X(x)]\\&amp;=E\left[-\log\frac{1}{\sqrt{2\pi\sigma^2}}-\log e^{-\frac{(x -m)^2}{2\sigma^2}}\right]\\&amp;=E\left[\frac{1}{2}\log(2\pi\sigma^2)+\frac{(x -m)^2}{2\sigma^2}\log e\right]\\&amp;=\frac{1}{2}\log(2\pi\sigma^2)+\frac{\log e}{2}\\&amp;=\frac{1}{2}\log(2\pi e\sigma^2)\end{align*}$$</span></p></li><li><p><strong>证明</strong>： 设 <span class="math inline"><em>φ</em>(<em>x</em>) ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span>，<span class="math inline"><em>g</em>(<em>x</em>)</span> 满足 <span class="math inline">∫<em>x</em><sup>2</sup><em>g</em>(<em>x</em>)<em>d</em><em>x</em> = <em>σ</em><sup>2</sup></span>，因为 <span class="math inline"><em>D</em>(<em>g</em>(<em>x</em>)∥<em>φ</em>(<em>x</em>)) ≥ 0</span>，即：<span class="math display">$$  \begin{align*}  D(g(x)\|\varphi(x))&amp;=\int_{-\infty}^{+\infty}g(x)\log\frac{g(x)}{\varphi(x)}dx\\  &amp;=\int_{-\infty}^{+\infty}g(x)\logg(x)dx-\int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx\\  &amp;=-H_c(g(x))-\int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx\\  &amp;\geq0\\  \therefore \quadH_c(g(x))&amp;\leq-\int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx  \end{align*}  $$</span></p><p>又因为</p><p><span class="math display">$$  \begin{align*}  \int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx &amp;=\int_{-\infty}^{+\infty}g(x)\log\left(\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}\right)dx\\  &amp;=\int_{-\infty}^{+\infty}g(x)\left[-\frac{1}{2}\log(2\pi\sigma^2)-\frac{x^2}{2\sigma^2}\loge\right]dx\\  &amp;=-\frac{1}{2}\log(2\pi\sigma^2)\int_{-\infty}^{+\infty}g(x)dx-\frac{\loge}{2\sigma^2}\int_{-\infty}^{+\infty}x^2g(x)dx\\  &amp;=-\frac{1}{2}\log(2\pi e\sigma^2)  \end{align*}  $$</span></p><p>所以 <span class="math inline">$H_c(g(x))\leq\frac{1}{2}\log(2\pie\sigma^2)=H_c(\varphi(x))$</span>，当且仅当 <span class="math inline"><em>g</em>(<em>x</em>) = <em>φ</em>(<em>x</em>)</span>，为正态分布时等号成立。</p></li></ul></li></ol><h2 id="信源的冗余度">2.6 信源的冗余度</h2><ul><li><p>冗余度也称多余度或剩余度，表示给定信源在实际发出消息时所包含的多余信息。</p></li><li><p><strong>例子</strong>：英文字母26个，加上空格共27个符号，则<strong>单符号最大熵</strong>为<span class="math display"><em>H</em><sub>0</sub>(<em>X</em>) = log<sub>2</sub>27 ≈ 4.76bit/符号</span></p><p>对英文书中各符号出现的概率加以统计，可得一组数值。若字母间无记忆，有<span class="math display">$$H_1(X)= - \sum_{i = 1}^{n}p_i\log p_i =4.03 \text{ bit/符号}$$</span></p><p>若考虑2阶、3阶直至高阶平稳信源，有 <span class="math display">$$  \begin{align*}  &amp;H_2(X)= 3.32 \text{ bit/符号}\\  &amp;H_3(X)= 3.1 \text{ bit/符号}\\  &amp;\cdots\\  &amp;H_{\infty}(X)=1.4 \text{ bit/符号}\\  \end{align*}  $$</span></p><p>且满足 <span class="math inline"><em>H</em><sub>∞</sub> &lt; ⋯ &lt; <em>H</em><sub>3</sub>(<em>X</em>) &lt; <em>H</em><sub>2</sub>(<em>X</em>) &lt; <em>H</em><sub>1</sub>(<em>X</em>) &lt; <em>H</em><sub>0</sub>(<em>X</em>)</span></p><p>若发送消息时用 <span class="math inline"><em>H</em><sub>0</sub>(<em>X</em>) = 4.76 bit</span>表示一个信源符号，则信源效率为 <span class="math display">$$\eta =\frac{H_{\infty}(X)}{H_0(X)}=\frac{1.4}{4.76}\approx0.29$$</span></p><p>冗余度<span class="math display"><em>γ</em> = 1 − <em>η</em> = 0.71</span></p><p>这是因为符号间的相关性、分布不均匀性</p></li><li><p><strong>信源编码</strong>：压缩冗余，提高传输效率</p></li><li><p><strong>信道编码</strong>：加入特殊的冗余，抗干扰，提高可靠性</p></li></ul><h1 id="第二章补充-微分熵">第二章补充 微分熵</h1><h2 id="微分熵预备知识">微分熵预备知识</h2><h3 id="定义-3">定义</h3><ol type="1"><li><strong>随机变量 <span class="math inline"><em>X</em></span> 的均值<span class="math inline"><em>μ</em></span></strong>：<ul><li>定义为 <span class="math display"><em>μ</em> = <em>E</em>(<em>X</em>) = ∫<em>x</em><em>f</em>(<em>x</em>)<em>d</em><em>x</em></span>其中 <span class="math inline"><em>f</em>(<em>x</em>)</span> 为 <span class="math inline"><em>X</em></span> 的概率密度函数。</li></ul></li><li><strong>随机变量 <span class="math inline"><em>X</em></span>的方差</strong>：<ul><li>定义为 <span class="math display">$$  \begin{align*}  Var(X)&amp;=E(X - EX)^2 \\  &amp;= E(X - \mu)^2\\  &amp;=E(X^{2}-2X\mu+\mu^{2})\\  &amp;=E(X^{2})-\mu^{2}  \end{align*}  $$</span></li></ul></li><li><strong>两个随机变量 <span class="math inline"><em>X</em></span> 和<span class="math inline"><em>Y</em></span> 之间的协方差</strong>：<ul><li>定义为 <span class="math display"><em>C</em><em>o</em><em>v</em>(<em>X</em>, <em>Y</em>) = <em>E</em>(<em>X</em> − <em>E</em><em>X</em>)(<em>Y</em> − <em>E</em><em>Y</em>) = <em>E</em>(<em>X</em><em>Y</em>) − <em>μ</em><sub><em>X</em></sub><em>μ</em><sub><em>Y</em></sub></span></li></ul></li><li><strong>对于随机变量 <span class="math inline">$\vec{X_{}}=[X_1,X_2,\cdots,X_n]^T$</span>（列向量）</strong>：<ul><li>其<strong>协方差矩阵</strong>定义为 <span class="math display">$$K_{\vec{X_{}}}=E(\vec{X_{}}-E\vec{X_{}})(\vec{X_{}}-E\vec{X_{}})^T= [Cov(X_i,X_j)]$$</span></li><li>其<strong>相关矩阵</strong>定义为 <span class="math display">$$\widetilde{K}_{\vec{X_{}}}=E(\vec{X_{}}\vec{X_{}}^T)=[E(X_iX_j)]$$</span></li><li>若 <span class="math inline">$E(\vec{X_{}})=\vec{\mu_{}}=\vec{0_{}}$</span>，则<span class="math inline">$K_{\vec{X_{}}}=\widetilde{K}_{\vec{X_{}}}$</span></li></ul></li><li><strong>高斯分布</strong></li></ol><ul><li><p>令 <span class="math inline"><em>N</em>(<em>μ</em>, <em>σ</em><sup>2</sup>)</span>表示均值为 <span class="math inline"><em>μ</em></span>，方差为 <span class="math inline"><em>σ</em><sup>2</sup></span>的<strong>高斯（正态）分布</strong>，即它的概率密度函数为 <span class="math display">$$f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{(x- \mu)^{2}}{2\sigma^{2}}}$$</span></p></li><li><p>令 <span class="math inline">$N(\vec{\mu_{}},K)$</span>表示均值为 <span class="math inline">$\vec{\mu_{}}$</span>，协方差矩阵为<span class="math inline"><em>K</em></span>的<strong>多元高斯分布</strong>，即对所有的 <span class="math inline">$\vec{x_{}}\in R^n$</span>，其联合概率密度函数为<span class="math display">$$f(\vec{x_{}})=\frac{1}{(\sqrt{2\pi})^n|K|^{\frac{1}{2}}}e^{-\frac{1}{2}(\vec{x_{}}-\vec{\mu_{}})^TK^{-1}(\vec{x_{}}-\vec{\mu_{}})}$$</span></p><p>其中 <span class="math inline">|<em>K</em>|</span> 表示 <span class="math inline"><em>K</em></span> 的行列式值，<span class="math inline"><em>K</em></span> 是正定对称矩阵。</p></li></ul><h3 id="基本结论">基本结论</h3><ul><li>以下是关于矩阵和随机变量的线性变换的基本结论。所有的量和相关矩阵都假定为实值</li></ul><h4 id="定义-4">定义</h4><ul><li><strong>定义（对称矩阵）</strong>：如果 <span class="math inline"><em>K</em><sup><em>T</em></sup> = <em>K</em></span>，则称矩阵<span class="math inline"><em>K</em></span> 是对称的。</li><li><strong>定义（正定矩阵）</strong>：<ul><li>一个 <span class="math inline"><em>n</em> × <em>n</em></span> 矩阵<span class="math inline"><em>K</em></span>，如果对所有非零 <span class="math inline"><em>n</em></span> 维列向量 <span class="math inline">$\vec{x_{}}$</span>，<span class="math inline">$\vec{x_{}}^TK\vec{x_{}}&gt;0$</span> 成立，则称矩阵<span class="math inline"><em>K</em></span> 为正定的；</li><li>如果对所有 <span class="math inline"><em>n</em></span> 维列向量<span class="math inline">$\vec{x_{}}$</span>，<span class="math inline">$\vec{x_{}}^TK\vec{x_{}}\geq0$</span> 成立，则称矩阵<span class="math inline"><em>K</em></span> 为半正定的。</li></ul></li></ul><h4 id="命题">命题</h4><ol type="1"><li><strong>命题1</strong>：<ul><li><strong>协方差（相关）矩阵是对称且半正定的。</strong></li><li>如果矩阵 <span class="math inline"><em>K</em></span>是对称的，则它可以对角化为 <span class="math inline"><em>K</em> = <em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup></span>。其中，<span class="math inline"><em>Λ</em></span> 是对角矩阵，<span class="math inline"><em>Q</em></span> 和 <span class="math inline"><em>Q</em><sup><em>T</em></sup></span>是正交矩阵，即 <span class="math inline"><em>Q</em><sup>−1</sup> = <em>Q</em><sup><em>T</em></sup></span>，<span class="math inline">|<em>Q</em>| = |<em>Q</em><sup><em>T</em></sup>| = 1</span>，<span class="math inline"><em>Q</em><em>Q</em><sup><em>T</em></sup> = <em>I</em></span>。<span class="math display"><em>K</em><em>Q</em> = (<em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup>)<em>Q</em> = <em>Q</em><em>Λ</em>(<em>Q</em><sup><em>T</em></sup><em>Q</em>) = <em>Q</em><em>Λ</em></span>令 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 表示<span class="math inline"><em>Λ</em></span> 的第 <span class="math inline"><em>i</em></span> 个对角元素，<span class="math inline">$\vec{q_{i}}$</span> 表示 <span class="math inline"><em>Q</em></span> 的第 <span class="math inline"><em>i</em></span> 列，则： <span class="math display">$$\begin{align*}&amp;K[\vec{q_{1}},\vec{q_{2}},\cdots,\vec{q_{n}}]=[\vec{q_{1}},\vec{q_{2}},\cdots,\vec{q_{n}}]\begin{bmatrix}\lambda_1&amp;&amp; \\ &amp;\ddots&amp; \\ &amp; &amp;\lambda_n\end{bmatrix}\\&amp;K\vec{q_{i}}=\lambda_i\vec{q_{i}}\end{align*}$$</span> 即 <span class="math inline">$\vec{q_{i}}$</span> 是矩阵 <span class="math inline"><em>K</em></span> 对应于特征值 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span>的特征向量。</li></ul></li><li><strong>命题2</strong>：<ul><li><p><strong>半正定矩阵的特征值是非负的</strong>。</p></li><li><p><strong>证明</strong>： 令 <span class="math inline"><em>K</em></span> 表示一个半正定矩阵，<span class="math inline">$\vec{u_{}}$</span> 是矩阵 <span class="math inline"><em>K</em></span> 对应于特征值 <span class="math inline"><em>λ</em></span> 的特征向量，即 <span class="math display">$$K\vec{u_{}}=\lambda\vec{u_{}}$$</span></p><p>由于 <span class="math inline"><em>K</em></span> 是半正定的，有 <span class="math display">$$\vec{u_{}}^TK\vec{u_{}}=\vec{u_{}}^T\lambda\vec{u_{}}=\lambda\vec{u_{}}^T\vec{u_{}}\geq0$$</span></p><p>又因为 <span class="math inline">$\vec{u_{}}^T\vec{u_{}}&gt;0$</span>，所以有 <span class="math inline"><em>λ</em> ≥ 0</span>。</p></li></ul></li><li><strong>命题3</strong>：<ul><li>令 <span class="math inline">$\vec{Y_{}} = A\vec{X_{}}$</span>，其中<span class="math inline">$\vec{X_{}}$</span> 和 <span class="math inline">$\vec{Y_{}}$</span>均为由几个随机变量构成的列向量，<span class="math inline"><em>A</em></span> 是 <span class="math inline"><em>m</em> × <em>n</em></span> 矩阵，则 <span class="math display">$$K_{\vec{Y_{}}} = AK_{\vec{X_{}}}A^T$$</span> 且<span class="math display">$$\widetilde{K}_{\vec{Y_{}}} =A\widetilde{K}_{\vec{X_{}}}A^T$$</span></li><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  K_{\vec{Y_{}}}&amp;=E(\vec{Y_{}}-E\vec{Y_{}})(\vec{Y_{}}-E\vec{Y_{}})^T\\  &amp;=E[A(\vec{X_{}}-E\vec{X_{}})][A(\vec{X_{}}-E\vec{X_{}})]^T\\  &amp;=E[A(\vec{X_{}}-E\vec{X_{}})(\vec{X_{}}-E\vec{X_{}})^TA^T]\\  &amp;=A[E(\vec{X_{}}-E\vec{X_{}})(\vec{X_{}}-E\vec{X_{}})^T]A^T\\  &amp;=AK_{\vec{X_{}}}A^T  \end{align*}  $$</span></li></ul></li><li><strong>命题4</strong><ul><li><p>设<span class="math inline">$\vec{X_{}}$</span>和<span class="math inline">$\vec{Y_{}}$</span>均为由<span class="math inline"><em>n</em></span>个随机变量构成的列向量，且满足<span class="math display">$$\vec{Y_{}} = Q^T\vec{X_{}}$$</span> 其中<span class="math inline"><em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup></span>是<span class="math inline">$K_{\vec{X_{}}}$</span>（<span class="math inline">$\vec{X_{}}$</span>的协方差矩阵）的一个对角化。则有<span class="math display">$$K_{\vec{Y_{}}}=\Lambda$$</span> 即<span class="math inline">$\vec{Y_{}}$</span>中的随机变量是不相关的，且<span class="math inline"><em>V</em><em>a</em><em>r</em>(<em>Y</em><sub><em>i</em></sub>) = <em>λ</em><sub><em>i</em></sub></span>，<span class="math inline"><em>λ</em><sub><em>i</em></sub></span>是<span class="math inline"><em>Λ</em></span>的第<span class="math inline"><em>i</em></span>个对角元素。</p></li><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  K_{\vec{Y_{}}}&amp;=Q^TK_{\vec{X_{}}}Q\\  &amp;=Q^T(Q\Lambda Q^T)Q\\  &amp;=(Q^TQ)\Lambda(Q^TQ)\\  &amp;=\Lambda  \end{align*}  $$</span></p></li><li><p><strong>推论</strong>：设<span class="math inline">$\vec{X_{}}$</span>是由<span class="math inline"><em>n</em></span>个随机变量构成的列向量，且<span class="math inline"><em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup></span>是<span class="math inline">$K_{\vec{X_{}}}$</span>的一个对角化，则<span class="math display">$$\vec{X_{}}=Q\vec{Y_{}}$$</span> 其中<span class="math inline">$\vec{Y_{}}=Q^T\vec{X_{}}$</span>是由<span class="math inline"><em>n</em></span>个不相关的随机变量构成的列向量。</p><ul><li>证明： <span class="math display">$$\vec{X_{}}=QQ^T\vec{X_{}}=Q(Q^T\vec{X_{}})=Q\vec{Y_{}}$$</span></li></ul></li></ul></li><li><strong>命题5</strong><ul><li>设<span class="math inline">$\vec{X_{}}$</span>，<span class="math inline">$\vec{Y_{}}$</span>和<span class="math inline">$\vec{Z_{}}$</span>是由<span class="math inline"><em>n</em></span>个随机变量构成的列向量，<span class="math inline">$\vec{X_{}}$</span>和<span class="math inline">$\vec{Z_{}}$</span>相互独立，且<span class="math inline">$\vec{Y_{}}=\vec{X_{}}+\vec{Z_{}}$</span>，则<span class="math display">$$K_{\vec{Y_{}}} = K_{\vec{X_{}}} +K_{\vec{Z_{}}}$$</span></li></ul></li><li><strong>命题6</strong><ul><li>设<span class="math inline">$\vec{Y_{}}=Q\vec{X_{}}$</span>，其中<span class="math inline">$\vec{X_{}}$</span>和<span class="math inline">$\vec{Y_{}}$</span>是由<span class="math inline"><em>n</em></span>个随机变量构成的列向量，<span class="math inline"><em>Q</em></span>是一个正交矩阵，则<span class="math display">$$E(\sum_{i = 1}^{n}Y_{i}^{2}) = E(\sum_{i =1}^{n}X_{i}^{2})$$</span> 即随机变量的总能量在正交变换下不变</li><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  \sum_{i = 1}^{n}Y_{i}^{2}&amp;=\vec{Y_{}}^T\vec{Y_{}}\\  &amp;=(Q\vec{X_{}})^T(Q\vec{X_{}})\\  &amp;=\vec{X_{}}^TQ^TQ\vec{X_{}}\\  &amp;=\vec{X_{}}^T\vec{X_{}}\\  &amp;=\sum_{i = 1}^{n}X_{i}^{2}  \end{align*}  $$</span> 上式两边取期望，得证。</li></ul></li></ol><h2 id="微分熵">微分熵</h2><h3 id="微分熵-1">微分熵</h3><ol type="1"><li><p><strong>定义</strong> 一个概率密度函数为 <span class="math inline"><em>f</em>(<em>x</em>)</span> 的连续随机变量 <span class="math inline"><em>X</em></span> 的微分熵 <span class="math inline"><em>h</em>(<em>X</em>)</span> 定义为 <span class="math display"><em>h</em>(<em>X</em>) = −∫<sub><em>S</em></sub><em>f</em>(<em>x</em>)log <em>f</em>(<em>x</em>)<em>d</em><em>x</em> = −<em>E</em>log <em>f</em>(<em>x</em>)</span></p><p>其中 <span class="math inline"><em>S</em></span> 为 <span class="math inline"><em>X</em></span> 的支撑集，即（<span class="math inline"><em>f</em>(<em>x</em>) &gt; 0</span>，<span class="math inline"><em>x</em> ∈ <em>S</em></span>），<span class="math inline"><em>h</em>(<em>x</em>)</span>单位为<span class="math inline"><em>b</em><em>i</em><em>t</em></span>。</p></li><li><p><strong>均匀分布</strong> 设 <span class="math inline"><em>X</em> ∼ <em>U</em>(<em>a</em>, <em>b</em>)</span>,即<span class="math inline"><em>X</em></span> 服从 <span class="math inline">[<em>a</em>, <em>b</em>]</span> 上的均匀分布，则<span class="math display">$$h(X)=-\int_{a}^{b}\frac{1}{b-a}\log\frac{1}{b-a}dx= \log (b-a)$$</span></p><p>若 <span class="math inline"><em>b</em> − <em>a</em> &lt; 1</span>，则 <span class="math inline"><em>h</em>(<em>X</em>) &lt; 0</span>，因此微分熵可以为负。</p></li><li><p><strong>正态分布/高斯分布</strong> 设 <span class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>, <em>σ</em><sup>2</sup>)</span>，<span class="math inline">$f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}}$</span>。 <span class="math display">$$\begin{align*}h(X)&amp;=-\int f(x)\log f(x)dx\\&amp;=-\intf(x)\left(-\log\sqrt{2\pi\sigma^{2}}-\frac{x^{2}}{2\sigma^{2}}\loge\right)dx\\&amp;=\frac{1}{2}\log(2\pi\sigma^{2})\int f(x)dx+\frac{\loge}{2\sigma^{2}}\int x^{2}f(x)dx\\&amp;=\frac{1}{2}\log(2\pi\sigma^{2})+\frac{1}{2}\log e\\&amp;=\frac{1}{2}\log(2\pi e\sigma^{2})\end{align*}$$</span></p><p>其中 <span class="math display"><em>σ</em><sup>2</sup> = <em>V</em><em>a</em><em>r</em>(<em>X</em>) = <em>E</em>(<em>X</em> − <em>E</em>(<em>X</em>))<sup>2</sup> = ∫(<em>x</em> − <em>μ</em>)<sup>2</sup><em>f</em>(<em>x</em>)<em>d</em><em>x</em></span></p><p>若<span class="math inline"><em>X</em> ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span>，<span class="math inline">$f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{x^{2}}{2\sigma^{2}}}$</span>，则有 <span class="math inline">$h(X)=\frac{1}{2}\log(2\pie\sigma^{2})$</span> 其中 <span class="math display"><em>σ</em><sup>2</sup> = <em>V</em><em>a</em><em>r</em>(<em>X</em>) = ∫<em>x</em><sup>2</sup><em>f</em>(<em>x</em>)<em>d</em><em>x</em></span></p></li><li><p><strong>平移性质</strong> <span class="math display"><em>h</em>(<em>X</em> + <em>c</em>) = <em>h</em>(<em>X</em>)</span></p><ul><li><figure><img src="image-11.webp" srcset="/img/loading/loading3.gif" lazyload alt="图示"><figcaption aria-hidden="true">图示</figcaption></figure></li><li><strong>证明</strong>： 令 <span class="math inline"><em>Y</em> = <em>X</em> + <em>c</em></span>，则<span class="math inline"><em>f</em><sub><em>Y</em></sub>(<em>y</em>) = <em>f</em><sub><em>X</em></sub>(<em>y</em> − <em>c</em>)</span>，且 <span class="math inline"><em>S</em><sub><em>Y</em></sub> = {<em>x</em> + <em>c</em> : <em>x</em> ∈ <em>S</em><sub><em>X</em></sub>}</span>将 <span class="math inline"><em>x</em> = <em>y</em> − <em>c</em></span>代入下式： <span class="math display">$$  \begin{align*}  h(X)&amp;=-\int_{S_X}f_X(x)\log f_X(x)dx\\  &amp;=-\int_{S_Y}f_X(y - c)\log f_X(y - c)dy\\  &amp;=-\int_{S_Y}f_Y(y)\log f_Y(y)dy\\  &amp;=h(Y)\\  &amp;=h(X + c)  \end{align*}  $$</span></li></ul></li><li><p><strong>缩放性质</strong> <span class="math display"><em>对</em><em>a</em> ≠ 0，<em>有</em><em>h</em>(<em>a</em><em>X</em>) = <em>h</em>(<em>X</em>) + log |<em>a</em>|</span></p><ul><li><figure><img src="image-12.webp" srcset="/img/loading/loading3.gif" lazyload alt="图示"><figcaption aria-hidden="true">图示</figcaption></figure></li><li><strong>证明</strong>： 令 <span class="math inline"><em>Y</em> = <em>a</em><em>X</em></span>，则 <span class="math inline">$f_Y(y)=\frac{1}{|a|}f_X(\frac{y}{a})$</span>，且<span class="math inline"><em>S</em><sub><em>Y</em></sub> = {<em>a</em><em>x</em> : <em>x</em> ∈ <em>S</em><sub><em>X</em></sub>}</span>。将 <span class="math inline">$x = \frac{y}{a}$</span> 代入 <span class="math inline"><em>h</em>(<em>X</em>)</span> 的表达式： <span class="math display">$$  \begin{align*}  h(X)&amp;=-\int_{S_X}f_X(x)\log f_X(x)dx\\  &amp;=-\int_{S_Y}f_X(\frac{y}{a})\log f_X(\frac{y}{a})\frac{dy}{|a|}\\  &amp;=-\int_{S_Y}|a|f_Y(y)\log (f_Y(y)|a|)\frac{1}{|a|}dy\\  &amp;=-\int_{S_Y}f_Y(y)(\log f_Y(y)+\log|a|)dy\\  &amp;=-\int_{S_Y}f_Y(y)\log f_Y(y)dy-\log|a|\int_{S_Y}f_Y(y)dy\\  &amp;=h(Y)-\log|a|\\  &amp;=h(aX)-\log|a|  \end{align*}  $$</span> 移项可得 <span class="math inline"><em>h</em>(<em>a</em><em>X</em>) = <em>h</em>(<em>X</em>) + log |<em>a</em>|</span></li><li>示例：<img src="image-103.webp" srcset="/img/loading/loading3.gif" lazyload alt="示例"></li></ul></li></ol><h3 id="联合微分熵条件微分熵及互信息">联合微分熵，条件微分熵及互信息</h3><ol type="1"><li><p><strong>定义（联合微分熵）</strong> 联合概率密度函数为 <span class="math inline">$f(\vec{x_{}})$</span> 的随机向量 <span class="math inline">$\vec{x_{}}$</span> 的联合微分熵 <span class="math inline">$h(\vec{x_{}})$</span> 定义为 <span class="math display">$$h(\vec{x_{}})=-\int_{S}f(\vec{x_{}})\logf(\vec{x_{}})d\vec{x_{}}=-E\log f(\vec{x_{}})$$</span></p><p>如果 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>相互独立，则有 <span class="math display">$$h(\vec{x_{}})=\sum_{i =1}^{n}h(X_i)$$</span></p></li><li><p><strong>平移</strong> 令 <span class="math inline">$\vec{c_{}}$</span> 是 <span class="math inline">ℝ<sup><em>n</em></sup></span>（<span class="math inline"><em>n</em></span> 维实数空间）中的一个列向量，则<span class="math display">$$h(\vec{x_{}}+\vec{c_{}}) =h(\vec{x_{}})$$</span></p></li><li><p><strong>缩放</strong> 令 <span class="math inline"><em>A</em></span> 是一个 <span class="math inline"><em>n</em> × <em>n</em></span> 的非奇异矩阵，则<span class="math display">$$h(A\vec{x_{}})=h(\vec{x_{}})+\log|\det(A)|$$</span></p></li><li><p><strong>多元高斯分布</strong> 设 <span class="math inline">$\vec{X_{}} \sim N(\vec{\mu_{}},K)$</span> 。 令<span class="math inline">$N(\vec{\mu_{}},K)$</span> 表示均值为 <span class="math inline">$\vec{\mu_{}}$</span>，协方差矩阵为 <span class="math inline"><em>K</em></span> 的多元高斯分布，即对于所有 <span class="math inline">$\vec{x_{}} \in \mathbb{R}^n$</span>，其联合概率密度函数为： <span class="math display">$$f(\vec{x_{}}) =\frac{1}{(\sqrt{2\pi})^n|K|^{\frac{1}{2}}}e^{-\frac{1}{2}(\vec{x_{}}-\vec{\mu_{}})^TK^{-1}(\vec{x_{}}-\vec{\mu_{}})}$$</span></p><p>其中 <span class="math inline"><em>K</em></span>是正定对称矩阵，<span class="math inline">|<em>K</em>|</span> 表示 <span class="math inline"><em>K</em></span> 的行列式值，<span class="math inline">$\vec{x_{}},\vec{\mu_{}}$</span> 为列向量。</p><p>其微分熵 <span class="math inline">$h(\vec{X_{}})$</span> 为： <span class="math display">$$h(\vec{X_{}}) = \frac{1}{2} \log[(2\pie)^n|K|]$$</span></p><p>这里 <span class="math inline">|<em>K</em>|</span> 为 <span class="math inline"><em>K</em></span> 的行列式值。</p><ul><li><strong>证明</strong>： 设 <span class="math inline"><em>K</em></span> 可以对角化为 <span class="math inline"><em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup></span>，记 <span class="math inline">$\vec{X_{}} = Q\vec{Y_{}}$</span> ，其中<span class="math inline">$\vec{Y_{}}$</span> 中的随机变量不相关，且有<span class="math inline"><em>V</em><em>a</em><em>r</em>(<em>Y</em><sub><em>i</em></sub>) = <em>λ</em><sub><em>i</em></sub></span>，为 <span class="math inline"><em>Λ</em></span> 中第 <span class="math inline"><em>i</em></span> 个对角元素。由于 <span class="math inline">$\vec{X_{}}$</span> 是高斯的，所以 <span class="math inline">$\vec{Y_{}}$</span> 也是高斯的。又由于 <span class="math inline">$\vec{Y_{}}$</span>中的随机变量是不相关的，可知它们相互独立。 <span class="math display">$$  \begin{align*}  h(\vec{X_{}})&amp;=h(Q\vec{Y_{}})\\  &amp;=h(\vec{Y_{}})+\log|\det(Q)|\\  &amp;=h(\vec{Y_{}}) + 0\\  &amp;=\sum_{i = 1}^{n}h(Y_i)\\  &amp;=\sum_{i = 1}^{n}\frac{1}{2}\log(2\pi e\lambda_i)\\  &amp;=\frac{1}{2}\log[(2\pi e)^n\prod_{i = 1}^{n}\lambda_i]\\  &amp;=\frac{1}{2}\log[(2\pi e)^n|\Lambda|]\\  &amp;=\frac{1}{2}\log[(2\pi e)^n|K|]  \end{align*}  $$</span></li></ul></li><li><p><strong>定义（条件微分熵）</strong> 如果 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span> 的联合密度函数为 <span class="math inline"><em>f</em>(<em>x</em>, <em>y</em>)</span>，定义条件微分熵<span class="math inline"><em>h</em>(<em>X</em>|<em>Y</em>)</span> 为：<span class="math display"><em>h</em>(<em>X</em>|<em>Y</em>) = −∫<em>f</em>(<em>x</em>, <em>y</em>)log <em>f</em>(<em>x</em>|<em>y</em>)<em>d</em><em>x</em><em>d</em><em>y</em></span></p><p>由于 <span class="math inline"><em>f</em>(<em>x</em>|<em>y</em>) = <em>f</em>(<em>x</em>, <em>y</em>)/<em>f</em>(<em>y</em>)</span>，所以有：<span class="math display"><em>h</em>(<em>X</em>|<em>Y</em>) = <em>h</em>(<em>X</em>, <em>Y</em>) − <em>h</em>(<em>Y</em>)</span></p></li><li><p><strong>定义（相对熵）</strong> 两个密度函数 <span class="math inline"><em>f</em></span> 和 <span class="math inline"><em>g</em></span> 之间的相对熵 <span class="math inline"><em>D</em>(<em>f</em>||<em>g</em>)</span> 定义为：<span class="math display">$$D(f||g)=\intf\log\frac{f}{g}$$</span></p></li><li><p><strong>定义（互信息）</strong> 联合概率密度函数为 <span class="math inline"><em>f</em>(<em>x</em>, <em>y</em>)</span>的两个随机变量间的互信息 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 定义为：<span class="math display">$$I(X;Y)=\intf(x,y)\log\frac{f(x,y)}{f(x)f(y)}dxdy$$</span></p><p>显然有：<span class="math display">$$\begin{align*}I(X;Y)&amp;=h(X)-h(X|Y)=h(Y)-h(Y|X)\\&amp;=h(X)+h(Y)-h(X,Y)\end{align*}$$</span></p><p>以及：<span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>D</em>(<em>f</em>(<em>x</em>, <em>y</em>)||<em>f</em>(<em>x</em>)<em>f</em>(<em>y</em>))</span></p></li><li><p><strong>定理：相对熵的非负性</strong> <span class="math display"><em>D</em>(<em>f</em>||<em>g</em>) ≥ 0</span></p><ul><li><strong>证明</strong>： 设 <span class="math inline"><em>f</em></span> 的支撑集是 <span class="math inline"><em>S</em></span> <span class="math display">$$  \begin{align*}  -D(f||g)&amp;=\int_{S} f \log\frac{g}{f}\\  &amp;\leq \log\int_{S} f\frac{g}{f} \quad (\text{Jensen 不等式})\\  &amp;=\log\int_{S} g\\  &amp;\leq \log 1 = 0  \end{align*}  $$</span></li><li><strong>推论</strong>：<ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) ≥ 0</span>，当且仅当 <span class="math inline"><em>X</em></span> 与 <span class="math inline"><em>Y</em></span> 相互独立等号成立。</li><li><span class="math inline"><em>h</em>(<em>X</em>|<em>Y</em>) ≤ <em>h</em>(<em>X</em>)</span>。</li></ul></li></ul></li><li><p><strong>定理(链式法则)</strong> <span class="math display">$$h(X_1,X_2,X_3,\cdots,X_n)=\sum_{i =1}^{n}h(X_i|X_1,X_2,\cdots,X_{i - 1})$$</span></p><ul><li><strong>推论</strong>：<ul><li><span class="math inline">$h(X_1,X_2,\cdots,X_n) \leq \sum_{i =1}^{n}h(X_i)$</span></li></ul></li></ul></li><li><p><strong>Hadamard 阿达玛不等式</strong> 设 <span class="math inline">$\vec{X_{}} \sim N(0,K)$</span> 是一个多元正态分布。则有 <span class="math display">$$\begin{align*}h(X_1,X_2,\cdots,X_n)&amp;=\frac{1}{2}\log((2\pi e)^n|K|)\\&amp;\leq \sum_{i = 1}^{n}\frac{1}{2}\log(2\pi e K_{ii})\\&amp;=\frac{1}{2}\log((2\pi e K_{11} \times 2\pi e K_{22} \times \cdots\times 2\pi e K_{nn}))\end{align*}$$</span></p><p>即 <span class="math inline">$|K| \leq \prod_{i =1}^{n}K_{ii}$</span></p><ul><li>注意有关行列式的不等式可以由信息论中的不等式推导而得到。</li></ul></li></ol><h1 id="第三章-信道与信道容量">第三章 信道与信道容量</h1><h2 id="信道的数学模型">3.1 信道的数学模型</h2><h3 id="基本数学模型">基本数学模型</h3><ul><li><figure><img src="image-13.webp" srcset="/img/loading/loading3.gif" lazyload alt="数学模型"><figcaption aria-hidden="true">数学模型</figcaption></figure></li><li><span class="math inline">$\vec{X_{}}=(X_1, X_2, \cdots, X_i,\cdots)$</span>，<span class="math inline"><em>X</em><sub><em>i</em></sub> ∈ <em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span>为输入；</li><li><span class="math inline">$\vec{Y_{}}=(Y_1, Y_2, \cdots, Y_j,\cdots)$</span>，<span class="math inline"><em>Y</em><sub><em>j</em></sub> ∈ <em>B</em> = {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span>为输出。</li><li>用条件概率（转移概率）<span class="math inline">$p(\vec{Y_{}}|\vec{X_{}})$</span>来描述输入、输出之间的依赖关系。</li></ul><h3 id="无干扰信道无噪声">无干扰信道（无噪声）</h3><ul><li><span class="math inline">$\vec{Y_{}} =f(\vec{X_{}})$</span>，已知<span class="math inline">$\vec{X_{}}$</span>就能确知<span class="math inline">$\vec{Y_{}}$</span> <span class="math display">$$  p(\vec{Y_{}}|\vec{X_{}}) =  \begin{cases}  1, &amp;\vec{Y_{}} = f(\vec{X_{}}) \\  0, &amp;\vec{Y_{}} \neq f(\vec{X_{}})  \end{cases}  $$</span></li><li>例子：<ul><li>当输入<span class="math inline"><em>a</em><sub>1</sub></span>对应输出<span class="math inline"><em>b</em><sub>1</sub></span>，输入<span class="math inline"><em>a</em><sub>2</sub></span>对应输出<span class="math inline"><em>b</em><sub>2</sub></span>时，转移概率矩阵<span class="math inline">$P = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1\end{bmatrix}$</span></li><li><figure><img src="image-14.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul></li></ul><h3 id="有干扰无记忆信道">有干扰无记忆信道</h3><ul><li>无记忆：<span class="math display">$$p(\vec{Y_{}}|\vec{X_{}}) =p(y_1|x_1)p(y_2|x_2)\cdots p(y_l|x_l)$$</span></li><li>只需分析单个符号的转移概率<span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span></li></ul><h4 id="二进制离散对称信道binary-symmetric-channelbsc">二进制离散对称信道（BinarySymmetric Channel，BSC）</h4><ul><li>输入<span class="math inline"><em>X</em> ∈ <em>A</em> = {0, 1}</span></li><li>输出<span class="math inline"><em>Y</em> ∈ <em>B</em> = {0, 1}</span></li><li>$ BSC$</li><li>其中<span class="math inline"><em>p</em></span>为错误概率，其转移关系和转移概率矩阵如下：</li><li><figure><img src="image-15.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul><h4 id="离散无记忆信道discrete-memoryless-channeldmc">离散无记忆信道（DiscreteMemoryless Channel，DMC）</h4><ul><li>输入<span class="math inline"><em>X</em> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>输出<span class="math inline"><em>Y</em> ∈ {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li><li>转移概率矩阵<span class="math inline">$P = [p(b_j|a_i)] =[p_{ij}]_{n \times m} =  \begin{bmatrix}  p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1m} \\  \vdots &amp; &amp; &amp; \\  p_{n1} &amp; p_{n2} &amp; \cdots &amp; p_{nm}  \end{bmatrix}_{n \times m}$</span></li><li>并且满足<span class="math inline">$\sum_{j = 1}^{m} p(b_j|a_i) =1$</span>，<span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span></li><li><figure><img src="image-16.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li>二进制离散对称信道（BSC）是离散无记忆信道（DMC）的特例</li></ul><h4 id="离散输入连续输出信道">离散输入、连续输出信道</h4><ul><li>输入<span class="math inline"><em>X</em> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>输出<span class="math inline"><em>Y</em> ∈ {−∞, +∞}</span></li><li>信道模型为<span class="math inline"><em>Y</em> = <em>X</em> + <em>G</em></span>，其中<span class="math inline"><em>G</em> ∈ {−∞, +∞}</span>，<span class="math inline"><em>p</em><sub><em>G</em></sub>(<em>n</em>) ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span></li><li>条件概率密度<span class="math inline">$p_Y(y|a_i) \sim N(a_i,\sigma^2)=\frac{1}{\sqrt{2 \pi \sigma^2}}e^{-\frac{(y -a_i)^2}{2\sigma^2}}$</span></li><li>图例：<img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"></li></ul><h4 id="波形信道">波形信道</h4><ul><li>当 <span class="math inline"><em>t</em><sub><em>B</em></sub></span>、<span class="math inline"><em>f</em><sub><em>m</em></sub></span> 受限，<span class="math inline"><em>L</em> = 2<em>t</em><sub><em>B</em></sub><em>f</em><sub><em>m</em></sub></span>时</li><li>输入 <span class="math inline">$\vec{X_{}} = (X_1, X_2, \cdots,X_L)$</span></li><li>输出 <span class="math inline">$\vec{Y_{}} = (Y_1, Y_2, \cdots,Y_L)$</span></li><li><figure><img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li><strong>时间离散，取值连续的多维连续信道</strong>，信道转移概率密度函数为：<span class="math display">$$p_Y(\vec{y_{}}|\vec{x_{}}) = p_y(y_1,y_2,\cdots,y_L | x_1,x_2,\cdots,x_L)$$</span></li><li><strong>连续无记忆信道</strong>： <span class="math display">$$p_Y(\vec{y_{}}|\vec{x_{}}) = p_y(y_1 |x_1)p_y(y_2 | x_2)\cdots p_y(y_L | x_L) = \prod_{l = 1}^{L} p_Y (y_l|x_l)$$</span></li></ul><h4 id="因此无记忆时重点讨论单符号信道">因此无记忆时重点讨论单符号信道！</h4><ul><li><p>信道模型为 <span class="math inline"><em>y</em>(<em>t</em>) = <em>x</em>(<em>t</em>) + <em>n</em>(<em>t</em>)</span></p></li><li><p>其中 <strong><span class="math inline"><em>n</em>(<em>t</em>)</span> 为加性噪声，与信号<span class="math inline"><em>x</em>(<em>t</em>)</span>相互独立</strong></p></li><li><figure><img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li><p>根据概率关系有： <span class="math display"><em>p</em><sub><em>X</em>, <em>Y</em></sub>(<em>x</em>, <em>y</em>) = <em>p</em><sub><em>X</em>, <em>n</em></sub>(<em>x</em>, <em>n</em>) = <em>p</em><sub><em>X</em></sub>(<em>x</em>)<em>p</em><sub><em>n</em></sub>(<em>n</em>)</span></p><p><span class="math display">$$p_Y(y|x)=\frac{p_{X,Y}(x,y)}{p_X(x)}=\frac{p_{X,n}(x,n)}{p_X(x)}= p_n(n)$$</span></p></li><li><p>进一步考虑条件熵： <span class="math display">$$  \begin{align*}  H_c(Y|X)&amp;=-\iint_{R}p_{X,Y}(x,y)\log p_Y(y|x)dxdy\\  &amp;=-\int_{R}p_X(x)dx\int_{R}p_Y(y|x)\log p_Y(y|x)dy\\  &amp;=-\int_{R}p_n(n)\log p_n(n)dn\\  &amp;=H_c(n)  \end{align*}  $$</span></p><p>条件熵 <span class="math inline"><em>H</em><sub><em>c</em></sub>(<em>Y</em>|<em>X</em>)</span>称为<strong>噪声熵</strong></p></li><li><p>在加性多维连续信道中</p><ul><li><span class="math display">$$\vec{y_{}}=\vec{x_{}}+\vec{n_{}}$$</span></li><li>同理有 <span class="math inline">$p_{\vec{Y_{}}}(\vec{y_{}}|\vec{x_{}}) =p_n(\vec{n_{}})$</span>，<span class="math inline">$H_c(\vec{y_{}}|\vec{x_{}}) =H_c(\vec{n_{}})$</span></li></ul></li></ul><h3 id="有干扰有记忆信道">有干扰有记忆信道</h3><blockquote><p>略</p></blockquote><h3 id="信道容量的定义">信道容量的定义</h3><ul><li>定义信道的<strong>信息传输率 <span class="math inline"><em>R</em></span></strong>为信道中平均每个符号所传输的信息量： <span class="math display">$$  \begin{align*}  R=I(X;Y)&amp;=H(X)-H(X|Y)\quad \text{bit}/\text{信道符号}\\  &amp;=H(Y)-H(Y|X)  \end{align*}  $$</span></li><li>设 <span class="math inline"><em>T</em></span>为信道中符号的平均传输时间，定义<strong>信息传输速率</strong>： <span class="math display">$$R_t = \frac{R}{T}=\frac{I(X;Y)}{T}\quad\text{bit}/\text{秒}$$</span><ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>是输入符号分布概率 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>和信道转移概率 <span class="math inline"><em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>)</span>的函数，即 <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>f</em>(<em>p</em>(<em>a</em><sub><em>i</em></sub>), <em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>))</span></li></ul></li><li>对于某特定信道，<span class="math inline"><em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>)</span>确定，则 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是关于<span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>的凹函数（<span class="math inline">∩</span>型上凸函数），也即可以找到某种概率分布 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>，使<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>达到最大，该最大值为<strong>信道容量</strong>： <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>I</em>(<em>X</em>; <em>Y</em>)  bit/符号</span><ul><li>若符号传送时间周期为 <span class="math inline"><em>T</em></span>秒，则<strong>单位时间信道容量</strong>为： <span class="math display"><em>C</em><sub><em>t</em></sub> = <em>C</em>/<em>T</em>  bit/秒</span></li></ul></li><li>对于固定信道参数信道，信道容量是个定值。实际传输时能否提供最大传输能力，取决于输入端的概率分布，定义<strong>信道绝对冗余度和相对冗余度</strong>：<span class="math display"><em>信</em><em>道</em><em>绝</em><em>对</em><em>冗</em><em>余</em><em>度</em> = <em>C</em> − <em>I</em>(<em>X</em>; <em>Y</em>)</span><span class="math display">$$信道相对冗余度=1-\frac{I(X;Y)}{C}$$</span></li></ul><h2 id="离散单个符号信道及其容量">3.2 离散单个符号信道及其容量</h2><h3 id="无干扰离散信道">无干扰离散信道</h3><ul><li>信道输入<span class="math inline"><em>X</em> ∈ <em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>输出<span class="math inline"><em>Y</em> ∈ <em>B</em> = {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li></ul><h4 id="无噪无损信道n-mxy一一对应">无噪无损信道：n =m，X、Y一一对应</h4><ul><li>输入输出关系：<img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload alt="输入输出关系"></li><li>转移概率矩阵<span class="math inline">$P = \{p(y_j|x_i)\} =  \begin{bmatrix}  1 &amp; 0 &amp; \cdots \\  0 &amp; 1 &amp; \cdots \\  \vdots &amp; \vdots &amp; \ddots &amp;  \end{bmatrix}$</span>，<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>) ∈ {0, 1}</span>。</li><li><strong>噪声熵与疑义度</strong>： <span class="math display"><em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>X</em>|<em>Y</em>) = 0</span></li><li><strong>互信息</strong>： <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>I</em>(<em>Y</em>; <em>X</em>) = <em>H</em>(<em>X</em>) = <em>H</em>(<em>Y</em>)</span>当输入符号等概率分布时，<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>最大。</li><li><strong>信道容量</strong>: <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>I</em>(<em>X</em>; <em>Y</em>) = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>H</em>(<em>X</em>) = log <em>n</em></span></li></ul><h4 id="无噪有损信道n-m多个x对应一个y">无噪有损信道：n &gt;m，多个X对应一个Y</h4><ul><li>输入输出关系：<img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload alt="输入输出关系"></li><li>多个输入对应一个输出，即<span class="math inline"><em>n</em> &gt; <em>m</em></span></li><li><strong>噪声熵</strong>: <span class="math display"><em>H</em>(<em>Y</em>|<em>X</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)log <em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>) = 0</span></li><li><strong>疑义度</strong>: <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)log <em>p</em>(<em>a</em><sub><em>i</em></sub>|<em>b</em><sub><em>j</em></sub>) ≠ 0</span></li><li><strong>互信息</strong>: <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>Y</em>) ≠ 0</span>其中<span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>) = 0</span>，<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) ≠ 0</span>由此可得<span class="math inline"><em>H</em>(<em>X</em>) = <em>H</em>(<em>Y</em>) + <em>H</em>(<em>X</em>|<em>Y</em>)</span>，所以<span class="math inline"><em>H</em>(<em>X</em>) ≥ <em>H</em>(<em>Y</em>)</span>。</li><li><strong>信道容量</strong>： <span class="math display">$$C =\max_{p(a_i)} I(X;Y)=\max_{p(a_i)} H(Y) \overset{?}{=} \logm$$</span></li></ul><h4 id="有噪无损信道n-m一个x对应多个y">有噪无损信道：n &lt;m，一个X对应多个Y</h4><ul><li>输入输出关系：<img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload alt="输入输出关系"></li><li>信道噪声使一个输入对应多个输出，<span class="math inline"><em>n</em> &lt; <em>m</em></span></li><li><strong>噪声熵</strong>： <span class="math display"><em>H</em>(<em>Y</em>|<em>X</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)log <em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>) ≠ 0</span></li><li><strong>疑义度</strong>： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)log <em>p</em>(<em>a</em><sub><em>i</em></sub>|<em>b</em><sub><em>j</em></sub>) = 0</span></li><li><strong>互信息</strong>： <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>X</em>) ≠ 0</span>其中<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = 0</span>，<span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>) ≠ 0</span>由此可得<span class="math inline"><em>H</em>(<em>Y</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>|<em>X</em>)</span>，所以<span class="math inline"><em>H</em>(<em>Y</em>) ≥ <em>H</em>(<em>X</em>)</span>。</li><li><strong>信道容量</strong>： <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>I</em>(<em>X</em>; <em>Y</em>) = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>H</em>(<em>X</em>) = log <em>n</em></span></li></ul><h3 id="对称离散无记忆信道">对称离散无记忆信道</h3><ul><li><p>以下是两个转移概率矩阵示例： <span class="math display">$$  \begin{bmatrix}  \frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{6} \\  \frac{1}{6} &amp; \frac{1}{6} &amp; \frac{1}{3} &amp; \frac{1}{3}  \end{bmatrix}_{2\times4}  \quad  \begin{bmatrix}  \frac{1}{2} &amp; \frac{1}{3} &amp; \frac{1}{6} \\  \frac{1}{6} &amp; \frac{1}{2} &amp; \frac{1}{3} \\  \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{2}  \end{bmatrix}_{3\times3}  $$</span></p></li><li><p><strong>对称特性判断</strong>：</p><ul><li>若每一行包含相同元素，称为输入对称</li><li>若每一列包含相同元素，称为输出对称</li><li>当行列都对称时，为<strong>对称DMC（离散无记忆信道）</strong>。</li></ul></li><li><p><strong>相关信息论公式</strong>：</p><ul><li><strong>互信息</strong>: <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>)</span></li><li><strong>条件熵</strong>: <span class="math display">$$  \begin{align*}  H(Y|X)&amp;=-\sum_{i,j} p(a_i, b_j)\log p(b_j|a_i)\\  &amp;=-\sum_{i,j} p(a_i) p(b_j|a_i)\log p(b_j|a_i)\\  &amp;=-\sum_{i} p(a_i) \sum_{j} p(b_j|a_i)\log p(b_j|a_i)\\  &amp;=\sum_{i} p(a_i) H(Y|a_i) （输入对称）\\  &amp;= H(Y|a_i)，i = 1, 2, \cdots, n  \end{align*}  $$</span></li><li><strong>信道容量</strong>: <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>I</em>(<em>X</em>; <em>Y</em>) = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>a</em><sub><em>i</em></sub>)</span></li></ul></li><li><p>当<strong>输入符号等概率分布</strong>，即<span class="math inline">$p(a_i)=\frac{1}{n}$</span>时，设<span class="math inline"><em>m</em></span>为输出符号数目，则有：</p><ul><li><span class="math inline">$p(b_j)=\sum_{i}p(a_i)p(b_j|a_i)=\frac{1}{n}\sum_{i} p(b_j|a_i)=\frac{1}{n}\cdot\frac{n}{m}=\frac{1}{m}$</span></li><li><span class="math inline">$H(Y)=-\sum_{j} p(b_j)\log p(b_j)=\sum_{j}\frac{1}{m}\log m=m\frac{1}{m}\log m=\log m$</span></li><li><strong>信道容量</strong><span class="math display"><em>C</em> = log <em>m</em> − <em>H</em>(<em>Y</em>|<em>a</em><sub><em>i</em></sub>)</span></li><li>其中<span class="math inline"><em>m</em></span>为输出符号<span class="math inline"><em>Y</em></span>数目，<span class="math inline"><em>i</em> = 1, ⋯, <em>n</em></span></li></ul></li><li><p>例题：<img src="image-98.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li><li><p><strong>一般离散无记忆模k加性噪声信道</strong></p><ul><li>信道模型: <span class="math inline"><em>Y</em> = <em>X</em> ⊕ <em>Z</em>&nbsp;mod &nbsp;<em>k</em></span>，其中<span class="math inline"><em>X</em>, <em>Y</em>, <em>Z</em> ∈ {0, 1, ⋯, <em>k</em> − 1}</span></li><li>图例:<img src="image-23.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"></li><li><strong>加性噪声</strong>，有 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>) = <em>p</em>(<em>z</em>)</span><ul><li><strong>条件熵</strong>: <span class="math display">$$  \begin{align*}  H(Y|X)&amp;=-\sum_{x,y}p(x)p(y|x)\log p(y|x)\\  &amp;=-\sum_{x,z}p(x)p(z)\log p(z)\\  &amp;=-\sum_{x}p(x)\sum_{z}p(z)\log p(z)\\  &amp;=H(Z)  \end{align*}  $$</span></li><li><strong>信道容量</strong>: <span class="math display">$$  \begin{align*}  C&amp;=\max_{p(x)}H(Y)-H(Y|X)\\  &amp;=\max_{p(x)}H(Y)-H(Z)\\  &amp;=\log k - H(Z) \quad (\text{对称性})  \end{align*}  $$</span></li></ul></li><li>例题：<img src="image-26.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul></li></ul><h3 id="准对称离散无记忆信道">准对称离散无记忆信道</h3><ul><li><p>以下是两个转移概率矩阵示例： <span class="math display">$$P_1=\begin{bmatrix}\frac{1}{3}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{6}\\\frac{1}{6}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{3}\end{bmatrix}_{2\times4} \quadP_2=\begin{bmatrix}0.7&amp;0.1&amp;0.2\\0.2&amp;0.1&amp;0.7\end{bmatrix}_{2\times3}$$</span></p></li><li><p><strong>信道特性</strong>：</p><ul><li>矩阵中<strong>各行元素相同，但各列元素不同</strong>，这种信道称为<strong>准对称DMC（离散无记忆信道）</strong>。</li></ul></li><li><p><strong>相关信息论公式</strong>：</p><ul><li><p>因为各行元素相同，所以 <span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>Y</em>|<em>a</em><sub><em>i</em></sub>)</span>，其中 <span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span></p><ul><li>这表明在给定不同输入符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span>时，输出的条件熵是相同的</li></ul></li><li><p>由于各列元素不同，信道的输入和输出分布概率可以不同，并且 <span class="math inline"><em>H</em>(<em>Y</em>) ≤ log <em>m</em></span>（<span class="math inline"><em>m</em></span>为输出符号的数目）</p></li><li><p><strong>信道容量</strong>： <span class="math display">$$  \begin{align*}  C &amp;= \max_{p(x)}[H(Y)-H(Y|X)] \\  &amp;\leq\log m - H(Y|a_i)\\  &amp;=\log m+\sum_{j = 1}^{m}p_{ij}\log p_{ij}  \end{align*}  $$</span> 其中<span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span> ，<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>是转移概率矩阵中的元素</p><ul><li>这给出了准对称离散无记忆信道容量的一个<strong>上限估计</strong></li><li>求解：<strong>矩阵分解法</strong>、极值求导法</li></ul></li><li><p>例题：<img src="image-99.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul></li></ul><h3 id="矩阵分解法">矩阵分解法</h3><ul><li><strong>转移矩阵分解</strong>：<ul><li>将<strong>准对称</strong>转移概率矩阵<strong>按概率列</strong>分成若干个互不相交的<strong>对称的子集</strong>。例如：<ul><li><span class="math display">$$P_1 =\begin{bmatrix}\frac{1}{3}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{6}\\\frac{1}{6}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{3}\end{bmatrix}$$</span>可分解成<span class="math inline">$\begin{bmatrix}\frac{1}{3}&amp;\frac{1}{6}\\\frac{1}{6}&amp;\frac{1}{3}\end{bmatrix}$</span>，<span class="math inline">$\begin{bmatrix}\frac{1}{3}\\\frac{1}{3}\end{bmatrix}$</span>，<span class="math inline">$\begin{bmatrix}\frac{1}{6}\\\frac{1}{6}\end{bmatrix}$</span></li><li><span class="math display">$$P_2 =\begin{bmatrix}0.7&amp;0.1&amp;0.2\\0.2&amp;0.1&amp;0.7\end{bmatrix}$$</span>可分解成<span class="math inline">$\begin{bmatrix}0.7&amp;0.2\\0.2&amp;0.7\end{bmatrix}$</span>，<span class="math inline">$\begin{bmatrix}0.1\\0.1\end{bmatrix}$</span>。</li></ul></li></ul></li><li><strong>信道容量</strong>：<ul><li>可以证明，当<strong>输入等概率分布</strong>时，可达到信道容量。<span class="math display">$$C=\log n - H(P_1',P_2',\cdots,P_m')-\sum_{k= 1}^{r}N_k\log M_k$$</span></li><li>其中：<ul><li><span class="math inline"><em>n</em></span>为输入符号个数。</li><li><span class="math inline"><em>P</em><sub>1<sup>′</sup></sub>, <em>P</em><sub>2<sup>′</sup></sub>, ⋯, <em>P</em><sub><em>m</em><sup>′</sup></sub></span>是原转移概率矩阵<span class="math inline"><em>P</em></span>中一行的元素。</li><li><span class="math inline"><em>N</em><sub><em>k</em></sub></span>是第<span class="math inline"><em>k</em></span>个子矩阵中行元素之和。</li><li><span class="math inline"><em>M</em><sub><em>k</em></sub></span>是第<span class="math inline"><em>k</em></span>个子矩阵中列元素之和。</li><li><span class="math inline"><em>r</em></span>是子矩阵个数。</li></ul></li></ul></li><li><strong>例题</strong>：<img src="image-100.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h3 id="一般离散无记忆信道">一般离散无记忆信道</h3><ul><li><p><strong>转移概率<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>固定</strong></p></li><li><p><strong>信道容量</strong>： <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>x</em>)</sub><em>I</em>(<em>X</em>; <em>Y</em>) = max<sub><em>p</em>(<em>x</em>)</sub><em>I</em>(<em>p</em>(<em>x</em>), <em>p</em>(<em>y</em>|<em>x</em>))</span></p><p>即求互信息<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>关于输入概率分布<span class="math inline"><em>p</em>(<em>x</em>)</span>的极大值。</p></li><li><p><strong>互信息</strong>： <span class="math display">$$  \begin{align*}  I(X;Y)&amp;=\sum_{i}p(a_i)I(a_i;Y)\\  &amp;=\sum_{i}p(a_i)\sum_{j}p(b_j|a_i)\log\frac{p(a_i|b_j)}{p(a_i)}  \end{align*}  $$</span></p></li><li><p>为使<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>达到最大，输入符号概率集<span class="math inline">{<em>p</em>(<em>a</em><sub><em>i</em></sub>)}</span>必须满足的<strong>充分和必要条件</strong>是：</p><ul><li>对于所有<span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>) &gt; 0</span>的符号<span class="math inline"><em>a</em><sub><em>i</em></sub></span>，有<span class="math inline"><em>I</em>(<em>a</em><sub><em>i</em></sub>; <em>Y</em>) = <em>C</em></span></li><li>对于所有<span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>) = 0</span>的符号<span class="math inline"><em>a</em><sub><em>i</em></sub></span>，有<span class="math inline"><em>I</em>(<em>a</em><sub><em>i</em></sub>; <em>Y</em>) ≤ <em>C</em></span></li><li>这意味着除概率为0的符号<span class="math inline"><em>a</em><sub><em>i</em></sub></span>外，每个符号<span class="math inline"><em>a</em><sub><em>i</em></sub></span> 对<span class="math inline"><em>Y</em></span>提供相同的互信息</li></ul></li><li><p>注意：<strong>最佳输入分布不唯一！</strong></p></li><li><p>例题：<img src="image-33.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="离散序列信道及其容量">3.3 离散序列信道及其容量</h2><h3 id="信道模型与符号定义">信道模型与符号定义</h3><ul><li><figure><img src="image-24.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"><figcaption aria-hidden="true">信道模型</figcaption></figure></li><li>输入矢量为<span class="math inline">$\vec{X_{}}=(X_1,X_2,\cdots,X_L)$</span>，其中<span class="math inline"><em>X</em><sub><em>l</em></sub> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>输出矢量为<span class="math inline">$\vec{Y_{}}=(Y_1,Y_2,\cdots,Y_L)$</span>，其中<span class="math inline"><em>Y</em><sub><em>l</em></sub> ∈ {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li><li>条件概率表示为<span class="math inline">$p(\vec{Y_{}}|\vec{X_{}})$</span> ，即给定输入<span class="math inline">$\vec{X_{}}$</span>时输出<span class="math inline">$\vec{Y_{}}$</span>的概率。</li></ul><h3 id="无记忆离散序列信道">无记忆离散序列信道</h3><ul><li>对于无记忆离散序列信道： <span class="math display">$$p(\vec{Y_{}}|\vec{X_{}}) =p(Y_1,\cdots,Y_L|X_1,\cdots,X_L)=\prod_{l = 1}^{L}p(Y_l|X_l)$$</span><ul><li>若信道是平稳的： <span class="math display">$$p(\vec{Y_{}}|\vec{X_{}})=(p(y|x))^{L}=p^{L}(y|x)$$</span></li></ul></li><li><strong>互信息与信道容量</strong>: <span class="math display">$$  \begin{align*}  I(\vec{X_{}};\vec{Y_{}})&amp;=H(\vec{X_{}}) -H(\vec{X_{}}|\vec{Y_{}})=\sump(\vec{X_{}},\vec{Y_{}})\log\frac{p(\vec{X_{}}|\vec{Y_{}})}{p(\vec{X_{}})}\\  &amp;=H(\vec{Y_{}}) - H(\vec{Y_{}}|\vec{X_{}})=\sump(\vec{X_{}},\vec{Y_{}})\log\frac{p(\vec{Y_{}}|\vec{X_{}})}{p(\vec{Y_{}})}  \end{align*}  $$</span><ul><li><strong>信道无记忆时</strong>： <span class="math display">$$I(\vec{X_{}};\vec{Y_{}})\leq\sum_{l =1}^{L}I(X_l;Y_l)$$</span><ul><li>证明： 由定义有：<span class="math inline">$I(\vec{X_{}};\vec{Y_{}})=H(\vec{Y_{}})-H(\vec{Y_{}}|\vec{X_{}})$</span>和<span class="math inline"><em>I</em>(<em>X</em><sub><em>l</em></sub>; <em>Y</em><sub><em>l</em></sub>) = <em>H</em>(<em>Y</em><sub><em>l</em></sub>) − <em>H</em>(<em>Y</em><sub><em>l</em></sub>|<em>X</em><sub><em>l</em></sub>)</span>，利用<span class="math inline"><em>H</em>(<em>X</em>)</span>的链式法则有： ①<span class="math inline">$H(\vec{Y_{}})=H(Y_1,Y_2,\cdots,Y_L)=H(Y_1)+H(Y_2|Y_1)+\cdots+H(Y_L|Y_1,Y_2,\cdots,Y_{L- 1})\leq \sum_{l = 1}^{L}H(Y_l)$</span> ②<span class="math inline">$H(\vec{Y_{}}|\vec{X_{}})=H(Y_1|\vec{X_{}})+H(Y_2|Y_1,\vec{X_{}})+\cdots+H(Y_L|Y_1,Y_2,\cdots,Y_{L- 1},\vec{X_{}})=\sum_{l =1}^{L}H(Y_l|X_l)$</span>（无记忆信道下，给定&nbsp;<span class="math inline"><em>X</em><sub><em>l</em></sub></span>&nbsp;后，其他时刻的输入输出对确定&nbsp;<span class="math inline"><em>Y</em><sub><em>l</em></sub></span>&nbsp;的不确定性没有额外帮助）所以有：<span class="math inline">$I(\vec{X_{}};\vec{Y_{}})=H(\vec{Y_{}})-H(\vec{Y_{}}|\vec{X_{}})\leq\sum_{l = 1}^{L}H(Y_l)-\sum_{l = 1}^{L}H(Y_l|X_l)=\sum_{l =1}^{L}I(X_l;Y_l)$</span>。</li></ul></li><li><strong>输入矢量<span class="math inline">$\vec{X_{}}$</span>中各分量相互独立时</strong>：<span class="math display">$$I(\vec{X_{}};\vec{Y_{}})\geq\sum_{l =1}^{L}I(X_l;Y_l)$$</span><ul><li>证明： 由定义有：<span class="math inline">$I(\vec{X_{}};\vec{Y_{}})=H(\vec{X_{}}) -H(\vec{X_{}}|\vec{Y_{}})$</span>和<span class="math inline"><em>I</em>(<em>X</em><sub><em>l</em></sub>; <em>Y</em><sub><em>l</em></sub>) = <em>H</em>(<em>X</em><sub><em>l</em></sub>) − <em>H</em>(<em>X</em><sub><em>l</em></sub>|<em>Y</em><sub><em>l</em></sub>)</span>，利用<span class="math inline"><em>H</em>(<em>X</em>)</span>的链式法则有： ①<span class="math inline">$H(\vec{X_{}})=H(X_1,X_2,\cdots,X_L)=H(X_1)+H(X_2|X_1)+\cdots+H(X_L|X_1,X_2,\cdots,X_{L- 1})=\sum_{l = 1}^{L}H(X_l)$</span>（由于各分量相互独立） ②<span class="math inline">$H(\vec{X_{}}|\vec{Y_{}})=H(X_1|\vec{Y_{}})+H(X_2|X_1,\vec{Y_{}})+\cdots+H(X_L|X_1,X_2,\cdots,X_{L- 1},\vec{Y_{}})=\sum_{l = 1}^{L}H(X_l|\vec{Y_{}})\leq \sum_{l =1}^{L}H(X_l|Y_l)$</span>（已知更多信息&nbsp;<span class="math inline">$\vec{Y_{}}$</span>&nbsp;时，<span class="math inline"><em>X</em><sub><em>l</em></sub></span>&nbsp;的不确定性不会比仅知道&nbsp;<span class="math inline"><em>Y</em><sub><em>l</em></sub></span>&nbsp;时更大）所以有：<span class="math inline">$I(\vec{X_{}};\vec{Y_{}})=H(\vec{X_{}})-H(\vec{X_{}}|\vec{Y_{}})\geq\sum_{l = 1}^{L}H(X_l)-\sum_{l = 1}^{L}H(X_l|\vec{Y_{}})=\sum_{l =1}^{L}I(X_l;Y_l)$</span>。</li></ul></li><li><strong>当输入矢量<span class="math inline">$\vec{X_{}}$</span>独立且信道无记忆时</strong>，上述两个性质统一取等号，此时<strong>信道容量</strong>：<span class="math display">$$  \begin{align*}  C_L&amp;=\max_{p(x)}I(\vec{X_{}};\vec{Y_{}})=\max_{p(x)}\sum_{l =1}^{L}I(X_l;Y_l)\\  &amp;=\sum_{l = 1}^{L}\max_{p(x)}I(X_l;Y_l)=\sum_{l = 1}^{L}C_l  \end{align*}  $$</span><ul><li>当信道平稳时<span class="math inline"><em>C</em><sub><em>L</em></sub> = <em>L</em><em>C</em><sub>1</sub></span></li><li>一般情况下，<span class="math inline">$I(\vec{X_{}};\vec{Y_{}})\leqLC_1$</span> ，其中<span class="math inline"><em>C</em><sub>1</sub></span>是单个时刻的信道容量</li></ul></li></ul></li><li>输入矢量独立且信道无记忆时，相当于对单个信道进行<span class="math inline"><em>L</em></span>次扩展的信道，也相当于<span class="math inline"><em>L</em></span>个独立的信道并联在一起。</li><li>示例：<img src="image-101.webp" srcset="/img/loading/loading3.gif" lazyload alt="示例"></li></ul><h3 id="独立并联信道">独立并联信道</h3><ul><li>图例: <img src="image-25.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"></li><li>每个信道输出<span class="math inline"><em>Y</em><sub><em>l</em></sub></span>只与本信道的输入<span class="math inline"><em>X</em><sub><em>l</em></sub></span>有关，即：<span class="math display"><em>p</em>(<em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>L</em></sub>|<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub>) = <em>p</em>(<em>Y</em><sub>1</sub>|<em>X</em><sub>1</sub>)<em>p</em>(<em>Y</em><sub>2</sub>|<em>X</em><sub>2</sub>)⋯<em>p</em>(<em>Y</em><sub><em>L</em></sub>|<em>X</em><sub><em>L</em></sub>)</span><strong>信道无记忆</strong>, 并且有 <span class="math display">$$I(\vec{X_{}};\vec{Y_{}})\leq\sum_{l =1}^{L}I(X_l;Y_l)$$</span></li><li>并联信道容量 <span class="math display">$$C_{12\cdots L}=\maxI(\vec{X_{}};\vec{Y_{}})\leq\sum_{l = 1}^{L}C_l$$</span></li><li>当输入符号<span class="math inline"><em>X</em><sub><em>l</em></sub></span>相互独立，且<span class="math inline"><em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub>)</span>达到最佳分布时，容量最大，此时：<span class="math display">$$C_{12\cdots L}=\sum_{l =1}^{L}C_l$$</span></li></ul><h3 id="有记忆离散序列信道">有记忆离散序列信道</h3><blockquote><p>有记忆的离散序列信道复杂得多，不作介绍。</p></blockquote><h2 id="连续信道及其容量">3.4 连续信道及其容量</h2><h3 id="连续单符号加性信道">连续单符号加性信道</h3><h4 id="加性高斯信道">加性高斯信道</h4><ul><li><p><strong>信道模型</strong>：</p><ul><li><figure><img src="image-27.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"><figcaption aria-hidden="true">信道模型</figcaption></figure></li><li>$ y = x + n $</li><li>$ n $：加性噪声</li><li>$P_n(n) N(0, ^2) = e^{-} $。</li></ul></li><li><p><strong>微分熵</strong>： <span class="math display">$$H_c(n) =-\int_{-\infty}^{+\infty} P_n(n) \log P_n(n) dn = \frac{1}{2} \log(2\pie \sigma^2) $$</span></p></li><li><p><strong>互信息</strong>： <span class="math display">$$  \begin{align*}  I(X;Y) &amp;= H_c(X) - H_c(X|Y) \\  &amp;= H_c(Y) - H_c(Y|X) \\  \end{align*}  $$</span></p></li><li><p><strong>信道容量</strong>： <span class="math display">$$  \begin{align*}  C = \max_{p(x)} I(X;Y) &amp;= \max_{p(x)} [H_c(Y) - H_c(Y|X)] \\  &amp;= \max_{p(x)} H_c(Y) - \frac{1}{2} \log(2\pi e \sigma^2)  \end{align*}  $$</span></p><p>其中 $ H_c(Y|X) $ 是噪声熵，由于<span class="math inline"><em>x</em></span>与<span class="math inline"><em>n</em></span>相独立，所以<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>) = <em>p</em>(<em>x</em> + <em>n</em>|<em>x</em>) = <em>p</em>(<em>n</em>)</span>，所以$H_c(Y|X) = H_n(n) = (2e ^2) $。</p></li><li><p><strong>求 $ H_c(Y) $ 最大值</strong>： <span class="math display">$$  \begin{align*}  &amp;y = x + n , y \in (-\infty, +\infty) ，y是功率受限信号\\  &amp;\Rightarrow Y 正态分布时熵最大\\  &amp;\Rightarrow Y 正态分布时信道容量最大\\  \end{align*}  $$</span></p></li><li><p><span class="math inline"><em>y</em></span> 的功率 <span class="math inline"><em>P</em></span>（其中 <span class="math inline"><em>S</em></span> 是输入信号 <span class="math inline"><em>x</em></span> 的平均功率，<span class="math inline"><em>σ</em><sup>2</sup></span> 是噪声功率） <span class="math display"><em>P</em> = <em>S</em> + <em>σ</em><sup>2</sup></span></p><ul><li><p>若 <span class="math inline"><em>P</em><sub><em>Y</em></sub>(<em>y</em>) ∼ <em>N</em>(0, <em>P</em>)</span>，<span class="math inline"><em>P</em><sub><em>n</em></sub>(<em>n</em>) ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span>，<span class="math inline"><em>x</em> = <em>y</em> − <em>n</em></span>，则<span class="math inline"><em>P</em><sub><em>X</em></sub>(<em>x</em>) ∼ <em>N</em>(0, <em>S</em>)</span>。</p></li><li><p>当输入 $ X $ 是均值为 0，方差为 $ S $的高斯分布时，<strong>信息传输率</strong>达最大，等于<strong>信道容量</strong>：<span class="math display">$$  \begin{align*}  C &amp;= \frac{1}{2} \log(2\pi e P) - \frac{1}{2} \log(2\pi e\sigma^2) \\  &amp;= \frac{1}{2} \log \frac{P}{\sigma^2} \\  &amp;= \frac{1}{2} \log \left(1 + \frac{S}{\sigma^2}\right)\\  &amp;= \frac{1}{2} \log(1 + SNR) \quad bit/符号  \end{align*}  $$</span></p><p>其中 <span class="math inline">$SNR=\frac{S}{\sigma^2}$</span>，<span class="math inline"><em>S</em><em>N</em><em>R</em><sub><em>d</em><em>B</em></sub> = 10log<sub>10</sub><em>S</em><em>N</em><em>R</em></span>。</p></li></ul></li></ul><h4 id="加性非高斯信道">加性非高斯信道</h4><ul><li><p>对于加性、均值为 0、平均功率为 $ ^2 $ 的非高斯信道： <span class="math display"><em>C</em> = max (<em>H</em><sub><em>c</em></sub>(<em>Y</em>) − <em>H</em><sub><em>c</em></sub>(<em>n</em>))</span></p></li><li><p>高斯分布时： <span class="math display">$$H_c(Y)_{max} =\frac{1}{2} \log(2\pi e P) $$</span></p><p><span class="math display">$$H_c(n)_{max} = \frac{1}{2} \log(2\pi e\sigma^2) $$</span></p></li><li><p>满足： <span class="math display">$$\frac{1}{2} \log(2\pi e P) -\frac{1}{2} \log(2\pi e \sigma^2) \leq C \leq \frac{1}{2} \log(2\pi e P)- H_c(n) $$</span></p></li></ul><h3 id="多维无记忆加性连续信道">多维无记忆加性连续信道</h3><ul><li><p><strong>信道模型</strong>：</p><ul><li><figure><img src="image-28.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"><figcaption aria-hidden="true">信道模型</figcaption></figure><ul><li>输入<span class="math inline"><em>X</em></span>的总功率<span class="math inline">$P = \sum_{l = 1}^{L}P_l$</span>，<span class="math inline"><em>P</em><sub><em>l</em></sub></span>是第<span class="math inline"><em>l</em></span>个输入信号的功率</li><li><span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup></span>是第<span class="math inline"><em>l</em></span>个噪声的功率</li></ul></li><li>信道无记忆 <span class="math display">$$  p(\vec{y_{}}|\vec{x_{}}) = \prod_{l = 1}^{L} p(y_l|x_l)  $$</span></li><li>加性噪声各时刻独立 <span class="math display">$$  p_n(\vec{n_{}}) = p_y(\vec{y_{}}|\vec{x_{}}) = \prod_{l = 1}^{L}p_n(n_l) \quad n_l \sim N(0, \sigma_l^2)  $$</span></li></ul></li><li><p><strong>互信息</strong>： <span class="math display">$$  I(\vec{X_{}}; \vec{Y_{}}) \leq \sum_{l = 1}^{L} I(X_l; Y_l) \leq\sum_{l = 1}^{L} \frac{1}{2} \log(1 + \frac{P_l}{\sigma_l^2})  $$</span></p></li><li><p><strong>信道容量</strong>： <span class="math display">$$  C = \max_{p(x)} I(\vec{X_{}}; \vec{Y_{}}) = \sum_{l = 1}^{L}\frac{1}{2} \log(1 + \frac{P_l}{\sigma_l^2}) \quad \text{bit}/L \text{序列}  $$</span></p><p>当且仅当输入随机变量 <span class="math inline">$\vec{X_{}}$</span>中各分量统计独立，且均值为0，方差为 <span class="math inline"><em>P</em><sub><em>l</em></sub></span>的高斯分布时，才能达到此容量。</p></li></ul><ol type="1"><li><p><strong><span class="math inline"><em>L</em></span>个高斯噪声每个单元时刻噪声功率相等</strong>，<span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup> = <em>σ</em><sup>2</sup></span>，<span class="math inline"><em>l</em> ∈ {1, 2, ⋯, <em>L</em>}</span>，有 <span class="math display">$$C = \frac{L}{2} \log(1 + \frac{S}{\sigma^2}) \quad, \quad S =\frac{P}{L}$$</span> <span class="math inline">$\vec{X_{}}$</span> 的各分量满足<span class="math inline"><em>N</em>(0, <em>S</em>)</span>分布时，达到信道容量。</p></li><li><p><strong><span class="math inline"><em>L</em></span>个高斯噪声均值为0，方差不同且为 <span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup></span>时</strong>，若输入信号的总平均功率受限，即 <span class="math display">$$E\left[\sum_{l = 1}^{L} x_l^2\right] = \sum_{l = 1}^{L} E[x_l^2] =\sum_{l = 1}^{L} P_l = P$$</span></p><ul><li><figure><img src="image-29.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li><p><strong>怎样合理分配各单元时刻的信号平均功率，才能使信道传输率最大？</strong>用拉格朗日乘数法，作辅助函数 <span class="math display">$$  f(P_1, P_2, \cdots, P_L) = \sum_{l = 1}^{L} \frac{1}{2} \log(1 +\frac{P_l}{\sigma_l^2}) + \lambda (\sum_{l = 1}^{L} P_l - P)  $$</span></p><p>对第一项求最大，第二项为约束条件 令 <span class="math inline">$\frac{\partial f( )}{\partial P_l} =0$</span>，<span class="math inline"><em>l</em> = 1, 2, ⋯, <em>L</em></span> 得 <span class="math display">$$  \begin{align*}  \frac{1}{2} \frac{1}{P_l + \sigma_l^2} + \lambda = 0 \quad, \quad l =1,2,\cdots,L\\  \Rightarrow P_l + \sigma_l^2 = -\frac{1}{2\lambda} \quad, \quad l =1,2,\cdots,L  \end{align*}  $$</span></p><p>令各时刻信道输出总功率（信号功率 <span class="math inline"><em>P</em><sub><em>l</em></sub></span> + 噪声功率<span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup></span>）相等，设为<span class="math inline"><em>V</em></span> <span class="math display">$$  V = \frac{P + \sum_{l = 1}^{L} \sigma_l^2}{L}  $$</span></p><p>当 <span class="math inline">$P_l = V - \sigma_l^2 = \frac{P +\sum_{l = 1}^{L} \sigma_l^2}{L} - \sigma_l^2$</span>，<span class="math inline"><em>l</em> = 1, 2, ⋯, <em>L</em></span>时，<strong>信道传输率达到最大</strong> <span class="math display">$$  \begin{align*}  C &amp;= \sum_{l = 1}^{L} \frac{1}{2} \log(1 +\frac{P_l}{\sigma_l^2})  = \frac{1}{2} \sum_{l = 1}^{L} \log \frac{P +\sum_{l = 1}^{L} \sigma_l^2}{L\sigma_l^2} \\  &amp;= \frac{1}{2} \sum_{l = 1}^{L} \log \frac{V}{\sigma_l^2}  \end{align*}  $$</span></p><p>若 <span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup></span>太大，大于 <span class="math inline"><em>V</em></span>，则置 <span class="math inline"><em>P</em><sub><em>l</em></sub> = 0</span>，然后重新调整功率分配，直到<span class="math inline"><em>P</em><sub><em>l</em></sub></span>不再出现负值。</p></li><li><p><strong>例题</strong>：<img src="image-88.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul></li></ol><h3 id="限时限频限功率加性高斯白噪声信道">限时限频限功率加性高斯白噪声信道</h3><h4 id="波形信道限时-t_b限频-omega">波形信道，限时 <span class="math inline"><em>t</em><sub><em>B</em></sub></span>，限频 <span class="math inline"><em>ω</em></span></h4><ul><li><strong>信道模型</strong>：<ul><li><figure><img src="image-30.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"><figcaption aria-hidden="true">信道模型</figcaption></figure></li></ul></li><li><strong>互信息</strong>： <span class="math display">$$  \begin{align*}  I(x(t); y(t)) &amp;= \lim_{L \to \infty} I(\vec{X_{}}; \vec{Y_{}}) \\  &amp;= \lim_{L \to \infty} [H_c(\vec{X_{}}) -H_c(\vec{X_{}}|\vec{Y_{}})] \\  &amp;= \lim_{L \to \infty} [H_c(\vec{Y_{}}) -H_c(\vec{Y_{}}|\vec{X_{}})] \quad \text{bit/波形}  \end{align*}  $$</span></li><li><strong>单位时间内的信息传输率</strong> <span class="math inline"><em>R</em><sub><em>t</em></sub></span> 为： <span class="math display">$$  R_t=\lim_{t_B \to \infty}\frac{1}{t_B}I(\vec{X_{}}; \vec{Y_{}})\quad\text{ bit/秒} \quad (t_B：\text{秒/波形})  $$</span></li><li><strong>信道容量</strong>: <span class="math display">$$  C_t=\max_{p(x)}[\lim_{t_B \to \infty}\frac{1}{t_B}I(\vec{X_{}};\vec{Y_{}})]\quad \text{ bit/秒}  $$</span></li><li>带宽受限加性高斯白噪声 <span class="math inline"><em>n</em>(<em>t</em>)</span>，均值为0，功率谱密度<span class="math inline">$\frac{N_0}{2}$</span></li></ul><h4 id="加性高斯白噪声">加性高斯白噪声</h4><ul><li><strong>模型</strong>： <img src="image-31.webp" srcset="/img/loading/loading3.gif" lazyload alt="模型"><ul><li><span class="math inline"><em>y</em>(<em>t</em>) = <em>x</em>(<em>t</em>) + <em>n</em>(<em>t</em>)</span></li><li>相关函数:<ul><li><span class="math inline"><em>P</em><sub><em>n</em></sub>(<em>n</em>) ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span></li><li><span class="math inline">$R_n(\tau) =\frac{N_0}{2}\delta(\tau)$</span></li><li>功率谱密度 <span class="math inline">$\Phi_n(f) =\frac{N_0}{2}$</span></li><li>总噪声功率 $^2 = = N_0$</li><li><span class="math inline"><em>N</em><sub>0</sub> = <em>k</em><em>T</em></span></li><li>波茨曼常数 <span class="math inline"><em>k</em></span></li><li>绝对温度 <span class="math inline"><em>T</em></span></li></ul></li></ul></li></ul><h4 id="低频带宽受限通信系统">低频带宽受限通信系统</h4><ul><li><p>在 <span class="math inline">[0, <em>t</em><sub><em>B</em></sub>]</span>内，采样个数 <span class="math inline"><em>L</em> = 2<em>ω</em><em>t</em><sub><em>B</em></sub></span>，各样本值彼此独立。</p></li><li><p>通信带宽为 $2$，噪声功率为 $2=N_0$ <span class="math display">$$  \begin{align*}  &amp;C=\frac{1}{2}\sum_{l = 1}^{L}\log(1 + \frac{P_l}{\sigma_l^2})\\  &amp;\sigma_l^2 = P_n=\frac{\frac{N_0}{2}\cdot 2\omega \cdott_B}{L}=\frac{\frac{N_0}{2}\cdot 2\omega \cdot t_B}{2\omega \cdott_B}=\frac{N_0}{2}\\  &amp;P_l = \frac{P_s t_B}{2\omega t_B}=\frac{P_s}{2\omega }  \end{align*}  $$</span></p></li><li><p>对于平稳系统 <span class="math display">$$  \begin{align*}  C&amp;=\frac{L}{2}\log(1 + \frac{P_s}{2\omega }\cdot\frac{2}{N_0})\\  &amp;=\frac{L}{2}\log(1 + \frac{P_s}{N_0\omega })\\  &amp;=\omega t_B\log(1 + \frac{P_s}{N_0\omega }) \quad \text{ bit}/L\text{维符号序列}  \end{align*}  $$</span></p></li><li><p>单位时间的信道容量 <span class="math display">$$  \begin{align*}  C_t&amp;=\lim_{t_B \to \infty}\frac{C}{t_B}\\  &amp;=\omega \log(1 + \frac{P_s}{N_0\omega })\quad \text{ bit/秒}\\  &amp;=\omega \log(1 + SNR)\quad \text{ bit/秒}  \end{align*}  $$</span></p><p>其中:</p><ul><li><span class="math inline"><em>P</em><sub><em>s</em></sub></span>：信号平均功率</li><li><span class="math inline"><em>N</em><sub>0</sub><em>ω</em></span>：噪声在系统中的平均功率（<span class="math inline">$\frac{N_0}{2}\cdot 2\omega=N_0\omega$</span>）</li><li><span class="math inline"><em>S</em><em>N</em><em>R</em><sub><em>d</em><em>B</em></sub> = 10log<sub>10</sub><em>S</em><em>N</em><em>R</em></span></li></ul></li><li><p>例题：<img src="image-102.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="多输入多输出信道及其容量">3.5 多输入多输出信道及其容量</h2><blockquote><p>略</p></blockquote><h2 id="信源与信道的匹配">3.6 信源与信道的匹配</h2><ul><li><strong>符号匹配</strong><ul><li><figure><img src="image-32.webp" srcset="/img/loading/loading3.gif" lazyload alt="符号匹配"><figcaption aria-hidden="true">符号匹配</figcaption></figure></li><li>信源编码：将信源符号转换为信道符号</li></ul></li><li><strong>信息匹配</strong><ul><li>信道绝对冗余度 <span class="math inline"><em>R</em><sub><em>a</em></sub> = <em>C</em> − <em>I</em>(<em>X</em>; <em>Y</em>)</span></li><li>信道相对冗余度 <span class="math inline">$R_r = 1 -\frac{I(X;Y)}{C}$</span></li><li>信道效率 <span class="math inline">$E =\frac{I(X;Y)}{C}$</span></li></ul></li></ul><h1 id="第四章-信息率失真函数">第四章 信息率失真函数</h1><h2 id="信息率失真函数的概念和性质">4.1 信息率失真函数的概念和性质</h2><h3 id="失真函数">失真函数</h3><ul><li><p><strong>信源编码器模型</strong>：</p><ul><li><figure><img src="image-34.webp" srcset="/img/loading/loading3.gif" lazyload alt="失真函数"><figcaption aria-hidden="true">失真函数</figcaption></figure></li><li>信源 <span class="math inline"><em>X</em> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>经信源编码器输出 <span class="math inline"><em>Y</em> ∈ {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li></ul></li><li><p><strong>失真函数</strong> <span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span>定义为： <span class="math display">$$d(x_i,y_j)=\begin{cases}0, &amp;x_i = y_j \\ \alpha, &amp; \alpha&gt;0, x_i\neqy_j\end{cases}$$</span></p></li><li><p><strong>失真矩阵</strong> <span class="math inline"><em>d</em></span> 定义为： <span class="math display">$$d = [d(x_i,y_j)]_{n×m} =\begin{bmatrix}d(a_1,b_1)&amp;d(a_1,b_2)&amp;\cdots&amp;d(a_1,b_m)\\\cdots\\d(a_n,b_1)&amp;d(a_n,b_2)&amp;\cdots&amp;d(a_n,b_m)\end{bmatrix}$$</span></p></li><li><p><span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span>的函数形式可任意选择，常用的有：</p><ul><li><strong>均方失真</strong>：<span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = (<em>x</em><sub><em>i</em></sub> − <em>y</em><sub><em>j</em></sub>)<sup>2</sup></span>（连续信源）</li><li><strong>绝对失真</strong>：<span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = |<em>x</em><sub><em>i</em></sub> − <em>y</em><sub><em>j</em></sub>|</span>（连续信源）</li><li><strong>相对失真</strong>：<span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = |<em>x</em><sub><em>i</em></sub> − <em>y</em><sub><em>j</em></sub>|/|<em>x</em><sub><em>i</em></sub>|</span>（连续信源）</li><li><strong>误码失真</strong>：<span class="math inline">$d(x_i,y_j)=\delta(x_i,y_j)=\begin{cases}0, &amp;x_i = y_j \\ 1, &amp; 其他\end{cases}$</span> （离散信源）</li></ul></li><li><p>例题：<img src="image-89.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h3 id="平均失真">平均失真</h3><ul><li><p>对于离散随机变量，<strong>平均失真</strong> <span class="math inline">$\overline{D}$</span> 的计算公式为： <span class="math display">$$  \begin{aligned}  \overline{D} = E(d(x_i,y_j)) &amp;= \sum_{i = 1}^{n}\sum_{j =1}^{m}p(a_i,b_j)d(a_i,b_j) \\  &amp;= \sum_{i = 1}^{n}\sum_{j = 1}^{m}p(a_i)p(b_j|a_i)d(a_i,b_j)  \end{aligned}  $$</span></p><p>其中:</p><ul><li><span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>是信源符号分布</li><li><span class="math inline"><em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>)</span>是有失真编码器转移概率分布</li><li><span class="math inline"><em>d</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)</span>是离散随机变量失真函数</li></ul></li></ul><h3 id="信息率失真函数-rd">信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span></h3><ul><li><p>将信源编码器看作信道：<img src="image-35.webp" srcset="/img/loading/loading3.gif" lazyload alt="假想信道"></p></li><li><p>编码的目的：</p><ul><li>使传输率 <span class="math inline"><em>R</em></span> 尽量小</li><li>但是<span class="math inline"><em>R</em></span> 越小，<span class="math inline">$\overline{D}$</span> 越大</li><li>在满足 <span class="math inline">$\overline{D} \leq D$</span>条件下，选择一种编码方法使 <span class="math inline"><em>R</em></span>尽量小</li></ul></li><li><p><strong>信息传输率</strong> <span class="math inline"><em>R</em> = <em>I</em>(<em>X</em>; <em>Y</em>)</span>，计算公式为：<span class="math display">$$  \begin{aligned}  R = I(X;Y) &amp; =\sum_{i,j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{p(y_j)} \\  &amp;=\sum_{i,j}p(x_i)p(y_j|x_i)\log\frac{p(y_j|x_i)}{\sum_{i}p(x_i)p(y_j|x_i)}  \end{aligned}  $$</span></p></li><li><p>对于某特定信源，<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>确定，<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是关于<span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span>的凸函数（<span class="math inline">∪</span>型下凸函数），可以从信道集合<span class="math inline"><em>P</em><sub><em>D</em></sub></span>中找到一种信道 <span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span>，使<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>最小。</p><ul><li><strong>信道集合</strong> <span class="math inline"><em>P</em><sub><em>D</em></sub></span>（<span class="math inline"><em>D</em></span>允许试验信道）定义为： <span class="math display">$$P_D = \{p(b_j|a_i) \quad|\quad \overline{D} \leqD, i = 1,2,\cdots,n;j = 1,2,\cdots,m\}$$</span></li><li><strong>信息率失真函数</strong> <span class="math inline"><em>R</em>(<em>D</em>)</span> 为： <span class="math display"><em>R</em>(<em>D</em>) = min<sub><em>P</em><sub><em>D</em></sub></sub><em>I</em>(<em>X</em>; <em>Y</em>)</span></li><li>对于<strong>离散无记忆信道</strong>，<span class="math inline"><em>R</em>(<em>D</em>)</span> 可写成： <span class="math display">$$R(D)=\min_{P_{ij}\in P_D}\sum_{i = 1}^{n}\sum_{j= 1}^{m}p(a_i)p(b_j|a_i)\log\frac{p(b_j|a_i)}{p(b_j)}$$</span></li></ul></li><li><p>例题：<img src="image-36.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h3 id="信息率失真函数的性质">信息率失真函数的性质</h3><h4 id="rd函数的定义域"><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的定义域</h4><ol type="1"><li><strong><span class="math inline"><em>D</em><sub><em>m</em><em>i</em><em>n</em></sub></span>和<span class="math inline"><em>R</em>(<em>D</em><sub><em>m</em><em>i</em><em>n</em></sub>)</span></strong><ul><li>平均失真<span class="math inline"><em>D</em></span>是失真函数<span class="math inline"><em>d</em>(<em>x</em>, <em>y</em>)</span>的数学期望，因此<span class="math inline"><em>D</em></span>也是非负实数，所以<span class="math inline"><em>D</em><sub><em>m</em><em>i</em><em>n</em></sub> = 0</span>。</li><li><span class="math display"><em>R</em>(<em>D</em><sub><em>m</em><em>i</em><em>n</em></sub>) = <em>R</em>(0) = <em>H</em>(<em>X</em>)</span>等式成立的条件：<ul><li><span class="math inline"><em>D</em><sub><em>m</em><em>i</em><em>n</em></sub> = 0</span>：失真矩阵中每行至少有一个零，令条件概率在该行该处为1</li><li><span class="math inline"><em>R</em>(0) = <em>H</em>(<em>X</em>)</span>：每一列最多只有一个零，否则多个<span class="math inline"><em>X</em></span>对应一个<span class="math inline"><em>Y</em></span>，<span class="math inline"><em>R</em>(0) = <em>H</em>(<em>Y</em>) &lt; <em>H</em>(<em>X</em>)</span>。</li></ul></li><li>对于连续信源，<span class="math inline"><em>R</em>(<em>D</em><sub><em>m</em><em>i</em><em>n</em></sub>) = <em>R</em>(0) = <em>H</em><sub><em>c</em></sub>(<em>X</em>) = ∞</span>。</li></ul></li><li><strong><span class="math inline"><em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>和<span class="math inline"><em>R</em>(<em>D</em><sub><em>m</em><em>a</em><em>x</em></sub>)</span></strong><ul><li><p><span class="math display"><em>D</em><sub><em>m</em><em>a</em><em>x</em></sub> = min<sub><em>R</em>(<em>D</em>) = 0</sub><em>D</em></span><span class="math display"><em>R</em>(<em>D</em><sub><em>m</em><em>a</em><em>x</em></sub>) = 0</span></p></li><li><p>当<span class="math inline"><em>R</em>(<em>D</em>) = 0</span>，即<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = 0</span>，<span class="math inline"><em>X</em></span>、<span class="math inline"><em>Y</em></span>互相独立，<span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = <em>p</em>(<em>y</em><sub><em>j</em></sub>) = <em>p</em><sub><em>j</em></sub></span></p></li><li><p><span class="math display">$$\overline{D}=\sum_{i = 1}^{n}\sum_{j= 1}^{m}p_ip_jd_{ij}$$</span> 其中<span class="math inline"><em>p</em><sub><em>i</em></sub></span>、<span class="math inline"><em>d</em><sub><em>i</em><em>j</em></sub></span>已知，<span class="math inline"><em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>为满足<span class="math inline">∑<sub><em>j</em></sub><em>p</em><sub><em>j</em></sub> = 1</span>条件下<span class="math inline">$\overline{D}$</span>的最小值。</p></li><li><p><span class="math display">$$\begin{align*}D_{max} &amp; =\min\sum_{j = 1}^{m}p_j\sum_{i = 1}^{n}p_id_{ij} \\&amp;=\min_{j = 1,2,\cdots,m}\sum_{i = 1}^{n}p_id_{ij}\end{align*}$$</span> 即在<span class="math inline"><em>j</em> = 1, 2, ⋯, <em>m</em></span>中，找到<span class="math inline">$\sum_{i = 1}^{n}p_id_{ij}$</span>值最小的一列<span class="math inline"><em>j</em></span>，此时取<span class="math inline"><em>p</em><sub><em>j</em></sub> = 1</span>，其余置<span class="math inline">0</span></p></li></ul></li><li><strong><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的定义域和值域</strong><ul><li><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的最大定义域为<span class="math display">$$[0\quad, \min_{j = 1,2,\cdots,m}\sum_{i =1}^{n}p_id_{ij}]$$</span></li><li><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的最大值域为<span class="math display">[0, <em>H</em>(<em>X</em>)]</span></li><li><figure><img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload alt="函数图像"><figcaption aria-hidden="true">函数图像</figcaption></figure></li></ul></li></ol><ul><li>例题：<ul><li><figure><img src="image-90.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li><li><figure><img src="image-91.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li></ul></li></ul><h4 id="rd函数的下凸性和连续性"><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的下凸性和连续性</h4><ul><li><figure><img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload alt="函数图像"><figcaption aria-hidden="true">函数图像</figcaption></figure></li><li><p><strong>下凸性</strong>： <span class="math display"><em>D</em><sup><em>α</em></sup> = <em>α</em><em>D</em><sup>′</sup> + (1 − <em>α</em>)<em>D</em><sup>″</sup>  0 ≤ <em>α</em> ≤ 1</span></p><p>有 <span class="math display"><em>R</em>(<em>D</em><sup><em>α</em></sup>) ≤ <em>α</em><em>R</em>(<em>D</em><sup>′</sup>) + (1 − <em>α</em>)<em>R</em>(<em>D</em><sup>″</sup>)</span></p></li><li><p><strong>连续性</strong>： 设 <span class="math inline"><em>D</em><sup>′</sup> = <em>D</em> + <em>δ</em></span>，当<span class="math inline"><em>δ</em> → 0</span> 时，<span class="math inline"><em>P</em><sub><em>D</em><sup>′</sup></sub> → <em>P</em><sub><em>D</em></sub></span>，<span class="math inline"><em>R</em>(<em>D</em><sup>′</sup>) → <em>R</em>(<em>D</em>)</span>。</p></li></ul><h4 id="rd函数的单调递减性"><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的单调递减性</h4><ul><li>允许的失真度越大，所要求的信息率就越小。</li><li>规定了允许失真 <span class="math inline"><em>D</em></span>，及失真函数 <span class="math inline"><em>d</em>(<em>i</em>, <em>j</em>)</span>，可以找到<span class="math inline"><em>R</em>(<em>D</em>)</span>，作为衡量信源编码压缩难度的一把尺子。</li></ul><h4 id="信息率失真函数与信道容量">信息率失真函数与信道容量</h4><table><thead><tr><th style="text-align: left;"></th><th style="text-align: left;">信道容量 <span class="math inline"><em>C</em></span></th><th style="text-align: left;">信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span></th></tr></thead><tbody><tr><td style="text-align: left;">研究对象</td><td style="text-align: left;">信道</td><td style="text-align: left;">信源</td></tr><tr><td style="text-align: left;">给定条件</td><td style="text-align: left;"><span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>∥<em>x</em><sub><em>i</em></sub>)</span></td><td style="text-align: left;"><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span></td></tr><tr><td style="text-align: left;">选择参数</td><td style="text-align: left;"><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span></td><td style="text-align: left;"><span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>∥<em>x</em><sub><em>i</em></sub>)</span></td></tr><tr><td style="text-align: left;">结论</td><td style="text-align: left;"><span class="math inline"><em>C</em> = max<sub><em>p</em>(<em>x</em>)</sub><em>I</em>(<em>X</em>; <em>Y</em>)</span></td><td style="text-align: left;"><span class="math inline"><em>R</em>(<em>D</em>) = min<sub><em>P</em><sub><em>D</em></sub></sub><em>I</em>(<em>X</em>; <em>Y</em>)</span></td></tr><tr><td style="text-align: left;"><span class="math inline"><em>H</em>(<em>X</em>∥<em>Y</em>) = <em>H</em>(<em>X</em>) − <em>I</em>(<em>X</em>; <em>Y</em>)</span></td><td style="text-align: left;">噪声干扰丢失的信息量</td><td style="text-align: left;">编码压缩损失的信息量</td></tr></tbody></table><h2 id="信息率失真函数rd的计算参量表示法">4.2 信息率失真函数<span class="math inline"><em>R</em>(<em>D</em>)</span>的计算（参量表示法）</h2><h3 id="例题">例题</h3><ol type="1"><li><strong>例题1</strong>： 已知<span class="math inline"><em>X</em>, <em>Y</em> ∈ {0, 1}</span>，<span class="math inline">$p(X) =\begin{cases}p, &amp;X=0 \\ 1-p, &amp;X=1\end{cases}$</span>，<span class="math inline">$0 &lt;p\leq\frac{1}{2}$</span>，<span class="math inline">$d(x,y)=\begin{cases}1, &amp; x\neq y \\ 0, &amp; x= y\end{cases}$</span> <strong>证明</strong>：<span class="math inline">$R(D)=\begin{cases}H_b(p)-H_b(D), &amp; 0\leq D\leqp \\ 0, &amp; D &gt; p\end{cases}$</span>，其中<span class="math inline"><em>H</em><sub><em>b</em></sub>(<em>p</em>) = <em>H</em>(<em>p</em>, 1 − <em>p</em>)</span>，<span class="math inline"><em>H</em><sub><em>b</em></sub>(<em>D</em>) = <em>H</em>(<em>D</em>, 1 − <em>D</em>)</span><ul><li>由<span class="math inline"><em>R</em>(<em>D</em>)</span>性质可得<strong>定义域</strong>：失真矩阵 <span class="math inline">$d=\begin{bmatrix}0&amp;1\\1&amp;0\end{bmatrix}$</span>，令转移概率矩阵<span class="math inline">$P=\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix}$</span><span class="math inline"><em>D</em><sub><em>m</em><em>i</em><em>n</em></sub> = 0</span>，<span class="math inline"><em>R</em>(0) = <em>H</em>(<em>X</em>) = <em>H</em><sub><em>b</em></sub>(<em>p</em>)</span><span class="math inline"><em>D</em><sub><em>m</em><em>a</em><em>x</em></sub> = min [<em>p</em>, 1 − <em>p</em>]</span>= p</li><li><strong>求<span class="math inline"><em>R</em>(<em>D</em>)</span></strong>： <span class="math inline"><em>R</em>(<em>D</em>) = min <em>I</em>(<em>X</em>; <em>Y</em>)</span>，限制条件<span class="math inline">$P_D = \{p(y|x) | \overline{D}=E(d(X,Y))\leq D\leqD_{max} = p\}$</span> 令 <span class="math inline">$Z = d(X,Y) =\begin{cases}1, &amp; x\neq y \\ 0, &amp; x = y\end{cases}$</span> <span class="math inline"><em>p</em>(<em>x</em>|<em>y</em>) = <em>p</em>(<em>z</em>|<em>y</em>)</span>，<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Z</em>|<em>Y</em>)</span>又<span class="math inline">$p(z=1) = p_r(x \neq y)=E(d(X,Y))\leq D\leqp\leq \frac{1}{2}$</span> 且<span class="math inline"><em>H</em><sub><em>b</em></sub>(<em>x</em>)</span>函数关于<span class="math inline">$\frac{1}{2}$</span>对称，在<span class="math inline">$0\leq x \leq\frac{1}{2}$</span>范围内，<span class="math inline"><em>H</em><sub><em>b</em></sub>(<em>x</em>)</span>函数单调递增。则<span class="math inline"><em>H</em>(<em>Z</em>) = <em>H</em><sub><em>b</em></sub>(<em>p</em><sub><em>r</em></sub>(<em>x</em> ≠ <em>y</em>)) ≤ <em>H</em><sub><em>b</em></sub>(<em>D</em>)</span><span class="math display">$$  \begin{align*}  I(X;Y)&amp;=H(X)-H(X|Y)\\  &amp;=H_b(p)-H(X|Y)\\  &amp;=H_b(p)-H(Z|Y)（令z=d(x,y)）\\  &amp;\geq H_b(p)-H(Z) （H(Z|Y)\leq H(Z)）\\  &amp;\geq H_b(p)-H_b(D) （H(Z) \leq H_b(D)）  \end{align*}  $$</span> 所以<span class="math inline"><em>R</em>(<em>D</em>) ≥ <em>H</em><sub><em>b</em></sub>(<em>p</em>) − <em>H</em><sub><em>b</em></sub>(<em>D</em>)</span></li><li><strong>证明下界可达</strong>： 构造反向BSC信道如图：<img src="image-41.webp" srcset="/img/loading/loading3.gif" lazyload alt="BSC信道"> 令<span class="math inline"><em>X</em>, <em>Y</em> ∈ {0, 1}</span>，<span class="math inline">$p(Y) =\begin{cases}p, &amp;Y=0 \\ 1-p, &amp;Y=1\end{cases}$</span>，<span class="math inline">$d(x,y)=\begin{cases}1,&amp; x\neq y \\ 0, &amp; x = y\end{cases}$</span> 转移概率矩阵 <span class="math inline">$P=\begin{bmatrix}1-D &amp; D\\D &amp; 1-D\end{bmatrix}$</span> 则<span class="math inline"><em>R</em> = <em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em><sub><em>b</em></sub>(<em>p</em>) − <em>H</em><sub><em>b</em></sub>(<em>D</em>)</span>，达到下界只需证明存在<span class="math inline"><em>α</em></span>满足<span class="math inline">0 ≤ <em>α</em> ≤ 1</span>，使得<span class="math inline">$p(X) =\begin{cases}\alpha, &amp;X=0 \\ 1-\alpha,&amp;X=1 \end{cases}$</span> 易知<span class="math inline"><em>p</em> = <em>α</em>(1 − <em>D</em>) + <em>D</em>(1 − <em>α</em>)</span>，即<span class="math inline">$\alpha=\frac{p - D}{1 - 2D}$</span> 因为<span class="math inline">$0 \leq D \leq p \leq \frac{1}{2}$</span>，<span class="math inline"><em>p</em> + <em>D</em> ≤ 1</span> 由此可得<span class="math inline">$0\leq\alpha=\frac{p - D}{1 -2D}\leq1$</span>，即存在<span class="math inline"><em>α</em></span>满足条件</li></ul></li><li><strong>例题2</strong>：<img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li><li><strong>结论</strong>：<strong>二元信源失真函数<span class="math inline">$R(D)=\begin{cases}H_b(p)-H_b(D), &amp; 0\leq D\leqp \\ 0, &amp; D &gt; p\end{cases}$</span></strong></li></ol><h3 id="参量表示法">参量表示法</h3><ol type="1"><li><p><strong>条件与记号</strong> 设离散信源的输入序列为 <span class="math display">$$\begin{bmatrix} X \\ P \end{bmatrix} =\begin{bmatrix} x_1 &amp; x_2 &amp; \cdots &amp; x_n \\ p(x_1) &amp;p(x_2) &amp; \cdots &amp; p(x_n) \end{bmatrix}$$</span></p><p>输出序列为 <span class="math display">$$\begin{bmatrix} Y \\ P \end{bmatrix} =\begin{bmatrix} y_1 &amp; y_2 &amp; \cdots &amp; y_m \\ p(y_1) &amp;p(y_2) &amp; \cdots &amp; p(y_m) \end{bmatrix}$$</span></p><p>字符传输的失真函数为 <span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span>， <span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span> ；<span class="math inline"><em>j</em> = 1, 2, ⋯, <em>m</em></span> 。为了书写方便，引入记号： <span class="math display">$$d_{ij} = d(x_i,y_j), \quad p_{ij} = p(y_j\mid x_i)\\p_i = p(x_i), \quad q_j = p(y_j)$$</span></p><p>式中 <span class="math display">$$p(y_j)=\sum_{i =1}^{n}p(x_i)p(y_j\mid x_i)=\sum_{i = 1}^{n}p_ip_{ij}$$</span></p></li><li><p><strong>问题转换</strong> 信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span> 的计算为在约束条件<span class="math display">$$\begin{cases}\sum_{i = 1}^{n}\sum_{j = 1}^{m}p_ip_{ij}d_{ij} = D \\\sum_{j = 1}^{m}p_{ij} = 1 \quad i = 1,2,\cdots,n\end{cases} \quad ①$$</span></p><p>下，求下式极小值问题。 <span class="math display">$$I(X;Y)=\sum_{i = 1}^{n}\sum_{j = 1}^{m}p_ip_{ij}\ln\frac{p_{ij}}{q_j}\quad ②$$</span></p><p>应用拉格朗日乘法，引入乘子 <span class="math inline"><em>s</em></span> 和 <span class="math inline"><em>μ</em><sub><em>i</em></sub></span> ， <span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span>将上述条件极值问题化成无条件极值问题： <span class="math display">$$\frac{\partial}{\partial p_{ij}}\left[I(X;Y)-sD - \mu_i\sum_{j =1}^{m}p_{ij}\right]=0\quad i = 1,2,\cdots,n \quad ③$$</span></p></li><li><p><strong>求解</strong> 由上式 ③ 解出 <span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>，代入式 ② 中得到在约束条件式 ① 下的 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 极小值，即<span class="math inline"><em>R</em>(<em>D</em>)</span> 。</p><p><span class="math display">$$\begin{align*}\frac{\partial I(X;Y)}{\partial p_{ij}}&amp;=\frac{\partial}{\partialp_{ij}}\left[\sum_{i = 1}^{n}\sum_{j =1}^{m}p_ip_{ij}\ln\frac{p_{ij}}{q_j}\right]\\&amp;=\frac{\partial}{\partial p_{ij}}\left[\sum_{i = 1}^{n}\sum_{j =1}^{m}p_ip_{ij}\ln p_{ij}-\sum_{i = 1}^{n}\left(\sum_{j =1}^{m}p_ip_{ij}\right)\ln q_j\right]\\&amp;=\frac{\partial}{\partial p_{ij}}\left[\sum_{i = 1}^{n}\sum_{j =1}^{m}p_ip_{ij}\ln p_{ij}-\sum_{j = 1}^{m}q_j\ln q_j\right]\\&amp;=\left[p_ip_{ij}\frac{1}{p_{ij}} + p_i\lnp_{ij}\right]-\left[q_j\frac{1}{q_j}\frac{\partial q_j}{\partialp_{ij}}+\frac{\partial q_j}{\partial p_{ij}}\ln q_j\right]\\&amp;=\left[p_i + p_i\ln p_{ij}\right]-\left[p_i + p_i\ln q_j\right]\\&amp;=p_i\ln\frac{p_{ij}}{q_j}\\     \frac{\partial [sD]}{\partial p_{ij}}&amp;=\frac{\partial}{\partialp_{ij}}\left[s\sum_{i = 1}^{n}\sum_{j =1}^{m}p_ip_{ij}d_{ij}\right]=sp_id_{ij}\\\frac{\partial}{\partial p_{ij}}&amp;\left[\mu_i\sum_{j =1}^{m}p_{ij}\right]=\mu_i\end{align*}$$</span></p><p>所以式 ③ 化为： <span class="math display">$$p_i\ln\frac{p_{ij}}{q_j}-sp_id_{ij}-\mu_i = 0\quad     i =1,2,\cdots,n;j = 1,2,\cdots,m \quad ④$$</span></p><p>由式 ④ 解出 <span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span> ：<span class="math display">$$p_{ij} = q_j\exp\{sd_{ij}\}\exp\left\{\frac{\mu_i}{p_i}\right\} \quad i= 1,2,\cdots,n;j = 1,2,\cdots,m \quad ⑤$$</span></p><p>令 <span class="math inline">$\lambda_i=\exp\left\{\frac{\mu_i}{p_i}\right\}$</span>，代入式 ⑤ 中得到： <span class="math display"><em>p</em><sub><em>i</em><em>j</em></sub> = <em>λ</em><sub><em>i</em></sub><em>q</em><sub><em>j</em></sub>exp {<em>s</em><em>d</em><sub><em>i</em><em>j</em></sub>}  <em>i</em> = 1, 2, ⋯, <em>n</em>; <em>j</em> = 1, 2, ⋯, <em>m</em>  ⑥</span></p><p>由 <span class="math inline">$\sum_{j = 1}^{m}p_{ij} = 1$</span>，将式 ⑥ 对 <span class="math inline"><em>j</em></span> 求和可得到 <span class="math display">$$1=\sum_{j = 1}^{m}\lambda_iq_j\exp\{sd_{ij}\} \quad i = 1,2,\cdots,n\quad ⑦$$</span></p><p>由式 ⑦ 可解出 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 的值 <span class="math display">$$\lambda_i=\frac{1}{\sum_{j = 1}^{m}q_j\exp\{sd_{ij}\}} \quad ⑧$$</span></p><p>由 <span class="math inline">$q_j=\sum_{i = 1}^{n}p_ip_{ij}$</span>，将式 ⑥ 两边同乘 <span class="math inline"><em>p</em><sub><em>i</em></sub></span> ，并对 <span class="math inline"><em>i</em></span> 求和可得到 <span class="math display">$$q_j=\sum_{i = 1}^{n}p_ip_{ij}=\sum_{i =1}^{n}\lambda_ip_iq_j\exp\{sd_{ij}\} \quad j = 1,2,\cdots,m \quad$$</span></p><p>即 <span class="math display">$$\sum_{i = 1}^{n}\lambda_ip_i\exp\{sd_{ij}\}=1 \quad j = 1,2,\cdots,m\quad ⑨$$</span></p><p>将式 ⑧ 代入式 ⑨ 中，可得到关于 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 的 <span class="math inline"><em>m</em></span> 个方程 <span class="math display">$$\sum_{i = 1}^{n}\frac{p_i\exp\{sd_{ij}\}}{\sum_{l =1}^{m}q_l\exp\{sd_{il}\}} = 1 \quad j = 1,2,\cdots,m \quad ⑩$$</span></p><p>由式 ⑩ 中可以解出以 <span class="math inline"><em>s</em></span>为参量的 <span class="math inline"><em>m</em></span> 个 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 值，将这<span class="math inline"><em>m</em></span> 个 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 值代入式 ⑧中可以解出以 <span class="math inline"><em>s</em></span> 为参量的 <span class="math inline"><em>n</em></span> 个 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span>值，再将解得的 <span class="math inline"><em>m</em></span> 个 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 值和 <span class="math inline"><em>n</em></span> 个 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 值代入式 ⑥中，可以解出以 <span class="math inline"><em>s</em></span> 为参量的<span class="math inline"><em>m</em><em>n</em></span> 个 <span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>值。</p><p>将解出的 <span class="math inline"><em>m</em><em>n</em></span> 个<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>值代入定义式中求出以 <span class="math inline"><em>s</em></span>为参量的平均失真度 <span class="math inline"><em>D</em>(<em>s</em>)</span> <span class="math display">$$D(s)=\sum_{i = 1}^{n}\sum_{j =1}^{m}\lambda_ip_iq_jd_{ij}\exp\{sd_{ij}\} \quad ⑪$$</span></p><p>其中， <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 和 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 由式 ⑦ 和 ⑩求得。</p><p>将解出的 <span class="math inline"><em>m</em><em>n</em></span> 个<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>值代入式 ② 中得到在约束条件 ① 下的 <span class="math inline"><em>I</em>(<em>X</em>, <em>Y</em>)</span>的极小值，即以 <span class="math inline"><em>s</em></span>为参量的信息率失真函数 <span class="math inline"><em>R</em>(<em>s</em>)</span> <span class="math display">$$\begin{align*}R(s)&amp;=\sum_{i = 1}^{n}\sum_{j =1}^{m}\lambda_ip_iq_j\exp\{sd_{ij}\}\ln\frac{\lambda_iq_j\exp\{sd_{ij}\}}{q_j}\\&amp;=\sum_{i = 1}^{n}\sum_{j =1}^{m}\lambda_ip_iq_j\exp\{sd_{ij}\}(\ln\lambda_i + sd_{ij})\\&amp;=\sum_{i = 1}^{n}p_i\ln\lambda_i\left[\sum_{j =1}^{m}\lambda_iq_j\exp\{sd_{ij}\}\right]+s\sum_{i = 1}^{n}\sum_{j =1}^{m}\lambda_ip_iq_jd_{ij}\exp\{sd_{ij}\}\\&amp;=\sum_{i = 1}^{n}p_i\ln\lambda_i\left(\sum_{j =1}^{m}p_{ij}\right)+sD(s)\\&amp;=\sum_{i = 1}^{n}p_i\ln\lambda_i + sD(s) \quad ⑫\end{align*}$$</span></p><p>一般情况下，参量 <span class="math inline"><em>s</em></span>无法消去，因此得不到 <span class="math inline"><em>R</em>(<em>D</em>)</span>的闭式解，只有在某些特定的简单问题中才能消去参量 <span class="math inline"><em>s</em></span> ，得到 <span class="math inline"><em>R</em>(<em>D</em>)</span>的闭式解。若无法消去参量 <span class="math inline"><em>s</em></span>，就需要进行逐点计算。下面分析一下参量 <span class="math inline"><em>s</em></span> 的意义。</p><p>将 <span class="math inline"><em>R</em>(<em>D</em>)</span> 看成 <span class="math inline"><em>D</em>(<em>s</em>)</span> 和 <span class="math inline"><em>s</em></span> 的隐函数，而 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 又是 <span class="math inline"><em>s</em></span> 的函数，利用全微分公式对 <span class="math inline"><em>R</em>(<em>D</em>)</span> 求导，可得 <span class="math display">$$\begin{align*}\frac{\mathrm{d}R(D)}{\mathrm{d}D}&amp;=\frac{\partial R(s)}{\partialD(s)}+\frac{\partial R(s)}{\partials}\left(\frac{\mathrm{d}s}{\mathrm{d}D}\right)+\sum_{i =1}^{n}\frac{\partial R(s)}{\partial\lambda_i}\left(\frac{\mathrm{d}\lambda_i}{\mathrm{d}D}\right)\\&amp;=s + D(s)\frac{\mathrm{d}s}{\mathrm{d}D}+\sum_{i =1}^{n}\frac{p_i}{\lambda_i}\cdot\frac{\mathrm{d}\lambda_i}{\mathrm{d}D}\\&amp;=s+\left[D(s)+\sum_{i =1}^{n}\frac{p_i}{\lambda_i}\cdot\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}\right]\frac{\mathrm{d}s}{\mathrm{d}D}\quad ⑬\end{align*}$$</span></p><p>为求出 <span class="math inline">$\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}$</span>，将式 ⑦ 对 <span class="math inline"><em>s</em></span> 求导，得到 <span class="math display">$$\sum_{i =1}^{n}\left[p_i\exp\{sd_{ij}\}\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+\lambda_ip_id_{ij}\exp\{sd_{ij}\}\right]=0$$</span></p><p>将上式两边同乘以 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> ，并对 <span class="math inline"><em>j</em></span> 求和，可得 <span class="math display">$$\sum_{j = 1}^{m}q_j\sum_{i =1}^{n}\left[p_i\exp\{sd_{ij}\}\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+\lambda_ip_id_{ij}\exp\{sd_{ij}\}\right]=0$$</span></p><p>即 <span class="math display">$$\sum_{i = 1}^{n}p_i\left[\sum_{j =1}^{m}q_j\exp\{sd_{ij}\}\right]\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+\sum_{i= 1}^{n}\sum_{j = 1}^{m}\lambda_ip_iq_jd_{ij}\exp\{sd_{ij}\}=0$$</span></p><p>将式 ⑧ 和 ⑫ 代入上式，可得 <span class="math display">$$\sum_{i =1}^{n}p_i\frac{1}{\lambda_i}\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+D(s)=0\quad ⑭$$</span></p><p>将式 ⑭ 代入式 ⑬ 中，可得 <span class="math display">$$\frac{\mathrm{d}R(D)}{\mathrm{d}D}=s \quad ⑮$$</span></p><p>式 ⑮ 表明，参量 <span class="math inline"><em>s</em></span>是信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span>的斜率。由 <span class="math inline"><em>R</em>(<em>D</em>)</span> 在<span class="math inline">0 &lt; <em>D</em> &lt; <em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>之间是严格单调减函数可知， <span class="math inline"><em>s</em></span>是负值，且是 <span class="math inline"><em>D</em></span> 的递增函数，即<span class="math inline"><em>s</em></span> 将随 <span class="math inline"><em>D</em></span> 的增加而增加。 由 <span class="math inline"><em>R</em>(<em>D</em>)</span> 的性质可知，在 <span class="math inline"><em>D</em> = 0</span> 处， <span class="math inline"><em>R</em>(<em>D</em>)</span> 的斜率有可能为 <span class="math inline">−∞</span> ；当 <span class="math inline"><em>D</em> &gt; <em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>时， <span class="math inline"><em>R</em>(<em>D</em>) = 0</span>，其斜率为零。所以参量 <span class="math inline"><em>s</em></span>的取值为 <span class="math inline">(−∞, 0)</span> 。进一步还可以证明：信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span> 是参量 <span class="math inline"><em>s</em></span> 的连续函数； <span class="math inline"><em>R</em>(<em>D</em>)</span> 的斜率，即参量 <span class="math inline"><em>s</em></span> 是失真度 <span class="math inline"><em>D</em></span> 的连续函数，在 <span class="math inline"><em>D</em> = <em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>处， <span class="math inline"><em>R</em>(<em>D</em>)</span>的斜率可能是不连续的。</p></li></ol><h1 id="第五章-信源编码">第五章 信源编码</h1><h2 id="信源编码与信道编码">信源编码与信道编码</h2><ul><li><strong>信源编码</strong><ul><li><strong>无失真信源编码——第一极限定理</strong>：离散信源</li><li><strong>限失真信源编码——第三极限定理</strong>：连续信源</li><li>在不失真或允许一定失真条件下，如何用尽可能少的符号来传送信源信息，以便提高信息传输率。</li></ul></li><li><strong>信道编码</strong><ul><li><strong>第二极限定理</strong>：离散和连续信道</li><li>在信道受干扰的情况下如何增加信号的抗干扰能力，同时又使得信息传输率最大。</li></ul></li><li><strong>信源编码的作用</strong><ol type="1"><li><strong>符号变换</strong>：使信源的输出符号与信道的输入符号相匹配；</li><li><strong>信息匹配</strong>：使信息传输率达到信道容量；</li><li><strong>冗余度压缩</strong>：使编码效率等于或接近100%。</li></ol><ul><li>例题：<img src="image-42.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul></li><li><strong>信源编码的基础</strong><ol type="1"><li><strong>无失真编码定理</strong>：可精确复制信源输出的消息，只适用于离散信源</li><li><strong>限失真编码定理</strong>：对于连续信源，只能在失真受限制的情况下进行限失真编码</li></ol></li></ul><h2 id="编码的概念">5.1 编码的概念</h2><h3 id="分组码">分组码</h3><ul><li><strong>分组码(Block Codes)</strong>：也叫块码<ul><li>将信源消息分成若干组，即符号序列 <span class="math inline"><em>x</em><sub><em>i</em></sub></span> ， <span class="math display">$$\begin{align*}x_{i}&amp;=(x_{i1}x_{i2} \cdotsx_{il} \cdots x_{iL})\\x_{il}&amp;\in A=\{a_{1}, a_{2}, \cdots, a_{i},\cdots, a_{n}\}\end{align*}$$</span></li><li>每个符号序列 <span class="math inline"><em>x</em><sub><em>i</em></sub></span>依照<strong>固定码表</strong>映射成一个码字 <span class="math inline"><em>y</em><sub><em>i</em></sub></span> ， <span class="math display">$$\begin{align*}y_{i}&amp;=(y_{i1}y_{i2} \cdotsy_{ik} \cdots y_{iK})\\y_{ik}&amp;\in B=\{b_{1}, b_{2}, \cdots, b_{i},\cdots, b_{m}\}\end{align*}$$</span></li><li>只有分组码才有对应的码表，而非分组码中则不存在码表。</li><li><strong>模型</strong>：<img src="image-43.webp" srcset="/img/loading/loading3.gif" lazyload alt="模型"></li></ul></li><li><strong>定长码与变长码</strong>：码可分为两类：<ul><li><strong>定长码</strong>：码中所有码字的长度都相同，如码1就是定长码(FixedLength Codes)。</li><li><strong>变长码</strong>：码中的码字长短不一，如码2就是变长码(VariableLength Codes)。</li><li><table><thead><tr><th>符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span></th><th>信源符号出现概率 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span></th><th>码1</th><th>码2</th></tr></thead><tbody><tr><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline"><em>p</em>(<em>a</em><sub>1</sub>)</span></td><td>00</td><td>0</td></tr><tr><td><span class="math inline"><em>a</em><sub>2</sub></span></td><td><span class="math inline"><em>p</em>(<em>a</em><sub>2</sub>)</span></td><td>01</td><td>01</td></tr><tr><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline"><em>p</em>(<em>a</em><sub>3</sub>)</span></td><td>10</td><td>001</td></tr><tr><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline"><em>p</em>(<em>a</em><sub>4</sub>)</span></td><td>11</td><td>111</td></tr></tbody></table></li></ul></li><li><strong>码的属性</strong>：<ul><li><strong>奇异码与非奇异码</strong>：<ul><li>若信源符号和码字是一一对应的，则该码为<strong>非奇异码</strong>(Non-SingularCodes)；</li><li>反之为<strong>奇异码</strong>(Singular Codes)</li></ul></li><li><strong>唯一可译码(Uniquely Decodable Codes_)</strong>：<ul><li>任意有限长的码元序列，只能被唯一地分割成一个个的码字，便称为唯一可译码。</li><li>奇异码不是唯一可译码</li><li>唯一可译码分为非即时码和即时码<ul><li><strong>非即时码</strong>指接收端收到一个完整的码字后不能立即译码，还需等下一个码字开始接收后才能判断是否可以译码</li><li><strong>即时码</strong>只要收到符号就表示该码字已完整，可以立即译码，又称为<strong>非延长码</strong>(UndelayedCodes)，任意一个码字都不是其它码字的前缀部分，又称为<strong>异前缀码</strong>(PrefixCodes)。</li></ul></li></ul></li></ul></li></ul><h3 id="码的分类">码的分类</h3><figure><img src="image-121.webp" srcset="/img/loading/loading3.gif" lazyload alt="码的分类"><figcaption aria-hidden="true">码的分类</figcaption></figure><h3 id="即时码及其树图构造法">即时码及其树图构造法</h3><ul><li><p>即时码(非延长码或异前缀码)是唯一可译码的一类子码，可用树图来构造</p></li><li><p><strong>构造的要点</strong>：</p><ul><li>最上端为树根A，从根出发向下伸出树枝，树枝总数等于m(<strong>进制数</strong>)，树枝的尽头为节点。</li><li>从每个节点再伸出m个树枝，当某个节点被安排为码字后，就不再伸枝，这节点为<strong>终端节点</strong>。能再伸枝的节点成为<strong>中间节点</strong>。一直继续下去，直至都不能伸枝为止。</li><li>每个节点所伸出的树枝标上码符号，从根出发到终端点所走路径对应的码符号序列则为终端节点的码字。</li></ul></li><li><p><strong>用码树图构造码</strong></p><ul><li>在树的生长过程中，节点生出树枝，各树枝旁标出相应的码符，为了清晰起见相同码符的树枝方向相同，终端节点表示信源符号，从树根到终端节点所经过的树枝旁的码符按经过的顺序组成的序列构成码字。</li></ul></li><li><p><strong>用码树图判断即时码</strong></p><ul><li>如果表示信源符号的终端节点不再延伸，或到达任一信源符号终端节点的路径不经过其它的终端节点，这样构造的码满足即时码条件。</li></ul></li><li><p><strong>码树与码字对应关系</strong></p><table><thead><tr><th>树结构概念</th><th>编码概念</th></tr></thead><tbody><tr><td>树根</td><td>码字的起点</td></tr><tr><td>树枝数</td><td>码的进制数</td></tr><tr><td>节点</td><td>码字或码字的一部分</td></tr><tr><td>终端节点</td><td>码字</td></tr><tr><td>节数</td><td>码长</td></tr><tr><td>非满树</td><td>变长码（码字为叶节点）</td></tr><tr><td>满树</td><td>等长码（码字为叶节点）</td></tr></tbody></table></li></ul><h3 id="克劳夫特不等式">克劳夫特不等式</h3><ul><li><p><strong>唯一可译码存在</strong>的充分必要条件是各码字的长度 <span class="math inline"><em>K</em><sub><em>i</em></sub></span>应符合<strong>克劳夫特不等式</strong>(Kraft Inequality) <span class="math display">$$\sum_{i=1}^{n} m^{-K_{i}} \leq 1$$</span></p><p>式中，m是编码进制数，n是信源符号数。</p><ul><li>必要性表现在如果码是唯一可译码，则必定满足该不等式</li><li>充分性表现在如果满足该不等式，则这种码长的唯一可译码一定存在，但并不表示所有满足不等式的一定是唯一可译码。</li><li>所以说，该不等式是唯一可译码存在的充要条件，而不是判别一个编码是否唯一可译码的充要条件</li></ul></li><li><p><strong>唯一可译码的判断方法</strong></p><ol type="1"><li><strong>基本判断</strong>：<ol type="1"><li>观察是否是非奇异码，若是奇异码则一定不是唯一可译码。</li><li>计算是否满足Kraft不等式，若不满足一定不是唯一可译码。</li><li>将码画成一棵树图，观察是否满足即时码的树图的构造，若满足则是唯一可译码。</li></ol></li><li><strong>尾随后缀法</strong>： <img src="image-46.webp" srcset="/img/loading/loading3.gif" lazyload><ol type="1"><li>考查 <span class="math inline"><em>C</em></span> 中所有的码字，若<span class="math inline"><em>W</em><sub><em>i</em></sub></span> 是<span class="math inline"><em>W</em><sub><em>j</em></sub></span>的前缀，则将相应的后缀作为一个尾随后缀码放入集合 <span class="math inline"><em>F</em><sub>0</sub></span> 中</li><li>考查 <span class="math inline"><em>C</em></span> 和 <span class="math inline"><em>F</em><sub><em>i</em></sub></span> 两个集合,<span class="math inline"><em>W</em><sub><em>i</em></sub> ∈ <em>C</em></span>是 <span class="math inline"><em>W</em><sub><em>j</em></sub> ∈ <em>F</em><sub><em>i</em></sub></span>的前缀或 <span class="math inline"><em>W</em><sub><em>i</em></sub> ∈ <em>F</em><sub><em>i</em></sub></span>是 <span class="math inline"><em>W</em><sub><em>j</em></sub> ∈ <em>C</em></span>的前缀，则将相应的后缀作为尾随后缀码放入集合 <span class="math inline"><em>F</em><sub><em>i</em> + 1</sub></span> 中;</li><li><span class="math inline"><em>F</em> = ∪<sub><em>i</em></sub><em>F</em><sub><em>i</em></sub></span>即为码 <span class="math inline"><em>C</em></span> 的尾随后缀集合;</li><li>构造尾随后缀集合F，若F中出现了<span class="math inline"><em>C</em></span>中的元素，则算法终止，返回假(<span class="math inline"><em>C</em></span>不是唯一可译码)；否则若F中没有出现新的元素，则返回真。</li></ol><ul><li><strong>例题</strong>：判断码<span class="math inline"><em>C</em></span>：<span class="math inline">{0, 1001, 1011, 1101, 1111, 011}</span>是否是唯一可译码。<ul><li>构造尾随后缀集合<span class="math inline"><em>F</em></span>：码字“0” 是 “011” 的前缀，其尾随后缀 “11” 是码字 “1011” 和 “1111”的前缀，得尾随后缀为 “01” 和 “11” ，其中 “0” 是 “01” 的前缀，尾随后缀为“1” ，“1” 又是 “1011” 的前缀，得到尾随后缀 “011” ，而 <strong>“011”是<span class="math inline"><em>C</em></span>中码字</strong>，所以码<span class="math inline"><em>C</em></span>不是唯一可译码。</li><li>尾随后缀集合<span class="math inline"><em>F</em> = {11, 01, 1, 001, 011, 111}</span> ，“011” 是一个码字，因此不唯一可译。 <span class="math inline">0 → 11 → 01 → 1 → 001</span>，<span class="math inline">$\colorbox{yellow}{011}$</span>，<span class="math inline">111</span></li></ul></li></ul></li></ol></li></ul><h2 id="无失真信源编码定理">5.2 无失真信源编码定理</h2><h3 id="无失真信源编码">无失真信源编码</h3><ul><li><strong>模型</strong>：<img src="image-44.webp" srcset="/img/loading/loading3.gif" lazyload alt="模型"><ul><li><p>信源编码器输入的消息序列： <span class="math display">$$\begin{align*}X=(X_{1}X_{2} \cdots X_{l} \cdotsX_{L})\quad X_{l}\in\{a_{1}, \cdots a_{n}\}\end{align*}$$</span></p><p>输入的消息总共有 <span class="math inline"><em>n</em><sup><em>L</em></sup></span> 种可能的组合输出的码字为： <span class="math display">$$\begin{align*}Y=(Y_{1}Y_{2}\cdots Y_{k} \cdots Y_{K_{L}})\quad Y_{k}\in\{b_{1}, \cdotsb_{m}\}\end{align*}$$</span></p><p>输出的码字总共有 <span class="math inline"><em>m</em><sup><em>K</em><sub><em>L</em></sub></sup></span>种可能的组合。</p></li><li><p><span class="math inline"><em>Y</em><sub><em>k</em></sub></span>有<span class="math inline"><em>m</em></span>种可能取值，所以平均每个符号输出的最大信息量为<span class="math inline">log <em>m</em></span>（等概分布）。</p></li><li><p><span class="math inline"><em>K</em><sub><em>L</em></sub></span>长码字的最大信息量为<span class="math inline"><em>K</em><sub><em>L</em></sub>log <em>m</em></span>，用该码字表示<span class="math inline"><em>L</em></span>长的信源序列。</p></li><li><p>则传送一个信源符号需要的平均信息率为： <span class="math display">$$\overline{K}=\frac{K_{L}}{L}\log m =\frac{1}{L}\log M \text{ bit/信源符号}$$</span></p><p>其中，<span class="math inline"><em>M</em> = <em>m</em><sup><em>K</em><sub><em>L</em></sub></sup></span>是<span class="math inline"><em>Y</em></span>所能编成的码字的个数。</p></li></ul></li><li><strong>无失真信源编码</strong><ul><li><strong>实现无失真的信源编码要求</strong>：<ul><li>信源符号 <span class="math inline"><em>X</em><sub>1</sub><em>X</em><sub>2</sub>⋯<em>X</em><sub><em>l</em></sub>⋯<em>X</em><sub><em>L</em></sub></span>与码字 <span class="math inline"><em>Y</em><sub>1</sub><em>Y</em><sub>2</sub>⋯<em>Y</em><sub><em>k</em></sub>⋯<em>Y</em><sub><em>K</em><sub><em>L</em></sub></sub></span>是一一对应的；</li><li>能够无失真或无差错地从Y恢复X，也就是能正确地进行反变换或译码 ；</li><li>传送Y时所需要的信息率最小，信息率最小就是找到一种编码方式使<span class="math inline">$\overline{K}  = \frac{K_L}{L} \log m =\frac{1}{L}\log M$</span>最小</li></ul></li><li><strong>无失真信源编码定理研究内容</strong>：<ul><li>最小信息率为多少时，才能得到无失真的译码？</li><li>若小于这个信息率是否还能无失真地译码？</li></ul></li></ul></li></ul><h3 id="定长编码">定长编码</h3><h4 id="定长编码的基本概念">定长编码的基本概念</h4><ul><li>码长<span class="math inline"><em>K</em></span>是定值，且是唯一可译码。</li><li>由<span class="math inline"><em>L</em></span>个符号组成的、每个符号的熵为<span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X</em>)</span>的无记忆平稳信源符号序列<span class="math inline"><em>X</em><sub>1</sub><em>X</em><sub>2</sub>...<em>X</em><sub><em>l</em></sub>...<em>X</em><sub><em>L</em></sub></span>（每个符号<span class="math inline"><em>n</em></span>种可能值）</li><li>输入的消息总共有<span class="math inline"><em>n</em><sup><em>L</em></sup></span>种可能的组合。</li><li>可用<span class="math inline"><em>K</em><sub><em>L</em></sub> = <em>K</em></span>个符号<span class="math inline"><em>Y</em><sub>1</sub></span>，<span class="math inline"><em>Y</em><sub>2</sub></span>，…，<span class="math inline"><em>Y</em><sub><em>k</em></sub></span>，…，<span class="math inline"><em>Y</em><sub><em>K</em><sub><em>L</em></sub></sub></span>（每个符号有<span class="math inline"><em>m</em></span>种可能值）进行定长编码</li><li>输出的码字总共有<span class="math inline"><em>m</em><sup><em>K</em></sup></span>种可能的组合</li><li><strong>若要对信源进行定长编码且无失真</strong>，必须满足： <span class="math display">$$n^{L} \leq m^{K} 或 \frac{K}{L} \geq \frac{\logn}{\log m}$$</span><ul><li>只有当<span class="math inline"><em>K</em></span>长的码符号序列数<span class="math inline"><em>m</em><sup><em>K</em></sup></span>大于或等于信源的符号数<span class="math inline"><em>n</em><sup><em>L</em></sup></span>时，才可能存在定长非奇异码。</li></ul></li></ul><h4 id="渐进均分性定理aep">渐进均分性定理（AEP）</h4><ul><li><strong>定理</strong>：<span class="math inline">$\vec{X_{}}=(X_1X_2 \cdotsX_L)$</span>，为独立同分布（i.i.d）随机变量序列，具有渐近均分性质（AEP，Asymptoticequipartition property）： <span class="math display">$$\forall\varepsilon &gt; 0，当 L \to \infty时，p(X_1,X_2,\cdots,X_L) \to 2^{-LH(X)}$$</span></li><li><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#渐进均分性定理aep">无失真信源编码定理</a></strong></li></ul><h4 id="定长编码定理">定长编码定理</h4><ul><li><p><strong>定理</strong>：对于由 <span class="math inline"><em>L</em></span> 个符号组成的，每个符号的熵为 <span class="math inline">$H_L(\vec{X_{}})$</span> 的无记忆平稳符号序列 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub></span>，可用<span class="math inline"><em>K</em><sub><em>L</em></sub></span> 个符号<span class="math inline"><em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>K</em><sub><em>L</em></sub></sub></span>（每个符号有<span class="math inline"><em>m</em></span> 种可能值，即<span class="math inline"><em>m</em></span>进制编码）进行定长编码。对于任意<span class="math inline"><em>ε</em> &gt; 0</span>，<span class="math inline"><em>δ</em> &gt; 0</span>，只要 <span class="math display">$$\overline{K} = \frac{K_L}{L}\log m \geqH_L(\vec{X_{}}) + \varepsilon$$</span></p><p>则当 <span class="math inline"><em>L</em></span>足够大时，必可使译码差错小于 <span class="math inline"><em>δ</em></span>； 反之，当 <span class="math display">$$\overline{K} = \frac{K_L}{L}\log m \leqH_L(\vec{X_{}}) - 2\varepsilon$$</span></p><p>时，译码差错一定是有限值，当 <span class="math inline"><em>L</em> → ∞</span>时，译码几乎必定出错。</p></li><li><p><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#定长编码定理">无失真信源编码定理</a></strong></p></li><li><p><strong>定长编码定理含义</strong></p><ul><li><p>当编码器容许的输出信息率，也就是当每个信源符号所必须输出的二进制码长是<span class="math display">$$  \overline{K}=\frac{K_{L}}{L}\log m=\frac{1}{L}\log M  $$</span></p><p>时，只要 <span class="math inline">$\overline{K}&gt;H_{L}(X)$</span>，这种编码器一定可以做到<strong>几乎无失真</strong>，也就是收端的译码差错概率接近于零，<strong>条件是所取的符号数<span class="math inline"><em>L</em></span>足够大</strong>。</p></li><li><p>将定理的条件改写成： <span class="math display"><em>K</em><sub><em>L</em></sub>log <em>m</em> &gt; <em>L</em><em>H</em><sub><em>L</em></sub>(<em>X</em>) = <em>H</em>(<em>X</em>)</span>其中：</p><ul><li>左边：<span class="math inline"><em>K</em><sub><em>L</em></sub></span>长码字所能携带的最大信息。</li><li>右边：<span class="math inline"><em>L</em></span>长信源序列携带的信息量。</li></ul><p>则：</p><ul><li>码字所能携带的信息量<strong>大于</strong>信源序列输出的信息量，则可以使传输<strong>几乎无失真</strong>，当然<strong>条件是<span class="math inline"><em>L</em></span>足够大</strong>。</li><li>反之，当 <span class="math inline">$\overline{K} &lt;H_{L}(X)$</span>时，不可能构成无失真的编码，也就是不可能做一种编码器，能使收端译码时差错概率趋于零。</li><li><span class="math inline">$\overline{K}=H_{L}(X)$</span>时，则为临界状态，可能无失真，也可能有失真。</li></ul></li></ul></li><li><p><strong>信源长度 <span class="math inline"><em>L</em></span></strong></p><ul><li><p>对定长编码，若要实现几乎无失真编码，则信源长度必须满足： <span class="math display">$$L \geq \frac{\sigma^{2}(X)}{\varepsilon^{2}\delta}$$</span></p><p>其中：</p><ul><li><span class="math inline"><em>σ</em><sup>2</sup>(<em>X</em>) = <em>E</em>{[<em>I</em>(<em>x</em><sub><em>i</em></sub>) − <em>H</em>(<em>X</em>)]<sup>2</sup>}</span>，表示信源序列的自信息方差。</li><li><span class="math inline"><em>δ</em></span>：差错率要求（如<span class="math inline">10<sup>−6</sup></span>）</li><li><span class="math inline">$\varepsilon =\overline{K}-H_{L}(X)$</span></li></ul></li><li><p>证明：见<a href="Ch5sup_无失真信源编码定理.md/#定长编码定理">无失真信源编码定理</a></p></li></ul></li><li><p><strong>编码效率<span class="math inline"><em>η</em></span></strong></p><ul><li><p>编码效率定义为 <span class="math display">$$\eta =\frac{H_{L}(X)}{\overline{K}}$$</span> 即信源的平均符号熵为<span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X</em>)</span>，采用平均二进制符号码长为<span class="math inline">$\overline{K}$</span>来编码，所得的效率。</p></li><li><p>无失真编码效率总是小于<span class="math inline">1</span>，且<strong>最佳编码效率</strong>为 <span class="math display">$$\eta =\frac{H_{L}(X)}{H_{L}(X)+\varepsilon},\varepsilon &gt;0$$</span></p></li><li><p>定长编码定理从理论上阐明了编码效率接近<span class="math inline">1</span>的理想定长编码器的存在性，它使输出符号的信息率与信源熵之比接近于<span class="math inline">1</span>，即只要<span class="math inline"><em>L</em></span>足够大 <span class="math display">$$\frac{H_{L}(X)}{\frac{K_{L}}{L}\log m} \to1$$</span></p><ul><li>但要在实际中实现，<span class="math inline"><em>L</em></span>必须取无限长的信源符号进行统一编码。这样做实际上是不可能的，因<span class="math inline"><em>L</em></span>非常大，无法实现。</li><li>当<span class="math inline"><em>L</em></span>有限时，要做到高编码效率、低错误率，对于定长编码来说是不可能做到的。</li></ul></li></ul></li><li><p><strong>例题</strong>：<img src="image-92.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h3 id="变长编码">变长编码</h3><h4 id="变长编码的基本概念">变长编码的基本概念</h4><ul><li>在变长编码中，码长<span class="math inline"><em>K</em><sub><em>i</em></sub></span>是变化的。</li><li><span class="math inline"><em>m</em></span>进制平均码长：<span class="math inline">$\overline{K^{'}} = \sum_{i}p(a_{i})K_{i}$</span></li><li>根据信源各个符号的统计特性，如概率大的符号用短码，概率小的用较长的码，使得编码后平均码长降低，从而提高编码效率。（统计匹配）</li></ul><h4 id="单个符号变长编码定理">单个符号变长编码定理</h4><ul><li><strong>定理</strong>：若离散无记忆信源的符号熵为 <span class="math inline"><em>H</em>(<em>X</em>)</span>，每个信源符号用m进制码元进行变长编码，一定存在一种无失真编码方法，其(m进制)码字平均长度<span class="math inline">$\overline{K'}$</span> 满足下列不等式 <span class="math display">$$\frac{H(X)}{\log m} \leq\overline{K'}&lt;\frac{H(X)}{\log m}+1$$</span></li><li><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#单符号变长编码定理">无失真信源编码定理</a></strong></li></ul><h4 id="离散平稳无记忆序列变长编码定理香农第一定理">离散平稳无记忆序列变长编码定理(香农第一定理)</h4><ul><li><p>由单个符号变长编码定理推广而来： <span class="math display">$$  \begin{align*}  \frac{H(X)}{\log m} \leq &amp;\overline{K^{'}} &lt; \frac{H(X)}{\logm} + 1 \\  \Rightarrow \frac{LH_{L}(X)}{\log m} \leq &amp;\overline{K_{L}} &lt;\frac{LH_{L}(X)}{\log m} + 1\\  \Rightarrow H_{L}(X) \leq &amp;\overline{K} &lt; H_{L}(X)+\frac{\logm}{L}  \end{align*}  $$</span></p></li><li><p><strong>定理</strong>：对于离散平稳无记忆信源，必存在一种无失真编码方法，使平均信息率<span class="math inline">$\overline{K}$</span> 满足不等式 <span class="math display">$$H_{L}(X) \leq \overline{K} &lt;H_{L}(X)+\frac{\log m}{L}$$</span></p><p>其中<span class="math inline">$\overline{K} =\frac{\overline{K_{L}}}{L}\log m$</span>，当L足够大时，可使 <span class="math inline">$\frac{\log m}{L}&lt;\varepsilon$</span> ，得到<span class="math display">$$H_{L}(X) \leq \overline{K} &lt;H_{L}(X)+\varepsilon$$</span></p><p>其中<span class="math inline"><em>ε</em></span>是任意小的正数。</p></li><li><p><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#离散平稳无记忆序列变长编码定理香农第一定理">无失真信源编码定理</a></strong></p></li><li><p><strong>变长编码效率</strong>变长编码效率的<strong>下界</strong>： <span class="math display">$$  \eta=\frac{H_{L}(X)}{\overline{K}} &gt; \frac{H_{L}(X)}{H_{L}(X) +\frac{\log m}{L}}  $$</span></p><p>无失真编码效率总是小于1，可以用它来衡量各种编码方法的优劣。为了衡量各种编码方法与最佳码的差距，定义<strong>码的剩余度</strong>为：<span class="math display">$$  \gamma = 1 - \eta = 1 - \frac{H_{L}(X)}{\frac{\overline{K_{L}}}{L}\logm}= 1 - \frac{H_{L}(X)}{\overline{K}}  $$</span></p><p>对某一信源和某一码符号集，若有一个唯一可译码，其平均长度小于所有其他唯一可译码的平均长度，则称该码为<strong>最佳码</strong>或<strong>紧致码</strong>。</p></li><li><p><strong>例题</strong>：</p><ul><li>例题1：<img src="image-93.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li><li>例题2：<img src="image-94.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul></li></ul><h3 id="香农编码">香农编码</h3><ul><li><p>香农第一定理指出了平均码长与信源熵之间的关系，同时也指出了可以通过编码使平均码长达到极限值，这是一个很重要的极限定理。</p></li><li><p>香农第一定理指出，选择每个码字的长度<span class="math inline"><em>l</em><sub><em>i</em></sub></span>满足下式：<span class="math display">$$l_{i} =\left\lceil\log\frac{1}{p(x_{i})}\right\rceil（向上取整）$$</span>或：<span class="math display"><em>I</em>(<em>x</em><sub><em>i</em></sub>) ≤ <em>l</em><sub><em>i</em></sub> &lt; <em>I</em>(<em>x</em><sub><em>i</em></sub>) + 1</span></p><p>这种编码方法称为香农编码</p></li><li><p><strong>编码步骤</strong></p><ol type="1"><li>将信源消息符号按其出现的概率大小依次排列：<span class="math display"><em>p</em><sub>1</sub> ≥ <em>p</em><sub>2</sub> ≥ ⋯ ≥ <em>p</em><sub><em>n</em></sub></span></li><li>依照下列不等式确定整数的码长<span class="math inline"><em>K</em><sub><em>i</em></sub></span>：<span class="math display">−log<sub>2</sub>(<em>p</em><sub><em>i</em></sub>) ≤ <em>l</em><sub><em>i</em></sub> &lt; −log<sub>2</sub>(<em>p</em><sub><em>i</em></sub>) + 1</span></li><li>为了编成唯一可译码，计算第<span class="math inline"><em>i</em></span>个消息的累加概率：<span class="math display">$$P_{i}=\sum_{k = 1}^{i - 1}p(a_{k})$$</span></li><li>将累加概率<span class="math inline"><em>P</em><sub><em>i</em></sub></span>变换成二进制数</li><li>取<span class="math inline"><em>P</em><sub><em>i</em></sub></span>二进制数的小数点后<span class="math inline"><em>l</em><sub><em>i</em></sub></span>位即为该消息符号的二进制码字</li></ol></li><li><p><strong>香农编码图示</strong></p><ul><li>累加概率<span class="math inline"><em>P</em><sub><em>i</em></sub></span>把区间<span class="math inline">[0, 1)</span>分割成许多小区间，每个小区间的长度等于各符号的概率<span class="math inline"><em>p</em><sub><em>i</em></sub></span>，小区间内的任一点可用来代表该符号：<span class="math inline">$P_{i}=\sum_{k = 1}^{i -1}p(a_{k})$</span></li><li><figure><img src="image-45.webp" srcset="/img/loading/loading3.gif" lazyload alt="香农编码图示"><figcaption aria-hidden="true">香农编码图示</figcaption></figure></li></ul></li><li><p><strong>例题</strong>：<img src="image-58.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="限失真信源编码定理">5.3 限失真信源编码定理</h2><h3 id="无失真与有失真信源编码">无失真与有失真信源编码</h3><ul><li>无失真信源编码是<strong>保熵的</strong>：通过信道的信息传输率<span class="math inline"><em>R</em></span>等于信源熵<span class="math inline"><em>H</em>(<em>X</em>)</span>。</li><li>有失真信源编码属<strong>熵压缩编码</strong>，即编码后的信息率得到压缩。</li><li>采用有失真的熵压缩编码的原因：<ul><li>保熵编码并非总是必需的；</li><li>保熵编码并非总是可能的；</li><li>降低信息率有利于传输和处理。</li></ul></li></ul><h3 id="限失真信源编码定理-1">限失真信源编码定理</h3><ul><li><p>信息率失真函数给出了失真小于<span class="math inline"><em>D</em></span>时所必须具有的最小信息率<span class="math inline"><em>R</em>(<em>D</em>)</span>；只要信息率大于<span class="math inline"><em>R</em>(<em>D</em>)</span>，一定可以找到一种编码，使译码后的失真小于<span class="math inline"><em>D</em></span>。</p></li><li><p><strong>限失真信源编码定理</strong>：设<strong>离散无记忆信源</strong><span class="math inline"><em>X</em></span>的信息率失真函数为<span class="math inline"><em>R</em>(<em>D</em>)</span>，则当信息率<span class="math inline"><em>R</em> &gt; <em>R</em>(<em>D</em>)</span>，只要信源序列长度<span class="math inline"><em>L</em></span>足够长，一定存在一种编码方法，其译码失真小于或等于<span class="math inline"><em>D</em> + <em>ε</em></span>，<span class="math inline"><em>ε</em></span>为任意小的正数。反之，若<span class="math inline"><em>R</em> &lt; <em>R</em>(<em>D</em>)</span>，则无论采用什么样的编码方法，其译码失真必大于<span class="math inline"><em>D</em></span>。</p></li><li><p>二元信源编码：</p><ul><li><p>对于任意小的<span class="math inline"><em>ε</em></span>，每一个信源符号的平均码长满足如下公式：<span class="math display">$$R(D) \leq \overline{K} &lt; R(D) +\varepsilon$$</span></p><p>在失真限度内使信息率任意接近<span class="math inline"><em>R</em>(<em>D</em>)</span>的编码方法是存在的。然而，如果使信息率小于<span class="math inline"><em>R</em>(<em>D</em>)</span>，平均失真一定会超过失真限度<span class="math inline"><em>D</em></span>。</p></li></ul></li><li><p>对于<strong>连续</strong>平稳无记忆信源，无法进行无失真编码，在<strong>限失真</strong>情况下，有与上述定理一样的编码定理。</p></li><li><p>限失真信源编码定理只能说明<strong>最佳编码是存在的</strong>，而具体构造编码方法却一无所知。因而就不能象无失真编码那样从证明过程中引出概率匹配的编码方法。一般只能从优化的思路去求最佳编码。实际上迄今尚无合适的可实现的编码方法可接近<span class="math inline"><em>R</em>(<em>D</em>)</span>这个界。</p></li></ul><h2 id="常用信源编码方法简介">5.4 常用信源编码方法简介</h2><h3 id="变长码与存储器容量">变长码与存储器容量</h3><ul><li><p><span class="math inline"><em>T</em></span>秒内有<span class="math inline"><em>N</em></span>个信源符号输出，信源输出符号速率<span class="math inline"><em>S</em> = <em>N</em>/<em>T</em></span>，若符号的平均码长为<span class="math inline">$\overline{K}$</span>，则信道<strong>传输速率</strong>需要<span class="math display">$$R_{t}=S\overline{K}$$</span></p></li><li><p><span class="math inline"><em>N</em></span>个码字的长度分别为<span class="math inline"><em>K</em><sub><em>i</em></sub>, <em>i</em> = 1, …, <em>N</em></span>，即在此期间输入存储器<span class="math inline">$\sum_{i = 1}^{N}K_{i}$</span> bit，输出信道<span class="math inline"><em>R</em><sub><em>t</em></sub><em>T</em></span>bit，则在<strong>存储器里还剩</strong>： <span class="math display">$$X=\sum_{i = 1}^{N}K_{i}-R_{t}T$$</span></p></li><li><p>已知<span class="math inline"><em>K</em><sub><em>i</em></sub></span>是随机变量，其均值和方差为：<span class="math display">$$  \overline{K}=E[K_{i}]=\sum_{j = 1}^{m}p_{j}K_{j}\\  \sigma^{2}=E[K_{i}^{2}]-\overline{K}^{2}=\sum_{j =1}^{m}p_{j}K_{j}^{2}-\overline{K}^{2}  $$</span></p><p>式中<span class="math inline"><em>m</em></span>为信源符号集的元数。当<span class="math inline"><em>N</em></span>足够大时，<span class="math inline"><em>X</em></span>是许多独立同分布的随机变量之和，它近似于正态分布<span class="math display">$$p_{X}(x)=\frac{1}{\sqrt{2\pi}\sigma_{X}}e^{-\frac{(x- E[X])^{2}}{2\sigma_{X}^{2}}}$$</span></p><p>其均值和方差分别为： <span class="math display">$$  E[X]=N\overline{K}-R_{t}T$$</span><span class="math display"><em>σ</em><sub><em>X</em></sub><sup>2</sup> = <em>N</em><em>σ</em><sup>2</sup></span></p></li><li><p>若信道速率满足<span class="math inline">$R_{t}=S\overline{K}$</span>，<span class="math inline"><em>E</em>[<em>X</em>] = 0</span>。假设存储器容量为<span class="math inline">2<em>A</em><em>σ</em><sub><em>X</em></sub></span>，起始时存储器为半满，则<strong>溢出概率</strong>为：<span class="math display"><em>P</em>(<em>X</em> &gt; <em>A</em><em>σ</em><sub><em>X</em></sub>) = <em>ϕ</em>(−<em>A</em>) = ∫<sub>−∞</sub><sup>−<em>A</em></sup><em>φ</em>(<em>x</em>)<em>d</em><em>x</em></span></p><p><strong>取空概率</strong>为： <span class="math display"><em>P</em>(<em>X</em> &lt; −<em>A</em><em>σ</em><sub><em>X</em></sub>) = <em>ϕ</em>(−<em>A</em>)</span></p><p>其中<span class="math inline"><em>ϕ</em>(<em>x</em>)</span>为标准正态分布函数，<span class="math inline"><em>φ</em>(<em>x</em>)</span>为标准正态分布密度函数。</p></li><li><p>若要求溢出和取空概率<span class="math inline"><em>P</em><sub><em>e</em></sub> = 0.001</span>，查表得<span class="math inline"><em>A</em> = 3.08</span>，则存储器容量为： <span class="math display">$$C&gt;2A\sigma_{X}=2A\sqrt{N}\sigma =6.16\sqrt{N}\sigma$$</span></p><ul><li>码方差<span class="math inline"><em>σ</em></span>越大，要求存储器的容量也越大。</li><li>时间越长，<span class="math inline"><em>N</em></span>越大，要求存储器的容量也越大。</li><li>存储器容量设定后，随着时间的增长，存储器溢出和取空的概率都将增大。</li></ul></li><li><p>一般来说，变长码只适用于有限长的信息传输（如传真）。实际使用时，可把长信息分段发送，也可以实时检测存储器的状态，调整输出。</p></li></ul><h3 id="分组码-1">分组码</h3><h4 id="香农shannon编码">香农(Shannon)编码</h4><ul><li>见<a href="#香农编码">香农编码</a></li><li><strong>编码步骤</strong><ol type="1"><li>将信源消息符号按其出现的概率大小依次排列：<span class="math display"><em>p</em><sub>1</sub> ≥ <em>p</em><sub>2</sub> ≥ ⋯ ≥ <em>p</em><sub><em>n</em></sub></span></li><li>依照下列不等式确定整数的码长<span class="math inline"><em>K</em><sub><em>i</em></sub></span>：<span class="math display">−log<sub>2</sub>(<em>p</em><sub><em>i</em></sub>) ≤ <em>l</em><sub><em>i</em></sub> &lt; −log<sub>2</sub>(<em>p</em><sub><em>i</em></sub>) + 1</span></li><li>为了编成唯一可译码，计算第<span class="math inline"><em>i</em></span>个消息的累加概率：<span class="math display">$$P_{i}=\sum_{k = 1}^{i - 1}p(a_{k})$$</span></li><li>将累加概率<span class="math inline"><em>P</em><sub><em>i</em></sub></span>变换成二进制数</li><li>取<span class="math inline"><em>P</em><sub><em>i</em></sub></span>二进制数的小数点后<span class="math inline"><em>l</em><sub><em>i</em></sub></span>位即为该消息符号的二进制码字</li></ol></li></ul><h4 id="哈夫曼huffman编码">哈夫曼(Huffman)编码</h4><ul><li><strong>特点</strong><ul><li>哈夫曼（Huffman）编码是分组码。</li><li>依据各符号出现的<strong>概率</strong>来构造码字。</li><li>基于二叉树的编码思想，所有可能的符号在哈夫曼树上对应为一个节点，节点的位置就是该符号的码字。这些节点都是终极节点，不再延伸，不会出现前缀码，因而唯一可译。</li><li>哈夫曼编码是一种效率比较高的<strong>变长无失真信源编码</strong>方法。</li></ul></li><li><strong>编码步骤</strong>：<ol type="1"><li>将信源消息符号按其出现的概率大小依次排列 <span class="math display"><em>p</em><sub>1</sub> ≥ <em>p</em><sub>2</sub> ≥ ⋯ ≥ <em>p</em><sub><em>n</em></sub></span></li><li>取两个概率最小的符号分别配以0和1两个码元，并将这两个概率相加作为一个新符号的概率，与未分配的二进符号的符号重新排队。</li><li>对重排后的两个概率最小符号重复步骤 2 的过程。</li><li>不断继续上述过程，直到最后两个符号配以0和1为止。</li><li>从最后一级开始，<strong>向前</strong>返回得到各个信源符号所对应的码元序列，即相应的码字。</li></ol></li><li>哈夫曼编码方法得到的码<strong>并非唯一</strong>的。<ul><li>每次对信源缩减时，赋予信源最后两个概率最小的符号时，0和1是可以任意的，所以可以得到不同的哈夫曼码，但不会影响码字的长度。</li><li>对信源进行缩减时，若两个概率最小的符号合并后的概率与其它信源符号的概率相同时，这两者在缩减信源中进行概率排序，其位置放置次序是可以任意的，故会得到不同的哈夫曼码。此时将影响码字的长度，一般将<strong>合并的概率放在靠前位置</strong>，这样可获得<strong>较小的码方差</strong>。</li><li>不同的编法得到的码字长度<span class="math inline"><em>K</em><sub><em>i</em></sub></span>也不尽相同。</li></ul></li><li>单符号信源编二进制哈夫曼码，编码效率主要决定于信源熵和平均码长之比。<ul><li>对相同的信源编码，其熵是一样的，采用不同的编法得到的平均码长可能不同。</li><li>平均码长越短，编码效率就越高。</li></ul></li><li><strong>码方差</strong>： <span class="math display">$$  \sigma_{I}^{2}=E\left[\left(K_{i}-\overline{K}\right)^{2}\right]=\sum_{i= 1}^{q}p(a_{i})(K_{i}-\overline{K})^{2}  $$</span><ul><li>例题：<img src="image-95.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul></li><li><strong>N进制哈夫曼编码</strong>：<ul><li>在N进制哈夫曼编码中，为了得到最短平均码长，有时需要对信源符号作添加，使信源符号数量满足<span class="math display"><em>N</em> + <em>k</em>(<em>N</em> − 1)  <em>k</em> ∈ <em>N</em></span></li><li>平均二进制码长(信息率)为 <span class="math display">$$\overline{K} =\frac{\overline{K_L}}{L}\log_2 N$$</span></li></ul></li><li><strong>用哈夫曼方法对信源序列编码</strong><ul><li>随着序列长度<span class="math inline"><em>L</em></span>的增加，平均（二进制）码长迅速降低，接近信源熵值。</li><li>例题：信源输出两个符号，概率分布为<span class="math inline"><em>P</em> = (0.9, 0.1)</span>，信源熵<span class="math inline"><em>H</em>(<em>X</em>) = 0.469</span>比特/符号。采用二进制哈夫曼编码。<ul><li><span class="math inline">$L = 1,\overline{K}=1$</span>bit/符号</li><li><span class="math inline">$L = 2,P'=(0.81, 0.09, 0.09,0.01),\overline{K}=0.645$</span> bit/符号</li><li><span class="math inline">$L = 3,\overline{K}=0.533$</span>bit/符号</li><li><span class="math inline">$L = 4,\overline{K}=0.494$</span>bit/符号</li></ul></li></ul></li></ul><h4 id="费诺fano编码">费诺(Fano)编码</h4><ul><li><strong>特点</strong>：<ul><li>费诺（Fano）编码方法属于概率匹配编码</li><li>费诺码的编码方法实际上是一种构造码树的方法，所以费诺码是即时码。</li><li>费诺码考虑了信源的统计特性，使概率大的信源符号能对应码长短的码字，从而有效地提高了编码效率。</li><li>但是费诺编码方法不一定使短码得到充分利用。尤其当信源符号较多时，若有一些符号概率分布很接近时，分两大组的组合方法会很多。可能某种分大组的结果，会使后面小组的“概率和”相差较远，使平均码长增加。</li></ul></li><li><strong>编码步骤</strong>：<ol type="1"><li>将信源消息符号按其出现的概率大小依次排列 <span class="math display"><em>p</em><sub>1</sub> ≥ <em>p</em><sub>2</sub> ≥ ⋯ ≥ <em>p</em><sub><em>n</em></sub></span></li><li>将依次排列的信源符号按概率值分为两大组，使两个组的概率之和近于相同，并对各组赋予一个二进制码元“0”和“1”；</li><li>将每一大组的信源符号进一步再分成两组，使划分后的两个组的概率之和近于相同，并又赋予两个组一个二进制符号“0”和“1”。</li><li>如此重复，直至每个组只剩下一个信源符号为止。</li><li>信源符号所对应的码字即为费诺码。</li></ol></li><li>适用场景：费诺码比较适合于每次分组概率都很接近的信源，特别是对每次分组概率都相等的信源进行编码时，可达到理想的编码效率。</li><li>例题：<img src="image-96.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h4 id="分组码的局限性">分组码的局限性</h4><ul><li>概率特性必须得到精确的测定，若其略有变化，还需更换码表。</li><li>对于二元信源，常常需要将多个符号合起来编码才能取得较好的效果。</li><li>当合并的符号数不大时，编码效率提高不明显，尤其是对于相关信源，结果难以令人满意。</li><li>而合并的符号数增大时，码表中的码字数增多，会导致设备越来越复杂。</li></ul><h3 id="非分组码">非分组码</h3><h4 id="算术编码">算术编码</h4><ul><li><strong>特点</strong>：<ul><li>算术码是一种<strong>非分组码</strong>，其基本思路是：<ul><li>积累概率<span class="math inline"><em>P</em>(<em>S</em>)</span>把区间<span class="math inline">[0, 1)</span>分割成许多小区间，每个小区间的长度等于各序列的概率<span class="math inline"><em>p</em>(<em>S</em>)</span>，小区间内的任一点可用来代表这序列。</li><li><figure><img src="image-47.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li></ul></li><li><strong>与<a href="#香农编码">香农编码</a>的区别</strong>：香农码考虑单个符号，算术编码考虑的是整个数据文件。</li></ul></li><li><strong>求序列的概率<span class="math inline"><em>p</em>(<em>S</em>)</span>和累计概率<span class="math inline"><em>P</em>(<em>S</em>)</span></strong>：<ul><li>信源符号集<span class="math inline"><em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span>，<span class="math inline"><em>L</em></span>长信源序列共有<span class="math inline"><em>n</em><sup><em>L</em></sup></span>种可能序列，因为序列长度<span class="math inline"><em>L</em></span>很大，很难得到对应序列的概率和累积概率，只能从已知的信源符号概率中递推得到。</li><li>信源符号概率分布为：<span class="math display"><em>P</em> = [<em>p</em>(<em>a</em><sub>1</sub>), <em>p</em>(<em>a</em><sub>2</sub>), ⋯, <em>p</em>(<em>a</em><sub><em>n</em></sub>)] = [<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub>]</span></li><li>定义各符号的累积概率为：<span class="math display">$$P_{r}=\sum_{i =1}^{r - 1}p_{i}\quad p_{r}=P_{r + 1}-P_{r}$$</span></li></ul></li><li><strong>累积概率递推公式</strong><ul><li><p><strong>二元序列</strong>： 有二元符号序列<span class="math inline"><em>S</em> = 011</span>，把3个二元符号的序列按自然二进制数排列，<span class="math inline">000, 001, 010, 011, ⋯</span>，则<span class="math inline"><em>S</em></span>的累积概率为： <span class="math display"><em>P</em>(<em>S</em>) = <em>p</em>(000) + <em>p</em>(001) + <em>p</em>(010)</span></p><p>如果<span class="math inline"><em>S</em></span>后面接一个“<span class="math inline">0</span>”，累积概率就成为： <span class="math display">$$  \begin{align*}  P(S,0)=&amp;P(0110)\\  =&amp;p(0000)+p(0001)+p(0010)+\\  &amp;p(0011)+p(0100)+p(0101)  \end{align*}  $$</span></p><p>由归一律，<span class="math inline"><em>p</em>(0000) + <em>p</em>(0001) = <em>p</em>(000)</span>等，得：<span class="math display"><em>P</em>(<em>S</em>, 0) = <em>P</em>(0110) = <em>p</em>(000) + <em>p</em>(001) + <em>p</em>(010) = <em>P</em>(<em>S</em>)</span></p><p>同理， <span class="math display">$$  \begin{align*}  P(S,1)=&amp;P(0111)\\  =&amp;p(0000)+p(0001)+p(0010)+\\  &amp;p(0011)+p(0100)+p(0101)+p(0110)\\  =&amp;P(S)+p(0110)\\  =&amp;P(S)+p(S)p_{0}  \end{align*}  $$</span></p><p>当<span class="math inline"><em>A</em> = {0, 1}</span>，即<strong>二元信源</strong>时：<span class="math inline"><em>P</em><sub>0</sub> = 0</span>；<span class="math inline"><em>P</em><sub>1</sub> = <em>p</em><sub>0</sub></span><img src="image-48.webp" srcset="/img/loading/loading3.gif" lazyload> <span class="math display">$$  \begin{align*}  &amp;P(S,0)=P(S)=P(S)+p(S)P_{0}\\  &amp;P(S,1)=P(S)+p(S)p_{0}=P(S)+p(S)P_{1}  \end{align*}  $$</span></p><p>统一写作 <span class="math display"><em>P</em>(<em>S</em>, <em>r</em>) = <em>P</em>(<em>S</em>) + <em>p</em>(<em>S</em>)<em>P</em><sub><em>r</em></sub>  <em>r</em> = 0, 1</span><img src="image-49.webp" srcset="/img/loading/loading3.gif" lazyload></p></li><li><p><strong>一般递推公式</strong>推广到多元序列，即可得到一般的递推公式： <span class="math display">$$  \begin{align*}  P(S,a_{r})=&amp;P(S)+p(S)P_{r}\\  p(S,a_{r})=&amp;p(S)p_{r}  \end{align*}  $$</span> <img src="image-50.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>随着序列的长度不断增加，<span class="math inline"><em>p</em>(<em>S</em>)</span>越来越小，<span class="math inline"><em>P</em>(<em>S</em>)</span>所在区间的长度就越短，也就可以更加精确地确定<span class="math inline"><em>P</em>(<em>S</em>)</span>的位置。</li></ul></li></ul></li><li><strong>编码过程</strong>：<ul><li>实际应用中，<strong>用码字<span class="math inline"><em>C</em>(<em>S</em>)</span>表示累积概率<span class="math inline"><em>P</em>(<em>S</em>)</span>，用状态区间<span class="math inline"><em>A</em>(<em>S</em>)</span>表示序列的概率<span class="math inline"><em>p</em>(<em>S</em>)</span></strong>，则递推公式为：<span class="math display">$$  \begin{cases}  C(S,r)=C(S)+A(S)P_{r}\\  A(S,r)=A(S)p_{r}  \end{cases}  $$</span> <img src="image-51.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><ol type="1"><li>设置两个存储器，起始时令<span class="math inline"><em>A</em>(<em>φ</em>) = 1, <em>C</em>(<em>φ</em>) = 0</span>，<span class="math inline"><em>φ</em></span>表示空集，即起始时码字为<span class="math inline">0</span>，状态区间为<span class="math inline">1</span>。</li><li>每输入一个信源符号，存储器<span class="math inline"><em>C</em></span>和<span class="math inline"><em>A</em></span>就按照递推公式更新一次，直至信源符号输入完毕。</li><li>确定码长 <span class="math display">$$L=\left\lceil\log\frac{1}{A(S)}\right\rceil$$</span>其中<span class="math inline">⌈<em>x</em>⌉</span>代表大于或等于<span class="math inline"><em>x</em></span>的最小整数。</li><li>取存储器<span class="math inline"><em>C</em></span>小数点后<span class="math inline"><em>L</em></span>位的内容作为该序列的码字输出；如果有尾数，就进位到第<span class="math inline"><em>L</em></span>位，这样得到一个数<span class="math inline"><em>C</em></span>。</li></ol></li><li><strong>译码过程</strong>：<ol type="1"><li>判断接收到的码字 <span class="math inline"><em>C</em>(<em>S</em>)</span>落在哪个初始概率区间，从而确定第一个符号。</li><li>从 <span class="math inline"><em>C</em>(<em>S</em>)</span>中减去对应首个符号的累积概率 <span class="math inline"><em>P</em><sub><em>r</em></sub></span> 。</li><li>将相减后的数值乘以当前符号概率 <span class="math inline"><em>p</em><sub><em>r</em></sub></span>的倒数，放大至 <span class="math inline">[0, 1]</span>区间，以确定下一个符号所在的概率区间，进而确定下一个符号。</li><li>不断重复上述去掉累积概率、区间放大和确定符号的步骤，直到处理完整个码字，译出完整的符号序列。</li></ol></li><li><strong>示例</strong>：有四个符号<span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em></span>，<span class="math inline"><em>c</em></span>，<span class="math inline"><em>d</em></span>构成简单序列<span class="math inline"><em>S</em> = <em>a</em><em>b</em><em>d</em><em>a</em></span>，各符号及其对应概率如下表<img src="image-75.webp" srcset="/img/loading/loading3.gif" lazyload><ul><li><table><thead><tr><th>符号</th><th>符号概率<span class="math inline"><em>p</em><sub><em>i</em></sub></span></th><th>符号累积概率<span class="math inline"><em>P</em><sub><em>j</em></sub></span></th></tr></thead><tbody><tr><td><span class="math inline"><em>a</em></span></td><td><span class="math inline">0.100(1/2)</span></td><td><span class="math inline">0.000</span></td></tr><tr><td><span class="math inline"><em>b</em></span></td><td><span class="math inline">0.010(1/4)</span></td><td><span class="math inline">0.100</span></td></tr><tr><td><span class="math inline"><em>c</em></span></td><td><span class="math inline">0.001(1/8)</span></td><td><span class="math inline">0.110</span></td></tr><tr><td><span class="math inline"><em>d</em></span></td><td><span class="math inline">0.001(1/8)</span></td><td><span class="math inline">0.111</span></td></tr></tbody></table></li><li><p><strong>算术编码过程如下</strong>：</p><ol type="1"><li>设起始状态为空序列<span class="math inline"><em>φ</em></span>，则<span class="math inline"><em>A</em>(<em>φ</em>) = 1</span>，<span class="math inline"><em>C</em>(<em>φ</em>) = 0</span>。</li><li>计算<span class="math inline"><em>C</em>(<em>φ</em><em>a</em>)</span>和<span class="math inline"><em>A</em>(<em>φ</em><em>a</em>)</span>： <span class="math display">$$  \begin{cases}  C(\varphi a)=C(\varphi)+A(\varphi)P_a = 0 + 1\times0 = 0\\  A(\varphi a)=A(\varphi)p_a = 1\times0.1 = 0.1  \end{cases}  $$</span></li><li>计算<span class="math inline"><em>C</em>(<em>a</em><em>b</em>)</span>和<span class="math inline"><em>A</em>(<em>a</em><em>b</em>)</span>： <span class="math display">$$  \begin{cases}  C(ab)=C(a)+A(a)P_b = 0 + 0.1\times0.1 = 0.01\\  A(ab)=A(a)p_b = 0.1\times0.01 = 0.001  \end{cases}  $$</span></li><li>计算<span class="math inline"><em>C</em>(<em>a</em><em>b</em><em>d</em>)</span>和<span class="math inline"><em>A</em>(<em>a</em><em>b</em><em>d</em>)</span>：<span class="math display">$$  \begin{cases}  C(abd)=C(ab)+A(ab)P_d = 0.01 + 0.001\times0.111 = 0.010111\\  A(abd)=A(ab)p_d = 0.001\times0.001 = 0.000001  \end{cases}  $$</span></li><li>计算<span class="math inline"><em>C</em>(<em>a</em><em>b</em><em>d</em><em>a</em>)</span>和<span class="math inline"><em>A</em>(<em>a</em><em>b</em><em>d</em><em>a</em>)</span>：<span class="math display">$$  \begin{cases}  C(abda)=C(abd)+A(abd)P_a = 0.010111 + 0.000001\times0 = 0.010111\\  A(abda)=A(abd)p_a = 0.000001\times0.1 = 0.0000001  \end{cases}  $$</span></li><li>计算编码长度<span class="math inline"><em>L</em></span>：<span class="math display">$$L = \left\lceil\log\frac{1}{A(abcd)}\right\rceil= 7$$</span> 取<span class="math inline"><em>C</em>(<em>a</em><em>b</em><em>d</em><em>a</em>)</span>的小数点后<span class="math inline">7</span>位即为编码后的码字<span class="math inline">0101110</span>。</li></ol></li><li><p>该信源的熵为： <span class="math display">$$H(X)=\frac{1}{2}\log2+\frac{1}{4}\log4 +2\times\frac{1}{8}\log8 = 1.75\ bit/符号$$</span></p><p>编码效率<span class="math display">$$\eta=\frac{1.75}{\frac{7}{4}} =100\%$$</span></p></li><li><p><strong>译码过程如下</strong>： <img src="image-74.webp" srcset="/img/loading/loading3.gif" lazyload></p><ol type="1"><li>已知编码后的数值<span class="math inline"><em>C</em>(<em>S</em>) = 0.010111</span>，因为<span class="math inline"><em>C</em>(<em>S</em>) = 0.010111 ∈ [0, 0.1)</span>，根据符号累积概率表，第一个符号为<span class="math inline"><em>a</em></span>。</li><li>去掉累积概率<span class="math inline"><em>P</em><sub><em>a</em></sub></span>：<span class="math inline">0.010111 − 0 = 0.010111</span>， 放大至<span class="math inline">[0, 1]</span>（乘以<span class="math inline"><em>p</em><sub><em>a</em></sub><sup>−1</sup></span>）：<span class="math inline">0.010111 × 2<sup>1</sup> = 0.10111 ∈ [0.1, 0.110)</span>第二个符号为<span class="math inline"><em>b</em></span>。</li><li>去掉累积概率<span class="math inline"><em>P</em><sub><em>b</em></sub></span>：<span class="math inline">0.10111 − 0.1 = 0.00111</span>。 放大至<span class="math inline">[0, 1]</span>（乘以<span class="math inline"><em>p</em><sub><em>b</em></sub><sup>−1</sup></span>）：<span class="math inline">0.00111 × 2<sup>2</sup> = 0.111 ∈ [0.111, 1)</span>第三个符号为<span class="math inline"><em>d</em></span>。</li><li>去掉累积概率<span class="math inline"><em>P</em><sub><em>d</em></sub></span>：<span class="math inline">0.111 − 0.111 = 0</span>。 放大至<span class="math inline">[0, 1]</span>（乘以<span class="math inline"><em>p</em><sub><em>d</em></sub><sup>−1</sup></span>）：<span class="math inline">0 × 2<sup>3</sup> = 0 ∈ [0, 0.1)</span>第四个符号为<span class="math inline"><em>a</em></span>。</li></ol></li></ul></li></ul><h4 id="lz编码">LZ编码</h4><ul><li><strong>特点</strong>：<ul><li>LZ编码是一种<strong>字典编码</strong>，无需确定信源的统计特性。</li></ul></li><li><strong>LZ78 编码步骤</strong><ul><li>设信源符号集<span class="math inline"><em>A</em> = (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>K</em></sub>)</span>共<span class="math inline"><em>K</em></span>个符号，输入信源符号序列<span class="math inline"><em>U</em> = (<em>u</em><sub>1</sub>, <em>u</em><sub>2</sub>, ⋯, <em>u</em><sub><em>L</em></sub>)</span>，编码是将此序列分成不同的段。</li><li><strong>分段规则</strong>：尽可能取最少个相连的信源符号，并保证各段都不相同。<ol type="1"><li>在第<span class="math inline"><em>i</em></span>步，从<span class="math inline"><em>s</em><sub><em>i</em> − 1</sub></span>短语后的第一个符号开始向后搜索此前未出现过的最短短语<span class="math inline"><em>s</em><sub><em>i</em></sub></span>，将该短语添入字典第<span class="math inline"><em>i</em></span>段。</li><li>假设<span class="math inline"><em>s</em><sub><em>i</em></sub></span>去掉最后一个符号<span class="math inline"><em>x</em></span>后所得的前缀是在第<span class="math inline"><em>j</em></span>步出现的短语。</li><li>对<span class="math inline"><em>s</em><sub><em>i</em></sub></span>的编码为<span class="math inline">(<em>j</em>, <em>x</em>)</span>。<strong>对段号<span class="math inline"><em>j</em></span>，用<span class="math inline">⌈log <em>i</em>⌉</span>比特来表示，符号<span class="math inline"><em>x</em></span>用<span class="math inline">⌈log <em>K</em>⌉</span>比特来表示。</strong></li></ol></li></ul></li><li><strong>LZ译码</strong>：无需接收方提前知晓字典内容，通过码字和逐步构建的字典就能完成译码<ol type="1"><li>接收到码字<span class="math inline">(<em>j</em>, <em>x</em>)</span>后，在已建立或正在建立的字典中找到第<span class="math inline"><em>j</em></span>个短语。</li><li>将符号<span class="math inline"><em>x</em></span>添加到找到的第<span class="math inline"><em>j</em></span>个短语后，形成新的短语。</li><li>把新生成的短语添入字典，以便后续译码使用。</li><li>对每个接收到的码字，不断重复上述步骤，直至完成所有码字的译码。</li></ol></li><li><strong>例题</strong>：<ul><li><p><strong>编码</strong>：设<span class="math inline"><em>U</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, <em>a</em><sub>4</sub>}</span>，信源序列为<span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>3</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>4</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>4</sub>, <em>a</em><sub>3</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>4</sub>⋯</span>，按照分段规则进行分段。符号编码表如下:</p><table><thead><tr><th><span class="math inline"><em>a</em><sub>1</sub></span></th><th><span class="math inline"><em>a</em><sub>2</sub></span></th><th><span class="math inline"><em>a</em><sub>3</sub></span></th><th><span class="math inline"><em>a</em><sub>4</sub></span></th></tr></thead><tbody><tr><td>00</td><td>01</td><td>10</td><td>11</td></tr></tbody></table><table><thead><tr><th>段号<span class="math inline"><em>i</em></span></th><th>短语</th><th><span class="math inline"><em>j</em></span></th><th><span class="math inline"><em>x</em></span></th><th>码字</th><th>编码</th></tr></thead><tbody><tr><td>1</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td>0</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>1</sub>)</span></td><td>0,00</td></tr><tr><td>2</td><td><span class="math inline"><em>a</em><sub>2</sub></span></td><td>0</td><td><span class="math inline"><em>a</em><sub>2</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>2</sub>)</span></td><td>0,01</td></tr><tr><td>3</td><td><span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>3</sub></span></td><td>1</td><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline">(1, <em>a</em><sub>3</sub>)</span></td><td>01,10</td></tr><tr><td>4</td><td><span class="math inline"><em>a</em><sub>2</sub><em>a</em><sub>4</sub></span></td><td>2</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline">(2, <em>a</em><sub>4</sub>)</span></td><td>10,11</td></tr><tr><td>5</td><td><span class="math inline"><em>a</em><sub>2</sub><em>a</em><sub>4</sub><em>a</em><sub>3</sub></span></td><td>4</td><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline">(4, <em>a</em><sub>3</sub>)</span></td><td>100,10</td></tr><tr><td>6</td><td><span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>1</sub></span></td><td>1</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline">(1, <em>a</em><sub>1</sub>)</span></td><td>001,00</td></tr><tr><td>7</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td>0</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>4</sub>)</span></td><td>000,11</td></tr></tbody></table></li><li><p><strong>译码</strong>：码序列为00000101101011100100010000011。符号编码表如下：</p><table><thead><tr><th>段号<span class="math inline"><em>i</em></span></th><th>编码</th><th><span class="math inline"><em>j</em></span></th><th><span class="math inline"><em>x</em></span></th><th>码字</th><th>短语</th></tr></thead><tbody><tr><td>1</td><td>0,00</td><td>0</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>1</sub>)</span></td><td><span class="math inline"><em>a</em><sub>1</sub></span></td></tr><tr><td>2</td><td>0,01</td><td>0</td><td><span class="math inline"><em>a</em><sub>2</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>2</sub>)</span></td><td><span class="math inline"><em>a</em><sub>2</sub></span></td></tr><tr><td>3</td><td>01,10</td><td>1</td><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline">(1, <em>a</em><sub>3</sub>)</span></td><td><span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>3</sub></span></td></tr><tr><td>4</td><td>10,11</td><td>2</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline">(2, <em>a</em><sub>4</sub>)</span></td><td><span class="math inline"><em>a</em><sub>2</sub><em>a</em><sub>4</sub></span></td></tr><tr><td>5</td><td>100,10</td><td>4</td><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline">(4, <em>a</em><sub>3</sub>)</span></td><td><span class="math inline"><em>a</em><sub>2</sub><em>a</em><sub>4</sub><em>a</em><sub>3</sub></span></td></tr><tr><td>6</td><td>001,00</td><td>1</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline">(1, <em>a</em><sub>1</sub>)</span></td><td><span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>1</sub></span></td></tr><tr><td>7</td><td>000,11</td><td>0</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>4</sub>)</span></td><td><span class="math inline"><em>a</em><sub>4</sub></span></td></tr></tbody></table></li></ul></li></ul><h4 id="游程编码rlerun-length-encoding">游程编码(RLE，run-lengthencoding)</h4><ul><li>在二元序列中，连0段称为0游程，连1段称为1游程。</li><li>例如二元码序列：<span class="math inline">000101110010001⋯</span>，可变换成下列游程序列：<span class="math inline">31132131⋯</span> 。</li><li>若已知二元序列以0起始，从游程序列很容易恢复成原来的二元序列。</li><li>游程序列是多元序列，各长度可按哈夫曼编码或其它方法处理以达到压缩码率的目的。</li></ul><h4 id="mh-编码传真编码">MH 编码(传真编码)</h4><ul><li><strong>MH编码方法</strong><ol type="1"><li>黑白游程分别对应不同的编码表。</li><li>游程长度在<span class="math inline">0 ∼ 63</span>时，码字直接用相应的终端码（结尾码）表示。<ul><li>例如：<ul><li>白游程长度为<span class="math inline">0</span>，查表得码字<span class="math inline">000</span> 。</li><li>黑游程长度为<span class="math inline">24</span> ，查表得码字<span class="math inline">11111</span> 。</li></ul></li></ul></li><li>游程长度在<span class="math inline">64 ∼ 1728</span>，用一个组合码加上一个结尾码为相应码字。<ul><li>例如：<ul><li>白游程长度为<span class="math inline">65( = 64 + 1)</span>，查表得码字<span class="math inline">11011 ∣ 000111</span> 。</li><li>黑游程长度为<span class="math inline">856( = 832 + 24)</span>，查表得码字<span class="math inline">0000001001101 ∣ 00000010111</span>。</li></ul></li></ul></li><li>规定每行都从白游程开始，若实际出现黑游程开始的话，则在行首加上零长度白游程码字，每行结束用一个结束码（EOL）。</li><li>每行恢复成<span class="math inline">1728</span>个像素，否则有错。</li><li>每页文件开始第一个数据前加一个结束码。每页尾连续使用<span class="math inline">6</span>个结束码表示结尾。</li><li>为了传输时实现同步操作，规定<span class="math inline"><em>T</em></span>为每编码行的最小传输时间。一般规定<span class="math inline"><em>T</em></span>最小为<span class="math inline">20<em>m</em><em>s</em></span>，最大为<span class="math inline">5<em>s</em></span>。若编码行传输时间小于<span class="math inline"><em>T</em></span>，则在结束码之前填以足够的“<span class="math inline">0</span>”码元（称填充码） 。</li></ol></li><li>页面数据结构<img src="image-76.webp" srcset="/img/loading/loading3.gif" lazyload alt="页面数据结构"></li><li>结尾码码表<img src="image-77.webp" srcset="/img/loading/loading3.gif" lazyload alt="结尾码码表"></li><li>组合基干码码表<img src="image-78.webp" srcset="/img/loading/loading3.gif" lazyload alt="组合基干码码表"></li><li>例题：<img src="image-97.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h1 id="第五章补充-无失真信源编码">第五章补充 无失真信源编码</h1><h2 id="渐进均分性定理aep-1">渐进均分性定理（AEP）</h2><ul><li><p><strong>定理</strong>：<span class="math inline">$\vec{X_{}}=(X_1X_2 \cdotsX_L)$</span>，为独立同分布（i.i.d）随机变量序列，具有渐近均分性质（AEP，Asymptoticequipartition property）： <span class="math display">$$\forall\varepsilon &gt; 0，当 L \to \infty时，p(X_1,X_2,\cdots,X_L) \to 2^{-LH(X)}$$</span></p></li><li><p><strong>信源编码模型</strong>： <img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload alt="信源模型"></p><ul><li><span class="math inline"><em>X</em><sub><em>i</em></sub> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li><span class="math inline"><em>Y</em><sub><em>i</em></sub> ∈ {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li></ul></li><li><p><strong>证明1</strong>：</p><ul><li><strong>自信息量</strong>： <span class="math display">$$  \begin{align*}  I(\vec{X_{}}) &amp;= -\log p(X_1,X_2,\cdots,X_L)\\  &amp;=-\log p(X_1)-\log p(X_2)-\cdots-\log p(X_L)\\  &amp;=\sum_{i = 1}^{L} I(X_i)  \end{align*}  $$</span></li><li><strong>均值</strong>(由i.i.d.)）： <span class="math display">$$  E\{I(\vec{X_{}})\}=E\left\{\sum_{i = 1}^{L} I(X_i)\right\}=\sum_{i =1}^{L} E\{I(X_i)\}=\sum_{i = 1}^{L} H(X_i)=L H(X)  $$</span></li><li><strong>方差</strong>(由i.i.d.)： <span class="math display">$$  D\{I(\vec{X_{}})\}=D\left\{\sum_{i = 1}^{L} I(X_i)\right\}=\sum_{i =1}^{L} D\{I(X_i)\}=L D(I(X))  $$</span> 其中 <span class="math display">$$  D(I(X)) = E\left[(I(X)-H(X))^2\right]=\sum_{i = 1}^{n} p(x_i)(-\logp(x_i)-H(X))^2  $$</span></li><li>根据切比雪夫不等式 <span class="math display">$$      P_r\{|X - \mu| \geq \varepsilon\} \leq\frac{\sigma^2}{\varepsilon^2}\quad (\varepsilon&gt;0, \sigma&gt;0)  $$</span> 有： <span class="math display">$$  P_r\left\{\left|I(\vec{X_{}})-L H(X)\right| \geq L\varepsilon\right\}\leq \frac{L D(I(X))}{(L\varepsilon)^2}  $$</span> <span class="math display">$$  P_r\left\{\left|\frac{I(\vec{X_{}})}{L}-H(X)\right| \geq\varepsilon\right\} \leq \frac{D(I(X))}{L\varepsilon^2}  $$</span> 当 <span class="math inline"><em>L</em> → ∞</span> 时 <span class="math display">$$  \begin{align*}  &amp;\frac{D(I(X))}{L\varepsilon^2} \to 0,\\  &amp;\frac{-\log p(X_1,X_2,\cdots,X_L)}{L} \to H(X),\\  &amp;p(X_1,X_2,\cdots,X_L) \to 2^{-L H(X)}  \end{align*}  $$</span></li></ul></li><li><p><strong>证明2</strong>：</p><ul><li>AEP 也可由弱大数定律直接得到</li><li>当 <span class="math inline"><em>X</em></span> 为 i.i.d，<span class="math inline"><em>n</em></span> 很大时，<span class="math inline">$\frac{1}{n}\sum_{i = 1}^{n} x_i \to E(X)$</span><span class="math display">$$  \begin{align*}  -\frac{1}{L}\log p(X_1,X_2,\cdots,X_L)= &amp;-\frac{1}{L}\sum_{i =1}^{L} \log p(X_i)\\  \overset{a.s.}{\to} &amp;-E(\log p(X))\\  = &amp;H(X)  \end{align*}  $$</span></li></ul></li><li><p><strong>典型集<span class="math inline"><em>A</em><sub><em>ε</em></sub></span></strong></p><ul><li><p><strong>定义</strong> <span class="math display">$$  \begin{align*}  &amp;A_{\varepsilon}=\left\{\vec{x_{}}:\left|\frac{I(\vec{x_{}})}{L}-H(X)\right|\leq \varepsilon\right\}\\  &amp;A_{\varepsilon}^c=\left\{\vec{x_{}}:\left|\frac{I(\vec{x_{}})}{L}-H(X)\right|&gt; \varepsilon\right\}\\  &amp;A_{\varepsilon}+A_{\varepsilon}^c = X^L=\{\vec{x_{i}}\}\quad i =1,2,\cdots,n^L  \end{align*}  $$</span></p></li><li><p><strong>性质</strong></p><ol type="1"><li>若 <span class="math inline">$\vec{x_{}} \inA_{\varepsilon}$</span>，则典型集中的元素几乎是等概率出现的： <span class="math display">$$2^{-L(H(X)+\varepsilon)} \leq p(\vec{x_{}}) \leq2^{-L(H(X)-\varepsilon)}$$</span></li><li>当 <span class="math inline"><em>L</em></span>充分大时，典型集的概率近似为1： <span class="math display">$$P_r(A_\varepsilon) = \sum_{\vec{x_{}} \inA_{\varepsilon}} p(\vec{x_{}})&gt;1 - \varepsilon$$</span></li><li>典型集中元素的个数： <span class="math display">|<em>A</em><sub><em>ε</em></sub>| ≤ 2<sup><em>L</em>(<em>H</em>(<em>X</em>) + <em>ε</em>)</sup></span><ul><li>证明： <span class="math display">$$  \begin{align*}  1&amp;=\sum_{\vec{x_{}} \in X^L} p(\vec{x_{}}) \geq \sum_{\vec{x_{}}\in A_{\varepsilon}} p(\vec{x_{}})\\  &amp;\geq \sum_{\vec{x_{}} \in A_{\varepsilon}}2^{-L(H(X)+\varepsilon)}=|A_{\varepsilon}|2^{-L(H(X)+\varepsilon)}\\  \Rightarrow &amp;|A_{\varepsilon}| \leq 2^{L(H(X)+\varepsilon)}  \end{align*}  $$</span></li></ul></li><li>典型集中元素的个数： <span class="math display">|<em>A</em><sub><em>ε</em></sub>| ≥ (1 − <em>ε</em>)2<sup><em>L</em>(<em>H</em>(<em>X</em>) − <em>ε</em>)</sup></span>当 <span class="math inline"><em>L</em></span> 充分大时，<span class="math inline"><em>P</em><sub><em>r</em></sub>(<em>A</em><sub><em>ε</em></sub>) &gt; 1 − <em>ε</em></span><ul><li>证明： <span class="math display">$$  \begin{align*}  1-\varepsilon &amp;\leq P_r(A_{\varepsilon}) = \sum_{\vec{x_{}} \inA_{\varepsilon}} p(\vec{x_{}})\\  &amp; \leq \sum_{\vec{x_{}} \in A_{\varepsilon}}2^{-L(H(X)-\varepsilon)}=|A_{\varepsilon}|2^{-L(H(X)-\varepsilon)}\\  \Rightarrow |A_{\varepsilon}| &amp;\geq (1 -\varepsilon)2^{L(H(X)-\varepsilon)}  \end{align*}  $$</span></li></ul></li></ol></li></ul></li></ul><h2 id="定长编码定理-1">定长编码定理</h2><ul><li><p><strong>定理</strong>：对于由 <span class="math inline"><em>L</em></span> 个符号组成的，每个符号的熵为 <span class="math inline">$H_L(\vec{X_{}})$</span> 的无记忆平稳符号序列 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub></span>，可用<span class="math inline"><em>K</em><sub><em>L</em></sub></span> 个符号<span class="math inline"><em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>K</em><sub><em>L</em></sub></sub></span>（每个符号有<span class="math inline"><em>m</em></span> 种可能值，即<span class="math inline"><em>m</em></span>进制编码）进行定长编码。对于任意<span class="math inline"><em>ε</em> &gt; 0</span>，<span class="math inline"><em>δ</em> &gt; 0</span>，只要 <span class="math display">$$\frac{K_L}{L}\log m \geq H_L(\vec{X_{}}) +\varepsilon$$</span></p><p>则当 <span class="math inline"><em>L</em></span>足够大时，必可使译码差错小于 <span class="math inline"><em>δ</em></span>； 反之，当 <span class="math display">$$\frac{K_L}{L}\log m \leq H_L(\vec{X_{}}) -2\varepsilon$$</span></p><p>时，译码差错一定是有限值，当 <span class="math inline"><em>L</em> → ∞</span>时，译码几乎必定出错。</p></li><li><p><strong>证明</strong></p><ul><li><p>对 <span class="math inline"><em>A</em><sub><em>ε</em></sub></span>中的元素进行定长编码，为了唯一可译，码符号个数大于等于 <span class="math inline">|<em>A</em><sub><em>ε</em></sub>|</span>，即 <span class="math display"><em>m</em><sup><em>K</em><sub><em>L</em></sub></sup> ≥ |<em>A</em><sub><em>ε</em></sub>|</span></p><p>此时<span class="math inline">|<em>A</em><sub><em>ε</em></sub>|</span>取上界，记平均符号熵<span class="math inline">$H_L(\vec{X_{}})$</span>为 <span class="math inline"><em>H</em>(<em>X</em>)</span> <span class="math display">$$  \begin{align*}  m^{K_L} &amp;\geq 2^{L(H(X) + \varepsilon)}\\  K_L\log m &amp;\geq L(H(X) + \varepsilon)\\  \frac{K_L}{L}\log m &amp;\geq H(X) + \varepsilon  \end{align*}  $$</span></p><p>此时，错误译码的概率为 <span class="math display">$$P_e =P_r\{A_{\varepsilon}^c\} \leq\frac{D(I(X))}{L\varepsilon^2}$$</span></p><p>若需 <span class="math inline"><em>P</em><sub><em>e</em></sub> ≤ <em>δ</em></span>，则有<span class="math display">$$  \begin{align*}  &amp;\frac{D(I(X))}{L\varepsilon^2} \leq \delta\\  &amp;L \geq \frac{D(I(X))}{\varepsilon^2\delta}  \end{align*}  $$</span></p><p>即信源长度 <span class="math inline"><em>L</em></span> 需满足 <span class="math inline">$L \geq\frac{D(I(X))}{\varepsilon^2\delta}$</span></p></li><li><p>反之，若 <span class="math display">$$  \begin{align*}  &amp;\frac{K_L}{L}\log m \leq H(X) - 2\varepsilon\\  &amp;\log m^{K_L} \leq L(H(X) - 2\varepsilon)\\  &amp;m^{K_L} \leq 2^{L(H(X) - 2\varepsilon)} &lt; (1 -\varepsilon)2^{L(H(X) - \varepsilon)} = |A_{\varepsilon}|_{min}  \end{align*}  $$</span></p><p>即 <span class="math inline"><em>m</em><sup><em>K</em><sub><em>L</em></sub></sup> &lt; |<em>A</em><sub><em>ε</em></sub>|</span>，码字个数少于<span class="math inline"><em>A</em><sub><em>ε</em></sub></span>中的元素个数</p><p>此时只能在 <span class="math inline"><em>A</em><sub><em>ε</em></sub></span> 中选取 <span class="math inline"><em>m</em><sup><em>K</em><sub><em>L</em></sub></sup></span>个元素进行一对一编码， <span class="math display">$$  \begin{align*}  P_r(只出现A_{\varepsilon}中的m^{K_L}个元素) &amp;\leq m^{K_L} \cdot\max_{\vec{x_{}} \in A_{\varepsilon}} p(\vec{x_{}}) = m^{K_L}2^{-L(H(X)- \varepsilon)}\\  &amp;\leq 2^{L(H(X) - 2\varepsilon) - L(H(X) - \varepsilon)}\\  &amp;= 2^{-L\varepsilon}  \end{align*}  $$</span></p><p>译码错误概率为 <span class="math inline"><em>P</em><sub><em>e</em></sub> = 1 − 2<sup>−<em>L</em><em>ε</em></sup></span>，<span class="math inline"><em>L</em> → ∞</span>，<span class="math inline"><em>P</em><sub><em>e</em></sub> → 1</span></p></li></ul></li></ul><h2 id="单符号变长编码定理">单符号变长编码定理</h2><ul><li><p><strong>定理</strong>：对于离散无记忆信源的符号 <span class="math inline"><em>X</em></span>，其熵为 <span class="math inline"><em>H</em>(<em>X</em>)</span>，每个信源符号用 <span class="math inline"><em>m</em></span>进制码元进行变长编码，一定存在一种无失真编码方法，其（<span class="math inline"><em>m</em></span> 进制）码元平均长度 <span class="math inline">$\overline{k}$</span> 满足下列不等式： <span class="math display">$$\frac{H(X)}{\log m} \leq \overline{k} &lt;\frac{H(X)}{\log m} + 1$$</span></p><p>其中，<span class="math inline">$\overline{k} = \sum_{i = 1}^{n}p(a_i)l_i$</span>，<span class="math inline"><em>l</em><sub><em>i</em></sub></span> 为符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span>的码长。</p></li><li><p><strong>证明</strong>：</p><ul><li><strong>定义</strong>：<span class="math inline"><em>l</em><sub><em>i</em></sub></span> 为符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的码长，<span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>为符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span>的概率，<span class="math inline">$\overline{k} = \sum_{i = 1}^{n}p(a_i)l_i$</span> 为码元平均长度。</li><li><figure><img src="image-57.webp" srcset="/img/loading/loading3.gif" lazyload alt="码元平均长度"><figcaption aria-hidden="true">码元平均长度</figcaption></figure></li></ul><ol type="1"><li><p><strong>证明必存在无失真编码，使得 <span class="math inline">$H(X) - (\log m)\overline{k} \leq 0$</span></strong><span class="math display">$$\begin{align*}H(X) - (\log m)\overline{k} &amp;= -\sum_{i = 1}^{n} p(a_i)\log p(a_i) -\sum_{i = 1}^{n} p(a_i)l_i\log m\\&amp;=\sum_{i = 1}^{n} p(a_i)\log \frac{m^{-l_i}}{p(a_i)}\end{align*}$$</span></p><p>根据Jensen不等式 <span class="math inline"><em>E</em>[<em>f</em>(<em>x</em>)] ≤ <em>f</em>(<em>E</em>(<em>x</em>))</span>，有<span class="math display">$$\begin{align*}H(X) - (\log m)\overline{k} &amp;=\sum_{i = 1}^{n} p(a_i)\log\frac{m^{-l_i}}{p(a_i)}\\&amp;\leq \log \sum_{i = 1}^{n} p(a_i)\frac{m^{-l_i}}{p(a_i)} = \log\sum_{i = 1}^{n} m^{-l_i}\end{align*}$$</span></p><p>唯一可译码存在（无失真），因此 <span class="math inline">$\sum_{i =1}^{n} m^{-l_i} \leq 1$</span> <span class="math display">$$\begin{align*}&amp;H(X) - (\log m)\overline{k} \leq \log 1 = 0\\&amp;\Rightarrow \overline{k} \geq \frac{H(X)}{\log m}\end{align*}$$</span></p><p>若要等号成立 <span class="math display">$$m^{-l_i} = p(a_i),\quad l_i = \frac{-\log p(a_i)}{\log m}$$</span></p></li><li><p><strong>证明 <span class="math inline">$\overline{k} &lt;\frac{H(X)}{\log m} + 1$</span></strong> 符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的码长 <span class="math inline"><em>l</em><sub><em>i</em></sub></span>需要是整数，因此取 <span class="math display">$$\frac{-\log p(a_i)}{\logm} \leq l_i &lt; \frac{-\log p(a_i)}{\log m} + 1$$</span></p><p>由 <span class="math display">$$\begin{align*}&amp;\frac{-\log p(a_i)}{\log m} \leq l_i\\&amp;\Rightarrow -\log m^{l_i} \leq \log p(a_i)\\&amp;\Rightarrow m^{-l_i} \leq p(a_i)\\&amp;\Rightarrow \sum_{i = 1}^{n} m^{-l_i} \leq \sum_{i = 1}^{n}p(a_i)=1\end{align*}$$</span></p><p>表明 <span class="math inline"><em>l</em><sub><em>i</em></sub></span>满足唯一可译码存在的条件。 又由 <span class="math display">$$\begin{align*}l_i &amp;&lt; \frac{-\log p(a_i)}{\log m} + 1\\\sum_{i = 1}^{n} l_i p(a_i) &amp;&lt; \sum_{i = 1}^{n}p(a_i)(\frac{-\log p(a_i)}{\log m} + 1)\\\overline{k} &amp;&lt; \frac{H(X)}{\log m} + 1\end{align*}$$</span></p></li></ol></li></ul><h2 id="离散平稳无记忆序列变长编码定理香农第一定理-1">离散平稳无记忆序列变长编码定理（香农第一定理）</h2><ul><li><p><strong>定理</strong>：对于平均符号熵为 <span class="math inline">$H_L(\vec{X_{}})$</span>的离散平稳无记忆信源，必存在一种无失真编码方法，使平均信息率 <span class="math inline">$\overline{K}$</span> 满足不等式： <span class="math display">$$H_L(\vec{X_{}}) \leq \overline{K} &lt;H_L(\vec{X_{}}) + \varepsilon$$</span></p><p>其中 <span class="math inline"><em>ε</em></span> 为任意小正数，<span class="math inline">$\overline{K} = \frac{\overline{k}_L}{L} \logm$</span>，<span class="math inline">$\overline{k}_L$</span> 为 <span class="math inline"><em>L</em></span> 个符号的平均码长。</p></li><li><p><strong>证明</strong> 将 <span class="math inline">$\vec{X_{}}=(X_1 X_2 \cdots X_L)$</span>作为一个整体，构成一个新的单符号信源。因此有： <span class="math display">$$  \begin{align*}  \frac{L H_L(\vec{X_{}})}{\log m} &amp;\leq \overline{k}_L &lt; \frac{LH_L(\vec{X_{}})}{\log m} + 1\\  H_L(\vec{X_{}}) &amp;\leq \frac{\overline{k}_L}{L} \log m &lt;H_L(\vec{X_{}}) + \frac{\log m}{L}  \end{align*}  $$</span></p><p>令 <span class="math inline">$\overline{K}= \frac{\overline{k}_L}{L}\log m$</span>，则有 <span class="math display">$$H_L(\vec{X_{}}) \leq\overline{K} &lt; H_L(\vec{X_{}}) + \varepsilon \quad (L \to\infty)$$</span></p><p>此时编码效率<span class="math display">$$\eta =\frac{H_L(\vec{X_{}})}{\overline{K}} &gt;\frac{H_L(\vec{X_{}})}{H_L(\vec{X_{}}) + \frac{\logm}{L}}$$</span></p></li></ul><h1 id="第六章-信道编码">第六章 信道编码</h1><ul><li>信道传输会使接收信号出现差错，信道编码旨在提升传输可靠性，主要涉及两个层面的问题：<ul><li>如何准确接收承载信息的信号：线路编码（通信原理）</li><li>怎样避免少量错误信号对信息内容产生影响：纠错编码</li></ul></li></ul><h2 id="信道编码概念和理论">6.1 6.2 信道编码概念和理论</h2><h3 id="差错和差错控制系统分类">差错和差错控制系统分类</h3><ul><li><p><strong>差错类型</strong></p><ul><li><strong>符号差错</strong>：由符号发生差错引起，也叫信号差错，信号差错概率用符号差错概率表示。</li><li><strong>差错比特</strong>：由信息比特发生差错引起，也叫信息差错，信息差错概率用误比特率表示。</li><li>对于二进制传输系统，符号差错等效于比特差错。</li><li>对于多进制系统，一个符号差错到底对应多少比特差错难以确定，因为一个符号由多个比特组成。</li></ul></li><li><p>两种八电平线路编码方法比较</p><table><thead><tr><th>量级</th><th>自然二进码</th><th>反射二进码(格雷码)</th></tr></thead><tbody><tr><td>0</td><td>000</td><td>000</td></tr><tr><td>1</td><td>001</td><td>001</td></tr><tr><td>2</td><td>010</td><td>011</td></tr><tr><td>3</td><td>011</td><td>010</td></tr><tr><td>4</td><td>100</td><td>110</td></tr><tr><td>5</td><td>101</td><td>111</td></tr><tr><td>6</td><td>110</td><td>101</td></tr><tr><td>7</td><td>111</td><td>100</td></tr></tbody></table><ul><li>格雷码可以通过普通二进制码转换得到。</li><li>以下是生成格雷码的常见方法：<ol type="1"><li>最高位保留：格雷码的最高位（最左边） 与二进制码的最高位相同。</li><li>逐位异或：格雷码的每一位是二进制码当前位与上一位的异或结果。</li></ol></li></ul></li><li><p><strong>差错图样</strong>（error pattern）</p><ul><li><strong>定义</strong>：<ul><li><strong>差错图样 <span class="math inline"><em>E</em>=</span> 发码<span class="math inline"><em>C</em>−</span> 收码 <span class="math inline"><em>R</em></span> <span class="math inline">( mod &nbsp;<em>q</em>)</span></strong></li><li><strong>示例</strong>：8进制(<span class="math inline"><em>q</em> = 8</span>)码，若发码 <span class="math inline"><em>C</em> = (0, 2, 5, 4, 7, 5, 2)</span> ，收码变为<span class="math inline"><em>R</em> = (0, 1, 5, 4, 7, 5, 4)</span>，差错图样 <span class="math inline"><em>E</em> = <em>C</em> − <em>R</em> = (0, 1, 0, 0, 0, 0, 6)</span>（模8）。</li></ul></li><li>二进制码：<span class="math inline"><em>E</em> = <em>C</em> ⊕ <em>R</em></span> 或 <span class="math inline"><em>C</em> = <em>R</em> ⊕ <em>E</em></span>，差错图样中的“1”既是符号差错也是比特差错。</li><li><strong>汉明距离</strong>：两码字之间不同的位数叫它们之间的汉明距离，记作<span class="math inline"><em>d</em>(<em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub>)</span>，即<span class="math display">$$d(c_i,c_j) = \sum_{k=1}^{N}c_{ik}\oplusc_{jk}$$</span></li><li><strong>差错图样类型</strong><ul><li><strong>随机差错</strong>：若差错图样上各码位的取值既与前后位置无关又与时间无关，即差错始终以相等的概率独立发生于各码字、各码元、各比特</li><li><strong>突发差错</strong>：前后相关、成堆出现。突发差错总是以差错码元开头、以差错码元结尾，头尾之间并不是每个码元都错，而是码元差错概率超过了某个额定值</li></ul></li></ul></li><li><p><strong>纠错码分类</strong></p><ul><li><strong>从功能角度</strong>：检错码 、纠错码</li><li><strong>对信息序列的处理方法</strong>：分组码、卷积码</li><li><strong>码元与原始信息位的关系</strong>：线性码、非线性码</li><li><strong>差错类型</strong>：纠随机差错码、纠突发差错码、介于中间的纠随机/突发差错码</li><li><strong>构码理论</strong>：代数码、几何码、算术码、组合码等</li></ul></li><li><p><strong>差错控制系统分类</strong></p><ul><li><strong>前向纠错（FEC）</strong>：发端信息经纠错编码后传送，收端通过纠错译码自动纠正传递过程中的差错</li><li><strong>反馈重发（ARQ）</strong>：收端通过检测接收码是否符合编码规律来判断，如判定码组有错，则通过反向信道通知发端重发该码组</li><li><strong>混合纠错（HEC）</strong>：前向纠错和反馈重发的结合，发端发送的码兼有检错和纠错两种能力</li></ul></li></ul><h3 id="矢量空间与码空间">矢量空间与码空间</h3><h4 id="矢量空间">矢量空间</h4><ul><li>**矢量*<ul><li><span class="math inline"><em>F</em></span>表示码元所在的<strong>数域</strong>，对于二进制码，<span class="math inline"><em>F</em></span>代表二元域<span class="math inline">{0, 1}</span>。</li><li>设<span class="math inline"><em>n</em></span>重有序元素（<span class="math inline"><em>n</em></span>重矢量）的集合<span class="math inline"><em>V</em> = {<em>v</em><sub><em>i</em></sub>}</span><span class="math display"><em>v</em><sub><em>i</em></sub> = (<em>v</em><sub><em>i</em>0</sub>, <em>v</em><sub><em>i</em>1</sub>, ⋯, <em>v</em><sub><em>i</em><em>j</em></sub>, ⋯, <em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub>)  <em>v</em><sub><em>j</em><em>i</em></sub> ∈ <em>F</em></span></li><li>若满足条件：<ol type="1"><li><span class="math inline"><em>V</em></span>中矢量元素在<strong>矢量加运算</strong>下构成加群。</li><li><span class="math inline"><em>V</em></span>中矢量元素与数域<span class="math inline"><em>F</em></span>元素的<strong>标乘</strong>封闭在<span class="math inline"><em>V</em></span>中。</li><li>分配律、结合律成立。</li></ol>则称集合<span class="math inline"><em>V</em></span>是数域<span class="math inline"><em>F</em></span>上的一个<span class="math inline"><em>n</em></span><strong>重矢量空间</strong>，或称<span class="math inline"><em>n</em></span>重线性空间，<span class="math inline"><em>n</em></span>重矢量又称<span class="math inline"><em>n</em></span>重(<span class="math inline"><em>n</em></span>-tuples)。</li><li>码字又叫码矢、<span class="math inline"><em>n</em></span>重(矢量)。</li><li><strong>示例</strong>：<span class="math inline"><em>n</em></span>维实数域矢量空间<span class="math inline">ℝ<sup><em>n</em></sup></span>，<span class="math inline"><em>n</em></span>维复数域矢量空间<span class="math inline">ℂ<sup><em>n</em></sup></span>，<span class="math inline"><em>n</em></span>维有限域矢量空间<span class="math inline"><em>G</em><em>F</em>(<em>q</em>)<sup><em>n</em></sup></span>等。</li></ul></li><li><strong>码矢的运算法则</strong><ul><li>码矢的运算法则遵从矢量的运算法则，对于矢量<span class="math inline"><em>v</em><sub><em>i</em></sub> = (<em>v</em><sub><em>i</em>0</sub>, <em>v</em><sub><em>i</em>1</sub>, ⋯, <em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub>)</span>，<span class="math inline"><em>v</em><sub><em>j</em></sub> = (<em>v</em><sub><em>j</em>0</sub>, <em>v</em><sub><em>j</em>1</sub>, ⋯, <em>v</em><sub><em>j</em>(<em>n</em> − 1)</sub>)</span>，及标量<span class="math inline"><em>α</em> ∈ <em>F</em></span>（数域），定义：<ul><li><strong>矢量加</strong>：<span class="math inline"><em>v</em><sub><em>i</em></sub> + <em>v</em><sub><em>j</em></sub> = (<em>v</em><sub><em>i</em>0</sub> + <em>v</em><sub><em>j</em>0</sub>, <em>v</em><sub><em>i</em>1</sub> + <em>v</em><sub><em>j</em>1</sub>, ⋯, <em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub> + <em>v</em><sub><em>j</em>(<em>n</em> − 1)</sub>)</span>，所得结果仍是矢量。</li><li><strong>标乘（标量乘矢量）</strong>：<span class="math inline"><em>α</em><em>v</em><sub><em>i</em></sub> = (<em>α</em><em>v</em><sub><em>i</em>0</sub>, <em>α</em><em>v</em><sub><em>i</em>1</sub>, ⋯, <em>α</em><em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub>)</span>，所得结果是矢量。</li><li><strong>点积或内积（矢量乘矢量）</strong>：<span class="math inline"><em>v</em><sub><em>i</em></sub> ⋅ <em>v</em><sub><em>j</em></sub> = <em>v</em><sub><em>i</em>0</sub> ⋅ <em>v</em><sub><em>j</em>0</sub> + <em>v</em><sub><em>i</em>1</sub> ⋅ <em>v</em><sub><em>j</em>1</sub> + ⋯ + <em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub> ⋅ <em>v</em><sub><em>j</em>(<em>n</em> − 1)</sub></span>，所得结果是标量。</li></ul></li></ul></li><li><strong>矢量空间中各元素间的关系</strong><ul><li><strong>线性组合</strong>：若<span class="math inline"><em>v</em><sub><em>k</em></sub> = <em>a</em><sub>1</sub><em>v</em><sub>1</sub> + <em>a</em><sub>2</sub><em>v</em><sub>2</sub> + ⋯ + <em>a</em><sub><em>l</em></sub><em>v</em><sub><em>l</em></sub></span>(<span class="math inline"><em>a</em><sub><em>i</em></sub> ∈ <em>F</em></span>)，则称<span class="math inline"><em>v</em><sub><em>k</em></sub></span>是<span class="math inline"><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ⋯, <em>v</em><sub><em>l</em></sub></span>的线性组合。</li><li><strong>线性相关</strong>：若满足<span class="math inline"><em>a</em><sub>1</sub><em>v</em><sub>1</sub> + <em>a</em><sub>2</sub><em>v</em><sub>2</sub> + ⋯ + <em>a</em><sub><em>l</em></sub><em>v</em><sub><em>l</em></sub> = 0</span>，(<span class="math inline"><em>a</em><sub><em>i</em></sub> ∈ <em>F</em></span>且不全为<span class="math inline">0</span>)，则称<span class="math inline"><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ⋯, <em>v</em><sub><em>l</em></sub></span>线性相关。其中任一矢量可表示为其它矢量的线性组合。</li><li><strong>线性无关或线性独立</strong>：一组矢量中的任意一个都不可能用其它矢量的线性组合来代替。</li></ul></li><li><strong>矢量空间与基底</strong><ul><li>如果存在一组线性无关的矢量<span class="math inline"><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ⋯, <em>v</em><sub><em>k</em></sub></span>，这些矢量<strong>线性组合的集合</strong>就构成了一个<span class="math inline"><em>k</em></span><strong>维矢量空间</strong><span class="math inline"><em>V</em></span>，这组矢量就是这个矢量空间的<strong>基底</strong>。</li><li><strong>性质</strong>：<ul><li><strong><span class="math inline"><em>k</em></span>维矢量空间应包含<span class="math inline"><em>k</em></span>个基底</strong>，可以说：<span class="math inline"><em>k</em></span>个基底“张成”<span class="math inline"><em>k</em></span>维矢量空间。</li><li><strong>基底不是唯一的</strong>。<ul><li>示例：线性无关的两个矢量<span class="math inline">(1, 0)</span>和<span class="math inline">(0, 1)</span>以及<span class="math inline">(−1, 0)</span>和<span class="math inline">(0, −1)</span>都可张成同一个2维实数域空间(<span class="math inline"><em>x</em>, <em>y</em></span>) 。</li></ul></li></ul></li><li><strong>自然基底</strong>：矢量元素中包含一个<span class="math inline">1</span>而其余为<span class="math inline">0</span>的那组基底</li></ul></li><li><strong>子空间</strong><ul><li>若矢量空间<span class="math inline"><em>V</em></span>的一个子集<span class="math inline"><em>V</em><sub><em>s</em></sub></span>也能构成一个矢量空间，则称<span class="math inline"><em>V</em><sub><em>s</em></sub></span>是<span class="math inline"><em>V</em></span>的子空间 。</li><li><strong>示例</strong>：<ul><li>二元域<span class="math inline"><em>G</em><em>F</em>(2)</span>上三维三重矢量空间<span class="math inline"><em>V</em></span>的三个自然基底是<span class="math inline">(100)</span>，<span class="math inline">(010)</span>，<span class="math inline">(001)</span> 。</li><li>以<span class="math inline">(100)</span>为基底可张成一维三重子空间<span class="math inline"><em>V</em><sub><em>s</em>1</sub></span>，含<span class="math inline">2<sup>1</sup> = 2</span>个元素，即 <span class="math inline"><em>V</em><sub><em>s</em>1</sub> = {(000), (100)}</span>。</li><li>以<span class="math inline">(010), (001)</span>为基底可张成二维三重子空间<span class="math inline"><em>V</em><sub><em>s</em>2</sub></span>，含<span class="math inline">2<sup>2</sup> = 4</span>个元素，即 <span class="math inline"><em>V</em><sub><em>s</em>2</sub> = {(000), (001), (010), (011)}</span>。</li><li><span class="math inline"><em>V</em><sub><em>s</em>1</sub></span>和<span class="math inline"><em>V</em><sub><em>s</em>2</sub></span>都是<span class="math inline"><em>V</em></span>的子空间。</li></ul></li></ul></li><li><strong>矢量空间构成</strong><ul><li>每个矢量空间或子空间中必然包含<strong>零矢量</strong>。</li><li><strong>构成矢量的有序元素的个数称为“重”数，张成矢量空间的基底的个数称为“维”数</strong>。</li><li>一般情况下，由<span class="math inline"><em>n</em></span>个<span class="math inline"><em>n</em></span>重的基底张成<span class="math inline"><em>n</em></span>维矢量空间<span class="math inline"><em>V</em><sub><em>n</em></sub></span>，维数和重数一致。</li><li>子空间的引入使维数和重数可以不一样。</li><li><strong>维数不可能大于重数</strong>，而当维数小于重数时就说明这是一个子空间。</li></ul></li><li><strong>正交与对偶空间</strong><ul><li>若两个矢量点积为<span class="math inline">0</span>，即<span class="math inline"><em>v</em><sub>1</sub> ⋅ <em>v</em><sub>2</sub> = 0</span>，则称<span class="math inline"><em>v</em><sub>1</sub></span>和<span class="math inline"><em>v</em><sub>2</sub></span><strong>矢量正交</strong>。</li><li>若某矢量空间中的任意元素与另一矢量空间中的任意元素正交，则称这两个<strong>矢量空间正交</strong>。<ul><li>若两个矢量空间的基底正交，则这两个矢量空间一定正交。</li></ul></li><li>正交的两个子空间<span class="math inline"><em>V</em><sub>1</sub></span>、<span class="math inline"><em>V</em><sub>2</sub></span>互为<strong>对偶空间</strong>（DualSpace），其中一个空间是另一个空间的<strong>零空间</strong>（nullspace，也称零化空间）。</li></ul></li></ul><h4 id="码空间">码空间</h4><ul><li><strong>码空间</strong><ul><li><img src="image-59.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><ol type="1"><li>码字<span class="math inline"><em>c</em><sub><em>i</em></sub></span>是<span class="math inline"><em>n</em></span>个码元的有序排列，是<span class="math inline"><em>n</em></span>维<span class="math inline"><em>n</em></span>重矢量空间<span class="math inline"><em>V</em><sub><em>n</em></sub></span>的元素之一。</li><li>然而，矢量空间<span class="math inline"><em>V</em><sub><em>n</em></sub></span>的元素不一定是码字。</li><li>将码字<span class="math inline"><em>c</em><sub><em>i</em></sub></span>写作<span class="math inline">(<em>c</em><sub><em>i</em>0</sub>, <em>c</em><sub><em>i</em>1</sub>, ⋯, <em>c</em><sub><em>i</em>(<em>n</em> − 1)</sub>)</span>，将码字的集合写成<span class="math inline"><em>C</em></span>，称为码集。</li><li>码集不一定能构成<span class="math inline"><em>V</em><sub><em>n</em></sub></span>的一个子空间，但对线性分组码而言，码集<span class="math inline"><em>C</em></span>一定是<span class="math inline"><em>V</em><sub><em>n</em></sub></span>的一个子空间。</li></ol></li><li><strong>分组编码的任务</strong><ul><li>通常<span class="math inline"><em>q</em><sup><em>n</em></sup> &gt;  &gt; <em>q</em><sup><em>k</em></sup></span>，分组编码的任务是要在<span class="math inline"><em>n</em></span>维<span class="math inline"><em>n</em></span>重矢量空间的<span class="math inline"><em>q</em><sup><em>n</em></sup></span>种可能组合中选择其中的<span class="math inline"><em>q</em><sup><em>k</em></sup></span>个构成一个码空间，其元素就是许用码的码集。</li><li>因此分组编码的任务就是：<ol type="1"><li>选择一个<span class="math inline"><em>k</em></span>维<span class="math inline"><em>n</em></span>重子空间作为码空间。</li><li>确定由<span class="math inline"><em>k</em></span>维<span class="math inline"><em>k</em></span>重信息空间到<span class="math inline"><em>k</em></span>维<span class="math inline"><em>n</em></span>重码空间的映射方法。</li></ol></li><li>码空间的不同选择方法，以及信息组与码组的不同映射算法，就构成了不同的分组码。</li></ul></li></ul><h3 id="译码方法">译码方法</h3><ul><li><p><strong>译码的任务</strong></p><ul><li>译码器的任务是从受损的信息序列中尽可能正确地恢复出原信息。</li><li>译码算法的已知条件是：<ul><li>实际接收到的码字序列<span class="math inline">{<em>r</em>}</span>，<span class="math inline"><em>r</em> = (<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, ⋯, <em>r</em><sub><em>N</em></sub>)</span>。</li><li>发端所采用的编码算法和该算法产生的码集<span class="math inline"><em>X</em><sup><em>N</em></sup></span>，满足<span class="math inline"><em>c</em><sub><em>i</em></sub> = (<em>c</em><sub><em>i</em>1</sub>, <em>c</em><sub><em>i</em>2</sub>, ⋯, <em>c</em><sub><em>i</em><em>N</em></sub>) ∈ <em>X</em><sup><em>N</em></sup></span>。</li><li>信道模型及信道参数。</li></ul></li></ul></li><li><p><strong>信道模型</strong>：<img src="image-60.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"></p></li><li><p><strong>译码规则</strong>：见<a href="./Ch6sup_信道编码定理.md/#译码规则">译码规则</a></p></li><li><p><strong><a href="./Ch6sup_信道编码定理.md/#最大后验概率译码">最大后验概率译码</a></strong></p><ul><li><strong>最佳译码</strong>，也叫<strong>最大后验概率译码(MAP)</strong>：<span class="math display"><em>ĉ</em><sub><em>i</em></sub> = arg max<sub>1 ≤ <em>i</em> ≤ <em>M</em></sub><em>P</em>(<em>c</em><sub><em>i</em></sub>|<em>r</em>)</span></li></ul></li><li><p><strong><a href="./Ch6sup_信道编码定理.md/#最大联合概率译码">最大联合概率译码</a></strong><span class="math display">$$P(c_i/r)=\frac{P(c_i)P(r/c_i)}{P(r)}\quad i= 1, 2, \cdots, 2^K$$</span></p><ul><li><span class="math inline"><em>P</em>(<em>c</em><sub><em>i</em></sub>/<em>r</em>)</span>最大等效于<span class="math inline"><em>P</em>(<em>c</em><sub><em>i</em></sub>)<em>P</em>(<em>r</em>/<em>c</em><sub><em>i</em></sub>)</span>最大。</li><li><strong>最大联合概率译码</strong>：<span class="math display"><em>ĉ</em><sub><em>i</em></sub> = arg max<sub>1 ≤ <em>i</em> ≤ <em>M</em></sub><em>P</em>(<em>c</em><sub><em>i</em></sub>)<em>P</em>(<em>r</em>|<em>c</em><sub><em>i</em></sub>)</span></li></ul></li><li><p><strong><a href="./Ch6sup_信道编码定理.md/#最大似然译码">最大似然译码</a></strong></p><ul><li>如果 构成码集的<span class="math inline">2<sup><em>K</em></sup></span>个码字以相同概率发送，满足<span class="math inline"><em>P</em>(<em>c</em><sub><em>i</em></sub>) = 1/2<sup><em>K</em></sup></span>，<span class="math inline"><em>i</em> = 1, 2, ⋯, 2<sup><em>K</em></sup></span>，在此前提下最佳译码等效于如下最大似然译码。</li><li><strong>最大似然译码</strong>(MLD)：码字等概率发送时：<span class="math display"><em>ĉ</em><sub><em>i</em></sub> = arg max<sub>1 ≤ <em>i</em> ≤ <em>M</em></sub><em>P</em>(<em>r</em>|<em>c</em><sub><em>i</em></sub>)</span></li></ul></li><li><p><strong><a href="./Ch6sup_信道编码定理.md/#最小汉明距离译码">最小汉明距离译码</a></strong></p><ul><li><p>对于无记忆信道：<span class="math display">$$\max P(r/c_i)=\max\prod_{j = 1}^{N}P(r_j/c_{ij})$$</span></p></li><li><p>对BSC信道： <span class="math display">$$P(r_j|c_{ij}) =  \begin{cases}  p, &amp; c_{ij} \neq r_j \\  1 - p, &amp; c_{ij} = r_j  \end{cases}$$</span></p><p><span class="math display">$$P(r|c_i)=\prod_{j = 1}^{N}P(r_j|c_{ij})= p^d(1 - p)^{N - d}=(\frac{p}{1 - p})^d(1 - p)^N$$</span> 其中<span class="math inline"><em>d</em></span>为<span class="math inline"><em>r</em></span>与<span class="math inline"><em>c</em><sub><em>i</em></sub></span>的汉明距离，可见，<strong><span class="math inline"><em>d</em></span>越小，<span class="math inline"><em>P</em>(<em>r</em>|<em>c</em><sub><em>i</em></sub>)</span>越大</strong>。</p></li><li><p>BSC信道的最大似然译码可以简化为最小汉明距离译码。 <span class="math display"><em>ĉ</em><sub><em>i</em></sub> = arg min<sub>1 ≤ <em>i</em> ≤ <em>M</em></sub><em>d</em>(<em>r</em>, <em>c</em><sub><em>i</em></sub>)</span></p><ul><li>只要在接收端将收码<span class="math inline"><em>r</em></span>与发码<span class="math inline"><em>c</em><sub><em>i</em></sub></span>的各码元逐一比较，选择其中汉明距离最小的码字作为译码估值<span class="math inline"><em>ĉ</em><sub><em>i</em></sub></span>。</li><li>由于BSC信道是对称的，只要发送的码字独立、等概，汉明距离译码也就是最佳译码。</li></ul></li></ul></li></ul><h3 id="信道编码定理">信道编码定理</h3><ul><li>信道编码定理研究的问题：<img src="image-61.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="随机编码">随机编码</h4><ul><li>所有可能的编码：平均错误概率<span class="math inline">$\overline{P}_e$</span><ul><li>若<span class="math inline">$\overline{P}_e \to0$</span>，必存在一种编码<span class="math inline"><em>P</em><sub><em>e</em></sub> → 0</span> 。</li><li>用这种方法不能得知最优码是如何具体编出来的；却能得知最优码可以好到什么程度，并进而推导出有扰离散信道的编码定理，对指导编码技术具有特别重要的理论价值。</li></ul></li><li>在<span class="math inline">(<em>N</em>, <em>K</em>)</span>分组编码器中随机选定的码集有<span class="math inline"><em>q</em><sup><em>N</em><em>M</em></sup></span>种。第<span class="math inline"><em>m</em></span>个码集(记作<span class="math inline">{<em>c</em>}<sub><em>m</em></sub></span>)被随机选中的概率是<span class="math display"><em>P</em>({<em>c</em>}<sub><em>m</em></sub>) = <em>q</em><sup>−(<em>N</em><em>M</em>)</sup></span><ul><li>设与这种选择相对应的条件差错概率是<span class="math inline"><em>P</em><sub><em>e</em></sub>({<em>c</em>}<sub><em>m</em></sub>)</span>。</li><li>全部码集的平均差错概率是<span class="math display">$$\overline{P}_e= \sum_{m = 1}^{q^{NM}} P(\{c\}_m)P_e(\{c\}_m)=q^{-NM}\sum_{m =1}^{q^{NM}} P_e(\{c\}_m)$$</span></li><li>必定存在某些码集<span class="math inline">$P_e(\{c\}_m)&gt;\overline{P}_e$</span>，某些码集<span class="math inline">$P_e(\{c\}_m)&lt;\overline{P}_e$</span> 。</li><li>若<span class="math inline">$\overline{P}_e \to0$</span>，就必然存在一批码集<span class="math inline"><em>P</em><sub><em>e</em></sub>({<em>c</em>}<sub><em>m</em></sub>) → 0</span>，即差错概率趋于零的好码一定存在。</li></ul></li><li>码集点数<span class="math inline"><em>M</em> = <em>q</em><sup><em>K</em></sup></span>占<span class="math inline"><em>N</em></span>维矢量空间总点数<span class="math inline"><em>q</em><sup><em>N</em></sup></span>的比例是<span class="math inline"><em>F</em> = <em>q</em><sup><em>K</em></sup>/<em>q</em><sup><em>N</em></sup> = <em>q</em><sup>−(<em>N</em> − <em>K</em>)</sup></span><ul><li>当<span class="math inline"><em>K</em></span>和<span class="math inline"><em>N</em></span>的差值拉大即冗余的空间点数增加时，平均而言码字的分布将变得稀疏，码字间的平均距离将变大，平均差错概率将变小。</li><li>当<span class="math inline"><em>F</em> → 0</span>即<span class="math inline">(<em>N</em> − <em>K</em>) → ∞</span>时，能否让平均差错概率<span class="math inline">$\overline{P}_e \to 0$</span> ？<ul><li>Gallager在1965年推导了<span class="math inline">$\overline{P}_e$</span>的上边界，并证明这个上边界是按指数规律收敛的。</li></ul></li></ul></li></ul><h4 id="信道编码定理-1">信道编码定理</h4><ul><li><span class="math inline">$\overline{P}_e &lt; e^{-NE(R)}$</span><ul><li><span class="math inline"><em>E</em>(<em>R</em>)</span>为可靠性函数，也叫误差指数。</li><li><strong>码率</strong>：<span class="math inline">$R = \frac{\logM}{N}=\frac{\log q^K}{N}$</span> 。</li><li><span class="math inline"><em>M</em></span>是可能的信息组合数，<span class="math inline"><em>M</em> = <em>q</em><sup><em>K</em></sup></span>；<span class="math inline"><em>N</em></span>是每码字的码元数；<span class="math inline"><em>R</em></span>表示每码元携带的信息量（bit/码元）。</li></ul></li><li><span class="math inline"><em>E</em>(<em>R</em>)</span>可靠性函数<ul><li><span class="math inline"><em>R</em></span>在<span class="math inline">[0, <em>R</em><sub>0</sub>]</span>区间时，<span class="math inline"><em>E</em>(<em>R</em>) − <em>R</em></span>曲线是斜率为<span class="math inline">−1</span>（<span class="math inline">−45<sup>∘</sup></span>）的直线，<span class="math inline"><em>E</em>(<em>R</em>)</span>反比于<span class="math inline"><em>R</em></span></li><li><span class="math inline"><em>R</em><sub>0</sub> &lt; <em>C</em></span>，临界速率</li><li>而当<span class="math inline"><em>R</em> = <em>C</em></span>时<span class="math inline"><em>E</em>(<em>R</em>) = 0</span>即可靠性为零。</li><li><img src="image-62.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>噪声信道的信道编码定理</strong><ul><li><strong><a href="./Ch6sup_信道编码定理.md#信道编码正定理">正定理</a></strong>：只要传输率<span class="math inline"><em>R</em></span> 小于信道容量 <span class="math inline"><em>C</em></span>，总存在一种信道码（及解码器），在码长 <span class="math inline"><em>N</em></span>足够长的情况下，能够以所要求的任意小的差错概率实现可靠的通信。</li><li><strong><a href="./Ch6sup_信道编码定理.md#信道编码逆定理">逆定理</a></strong>：信道容量<span class="math inline"><em>C</em></span> 是可靠通信系统传输率 <span class="math inline"><em>R</em></span> 的上边界，如果 <span class="math inline"><em>R</em> &gt; <em>C</em></span>，就不可能有任何一种编码能使差错概率任意小。</li></ul></li></ul><h4 id="联合信源信道编码定理">联合信源信道编码定理</h4><ul><li><strong>两步编码处理方法</strong>：<ul><li><strong>信源编码</strong>：针对各自信源的不同特点，进行不同的数据压缩，用最有效的二元码来表达这些不同的信源。</li><li><strong>信道编码</strong>：对于共同传输的数字信道而言，输入端只看成是一系列二元码。信道编码只针对信道特性来进行，不考虑不同信源的不同特性。</li><li>信源压缩编码只考虑信源的统计特性；信道编码只考虑信道的统计特性。</li></ul></li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：设计简单、通用性好，可以分别形成标准。</li><li><strong>缺点</strong>：没有充分利用各自的优势，因而不是最佳的。</li></ul></li><li><strong>信源－信道编码定理内容</strong>：<ul><li>若信源 <span class="math inline"><em>S</em></span> 极限熵 <span class="math inline"><em>H</em><sub>∞</sub></span> 小于信道容量 <span class="math inline"><em>C</em></span> ，则存在信源信道编码，使得 <span class="math inline"><em>P</em><sub><em>e</em></sub> → 0</span></li><li>反之，对于任意平稳随机序列，若极限熵 <span class="math inline"><em>H</em><sub>∞</sub> &gt; <em>C</em></span>，则错误概率远离零，即不可能在信道中以任意小的错误概率发送这随机序列</li></ul></li><li><strong>总结</strong>：<ul><li>当且仅当信源极限熵小于信道容量，在信道上能够无错误地传输平稳遍历信源。<strong><span class="math inline"><em>H</em> &lt; <em>C</em></span>是信源通过信道有效和可靠传输的充要条件</strong>。</li><li>如果信道的容量 <span class="math inline"><em>C</em> &gt; <em>R</em>(<em>D</em>)</span>，则在信源和信道处用足够复杂的处理后，总能以失真度 <span class="math inline"><em>D</em> + <em>ε</em></span> 再现信源的消息。</li></ul></li></ul><h3 id="纠错编码的基本思路">纠错编码的基本思路</h3><ul><li><strong>思路一</strong>：<span class="math display">$$\overline{P}_e&lt; e^{-NE(R)}$$</span><ul><li><img src="image-63.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong><span class="math inline"><em>R</em></span>不变</strong>，信道容量大者其可靠性函数<span class="math inline"><em>E</em>(<em>R</em>)</span>也大<ul><li><strong>增大信道容量<span class="math inline"><em>C</em></span>的方法</strong>：<ul><li>扩展带宽。</li><li>加大功率。</li><li>降低噪声。</li></ul></li></ul></li><li><strong><span class="math inline"><em>C</em></span>不变</strong>，码率减小时其可靠性函数<span class="math inline"><em>E</em>(<em>R</em>)</span>增大<ul><li><strong>减小码率<span class="math inline"><em>R</em></span>的方法</strong>：<ul><li><span class="math inline"><em>Q</em></span>、<span class="math inline"><em>N</em></span>不变而减小<span class="math inline"><em>K</em></span>。</li><li><span class="math inline"><em>Q</em></span>、<span class="math inline"><em>K</em></span>不变而增大<span class="math inline"><em>N</em></span>。</li><li><span class="math inline"><em>N</em></span>、<span class="math inline"><em>K</em></span>不变而减小<span class="math inline"><em>Q</em></span>。</li></ul></li></ul></li><li><strong>增大码长<span class="math inline"><em>N</em></span></strong></li></ul></li><li><strong>思路二：纠错能力的获取途径</strong>：<ul><li><strong>利用冗余度</strong>：时间、频带、功率、设备复杂度。</li><li><strong>噪声均化(随机化、概率化)</strong>：增加码长、卷积、交错。</li></ul></li></ul><h2 id="线性分组码">6.3 线性分组码</h2><p><img src="image-64.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>构造一个<span class="math inline"><em>k</em></span>维<span class="math inline"><em>n</em></span>重子空间（码空间），使<span class="math inline"><em>q</em><sup><em>k</em></sup></span>个信息元组一一对应映射到码空间。</li><li><strong>码率(编码效率)</strong>：<span class="math inline"><em>R</em><sub><em>c</em></sub> = <em>k</em>/<em>n</em></span></li></ul><h3 id="线性分组码的形成">线性分组码的形成</h3><h4 id="基本概念">基本概念</h4><ul><li><strong>码空间</strong><ul><li><strong>码空间</strong>：所有元素（即码字）都可以写成<span class="math inline"><em>k</em></span>个基底的线性组合，表达式为<span class="math display"><strong>c</strong> = <em>m</em><sub><em>k</em> − 1</sub><strong>g</strong><sub><em>k</em> − 1</sub> + ⋯ + <em>m</em><sub>1</sub><strong>g</strong><sub>1</sub> + <em>m</em><sub>0</sub><strong>g</strong><sub>0</sub></span></li><li><span class="math inline"><strong>m</strong> = (<em>m</em><sub><em>k</em> − 1</sub>, ⋯, <em>m</em><sub>1</sub>, <em>m</em><sub>0</sub>)</span>是<span class="math inline"><em>k</em></span>维<span class="math inline"><em>k</em></span>重信息组</li><li><span class="math inline"><strong>c</strong> = (<em>c</em><sub><em>n</em> − 1</sub>, ⋯, <em>c</em><sub>1</sub>, <em>c</em><sub>0</sub>)</span>是码字。</li><li><span class="math inline"><strong>g</strong> = (<strong>g</strong><sub><em>k</em> − 1</sub>, ⋯, <strong>g</strong><sub>1</sub>, <strong>g</strong><sub>0</sub>)</span>是在<span class="math inline"><em>n</em></span>维<span class="math inline"><em>n</em></span>重空间<span class="math inline"><em>V</em></span>中，从<span class="math inline"><em>n</em></span>个基底中选取出来的<span class="math inline"><em>k</em></span>个矢量作为码空间的<strong>基底</strong></li><li><img src="image-65.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>映射规律</strong>：信息元作为基底线性组合的系数。</li><li><strong>生成矩阵</strong>：<ul><li><strong>生成矩阵</strong><span class="math inline">$\mathbf{G}_{k\times n}=\begin{bmatrix}\mathbf{g}_{k-1}\\\vdots\\\mathbf{g}_{1}\\\mathbf{g}_{0}\end{bmatrix}=\begin{bmatrix}g_{(k- 1)(n - 1)}&amp;\cdots&amp;g_{(k - 1)1}&amp;g_{(k -1)0}\\\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\g_{1(n -1)}&amp;\cdots&amp;g_{11}&amp;g_{10}\\g_{0(n -1)}&amp;\cdots&amp;g_{01}&amp;g_{00}\end{bmatrix}$</span></li><li>码字<span class="math inline"><strong>c</strong></span>、消息<span class="math inline"><strong>m</strong></span>与生成矩阵<span class="math inline"><strong>G</strong></span>的关系为：<span class="math display"><strong>c</strong><sub><strong>1</strong> <strong>×</strong> <strong>n</strong></sub> = <strong>m</strong><sub><strong>1</strong> <strong>×</strong> <strong>k</strong></sub><strong>G</strong><sub><strong>k</strong> <strong>×</strong> <strong>n</strong></sub></span><ul><li>其中<span class="math inline"><strong>c</strong><sub><strong>1</strong> <strong>×</strong> <strong>n</strong></sub></span>是<span class="math inline"><em>n</em></span>维码字，<span class="math inline"><strong>m</strong><sub><strong>1</strong> <strong>×</strong> <strong>k</strong></sub></span>是<span class="math inline"><em>k</em></span>维信息组，<span class="math inline"><strong>G</strong><sub><strong>k</strong> <strong>×</strong> <strong>n</strong></sub></span>是<span class="math inline"><em>k</em> × <em>n</em></span>生成矩阵。</li><li>因为<span class="math inline"><em>k</em></span>个基底即<span class="math inline"><strong>G</strong></span>的<span class="math inline"><em>k</em></span>个行矢量线性无关，矩阵<span class="math inline"><strong>G</strong></span>的秩一定等于<span class="math inline"><em>k</em></span>。</li><li>当信息元确定后，码字仅由<span class="math inline"><strong>G</strong></span>矩阵决定，所以称这<span class="math inline"><em>k</em> × <em>n</em></span>矩阵<span class="math inline"><strong>G</strong></span>为该<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码的生成矩阵。</li></ul></li><li><strong>特点</strong>:<ul><li>想要保证<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码能够构成<span class="math inline"><em>k</em></span>维<span class="math inline"><em>n</em></span>重子空间，<span class="math inline"><em>G</em></span>的<span class="math inline"><em>k</em></span>个行矢量<span class="math inline"><em>g</em><sub><em>k</em> − 1</sub>, ⋯, <em>g</em><sub>1</sub>, <em>g</em><sub>0</sub></span>必须是线性无关的，只有这样才符合作为基底的条件。</li><li>由于基底不是唯一的，所以<span class="math inline"><em>G</em></span>也就不是唯一的。</li><li>不同的基底有可能生成同一码集，但因编码涉及码集和映射两个因素，码集一样而映射方法不同也不能说是同样的码。</li></ul></li></ul></li><li><strong>基底的选择</strong>：构造<span class="math inline">(3, 2)</span>线性分组码示例<ul><li><img src="image-66.webp" srcset="/img/loading/loading3.gif" lazyload></li><li>需要构造<span class="math inline">2</span>维<span class="math inline">3</span>重码空间。</li><li><span class="math inline">3</span>维<span class="math inline">3</span>重空间的<span class="math inline">3</span>个自然基底为<span class="math inline">100</span>，<span class="math inline">010</span>，<span class="math inline">001</span>。</li><li>选择其中<span class="math inline">2</span>个基底<span class="math inline">010</span>，<span class="math inline">001</span>构成码空间，对应码集为<span class="math inline">(000, 010, 001, 011)</span></li><li><span class="math inline">2</span>个基底的线性组合<span class="math inline">010</span>，<span class="math inline">011</span>也可以张成码空间 ，对应码集为<span class="math inline">(000, 010, 011, 001)</span> 。</li><li>码集一样，对应关系不一样</li></ul></li><li><strong>示例</strong>：<ul><li>对于<span class="math inline">(6, 3)</span>线性分组码，<span class="math inline"><em>k</em> = 3</span>，<span class="math inline">2<sup><em>k</em></sup> = 8</span>（消息数量）<ul><li>基底<span class="math inline"><strong>g</strong><sub>2</sub> = 111010</span>，<span class="math inline"><strong>g</strong><sub>1</sub> = 110001</span>，<span class="math inline"><strong>g</strong><sub>0</sub> = 011101</span>。</li><li>则<span class="math inline">$\mathbf{G}=\begin{bmatrix}\mathbf{g}_{2}\\\mathbf{g}_{1}\\\mathbf{g}_{0}\end{bmatrix}=\begin{bmatrix}111010\\110001\\011101\end{bmatrix}$</span>。 $$</li><li><table><thead><tr><th>信息<span class="math inline"><strong>u</strong> = <em>m</em><sub>2</sub><em>m</em><sub>1</sub><em>m</em><sub>0</sub></span></th><th>码字<span class="math inline"><strong>c</strong> = <em>c</em><sub>5</sub><em>c</em><sub>4</sub><em>c</em><sub>3</sub><em>c</em><sub>2</sub><em>c</em><sub>1</sub><em>c</em><sub>0</sub></span></th></tr></thead><tbody><tr><td>000</td><td>000000</td></tr><tr><td>001</td><td>011101</td></tr><tr><td>010</td><td>110001</td></tr><tr><td>011</td><td>101100</td></tr><tr><td>100</td><td>111010</td></tr><tr><td>101</td><td>100111</td></tr><tr><td>110</td><td>001011</td></tr><tr><td>111</td><td>010110</td></tr></tbody></table></li></ul></li></ul></li></ul><h4 id="系统形式的生成矩阵与校验矩阵">系统形式的生成矩阵与校验矩阵</h4><ul><li><strong>系统形式的生成矩阵</strong><ul><li><p><span class="math inline">(<em>n</em>, <em>k</em>)</span>码的任何生成矩阵都可以通过行运算（以及列置换）简化成“系统形式”<span class="math display">$$\mathbf{G_S} = [I_k |P]=\begin{bmatrix}1&amp;0&amp;\cdots&amp;0&amp;p_{(k - 1)(n - k -1)}&amp;\cdots&amp;p_{(k - 1)1}&amp;p_{(k -1)0}\\0&amp;1&amp;\vdots&amp;0&amp;p_{(k - 2)(n - k -1)}&amp;\cdots&amp;p_{(k - 2)1}&amp;p_{(k -2)0}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;1&amp;p_{0(n- k - 1)}&amp;\cdots&amp;p_{01}&amp;p_{00}\end{bmatrix}$$</span></p><p>其中<span class="math inline"><em>I</em><sub><em>k</em></sub></span>是<span class="math inline"><em>k</em> × <em>k</em></span>单位矩阵，<span class="math inline"><em>P</em></span>是<span class="math inline"><em>k</em> × (<em>n</em> − <em>k</em>)</span>矩阵。</p></li></ul></li><li><strong>系统码</strong><ul><li><strong>码字结构</strong>：码字<span class="math inline"><em>c</em></span>包含信息位（<span class="math inline"><em>k</em></span>位）和校验位（<span class="math inline"><em>n</em> − <em>k</em></span>位）<img src="image-67.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>特点</strong>：<ul><li>前<span class="math inline"><em>k</em></span>位由单位矩阵<span class="math inline"><em>I</em><sub><em>k</em></sub></span>决定，等于把信息组<span class="math inline"><em>m</em></span>原封不动搬到码字的前<span class="math inline"><em>k</em></span>位</li><li>其余的<span class="math inline"><em>n</em> − <em>k</em></span>位叫<strong>冗余位</strong>或<strong>一致校验位</strong>，是前<span class="math inline"><em>k</em></span>个信息位的线性组合。</li></ul></li><li><strong>定义</strong>：具备以上系统形式的<span class="math inline">(<em>n</em>, <em>k</em>)</span>码叫做<strong>系统码</strong>。若生成矩阵<span class="math inline"><em>G</em></span>不具备系统形式，则生成的码叫做非系统码。</li><li>系统化不改变码集，只是改变了映射规则。</li><li><strong>性质</strong>：<ul><li><strong>等效矩阵</strong>：若通过行运算和列置换能将两个生成矩阵<span class="math inline"><em>G</em></span>互等，则称这两个<span class="math inline"><em>G</em></span>等效。</li><li><strong>形式转换</strong>：非系统码的<span class="math inline"><em>G</em></span>可通过运算转变为系统码的<span class="math inline"><em>G</em></span>。</li><li><strong>等效码</strong>：等效的两个<span class="math inline"><em>G</em></span>生成的两个<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码也是等效的。</li><li>因此，<strong>每个<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码都可以和一个系统的<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码等效</strong></li></ul></li></ul></li><li><strong>线性分组码空间构成</strong><ul><li><span class="math inline"><em>n</em></span>维<span class="math inline"><em>n</em></span>重空间<span class="math inline"><em>V</em><sub><em>n</em></sub></span>有相互正交的<span class="math inline"><em>n</em></span>个基底。</li><li>选择<span class="math inline"><em>k</em></span>个基底构成码空间<span class="math inline"><em>G</em></span> 。</li><li>选择另外的<span class="math inline">(<em>n</em> − <em>k</em>)</span>个基底构成空间<span class="math inline"><em>H</em></span> 。</li><li><span class="math inline"><em>G</em></span>和<span class="math inline"><em>H</em></span>是对偶的，满足<span class="math inline"><em>G</em><em>H</em><sup><em>T</em></sup> = 0</span>，<span class="math inline"><em>H</em><em>G</em><sup><em>T</em></sup> = 0</span>。</li><li><img src="image-70.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>码空间与对偶空间</strong><ul><li>将<span class="math inline"><em>H</em></span>空间的<span class="math inline"><em>n</em> − <em>k</em></span>个基底排列起来可构成一个<span class="math inline">(<em>n</em> − <em>k</em>) × <em>n</em></span>矩阵，称为<strong>校验矩阵<span class="math inline"><em>H</em></span></strong>，用于校验接收到的码字是否正确。</li><li><span class="math inline"><em>G</em></span>是<span class="math inline">(<em>n</em>, <em>k</em>)</span>码的生成矩阵，<span class="math inline"><em>H</em></span>是其校验矩阵。</li><li><span class="math inline"><em>H</em></span>是<span class="math inline">(<em>n</em>, <em>n</em> − <em>k</em>)</span>对偶码的生成矩阵，它的每一行是一个基底，<span class="math inline"><em>G</em></span>则是其校验矩阵。</li><li>满足<span class="math inline"><em>G</em><em>H</em><sup><em>T</em></sup> = 0</span>，且<span class="math inline"><em>H</em> = [−<em>P</em><sup><em>T</em></sup>|<em>I</em><sub><em>n</em> − <em>k</em></sub>]</span>，在二进制情况下，负号可省略。</li></ul></li><li><strong>生成矩阵与校验矩阵的关系</strong><ul><li>对于任何一个码字<span class="math inline"><strong>c</strong></span>，有<span class="math display"><strong>c</strong><sub>1 × <em>n</em></sub><strong>H</strong><sub><em>n</em> × (<em>n</em> − <em>k</em>)</sub><sup><em>T</em></sup> = <strong>0</strong><sub>1 × (<em>n</em> − <em>k</em>)</sub></span></li><li>因为生成矩阵的每个行矢量是一个码字，所以必有<span class="math display"><strong>G</strong><sub><em>k</em> × <em>n</em></sub><strong>H</strong><sup><strong>T</strong></sup><sub><em>n</em> × (<em>n</em> − <em>k</em>)</sub> = <strong>0</strong><sub><em>k</em> × (<em>n</em> − <em>k</em>)</sub></span></li><li>对于系统码的生成矩阵<span class="math inline"><strong>G</strong><sub><strong>S</strong></sub><sub><em>k</em> × <em>n</em></sub> = [<strong>I</strong><sub><em>k</em></sub>|<strong>P</strong><sub><em>k</em> × (<em>n</em> − <em>k</em>)</sub>]</span>，有：<span class="math display">$$  \begin{align*}  \mathbf{G_S}_{k\times n}[-\mathbf{P}_{(n - k)\times k}^T |\mathbf{I}_{n - k}]^T&amp;=[\mathbf{I}_k | \mathbf{P}_{k\times(n -k)}][-\mathbf{P}_{(n - k)\times k}^T | \mathbf{I}_{n - k}]^T\\  &amp;=[-\mathbf{I}_k\mathbf{P}_{k\times(n -k)}]+[\mathbf{P}_{k\times(n - k)}\mathbf{I}_{n - k}]\\  &amp;=[-\mathbf{P}]+[\mathbf{P}]\\  &amp;=\mathbf{0}_{k\times(n - k)}  \end{align*}  $$</span></li><li>由此可得<span class="math inline"><strong>H</strong> = [−<strong>P</strong><sup><em>T</em></sup>|<strong>I</strong><sub><em>n</em> − <em>k</em></sub>] = [<strong>P</strong><sup><em>T</em></sup>|<strong>I</strong><sub><em>n</em> − <em>k</em></sub>]</span>，二进制码省略负号</li></ul></li><li><strong>示例</strong>：<ul><li>同上例：<span class="math inline">$G =\begin{bmatrix}111010&amp;①\\110001&amp;②\\011101&amp;③\end{bmatrix}\RightarrowG_s = \begin{bmatrix}100111&amp;① + ③\\010110&amp;① + ②+ ③\\001011&amp;①+ ②\end{bmatrix}$</span></li><li><table><thead><tr><th>信息</th><th>码字</th><th>系统码字</th></tr></thead><tbody><tr><td>000</td><td>000000</td><td><strong>000000</strong></td></tr><tr><td>001</td><td>011101</td><td><strong>001011</strong></td></tr><tr><td>010</td><td>110001</td><td><strong>010110</strong></td></tr><tr><td>011</td><td>101100</td><td><strong>011101</strong></td></tr><tr><td>100</td><td>111010</td><td><strong>100111</strong></td></tr><tr><td>101</td><td>100111</td><td><strong>101100</strong></td></tr><tr><td>110</td><td>001011</td><td><strong>110001</strong></td></tr><tr><td>111</td><td>010110</td><td><strong>111010</strong></td></tr></tbody></table></li><li><strong>一致校验位</strong> <img src="image-68.webp" srcset="/img/loading/loading3.gif" lazyload><ul><li><p><span class="math display">$$\mathbf{c} =(c_5c_4c_3c_2c_1c_0)=(m_2m_1m_0)G_S=(m_2m_1m_0)\begin{bmatrix}100111\\010110\\001011\end{bmatrix}$$</span></p><p>可得： <span class="math display">$$  \begin{cases}  c_5 = m_2\\  c_4 = m_1\\  c_3 = m_0  \end{cases}  $$</span> 因此，校验位可按下面方程组计算：</p><p><span class="math display">$$  \begin{cases}  c_2 = m_2 + m_1 = c_5 + c_4\\  c_1 = m_2 + m_1 + m_0 = c_5 + c_4 + c_3\\  c_0 = m_2 + m_0 = c_5 + c_3  \end{cases}  $$</span></p><p>由于校验位和信息元之间是线性运算关系，所以叫<strong>线性分组码</strong>。</p></li><li><p>编码器<img src="image-69.webp" srcset="/img/loading/loading3.gif" lazyload></p></li></ul></li><li><strong>校验矩阵</strong><ul><li>由<span class="math display">$$  \begin{cases}  c_2 = c_5 + c_4\\  c_1 = c_5 + c_4 + c_3\\  c_0 = c_5 + c_3  \end{cases}  $$</span>在模2加法下可转化为<span class="math display">$$  \begin{cases}  c_5 + c_4 + 0 + c_2 + 0 + 0 = 0\\  c_5 + c_4 + c_3 + 0 + c_1 + 0 = 0\\  c_5 + 0 + c_3 + 0 + 0 + c_0 = 0  \end{cases}  $$</span></li><li>令<span class="math inline"><strong>c</strong><sub>1 × <em>n</em></sub> = (<em>c</em><sub>5</sub><em>c</em><sub>4</sub><em>c</em><sub>3</sub><em>c</em><sub>2</sub><em>c</em><sub>1</sub><em>c</em><sub>0</sub>)</span>，<span class="math inline"><strong>0</strong><sub>1 × (<em>n</em> − <em>k</em>)</sub> = (000)</span>，有<span class="math inline">$(c_5c_4c_3c_2c_1c_0)\begin{bmatrix}111\\110\\011\\100\\010\\001\end{bmatrix}=[000]$</span>，校验矩阵<span class="math inline">$\mathbf{H} =\begin{bmatrix}110100\\111010\\101001\end{bmatrix}_{(n - k)\timesn}$</span></li><li>满足<span class="math inline"><strong>c</strong><sub>1 × <em>n</em></sub><strong>H</strong><sub><em>n</em> × (<em>n</em> − <em>k</em>)</sub><sup><em>T</em></sup> = <strong>0</strong><sub>1 × (<em>n</em> − <em>k</em>)</sub></span>，<span class="math inline"><strong>H</strong></span>为校验矩阵，<strong>上式用来验证一个<span class="math inline"><em>n</em></span>重矢量是否为码字</strong>。</li></ul></li><li><strong>综上</strong>：对于<span class="math inline">(6, 3)</span>线性分组码，其中<span class="math inline"><em>k</em> = 3</span>，<span class="math inline">2<sup><em>k</em></sup> = 8</span>（消息数量） ：<ul><li>原始生成矩阵<span class="math inline">$G =\begin{bmatrix}111010\\110001\\011101\end{bmatrix}$</span></li><li>系统形式的生成矩阵<span class="math inline">$G_s =\begin{bmatrix}100111\\010110\\001011\end{bmatrix} = [I_{k} |P]$</span></li><li>校验矩阵<span class="math inline">$H = [P^T | I_{n - k}] =\begin{bmatrix}110100\\111010\\101001\end{bmatrix}$</span></li></ul></li></ul></li></ul><h3 id="伴随式与标准阵列译码">伴随式与标准阵列译码</h3><h4 id="基本概念-1">基本概念</h4><ul><li><img src="image-71.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>定义差错图案<span class="math inline"><em>E</em></span></strong> <span class="math display"><strong>E</strong> = (<em>e</em><sub><em>n</em> − 1</sub>, ⋯, <em>e</em><sub>1</sub>, <em>e</em><sub>0</sub>) = <strong>R</strong> − <strong>C</strong> = (<em>r</em><sub><em>n</em> − 1</sub> − <em>c</em><sub><em>n</em> − 1</sub>, ⋯, <em>r</em><sub>1</sub> − <em>c</em><sub>1</sub>, <em>r</em><sub>0</sub> − <em>c</em><sub>0</sub>)</span><ul><li>在二进制码中，模2加与模2减等同，因此有<span class="math display"><strong>E</strong> = <strong>R</strong> + <strong>C</strong>  <strong>R</strong> = <strong>C</strong> + <strong>E</strong></span></li></ul></li><li><strong>定义伴随式<span class="math inline"><em>S</em></span></strong> <span class="math display"><strong>S</strong> = (<em>s</em><sub><em>n</em> − <em>k</em> − 1</sub>, ⋯, <em>s</em><sub>1</sub>, <em>s</em><sub>0</sub>) = <strong>R</strong><strong>H</strong><sup><em>T</em></sup> = <strong>E</strong><strong>H</strong><sup><em>T</em></sup></span><ul><li>因为<span class="math inline"><strong>C</strong><strong>H</strong><sup><em>T</em></sup> = 0</span>，所以<span class="math inline"><strong>R</strong><strong>H</strong><sup><em>T</em></sup> = (<strong>C</strong> + <strong>E</strong>)<strong>H</strong><sup><em>T</em></sup> = <strong>C</strong><strong>H</strong><sup><em>T</em></sup> + <strong>E</strong><strong>H</strong><sup><em>T</em></sup> = <strong>E</strong><strong>H</strong><sup><em>T</em></sup></span><ul><li>若收码无误：则<span class="math inline"><strong>R</strong> = <strong>C</strong></span>即<span class="math inline"><strong>E</strong> = 0</span> ，此时<span class="math inline"><strong>C</strong><strong>H</strong><sup><em>T</em></sup> = <strong>E</strong><strong>H</strong><sup><em>T</em></sup> = <strong>R</strong><strong>H</strong><sup><em>T</em></sup> = 0</span></li><li>若收码有误：即<span class="math inline"><strong>E</strong> ≠ 0</span> ，则<span class="math inline"><strong>R</strong><strong>H</strong><sup><em>T</em></sup> = <strong>E</strong><strong>H</strong><sup><em>T</em></sup> ≠ 0</span></li></ul></li><li>在<span class="math inline"><strong>H</strong><sup><em>T</em></sup></span>固定的前提下，<span class="math inline"><strong>R</strong><strong>H</strong><sup><em>T</em></sup></span>仅与差错图案<span class="math inline"><strong>E</strong></span>有关，而与发送码<span class="math inline"><strong>C</strong></span>无关。</li></ul></li></ul><h4 id="编译码过程">编译码过程</h4><ul><li><strong>编译码过程</strong><ul><li><img src="image-72.webp" srcset="/img/loading/loading3.gif" lazyload></li><li>差错图案<span class="math inline"><strong>E</strong></span>是<span class="math inline"><em>n</em></span>重矢量，共有<span class="math inline">2<sup><em>n</em></sup></span>个可能的组合，而伴随式<span class="math inline"><strong>S</strong></span>是<span class="math inline">(<em>n</em> − <em>k</em>)</span>重矢量，只有<span class="math inline">2<sup><em>n</em> − <em>k</em></sup></span>个可能的组合，因此不同的差错图案可能有相同的伴随式。</li></ul></li><li><strong>差错图案E的求解</strong><ul><li><p>可以通过解线性方程求解<span class="math inline"><strong>E</strong></span>： <span class="math display">$$  \begin{align*}  \mathbf{S}&amp;=(s_{n - k -1},\cdots,s_{1},s_{0})=\mathbf{E}\mathbf{H}^T\\  &amp;=(e_{n - 1},\cdots,e_{1},e_{0})\begin{bmatrix}h_{(n - k - 1)(n -1)}&amp;\cdots&amp;h_{(n - k - 1)1}&amp;h_{(n - k -1)0}\\\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\h_{1(n -1)}&amp;\cdots&amp;h_{11}&amp;h_{10}\\h_{0(n -1)}&amp;\cdots&amp;h_{01}&amp;h_{00}\end{bmatrix}^T  \end{align*}  $$</span></p><p>得到线性方程组： <span class="math display">$$  \begin{cases}  s_{n - k - 1}=e_{n - 1}h_{(n - k - 1)(n - 1)}+\cdots+e_{1}h_{(n - k -1)1}+e_{0}h_{(n - k - 1)0}\\  \vdots\\  s_{1}=e_{n - 1}h_{1(n - 1)}+\cdots+e_{1}h_{11}+e_{0}h_{10}\\  s_{0}=e_{n - 1}h_{0(n - 1)}+\cdots+e_{1}h_{01}+e_{0}h_{00}  \end{cases}  $$</span></p><p>上述方程组中有<span class="math inline"><em>n</em></span>个未知数<span class="math inline"><em>e</em><sub><em>n</em> − 1</sub>, ⋯, <em>e</em><sub>1</sub>, <em>e</em><sub>0</sub></span>，却只有<span class="math inline"><em>n</em> − <em>k</em></span>个方程，可知方程组有多解。在有理数或实数域中，少一个方程就可能导致无限多个解，而在二元域中，少一个方程导致两个解，少两个方程四个解，以此类推，少<span class="math inline"><em>n</em> − (<em>n</em> − <em>k</em>) = <em>k</em></span>个方程导致每个未知数有<span class="math inline">2<sup><em>k</em></sup></span>个解。因此，由上述方程组解出的<span class="math inline"><strong>E</strong></span>可以有<span class="math inline">2<sup><em>k</em></sup></span>个解。到底取哪一个作为附加在收码<span class="math inline"><strong>R</strong></span>上的差错图案<span class="math inline"><strong>E</strong></span>的估值呢？<strong>概率译码</strong>：把所有<span class="math inline">2<sup><em>k</em></sup></span>个解的重量(差错图案<span class="math inline"><strong>E</strong></span>中<span class="math inline">1</span>的个数)作比较，选择其中最轻（<span class="math inline">1</span>的个数最少）者作为<span class="math inline"><strong>E</strong></span>的估值。</p></li></ul></li><li><strong>标准阵列译码表</strong>: 列出伴随式对应的所有差错图案<ul><li><p><strong>标准阵列构造方法</strong></p><ol type="1"><li>先将<span class="math inline">2<sup><em>k</em></sup></span>个码字排成一行，作为标准阵列的第一行，并将全<span class="math inline">0</span>码字<span class="math inline"><strong>C</strong><sub>1</sub> = (00…0)</span>放在最左面的位置上。</li><li>然后在剩下的<span class="math inline">(2<sup><em>n</em></sup> − 2<sup><em>k</em></sup>)</span>个<span class="math inline"><em>n</em></span>重中选取一个重量最轻的<span class="math inline"><em>n</em></span>重<span class="math inline"><strong>E</strong><sub>2</sub></span>放在全<span class="math inline">0</span>码字<span class="math inline"><strong>C</strong><sub>1</sub></span>下面，再将<span class="math inline"><strong>E</strong><sub>2</sub></span>分别和码字<span class="math inline"><strong>C</strong><sub>2</sub>, <strong>C</strong><sub>3</sub>, ⋯, <strong>C</strong><sub>2<sup><em>k</em></sup></sub></span>相加，放在对应码字下面构成阵列第二行。</li><li>在第二次剩下的<span class="math inline"><em>n</em></span>重中，选取重量最轻的<span class="math inline"><em>n</em></span>重<span class="math inline"><strong>E</strong><sub>3</sub></span>，放在<span class="math inline"><strong>E</strong><sub>2</sub></span>下面，并将<span class="math inline"><strong>E</strong><sub>3</sub></span>分别加到第一行各码字上，得到第三行。</li><li>继续这样做下去，直到全部<span class="math inline"><em>n</em></span>重用完为止，得到给定<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码的标准阵列。</li></ol><ul><li><strong>在标准阵列的同一行中没有相同的矢量，而且<span class="math inline">2<sup><em>n</em></sup></span>个<span class="math inline"><em>n</em></span>重中任一个<span class="math inline"><em>n</em></span>重在阵列中出现一次且仅出现一次</strong></li></ul></li><li><p>标准阵列译码表：<strong>标准阵列可能不唯一</strong></p><table style="width:100%;"><thead><tr><th></th><th>伴随式</th><th>陪集首</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>子集头</td><td><span class="math inline"><em>S</em><sub>1</sub></span></td><td><span class="math inline"><strong>C</strong><sub>1</sub> = <strong>E</strong><sub>1</sub> = 0</span></td><td><span class="math inline"><strong>C</strong><sub>2</sub></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><strong>C</strong><sub>2<sup><em>k</em></sup></sub></span></td></tr><tr><td></td><td><span class="math inline"><em>S</em><sub>2</sub></span></td><td><span class="math inline"><strong>E</strong><sub>2</sub></span></td><td><span class="math inline"><strong>C</strong><sub>2</sub> + <strong>E</strong><sub>2</sub></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><strong>C</strong><sub>2<sup><em>k</em></sup></sub> + <strong>E</strong><sub>2</sub></span></td></tr><tr><td></td><td><span class="math inline"><em>S</em><sub>3</sub></span></td><td><span class="math inline"><strong>E</strong><sub>3</sub></span></td><td><span class="math inline"><strong>C</strong><sub>2</sub> + <strong>E</strong><sub>3</sub></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><strong>C</strong><sub>2<sup><em>k</em></sup></sub> + <strong>E</strong><sub>3</sub></span></td></tr><tr><td></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td></tr><tr><td></td><td><span class="math inline"><em>S</em><sub>2<sup><em>n</em> − <em>k</em></sup></sub></span></td><td><span class="math inline"><strong>E</strong><sub>2<sup><em>n</em> − <em>k</em></sup></sub></span></td><td><span class="math inline"><strong>C</strong><sub>2</sub> + <strong>E</strong><sub>2<sup><em>n</em> − <em>k</em></sup></sub></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><strong>C</strong><sub>2<sup><em>k</em></sup></sub> + <strong>E</strong><sub>2<sup><em>n</em> − <em>k</em></sup></sub></span></td></tr></tbody></table></li><li><p><strong>陪集和子集</strong></p><ul><li><strong>陪集</strong>：译码表中有<span class="math inline">2<sup><em>n</em> − <em>k</em></sup></span>行，每行是一个陪集，每陪集的第一个元素(位于第一列)叫<strong>陪集首</strong>。同一陪集（同一行）中的所有元素对应共同的一个伴随式。第一行陪集的陪集首是全零伴随式<span class="math inline"><strong>S</strong><sub>0</sub></span>所对应的全零差错图案<span class="math inline"><strong>E</strong><sub>0</sub></span>(无差错)，而第<span class="math inline"><em>j</em></span>行陪集的陪集首是伴随式<span class="math inline"><strong>S</strong><sub><em>j</em></sub></span>所对应的重量最小的差错图案<span class="math inline"><strong>E</strong><sub><em>j</em></sub></span>(<span class="math inline"><strong>C</strong><sub>0</sub> = 0, <strong>R</strong><sub><em>j</em></sub> = <strong>E</strong><sub><em>j</em></sub></span>)。</li><li><strong>子集</strong>：译码表中有<span class="math inline">2<sup><em>k</em></sup></span>列，每列是一个子集，每子集的第一个元素(位于第一行)叫<strong>子集头</strong>。同一子集（同一列）中的所有元素对应同一个码字，第一列子集的子集头是全零码字<span class="math inline"><strong>C</strong><sub>0</sub></span>，而第<span class="math inline"><em>i</em></span>列子集的子集头是码字<span class="math inline"><strong>C</strong><sub><em>i</em></sub></span>(<span class="math inline"><strong>E</strong><sub>0</sub> = 0, <strong>R</strong><sub><em>i</em></sub> = <strong>C</strong><sub><em>i</em></sub></span>)。</li></ul></li><li><p><strong>检错纠错能力</strong>：根据<span class="math inline"><strong>E</strong></span>在标准阵列中的位置</p><ul><li>第一行：不可检错</li><li>第一列：可检错可纠错</li><li>剩余部分：可检错不可纠错</li></ul></li></ul></li><li><strong>具体译码过程</strong>：<ol type="1"><li>求生成矩阵<span class="math inline"><strong>G</strong></span>和校验矩阵<span class="math inline"><strong>H</strong></span>。</li><li>通过信息组<span class="math inline"><strong>m</strong></span>和生成矩阵<span class="math inline"><strong>G</strong></span>求出各子集头码字<span class="math inline"><strong>C</strong></span>。</li><li>构造标准阵列译码表。</li><li>根据标准阵列译码表，对收到的码字<span class="math inline"><strong>R</strong></span>进行译码。译码方法：<ul><li>直接搜索码表，查得<span class="math inline"><strong>R</strong></span>所在列的子集头<span class="math inline"><strong>C</strong></span>，因此译码输出取为<span class="math inline"><strong>C</strong></span></li><li>先求伴随式 <span class="math inline"><strong>S</strong> = <strong>R</strong><strong>H</strong><sup><strong>T</strong></sup></span>，确定<span class="math inline"><strong>S</strong></span>所在行，再沿着行对码表作一维搜索找到<span class="math inline"><strong>R</strong></span>，最后顺着所在列向上找出码字<span class="math inline"><strong>C</strong></span></li><li>先求出伴随式 <span class="math inline"><strong>S</strong> = <strong>R</strong><strong>H</strong><sup><strong>T</strong></sup></span>并确定 <span class="math inline"><strong>S</strong></span>所对应的陪集首（差错图案）<span class="math inline"><strong>E</strong></span>，再将陪集首与收码相加得到码字<span class="math inline"><strong>C</strong> = <strong>R</strong> + <strong>E</strong></span></li></ul>上述三种方法由上而下，查表的时间下降而所需计算量增大，实际使用时可针对不同情况选用。</li></ol></li><li><strong>示例</strong>： 一个<span class="math inline">(5, 2)</span>系统线性码的生成矩阵是<span class="math inline">$G =\begin{bmatrix}10111\\01101\end{bmatrix}$</span> ，设收码<span class="math inline"><strong>R</strong> = (10101)</span>，构造标准阵列译码表，译出发码的估值。<ul><li><p>求出校验矩阵：<span class="math inline">$H = [P^T |I_3]=\begin{bmatrix}11100\\10010\\11001\end{bmatrix}$</span></p></li><li><p>分别以信息组<span class="math inline"><strong>m</strong> = (00)</span>、<span class="math inline">(01)</span>、<span class="math inline">(10)</span>、<span class="math inline">(11)</span>及已知的<span class="math inline"><em>G</em></span>求得<span class="math inline">4</span>个许用码字为<span class="math inline"><strong>C</strong><sub>0</sub> = (00000)</span>、<span class="math inline"><strong>C</strong><sub>1</sub> = (10111)</span>、<span class="math inline"><strong>C</strong><sub>2</sub> = (01101)</span>、<span class="math inline"><strong>C</strong><sub>3</sub> = (11010)</span></p></li><li><p>构造标准阵列译码表</p><table><thead><tr><th>伴随式</th><th>陪集首</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><span class="math inline"><em>S</em><sub>0</sub> = 000</span></td><td><span class="math inline"><em>E</em><sub>0</sub> + <em>C</em><sub>0</sub> = 00000</span></td><td><span class="math inline"><em>C</em><sub>1</sub> = 10111</span></td><td><span class="math inline"><em>C</em><sub>2</sub> = 01101</span></td><td><span class="math inline"><em>C</em><sub>3</sub> = 11010</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>1</sub> = 111</span></td><td><span class="math inline"><em>E</em><sub>1</sub> = 10000</span></td><td><span class="math inline">00111</span></td><td><span class="math inline">11101</span></td><td><span class="math inline">01010</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>2</sub> = 101</span></td><td><span class="math inline"><em>E</em><sub>2</sub> = 01000</span></td><td><span class="math inline">11111</span></td><td><span class="math inline">00101</span></td><td><span class="math inline">10010</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>3</sub> = 100</span></td><td><span class="math inline"><em>E</em><sub>3</sub> = 00100</span></td><td><span class="math inline">10011</span></td><td><span class="math inline">01001</span></td><td><span class="math inline">11110</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>4</sub> = 010</span></td><td><span class="math inline"><em>E</em><sub>4</sub> = 00010</span></td><td><span class="math inline">10101</span></td><td><span class="math inline">01111</span></td><td><span class="math inline">11000</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>5</sub> = 001</span></td><td><span class="math inline"><em>E</em><sub>5</sub> = 00001</span></td><td><span class="math inline">10110</span></td><td><span class="math inline">01100</span></td><td><span class="math inline">11011</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>6</sub> = 011</span></td><td><span class="math inline"><em>E</em><sub>6</sub> = 00011</span></td><td><span class="math inline">10100</span></td><td><span class="math inline">01110</span></td><td><span class="math inline">11001</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>7</sub> = 110</span></td><td><span class="math inline"><em>E</em><sub>7</sub> = 00110</span></td><td><span class="math inline">10001</span></td><td><span class="math inline">01011</span></td><td><span class="math inline">11100</span></td></tr></tbody></table></li><li><p>将接收码<span class="math inline"><strong>R</strong> = 10101</span>译码，可选以下三种方法之一译码：</p><ol type="1"><li>直接搜索码表，查得<span class="math inline">(10101)</span>所在列的子集头是<span class="math inline">(10111)</span>，因此译码输出取为<span class="math inline">(10111)</span>。</li><li>先求伴随式<span class="math inline"><strong>R</strong><em>H</em><sup><em>T</em></sup> = (10101) ⋅ <em>H</em><sup><em>T</em></sup> = (010) = <em>S</em><sub>4</sub></span>，确定<span class="math inline"><em>S</em><sub>4</sub></span>所在行，再沿着行对码表作一维搜索找到<span class="math inline">(10101)</span>，最后顺着所在列向上找出码字<span class="math inline">(10111)</span>。</li><li>先求出伴随式<span class="math inline"><strong>R</strong><em>H</em><sup><em>T</em></sup> = (010) = <em>S</em><sub>4</sub></span>并确定<span class="math inline"><em>S</em><sub>4</sub></span>所对应的陪集首（差错图案）<span class="math inline"><em>E</em><sub>4</sub> = (00010)</span>，再将陪集首与收码相加得到码字<span class="math inline"><strong>C</strong> = <strong>R</strong> + <em>E</em><sub>4</sub> = (10101) + (00010) = (10111)</span>。</li></ol></li></ul></li></ul><h3 id="码距纠错能力mdc码及重量谱">码距、纠错能力、MDC码及重量谱</h3><ul><li><p><strong>汉明距离</strong>：两个码字<span class="math inline"><em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub></span>之间对应码元位上符号取值不同的个数，称为码字<span class="math inline"><em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub></span>之间的汉明距离<span class="math display">$$d(c_i, c_j)=\sum_{k = 0}^{n -1}(c_{ik}\oplus c_{jk})$$</span></p></li><li><p><strong>最小距离</strong>：在<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码中，码字之间的最小汉明距离<span class="math display"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = <em>m</em><em>i</em><em>n</em>(<em>d</em>(<em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub>)), <em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub> ∈ <em>C</em></span></p></li><li><p><strong>定理6.1</strong>：任何最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>的线性分组码，其检错能力为<span class="math inline">(<em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> − 1)</span>，纠错能力<span class="math inline"><em>t</em></span>为<span class="math display">$$t =\left\lfloor\frac{d_{min}-1}{2}\right\rfloor$$</span></p><ul><li>纠错能力<span class="math inline"><em>t</em></span>是指在接收码中，最多允许有<span class="math inline"><em>t</em></span>个差错图案而不致于误译的能力。（只要不到另一个点，你就能知道出错了）</li><li>检错能力是指在接收码中，最多允许有<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> − 1</span>个差错图案而不致于误译的能力。（只要离原来的点比任何一个点都近，你就能知道原来的点）</li></ul></li><li><p><strong>纠错能力示意图</strong>：码集各码字间的距离是不同的，码距最小者决定码的特性，称之为最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span></p><ul><li><img src="image-73.webp" srcset="/img/loading/loading3.gif" lazyload></li><li>如图中<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = 3</span>，纠错能力是<span class="math inline">1</span>，检错能力是<span class="math inline">2</span></li></ul></li><li><p><strong>最小距离计算</strong>：</p><ul><li><strong>汉明重量</strong>：码字中非<span class="math inline">0</span>码元符号的个数，称为该码字的汉明重量。<strong>在二元线性码中，码字重量就是码字中含“<span class="math inline">1</span>”的个数</strong> <span class="math display">$$w(c)=\sum_{i = 0}^{n - 1}c_i$$</span></li><li><strong>定理6.2</strong>：线性分组码的最小距离等于码集中非零码字的最小重量<span class="math display"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = <em>m</em><em>i</em><em>n</em>{<em>w</em>(<em>C</em><sub><em>i</em></sub>)}  <em>C</em><sub><em>i</em></sub> ∈ <em>C</em><em>及</em><em>C</em><sub><em>i</em></sub> ≠ 0</span><span class="math display"><em>d</em>(<em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub>) = <em>w</em>(<em>c</em><sub><em>i</em></sub> ⊕ <em>c</em><sub><em>j</em></sub>) = <em>w</em>(<em>c</em><sub><em>k</em></sub>)  <em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub>, <em>c</em><sub><em>k</em></sub> ∈ <em>C</em></span></li><li><strong>定理6.3</strong>：<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码最小距离等于<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>的<strong>必要</strong>条件是：校验矩阵<span class="math inline"><em>H</em></span>中任意<span class="math inline">(<em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> − 1)</span>列线性无关。<ul><li>将<span class="math inline"><em>H</em></span>写成<span class="math inline"><em>H</em> = [<em>h</em><sub><em>n</em> − 1</sub>, ⋯, <em>h</em><sub>1</sub>, <em>h</em><sub>0</sub>]</span>，其中<span class="math inline"><em>h</em><sub><em>n</em> − 1</sub>, ⋯, <em>h</em><sub>1</sub>, <em>h</em><sub>0</sub></span>为列矢量<span class="math display">$$  \begin{align*}  cH^T &amp;= [c_{n - 1},\cdots, c_1, c_0]\begin{bmatrix}h_{n -1}^T\\\vdots\\h_1^T\\h_0^T\end{bmatrix}\\  &amp;=c_{n - 1}h_{n - 1}^T+\cdots + c_1h_1^T + c_0h_0^T = 0  \end{align*}  $$</span></li><li>若存在一个重量为<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>的码字，则必有<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>列线性相关</li></ul></li><li><strong>定理6.4</strong>：<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码的最小距离必定小于等于<span class="math inline">(<em>n</em> − <em>k</em> + 1)</span> <span class="math display"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> ≤ (<em>n</em> − <em>k</em> + 1)</span><ul><li>计算校验矩阵的秩，则<span class="math inline"><em>H</em></span>的秩加<span class="math inline">1</span>就是最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>的上限。</li></ul></li></ul></li><li><p><strong>示例</strong>：对于<span class="math inline">(7, 4)</span>线性码，<span class="math inline">$H =\begin{bmatrix}1110100\\0111010\\1101001\end{bmatrix}$</span></p><ul><li>各列都不相同，任意<span class="math inline">2</span>列之和不等于<span class="math inline">0</span>，任何<span class="math inline">2</span>列线性无关；</li><li>存在<span class="math inline">2</span>列之和等于矩阵中某一列，即存在<span class="math inline">3</span>列线性相关</li><li>存在重量为<span class="math inline">3</span>的码字</li><li>能找到的最小线性相关的列数为<span class="math inline">3</span></li><li>所以该码的最小距离为<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = 3</span>，小于<span class="math inline"><em>n</em> − <em>k</em> + 1 = 4</span> 。</li><li>该码的纠错能力为<span class="math inline">$t =\left\lfloor\frac{d_{min}-1}{2}\right\rfloor =1$</span>，检错能力为<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> − 1 = 2</span>。</li></ul></li><li><p><strong>极大最小距离码 (MDC)</strong>：</p><ul><li><strong>定义</strong>：<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = <em>n</em> − <em>k</em> + 1</span>的<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码称为极大最小距离码(MDC - Maximized minimum Distance Code)。</li><li>总体的、平均的纠错能力不但与最小距离有关，而且与其余码距或者说与码字的重量分布特性有关。</li></ul></li></ul><h3 id="完备码perfect-code">完备码（Perfect code）</h3><h4 id="完备码定义与性质">完备码定义与性质</h4><ul><li><strong>汉明限</strong>：任何一个二元<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码都有<span class="math inline">2<sup><em>n</em> − <em>k</em></sup></span>个伴随式，若该码的纠错能力是<span class="math inline"><em>t</em></span>，则对于任何一个重量小于等于<span class="math inline"><em>t</em></span>的差错图案，都应有一个伴随式与之对应，即伴随式的数目满足条件<span class="math display">$$2^{n -k}\geq\binom{n}{0}+\binom{n}{1}+\binom{n}{2}+\cdots+\binom{n}{t}$$</span>此式称作<strong>汉明限</strong>，任何一个纠错码都应满足该条件。</li><li><strong>完备码定义</strong>：满足以下等式的二元<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码 <span class="math display">$$2^{n -k}=\binom{n}{0}+\binom{n}{1}+\binom{n}{2}+\cdots+\binom{n}{t}$$</span></li><li><strong>完备码性质</strong>：<ol type="1"><li>即该码的伴随式数目恰好和不大于<span class="math inline"><em>t</em></span>个差错的图案数目相等。</li><li>相当于在标准译码阵列中能将所有重量不大于<span class="math inline"><em>t</em></span>的差错图案选作陪集首，且没有一个陪集首的重量大于<span class="math inline"><em>t</em></span>，此时校验位得到最充分的利用。</li><li>这样的二元<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码称为<strong>完备码</strong>。</li></ol></li></ul><h4 id="汉明码hamming-code">汉明码（Hamming Code）</h4><ul><li><strong>定义</strong>：汉明码是纠错能力<span class="math inline"><em>t</em> = 1</span>的一类码的统称。</li><li><strong>性质</strong>：<ul><li><p>汉明码既有二进制的，也有非二进制的。</p></li><li><p>二进制时，汉明码码长<span class="math inline"><em>n</em></span>和信息位<span class="math inline"><em>k</em></span>服从规律<span class="math display">(<em>n</em>, <em>k</em>) = (2<sup><em>m</em></sup> − 1, 2<sup><em>m</em></sup> − 1 − <em>m</em>)</span>其中<span class="math inline"><em>m</em> = <em>n</em> − <em>k</em></span>，是正整数。</p><table><thead><tr><th>正整数<span class="math inline"><em>m</em> = <em>n</em> − <em>k</em></span></th><th>码长 <span class="math inline"><em>n</em> = 2<sup><em>m</em></sup> − 1</span></th><th>信息位 <span class="math inline"><em>k</em> = 2<sup><em>m</em></sup> − 1 − <em>m</em></span></th><th>汉明码<span class="math inline">(<em>n</em>, <em>k</em>)</span></th></tr></thead><tbody><tr><td>3</td><td><span class="math inline">2<sup>3</sup> − 1 = 7</span></td><td><span class="math inline">2<sup>3</sup> − 1 − 3 = 4</span></td><td><span class="math inline">(7, 4)</span></td></tr><tr><td>4</td><td><span class="math inline">2<sup>4</sup> − 1 = 15</span></td><td><span class="math inline">2<sup>4</sup> − 1 − 4 = 11</span></td><td><span class="math inline">(15, 11)</span></td></tr><tr><td>5</td><td><span class="math inline">2<sup>5</sup> − 1 = 31</span></td><td><span class="math inline">2<sup>5</sup> − 1 − 5 = 26</span></td><td><span class="math inline">(31, 26)</span></td></tr><tr><td>6</td><td><span class="math inline">2<sup>6</sup> − 1 = 63</span></td><td><span class="math inline">2<sup>6</sup> − 1 − 6 = 57</span></td><td><span class="math inline">(63, 57)</span></td></tr><tr><td>7</td><td><span class="math inline">2<sup>7</sup> − 1 = 127</span></td><td><span class="math inline">2<sup>7</sup> − 1 − 7 = 120</span></td><td><span class="math inline">(127, 120)</span></td></tr><tr><td>8</td><td><span class="math inline">2<sup>8</sup> − 1 = 255</span></td><td><span class="math inline">2<sup>8</sup> − 1 − 8 = 247</span></td><td><span class="math inline">(255, 247)</span></td></tr><tr><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td></tr></tbody></table></li><li><p>汉明码是完备码，因为满足等式<span class="math display">$$\binom{n}{0}+\binom{n}{1}=1 + n=1 + 2^m -1=2^m=2^{n - k}$$</span></p></li></ul></li><li><strong>校验矩阵构成</strong>：汉明码的校验矩阵<span class="math inline"><em>H</em></span>具有特殊性质，可简化构造方法。<ul><li>一个<span class="math inline">(<em>n</em>, <em>k</em>)</span>码的校验矩阵有<span class="math inline"><em>n</em> − <em>k</em></span>行和<span class="math inline"><em>n</em></span>列，二进制时<span class="math inline"><em>n</em> − <em>k</em></span>个码元所能组成的列矢量总数是<span class="math inline">2<sup><em>n</em> − <em>k</em></sup></span>，除去全<span class="math inline">0</span>矢量后为<span class="math inline">2<sup><em>n</em> − <em>k</em></sup> − 1 = 2<sup><em>m</em></sup> − 1 = <em>n</em></span>，恰好和校验矩阵的列数<span class="math inline"><em>n</em></span>相等。</li><li>只要排列所有列，通过列置换将矩阵<span class="math inline"><em>H</em></span>转换成系统形式，就可以进一步得到相应的生成矩阵<span class="math inline"><em>G</em></span>。</li></ul></li><li><strong>示例</strong>：构造一个<span class="math inline"><em>m</em> = 3</span>的二元<span class="math inline">(7, 4)</span>汉明码。<ul><li>先利用汉明码的特性构造一个<span class="math inline">(7, 4)</span>汉明码的校验矩阵<span class="math inline"><em>H</em></span>，再通过列置换将它变为系统形式：</li><li>校验矩阵<span class="math inline">$H=\begin{bmatrix}0001111\\0110011\\1010101\end{bmatrix}$</span>，经列置换得到<span class="math inline">$\begin{bmatrix}1110100\\0111010\\1101001\end{bmatrix}=[P^T| I_3]$</span>，再得生成矩阵<span class="math inline">$G = [I_4 |P]=\begin{bmatrix}1000101\\0100111\\0010110\\0001011\end{bmatrix}$</span>#### 高莱（Golay）码</li></ul></li><li>是二进制<span class="math inline">(23, 12)</span>线性码</li><li>最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = 7</span></li><li>纠错能力<span class="math inline"><em>t</em> = 3</span></li><li>高莱码是完备码，因为满足等式<span class="math display">$$2^{23 -12}=2048=1+\binom{23}{1}+\binom{23}{2}+\binom{23}{3}$$</span></li><li>在<span class="math inline">(23, 12)</span>码上添加一位奇偶位即得二进制线性<span class="math inline">(24, 12)</span>扩展高莱码，其最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = 8</span>。</li><li>编码步骤见<a href="#高莱golay码-1">高莱码编码步骤</a></li></ul><h3 id="循环码">循环码</h3><h4 id="基本概念与多项式描述">基本概念与多项式描述</h4><ul><li><p><strong>循环码的定义</strong>：设一个<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码<span class="math inline"><em>C</em></span>，如果它的任一码字的每一次循环移位都还是<span class="math inline"><em>C</em></span>的一个码字，则称<span class="math inline"><em>C</em></span>是<strong>循环码</strong>。 <span class="math display">$$  \begin{align*}  \forall: &amp;\boldsymbol{c}=(c_{n - 1},c_{n - 2},\cdots,c_{0})\in C\\  &amp;\boldsymbol{c}_1=(c_{n - 2},c_{n - 3},\cdots,c_{0},c_{n - 1})\inC\\  &amp;\boldsymbol{c}_2=(c_{n - 3},c_{n - 4},\cdots,c_{0},c_{n - 1},c_{n- 2})\in C\\  &amp;\vdots\\  &amp;\boldsymbol{c}_{n - 1}=(c_{0},c_{n - 1},\cdots,c_{2},c_{1})\in C  \end{align*}  $$</span></p></li><li><p><strong>循环码的数学描述</strong>：</p><ul><li><strong>循环码的特点</strong>：<ul><li>它是线性分组码，其数学模型应具有线性特性。</li><li>具有循环特性。</li><li>码字的全体<strong>构成了<span class="math inline"><em>n</em></span>维矢量空间中具有循环特性的<span class="math inline"><em>k</em></span>维子空间</strong>。</li></ul></li><li><strong>线性分组码的多项式描述</strong>：<ul><li>码字<span class="math display"><strong>c</strong> = (<em>c</em><sub><em>n</em> − 1</sub>, <em>c</em><sub><em>n</em> − 2</sub>, ⋯, <em>c</em><sub>0</sub>)</span></li><li>码多项式<span class="math display"><em>c</em>(<em>x</em>) = <em>c</em><sub><em>n</em> − 1</sub><em>x</em><sup><em>n</em> − 1</sup> + <em>c</em><sub><em>n</em> − 2</sub><em>x</em><sup><em>n</em> − 2</sup> + ⋯ + <em>c</em><sub>1</sub><em>x</em> + <em>c</em><sub>0</sub></span></li><li>对于线性分组码<span class="math inline"><em>C</em></span>，可以表示成码多项式构成的集合：<span class="math display">$$  \begin{align*}  &amp;C\leftrightarrow C(x)\\  &amp;=\{c_{n - 1}x^{n - 1}+c_{n - 2}x^{n - 2}+\cdots + c_1x +c_0\mid(c_{n - 1},c_{n - 2},\cdots,c_{0})\in C\}  \end{align*}  $$</span></li></ul></li></ul></li><li><p><strong>示例</strong>：<span class="math inline">(7, 3)</span>线性分组码</p><ul><li>校验矩阵<span class="math inline">$H=\begin{bmatrix}1&amp;0&amp;1&amp;1&amp;0&amp;0&amp;0\\1&amp;1&amp;1&amp;0&amp;1&amp;0&amp;0\\1&amp;1&amp;0&amp;0&amp;0&amp;1&amp;0\\0&amp;1&amp;1&amp;0&amp;0&amp;0&amp;1\end{bmatrix}$</span>生成矩阵<span class="math inline">$G=\begin{bmatrix}1&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0\\0&amp;1&amp;0&amp;0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;1&amp;1&amp;0&amp;1\end{bmatrix}$</span>由<span class="math inline"><strong>c</strong> = <strong>m</strong><em>G</em></span>得码集（由两组码字循环构成的循环码）：<img src="image-79.webp" srcset="/img/loading/loading3.gif" lazyload></li><li>任取一码字<ul><li>设<span class="math inline"><strong>c</strong> = 0011101</span>，则<span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>。</li><li>移一位，<span class="math inline"><strong>c</strong><sub>1</sub> = 0111010</span>，<span class="math inline"><em>c</em><sub>1</sub>(<em>x</em>) = <em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em> = <em>x</em><em>c</em>(<em>x</em>)</span>。</li><li>移两位，<span class="math inline"><strong>c</strong><sub>2</sub> = 1110100</span>，<span class="math inline"><em>c</em><sub>2</sub>(<em>x</em>) = <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>2</sup> = <em>x</em><sup>2</sup><em>c</em>(<em>x</em>)</span>。</li><li>移三位，<span class="math inline"><strong>c</strong><sub>3</sub> = 1101001</span>，<span class="math inline"><em>c</em><sub>3</sub>(<em>x</em>) = <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>3</sup> + 1 = <em>x</em><sup>3</sup><em>c</em>(<em>x</em>)&nbsp;(mod &nbsp;(<em>x</em><sup>7</sup> + 1))</span>。</li><li><span class="math inline">⋮</span></li></ul></li></ul></li><li><p><strong>结论</strong>：如果将一个循环码的某一非零码字用码多项式表示出来，那么其他的非零码字多项式就可以用这个码字多项式（或码字多项式的和）乘上<span class="math inline"><em>x</em></span>的一个幂，再求<span class="math inline">(<em>x</em><sup><em>n</em></sup> + 1)</span>的余得到。</p></li><li><p><strong>说明</strong>：一个码字的移位最多能得到<span class="math inline"><em>n</em></span>个码字，因此“循环码字的循环仍是码字”并不意味着循环码集可以从一个码字循环而得，还应包含码字的一些线性组合。</p></li></ul><h4 id="基本定理与矩阵描述">基本定理与矩阵描述</h4><ul><li><strong>循环码的生成多项式</strong>:<ul><li><strong>定义</strong>：若<span class="math inline"><em>g</em>(<em>x</em>)</span>是一个<span class="math inline">(<em>n</em> − <em>k</em>)</span>次多项式，且是<span class="math inline">(<em>x</em><sup><em>n</em></sup> + 1)</span>的因式，则由<span class="math inline"><em>g</em>(<em>x</em>)</span>可以生成一个<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码，<span class="math inline"><em>g</em>(<em>x</em>)</span>称为该循环码的<strong>生成多项式</strong>。</li><li><strong>结论</strong>：<ol type="1"><li><p><strong>结论1</strong>：<span class="math inline"><em>G</em><em>F</em>(2)</span>上的<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码中，存在着一个次数为<span class="math inline">(<em>n</em> − <em>k</em>)</span>的<strong>首一码多项式</strong><span class="math inline"><em>g</em>(<em>x</em>)</span>（首一：多项式最高幂次项系数<span class="math inline"><em>g</em><sub><em>n</em> − <em>k</em></sub> = 1</span>） <span class="math display"><em>g</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup> + <em>g</em><sub><em>n</em> − <em>k</em> − 1</sub><em>x</em><sup><em>n</em> − <em>k</em> − 1</sup> + ⋯ + <em>g</em><sub>2</sub><em>x</em><sup>2</sup> + <em>g</em><sub>1</sub><em>x</em> + 1</span></p><p>使得所有码多项式都是<span class="math inline"><em>g</em>(<em>x</em>)</span>的倍式，即 <span class="math display"><em>c</em>(<em>x</em>) = <em>m</em>(<em>x</em>) ⋅ <em>g</em>(<em>x</em>)</span></p><p>其中<span class="math display"><em>m</em>(<em>x</em>) = <em>m</em><sub><em>k</em> − 1</sub><em>x</em><sup><em>k</em> − 1</sup> + ⋯ + <em>m</em><sub>1</sub><em>x</em> + <em>m</em><sub>0</sub></span></p><p>且所有小于<span class="math inline"><em>n</em></span>次的<span class="math inline"><em>g</em>(<em>x</em>)</span>的倍式都是码多项式。<strong>故循环码完全由它的生成多项式确定</strong>。</p></li><li><p><strong>结论2</strong>：<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码的生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>一定是<span class="math inline">(<em>x</em><sup><em>n</em></sup> + 1)</span>的因子，即<span class="math display">$$g(x)\mid(x^n + 1)\quad或写成\quad x^n + 1 =g(x)h(x)$$</span> 相反，如果<span class="math inline"><em>g</em>(<em>x</em>)</span>是<span class="math inline"><em>x</em><sup><em>n</em></sup> + 1</span>的<span class="math inline">(<em>n</em> − <em>k</em>)</span>次因子，则<span class="math inline"><em>g</em>(<em>x</em>)</span>一定是<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码的生成多项式。<strong>生成多项式不唯一</strong>。</p></li><li><p><strong>结论3</strong>：任何码字的循环移位仍是码字，但并非由一个码字循环移位可以得到所有码字。</p></li><li><p><strong>结论4</strong>：当一个循环码给定其生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>后，根据生成多项式就可以进行编码，但编出的码不一定为系统码。</p></li></ol></li><li><strong><span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码的构造</strong>：<ol type="1"><li>对<span class="math inline"><em>x</em><sup><em>n</em></sup> + 1</span>做因式分解，找出<span class="math inline">(<em>n</em> − <em>k</em>)</span>次因式。</li><li>以该<span class="math inline">(<em>n</em> − <em>k</em>)</span>次因式为生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>与不高于<span class="math inline">(<em>k</em> − 1)</span>次信息多项式<span class="math inline"><em>m</em>(<em>x</em>)</span>相乘，即得到对应消息序列的码多项式。</li></ol></li></ul></li><li><strong>循环码的生成矩阵</strong>:<ul><li><p><span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码是<span class="math inline"><em>n</em></span>维线性空间中具有循环特性的<span class="math inline"><em>k</em></span>维子空间，其生成矩阵可由码空间中任一组<span class="math inline"><em>k</em></span>个线性无关的码字构成，这<span class="math inline"><em>k</em></span>个线性无关的码字组成<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码的基底，且基底不唯一。</p></li><li><p><strong>获得<span class="math inline"><em>k</em></span>个线性无关码字的方法</strong><strong>当循环码的生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>确定后，可取<span class="math inline"><em>g</em>(<em>x</em>)</span>本身加上移位<span class="math inline"><em>k</em> − 1</span>次所得到的<span class="math inline"><em>k</em> − 1</span>个码字，与<span class="math inline"><em>g</em>(<em>x</em>)</span>一起作为<span class="math inline"><em>k</em></span>个基底</strong>，即： <span class="math display">$$  \begin{align*}  G&amp;=\begin{bmatrix}x^{k - 1}g(x)\\x^{k -2}g(x)\\\vdots\\xg(x)\\g(x)\end{bmatrix}\\  &amp;=\begin{bmatrix}g_{n - k}&amp;g_{n - k -1}&amp;\cdots&amp;g_0&amp;0&amp;0&amp;\cdots&amp;0\\0&amp;g_{n -k}&amp;g_{n - k -1}&amp;\cdots&amp;g_0&amp;0&amp;\cdots&amp;0\\\vdots&amp;&amp;&amp;\ddots&amp;&amp;&amp;\vdots\\0&amp;\cdots&amp;0&amp;0&amp;g_{n- k}&amp;g_{n - k - 1}&amp;\cdots&amp;g_0\end{bmatrix}  \end{align*}  $$</span></p><p>这<span class="math inline"><em>k</em></span>个矢量线性无关，且由<span class="math inline"><em>g</em>(<em>x</em>)</span>循环移位得到，所以都是码字，它们构成一个<span class="math inline"><em>k</em> × <em>n</em></span>的矩阵，即循环码的生成矩阵。</p></li></ul></li><li><strong>循环码的系统码</strong><ul><li><strong>系统循环码的编码</strong>：<ul><li>码多项式<span class="math display"><em>c</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)</span>其中<span class="math inline"><em>r</em>(<em>x</em>)</span>是与码字中<span class="math inline">(<em>n</em> − <em>k</em>)</span>个校验元相对应的<span class="math inline">(<em>n</em> − <em>k</em> − 1)</span>次多项式。对等式两边取<span class="math inline">&nbsp;mod &nbsp;<em>g</em>(<em>x</em>)</span>：</li><li>等式左边：<span class="math inline"><em>c</em>(<em>x</em>) = <em>m</em>(<em>x</em>)<em>g</em>(<em>x</em>)</span>，所以<span class="math inline"><em>c</em>(<em>x</em>)&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = 0</span>。</li><li>等式右边：必有<span class="math inline">[<em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)]&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = 0</span>，由于<span class="math inline"><em>r</em>(<em>x</em>)</span>的幂次<span class="math inline">(<em>n</em> − <em>k</em> − 1)</span>低于<span class="math inline"><em>g</em>(<em>x</em>)</span>的幂次<span class="math inline">(<em>n</em> − <em>k</em>)</span>，要使等式右边为<span class="math inline">0</span>，必有<span class="math display"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>r</em>(<em>x</em>)</span></li></ul></li><li><strong>系统码的编码步骤</strong>：<ol type="1"><li>将信息多项式<span class="math inline"><em>m</em>(<em>x</em>)</span>乘以<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup></span>，即左移<span class="math inline">(<em>n</em> − <em>k</em>)</span>位</li><li>将<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)</span>除以<span class="math inline"><em>g</em>(<em>x</em>)</span> ，得到余式<span class="math inline"><em>r</em>(<em>x</em>)</span></li><li>得到系统循环码的码多项式：<span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)</span></li><li>将码多项式转换为码字。</li></ol></li><li><strong>系统码的生成矩阵</strong><ul><li>系统形式的生成矩阵 <span class="math inline"><em>G</em> = [<em>I</em>|<em>P</em>]</span></li><li><span class="math display">$$G(x)=\begin{bmatrix}x^{n-1} +p_{n-k}(x)\\x^{n-2} + p_{n-k-1}(x)\\\vdots\\x^{n-k+1} +p_1(x)\\x^{n-k}  + p_0(x)\end{bmatrix}_{k \times n}$$</span> 其中<span class="math display"><em>p</em><sub><em>i</em></sub>(<em>x</em>) = <em>x</em><sup><em>i</em> + (<em>n</em> − <em>k</em>)</sup>&nbsp;mod &nbsp;(<em>g</em>(<em>x</em>))</span></li></ul></li></ul></li><li><strong>示例</strong>：一个长度<span class="math inline"><em>n</em> = 7</span>的循环码的构造方法<ol type="1"><li><p><strong>求一种<span class="math inline">(7, 4)</span>循环码</strong></p><ol type="1"><li>对<span class="math inline"><em>x</em><sup>7</sup> + 1</span>作因式分解： <span class="math inline"><em>x</em><sup>7</sup> + 1 = (<em>x</em> + 1)(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1)(<em>x</em><sup>3</sup> + <em>x</em> + 1)</span>，故<span class="math inline"><em>x</em><sup>7</sup> + 1</span>有如下因式：<ul><li>一次因式：<span class="math inline"><em>x</em> + 1</span>（一个）</li><li>三次因式：<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em> + 1</span>，<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>（两个）</li><li>四次因式：<span class="math inline">(<em>x</em> + 1)(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1) = <em>x</em><sup>4</sup> + <em>x</em><sup>2</sup> + <em>x</em> + 1</span>，<span class="math inline">(<em>x</em> + 1)(<em>x</em><sup>3</sup> + <em>x</em> + 1) = <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>（两个）</li><li>六次因式：<span class="math inline">(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1)(<em>x</em><sup>3</sup> + <em>x</em> + 1) = <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + <em>x</em> + 1</span>（一个）</li></ul></li><li>以<span class="math inline">(<em>n</em> − <em>k</em>)</span>次因式作为生成多项式：<ul><li><span class="math inline"><em>n</em> − <em>k</em> = 1</span>，<span class="math inline"><em>k</em> = 6</span>，生成一种<span class="math inline">(7, 6)</span>循环码；</li><li><span class="math inline"><em>n</em> − <em>k</em> = 3</span>，<span class="math inline"><em>k</em> = 4</span>，生成两种<span class="math inline">(7, 4)</span>循环码；</li><li><span class="math inline"><em>n</em> − <em>k</em> = 4</span>，<span class="math inline"><em>k</em> = 3</span>，生成两种<span class="math inline">(7, 3)</span>循环码；</li><li><span class="math inline"><em>n</em> − <em>k</em> = 6</span>，<span class="math inline"><em>k</em> = 1</span>，生成一种<span class="math inline">(7, 1)</span>循环码。</li></ul></li></ol><ul><li><p>求一种<span class="math inline">(7, 4)</span>循环码，可选<span class="math inline"><em>n</em> − <em>k</em> = 3</span>次多项式<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>或<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em> + 1</span>为生成多项式。以选择<span class="math inline"><em>g</em>(<em>x</em>) = <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>为例，<span class="math inline"><em>n</em> − <em>k</em> = 3</span>，<span class="math inline"><em>k</em> = 4</span>（信息位为<span class="math inline">4</span> ）。 设信息多项式为<span class="math display"><em>m</em>(<em>x</em>) = <em>m</em><sub>3</sub><em>x</em><sup>3</sup> + <em>m</em><sub>2</sub><em>x</em><sup>2</sup> + <em>m</em><sub>1</sub><em>x</em> + <em>m</em><sub>0</sub></span></p><p>则循环码编码后的码多项式为<span class="math display"><em>c</em>(<em>x</em>) = <em>m</em>(<em>x</em>)<em>g</em>(<em>x</em>) = (<em>m</em><sub>3</sub><em>x</em><sup>3</sup> + <em>m</em><sub>2</sub><em>x</em><sup>2</sup> + <em>m</em><sub>1</sub><em>x</em> + <em>m</em><sub>0</sub>)(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1)</span></p><table><thead><tr><th><span class="math inline"><em>m</em></span></th><th><span class="math inline"><em>m</em>(<em>x</em>)</span></th><th><span class="math inline"><em>c</em>(<em>x</em>)</span></th><th><span class="math inline"><em>c</em></span></th></tr></thead><tbody><tr><td><span class="math inline">0000</span></td><td><span class="math inline">0</span></td><td><span class="math inline">0</span></td><td><span class="math inline">0000000</span></td></tr><tr><td><span class="math inline">0001</span></td><td><span class="math inline">1</span></td><td><span class="math inline"><em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span></td><td><span class="math inline">0001101</span></td></tr><tr><td><span class="math inline">0010</span></td><td><span class="math inline"><em>x</em></span></td><td><span class="math inline"><em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em></span></td><td><span class="math inline">0011010</span></td></tr><tr><td><span class="math inline">0011</span></td><td><span class="math inline"><em>x</em> + 1</span></td><td><span class="math inline"><em>x</em><sup>4</sup> + <em>x</em><sup>2</sup> + <em>x</em> + 1</span></td><td><span class="math inline">0010111</span></td></tr><tr><td><span class="math inline">0100</span></td><td><span class="math inline"><em>x</em><sup>2</sup></span></td><td><span class="math inline"><em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>2</sup></span></td><td><span class="math inline">0101100</span></td></tr><tr><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td></tr></tbody></table><p>最终得： <img src="image-80.webp" srcset="/img/loading/loading3.gif" lazyload></p></li></ul></li><li><p><strong>求<span class="math inline"><em>g</em>(<em>x</em>) = <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>，<span class="math inline"><em>k</em> = 4</span>的循环码的生成矩阵</strong>：<span class="math display">$$\begin{cases}x^3g(x)\leftrightarrow1101000\\x^2g(x)\leftrightarrow0110100\\xg(x)\leftrightarrow0011010\\g(x)\leftrightarrow0001101\end{cases}\RightarrowG=\begin{bmatrix}1101000\\0110100\\0011010\\0001101\end{bmatrix}$$</span></p><p>当循环码的生成矩阵确定后，编码规则为<span class="math display"><strong>c</strong> = <strong>m</strong><em>G</em></span></p><p>例如，当<span class="math inline"><strong>m</strong> = (1001)</span>时，<span class="math inline"><strong>c</strong> = (1001)<em>G</em> = 1100101</span>。 这与通过生成多项式计算结果相同：<span class="math inline"><em>m</em>(<em>x</em>)<em>g</em>(<em>x</em>) = (<em>x</em><sup>3</sup> + 1)(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1) = <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>2</sup> + 1</span>，对应码字也是<span class="math inline">1100101</span> 。</p></li><li><p><strong>求<span class="math inline"><em>g</em>(<em>x</em>) = <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>，<span class="math inline"><em>m</em> = (1001)</span>的系统码字。</strong></p><ol type="1"><li>计算<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)</span>：<ul><li>因为<span class="math inline"><em>n</em> = 7</span>，<span class="math inline"><em>k</em> = 4</span>，<span class="math inline"><em>m</em>(<em>x</em>) = <em>x</em><sup>3</sup> + 1</span>，所以<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) = <em>x</em><sup>3</sup>(<em>x</em><sup>3</sup> + 1) = <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup></span>。</li></ul></li><li>计算<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)</span>除以<span class="math inline"><em>g</em>(<em>x</em>)</span>的余式<span class="math inline"><em>r</em>(<em>x</em>)</span>： 用<span class="math inline"><em>x</em><sup>6</sup> + <em>x</em><sup>3</sup></span>除以<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>，通过长除法： <img src="image-81.webp" srcset="/img/loading/loading3.gif" lazyload> 得到<span class="math inline"><em>r</em>(<em>x</em>) = <em>x</em> + 1</span>。</li><li>得到系统循环码的码多项式<span class="math inline"><em>c</em>(<em>x</em>)</span>并转换为码字：<ul><li><span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>) = <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup> + <em>x</em> + 1</span>，转换为码字<span class="math inline"><em>c</em> = (1001011)</span>。</li></ul></li></ol></li><li><p><strong>求<span class="math inline">(7, 4)</span>循环码<span class="math inline"><em>g</em>(<em>x</em>) = <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>系统形式的生成矩阵</strong>：设<span class="math inline">$G=\begin{bmatrix}g_3\\g_2\\g_1\\g_0\end{bmatrix}=\begin{bmatrix}1000p_{32}p_{31}p_{30}\\0100p_{22}p_{21}p_{20}\\0010p_{12}p_{11}p_{10}\\0001p_{02}p_{01}p_{00}\end{bmatrix}$</span>，<span class="math inline">$G(x)=\begin{bmatrix}x^6 + p_3(x)\\x^5 +p_2(x)\\x^4 + p_1(x)\\x^3 + p_0(x)\end{bmatrix}$</span> 分别计算：</p><ul><li><span class="math inline"><em>p</em><sub>3</sub>(<em>x</em>) = <em>x</em><sup>6</sup>&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>x</em><sup>2</sup> + <em>x</em></span></li><li><span class="math inline"><em>p</em><sub>2</sub>(<em>x</em>) = <em>x</em><sup>5</sup>&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>x</em> + 1</span></li><li><span class="math inline"><em>p</em><sub>1</sub>(<em>x</em>) = <em>x</em><sup>4</sup>&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>x</em><sup>2</sup> + <em>x</em> + 1</span></li><li><span class="math inline"><em>p</em><sub>0</sub>(<em>x</em>) = <em>x</em><sup>3</sup>&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>x</em><sup>2</sup> + 1</span></li></ul><p>最终得到<span class="math inline">$G=\begin{bmatrix}1000110\\0100011\\0010111\\0001101\end{bmatrix}$</span></p></li></ol></li></ul><h4 id="编译码方法及其实现电路">编译码方法及其实现电路</h4><ul><li><strong>循环码的编码</strong><ul><li><strong>编码步骤</strong>：<ol type="1"><li>将信息多项式<span class="math inline"><em>m</em>(<em>x</em>)</span>乘以<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup></span>，即左移<span class="math inline">(<em>n</em> − <em>k</em>)</span>位。</li><li>将<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)</span>除以<span class="math inline"><em>g</em>(<em>x</em>)</span> ，得到余式<span class="math inline"><em>r</em>(<em>x</em>)</span></li><li>得到系统循环码的码多项式<span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)</span></li><li>将码多项式转换为码字。</li></ol></li><li><strong>用除法器实现<span class="math inline">(7, 3)</span>循环编码器</strong>： <img src="image-82.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>除法器编码示例</strong>： <img src="image-83.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>循环码的译码</strong><ul><li><strong>译码步骤</strong>：<ol type="1"><li>计算接收多项式<span class="math inline"><em>R</em>(<em>x</em>)</span>的伴随多项式<span class="math inline"><em>S</em>(<em>x</em>)</span> ，伴随式为<span class="math inline">0</span>则认为无差错</li><li>根据<span class="math inline"><em>S</em>(<em>x</em>)</span>找出相应错误图样多项式<span class="math inline"><em>e</em>(<em>x</em>)</span></li><li>将<span class="math inline"><em>e</em>(<em>x</em>)</span>和<span class="math inline"><em>R</em>(<em>x</em>)</span>模<span class="math inline">2</span>加，得到译码输出<span class="math inline"><em>ĉ</em>(<em>x</em>)</span> 。</li></ol></li><li><strong>伴随式计算及错误检测</strong>：<ul><li>设接收多项式为<span class="math inline"><em>R</em>(<em>x</em>)</span> ，码多项式为<span class="math inline"><em>c</em>(<em>x</em>)</span>，错误图样多项式为<span class="math inline"><em>e</em>(<em>x</em>)</span> ，则<span class="math display"><em>R</em>(<em>x</em>) = <em>c</em>(<em>x</em>) + <em>e</em>(<em>x</em>)</span>用生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>除<span class="math inline"><em>R</em>(<em>x</em>)</span>得伴随式<span class="math display"><em>s</em>(<em>x</em>) = <em>R</em>(<em>x</em>)&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>e</em>(<em>x</em>)&nbsp;mod &nbsp;<em>g</em>(<em>x</em>)</span><strong>可通过译码电路高效实现</strong></li></ul></li></ul></li></ul><h4 id="高莱golay码">高莱（Golay）码</h4><ul><li><strong>二进制高莱码（Golay (23,12)码）的编码</strong><ul><li>二进制高莱码是一种循环码，其生成多项式为： <span class="math display"><em>g</em>(<em>x</em>) = <em>x</em><sup>11</sup> + <em>x</em><sup>9</sup> + <em>x</em><sup>7</sup> + <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em> + 1</span></li><li><strong>编码步骤</strong>：<ol type="1"><li><strong>信息位准备</strong>：假设有12位的信息位，记为<span class="math inline"><em>m</em>(<em>x</em>)</span>。</li><li><strong>生成多项式</strong>：使用生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>。</li><li><strong>计算校验位</strong>：<ul><li>将信息位<span class="math inline"><em>m</em>(<em>x</em>)</span>左移11位（即乘以<span class="math inline"><em>x</em><sup>11</sup></span> ），得到<span class="math inline"><em>x</em><sup>11</sup><em>m</em>(<em>x</em>)</span>。</li><li>计算<span class="math inline"><em>x</em><sup>11</sup><em>m</em>(<em>x</em>)</span>除以<span class="math inline"><em>g</em>(<em>x</em>)</span>的余数<span class="math inline"><em>r</em>(<em>x</em>)</span>。</li><li>将余数<span class="math inline"><em>r</em>(<em>x</em>)</span>添加到<span class="math inline"><em>x</em><sup>11</sup><em>m</em>(<em>x</em>)</span>的末尾，得到编码后的码字<span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup>11</sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)</span>。</li></ul></li></ol></li></ul></li><li><strong>扩展高莱码（Golay (24,12)码）的编码</strong><ul><li>扩展高莱码是在二进制高莱码的基础上增加一个奇偶校验位。</li><li><strong>编码步骤</strong>：<ol type="1"><li><strong>二进制高莱码编码</strong>：首先使用二进制高莱码的编码方法，生成23位的码字<span class="math inline"><em>c</em>(<em>x</em>)</span> 。</li><li><strong>计算奇偶校验位</strong>：<ul><li>计算23位码字中1的个数。</li><li>如果1的个数为奇数，则添加1作为奇偶校验位；如果为偶数，则添加0。</li></ul></li><li><strong>生成扩展码字</strong>：将奇偶校验位添加到23位码字的末尾，得到24位的扩展高莱码。</li></ol></li></ul></li></ul><h4 id="循环冗余校验cyclic-redundancy-checkcrc">循环冗余校验（CyclicRedundancy Check，CRC）</h4><ul><li><strong>原理</strong>：<ul><li>把数据视作二进制数<span class="math inline"><em>D</em></span></li><li>确定校验序列长度<span class="math inline"><em>r</em></span></li><li>选择长度为<span class="math inline"><em>r</em> + 1</span>的生成序列<span class="math inline"><em>G</em></span></li><li><span class="math inline"><em>D</em></span>后面添加<span class="math inline"><em>r</em></span>个<span class="math inline">0</span>后除以<span class="math inline"><em>G</em></span> ，余数为校验序列<span class="math inline"><em>R</em></span></li><li>将<span class="math inline"><em>R</em></span>附加在<span class="math inline"><em>D</em></span>后面作为实际传输数据。</li><li><strong>检错</strong>：接收方将接收到的数据除以<span class="math inline"><em>G</em></span> ，若余数为<span class="math inline">0</span> ，则认为无出错，否则认为传输出错</li></ul></li><li><strong>特点</strong>：可检测长度小于<span class="math inline"><em>r</em> + 1</span> bits的所有突发错误。<img src="image-84.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>CRC示例</strong>：<img src="image-85.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>常用CRC版本</strong>：<img src="image-86.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>CRC有效性</strong>：<img src="image-87.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h1 id="第六章补充-信道编码">第六章补充 信道编码</h1><p><img src="image-52.webp" srcset="/img/loading/loading3.gif" lazyload></p><h2 id="译码规则和译码错误概率">译码规则和译码错误概率</h2><ul><li>已知信道转移错误概率 <span class="math inline"><em>p</em> = 0.9</span>，转移情况如下：<img src="image-53.webp" srcset="/img/loading/loading3.gif" lazyload><ul><li>若规定：<ul><li><span class="math inline"><em>Y</em> = 0 → <em>X̂</em> = 0</span></li><li><span class="math inline"><em>Y</em> = 1 → <em>X̂</em> = 1</span></li><li>即 <span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = <em>x</em><sub>1</sub></span>，<span class="math inline"><em>F</em>(<em>y</em><sub>2</sub>) = <em>x</em><sub>2</sub></span>，则译码错误概率<span class="math inline"><em>P</em><sub><em>e</em></sub> = 0.9</span>。</li></ul></li><li>反之若：<ul><li><span class="math inline"><em>Y</em> = 0 → <em>X̂</em> = 1</span></li><li><span class="math inline"><em>Y</em> = 1 → <em>X̂</em> = 0</span></li><li>即 <span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = <em>x</em><sub>2</sub></span>，<span class="math inline"><em>F</em>(<em>y</em><sub>2</sub>) = <em>x</em><sub>1</sub></span>，则译码错误概率<span class="math inline"><em>P</em><sub><em>e</em></sub> = 0.1</span>。</li></ul></li></ul></li></ul><h3 id="译码规则">译码规则</h3><ul><li><strong>定义译码规则</strong>：<span class="math display"><em>F</em>(<em>y</em><sub><em>j</em></sub>) = <em>x</em><sub><em>i</em></sub>  <em>i</em> = 1, 2, ⋯, <em>n</em>；<em>j</em> = 1, 2, ⋯, <em>m</em></span></li><li>示例：<ul><li>设转移概率矩阵 <span class="math inline">$P=\begin{bmatrix}0.5&amp;0.3&amp;0.2\\0.2&amp;0.3&amp;0.5\\0.3&amp;0.3&amp;0.4\end{bmatrix}_{(n\timesm)}$</span>，共有<span class="math inline"><em>n</em><sup><em>m</em></sup></span>种译码规则，如：<ul><li>译码规则 <span class="math inline"><em>A</em></span>：<span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = <em>x</em><sub>1</sub></span>；<span class="math inline"><em>F</em>(<em>y</em><sub>2</sub>) = <em>x</em><sub>2</sub></span>；<span class="math inline"><em>F</em>(<em>y</em><sub>3</sub>) = <em>x</em><sub>3</sub></span>。</li><li>译码规则 <span class="math inline"><em>B</em></span>：<span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = <em>x</em><sub>1</sub></span>；<span class="math inline"><em>F</em>(<em>y</em><sub>2</sub>) = <em>x</em><sub>3</sub></span>；<span class="math inline"><em>F</em>(<em>y</em><sub>3</sub>) = <em>x</em><sub>2</sub></span>。</li><li><span class="math inline">⋯</span></li></ul></li></ul></li></ul><h3 id="错误概率">错误概率</h3><ul><li>若 <span class="math inline"><em>F</em>(<em>y</em><sub><em>j</em></sub>) = <em>x</em><sub><em>i</em></sub><sup>*</sup></span>，则：<ul><li><strong>正确概率</strong>：<span class="math display"><em>p</em>(<em>F</em>(<em>y</em><sub><em>j</em></sub>)|<em>y</em><sub><em>j</em></sub>) = <em>p</em>(<em>x</em><sub><em>i</em></sub><sup>*</sup>|<em>y</em><sub><em>j</em></sub>)</span></li><li><strong>错误概率</strong>：<span class="math display"><em>p</em>(<em>e</em>|<em>y</em><sub><em>j</em></sub>) = 1 − <em>p</em>(<em>x</em><sub><em>i</em></sub><sup>*</sup>|<em>y</em><sub><em>j</em></sub>)</span></li><li><strong>平均错误概率</strong>： <span class="math display">$$  \begin{align*}  P_e &amp;= E[p(e|y_j)]\\  &amp;=\sum_{j = 1}^{m}p(y_j)p(e|y_j)\\  &amp;=\sum_{j = 1}^{m}p(y_j)(1 - p(x_i^*|y_j))\\  &amp;=\sum_{j = 1}^{m}p(y_j)-\sum_{j = 1}^{m}p(x_i^*,y_j)\\  &amp;=1-\sum_{j = 1}^{m}p(x_i^*,y_j)\\  &amp;=\sum_{Y, X-X^*}p(x,y)  \end{align*}  $$</span></li></ul></li></ul><h3 id="最佳译码规则">最佳译码规则</h3><ul><li><p>最佳译码就是使平均错误概率最小 <span class="math display">$$P_e=\sum_{j = 1}^{m}p(y_j)p(e|y_j)$$</span></p><p>只需使 <span class="math inline"><em>p</em>(<em>e</em>|<em>y</em><sub><em>j</em></sub>)</span>最小（<span class="math inline"><em>j</em> = 1, 2, ⋯, <em>m</em></span>），而 <span class="math inline"><em>p</em>(<em>e</em>|<em>y</em><sub><em>j</em></sub>) = 1 − <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>) = 1 − <em>p</em>(<em>F</em>(<em>y</em><sub><em>j</em></sub>)|<em>y</em><sub><em>j</em></sub>)</span>。</p><p>因此，<strong>最佳译码</strong>规则 <span class="math inline"><em>F</em>(<em>y</em><sub><em>j</em></sub>) = <em>x</em><sup>*</sup></span>，满足<span class="math display"><em>p</em>(<em>x</em><sup>*</sup>|<em>y</em><sub><em>j</em></sub>) ≥ <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>),  <em>i</em> = 1, 2, ⋯, <em>n</em></span></p></li></ul><h4 id="最大后验概率译码">最大后验概率译码</h4><ul><li>最大后验概率译码满足最佳译码规则：<span class="math display"><em>x</em><sup>*</sup> = arg max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span></li><li><span class="math display">$$  F:\left\{  \begin{array}{l}  F(b_j)=a_j^*\in A, b_j\in B\\  P(a_j^*|b_j)\geq P(a_i|b_j), a_i\in A  \end{array}  \right.  $$</span></li></ul><h4 id="最大联合概率译码">最大联合概率译码</h4><ul><li><p>根据贝叶斯公式<span class="math inline">$p(x_i|y_j)=\frac{p(y_j|x_i)p(x_i)}{p(y_j)}$</span>：<span class="math display">$$\max_{x_i} p(x_i|y_j) = \max_{x_i}\frac{p(y_j|x_i)p(x_i)}{p(y_j)}$$</span></p></li><li><p>则<strong>最大联合概率译码</strong>为： <span class="math display"><em>x</em><sup>*</sup> = arg max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)<em>p</em>(<em>x</em><sub><em>i</em></sub>)</span></p></li><li><p><span class="math display">$$  F:\left\{  \begin{array}{l}  F(b_j)=a_j^*\in A, b_j\in B\\  P(a_j^*, b_j)\geq P(a_i, b_j), a_i\in A  \end{array}  \right.  $$</span></p></li></ul><h4 id="最大似然译码">最大似然译码</h4><ul><li><p>当<span class="math inline">$p(x_i)=\frac{1}{n}$</span>时，即<strong>信源符号等概率分布时</strong>，有<strong>最大似然译码</strong>：<span class="math display"><em>x</em><sup>*</sup> = arg max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span></p></li><li><p><span class="math display">$$  F:\left\{  \begin{array}{l}  F(b_j)=a_j^*\in A, b_j\in B\\  P(b_j|a_j^*)\geq P(b_j|a_i), a_i\in A  \end{array}  \right.  $$</span></p></li><li><p><strong>示例</strong>：已知转移概率矩阵<span class="math inline">$P =      \begin{bmatrix}      \frac{1}{2}&amp;\frac{1}{3}&amp;\frac{1}{6}\\      \frac{1}{6}&amp;\frac{1}{2}&amp;\frac{1}{3}\\      \frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{2}      \end{bmatrix}$</span>，且<span class="math inline">$p(x_1)=p(x_2)=p(x_3)=\frac{1}{3}$</span>，则：</p><ul><li><span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = arg max (<em>p</em>(<em>y</em><sub>1</sub>|<em>x</em><sub>1</sub>), <em>p</em>(<em>y</em><sub>1</sub>|<em>x</em><sub>2</sub>), <em>p</em>(<em>y</em><sub>1</sub>|<em>x</em><sub>3</sub>)) = <em>x</em><sub>1</sub></span></li><li><span class="math inline">$F(y_2)=\arg\max(\frac{1}{3},\frac{1}{2},\frac{1}{6})= x_2$</span></li><li><span class="math inline"><em>F</em>(<em>y</em><sub>3</sub>) = <em>x</em><sub>3</sub></span></li><li><strong>译码规则A</strong>：<span class="math inline">$\begin{cases}F(y_1)=x_1\\F(y_2)=x_2\\F(y_3)=x_3\end{cases}$</span>，为最佳译码规则此时<span class="math inline">$P_e=\frac{1}{3}(\frac{1}{3}+\frac{1}{6}+\frac{1}{3}+\frac{1}{6}+\frac{1}{3}+\frac{1}{6})=\frac{1}{2}$</span></li><li><strong>译码规则B</strong>：<span class="math inline">$\begin{cases}F(y_1)=x_1\\F(y_2)=x_3\\F(y_3)=x_2\end{cases}$</span>此时<span class="math inline">$P_e=\frac{1}{3}(\frac{1}{6}+\frac{1}{3}+\frac{1}{3}+\frac{1}{2}+\frac{1}{6}+\frac{1}{2})=\frac{2}{3}$</span></li><li><strong>结论：最佳译码规则的错误概率最小</strong></li></ul></li></ul><h4 id="最小汉明距离译码">最小汉明距离译码</h4><ul><li><span class="math display">$$\hat{C}_i=\arg\max_{1\leq i\leqM}p(\vec{r_{}}|\vec{C_{0}})p(\vec{C_{0}}),\quad M = q^k$$</span></li><li>在二进制对称信道（BSC）中：<ul><li><span class="math inline">$p(\vec{r_{}}|\vec{C_{0}})=\prod_{j =1}^{n}p(r_j|c_{ij})$</span> ，且 <span class="math inline">$p(r_j|c_{ij}) =  \begin{cases}  p, &amp; c_{ij} \neq r_j \\  1 - p, &amp; c_{ij} = r_j  \end{cases}$</span>，其中<span class="math inline">$p=P_e&lt;\frac{1}{2}$</span>。</li><li>进一步推导可得<span class="math display">$$p(\vec{r_{}}|\vec{C_{0}})=\prod_{j =1}^{n}p(r_j|c_{ij})=p^d(1 - p)^{n - d}=(\frac{p}{1 - p})^d(1 -p)^n$$</span></li><li>其中 <span class="math display">$$d =dis(\vec{r_{}},\vec{C_{0}})=w(\vec{r_{}}\oplus\vec{C_{0}})=\sum_{j =1}^{n}r_j\oplus c_{ij}$$</span> 即 <span class="math inline">$\vec{r_{}}$</span> 与 <span class="math inline">$\vec{C_{0}}$</span> 的汉明距离。</li><li>由于 <span class="math inline">$\frac{p}{1 - p} \leq 1$</span>，<span class="math inline">(1 − <em>p</em>)<sup><em>n</em></sup></span>是常数，所以 <span class="math inline"><em>d</em></span> 越大，<span class="math inline">$p(\vec{r_{}}|\vec{C_{0}})$</span> 越小。求 <span class="math inline">$\max p(\vec{r_{}}|\vec{C_{0}})$</span>的问题就转化成求最小汉明距离问题。</li></ul></li></ul><h3 id="译码错误与信道条件的关系">译码错误与信道条件的关系</h3><ul><li><p>译码时发生的错误是由信道中噪声引起的，错误概率 <span class="math inline"><em>P</em><sub><em>e</em></sub></span> 与信道疑义度<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span>满足以下关系（<strong>费诺不等式</strong>）： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>P</em><sub><em>e</em></sub>) + <em>P</em><sub><em>e</em></sub>log (<em>n</em> − 1)</span></p></li><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  右式=&amp;H(P_e, 1 - P_e) + P_e \log (n - 1)\\  =&amp;P_e \log \frac{1}{P_e} + (1 - P_e) \log \frac{1}{1 - P_e} + P_e\log (n - 1)\\  =&amp;\sum_{Y, X - X^*} p(x, y) \log \frac{n - 1}{P_e} + \sum_{Y}p(x^*, y) \log \frac{1}{1 - P_e}  \end{align*}  $$</span></p><p><span class="math display">$$  \begin{align*}  左式=&amp;H(X|Y)\\  =&amp;\sum_{x, y} p(x, y) \log \frac{1}{p(x|y)}\\  =&amp;\sum_{Y, X - X^*} p(x, y) \log \frac{1}{p(x|y)} + \sum_{Y}p(x^*, y) \log \frac{1}{p(x^*|y)}  \end{align*}  $$</span></p><p>因此： <span class="math display">$$  \begin{align*}  &amp;H(X|Y) - H(P_e) - P_e \log (n - 1)\\  =&amp;\sum_{Y, X - X^*} p(x, y) \log \frac{P_e}{(n - 1) p(x|y)} +\sum_{Y} p(x^*, y) \log \frac{1 - P_e}{p(x^*|y)}\\  \leq&amp;\sum_{Y, X - X^*} p(x, y) \left[\frac{P_e}{(n - 1) p(x|y)} -1\right] + \sum_{Y} p(x^*, y) \left[\frac{1 - P_e}{p(x^*|y)} -1\right]\\  &amp;(利用\log x \leq x - 1放缩)\\  =&amp;\frac{P_e}{n - 1} \underbrace{\sum_{Y, X - X^*} p(y)}_{= n - 1}- \underbrace{\sum_{Y, X - X^*} p(x, y)}_{= P_e} + (1 - P_e) \sum_{Y}p(y) - (1 - P_e)\\  =&amp;P_e - P_e + (1 - P_e) - (1 - P_e)\\  =&amp;0  \end{align*}  $$</span></p><p>由此可得： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>P</em><sub><em>e</em></sub>) + <em>P</em><sub><em>e</em></sub>log (<em>n</em> − 1)</span></p><p><span class="math display">$$P_e \geq \frac{H(X|Y) - 1}{\log (n -1)}$$</span></p></li></ul><h2 id="信道编码定理-2">信道编码定理</h2><p><img src="image-54.webp" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="错误概率与编码方法">错误概率与编码方法</h3><ul><li>转移概率如图：<img src="image-55.webp" srcset="/img/loading/loading3.gif" lazyload></li><li>采用<strong>简单重复编码</strong>，<span class="math inline"><em>k</em> = 1</span> ，<span class="math inline"><em>n</em> = 3</span> ，则<span class="math inline">0 → 000</span>（<span class="math inline">$\vec{C_{1}}$</span>），<span class="math inline">1 → 111</span>（<span class="math inline">$\vec{C_{2}}$</span>）</li><li>已知信道转移概率 <span class="math inline"><em>p</em> = 0.01</span>，<span class="math inline">$\overline{p}=1-p=0.99$</span>，转移概率矩阵：<img src="image-56.webp" srcset="/img/loading/loading3.gif" lazyload> <!-- $$P =\begin{bmatrix}      & 000(r_1)  & 001(r_2)  & 010(r_3)  & 011(r_4)  & 100(r_5)  & 101(r_6)  & 110(r_7)  & 111(r_8)\\  000 & (1-p)^3   & (1-p)^2p  & (1-p)^2p  & p^2(1-p)  & (1-p)^2p  & p^2(1-p)  & p^2(1-p)  & p^3\\  111 & p^3       & p^2(1-p)  & p^2(1-p)  & (1-p)^2p  & p^2(1-p)  & (1-p)^2p  & (1-p)^2p  & (1-p)^3  \end{bmatrix}$$ --></li><li>译码规则为 <span class="math inline">$F(\vec{r_{1}})=\vec{C_{1}}$</span> ，<span class="math inline">$F(\vec{r_{2}})=\vec{C_{1}}$</span> ，<span class="math inline">$F(\vec{r_{3}})=\vec{C_{1}}$</span> ，<span class="math inline">$F(\vec{r_{4}})=\vec{C_{2}}$</span> ，<span class="math inline">$F(\vec{r_{5}})=\vec{C_{1}}$</span> ，<span class="math inline">$F(\vec{r_{6}})=\vec{C_{2}}$</span> ，<span class="math inline">$F(\vec{r_{7}})=\vec{C_{2}}$</span> ，<span class="math inline">$F(\vec{r_{8}})=\vec{C_{2}}$</span> 。</li><li>错误概率 <span class="math display">$$P_e=\frac{1}{2}[p^3 + p^2(1 -p)+(1 - p)p^2 + p^2(1 - p)+p(1 - p)^2 + p^2(1 - p)+p(1 - p)^2 +p^3]\approx3\times10^{-4}$$</span></li><li>增大 <span class="math inline"><em>n</em></span>，会继续降低平均错误概率 <span class="math inline"><em>P</em><sub><em>e</em></sub></span> ：<ul><li><span class="math inline"><em>n</em> = 1</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> = 0.01</span>；</li><li><span class="math inline"><em>n</em> = 3</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 3 × 10<sup>−4</sup></span>；</li><li><span class="math inline"><em>n</em> = 5</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 10<sup>−5</sup></span>；</li><li><span class="math inline"><em>n</em> = 6</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 4 × 10<sup>−7</sup></span>；</li><li><span class="math inline"><em>n</em> = 9</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 10<sup>−8</sup></span>；</li><li><span class="math inline"><em>n</em> = 11</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 5 × 10<sup>−10</sup></span>。</li></ul></li><li>信息传输率 <span class="math inline">$R=\frac{H(X)}{n}=\frac{\logM}{n}=\frac{k}{n}\text{ bit/符号}$</span> 。随着 <span class="math inline"><em>n</em></span>增大，信息传输率减小。思考是否能找到一种编码方法，使 <span class="math inline"><em>P</em><sub><em>e</em></sub></span> 充分小，且<span class="math inline"><em>R</em></span> 维持在一定水平？</li></ul><h3 id="有噪信道编码定理香农第二定理">有噪信道编码定理（香农第二定理）</h3><h4 id="信道编码正定理">信道编码正定理</h4><ul><li><strong>定理</strong>：设有一离散无记忆平稳信道，其信道容量为 <span class="math inline"><em>C</em></span> ，只要待传送的信息率 <span class="math inline"><em>R</em> &lt; <em>C</em></span>，则存在一种编码，当输入长度 <span class="math inline"><em>n</em></span>足够大时，译码错误概率任意小。</li><li><strong>证明</strong>：<ul><li><p>消息序列长度为 <span class="math inline"><em>k</em></span>，个数为 <span class="math inline"><em>M</em> = 2<sup><em>k</em></sup></span> ，码长为<span class="math inline"><em>n</em></span> 。记信息传输率 <span class="math inline">$R=\frac{\log M}{n}=\frac{\log 2^k}{n}=\frac{k}{n}=C- \varepsilon$</span> （<span class="math inline"><em>ε</em> &gt; 0</span>），则 <span class="math inline"><em>k</em> = <em>n</em>(<em>C</em> − <em>ε</em>)</span>，<span class="math inline"><em>M</em> = 2<sup><em>n</em>(<em>C</em> − <em>ε</em>)</sup></span>。<strong>只需证当<span class="math inline"><em>n</em> → ∞</span> 时，可使 <span class="math inline"><em>P</em><sub><em>e</em></sub> → 0</span>。</strong></p></li><li><p><strong>编码</strong>：从 <span class="math inline">2<sup><em>n</em></sup></span> 个矢量集中找出 <span class="math inline">2<sup><em>n</em>(<em>C</em> − <em>ε</em>)</sup></span>个码字组成一组码。</p></li><li><p><strong>BSC信道</strong>：错误概率 <span class="math inline">$p&lt;\frac{1}{2}$</span> ，信道容量 <span class="math inline"><em>C</em> = 1 − <em>H</em>(<em>p</em>)</span>。</p></li><li><p>设发送码字 <span class="math inline">$\vec{C_{0}}$</span>，接收到 <span class="math inline">$\vec{r_{}}$</span> ，<span class="math inline">$\vec{C_{0}}$</span> 与 <span class="math inline">$\vec{r_{}}$</span> 之间的平均汉明距离为 <span class="math inline"><em>n</em><em>p</em></span> 。</p></li><li><p><strong>译码方法</strong>：以 <span class="math inline">$\vec{r_{}}$</span> 为球心，以 <span class="math inline"><em>n</em><em>p</em></span> 为半径的球体内寻找码字<span class="math inline">$\vec{C_{0}}$</span>。为保证译码可靠，将球体稍微扩大，令半径为 <span class="math inline"><em>n</em>(<em>p</em> + <em>ε</em>) = <em>n</em><em>p</em><sub><em>ε</em></sub></span>，<span class="math inline"><em>ε</em> &gt; 0</span> 任意小，用 <span class="math inline"><em>S</em>(<em>n</em><em>p</em><sub><em>ε</em></sub>)</span>表示这个球体。如果球体内只有一个唯一的码字，则判定这个码字为发送的码字<span class="math inline">$\vec{C_{0}}$</span> 。</p></li><li><p><strong>译码错误概率 <span class="math inline"><em>P</em><sub><em>e</em></sub></span>表达式</strong>： <span class="math display">$$  \begin{align*}  P_e &amp;= P\{\vec{C_{0}}\notinS(np_{\varepsilon})\}+P\{\vec{C_{0}}\in S(np_{\varepsilon})\}\cdotP\{\text{找到一个其他码字}\in S(np_{\varepsilon})\}\\  &amp;\leq P\{\vec{C_{0}}\notinS(np_{\varepsilon})\}+P\{\text{找到一个其他码字}\inS(np_{\varepsilon})\}  \end{align*}  $$</span></p></li><li><p>根据大数定理，<span class="math inline">$\vec{C_{0}}$</span> 与<span class="math inline">$\vec{r_{}}$</span> 之间的汉明距离（即 <span class="math inline">$\vec{C_{0}}$</span>在信道传输中错误比特数）超过平均值 <span class="math inline"><em>n</em>(<em>p</em> + <em>ε</em>)</span>的概率很小。因此当 <span class="math inline"><em>n</em></span>足够大时： <span class="math display">$$P\{\vec{C_{0}}\notinS(np_{\varepsilon})\} &lt; \delta$$</span></p><p><span class="math display">$$  \begin{align*}  P\{\text{至少有一个其他码字} \in S(np_{\varepsilon})\} &amp;\leq\sum_{\vec{C_{i}} \neq \vec{C_{0}}} P\{\vec{C_{i}} \inS(np_{\varepsilon})\} \\  &amp;\leq (M - 1)P\{\vec{C_{*}} \in S(np_{\varepsilon})\}  \end{align*}  $$</span> 其中 <span class="math inline">$P\{\vec{C_{i}} \inS(np_{\varepsilon})\} = \max_{\vec{C_{i}} \neq \vec{C_{0}}}P\{\vec{C_{i}} \in S(np_{\varepsilon})\}$</span> 。</p></li><li><p>由此可得： <span class="math display">$$P_e \leq \delta + (M -1)P\{\vec{C_{*}} \in S(np_{\varepsilon})\}$$</span> 其中<span class="math inline">$\vec{C_{*}} \neq \vec{C_{0}}$</span>，<span class="math inline">$\vec{C_{*}}$</span> 为与 <span class="math inline">$\vec{C_{0}}$</span> 距离最近的码字右式前一项与编码无关，后一项依赖于码字的选择。</p></li><li><p><strong>随机编码</strong>：从 <span class="math inline">2<sup><em>n</em></sup></span>个可能的序列中，随机选取 <span class="math inline"><em>M</em></span>个作为有效码字。每次选一个码字有 <span class="math inline">2<sup><em>n</em></sup></span> 种可能，选 <span class="math inline"><em>M</em></span> 个码字，共有 <span class="math inline">2<sup><em>n</em><em>M</em></sup></span>种不同的编码方式。</p><ul><li>对于每一种编码方式都有： <span class="math display">$$P_e \leq\delta + (M - 1)P\{\vec{C_{*}} \in S(np_{\varepsilon})\},\quad\vec{C_{*}} \neq \vec{C_{0}}$$</span></li><li>对 <span class="math inline">2<sup><em>n</em><em>M</em></sup></span>种可能的编码取平均： <span class="math display">$$E[P_e] \leq \delta +(M - 1)E[P\{\vec{C_{*}} \in S(np_{\varepsilon})\}]$$</span></li><li>于是，所有可能落在 <span class="math inline"><em>S</em>(<em>n</em><em>p</em><sub><em>ε</em></sub>)</span>内的序列总数为： <span class="math display">$$N(np_{\varepsilon}) =C_{n}^{0} + C_{n}^{1} + C_{n}^{2} + \cdots + C_{n}^{np_{\varepsilon}} =\sum_{k = 0}^{np_{\varepsilon}} C_{n}^{k}$$</span></li><li>则 <span class="math display">$$E[P\{\vec{C_{*}} \inS(np_{\varepsilon})\}] = \frac{N(np_{\varepsilon})}{2^{n}} = \sum_{k =0}^{np_{\varepsilon}} C_{n}^{k}/2^{n}$$</span></li></ul></li><li><p>引用二项式系数不等式 <span class="math inline">$\sum_{k =0}^{np_{\varepsilon}} C_{n}^{k} \leq 2^{nH(p_{\varepsilon})}$</span>（<span class="math inline">$p_{\varepsilon} &lt;\frac{1}{2}$</span>），可得：<span class="math display">$$E[P_e] \leq\delta + M2^{-n[1 - H(p_{\varepsilon})]}\quad (p_{\varepsilon} &lt;\frac{1}{2})$$</span></p><ul><li>式中 <span class="math display">$$  \begin{align*}  1 - H(p_{\varepsilon}) &amp;= 1 - H(p + \varepsilon)\\  &amp;= 1 - H(p) + H(p) - H(p + \varepsilon)\\  &amp;= C - [H(p + \varepsilon) - H(p)]  \end{align*}  $$</span></li><li>因为 <span class="math inline"><em>H</em>(<em>p</em>)</span> 是<span class="math inline"><em>p</em></span> 的上凸函数，所以有： <span class="math display">$$  \begin{align*}  H(p + \varepsilon) &amp;\leq H(p) + \varepsilon\frac{dH(p)}{dp}\\  &amp;\leq H(p) + \varepsilon\log\frac{1 - p}{p} \quad (p &lt;\frac{1}{2}, \log\frac{1 - p}{p} &gt; 0)  \end{align*}  $$</span></li><li>进而可得 <span class="math inline">$1 - H(p_{\varepsilon}) \geq C -\varepsilon\log\frac{1 - p}{p}$</span> 。</li><li>令 <span class="math inline">$\varepsilon_1 = \varepsilon\log\frac{1- p}{p}$</span> ，<span class="math inline"><em>M</em> = 2<sup><em>n</em>(<em>C</em> − <em>ε</em><sub>2</sub>)</sup></span>，则： <span class="math display"><em>E</em>[<em>P</em><sub><em>e</em></sub>] ≤ <em>δ</em> + 2<sup><em>n</em>(<em>C</em> − <em>ε</em><sub>2</sub>) − <em>n</em>(<em>C</em> − <em>ε</em><sub>1</sub>)</sup> = <em>δ</em> + 2<sup>−<em>n</em>(<em>ε</em><sub>2</sub> − <em>ε</em><sub>1</sub>)</sup></span></li><li>式中 <span class="math inline">$\varepsilon_2 - \varepsilon_1 =\varepsilon_2 - \varepsilon\log\frac{1 - p}{p}$</span> ，只要 <span class="math inline"><em>ε</em></span> 足够小，总能满足 <span class="math inline"><em>ε</em><sub>2</sub> − <em>ε</em><sub>1</sub> &gt; 0</span>。当 <span class="math inline"><em>n</em> → ∞</span> 时，<span class="math inline"><em>E</em>[<em>P</em><sub><em>e</em></sub>] → 0</span>。</li></ul></li><li><p>因为 <span class="math inline"><em>E</em>[<em>P</em><sub><em>e</em></sub>]</span>是对所有 <span class="math inline">2<sup><em>n</em><em>M</em></sup></span>种随机编码求导的平均值，所以必然存在一些码字错误概率 <span class="math inline"> &lt; <em>E</em>[<em>P</em><sub><em>e</em></sub>]</span>。故必存在一种编码，当 <span class="math inline"><em>n</em> → ∞</span>时， <span class="math inline"><em>P</em><sub><em>e</em></sub> → 0</span>。</p></li></ul></li></ul><h4 id="信道编码逆定理">信道编码逆定理</h4><ul><li><strong>逆定理</strong>：设有一离散无记忆平稳信道，其信道容量为<span class="math inline"><em>C</em></span> 。对于任意 <span class="math inline"><em>ε</em> &gt; 0</span> ，若选用码字总数 <span class="math inline"><em>M</em> = 2<sup><em>n</em>(<em>C</em> + <em>ε</em>)</sup></span>（信息传输率<span class="math inline">$R=\frac{\log M}{n}=C +\varepsilon&gt;C$</span>），则无论 <span class="math inline"><em>n</em></span>取多大，也找不到一种码，使译码错误概率 <span class="math inline"><em>P</em><sub><em>e</em></sub></span> 任意小。</li><li><strong>证明</strong>：<ul><li>已知信息传输率 <span class="math inline">$R=\frac{\log M}{n}=C +\varepsilon$</span> ，其中 <span class="math inline"><em>M</em> = 2<sup><em>n</em>(<em>C</em> + <em>ε</em>)</sup></span>为码字总数。</li><li>假设 <span class="math inline"><em>M</em></span> 个码字等概率分布<span class="math display"><em>H</em>(<em>X</em><sup><em>n</em></sup>) = log <em>M</em> = <em>n</em>(<em>C</em> + <em>ε</em>)</span><ul><li><span class="math inline"><em>n</em></span> 次扩展信道的平均互信息为<span class="math display"><em>I</em>(<em>X</em><sup><em>n</em></sup>; <em>Y</em><sup><em>n</em></sup>) = <em>H</em>(<em>X</em><sup><em>n</em></sup>) − <em>H</em>(<em>X</em><sup><em>n</em></sup>|<em>Y</em><sup><em>n</em></sup>) ≤ <em>n</em><em>C</em></span></li><li>由此可得 <span class="math display"><em>H</em>(<em>X</em><sup><em>n</em></sup>|<em>Y</em><sup><em>n</em></sup>) ≥ <em>H</em>(<em>X</em><sup><em>n</em></sup>) − <em>n</em><em>C</em> = <em>n</em><em>ε</em></span></li><li>根据费诺不等式： <span class="math display">$$  \begin{align*}  H(X^n|Y^n)&amp;\leq H(P_e,1 - P_e)+P_e\log(M - 1)\\  &amp;\leq 1+P_e\log M\\  &amp;=1+P_e n(C + \varepsilon)  \end{align*}  $$</span></li><li>由于 <span class="math inline"><em>n</em><em>ε</em> ≤ <em>H</em>(<em>X</em><sup><em>n</em></sup>|<em>Y</em><sup><em>n</em></sup>) ≤ 1 + <em>P</em><sub><em>e</em></sub><em>n</em>(<em>C</em> + <em>ε</em>)</span>，所以有： <span class="math display">$$  \begin{align*}  n\varepsilon&amp;\leq 1+P_e n(C + \varepsilon)\\  P_e&amp;\geq\frac{n\varepsilon - 1}{n(C +\varepsilon)}=\frac{\varepsilon+\frac{1}{n}}{C + \varepsilon}  \end{align*}  $$</span></li><li>当 <span class="math inline"><em>n</em> → ∞</span> 时， <span class="math inline"><em>P</em><sub><em>e</em></sub></span> 不会趋于<span class="math inline">0</span> 。</li></ul></li><li>因此，当信息传输率 <span class="math inline"><em>R</em> &gt; <em>C</em></span>时，无法完成消息的无错误传输。香农第二定理和它的逆定理表明：在任何信道中，信道容量等于进行可靠传输的最大信息传输率。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 数学 </category>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 信息论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>厝角听涛</title>
      <link href="/_posts/%E5%8E%9D%E8%A7%92%E5%90%AC%E6%B6%9B/"/>
      <url>/_posts/%E5%8E%9D%E8%A7%92%E5%90%AC%E6%B6%9B/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_01.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_02.webp&quot;);" viewBox="0 0 1000 1886"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_03.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_04.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_05.webp&quot;);" viewBox="0 0 1000 1886"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_06.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_07.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_08.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_09.webp&quot;);" viewBox="0 0 1000 1886"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_10.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_11.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_12.webp&quot;);" viewBox="0 0 1000 1886"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_13.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_14.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_15.webp&quot;);" viewBox="0 0 1000 1886"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_16.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_17.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_18.webp&quot;);" viewBox="0 0 1000 1887"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_19.webp&quot;);" viewBox="0 0 1000 1886"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./厝角听涛_20.webp&quot;);" viewBox="0 0 1000 1887"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二四映纪</title>
      <link href="/_posts/%E4%BA%8C%E5%9B%9B%E6%98%A0%E7%BA%AA/"/>
      <url>/_posts/%E4%BA%8C%E5%9B%9B%E6%98%A0%E7%BA%AA/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_01.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_02.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_03.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_04.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_05.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_06.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_07.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_08.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_09.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_10.webp&quot;);" viewBox="0 0 1000 2499"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_11.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_12.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_13.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_14.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_15.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_16.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_17.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_18.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_19.webp&quot;);" viewBox="0 0 1000 2500"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./贰肆映纪_20.webp&quot;);" viewBox="0 0 1000 2500"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成与系统结构</title>
      <link href="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
      <url>/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>许可老师</em> 2024-2025学年秋季学期教学内容进行整理，部分图片来源于网络，如有侵权请联系删除。</p></blockquote><h1 id="ch12-导论-计算机的演变和性能">Ch1~2 导论 计算机的演变和性能</h1><h2 id="计算机发展简史">计算机发展简史</h2><ul><li>第一代：真空管</li><li>第二代：晶体管</li><li>第三代：集成电路</li><li>第三代以后：超大规模集成电路</li></ul><h2 id="ias计算机">IAS计算机</h2><ul><li>1945年，冯·诺依曼提出的计算机体系结构</li></ul><h2 id="摩尔定律">摩尔定律</h2><ul><li>集成电路的集成度每年翻一倍，后修正为18个月</li><li>影响：<ul><li>集成度增加的同时单芯片成本几乎不变；</li><li>高集成度，电路短，速度快；</li><li>体积、能耗、冷却需求小；</li><li>片外互联少，可靠性高。</li></ul></li></ul><h2 id="微处理器速度">微处理器速度</h2><h3 id="芯片制造技术">芯片制造技术</h3><ul><li>当代处理器内置技术：<ul><li>流水线</li><li>分支预测</li><li>超标量执行</li><li>数据流分析</li><li>推测执行</li></ul></li></ul><h2 id="性能平衡">性能平衡</h2><ul><li>问题1：处理器比主存快太多<ol type="1"><li>提高一次性读取数据位数；</li><li>改进DRAM接口（使用cache）；</li><li>减少主存访问频度（多级cache）；</li><li>提高互联带宽（更高速的总线，改进总线层次）</li></ol></li><li>问题2：频繁操作、高吞吐量的IO与处理器间的数据传输<ol type="1"><li>提高IO设备速度；</li><li>减少IO操作频度（使用cache）；</li><li>改进IO接口（DMA）；</li><li>改进互联结构（高速总线、改变互联结构）</li></ol></li></ul><h2 id="改进芯片组成和体系结构">改进芯片组成和体系结构</h2><h3 id="提高处理器速度的方法">提高处理器速度的方法：</h3><ol type="1"><li>提高硬件速度：缩小逻辑门尺寸，提高时钟频率（CLK）<ul><li>但是时钟频率和逻辑密度的增加会造成：功率增加、RC延迟增长、内存延迟和吞吐量滞后更严重</li></ul></li><li>增加处理器与主存间高速缓存的大小和速度</li><li>改变体系结构：更复杂的指令执行逻辑，并行、流水线、超标量<ul><li>上述方法收益递减，因此目前新方向是多核</li></ul></li></ol><h2 id="计算机性能评估">计算机性能评估</h2><ol type="1"><li>时钟速度（也叫时钟频率）：传统<ul><li>缺点：不同指令需要的时钟周期不同；有流水线的处理器在相同时钟频率下执行的指令更多</li></ul></li><li>CPI（程序每条机器指令所需的平均时间周期数）：<ul><li>通常不同类指令的CPI不同</li><li><span class="math inline"><em>I</em><sub><em>c</em></sub></span>：规定时间内执行的机器指令总条数</li><li><span class="math inline"><em>C</em><em>P</em><em>I</em><sub><em>i</em></sub></span>，<span class="math inline"><em>I</em><sub><em>i</em></sub></span>：给定程序中i类指令的CPI和执行条数</li><li><span class="math inline"><em>f</em></span>：时钟频率，<span class="math display">$$τ=\frac{1}{f}$$</span></li><li>有： <span class="math display">$$  \begin{aligned}  CPI&amp;=\frac{\sum_{i=1}^{n}(CPI_i×I_i)}{I_c}\\  T&amp;=I_c×CPI×τ  \end{aligned}  $$</span></li></ul></li><li>MIPS速率（每秒执行的百万条指令的数量）：<ul><li><span class="math display">$$MIPS=\frac{I_c}{T\times10^6}=\frac{f}{CPI\times 10^6}$$</span></li><li>注：关于CPI与MIPS计算，课本p43有例题</li></ul></li><li>MFLOPS速率（每秒执行的百万次浮点运算的数量）：<ul><li>是由于CISC相比RISC，一条指令耗时更长但功能更多，用MIPS可能不合适</li><li><span class="math display">$$MFLOPS=\frac{\text{程序中执行的浮点操作数量}}{\text{执行时间}\times10^6}$$</span></li></ul></li><li>SPEC速度度量：<ul><li>以基准程序i在参照系统上的运行时间作为基准程序i的参考运行时间<span class="math inline"><em>T</em><em>r</em><em>e</em><em>f</em><sub><em>i</em></sub></span></li><li>以基准程序i在被测系统上的运行时间作为基准程序i的参考运行时间<span class="math inline"><em>T</em><em>s</em><em>u</em><em>t</em><sub><em>i</em></sub></span></li><li><span class="math display">$$r_i=\frac{Tref_i}{Tsut_i}$$</span><ul><li>是参考时间/被测时间，速度更快的机器比值更高</li></ul></li><li><span class="math display">$$r_G=(\prod_{i=1}^{n}r_i)^{\frac{1}{n}}$$</span><ul><li>作几何平均，作为被测机器的SPEC速度度量</li></ul></li></ul></li><li>SPEC频率度量：<ul><li>测量执行多个任务的吞吐量，多个基准程序的拷贝同时执行</li><li><span class="math display">$$r_i=\frac{N×Tref_i}{Tsut_i}$$</span></li><li><span class="math inline"><em>T</em><em>r</em><em>e</em><em>f</em><sub><em>i</em></sub></span>为基准程序i在参照系统上运行的时间，N是同时执行的程序数量</li><li><span class="math inline"><em>T</em><em>s</em><em>u</em><em>t</em><sub><em>i</em></sub></span>为N个基准程序在被测系统上从开始执行到全部完成所需时间</li></ul></li></ol><h2 id="amdahl定律衡量多个处理器的加速比">Amdahl定律：衡量多个处理器的加速比</h2><p><span class="math display">$$\text{加速比}=\frac{\text{增强前的性能（执行时间）}}{\text{增强后的性能（执行时间）}}=\frac{\text{程序在单处理器上的执行时间}}{\text{程序在N个并行处理器上的执行时间}}$$</span></p><p>令：<span class="math inline"><em>f</em></span>为程序中可以无限并行执行的部分，<span class="math inline">1 − <em>f</em></span>为程序中固定只能串行执行的部分，<span class="math inline"><em>T</em></span>为程序在单处理器上的执行时间，<span class="math inline"><em>N</em></span>为并行系统的处理器数，则：</p><p><span class="math display">$$Speedup=\frac{T}{T(1-f)+\frac{Tf}{N}}=\frac{1}{(1-f)+\frac{f}{N}}$$</span></p><p>结论：</p><ul><li><span class="math inline"><em>f</em></span>非常小时并行处理意义不大；</li><li><span class="math display">$$\lim_{N→∞}Speedup=\frac{1}{1-f}$$</span></li></ul><h2 id="总线数据传输率">总线数据传输率</h2><p><span class="math display">$$\text{总线数据传输率}=\frac{\text{一段时间内传输的数据量}}{\text{这段时间}}$$</span></p><h1 id="ch3-计算机功能和互连的顶层视图">Ch3计算机功能和互连的顶层视图</h1><h2 id="计算机的寄存器">计算机的寄存器</h2><ul><li>PC：程序计数器，保存下条要执行的指令的地址</li><li>IR：指令寄存器</li><li>MAR：内存地址寄存器，保存地址</li><li>MBR：内存缓冲寄存器，保存数据</li></ul><h2 id="机器周期和指令周期">机器周期和指令周期</h2><ol type="1"><li>机器周期（CPU周期）：<ul><li>定义：从寄存器中取出两个数，执行一次ALU操作，并将结果存回寄存器所需时间</li><li>人为规定的对一条指令执行过程的划分</li><li>一个机器周期一般包含了多个时钟周期，一个指令周期包含了多个机器周期；一个指令周期包含多个流水线阶段，一个流水线阶段包含了一至多个机器周期。</li></ul></li><li>指令周期：单条指令所需要的处理时间，可粗略分为取指周期和执行周期<ul><li>取指周期：<ul><li>CPU从PC获得地址并读取该地址存储的指令，PC++（除非指令修改PC），指令被加载到指令寄存器IR，CPU译指</li></ul></li><li>执行周期：<ul><li>计算操作数地址，获取操作数（从内存或IO到CPU），数据操作，数据保存（从CPU到内存或IO）</li></ul></li></ul></li></ol><figure><img src="image-29.webp" srcset="/img/loading/loading3.gif" lazyload alt="指令周期状态图"><figcaption aria-hidden="true">指令周期状态图</figcaption></figure><h2 id="中断">中断</h2><ol type="1"><li>类型：<ul><li>程序中断（溢出、除0）</li><li>CPU定时器中断</li><li>IO中断</li><li>硬件故障</li></ul></li><li>无中断程序：<ul><li>CPU必须等待IO操作完成才能执行自己的下一条指令，图中的④表示为IO操作做准备的一系列指令，⑤表示IO操作完成后用来完成操作（收尾，比如设置标志之类）的一系列指令。</li><li><figure><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="无中断程序流"><figcaption aria-hidden="true">无中断程序流</figcaption></figure></li></ul></li><li>中断：<ul><li>CPU在调用IO时仅执行④（准备代码和实际IO指令），之后马上返回用户程序。</li><li>在IO操作的过程中，CPU也在执行用户程序指令。</li><li>在IO完成IO操作后，即IO准备好接受服务后，IO向处理器发出中断请求信号。</li><li>处理器响应中断请求，挂起当前程序，执行中断处理程序（图中的⑤）。</li><li>中断处理程序执行完成后，CPU恢复用户程序的执行。</li><li><figure><img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="有中断程序流"><figcaption aria-hidden="true">有中断程序流</figcaption></figure></li></ul></li><li>中断周期：指令周期的一部分<ul><li>处理器检查是否有中断请求，若没有，则执行下一条指令；若有，则：<ul><li>挂起当前程序，保存上下文；</li><li>将PC设置为中断处理程序的起始地址；</li><li>处理中断；</li><li>恢复上下文并继续执行被中断的程序。</li></ul></li></ul></li><li>多中断：两种解决方法<ul><li>禁止中断：<ul><li>CPU在处理中断时禁止其他中断；</li><li>CPU处理完当前中断后检测是否还存在未响应的中断；</li><li>中断严格按照顺序处理。</li></ul></li><li>定义优先级：高优先级中断可中断低优先级中断，嵌套处理。</li></ul></li></ol><h2 id="计算机顶层互联">计算机顶层互联</h2><ol type="1"><li>内存：<ul><li>输入：读写控制信号，地址，数据</li><li>输出：数据</li></ul></li><li>IO模块：通过多个端口控制多个外设<ul><li>输入：读写控制信号，地址，来自计算机的数据，来自外设的数据</li><li>输出：送给CPU的数据，送给外设的数据数据，中断信号</li></ul></li><li>CPU：<ul><li>输入：指令、数据、中断信号</li><li>输出：地址、控制信号、数据</li></ul></li></ol><h2 id="计算机总线">计算机总线：</h2><p>连接两个及以上设备的共享的通信通道，一次只能有一个设备传输成功</p><ol type="1"><li>系统总线：连接主要计算机组件（CPU、M、IO）的总线<ul><li>系统总线又分为：<ul><li>数据总线：数据总线的宽度是决定系统整体性能的关键因素，称为字长。</li><li>地址总线：地址总线的位宽决定了系统可能的最大内存容量。</li><li>控制总线、控制对数据总线、地址总线的访问和应用。</li></ul></li></ul></li><li>总线类型：<ul><li>专用总线：数据线和地址线分离</li><li>复用总线：数据和地址共享线路，靠数据有效/地址有效控制。线路少，单控制复杂，性能低</li></ul></li><li>单一总线：传输延迟、总线带宽瓶颈</li><li>总线仲裁：<ul><li>不止一个模块能控制总线，但同一时刻只有一个模块能控制总线。</li><li>集中式：总线仲裁器控制总线的访问</li><li>分布式：每个模块都能宣布对总线的控制</li></ul></li><li>时序<ul><li>同步时序：时钟信号决定事件发生，一个0-1变化称为一个总线周期，通常以上升沿同步，通常一个总线周期对应一个事件。</li><li>异步时序：完全依赖线路引脚通知。</li></ul></li><li>PCI Express<ul><li>高带宽、独立于处理器的总线，可用于中间层和外设总线，为高速IO子系统提供了更好的性能。（图形、网络、磁盘控制器）</li></ul></li></ol><h1 id="ch4-cache存储器">Ch4 Cache存储器</h1><h2 id="cache的传输单位">Cache的传输单位</h2><ol type="1"><li>字：存储器组织的天然单位，存储器单次传输所能传输数据的宽度</li><li>可寻址单元：能唯一确定地址的最小单位。一般是字或字节。<ul><li>地址位数 <span class="math inline"><em>A</em></span>与可寻址单元个数 <span class="math inline"><em>N</em></span>：<span class="math inline">2<sup><em>A</em></sup> = <em>N</em></span></li></ul></li><li>传输单位：<ul><li>对主存：一次读出/写入存储器的位数，通常是数据总线宽度。</li><li>对外存：以块为单位</li></ul></li></ol><h2 id="cache访问数据单元的方式">Cache访问数据单元的方式</h2><ol type="1"><li>顺序访问：必须以特定线性顺序访问，访问时间高度变化。<ul><li>磁带</li></ul></li><li>直接访问：存储器中每个数据块有唯一地址，以此先通过块间跳转找到块，再在块内顺序搜索定位可寻址单元。访问时间变化。<ul><li>磁盘</li></ul></li><li>随机访问：存储器中每个可寻址位置都是唯一的，以此直接定位可寻址单元。访问时间固定。<ul><li>主存</li></ul></li><li>关联存取：属于随机访问类型的存储器，根据数据部分内容确定存储位置，存取时间与数据位置无关。<ul><li>Cache</li></ul></li></ol><h2 id="cache性能">Cache性能</h2><ol type="1"><li>访问时间（延迟）：<ul><li>对随机访问存储器：读写操作所需时间</li><li>对非随机访问存储器：定位时间</li></ul></li><li>存储器周期时间：随机访问存储器，访问时间+第二次访问开始前所需额外时间</li><li>传输速率：通常以 <span class="math inline"><em>b</em><em>i</em><em>t</em>/<em>s</em>(<em>b</em><em>p</em><em>s</em>)</span>为单位<ul><li>对随机： <span class="math display">$$\text{传输速率}=\frac{1}{\text{周期时间}}$$</span></li><li>对非随机：<ul><li><span class="math display">$$T_n=T_A+\frac{n}{R}$$</span></li><li><span class="math inline"><em>T</em><sub><em>n</em></sub>=</span>读/写n位的平均时间；</li><li><span class="math inline"><em>T</em><sub><em>A</em></sub>=</span>平均访问时间；</li><li><span class="math inline"><em>n</em>=</span> 位数；<span class="math inline"><em>R</em>=</span> 传输速率，以 <span class="math inline"><em>b</em><em>p</em><em>s</em></span> 为单位。</li></ul></li></ul></li></ol><h2 id="cache特性">Cache特性</h2><ul><li>越快越贵</li><li>越快越耗能</li><li>越大越慢</li><li>越大越便宜</li><li>越大越耗能</li></ul><h2 id="访问局部性原理">访问局部性原理：</h2><ul><li>在程序执行期间，CPU对指令、数据的访问往往比较集中，即在某一段时间内，CPU对某些指令或数据的访问频率较高，这种现象称为访问局部性。<ul><li>时间局部性：如果某个数据被访问过，那么在不久的将来，它很可能会再次被访问。</li><li>空间局部性：如果某个数据被访问过，那么它附近的数据很可能会被访问。</li></ul></li></ul><h2 id="存储器分层">存储器分层：</h2><ul><li>从上至下：<ul><li>容量越来越大</li><li>每位价格越来越便宜</li><li>速度越来越慢</li><li>访问频率越来越低（依赖于访问局部性原理）</li></ul></li></ul><h2 id="cache原理和操作">Cache原理和操作：</h2><ul><li>主存由多个块构成，每个块包含 <span class="math inline"><em>K</em></span> 个字。</li><li>Cache由多个块构成，每个块称为一行，每行包括 <span class="math inline"><em>K</em></span>个字以及若干位标签、控制位（行的大小为 <span class="math inline"><em>K</em></span> 个字，不算标签和控制位）。</li><li>主存和Cache之间以块为单位传输，Cache和CPU之间以字为单位传输。</li><li>Cache读操作：<ul><li>检查数据是否在Cache中；</li><li>若命中，直接访问Cache；</li><li>若缺失，从主存中加载包含这个字的块，并将这个字送到CPU中，两个操作同时发生。</li></ul></li><li>Cache写操作：<ul><li>检查数据是否在Cache中；</li><li>若命中，直接更新Cache行；</li><li>若缺失，从主存中加载包含这个字的块，并更新Cache行。</li></ul></li></ul><h2 id="主存块与cache行之间的映射方式">主存块与Cache行之间的映射方式</h2><figure><img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload alt="Cache映射"><figcaption aria-hidden="true">Cache映射</figcaption></figure><h3 id="直接映射">直接映射</h3><p><span class="math display"><em>i</em> = <em>j</em> mod &nbsp;<em>m</em></span></p><p><span class="math inline"><em>i</em>=</span> 高速缓存行号；<span class="math inline"><em>j</em>=</span> 主存块号；<span class="math inline"><em>m</em>=</span> 高速缓存行总数。</p><figure><img src="image-31.webp" srcset="/img/loading/loading3.gif" lazyload alt="直接映射"><figcaption aria-hidden="true">直接映射</figcaption></figure><ul><li>从主存来看：<ul><li>主存地址长度 = <span class="math inline">(<em>s</em> + <em>w</em>)</span> 位，其中最低 <span class="math inline"><em>w</em></span> 位指定主存的一个块内的 <span class="math inline">2<sup><em>w</em></sup></span>个字中的一个字/字节，剩下 <span class="math inline"><em>s</em></span>位指定主存内的 <span class="math inline">2<sup><em>s</em></sup></span>个块中的一块</li><li>可寻址单元个数 = <span class="math inline">2<sup>(<em>s</em> + <em>w</em>)</sup></span>个字/字节</li><li>块大小=行大小 = <span class="math inline">2<sup><em>w</em></sup></span> 个字/字节</li></ul></li><li>从Cache来看：<ul><li>主存地址最高 <span class="math inline"><em>s</em></span> 位 = 低<span class="math inline"><em>r</em></span> 位 + 高 <span class="math inline">(<em>s</em> − <em>r</em>)</span> 位，其中低 <span class="math inline"><em>r</em></span> 位指定 Cache 的 <span class="math inline">2<sup><em>r</em></sup></span> 行中的一行，高 <span class="math inline">(<em>s</em> − <em>r</em>)</span>位被当作标签存储。</li><li>Cache行数：<span class="math inline">2<sup><em>r</em></sup></span>行</li><li>Cache大小：<span class="math inline">2<sup>(<em>r</em> + <em>w</em>)</sup></span>个字/字节</li><li>标签大小：<span class="math inline">(<em>s</em> − <em>r</em>)</span>位</li><li>即：<span class="math inline">(<em>s</em> − <em>r</em>)</span>位标签 + <span class="math inline"><em>r</em></span> 位Cache内行号 =<span class="math inline"><em>s</em></span> 位主存块号</li></ul></li><li>优点：简单便宜</li><li>缺点：任何给定块都只有固定的Cache存储位置。若程序需要访问的两个块正好映射到同一行，这两个块就会不断交换，降低命中率，称为抖动。</li></ul><h3 id="全关联映射">全关联映射：</h3><p>允许每个主存块加载到任意Cache行，标签 = 主存块号</p><figure><img src="image-30.webp" srcset="/img/loading/loading3.gif" lazyload alt="全关联映射"><figcaption aria-hidden="true">全关联映射</figcaption></figure><ul><li>优点：命中率提高</li><li>缺点：访问时需要复杂电路并行检查全部行的标签</li></ul><h3 id="k路组关联映射">K路组关联映射</h3><figure><img src="image-32.webp" srcset="/img/loading/loading3.gif" lazyload alt="组关联映射"><figcaption aria-hidden="true">组关联映射</figcaption></figure><p><span class="math display">$$\begin{aligned}m=v \times k\\i=j \mod v\end{aligned}$$</span></p><p><span class="math inline"><em>i</em></span> = Cache的组号；<span class="math inline"><em>j</em></span> = 主存块号；<span class="math inline"><em>m</em></span> = Cache中的行数；<span class="math inline"><em>v</em></span> = 组数；<span class="math inline"><em>k</em></span> = 每组中的行数。</p><ul><li>从主存来看：<ul><li>主存地址长度 = <span class="math inline">(<em>s</em> + <em>w</em>)</span> 位，其中最低 <span class="math inline"><em>w</em></span> 位指定主存的一个块内的 <span class="math inline">2<sup><em>w</em></sup></span>个字中的一个字/字节，剩下 <span class="math inline"><em>s</em></span>位指定主存内的 <span class="math inline">2<sup><em>s</em></sup></span>个块中的一块</li><li>可寻址单元个数 = <span class="math inline">2<sup>(<em>s</em> + <em>w</em>)</sup></span>个字/字节</li><li>块大小 = 行大小 = <span class="math inline">2<sup><em>w</em></sup></span> 个字/字节</li></ul></li><li>从Cache来看：<ul><li>主存地址最高 <span class="math inline"><em>s</em></span> 位 = 低<span class="math inline"><em>d</em></span> 位 + 高 <span class="math inline">(<em>s</em> − <em>d</em>)</span> 位，其中低 <span class="math inline"><em>d</em></span> 位指定 Cache 的 <span class="math inline">2<sup><em>d</em></sup></span> 组中的一组，高 <span class="math inline">(<em>s</em> − <em>d</em>)</span>位被当作标签存储。</li><li>Cache组数：<span class="math inline"><em>v</em> = 2<sup><em>d</em></sup></span> 行</li><li>Cache行数：<span class="math inline"><em>m</em> = <em>k</em><em>v</em> = <em>k</em> × 2<sup><em>d</em></sup></span></li><li>Cache大小：<span class="math inline"><em>k</em> × 2<sup>(<em>d</em> + <em>w</em>)</sup></span>个字/字节</li><li>标签大小：<span class="math inline">(<em>s</em> − <em>d</em>)</span>位</li><li>即：<span class="math inline">(<em>s</em> − <em>d</em>)</span>位标签 + <span class="math inline"><em>d</em></span> 位Cache内组号 =<span class="math inline"><em>s</em></span> 位主存块号</li></ul></li><li>优点：灵活，标签较小，且只需并行比较组内的 <span class="math inline"><em>k</em></span> 个标签</li></ul><h2 id="替换算法">替换算法</h2><p>当Cache已满而又有新块需要调入，就必须替换Cache中的块。</p><ul><li>最近最少使用算法（LRU）<ul><li>替换组内在Cache中最久没有被引用过的块。以2路组关联为例，当组中一行被引用时，其USE位置1，另一行USE置0。替换时选择USE为0的行。</li></ul></li><li>先进先出算法（FIFO）<ul><li>替换组内最早进入Cache的块。</li></ul></li><li>最不经常使用（LFU）：<ul><li>替换组内使用频率最低的块。</li></ul></li><li>随机<ul><li>随机选择组内的一个块进行替换。</li></ul></li></ul><h2 id="写策略">写策略</h2><ul><li>通写（写直达）：所有写都会施加于Cache和主存。任何其他处理器和Cache都可以监视到主存的改变以维护一致性。<ul><li>优点：简单</li><li>缺点：产生大量主存流量，让写变慢</li></ul></li><li>回写：CPU写的更新仅在Cache中执行，此时USE为置1。当一个块被替换时，仅当USE位为1才会被写回主存。<ul><li>优点：最小化主存写操作</li><li>缺点：部分主存在块替换前是无效的，IO存取只能通过Cache进行。</li></ul></li></ul><h2 id="行块大小">行/块大小</h2><p>随着行大小从很小到较大，命中率先上升后下降。</p><ul><li>原因：<ul><li>行较大时Cache中行数较少；</li><li>行较大时离访问位置较远的字再次访问概率低（局部性原理）</li></ul></li></ul><h1 id="ch5-内部存储器">Ch5 内部存储器</h1><h2 id="半导体存储器类型">半导体存储器类型</h2><table><thead><tr><th>存储器类型</th><th>种类</th><th>可擦除性</th><th>写机制</th><th>易失性</th></tr></thead><tbody><tr><td>随机存储器(RAM)</td><td>读-写存储器</td><td>电，字节级</td><td>电</td><td>易失</td></tr><tr><td>只读存储器(ROM)</td><td>只读存储器</td><td>不能</td><td>掩模</td><td>不易失</td></tr><tr><td>可编程ROM(PROM)</td><td>只读存储器</td><td>不能</td><td>电</td><td>不易失</td></tr><tr><td>可擦PROM(EPROM)</td><td>读多次存储器</td><td>紫外线，字节级</td><td>电</td><td>不易失</td></tr><tr><td>电可擦PROM(EEPROM)</td><td>读多次存储器</td><td>电，字节级</td><td>电</td><td>不易失</td></tr><tr><td>快闪存储器</td><td>读多次存储器</td><td>电，块级</td><td>电</td><td>不易失</td></tr></tbody></table><p>注：SRAM和DRAM都需要持续供电。</p><h2 id="dram动态ram">DRAM（动态RAM）</h2><ul><li>数据被存储为电容上的电荷</li><li>由于电容有漏电的天性，DRAM需要定期充电（刷新）。</li><li>结构简单，成本较低，速度较慢。常用于主存。</li></ul><h2 id="sram静态ram">SRAM（静态RAM）</h2><ul><li>用触发器逻辑门存储数据</li><li>不漏电，不需要定期刷新（但也需要持续供电！）</li><li>结构更复杂，成本更高，体积更大，但速度更快。常用于Cache。</li></ul><h2 id="存储器芯片组织">存储器芯片组织</h2><ol type="1"><li>位扩展：增加存储模块单次传输所能传输的位<ul><li>N块芯片读取相同的地址，每块芯片同时输出其在相同行列位置上存储的数据（假设输出<span class="math inline"><em>m</em></span>bit），则存储模块的一个地址可以存储 <span class="math inline">(<em>N</em> × <em>m</em>)<em>b</em><em>i</em><em>t</em></span>数据。</li><li>例：位扩展前，一个芯片只能输出 <span class="math inline">1</span>bit；位扩展后，<span class="math inline">8</span>个芯片同时根据MAR信号输出 <span class="math inline">8</span>bit数据。</li><li><figure><img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload alt="位扩展"><figcaption aria-hidden="true">位扩展</figcaption></figure></li></ul></li><li>字位扩展：增加存储模块的大小（即增加存储模块能够存储的字的数量）<ul><li>假设一组芯片有 <span class="math inline"><em>N</em></span>个，存储模块由 <span class="math inline"><em>M</em></span>组芯片构成，此时地址要增加 <span class="math inline">log<sub>2</sub><em>M</em></span> bit，用于选择 <span class="math inline"><em>M</em></span> 组芯片中的一组。</li><li><figure><img src="image-4.webp" srcset="/img/loading/loading3.gif" lazyload alt="字扩展"><figcaption aria-hidden="true">字扩展</figcaption></figure></li></ul></li><li>字节级精度的访问<ul><li>存储模块一次传输能够传输 <span class="math inline"><em>N</em></span>bit数据（一般 <span class="math inline"><em>N</em></span>为8的倍数）,则可以实现字节级精度访问。需要在原地址信号的基础上添加 <span class="math inline">$\log_2 \frac{N}{8}$</span> 位地址。</li><li>以 <span class="math inline"><em>N</em> = 16</span>为例，此时地址新添加 <span class="math inline">1</span> 位作为最低位。<ul><li>若要读取 <span class="math inline">16</span>bit数据，且地址为偶数，则新添加的最低位置 <span class="math inline">0</span>，可一次读取完成。</li><li>若地址为奇数则新添加的最低位置 <span class="math inline">1</span>，需要两次读取：CPU先读取奇数地址上的 <span class="math inline">16</span> bit，只保留A9-A16芯片上的 <span class="math inline">8</span> bit作为低 <span class="math inline">8</span> bit；CPU再将地址 <span class="math inline">+1</span> 读取 <span class="math inline">16</span>bit，只保留A1-A9芯片上的 <span class="math inline">8</span> bit作为高<span class="math inline">8</span> bit。</li></ul></li></ul></li><li>数据对齐<ul><li>例如，<span class="math inline">2</span>Byte的short型变量的地址通常为偶数，<span class="math inline">4</span>Byte的int型变量的地址通常为 <span class="math inline">4</span>的倍数。</li><li>否则，读取时CPU要进行两次读取。</li></ul></li></ol><h2 id="纠错码">纠错码</h2><p>数据 <span class="math inline"><em>M</em></span> bit，校验码/纠错码<span class="math inline"><em>K</em></span> bit，实际存储 <span class="math inline">(<em>M</em> + <em>K</em>)</span> bit。</p><figure><img src="image-5.webp" srcset="/img/loading/loading3.gif" lazyload alt="纠错码"><figcaption aria-hidden="true">纠错码</figcaption></figure><h3 id="以汉明码和文氏图为例">以汉明码和文氏图为例</h3><figure><img src="image-6.webp" srcset="/img/loading/loading3.gif" lazyload alt="汉明码与文氏图!"><figcaption aria-hidden="true">汉明码与文氏图!</figcaption></figure><ul><li>初始数据为 <span class="math inline">1110</span>，放在 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>B</em></span>、<span class="math inline"><em>C</em></span> 三个圈相交位置；</li><li>在 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>B</em></span>、<span class="math inline"><em>C</em></span>三个圈中生成纠错码，满足每个圈中四个数字异或结果为 <span class="math inline">0</span>；</li><li>若传输过程中出现错误，可进行定位；</li><li>发现 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>C</em></span> 两个圈中异或结果不为 <span class="math inline">0</span>，<span class="math inline"><em>B</em></span> 异或结果为 <span class="math inline">0</span>，则错误出现在与 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>C</em></span> 相交但不与 <span class="math inline"><em>B</em></span> 相交的位置。</li></ul><h3 id="纠错码设计">纠错码设计：</h3><p>数据 <span class="math inline"><em>M</em></span> bit，校验码/纠错码<span class="math inline"><em>K</em></span> bit，实际存储 <span class="math inline">(<em>M</em> + <em>K</em>)</span>bit，则应满足：<span class="math inline">2<sup><em>K</em></sup> − 1 ≥ <em>M</em> + <em>K</em></span></p><ul><li>纠错码全 <span class="math inline">0</span> 表示 <span class="math inline">(<em>M</em> + <em>K</em>)</span> bit数据都正常，因此 <span class="math inline"><em>K</em></span> bit纠错码能表示 <span class="math inline">2<sup><em>K</em></sup> − 1</span>个数，要求 <span class="math inline"><em>K</em></span> bit纠错码必须能表示 <span class="math inline">(<em>M</em> + <em>K</em>)</span> bit数据的位置，因此有上述关系式。</li></ul><figure><img src="image-7.webp" srcset="/img/loading/loading3.gif" lazyload alt="例子"><figcaption aria-hidden="true">例子</figcaption></figure><p>具体纠错过程为：</p><ul><li>根据右图公式计算纠错码 <span class="math inline"><em>C</em>8<sup>′</sup>&nbsp;<em>C</em>4′&nbsp;<em>C</em>2′&nbsp;<em>C</em>1′</span>，与存储的原纠错码<span class="math inline"><em>C</em>8&nbsp;<em>C</em>4&nbsp;<em>C</em>2&nbsp;<em>C</em>1</span>一一异或，得到结果 <span class="math inline"><em>C</em>8′′<em>C</em>4′′<em>C</em>2′′<em>C</em>1′′</span></li><li>若只有一项异或结果为1，即只有一个纠错码与原纠错码不同，则错误出现在该纠错码上，翻转该纠错码即可。例如，若只有<span class="math inline"><em>C</em>8′′ = 1</span>，即 <span class="math inline"><em>C</em>8′′&nbsp;<em>C</em>4′′&nbsp;<em>C</em>2′′&nbsp;<em>C</em>1′′ = 1000</span>，表示位置8出错，即<span class="math inline"><em>C</em>8</span> 自身出错。</li><li>若有两项异或结果为1，即有两个纠错码与原纠错码不同，则错误出现在纠错码所表示的位置对应的数据上。例如，若<span class="math inline"><em>C</em>1′′ = <em>C</em>4′′ = 1</span>，即<span class="math inline"><em>C</em>8′′&nbsp;<em>C</em>4′′&nbsp;<em>C</em>2′′&nbsp;<em>C</em>1′′ = 0101</span>，则错误出现在位置<span class="math inline">0101</span> 对应数据，即 <span class="math inline"><em>D</em>2</span>上；从右图的公式里也可以看到，只有 <span class="math inline"><em>D</em>2</span> 能同时影响 <span class="math inline"><em>C</em>1<em>C</em>4</span>。</li></ul><h1 id="ch6-外部存储器">Ch6 外部存储器</h1><h2 id="磁盘数据组织">磁盘数据组织</h2><ol type="1"><li>磁道：一组同心圆环。相邻磁道间由磁道间隔隔开（防止相互干扰）。</li><li>扇区：最小读写单位。一个磁道通常被划分成多个扇区，相邻扇区由扇区间隔隔开。</li></ol><figure><img src="image-33.webp" srcset="/img/loading/loading3.gif" lazyload alt="磁道与扇区"><figcaption aria-hidden="true">磁道与扇区</figcaption></figure><h2 id="磁盘读写机制">磁盘读写机制</h2><p>由于角速度相同时，线速度外大内小，必须补偿，使得磁头读取所有的位的速度相同。</p><figure><img src="image-8.webp" srcset="/img/loading/loading3.gif" lazyload alt="磁盘读写机制!"><figcaption aria-hidden="true">磁盘读写机制!</figcaption></figure><ol type="1"><li>恒定角速度：增大外层扇区间隔。<ul><li>优点：构造简单，磁头移到固定位置等待扇区来即可。</li><li>缺点：浪费了外层磁道容量。</li></ul></li><li>多区段记录：每个区段包含多个磁道，区段内每个磁道位数固定，半径大的区段内的磁道比半径小的区段内的磁道容纳更多的位。同一区段的读取角速度相同，不同区段读取角速度不同。<ul><li>优点：充分利用磁道容量。</li><li>缺点：需要更复杂的电路控制角速度。</li></ul></li></ol><h2 id="寻找扇区">寻找扇区</h2><p>附加数据标记磁道和扇区，这些数据只对磁盘驱动器可见。</p><h2 id="磁头">磁头</h2><ul><li>固定磁头：一个磁道一个磁头，安装在一个固定支架上</li><li>可移动磁头：每面一个，可伸缩支架</li></ul><h2 id="多盘片">多盘片</h2><figure><img src="image-9.webp" srcset="/img/loading/loading3.gif" lazyload alt="多盘片"><figcaption aria-hidden="true">多盘片</figcaption></figure><h2 id="ssd">SSD</h2><ul><li>优点：高速启动，低噪音，机械可靠性更高</li><li>缺点：成本较高，容量较低，写入寿命较短</li></ul><h2 id="磁盘性能参数">磁盘性能参数：</h2><h3 id="传送时间">传送时间：</h3><p><span class="math display">$$T=\frac{b}{rN}$$</span></p><p>其中：</p><ul><li><span class="math inline"><em>b</em></span> = 传送的字节数；</li><li><span class="math inline"><em>r</em></span> =磁盘旋转速率（转/秒）；</li><li><span class="math inline"><em>N</em></span> = 每磁道字节数。</li></ul><h3 id="平均存取时间">平均存取时间：</h3><p><span class="math display">$$T_a=T_s+\frac{1}{2r}+\frac{b}{rN}$$</span></p><p>其中：</p><ul><li><span class="math inline"><em>T</em><sub><em>s</em></sub></span> =平均寻道时间，指磁盘移动支架使磁头对准磁道所需时间；</li><li><span class="math inline">$\frac{1}{2r}$</span> =平均旋转延迟，是磁道旋转半圈的时间。<ul><li>旋转延迟，指等待相关扇区旋转到磁头可读写位置的时间。</li></ul></li><li><span class="math inline">$\frac{b}{rN}$</span> =传送时间，指从磁道上读取或写入 <span class="math inline"><em>b</em></span> 字节所需的时间。</li></ul><h2 id="磁盘调度算法">磁盘调度算法</h2><ul><li>先来先服务算法（FCFS）：<ul><li>按照请求到达的顺序处理磁盘请求。</li><li>优点：简单，公平。</li><li>缺点：可能导致长时间等待，尤其是当请求分布不均时。</li></ul></li><li>最短寻道时间优先算法（SSTF）：<ul><li>选择距离当前磁头位置最近的请求进行处理。</li><li>优点：减少平均寻道时间。</li><li>缺点：可能导致饥饿现象，即某些请求长时间得不到处理。</li></ul></li><li>扫描算法（SCAN）：<ul><li>磁头在磁盘上来回扫描，处理沿途的请求。</li><li>优点：减少平均寻道时间，避免饥饿现象。</li><li>缺点：可能导致某些请求等待较长时间。</li></ul></li><li>循环扫描算法（C-SCAN）：<ul><li>磁头在磁盘上来回扫描，但当到达一端时，磁头直接跳到另一端继续扫描。</li><li>优点：提供更均匀的服务，避免了长时间等待。</li><li>缺点：可能导致某些请求等待较长时间。</li></ul></li></ul><h2 id="磁盘冗余阵列raid">磁盘冗余阵列（RAID）</h2><p>使用多个磁盘增加冗余提高可靠性，本质是一组物理磁盘驱动器，但被操作系统看作一整个逻辑驱动器</p><ul><li>在阵列上条带分布</li><li>冗余磁盘用于存储校验信息</li></ul><table style="width:100%;"><thead><tr><th>RAID级别</th><th>描述</th><th>数据可用性</th><th>大型I/O数据传输能力</th><th>小型I/O请求率</th><th>需要的磁盘数</th></tr></thead><tbody><tr><td>0</td><td>无冗余</td><td>无</td><td>非常高</td><td>低于单个磁盘</td><td>N</td></tr><tr><td>1</td><td>镜像</td><td>非常高</td><td>读操作可达单个磁盘的两倍；写操作与单个磁盘相同</td><td>读操作比单个磁盘高；写操作与单个磁盘相同</td><td>2N</td></tr><tr><td>2</td><td>通过海明码冗余</td><td>所有列出的选择中最高</td><td>大约是单个磁盘的两倍</td><td>远高于单个磁盘；可与RAID 3、4、5相比较</td><td>N+m（m与logN成正比）</td></tr><tr><td>3</td><td>位交叉奇偶校验</td><td>所有列出的选择中最高</td><td>远高于单个磁盘；可与RAID 2、4、5相比较</td><td>大约是单个磁盘的两倍</td><td>N+1</td></tr><tr><td>4</td><td>块交叉奇偶校验</td><td>无</td><td>远高于单个磁盘；可与RAID 2、3、5相比较</td><td>读操作与RAID 0相同；写操作明显低于单个磁盘</td><td>N+1</td></tr><tr><td>5</td><td>块交叉分布奇偶校验</td><td>高</td><td>远高于单个磁盘；可与RAID 2、3、4相比较</td><td>读操作与RAID 0相同；写操作一般低于单个磁盘</td><td>N+1</td></tr><tr><td>6</td><td>块交叉双分布奇偶校验</td><td>所有列出的选择中最高</td><td>读操作与RAID 0相同；写操作低于RAID 5</td><td>读操作与RAID 0相同；写操作明显低于RAID 5</td><td>N+2</td></tr></tbody></table><h1 id="ch7-输入输出">Ch7 输入输出</h1><h2 id="外部设备">外部设备</h2><ul><li>外部设备：计算机系统外部的设备，通常通过IO模块与计算机系统连接。</li><li>人可读的<ul><li>显示屏、打印机、键盘</li></ul></li><li>机器可读的<ul><li>磁盘（功能上是存储器，但结构上被I/O模块控制）、传感器</li></ul></li><li>通信设备<ul><li>网卡，调制解调器</li></ul></li></ul><figure><img src="image-35.webp" srcset="/img/loading/loading3.gif" lazyload alt="外部设备"><figcaption aria-hidden="true">外部设备</figcaption></figure><h2 id="io模块">IO模块</h2><ul><li>为什么需要IO模块<ul><li>各种外设操作逻辑、数据格式和字长都不一样，且运行速度比主存和CPU慢很多</li></ul></li><li>主要功能<ul><li>通过系统总线或中央交换机与CPU和内存连接；</li><li>通过定制数据线连接一至多个外设；</li><li>具体包括：控制和定时，与CPU、内存和外设通信，数据缓冲，检错</li></ul></li></ul><figure><img src="image-34.webp" srcset="/img/loading/loading3.gif" lazyload alt="IO模块"><figcaption aria-hidden="true">IO模块</figcaption></figure><h2 id="读io步骤">读IO步骤</h2><ul><li>CPU查询IO模块状态</li><li>IO返回设备状态</li><li>若设备就绪，CPU请求数据传输</li><li>IO从外设处获取数据</li><li>IO将数据放到数据总线上传给CPU</li></ul><h2 id="io设备寻址">IO设备寻址</h2><ol type="1"><li>内存映射寻址：<ul><li>内存位置和IO设备共享同一个地址空间</li><li>CPU把IO模块的状态和数据寄存器看作内存位置</li><li>访问内存和操作IO所需机器指令相同</li></ul></li><li>独立寻址：<ul><li>CPU将内存和IO模块看作两个独立的地址空间</li><li>需要IO或内存选择线控制</li><li>需要特殊的IO命令操作IO</li></ul></li></ol><h2 id="io技术">IO技术</h2><ol type="1"><li>可编程式IO：无中断，数据通过CPU传输，即IO-CPU-内存<ul><li>在IO模块操作未完成，CPU一直保持定期检查IO状态的周期，浪费CPU时间。</li></ul><figure><img src="image-36.webp" srcset="/img/loading/loading3.gif" lazyload alt="编程式IO"><figcaption aria-hidden="true">编程式IO</figcaption></figure></li><li>中断驱动式IO：有中断，数据通过CPU传输，即IO-CPU-内存<ul><li>CPU向IO模块发出命令后执行其他程序。当IO操作完成时，即IO模块就绪时，IO模块会向CPU发送中断请求，CPU响应中断请求并开始传输数据。</li><li>无需CPU一直周期性检查，克服了CPU等待的问题。</li></ul><figure><img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload alt="中断驱动式IO"><figcaption aria-hidden="true">中断驱动式IO</figcaption></figure></li><li>存储器直接存储（DMA）：有中断，数据通过DMA传输，即IO-DMA-CPU<ul><li>DMA操作：CPU通知DMA相关命令，之后CPU执行其他程序；DMA负责传输数据；DMA传输完成后，向CPU发出中断请求。</li><li>周期窃取：DMA必须在CPU不使用总线时，或迫使处理器挂起，才能够使用总线传输数据。一般地，CPU在访问总线前被挂起，DMA接管一个总线周期传输一个字，然后CPU继续访问总线。稍微降低了CPU速度，不是中断，CPU不用转换现场。</li></ul></li></ol><h2 id="中断处理">中断处理</h2><ul><li>中断认可信号是CPU告诉发出中断的IO：我已经收到了你的中断请求信号并开始处理，你可以停止发送中断请求信号了。</li><li>PSW：程序状态字，一个寄存器，存储CPU状态。</li><li>软件部分：即中断服务程序（ISR）。</li></ul><h2 id="中断请求的定位和优先级">中断请求的定位和优先级</h2><ol type="1"><li>多中断信号线法：直接在CPU与每个IO模块之间提供多中断信号线，一般不用，硬件太复杂。</li><li>软件轮询法：CPU检测到中断后，执行中断服务程序，中断服务程序挨个轮询每个IO模块，找到所有发出中断的。<ul><li>优先级：由中断服务程序决定先处理哪个。</li><li>优点：硬件简单，优先级安排、修改简单，灵活。</li><li>缺点：速度慢。</li></ul></li><li>菊花链法（硬件轮询、向量）：所有IO共享一条中断请求线，但是中断响应线以菊花链形式连接各个IO模块。<ul><li>CPU感知到中断后，发出中断响应信号，沿菊花链传播。</li><li>当中断响应信号传播到某个IO模块时：<ul><li>若该IO发出了中断，则会在数据线上放向量（一个字，IO模块的地址或唯一标识符，CPU认为其指向适合的设备服务例程）。CPU会根据向量来定位IO模块并处理中断。该IO模块的中断处理完后，才会将中断响应信号传给下个IO模块；</li><li>若该IO没有发出中断，则直接将中断响应信号传给下个IO模块；</li></ul></li><li>优先级：菊花链上游的IO模块中断优先级更高。是固定的，不灵活。</li><li>优点：速度快。</li><li>缺点：优先级固定，不灵活。</li></ul></li><li>总线仲裁（向量）：由中断控制器控制哪个IO模块能够获得总线控制权。IO模块只有获得总线控制权后才能发送中断，一次只有一个IO模块能发送中断，中断控制器检测到CPU的中断响应信号时，将发出中断的IO模块对应向量放到数据线上。</li></ol><h1 id="ch9-计算机算术">Ch9 计算机算术</h1><h2 id="整数2的补码法">整数：2的补码法</h2><ul><li><span class="math inline"><em>N</em></span>bit整数，最高位为符号位，0表示正数，1表示负数。</li><li>正数：最高位为0，剩下 <span class="math inline"><em>N</em> − 1</span> 位为二进制。</li><li>负数：先写出对应正数，然后对 <span class="math inline"><em>N</em></span> 位全部按位取反，再将其视作无符号数<span class="math inline">+1</span>。</li><li>表示范围：<span class="math inline"><em>N</em></span>bit能表示：<span class="math inline">[−2<sup><em>N</em> − 1</sup>, 2<sup><em>N</em> − 1</sup> − 1]</span>范围内的整数。</li><li>符号填充：符号位移到新最高位，空余的，对正数填全0，对负数填全1。</li></ul><h2 id="整数的加减法">整数的加减法</h2><ul><li>用加法实现减法</li><li>溢出规则：两个数相加，若他们同为正或同为负，当且仅当结果符号相反时发生上溢。</li></ul><h2 id="无符号乘法">无符号乘法</h2><figure><img src="image-10.webp" srcset="/img/loading/loading3.gif" lazyload alt="无符号乘法"><figcaption aria-hidden="true">无符号乘法</figcaption></figure><ul><li><span class="math inline"><em>M</em> × <em>Q</em> = <em>A</em><em>Q</em></span>，<span class="math inline"><em>M</em></span> 为被乘数，<span class="math inline"><em>Q</em></span> 为乘数，<span class="math inline"><em>A</em><em>Q</em></span> 为结果，由寄存器 <span class="math inline"><em>A</em></span> 和寄存器 <span class="math inline"><em>Q</em></span> 拼接而成。</li><li>每个循环，若 <span class="math inline"><em>Q</em></span>最低位为1，则将 <span class="math inline"><em>M</em></span> 加在 <span class="math inline"><em>A</em></span> 上；若为0，则不相加。</li><li>然后将 <span class="math inline"><em>A</em><em>Q</em></span>整体右移一位，<span class="math inline"><em>Q</em></span>最低位舍弃，<span class="math inline"><em>A</em></span>最高位为相加的溢出位。</li><li><span class="math inline"><em>Q</em></span>有几位，就执行几个循环。</li></ul><h2 id="有符号乘法booth算法">有符号乘法：Booth算法</h2><figure><img src="image-11.webp" srcset="/img/loading/loading3.gif" lazyload alt="Booth"><figcaption aria-hidden="true">Booth</figcaption></figure><ul><li><span class="math inline"><em>Q</em><sub>0</sub><em>Q</em><sub>−1</sub> = 10</span>，则<span class="math inline"><em>A</em> = <em>A</em> − <em>M</em></span>（记忆：最高位为1，负数，减），然后shift</li><li><span class="math inline"><em>Q</em><sub>0</sub><em>Q</em><sub>−1</sub> = 01</span>，则<span class="math inline"><em>A</em> = <em>A</em> + <em>M</em></span>（记忆：最高位为0，正数，加），溢出位舍去，然后shift</li><li><span class="math inline"><em>Q</em><sub>0</sub><em>Q</em><sub>−1</sub> = 00</span>或 <span class="math inline">11</span>，则直接shift</li><li>Shift将<span class="math inline"><em>Q</em><sub>−1</sub></span>舍去，<span class="math inline"><em>Q</em><sub>0</sub></span> 位移到<span class="math inline"><em>Q</em><sub>−1</sub></span>，新最高位和原最高位相同。</li><li><span class="math inline"><em>Q</em></span>有几位，循环几个周期。最终结果为 <span class="math inline"><em>A</em><em>Q</em></span> 相拼接，不算 <span class="math inline"><em>Q</em><sub>−1</sub></span>！</li></ul><figure><img src="image-12.webp" srcset="/img/loading/loading3.gif" lazyload alt="例子"><figcaption aria-hidden="true">例子</figcaption></figure><h2 id="浮点数表示">浮点数表示</h2><p>以32bit为例：</p><ul><li>1bit符号位 <span class="math inline"><em>m</em></span> + 8bit指数<span class="math inline"><em>E</em></span>（移码表示）+ 23bit有效数<span class="math inline"><em>B</em></span><ul><li>移码表示：<span class="math inline"><em>N</em></span>bit二进制，按照无符号数理解，得到在<span class="math inline">0&nbsp;2<sup><em>N</em></sup> − 1</span>之间的整数，再减去一个固定的偏阶（为<span class="math inline">2<sup><em>N</em> − 1</sup> − 1</span>），得到真正的指数，范围为<span class="math inline">−2<sup><em>N</em> − 1</sup> + 1&nbsp;2<sup><em>N</em> − 1</sup></span><ul><li>8bit 范围为-127~+128</li></ul></li></ul></li><li>规格化数：有效数的最高位一定为1，且不实际存储到内存中。因此，23bit有效数<span class="math inline"><em>B</em></span>实际表示24bit，表示一个二进制小数：1.B</li><li>综上，浮点数被表示为：<span class="math inline">(−1)<sup><em>m</em></sup> × 1.<em>B</em> × 2<sup><em>E</em> − 2<sup><em>N</em> − 1</sup> + 1</sup></span></li><li>范围：<ul><li>以32bit为例：正数在<span class="math inline">2<sup>−127</sup>&nbsp;(2 − 2<sup>−23</sup>) × 2<sup>128</sup></span>，负数在<span class="math inline">−(2 − 2<sup>−23</sup>) × 2<sup>128</sup>&nbsp; − 2<sup>−127</sup></span></li><li>因此有正上溢、正下溢、负上溢、负下溢</li></ul></li></ul><p><img src="image-13.webp" srcset="/img/loading/loading3.gif" lazyload></p><p><img src="image-14.webp" srcset="/img/loading/loading3.gif" lazyload></p><figure><img src="image-15.webp" srcset="/img/loading/loading3.gif" lazyload alt="32bit float"><figcaption aria-hidden="true">32bit float</figcaption></figure><h3 id="ieee754的一些特殊表示">IEEE754的一些特殊表示:</h3><ul><li>当<span class="math inline"><em>E</em> = 0</span>且<span class="math inline"><em>M</em> = 0</span>时,表示0。</li><li>当<span class="math inline"><em>E</em> = 0</span>且<span class="math inline"><em>M</em> ≠ 0</span>时,表示非规格化数(下溢数)。</li><li>当<span class="math inline"><em>E</em> = 255</span>且<span class="math inline"><em>M</em> = 0</span>时,表示∞。</li><li>当<span class="math inline"><em>E</em> = 255</span>且<span class="math inline"><em>M</em> ≠ 0</span>时, 表示NAN。</li></ul><h2 id="浮点数加减法">浮点数加减法：</h2><ol type="1"><li>零检查<ul><li>若是减法运算，则改变减数符号并改为加法运算。若某个操作数为0，则另一个操作数直接作为结果。否则，将存储的23bit有效数扩充成24bit实际有效数。</li></ul></li><li>对齐<ul><li>若两数指数不相等，则增加较小的指数，并右移其有效位数。若此过程中出现有效位数为0，则另一个数直接作为结果。</li></ul></li><li>有效数相加<ul><li>即1.B相加。若产生上溢，则右移有效位数并增加指数。若此操作产生了指数上溢，报错。</li></ul></li><li>规格化<ul><li>若加法结果最高位不为1，则左移有效位数并减小指数。若此操作产生了指数下溢，报错。</li></ul></li></ol><p>注：有效数右移时可以在右边增加保护位以确保精度。 <img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload alt="浮点数加减法"></p><h2 id="浮点数乘法">浮点数乘法</h2><ol type="1"><li>预处理<ul><li>零检查：若有一个操作数为 <span class="math inline">0</span>，则另一个操作数直接作为结果。</li><li>符号位计算：<span class="math inline"><em>m</em> = <em>m</em><sub>1</sub> ⊕ <em>m</em><sub>2</sub></span>，即两个操作数的符号位进行异或运算。</li><li>规格化</li></ul></li><li>指数相加<ul><li><span class="math inline"><em>E</em> = <em>E</em><sub>1</sub> + <em>E</em><sub>2</sub> − 127</span>，即两个操作数的指数相加后减去偏阶。</li></ul></li><li>有效数相乘<ul><li><span class="math inline"><em>B</em> = <em>B</em><sub>1</sub> × <em>B</em><sub>2</sub></span>，即两个操作数的有效数相乘。</li></ul></li><li>规格化<ul><li>若乘法结果的有效数最高位不为 <span class="math inline">1</span>，则左移有效位数并减小指数。若此操作产生了指数下溢，报错。</li><li>若乘法结果的有效数最高位为 <span class="math inline">1</span>，则直接将结果存储为 <span class="math inline">1.<em>B</em></span> 的形式。</li></ul></li></ol><figure><img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload alt="浮点数乘法"><figcaption aria-hidden="true">浮点数乘法</figcaption></figure><h2 id="浮点数除法">浮点数除法</h2><ol type="1"><li>零检查</li><li>指数相减<ul><li><span class="math inline"><em>E</em> = <em>E</em><sub>1</sub> − <em>E</em><sub>2</sub> + 127</span>，即被除数的指数减去除数的指数后加上偏阶。</li></ul></li><li>判断溢出</li><li>有效数相除</li><li>规格化</li></ol><h1 id="ch10-指令集特征和功能">Ch10 指令集：特征和功能</h1><h2 id="机器指令的要素">机器指令的要素</h2><ul><li>操作码</li><li>源操作数引用</li><li>结果操作数引用</li><li>下一条指令引用</li></ul><h2 id="操作数个数">操作数个数</h2><ul><li>三地址：操作数1，操作数2，结果，<span class="math inline"><em>c</em> = <em>a</em> + <em>b</em></span></li><li>双地址：其中一个地址既是操作数也存储结果，<span class="math inline"><em>a</em> = <em>a</em> + <em>b</em></span></li><li>单地址：寄存器操作</li><li>零地址：pop，push等</li><li>更多的地址：更复杂强大的指令，更复杂的CPU，更少的程序指令数</li><li>更少的地址：更简单的指令和CPU，更多的程序指令数</li></ul><h2 id="移位操作">移位操作</h2><ol type="1"><li>逻辑移位<ul><li>逻辑右移1位相当于：无符号整数除以2</li><li>逻辑左移1位相当于：无符号整数乘以2</li><li><figure><img src="image-16.webp" srcset="/img/loading/loading3.gif" lazyload alt="逻辑移位"><figcaption aria-hidden="true">逻辑移位</figcaption></figure></li></ul></li><li>算数移位<ul><li>算术右移1位相当于：带符号整数除以2</li><li>算术左移1位相当于：带符号整数乘以2</li><li><figure><img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload alt="逻辑移位"><figcaption aria-hidden="true">逻辑移位</figcaption></figure></li></ul></li><li>循环移位：<ul><li>保留所有被处理的位，检查某一位的状态，高低位交换</li><li>循环右移 &amp; 循环左移</li><li><figure><img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload alt="循环移位"><figcaption aria-hidden="true">循环移位</figcaption></figure></li></ul></li></ol><h2 id="数端">数端</h2><ul><li>大数端(big-endian ordering)：最高有效字节存放在最低的地址上</li><li>小数端(little-endian ordering)：最高有效字节存放在最高的地址上</li></ul><h2 id="内存对齐">内存对齐</h2><ul><li>内存对齐是指数据在内存中存放时，地址必须是某个特定值的倍数，以提高访问效率。</li><li>例如，32位数据要求在4字节对齐的地址上存放，64位数据要求在8字节对齐的地址上存放。</li></ul><h1 id="ch11-指令集寻址方式和指令模式">Ch11指令集：寻址方式和指令模式</h1><h3 id="符号说明">符号说明：</h3><ul><li><span class="math inline"><em>A</em></span>：指令中出现的地址/数据的内容</li><li><span class="math inline"><em>R</em></span>：指令中出现的寄存器存储的地址/数据的内容</li><li><span class="math inline"><em>E</em><em>A</em></span>：被访问位置的实际有效地址</li><li><span class="math inline">(<em>X</em>)</span>：位置<span class="math inline"><em>X</em></span>的内容</li></ul><h2 id="立即寻址">立即寻址</h2><ul><li>操作数 = <span class="math inline"><em>A</em></span></li><li>优点：不要求存储访问，速度快</li><li>缺点：操作数范围受限</li></ul><h2 id="直接寻址">直接寻址</h2><ul><li><span class="math inline"><em>E</em><em>A</em> = <em>A</em></span>，即实际访问位置的地址写在指令中。</li><li>优点：只需要一次内存引用。</li><li>缺点：地址范围受限。</li><li><figure><img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload alt="直接寻址"><figcaption aria-hidden="true">直接寻址</figcaption></figure></li></ul><h2 id="间接寻址">间接寻址</h2><ul><li><span class="math inline"><em>E</em><em>A</em> = (<em>A</em>)</span>，即指令中存储的地址指向一个内存位置，该位置存储着实际访问位置真正的地址。</li><li>优点：地址范围更大。</li><li>缺点：需要两次内存引用（第一次获取真正地址，第二次获取实际数据）。</li><li><figure><img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload alt="间接寻址"><figcaption aria-hidden="true">间接寻址</figcaption></figure></li></ul><h2 id="寄存器寻址类似直接寻址">寄存器寻址（类似直接寻址）</h2><ul><li><span class="math inline"><em>E</em><em>A</em> = <em>R</em></span>，即指令中存储的地址指向一个寄存器，实际访问内容存储在该寄存器中。</li><li>优点：无需内存引用；指令中寄存器地址通常较短。</li><li>缺点：寄存器地址空间有限。</li></ul><h2 id="寄存器间接寻址类似间接寻址">寄存器间接寻址（类似间接寻址）</h2><ul><li><span class="math inline"><em>E</em><em>A</em> = (<em>R</em>)</span>，即指令中存储的地址指向一个寄存器，该寄存器存储着实际访问位置的真正地址。</li><li>优点：地址范围更大；相比间接寻址只需一次内存访问；指令内地址更短。</li><li><figure><img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload alt="寄存器间接寻址"><figcaption aria-hidden="true">寄存器间接寻址</figcaption></figure></li></ul><h2 id="偏移寻址寄存器间接寻址和直接寻址的结合">偏移寻址（寄存器间接寻址和直接寻址的结合）</h2><ul><li><span class="math inline"><em>E</em><em>A</em> = (<em>R</em>) + <em>A</em></span>，实际地址由寄存器内容与指令内地址相加得到。<ul><li>相对寻址：<ul><li><span class="math inline"><em>R</em> = <em>P</em><em>C</em></span>，<span class="math inline"><em>A</em></span> 为补码，有效地址 = 指令地址 +偏移量（可正可负）。</li></ul></li><li>基址寄存器寻址：<ul><li><span class="math inline">(<em>R</em>)</span> 为基址，<span class="math inline"><em>A</em></span>为偏移量（相对寻址是其特例）。</li></ul></li><li>变址寻址：<ul><li><span class="math inline"><em>A</em></span> 为基址，<span class="math inline">(<em>R</em>)</span> 为偏移量，常用于迭代场景。</li></ul></li></ul></li><li><figure><img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload alt="偏移寻址"><figcaption aria-hidden="true">偏移寻址</figcaption></figure></li></ul><h2 id="堆栈寻址">堆栈寻址</h2><ul><li>操作数在栈顶，通过指令隐式对栈顶进行操作</li><li>本质是通过存储在寄存器中的栈指针进行寄存器间接寻址，对栈顶元素进行操作。</li></ul><h1 id="ch12-cpu结构和功能">Ch12 CPU结构和功能</h1><h2 id="cpu内部结构">CPU内部结构</h2><ul><li>包含ALU（算术逻辑单元）、CU（控制单元）、寄存器组、状态标志等。</li><li>内部处理器总线用于在ALU和寄存器间传递数据，因ALU仅能操作CPU内部存储数据。</li></ul><figure><img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload alt="CPU内部结构"><figcaption aria-hidden="true">CPU内部结构</figcaption></figure><h2 id="寄存器组织">寄存器组织</h2><ol type="1"><li>用户可见寄存器：<ul><li>通用寄存器：多功能用途。</li><li>数据寄存器：仅存储数据。</li><li>地址寄存器：可能通用或专用于特定寻址模式（如栈指针）。</li><li>设计问题：通用化灵活但指令长；专用化指令短但不灵活；寄存器数量过少需频繁访存，过多则收益不显著。</li></ul></li><li>控制和状态寄存器：<ul><li>程序计数器（PC）：保存下条指令地址。</li><li>指令寄存器（IR）：存储最近读取的指令。</li><li>内存地址寄存器（MAR）：保存地址，与地址总线直接相连。</li><li>内存缓冲寄存器（MBR）：保存数据，与数据总线直接相连。</li><li>程序状态字（PSW）：包含条件码等状态信息。</li></ul></li></ol><h2 id="指令周期的数据流">指令周期的数据流</h2><ol type="1"><li>取指周期<ul><li>下条指令地址：PC → MAR → 地址总线 → 主存。</li><li>指令：主存 → 数据总线 → MBR → IR，同时PC++（除非指令修改PC）。</li><li><figure><img src="image-41.webp" srcset="/img/loading/loading3.gif" lazyload alt="取值周期"><figcaption aria-hidden="true">取值周期</figcaption></figure></li></ul></li><li>间接周期（如有）<ul><li>MBR的低N位 → MAR → 地址总线。</li><li><figure><img src="image-42.webp" srcset="/img/loading/loading3.gif" lazyload alt="间接寻址"><figcaption aria-hidden="true">间接寻址</figcaption></figure></li></ul></li><li>执行周期<ul><li>复杂多样，取决于具体指令。</li></ul></li><li>中断周期<ul><li>PC复制到MBR，特定地址由控制单元给MAR，MBR数据存至主存。</li><li>PC装载中断服务程序地址</li><li><figure><img src="image-43.webp" srcset="/img/loading/loading3.gif" lazyload alt="中断周期"><figcaption aria-hidden="true">中断周期</figcaption></figure></li></ul></li></ol><h2 id="流水线技术">流水线技术</h2><ol type="1"><li>经典六阶段流水：<ul><li>取指令(FI)</li><li>指令译码(DI)</li><li>计算操作数(CO)</li><li>取操作数(FO)</li><li>执行指令(EI)</li><li>写操作数(WO)</li></ul></li><li>条件转移与流水线总清：<ul><li>条件转移可能导致流水线停顿，需清空流水线并重新取指。</li><li><img src="image-44.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li>流水线性能增强的限制：<ul><li>访存冲突（FI，FO，WO）</li><li>每个指令执行时间不完全相同</li><li>转移指令</li><li>中断</li></ul></li><li>流水线阶段并非越多越好：阶段越多开销越大，单指令执行时间越长，且相关性更复杂。</li><li>流水线性能<ul><li>流水线周期时间：通过流水线把一组指令推进一个阶段所需时间 <span class="math display"><em>τ</em> = <em>τ</em><sub><em>m</em></sub> + <em>d</em></span>其中<span class="math inline"><em>τ</em><sub><em>m</em></sub></span>为最大阶段延迟，<span class="math inline"><em>d</em></span>为锁存器延迟（通常可忽略）。</li><li>n条指令总时间：<span class="math display"><em>T</em><sub><em>k</em>, <em>n</em></sub> = [<em>k</em> + (<em>n</em> − 1)]<em>τ</em></span>（k阶段流水线，无分支）。</li><li>加速比：<span class="math display">$$S_k = \frac{nk\tau}{[k +(n-1)]\tau} = \frac{nk}{k + n - 1}$$</span> 当<span class="math inline"><em>n</em> → ∞</span>时，<span class="math inline">lim <em>S</em><sub><em>k</em></sub> = <em>k</em></span>。</li></ul></li><li>流水线冲突：流水线由于条件不允许继续执行而停顿<ul><li>资源冲突：<ul><li>访存冲突（FI/FO/WO同时请求内存）</li><li>ALU冲突（多条指令同时需ALU）</li></ul></li><li>数据冲突：<ol type="1"><li>写后读（RAW）：前指令修改数据，后指令读取时数据未更新。</li><li>读后写（WAR）：后指令写数据时，前指令尚未读取该数据。</li><li>写后写（WAW）：后指令写数据覆盖前指令未完成的写操作。</li></ol></li></ul></li></ol><h2 id="条件分支处理">条件分支处理</h2><ul><li>多指令流：复制流水线初始部分，同时取两条指令，但可能引发资源争用。</li><li>预取分支目标：识别转移时取两个分支指令，仅做取指和译指直至某分支执行。</li><li>循环缓冲区：存储最近取的顺序指令，转移时检查目标是否存在，适用于循环。</li><li>分支预测：<ul><li>静态预测：如预测从不跳转、总是跳转、按操作码预测。</li><li>动态预测：如1位预测（根据上次跳转预测）、2位预测（连续两次失败才反转预测）。</li></ul></li></ul><figure><img src="image-45.webp" srcset="/img/loading/loading3.gif" lazyload alt="2位预测"><figcaption aria-hidden="true">2位预测</figcaption></figure><h2 id="转移历史表">转移历史表</h2><ul><li>在预测分支并取来转移目标指令时，条件转移语句还没完成译指、计算操作数，无法得到转移目标语句的地址。</li><li>转移历史表：通过表格维护转移目标<ul><li>分支语句的地址</li><li>转移目标语句的地址</li><li>转移历史位</li></ul></li><li>预测转移时：<ul><li>从表中直接查询得出转移目标地址</li><li>如果该分支语句在表中不存在：等到操作数计算完成后，加入表中</li></ul></li></ul><h1 id="ch13-精简指令集计算机risc">Ch13 精简指令集计算机RISC</h1><h2 id="risc的主要特性">RISC的主要特性</h2><ul><li>大量通用寄存器，使用编译器优化寄存器用法。</li><li>有限、简单的指令集。</li><li>强调优化指令流水线。</li></ul><h2 id="现代精简指令集的特点">现代精简指令集的特点</h2><ul><li>每个机器周期一条指令。</li><li>寄存器-寄存器操作。</li><li>简单的寻址模式和指令格式。</li></ul><h2 id="cisc">CISC</h2><ol type="1"><li>朝向CISC的原因：<ul><li>出现了功能强大的复杂高级程序设计语言（HLL）</li><li>导致程序设计语言与汇编语言之间的语义间隙增大</li><li>出现了更复杂的机器指令、寻址方式，硬件实现的HLL语句</li></ul></li><li>CISC的目标：<ul><li>提高执行效率</li><li>简化编译</li><li>用复杂的机器指令执行复杂的HLL语句</li></ul></li></ol><h2 id="对hll操作的研究">对HLL操作的研究</h2><figure><img src="image-23.webp" srcset="/img/loading/loading3.gif" lazyload alt="HLL操作动态频度"><figcaption aria-hidden="true">HLL操作动态频度</figcaption></figure><ul><li>HLL操作动态频度：过程调用在机器指令加权和存储器加权下占比很高，尤其存储器加权场景。</li><li>操作数：局部标量变量占多数，数组/结构次之。</li><li>过程调用：<ul><li>非常耗时的原因：<ul><li>过程传递的参量和变量数、过程嵌套深度</li><li>大部分过程调用的传送的参变量、使用的局部标量变量不多</li><li>很少出现长的一系列调用跟着一系列返回</li></ul></li></ul></li><li>结论：<ul><li>过程调用是HLL中最耗时的操作，应该优化</li><li>优化方法：优化寄存器的使用（从而减少访存）；优化流水线（减少分支影响）；</li></ul></li></ul><h2 id="优化方法">优化方法</h2><h3 id="大寄存器组硬件方案">大寄存器组（硬件方案）</h3><ul><li><p>依据/适用情况：参数、局部变量少，调用深度有限</p></li><li><p>寄存器（几百个）分为很多个组，每个过程对应一组寄存器</p></li><li><p>发生过程调用时，直接切换到另一个寄存器组（将过程调用优化为寄存器访问）</p></li><li><p>对程序，任何时刻只有一组寄存器可见</p></li><li><p>解决参数和返回值传递：</p><p><img src="image-24.webp" srcset="/img/loading/loading3.gif" lazyload></p></li><li><p>解决全局变量：用一组全局寄存器，所有过程可见</p></li><li><p>解决深度过深：将一部分寄存器存储在内存中</p></li><li><p>进一步优化：环形寄存器组织</p><figure><img src="image-25.webp" srcset="/img/loading/loading3.gif" lazyload alt="环形寄存器组织"><figcaption aria-hidden="true">环形寄存器组织</figcaption></figure></li></ul><h3 id="寄存器优化软件方案">寄存器优化（软件方案）</h3><ol type="1"><li>编译器的优化<ul><li>编译器为每个变量指派一个虚拟寄存器</li><li>并通过某种方法将虚拟寄存器映射到真实寄存器</li><li>生命周期不重叠的虚拟寄存器可以共享同一个真实寄存器</li><li>实在安排不下，就考虑内存</li></ul></li><li>实现方法：图着色法<ol type="1"><li>画点，每个点代表一个虚拟寄存器</li><li>连线，在两个生命周期有重叠的虚拟寄存器之间连线</li><li>着色，若有n个真实寄存器，则尽量用n种颜色给图上色，要求相邻（有连线）的节点颜色不能相同；无法上色的节点就存在内存里。</li></ol><figure><img src="image-26.webp" srcset="/img/loading/loading3.gif" lazyload alt="图着色法"><figcaption aria-hidden="true">图着色法</figcaption></figure></li></ol><h2 id="risc流水线">RISC流水线</h2><h3 id="流水线的效果">流水线的效果</h3><figure><img src="image-46.webp" srcset="/img/loading/loading3.gif" lazyload alt="流水线的效果"><figcaption aria-hidden="true">流水线的效果</figcaption></figure><h3 id="流水线优化">流水线优化</h3><ul><li>空指令（NOOP）：在流水线阶段插入空操作，解决数据相关性，保证指令顺序执行。<ul><li><figure><img src="image-47.webp" srcset="/img/loading/loading3.gif" lazyload alt="空指令"><figcaption aria-hidden="true">空指令</figcaption></figure></li></ul></li><li>延迟转移：交换分支指令与前序指令位置，使分支延迟期间执行有效指令，适用于无条件分支。<ul><li><figure><img src="image-48.webp" srcset="/img/loading/loading3.gif" lazyload alt="延迟分支"><figcaption aria-hidden="true">延迟分支</figcaption></figure></li></ul></li><li>循环展开</li></ul><h1 id="ch14-指令级并行性和超标量处理器">Ch14指令级并行性和超标量处理器</h1><h2 id="超标量和超流水的区别">超标量和超流水的区别</h2><ul><li>超标量：多条指令同时启动独立执行，即多条流水线</li><li>超流水：流水线阶段时间短于时钟周期，内部时钟速率加倍，外部周期内发两条指令。</li></ul><figure><img src="image-49.webp" srcset="/img/loading/loading3.gif" lazyload alt="超标量与超流水"><figcaption aria-hidden="true">超标量与超流水</figcaption></figure><h2 id="指令相关性">指令相关性</h2><ol type="1"><li>数据相关性：访问操作数的位置有冲突<ol type="1"><li>写后读（RAW）或真相关：<ul><li>一条指令修改寄存器或内存位置，后续指令读取该内存或寄存器位置中的数据。</li><li>冲突：写操作完成之前发生了读操作</li></ul></li><li>读后写（WAR）或反相关<ul><li>冲突：读操作发生前完成了写操作</li><li>乱序发射会造成读后写冲突（按序发射一定不会出现前面的指令还没开始执行后面的指令已经执行完成的情况）</li></ul></li><li>写后写或输出相关<ul><li>冲突：写操作的顺序与预期顺序相反</li><li>乱序完成会造成写后写冲突</li></ul></li></ol></li><li>过程相关性<ul><li>即转移后的指令不能再转移指令未执行前执行</li><li>超标量中，若某条流水线上发生了分支预测错误，则所有流水线上都要进行流水线总清！</li></ul></li><li>资源相关性<ul><li>访存冲突、ALU冲突</li></ul></li></ol><h2 id="乱序执行">乱序执行</h2><ul><li>按序发射按序完成：指令按顺序发射和完成，可能因相关性停顿。</li><li>按序发射乱序完成：指令按序发射，完成顺序可乱序，可能会造成写后写相关性，引发WAW冲突。</li><li>乱序发射乱序完成：指令发射顺序可乱序，需指令窗口检测相关性，可能会造成读后写相关性，引发WAR冲突。</li></ul><h2 id="寄存器重命名解决写后写和读后写相关性">寄存器重命名：解决写后写和读后写相关性</h2><ul><li>产生写后写相关性和读后写相关性的原因：<ul><li>寄存器值不再反应程序流顺序</li></ul></li><li>解决方法：<ul><li>寄存器重命名<ul><li>由CPU硬件动态分配寄存器</li><li>每产生一个新的寄存器值就分配一个新的真实寄存器</li></ul></li></ul></li></ul><h1 id="ch17-并行处理">Ch17 并行处理</h1><h2 id="并行处理机分类">并行处理机分类</h2><ul><li>单指令单数据流（SISD）：传统单处理器。</li><li>单指令多数据流（SIMD）：同一指令对不同数据组在不同处理器执行。</li><li>多指令单数据流（MISD）：未实现。</li><li>多指令多数据流（MIMD）：分为紧耦合、松耦合。</li></ul><h2 id="紧耦合">紧耦合</h2><ul><li>处理器共享存储器，通过共享存储器相互通信</li></ul><h3 id="对称多处理器smp">对称多处理器（SMP）</h3><ol type="1"><li>定义<ul><li>共享内存、IO，通过共享总线分时共享</li><li>存储器在任何范围内的存储时间对各个处理器大致相同</li><li>所有处理器能完成同样的功能(对称)，地位平等</li><li>系统由一个集中式操作系统控制</li></ul></li><li>优点：<ul><li>性能好，可以并行执行</li><li>可用性，单个故障总体不会停机</li><li>增量式增长和可扩展性</li></ul></li></ol><h3 id="非一致性内存访问numa">非一致性内存访问（NUMA）</h3><p>存储器在不同范围内的存储时间对不同处理器是不同的</p><h2 id="cache一致性问题与mesi协议">Cache一致性问题与MESI协议</h2><ol type="1"><li>问题：<ul><li>同一数据在不同的Cache中都有副本</li><li>CPU读取数据时会先检查Cache，导致不同的CPU眼里的内存不一样</li><li>回写显然会导致不一致，写直达也会，不过可以通过监听消除</li></ul></li><li>目录协议<ul><li>收集维护有关数据块的副本放在哪里的信息</li><li>目录放在主存中</li><li>优点：适用于多总线或复杂的大型系统</li><li>缺点：产生了中央瓶颈</li></ul></li><li>监听协议<ul><li>Cache必须识别每一行是否共享、是否与主存相同</li><li>优点：适合使用总线的多处理机</li><li>缺点：增大了总线传输量</li><li>有两种策略：<ol type="1"><li>写-失效：适用于回写<ul><li>多个监听者，单个修改者</li><li>某Cache写操作时，其他Cache中的该行数据失效</li><li>发出写操作的处理器将获得数据独享直到其他Cache访问该行</li><li>例子：MESI协议</li></ul></li><li>写-更新：适用于写直达<ul><li>多个读者，多个写者</li><li>更新的字被广播到其他Cache</li></ul></li></ol></li></ul></li></ol><h3 id="mesi协议">MESI协议</h3><ul><li>M（Modified）：已修改，数据仅在本Cache，未写回主存。</li><li>E（Exclusive）：独占，数据在本Cache和主存，其他Cache无副本。</li><li>S（Shared）：共享，数据在本Cache和主存，其他Cache有副本。</li><li>I（Invalid）：失效，数据不在本Cache或已过时。</li></ul><p><img src="image-28.webp" srcset="/img/loading/loading3.gif" lazyload> <img src="image-27.webp" srcset="/img/loading/loading3.gif" lazyload alt="MESI协议状态转换"></p><h2 id="松耦合如集群">松耦合（如集群）</h2><ul><li>独立处理器或SMP互联，分布式存储器，通信通过网络。</li><li>优点：可扩展性强、可用性高、性价比高。</li></ul><h2 id="集群与smp对比">集群与SMP对比</h2><ul><li>共同点：<ul><li>提供多处理器支持高端应用</li><li>均商用化，SMP历史更久。</li></ul></li><li>SMP优点：<ul><li>易于配置管理</li><li>接近单处理器模型</li><li>占用物理空间小</li><li>耗电少</li><li>稳定</li></ul></li><li>集群优点：<ul><li>运行中可增减机器</li><li>高增量</li><li>绝对可扩展性强</li><li>高可用性</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学</title>
      <link href="/_posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
      <url>/_posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>马汝辉老师</em> 2024-2025学年秋季学期教学内容进行整理。</p></blockquote><h1 id="图论">图论</h1><h2 id="第一章-基本概念">第一章 基本概念</h2><h3 id="图的概念">图的概念</h3><ul><li><strong>图的定义</strong>：<ul><li>二元组 <span class="math inline">(<em>V</em>(<em>G</em>), <em>E</em>(<em>G</em>))</span>称为图。<ul><li>其中 <span class="math inline"><em>V</em>(<em>G</em>)</span>是非空集合，称为<strong>结点集</strong></li><li><span class="math inline"><em>E</em>(<em>G</em>)</span> 是 <span class="math inline"><em>V</em>(<em>G</em>)</span>诸结点之间<strong>边的集合</strong></li><li>常用 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>表示图。</li></ul></li><li><strong>边</strong>：用 <span class="math inline"><em>e</em><sub><em>k</em></sub> = (<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)</span>表示。这时我们说 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 与 <span class="math inline"><em>v</em><sub><em>j</em></sub></span>是相邻结点；<span class="math inline"><em>e</em><sub><em>k</em></sub></span> 分别与 <span class="math inline"><em>v</em><sub><em>i</em></sub></span>，<span class="math inline"><em>v</em><sub><em>j</em></sub></span> 相关联。</li></ul></li><li><strong>有限图与无限图</strong>：<ul><li>有限图： <span class="math inline"><em>V</em></span> 和 <span class="math inline"><em>E</em></span> 都是有限集。</li></ul></li><li><strong>有向图与无向图</strong>：<ul><li>有向图：<span class="math inline"><em>E</em></span>中的每条边都是有方向的，称为<strong>有向边</strong>（或弧）。<ul><li>如果 <span class="math inline"><em>e</em><sub><em>k</em></sub></span> 是有向边，称<span class="math inline"><em>v</em><sub><em>i</em></sub></span> 是<span class="math inline"><em>e</em><sub><em>k</em></sub></span>的始点，<span class="math inline"><em>v</em><sub><em>j</em></sub></span>是 <span class="math inline"><em>e</em><sub><em>k</em></sub></span>的终点 ；并称 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 是 <span class="math inline"><em>v</em><sub><em>j</em></sub></span>的<strong>直接前趋</strong>，<span class="math inline"><em>v</em><sub><em>j</em></sub></span> 是 <span class="math inline"><em>v</em><sub><em>i</em></sub></span>的<strong>直接后继</strong>。</li></ul></li><li>无向图：<span class="math inline"><em>E</em></span>中的每条边没有方向，称为<strong>无向边</strong>。<ul><li>如果 <span class="math inline"><em>e</em><sub><em>k</em></sub></span>是无向边，则称 <span class="math inline"><em>v</em><sub><em>i</em></sub></span>，<span class="math inline"><em>v</em><sub><em>j</em></sub></span> 是 <span class="math inline"><em>e</em><sub><em>k</em></sub></span>的两个<strong>端点</strong>。</li></ul></li><li>混合图：<span class="math inline"><em>E</em></span>中既有方向的边，也有没有方向的边。</li></ul></li></ul><figure><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="有向图与无向图"><figcaption aria-hidden="true">有向图与无向图</figcaption></figure><h3 id="度">度</h3><ul><li><span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>的某结点 <span class="math inline"><em>v</em></span>所关联的边数称为该结点的度，用 <span class="math inline"><em>d</em>(<em>v</em>)</span> 表示。如果 <span class="math inline"><em>v</em></span> 带有自环，则自环对 <span class="math inline"><em>d</em>(<em>v</em>)</span> 的贡献为 <span class="math inline">2</span>。</li><li>有向图中由于各边都是有向边，因此每个结点 <span class="math inline"><em>v</em></span> 还有其<strong>正度</strong> <span class="math inline">(<em>d</em><sup>+</sup>(<em>v</em>))</span>和<strong>负度</strong> <span class="math inline">(<em>d</em><sup>−</sup>(<em>v</em>))</span>。<ul><li><span class="math inline"><em>d</em><sup>+</sup>(<em>v</em>)</span>的值是以 <span class="math inline"><em>v</em></span>为始点的边的数目</li><li><span class="math inline"><em>d</em><sup>−</sup>(<em>v</em>)</span>是以 <span class="math inline"><em>v</em></span> 为终点的边的数目</li><li>显然有 <span class="math inline"><em>d</em><sup>+</sup>(<em>v</em>) + <em>d</em><sup>−</sup>(<em>v</em>) = <em>d</em>(<em>v</em>)</span></li></ul></li></ul><h2 id="图的类别">图的类别</h2><ul><li><strong>简单图</strong>：不含重边（任意两结点间最多只有一条边）和自环的无向图或有向图称为简单图</li><li><strong>空图</strong>：没有任何边的简单图叫空图，用 <span class="math inline"><em>N</em><sub><em>n</em></sub></span> 表示</li><li><strong>平凡图</strong>：只含一个结点的空图称为平凡图</li><li><strong>多重图</strong>：只与一个结点相关联的边称为<strong>自环</strong>，在同一对结点之间可以存在多条边，称之为<strong>重边</strong>。含有重边的图叫多重图。</li><li><strong>完全图</strong>：任何两结点间都有边的简单图称为完全图，用<span class="math inline"><em>K</em><sub><em>n</em></sub></span> 表示。<ul><li><span class="math inline"><em>K</em><sub><em>n</em></sub></span>中每个结点的度都是 <span class="math inline"><em>n</em> − 1</span>。</li><li><span class="math inline"><em>K</em><sub><em>n</em></sub></span>的边数是 <span class="math inline">$\frac{1}{2} n(n-1)$</span></li></ul></li><li><strong>完全有向图</strong>：一个简单有向图，其中每一对不同的顶点都只有一对边相连，称为完全有向图</li><li><strong>k-正则图</strong>：每个结点的度都相同的图，若其度均为 <span class="math inline"><em>k</em></span>，则称为 <span class="math inline"><em>k</em></span>-正则图。完全图是 <span class="math inline">(<em>n</em> − 1)</span>-正则图</li><li><strong>赋权图</strong>：如果图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>的每条边 <span class="math inline"><em>e</em><sub><em>k</em></sub> = (<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)</span>都赋以一个实数 <span class="math inline"><em>w</em><sub><em>k</em></sub></span>作为该边的权，则称 <span class="math inline"><em>G</em></span>是赋权图。<ul><li>特别地，如果这些权都是正实数，就称 <span class="math inline"><em>G</em></span> 是<strong>正权图</strong>。</li></ul></li><li><strong>子图</strong>：给定 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>，如果存在另一个图<span class="math inline"><em>G</em><sup>′</sup> = (<em>V</em><sup>′</sup>, <em>E</em><sup>′</sup>)</span>，满足<span class="math inline"><em>V</em><sup>′</sup> ⊆ <em>V</em></span>，<span class="math inline"><em>E</em><sup>′</sup> ⊆ <em>E</em></span>，则称<span class="math inline"><em>G</em><sup>′</sup></span> 是 <span class="math inline"><em>G</em></span> 的一个<strong>子图</strong>。<ul><li><strong>支撑子图/生成子图</strong>：如果 <span class="math inline"><em>V</em><sup>′</sup> = <em>V</em></span>，就称<span class="math inline"><em>G</em><sup>′</sup></span> 是 <span class="math inline"><em>G</em></span> 的支撑子图 或生成子图（只能删除边，结点不变）</li><li><strong>导出子图</strong>：如果 <span class="math inline"><em>V</em><sup>′</sup> ⊆ <em>V</em></span>，且 <span class="math inline"><em>E</em><sup>′</sup></span> 包含了 <span class="math inline"><em>G</em></span> 在结点子集 <span class="math inline"><em>V</em><sup>′</sup></span> 之间的所有边，则称<span class="math inline"><em>G</em><sup>′</sup></span> 是 <span class="math inline"><em>G</em></span>的导出子图。（删除结点及其关联的边）</li><li><strong>平凡子图</strong>：如果 <span class="math inline"><em>V</em><sup>′</sup> = <em>V</em></span>，<span class="math inline"><em>E</em><sup>′</sup> = <em>E</em></span> 或者<span class="math inline"><em>E</em><sup>′</sup> = ∅</span>，则称为平凡子图。</li></ul></li></ul><h3 id="图的性质">图的性质</h3><ul><li><strong>握手定理</strong> ：设 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> 有<span class="math inline"><em>n</em></span> 个结点，<span class="math inline"><em>m</em></span> 条边，则 <span class="math display">∑<sub><em>v</em> ∈ <em>V</em>(<em>G</em>)</sub><em>d</em>(<em>v</em>) = 2<em>m</em></span></li><li><span class="math inline"><em>G</em></span>中度为奇数的结点必为偶数个</li><li>有向图 <span class="math inline"><em>G</em></span>中正度之和等于负度之和。</li><li>非空简单无向图中一定存在度相同的结点。</li></ul><h3 id="图的运算">图的运算</h3><ul><li>给定两个图 <span class="math inline"><em>G</em><sub>1</sub> = (<em>V</em><sub>1</sub>, <em>E</em><sub>1</sub>)</span>，<span class="math inline"><em>G</em><sub>2</sub> = (<em>V</em><sub>2</sub>, <em>E</em><sub>2</sub>)</span>。<ul><li><span class="math inline"><em>G</em><sub>1</sub></span> 和 <span class="math inline"><em>G</em><sub>2</sub></span>的<strong>并</strong>：<span class="math inline"><em>G</em><sub>1</sub> ∪ <em>G</em><sub>2</sub> = (<em>V</em>, <em>E</em>)</span><ul><li>其中 <span class="math inline"><em>V</em> = <em>V</em><sub>1</sub> ∪ <em>V</em><sub>2</sub></span>，<span class="math inline"><em>E</em> = <em>E</em><sub>1</sub> ∪ <em>E</em><sub>2</sub></span></li></ul></li><li><span class="math inline"><em>G</em><sub>1</sub></span> 和 <span class="math inline"><em>G</em><sub>2</sub></span>的<strong>交</strong>：<span class="math inline"><em>G</em><sub>1</sub> ∩ <em>G</em><sub>2</sub> = (<em>V</em>, <em>E</em>)</span><ul><li>其中 <span class="math inline"><em>V</em> = <em>V</em><sub>1</sub> ∩ <em>V</em><sub>2</sub></span>，<span class="math inline"><em>E</em> = <em>E</em><sub>1</sub> ∩ <em>E</em><sub>2</sub></span></li></ul></li><li><span class="math inline"><em>G</em><sub>1</sub></span> 和 <span class="math inline"><em>G</em><sub>2</sub></span>的<strong>对称差</strong>：<span class="math inline"><em>G</em><sub>1</sub> ⊕ <em>G</em><sub>2</sub> = (<em>V</em>, <em>E</em>)</span><ul><li>其中 <span class="math inline"><em>V</em> = <em>V</em><sub>1</sub> ∪ <em>V</em><sub>2</sub></span>，<span class="math inline"><em>E</em> = <em>E</em><sub>1</sub> ⊕ <em>E</em><sub>2</sub></span></li></ul></li></ul></li><li>在 <span class="math inline"><em>G</em></span> 中删去一个子图 <span class="math inline"><em>H</em></span>，指删掉 <span class="math inline"><em>H</em></span> 中的各条边，记作 <span class="math inline"><em>G</em> − <em>H</em></span><ul><li>特别地，对于简单图 <span class="math inline"><em>G</em></span>，称<span class="math inline"><em>K</em><sub><em>n</em></sub> − <em>G</em></span>为 <span class="math inline"><em>G</em></span>的<strong>补图</strong>，记作 <span class="math inline"><em>Ḡ</em></span>。</li></ul></li><li>从 <span class="math inline"><em>G</em></span> 中删去某个结点 <span class="math inline"><em>v</em></span> 及其关联的边所得的图记作 <span class="math inline"><em>G</em> − <em>v</em></span><ul><li><span class="math inline"><em>G</em> − <em>v</em></span> 是 <span class="math inline"><em>G</em></span> 的导出子图</li></ul></li><li>从 <span class="math inline"><em>G</em></span> 中删去某特定的边<span class="math inline"><em>e</em> = (<em>u</em>, <em>v</em>)</span>所得的图记作 <span class="math inline"><em>G</em> − <em>e</em></span><ul><li><span class="math inline"><em>G</em> − <em>e</em></span> 是 <span class="math inline"><em>G</em></span> 的支撑子图</li></ul></li><li>在 <span class="math inline"><em>G</em></span> 中增加某条边 <span class="math inline"><em>e</em><sub><em>i</em><em>j</em></sub></span>，可记作<span class="math inline"><em>G</em> + <em>e</em><sub><em>i</em><em>j</em></sub></span></li></ul><figure><img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="图的运算"><figcaption aria-hidden="true">图的运算</figcaption></figure><h3 id="图的邻点集">图的邻点集</h3><ul><li><strong>邻点集</strong>：如果 <span class="math inline"><em>G</em></span> 是无向图，则 <span class="math inline"><em>Γ</em>(<em>v</em>) = <em>u</em> ∣ (<em>v</em>, <em>u</em>) ∈ <em>E</em></span>称为 <span class="math inline"><em>v</em></span> 的邻点集<ul><li>设 <span class="math inline"><em>v</em></span> 是有向图 <span class="math inline"><em>G</em></span> 的一个结点，则<ul><li><span class="math display"><em>Γ</em><sup>+</sup>(<em>v</em>) = {<em>u</em> ∣ (<em>v</em>, <em>u</em>) ∈ <em>E</em>}</span>称为 <span class="math inline"><em>v</em></span>的<strong>直接后继集</strong> 或<strong>外邻集</strong></li><li><span class="math display"><em>Γ</em><sup>−</sup>(<em>v</em>) = {<em>u</em> ∣ (<em>u</em>, <em>v</em>) ∈ <em>E</em>}</span>称为 <span class="math inline"><em>v</em></span>的<strong>直接前趋集</strong> 或<strong>内邻集</strong></li></ul></li></ul></li></ul><h3 id="图的同构">图的同构</h3><ul><li><strong>同构图</strong>：两个图 <span class="math inline"><em>G</em><sub>1</sub> = (<em>V</em><sub>1</sub>, <em>E</em><sub>1</sub>)</span>，<span class="math inline"><em>G</em><sub>2</sub> = (<em>V</em><sub>2</sub>, <em>E</em><sub>2</sub>)</span>，如果<span class="math inline"><em>V</em><sub>1</sub></span> 和 <span class="math inline"><em>V</em><sub>2</sub></span> 存在双射函数 <span class="math inline">f</span>，且 <span class="math inline">(<em>u</em>, <em>v</em>) ∈ <em>E</em><sub>1</sub></span>，当且仅当<span class="math inline">(<em>f</em>(<em>u</em>), <em>f</em>(<em>v</em>)) ∈ <em>E</em><sub>2</sub></span>时，并且这两条边的重数相同，称 <span class="math inline"><em>G</em><sub>1</sub></span> 和 <span class="math inline"><em>G</em><sub>2</sub></span><strong>同构</strong>，记作： <span class="math inline"><strong>G</strong><sub><strong>1</strong></sub> ≅ <strong>G</strong><sub><strong>2</strong></sub></span></li><li><span class="math inline"><em>G</em><sub>1</sub> ≅ <em>G</em><sub>2</sub></span>的<strong>必要条件</strong> ：<ul><li><span class="math inline">|<em>V</em>(<em>G</em><sub>1</sub>)| = |<em>V</em>(<em>G</em><sub>2</sub>)|</span>，<span class="math inline">|<em>E</em>(<em>G</em><sub>1</sub>)| = |<em>E</em>(<em>G</em><sub>2</sub>)|</span></li><li><span class="math inline"><em>G</em><sub>1</sub></span> 和 <span class="math inline"><em>G</em><sub>2</sub></span>结点度的非增序列相同</li><li>存在同构的导出子图</li></ul></li></ul><figure><img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload alt="同构的彼得森图"><figcaption aria-hidden="true">同构的彼得森图</figcaption></figure><h3 id="图的代数表示">图的代数表示</h3><h4 id="邻接矩阵">邻接矩阵</h4><ul><li>邻接矩阵表示了结点之间的邻接关系。</li><li>有向图的邻接矩阵 <span class="math inline"><strong>A</strong></span>是一个 <span class="math inline"><em>n</em></span> 阶方阵，其元素为<span class="math display">$$  a_{i j}=\left\{\begin{aligned}  1,&amp;\quad \left(v_{i},v_{j}\right) \in E \\  0,&amp;\quad otherwise  \end{aligned}\right.  $$</span></li><li>邻接矩阵 <span class="math inline"><strong>A</strong></span> 第<span class="math inline"><em>i</em></span> 行非零元的数目恰是 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 的正度，第<span class="math inline"><em>j</em></span> 列非零元的数目是 <span class="math inline"><em>v</em><sub><em>j</em></sub></span> 的负度。</li><li>邻接矩阵<strong>可以表示自环，但无法表示重边</strong>。</li><li>无向图的邻接矩阵，是一个对称矩阵</li></ul><figure><img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload alt="邻接矩阵"><figcaption aria-hidden="true">邻接矩阵</figcaption></figure><h4 id="权矩阵">权矩阵</h4><ul><li>赋权图常用权矩阵 <span class="math inline"><strong>A</strong></span>进行表示。其元素 <span class="math display">$$  a_{i j}= \left\{\begin{aligned}  w_{i j},&amp;\quad \left(v_{i},v_{j}\right) \in E \\  0,&amp;\quad otherwise  \end{aligned}\right.  $$</span></li><li>权矩阵实际即为带权值的邻接矩阵</li><li>权矩阵<strong>可以表示自环，但无法表示重边</strong>。</li><li>无向图的权矩阵，是一个对称矩阵</li></ul><figure><img src="image-4.webp" srcset="/img/loading/loading3.gif" lazyload alt="权矩阵"><figcaption aria-hidden="true">权矩阵</figcaption></figure><h4 id="关联矩阵">关联矩阵</h4><ul><li>关联矩阵表示结点与边之间的关联关系。</li><li>有向图 <span class="math inline"><strong>G</strong></span>的关联矩阵 <span class="math inline"><strong>B</strong></span> 是 <span class="math inline"><em>n</em> × <em>m</em></span>的矩阵，当给定结点和边的编号之后，其元素 <span class="math display">$$  b_{i j}=\left\{\begin{aligned}  1,&amp;\quad e_{j}=\left(v_{i},v_{k}\right) \in E \\  -1,&amp;\quad e_{j}=\left(v_{k},v_{i}\right) \in E \\  0, &amp;\quad otherwise  \end{aligned}\right.  $$</span></li><li>每列两个非零元：-1，1</li><li>第 <span class="math inline"><em>i</em></span>行非零元的数目恰是结点 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 的度，其中<span class="math inline">1</span> 元的数目是 <span class="math inline"><em>d</em><sup>+</sup>(<em>v</em><sub><em>i</em></sub>)</span>，<span class="math inline">−1</span> 元的数目是 <span class="math inline"><em>d</em><sup>−</sup>(<em>v</em><sub><em>i</em></sub>)</span>。</li><li>类似地，无向图也有其关联矩阵 <span class="math inline"><strong>B</strong></span>，但其中不含 <span class="math inline">−1</span> 元素。 <span class="math display">$$  b_{i j}=\left\{\begin{aligned}  1,&amp;\quad e_{j}=\left(v_{i},v_{k}\right) \in E \\  0, &amp;\quad otherwise  \end{aligned}\right.  $$</span></li><li>关联矩阵<strong>可以表示重边，但无法表示自环</strong>。</li><li>如果可以用邻接矩阵/关联矩阵表示某个图 <span class="math inline"><em>G</em></span>，则表示是<strong>唯一</strong>的。</li></ul><h4 id="邻接表">邻接表</h4><ul><li>邻接表是图的另一种表示方法。它是一个结点集 <span class="math inline"><em>V</em></span> 的数组，每个结点 <span class="math inline"><em>v</em><sub><em>i</em></sub></span>都有一个链表，链表中存储与 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 相邻的结点。<ul><li>对于有向图，链表中存储的是 <span class="math inline"><em>v</em><sub><em>i</em></sub></span>的直接后继集（外邻集）；</li><li>对于无向图，链表中存储的是 <span class="math inline"><em>v</em><sub><em>i</em></sub></span>的邻点集。</li></ul></li><li>表结点的结构：<ul><li>邻接点的编号</li><li>边权值（如果是赋权图）</li><li>指向下一个邻接点的指针</li></ul></li><li>特点：<ul><li>便于增加和删除边</li><li><strong>可以表示重边和自环</strong></li><li><strong>可以唯一表示任意一个图</strong></li><li>所需存储空间较小</li></ul></li></ul><figure><img src="image-5.webp" srcset="/img/loading/loading3.gif" lazyload alt="邻接表"><figcaption aria-hidden="true">邻接表</figcaption></figure><h2 id="第二章-道路与回路">第二章 道路与回路</h2><h3 id="道路与回路">道路与回路</h3><ul><li><strong>有向图</strong><ul><li><strong>道路与回路的定义</strong>：<ul><li><strong>有向道路</strong>：有向图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>中，若边序列 <span class="math inline"><em>P</em> = (<em>e</em><sub><em>i</em>1</sub>, <em>e</em><sub><em>i</em>2</sub>, ⋯, <em>e</em><sub><em>i</em><em>q</em></sub>)</span>，其中<span class="math inline"><em>e</em><sub><em>i</em><em>k</em></sub> = (<em>v</em><sub><em>l</em></sub>, <em>v</em><sub><em>j</em></sub>)</span>满足 <span class="math inline"><em>v</em><sub><em>l</em></sub></span> 是<span class="math inline"><em>e</em><sub><em>i</em><em>k</em> − 1</sub></span>的终点，<span class="math inline"><em>v</em><sub><em>j</em></sub></span>是 <span class="math inline"><em>e</em><sub><em>i</em><em>k</em> + 1</sub></span>的始点，就称 <span class="math inline"><em>P</em></span> 是 <span class="math inline"><em>G</em></span> 的一条有向道路。</li><li><strong>有向回路</strong>：如果 <span class="math inline"><em>e</em><sub><em>i</em><em>q</em></sub></span>的终点也是 <span class="math inline"><em>e</em><sub><em>i</em>1</sub></span> 的始点，则称<span class="math inline"><em>P</em></span> 是 <span class="math inline"><em>G</em></span> 的一条有向回路。</li></ul></li><li>简单/初级有向道路/回路：<ul><li><strong>简单有向道路和简单有向回路</strong>：如果 <span class="math inline"><em>P</em></span>中的边没有重复出现，则分别称为简单有向道路和简单有向回路。</li><li><strong>初级有向道路和初级有向回路</strong>：如果在 <span class="math inline"><em>P</em></span>中结点也不重复出现，又分别称它们是初级有向道路和初级有向回路，简称为路和回路。</li><li>显然，初级有向道路（回路）一定是简单有向道路（回路）。</li></ul></li><li><strong>长度</strong>：边的数目 <span class="math inline"><em>q</em></span> 称为道路（回路）的长度。</li></ul></li></ul><figure><img src="image-6.webp" srcset="/img/loading/loading3.gif" lazyload alt="有向道路/回路"><figcaption aria-hidden="true">有向道路/回路</figcaption></figure><ul><li><strong>无向图</strong><ul><li><strong>道路与回路的定义</strong>：<ul><li><strong>无向道路</strong>：无向图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>中，若点边交替序列 <span class="math inline"><em>P</em> = (<em>v</em><sub><em>i</em>1</sub>, <em>e</em><sub><em>i</em>1</sub>, <em>v</em><sub><em>i</em>2</sub>, <em>e</em><sub><em>i</em>2</sub>, ⋯, <em>e</em><sub><em>i</em><em>q</em> − 1</sub>, <em>v</em><sub><em>i</em><em>q</em></sub>)</span>满足 <span class="math inline"><em>v</em><sub><em>i</em><em>k</em></sub>, <em>v</em><sub><em>i</em><em>k</em> + 1</sub></span>是 <span class="math inline"><em>e</em><sub><em>i</em><em>k</em></sub></span>的两个端点，则称 <span class="math inline"><em>P</em></span> 是 <span class="math inline"><em>G</em></span>中的一条<strong>链</strong>，或<strong>道路</strong>。</li><li><strong>无向回路</strong>：如果 <span class="math inline"><em>v</em><sub><em>i</em><em>q</em></sub> = <em>v</em><sub><em>i</em>1</sub></span>，则称<span class="math inline"><em>P</em></span> 是 <span class="math inline"><em>G</em></span>中的一个<strong>圈</strong>，或<strong>回路</strong>。</li></ul></li><li>简单/初级无向道路/回路：<ul><li><strong>简单道路和简单回路</strong>：如果 <span class="math inline"><em>P</em></span>中没有重复出现的边，称之为简单道路或简单回路</li><li><strong>初级道路和初级回路</strong>：若其中结点也不重复，又称之为初级道路或初级回路</li></ul></li><li><strong>长度</strong>：边的数目 <span class="math inline"><em>q</em></span> 称为道路（回路）的长度。</li></ul></li><li><strong>两点距离</strong>：若 <span class="math inline"><em>G</em></span> 的任意两结点 <span class="math inline"><em>u</em>, <em>v</em></span> 之间连通，则称 <span class="math inline"><em>u</em>, <em>v</em></span>之间的最短道路为<strong>短程线</strong>，该短程线的长度称为 <span class="math inline"><em>u</em>, <em>v</em></span>之间的<strong>距离</strong>，记作 <span class="math inline"><em>d</em>(<em>u</em>, <em>v</em>)</span>。若 <span class="math inline"><em>u</em>, <em>v</em></span> 之间不连通，则 <span class="math inline"><em>d</em>(<em>u</em>, <em>v</em>) = ∞</span></li></ul><h3 id="图的连通性">图的连通性</h3><ul><li><strong>连通图与非连通图</strong>：<ul><li>无向图：设 <span class="math inline"><em>G</em></span> 是无向图，若<span class="math inline"><em>G</em></span>的任意两结点之间都存在道路，就称 <span class="math inline"><em>G</em></span> 是连通图，否则称为非连通图</li><li>有向图：如果 <span class="math inline"><em>G</em></span>是有向图，不考虑其边的方向，即视为无向图，若它是连通的，则称 <span class="math inline"><em>G</em></span> 是连通图</li></ul></li></ul><figure><img src="image-7.webp" srcset="/img/loading/loading3.gif" lazyload alt="连通图与非连通图"><figcaption aria-hidden="true">连通图与非连通图</figcaption></figure><ul><li><strong>极大连通子图/连通支</strong>：若连通子图 <span class="math inline"><em>H</em></span> 不是 <span class="math inline"><em>G</em></span> 的任何连通子图的真子图，则称 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的极大连通子图或称连通支<ul><li>显然 <span class="math inline"><em>G</em></span>的每个连通支都是它的导出子图</li><li>任何非连通图都是 <span class="math inline">2</span>个以上连通支的并集</li><li>设 <span class="math inline"><em>G</em></span> 是简单无向图，当<span class="math inline">$m&gt;\frac{1}{2}(n−1)(n−2)$</span> 时 <span class="math inline"><em>G</em></span> 是连通图。</li><li><span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>是连通图，则 <span class="math inline"><em>m</em> ≥ <em>n</em> − 1</span></li></ul></li><li><strong>强连通</strong>：在有向图 <span class="math inline"><em>G</em></span> 中，如果两个顶点 <span class="math inline"><em>u</em></span>，<span class="math inline"><em>v</em></span> 间有一条从 <span class="math inline"><em>u</em></span> 到 <span class="math inline"><em>v</em></span> 的有向路径，同时还有一条从 <span class="math inline"><em>v</em></span> 到 <span class="math inline"><em>u</em></span> 的有向路径，则称两个顶点强连通。<ul><li><strong>强连通图</strong>：如果有向图 <span class="math inline"><em>G</em></span> 的每两个顶点都强连通，称 <span class="math inline"><em>G</em></span> 是一个强连通图。</li><li><strong>强连通分量</strong>：有向非强连通图的极大强连通子图，称为强连通分量。</li></ul></li></ul><h3 id="弦">弦</h3><ul><li><strong>定义</strong>：设 <span class="math inline"><em>C</em></span> 是简单图 <span class="math inline"><em>G</em></span> 中含结点数大于 <span class="math inline">3</span> 的一个初级回路，如果结点 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 和 <span class="math inline"><em>v</em><sub><em>j</em></sub></span> 在 <span class="math inline">C</span> 中不相邻，而边 <span class="math inline">(<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>) ∈ E(G)</span>，则称<span class="math inline">(<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)</span>是 <span class="math inline">C</span> 的一条<strong>弦</strong>。</li><li><strong>性质</strong>：<ul><li>若对于每一个 <span class="math inline"><em>v</em><sub><em>k</em></sub> ∈ V(G)</span>，都有<span class="math inline">d(<em>v</em><sub><em>k</em></sub>) ≥ 3</span>，则<span class="math inline">G</span> 中必含带弦的回路。</li><li>在简单图中，若 <span class="math inline"><em>n</em> ≥ 4</span> 且<span class="math inline"><em>m</em> ≥ 2<em>n</em> − 3</span>，则 <span class="math inline"><em>G</em></span> 中含有带弦的回路。</li></ul></li></ul><h3 id="极长初级道路">极长初级道路</h3><ul><li><strong>定义</strong>：在简单图 <span class="math inline">G = (V, E)</span> 中，<span class="math inline">E ≠ ∅</span>，设 <span class="math inline"><em>P</em> = (<em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>, ⋯, <em>v</em><sub><em>l</em></sub>)</span>为 <span class="math inline">G</span>中一条初级道路，若路径的始点和终点两个端点 <span class="math inline"><em>v</em><sub>0</sub></span> 和 <span class="math inline"><em>v</em><sub><em>l</em></sub></span>不与初级道路本身结点集以外的任何结点相邻，这样的初级道路称为<strong>极长初级道路</strong>。</li><li><strong>性质</strong>：<ul><li>有向图中，初级道路始点的直接前驱集（内邻集），终点的直接后继集（外邻集），都在初级道路本身上。</li><li><strong>扩大初级道路法</strong>：任何一条初级道路，如果不是极长初级道路，则至少有一个端点与初级道路本身以外的结点相邻，则将该结点及其相关联的边扩到新的初级道路中来，得到更新的初级道路。继续上述过程，直到变成极长初级道路为止。<ul><li>由一条道路扩大的极长道路不一定唯一</li><li>极长初级道路不一定是图中的最长初级道路</li></ul></li></ul></li></ul><figure><img src="image-8.webp" srcset="/img/loading/loading3.gif" lazyload alt="扩大初级道路法"><figcaption aria-hidden="true">扩大初级道路法</figcaption></figure><h3 id="二分图">二分图</h3><ul><li><strong>定义</strong>：<span class="math inline">G = (V, E)</span>是无向图，如果 <span class="math inline">V(G)</span> 可以划分为子集<span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span>，使得所有 <span class="math inline"><em>e</em> = (<em>u</em>, <em>v</em>) ∈ <em>E</em>(<em>G</em>)</span>，<span class="math inline"><em>u</em></span> 和 <span class="math inline"><em>v</em></span> 分属于 <span class="math inline">X</span> 和 <span class="math inline">Y</span>，则称<span class="math inline">G</span> 为二分图。</li><li><strong>性质</strong>：<ul><li>二分图的子集 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span> 可能不唯一。</li><li>如果二分图 <span class="math inline"><em>G</em></span>中存在回路，则它们是由偶数条边组成的。</li><li>含 <span class="math inline"><em>K</em><sub>3</sub></span>子图的图一定不是二分图</li><li><span class="math inline"><em>K</em><sub><em>n</em></sub></span>不是二分图（<span class="math inline"><em>n</em> ≥ 3</span>）</li><li>如果二分图 <span class="math inline"><em>G</em></span>中存在回路，则它们都是由偶数条边组成的。</li></ul></li><li><strong>完全二分图/完全偶图</strong>：<span class="math inline">G = (V, E)</span> 是二分图，<span class="math inline">V(G)</span> 划分为子集 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span>，<span class="math inline"><em>X</em></span> 中任一结点与 <span class="math inline"><em>Y</em></span>中每一个结点有且只有唯一一条边相连，则称 <span class="math inline"><em>G</em></span> 为完全二分图（完全偶图），记作<span class="math inline"><strong>K</strong><sub><em>m</em>, <em>n</em></sub></span>，<span class="math inline"><em>m</em> = |<em>X</em>|</span>，<span class="math inline"><em>n</em> = |<em>Y</em>|</span>。</li></ul><h3 id="补图">补图</h3><ul><li><strong>定义</strong>： 设 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>是一个简单图，则 <span class="math inline"><em>G</em></span> 的补图<span class="math inline"><em>Ḡ</em></span> 是一个简单图，其结点集 <span class="math inline"><em>V</em>(<em>Ḡ</em>) = <em>V</em>(<em>G</em>) = <em>V</em></span>，边集为<span class="math inline"><em>E</em>(<em>Ḡ</em>) = {(<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>) ∣ <em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub> ∈ <em>V</em>, (<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>) ∉ <em>E</em>}</span>。</li></ul><h3 id="割点和割边">割点和割边</h3><ul><li><strong>割点</strong>：<span class="math inline"><em>G</em></span>图中，一结点 <span class="math inline"><em>u</em></span>，<span class="math inline"><em>G</em></span> 减去 <span class="math inline"><em>u</em></span> 后，图的连通分支数上升，则称 <span class="math inline"><em>u</em></span> 为图 <span class="math inline"><em>G</em></span> 的割点。<br></li><li><strong>割边</strong>：<span class="math inline"><em>G</em></span>图中，一边 <span class="math inline"><em>e</em></span>，<span class="math inline"><em>G</em></span> 减去 <span class="math inline"><em>e</em></span> 后，图的连通分支数上升，则称 <span class="math inline"><em>e</em></span> 为图 <span class="math inline"><em>G</em></span> 的割边/桥。</li></ul><h3 id="欧拉道路与回路">欧拉道路与回路</h3><h4 id="定义与性质">定义与性质</h4><ul><li><strong>定义</strong>：<ul><li><strong>欧拉回路/道路</strong>：无向连通图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>中的一条经过所有边的简单回路（道路）称为 <span class="math inline"><em>G</em></span> 的欧拉回路（道路）。</li><li><strong>欧拉图</strong>：具有欧拉回路的图称为欧拉图。</li></ul></li><li><strong>性质</strong>：<ul><li>无向连通图 <span class="math inline"><em>G</em></span>存在欧拉回路的充要条件是 <span class="math inline"><em>G</em></span>中各结点的度都是偶数。</li><li>若无向连通图 <span class="math inline"><em>G</em></span> 中只有<span class="math inline">2</span> 个度为奇的结点，则 <span class="math inline"><em>G</em></span> 存在欧拉道路。</li><li>若有向连通图 <span class="math inline"><em>G</em></span>中各结点的正、负度相等，则 <span class="math inline"><em>G</em></span>存在有向欧拉回路。</li><li><span class="math inline"><em>K</em><sub><em>n</em>, <em>m</em></sub></span>中含有欧拉道路当且仅当 <span class="math inline"><em>n</em>, <em>m</em></span> 均为偶数。</li><li>设连通图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> 有<span class="math inline"><em>k</em></span> 个度为奇数的结点，则 <span class="math inline"><em>E</em>(<em>G</em>)</span> 可以划分为 <span class="math inline"><em>k</em>/2</span> 条简单道路。</li></ul></li></ul><h4 id="判定仅针对无向图">判定（仅针对无向图）</h4><ul><li>如果图 <span class="math inline"><em>G</em></span>每个结点的度都是偶数，则 <span class="math inline"><em>G</em></span>存在欧拉回路。</li><li>如果图 <span class="math inline"><em>G</em></span>有且仅有两个结点的度为奇数，则 <span class="math inline"><em>G</em></span>存在欧拉道路，且这两个结点是欧拉道路的起点和终点。</li><li>其他情况下，<span class="math inline"><em>G</em></span>不存在欧拉道路或回路，但是奇数点数为 <span class="math inline"><em>k</em></span> 的图 <span class="math inline"><em>G</em></span> 中，存在 <span class="math inline"><em>k</em>/2</span> 条简单道路。</li></ul><figure><img src="image-9.webp" srcset="/img/loading/loading3.gif" lazyload alt="构造欧拉回路"><figcaption aria-hidden="true">构造欧拉回路</figcaption></figure><h3 id="哈密顿道路与回路">哈密顿道路与回路</h3><h4 id="定义与性质-1">定义与性质</h4><ul><li><strong>定义</strong>：<ul><li><strong>哈密顿回路/道路</strong>：无向图的一条过全部结点的初级回路（道路）称为<span class="math inline"><em>G</em></span> 的哈密顿回路（道路），简记为<span class="math inline"><em>H</em></span> 回路（道路）。</li><li><strong>哈密顿图</strong>：具有哈密顿回路的图也称为哈密顿图。</li></ul></li><li><strong>性质</strong>：<ul><li>哈密顿通路是经过所有结点中长度最短的通路</li><li>哈密顿回路是经过所有结点中长度最短的回路</li></ul></li></ul><figure><img src="image-10.webp" srcset="/img/loading/loading3.gif" lazyload alt="哈密顿图"><figcaption aria-hidden="true">哈密顿图</figcaption></figure><h4 id="判定">判定</h4><ul><li>哈密顿回路是初级回路，是特殊的简单回路，所以如果 <span class="math inline"><em>G</em></span>中含有重边或自环，删去它们后得到的简单图 <span class="math inline"><em>G</em><sup>′</sup></span>，那么 <span class="math inline"><em>G</em></span> 和 <span class="math inline"><em>G</em><sup>′</sup></span> 关于 <span class="math inline"><em>H</em></span>回路（道路）的存在性是等价的。因此，<strong>判定 <span class="math inline"><em>H</em></span>回路存在性问题一般是针对简单图的</strong>。</li></ul><h4 id="充分性定理">充分性定理</h4><ul><li><strong>引理</strong>：设 <span class="math inline"><em>P</em> = (<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ⋯, <em>v</em><sub><em>l</em></sub>)</span>是图 <span class="math inline"><em>G</em></span> 中一条极长的初级道路(即<span class="math inline"><em>v</em><sub>1</sub></span> 和 <span class="math inline"><em>v</em><sub><em>l</em></sub></span> 的邻点都在<span class="math inline"><em>P</em></span> 上)而且 <span class="math inline"><em>d</em>(<em>v</em><sub>1</sub>) + <em>d</em>(<em>v</em><sub><em>l</em></sub>) ≥ <em>l</em></span>，则<span class="math inline"><em>G</em></span> 中一定存在经过结点 <span class="math inline"><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ⋯, <em>v</em><sub><em>l</em></sub></span>的初级回路。<ol type="1"><li><strong>充分性定理 1</strong>：如果简单图 <span class="math inline"><em>G</em></span> 的任意两结点 <span class="math inline"><em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub></span>之间恒有 <span class="math inline"><em>d</em>(<em>v</em><sub><em>i</em></sub>) + <em>d</em>(<em>v</em><sub><em>j</em></sub>) ≥ <em>n</em> − 1</span>，则<span class="math inline"><em>G</em></span> 中存在哈密顿道路。</li><li><strong>充分性定理 1 推论</strong>：若简单图 <span class="math inline"><em>G</em></span> 的任意两结点 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 和 <span class="math inline"><em>v</em><sub><em>j</em></sub></span> 之间恒有<span class="math inline"><em>d</em>(<em>v</em><sub><em>i</em></sub>) + <em>d</em>(<em>v</em><sub><em>j</em></sub>) ≥ <em>n</em></span>，则<span class="math inline"><em>G</em></span> 中存在哈密顿回路。</li><li><strong>充分性定理 1 推论</strong>：若简单图 <span class="math inline"><em>G</em></span> 每个结点的度都大于等于 <span class="math inline">$\frac{n}{2}$</span>，则 <span class="math inline"><em>G</em></span> 有 <span class="math inline"><em>H</em></span> 回路。</li></ol></li><li><strong>引理</strong>：若 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 和 <span class="math inline"><em>v</em><sub><em>j</em></sub></span> 是简单图<span class="math inline"><em>G</em></span> 的不相邻结点，且满足 <span class="math inline"><em>d</em>(<em>v</em><sub><em>i</em></sub>) + <em>d</em>(<em>v</em><sub><em>j</em></sub>) ≥ <em>n</em></span>，则令<span class="math inline"><em>G</em>’ = <em>G</em> + (<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)</span>。对<span class="math inline"><em>G</em>’</span>重复上述过程，直至不再有这样的结点对为止。最终得到的图为 <span class="math inline"><em>G</em></span> 的闭合图，记作 <span class="math inline"><em>C</em>(<em>G</em>)</span>。则简单图 <span class="math inline"><em>G</em></span> 的闭合图 <span class="math inline"><em>C</em>(<em>G</em>)</span> 是唯一的<ol type="1"><li><strong>充分性定理 2</strong>：设 <span class="math inline"><em>G</em></span> 是简单图，<span class="math inline"><em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub></span>是不相邻结点，且满足 <span class="math inline"><em>d</em>(<em>v</em><sub><em>i</em></sub>) + <em>d</em>(<em>v</em><sub><em>j</em></sub>) ≥ <em>n</em><sub>∘</sub></span>则 <span class="math inline"><em>G</em></span> 存在 <span class="math inline"><em>H</em></span> 回路的充要条件是 <span class="math inline"><em>G</em> + (<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)</span>有 <span class="math inline"><em>H</em></span> 回路。</li><li><strong>充要条件</strong>：简单图 <span class="math inline"><em>G</em></span>存在哈密顿回路的充要条件是其闭合图存在哈密顿回路。</li><li><strong>充要条件推论</strong>：设 <span class="math inline"><em>G</em>(<em>n</em> ≥ 3)</span> 是简单图 <span class="math inline"><em>K</em><sub><em>n</em></sub></span>，若 <span class="math inline"><em>C</em>(<em>G</em>)</span> 是完全图，则 <span class="math inline"><em>G</em></span> 有 <span class="math inline"><em>H</em></span> 回路。</li></ol></li></ul><h4 id="必要性定理">必要性定理</h4><ul><li><strong>必要性定理 1</strong>：如无向图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> 是<span class="math inline"><em>H</em></span> 图，<span class="math inline"><em>V</em><sub>1</sub></span> 是 <span class="math inline"><em>V</em></span> 的任意非空子集，则 <span class="math inline"><em>p</em>(<em>G</em> − <em>V</em><sub>1</sub>) ≤ |<em>V</em><sub>1</sub>|</span>，其中<span class="math inline"><em>p</em>(<em>G</em> − <em>V</em><sub>1</sub>)</span>是从 <span class="math inline">G</span> 中删除 <span class="math inline"><em>V</em><sub>1</sub></span>后的连通支的数目。</li><li><strong>必要性定理 2</strong>：如无向图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span> 存在<span class="math inline">H</span> 道路，<span class="math inline"><em>V</em><sub>1</sub></span> 是 <span class="math inline"><em>V</em></span> 的任意非空子集，则 <span class="math inline"><em>p</em>(<em>G</em> − <em>V</em><sub>1</sub>) ≤ |<em>V</em><sub>1</sub>| + 1</span>。</li><li><strong>必要性定理推论</strong>：<ul><li>有割点的图一定不是 <span class="math inline"><em>H</em></span>图</li><li>如无向图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>是二分图，<ul><li>两边结点数不相同，则 <span class="math inline"><em>G</em></span>不存在 <span class="math inline"><em>H</em></span> 回路</li><li>两边结点数不相同也不相差 <span class="math inline">1</span>，则<span class="math inline"><em>G</em></span> 不存在 <span class="math inline"><em>H</em></span> 道路</li></ul></li><li><span class="math inline"><em>K</em><sub><em>n</em>, <em>m</em></sub></span>中含有哈密顿道路当且仅当 <span class="math inline">|<em>n</em> − <em>m</em>| ≤ 1</span></li><li><span class="math inline"><em>K</em><sub><em>n</em>, <em>m</em></sub></span>中含有哈密顿回路当且仅当 <span class="math inline"><em>n</em> = <em>m</em></span></li></ul></li></ul><h2 id="第三章-树">第三章 树</h2><h3 id="树的有关定义">树的有关定义</h3><ul><li><strong>树与林</strong>：<ul><li><strong>林</strong>：给定一个图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>，如果它不含任何回路，我们就叫它是林。</li><li><strong>树</strong>：如果 <span class="math inline"><em>G</em></span>又是连通的，即这个林只有一个连通支，就称它是树。<ul><li>一个不含任何回路的连通图称为<strong>树</strong>，用 <span class="math inline"><em>T</em></span> 表示。</li><li><span class="math inline"><em>T</em></span>中的边称为<strong>树枝</strong>，度为 <span class="math inline">1</span>的结点称为<strong>树叶</strong>。</li></ul></li></ul></li><li><strong>割边</strong>：树的每条边都不会属于任何回路。这样的边叫割边。<ul><li>设 <span class="math inline"><em>e</em></span> 是 <span class="math inline"><em>G</em></span> 的一条边，若 <span class="math inline"><em>G</em><sup>′</sup> = <em>G</em> − <em>e</em></span>比 <span class="math inline"><em>G</em></span> 的连通支数增加，则称<span class="math inline"><em>e</em></span> 是 <span class="math inline"><em>G</em></span> 的一条<strong>割边</strong>。</li><li><span class="math inline"><em>e</em> = (<em>u</em>, <em>v</em>)</span>是<strong>割边</strong>，当且仅当 <span class="math inline"><em>e</em></span> 不属于 <span class="math inline"><em>G</em></span> 的任何回路。</li></ul></li><li><strong>性质</strong>：设 <span class="math inline"><em>T</em></span> 是结点数为 <span class="math inline"><em>n</em> ≥ 2</span> 的树，则下列性质等价：<ul><li><span class="math inline"><em>T</em></span> 连通且无回路。</li><li><span class="math inline"><em>T</em></span>连通且每条边都是割边。</li><li><span class="math inline"><em>T</em></span> 连通且有 <span class="math inline"><em>n</em> − 1</span> 条边。<ul><li>树是极小的连通图，减少一条边就不连通</li></ul></li><li><span class="math inline"><em>T</em></span> 有 <span class="math inline"><em>n</em> − 1</span> 条边且无回路。</li><li><span class="math inline"><em>T</em></span>的任意两结点间有唯一道路。</li><li><span class="math inline"><em>T</em></span>无回路，但在任两结点间加上一条边后恰有一个回路。<ul><li>树是极大的不含回路的连通图。</li></ul></li></ul></li><li>树 <span class="math inline"><em>T</em></span>中一定存在树叶结点。</li></ul><h3 id="生成树">生成树</h3><ul><li><strong>支撑树/生成树</strong>：如果 <span class="math inline"><em>T</em></span> 是图 <span class="math inline"><em>G</em></span> 的支撑子图，而且又是一棵树，则称<span class="math inline"><em>T</em></span> 是 <span class="math inline"><em>G</em></span> 的一棵支撑树，或称生成树，又简称为<span class="math inline"><em>G</em></span> 的树。</li><li>任何无向连通图 <span class="math inline"><em>G</em></span>都含有生成树。<ul><li>一个连通图的生成树可能不唯一。</li></ul></li></ul><figure><img src="image-11.webp" srcset="/img/loading/loading3.gif" lazyload alt="生成树"><figcaption aria-hidden="true">生成树</figcaption></figure><ul><li><strong>余树</strong>：给定图 <span class="math inline"><em>G</em></span> 的一棵树 <span class="math inline"><em>T</em></span>，我们称 <span class="math inline"><em>G</em> − <em>T</em></span>，即 <span class="math inline"><em>G</em></span> 删去 <span class="math inline"><em>T</em></span> 中各边后的子图为 <span class="math inline"><em>T</em></span> 的余树。<ul><li>余树不一定连通，也不一定无回路，因而余树不一定是树，更不一定是生成树。</li></ul></li></ul><h3 id="二叉树">二叉树</h3><ul><li><strong>定义</strong>：除叶子结点外，其余结点的正度最多为 <span class="math inline">2</span> 的外向树称为<strong>二叉树</strong>。</li><li><strong>性质</strong>：<ul><li>二叉树的结点集是有限集合，它或者为空，或者由根结点及两棵互不相交的左右子树的结点集构成，该左右子树也均为二叉树</li><li>左子树为根结点左侧分叉的子树，右子树为根结点右侧分叉的子树，其<strong>严格区分</strong>，即使只有一棵子树也要说明是左子树还是右子树；左右子树交换位置，得到一棵新的二叉树</li><li>二叉树的第 <span class="math inline"><em>i</em></span> 层至多有<span class="math inline">2<sup>(<em>i</em> − 1)</sup></span>个结点</li><li>深度为 <span class="math inline"><em>k</em></span> 的二叉树至多有<span class="math inline">2<sup><em>k</em></sup> − 1</span>个结点（根结点的深度为 <span class="math inline">1</span>）</li></ul></li><li><strong>满二叉树</strong>：一棵高度（即结点层数）为 <span class="math inline"><em>k</em></span>，并具有 <span class="math inline">2<sup><em>k</em></sup> − 1</span>个结点的二叉树，称为满二叉树.<ul><li>一棵二叉树中任意一层的结点个数都达到了最大值</li></ul></li><li><strong>完全二叉树</strong>：若设二叉树的深度为 <span class="math inline"><em>h</em></span>，除第 <span class="math inline"><em>h</em></span> 层外，其它各层 <span class="math inline">1&nbsp;<em>h</em> − 1</span> 的结点数都达到最大个数，第<span class="math inline"><em>h</em></span>层所有的结点都连续集中在最左边，这就是完全二叉树。<ul><li>在满二叉树的最底层自右至左依次去掉若干个结点得到的二叉树</li><li>满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树</li><li>所有的叶结点都出现在最低的两层上。</li><li>对任一结点，如果其右子树的高度为 <span class="math inline"><em>k</em></span>，则其左子树的高度为 <span class="math inline"><em>k</em></span> 或 <span class="math inline"><em>k</em> + 1</span>。</li></ul></li></ul><h3 id="哈夫曼树">哈夫曼树</h3><ul><li><strong>赋权二叉树</strong>：如果二叉树 <span class="math inline"><em>T</em></span> 的每个叶子结点 <span class="math inline"><em>v</em><sub><em>i</em></sub></span>都赋予一个正实数 <span class="math inline"><em>w</em><sub><em>i</em></sub></span>，则称 <span class="math inline"><em>T</em></span> 为赋权二叉树</li><li><strong>带权路径总长度</strong>：从根到树叶 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 的路径 <span class="math inline"><em>P</em>(<em>v</em><sub>0</sub>, <em>v</em><sub><em>i</em></sub>)</span>所包含的边数计为该路径的长度 <span class="math inline"><em>l</em></span>，这样二叉树 <span class="math inline"><em>T</em></span> 带权的路径总长度为： <span class="math display"><em>W</em><em>P</em><em>L</em> = ∑<sub><em>i</em></sub><em>l</em><sub><em>i</em></sub><em>w</em><sub><em>i</em></sub>,  <em>v</em><sub><em>i</em></sub>是树叶</span></li><li><strong>最优二叉树/哈夫曼树</strong>：给定叶子结点数目以及每个叶子结点对应的权值，可以构造许多不同的赋权二叉树。在这些二叉树中，带权路径总长最小的二叉树，称为最优二叉树，又称哈夫曼树。</li></ul><h4 id="huffman算法">Huffman算法</h4><ol type="1"><li>对 <span class="math inline"><em>n</em>(<em>n</em> ≥ 2)</span>个权值进行排序，满足 <span class="math inline"><em>w</em><sub><em>i</em>1</sub> ≤ <em>w</em><sub><em>i</em>2</sub> ≤ ⋯ ≤ <em>w</em><sub><em>i</em><em>n</em></sub></span></li><li>计算 <span class="math inline"><em>w</em><sub><em>i</em></sub> = <em>w</em><sub><em>i</em>1</sub> + <em>w</em><sub><em>i</em>2</sub></span>作为中间结点 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 的权，<span class="math inline"><em>v</em><sub><em>i</em></sub></span> 的左儿子是<span class="math inline"><em>v</em><sub><em>i</em>1</sub></span>，右儿子是<span class="math inline"><em>v</em><sub><em>i</em>2</sub></span>。在权序列中删去<span class="math inline"><em>w</em><sub><em>i</em>1</sub></span> 和<span class="math inline"><em>w</em><sub><em>i</em>2</sub></span>，加入<span class="math inline"><em>w</em><sub><em>i</em></sub></span>，<span class="math inline"><em>n</em> ← <em>n</em> − 1</span>，若 <span class="math inline"><em>n</em> = 1</span>，结束。否则转 1。</li></ol><figure><img src="image-12.webp" srcset="/img/loading/loading3.gif" lazyload alt="Huffman算法"><figcaption aria-hidden="true">Huffman算法</figcaption></figure><h3 id="最短树最小生成树">最短树（最小生成树）</h3><ul><li><strong>最小/最大生成树</strong>：在赋权连通图 <span class="math inline"><em>G</em></span>中，其总长最小和最大的生成树，就被称为最短树和最长树，亦或称为最小生成树和最大生成树。</li><li><strong>充要条件</strong>：<span class="math inline"><em>T</em> = (<em>V</em>, <em>E</em>’)</span>是赋权连通图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>的最短树，当且仅当对任意的余树边 <span class="math inline"><em>e</em> ∈ <em>E</em> − <em>E</em>’</span>，回路<span class="math inline"><em>C</em><sub><em>e</em></sub> ⊆ <em>E</em>’ + <em>e</em></span>，满足其边权<span class="math inline"><em>w</em>(<em>e</em>) ≥ <em>w</em>(<em>a</em>), <em>a</em> ∈ <em>C</em><sub><em>e</em></sub>(<em>a</em> ≠ <em>e</em>)</span>。</li></ul><h4 id="kruskal算法">Kruskal算法</h4><ul><li><strong>基本思想</strong>：不断往 <span class="math inline"><em>T</em></span> 中加入当前的最短边 <span class="math inline"><em>e</em></span>，如果此时会构成回路，那么它一定是这个回路中的最长边，删之。直至最后达到<span class="math inline"><em>n</em> − 1</span> 条边为止。这时 <span class="math inline"><em>T</em></span> 中不包含任何回路，因此是树。</li><li><strong>Kruskal算法</strong>、<ol type="1"><li><span class="math inline"><em>T</em> ← ∅</span></li><li>当 <span class="math inline">|<em>T</em>| &lt; <em>n</em> − 1</span>且 <span class="math inline"><em>E</em> ≠ ∅</span> 时，<ol type="1"><li><span class="math inline"><em>e</em> ← <em>E</em></span>中最短边.</li><li><span class="math inline"><em>E</em> ← <em>E</em> − <em>e</em></span>.</li><li>若 <span class="math inline"><em>T</em> + <em>e</em></span> 无回路,则 <span class="math inline"><em>T</em> ← <em>T</em> + <em>e</em></span>.</li></ol></li><li>若 <span class="math inline">|<em>T</em>| &lt; <em>n</em> − 1</span>打印” 非连通” , 否则输出最短树</li></ol></li><li>计算复杂度：<span class="math inline"><em>O</em>(<em>m</em> + <em>p</em> ⋅ log <em>m</em>)</span>，其中<span class="math inline"><em>m</em></span> 为边数，<span class="math inline"><em>p</em></span> 是迭代次数</li></ul><figure><img src="image-13.webp" srcset="/img/loading/loading3.gif" lazyload alt="Kruskal算法"><figcaption aria-hidden="true">Kruskal算法</figcaption></figure><h4 id="prim算法">Prim算法</h4><ul><li><strong>基本思想</strong>：首先任选一结点 <span class="math inline"><em>v</em><sub>0</sub></span> 构成集合 <span class="math inline"><em>U</em></span>，然后不断在 <span class="math inline"><em>V</em> − <em>U</em></span> 中选一条到 <span class="math inline"><em>U</em></span> 中最短的边 <span class="math inline">(<em>u</em>, <em>v</em>)</span>（其中 <span class="math inline"><em>u</em> ∈ <em>V</em> − <em>U</em>, <em>v</em> ∈ <em>U</em></span>）进入树<span class="math inline"><em>T</em></span>，并且 <span class="math inline"><em>U</em> ← <em>U</em> + <em>u</em></span>，直到<span class="math inline"><em>U</em> = <em>V</em></span>。</li><li><strong>Prim算法</strong>：<ol type="1"><li><span class="math inline"><em>t</em> ← <em>v</em><sub>1</sub>, <em>T</em> ← ∅, <em>U</em> ← {<em>t</em>}</span></li><li>While <span class="math inline"><em>U</em> ≠ <em>V</em></span> do<ol type="1"><li><span class="math inline"><em>w</em>(<em>t</em>, <em>u</em>) = min<sub><em>v</em> ∈ <em>V</em> − <em>U</em></sub>{<em>w</em>(<em>t</em>, <em>v</em>)}</span></li><li><span class="math inline"><em>T</em> ← <em>T</em> + <em>e</em>(<em>t</em>, <em>u</em>)</span></li><li><span class="math inline"><em>U</em> ← <em>U</em> + <em>u</em></span></li><li>For <span class="math inline"><em>v</em> ∈ <em>V</em> − <em>U</em></span> do<ul><li><span class="math inline"><em>w</em>(<em>t</em>, <em>v</em>) ← min {<em>w</em>(<em>t</em>, <em>v</em>)|<em>t</em> ∈ <em>U</em>}</span></li></ul></li></ol></li></ol></li></ul><figure><img src="image-14.webp" srcset="/img/loading/loading3.gif" lazyload alt="Prim算法"><figcaption aria-hidden="true">Prim算法</figcaption></figure><h1 id="数理逻辑">数理逻辑</h1><h2 id="第一章-命题逻辑的基本概念">第一章 命题逻辑的基本概念</h2><h3 id="命题proposition">命题（Proposition）</h3><ul><li><strong>命题的定义</strong>：命题是一个非真即假的<strong>陈述句</strong>。<ul><li>命题是一个陈述句，命令句、疑问句和感叹句都不是命题</li><li>命题只有两个取值：真或假</li></ul></li><li><strong>真假命题</strong>:凡与事实相符的陈述句为真语句，而与事实不符的陈述句为假语句。<ul><li>通常用大写字母 <span class="math inline"><em>T</em>/1</span>表示真值为真， 用 <span class="math inline"><em>F</em>/0</span>表示真值为假</li><li>因为只有两种取值，所以这样的命题逻辑称为<strong>二值逻辑</strong>。</li></ul></li><li><strong>命题变项</strong>（变元）：用大写字母 <span class="math inline"><em>P</em>, <em>Q</em>, <em>R</em>, ⋯</span>表示命题变项。<ul><li>命题与命题变项含义是不同的，命题指具体的陈述句，是有确定的真值。</li><li>命题变项的真值不定，只当将某个具体命题代入命题变项时，命题变项化为命题，方可确定其真值。</li></ul></li><li><strong>命题的分类</strong><ul><li><strong>简单命题/原子命题</strong>(Primitiveproposition)：不包含任何的与、或、非一类联结词的命题。<ul><li>简单命题不可再分割，如再分割就不是命题了。</li></ul></li><li><strong>复合命题/分子命题</strong>(Compoundproposition)：由一个或几个简单命题用联结词（如与、或、非）联结所构成的新的命题。<ul><li>复合命题自然也是陈述句，其真值依赖于构成该复合命题的各简单命题的真值以及联结词，从而复合命题有确定的真值。</li></ul></li></ul></li></ul><h3 id="命题联结词及真值表">命题联结词及真值表</h3><h4 id="否定词-neg">否定词 <span class="math inline">¬</span></h4><ul><li><p><strong>定义</strong>：否定词（negation）<span class="math inline">¬</span> 是个一元联结词，亦称否定符号。</p><ul><li>一个命题 <span class="math inline"><em>P</em></span>加上否定词就形成了一个新的命题，记作 <span class="math inline">¬<em>P</em></span>，这个新命题是命题的否定，读作非<span class="math inline"><em>P</em></span>。</li></ul></li><li><p><strong>真值规定</strong>：</p><ul><li>若命题 <span class="math inline"><em>P</em></span> 的真值为真，那么<span class="math inline">¬<em>P</em></span> 的真值就为假</li><li>若 <span class="math inline"><em>P</em></span> 的真值为假，那么<span class="math inline">¬<em>P</em></span> 的真值就为真</li></ul></li><li><p><strong>真值表</strong>：</p><table><thead><tr><th><span class="math inline"><em>P</em></span></th><th><span class="math inline">¬<em>P</em></span></th></tr></thead><tbody><tr><td>T</td><td>F</td></tr><tr><td>F</td><td>T</td></tr></tbody></table></li></ul><h4 id="合取词-wedge">合取词 <span class="math inline">∧</span></h4><ul><li><p><strong>定义</strong>：合取词（conjunction）<span class="math inline">∧</span> 是个二元命题联结词，亦称合取符号。</p><ul><li>将两个命题 <span class="math inline"><em>P</em>, <em>Q</em></span>联结起来，构成一个新的命题 <span class="math inline"><em>P</em> ∧ <em>Q</em></span>，读作 <span class="math inline"><em>P</em>, <em>Q</em></span> 的合取，也可读作 <span class="math inline"><em>P</em></span> 与 <span class="math inline"><em>Q</em></span>。</li></ul></li><li><p><strong>真值表</strong>：</p><table><thead><tr><th><span class="math inline"><em>P</em></span></th><th><span class="math inline"><em>Q</em></span></th><th><span class="math inline"><em>P</em> ∧ <em>Q</em></span></th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>F</td></tr></tbody></table></li></ul><h4 id="析取词-vee">析取词 <span class="math inline">∨</span></h4><ul><li><p><strong>定义</strong>：析取词（disjunction）<span class="math inline">∨</span> 是个二元命题联结词，亦称析取符号。</p><ul><li>将两个命题 <span class="math inline"><em>P</em>, <em>Q</em></span>联结起来，构成一个新的命题 <span class="math inline"><em>P</em> ∨ <em>Q</em></span>，读作 <span class="math inline"><em>P</em>, <em>Q</em></span> 的析取，也读作 <span class="math inline"><em>P</em></span> 或 <span class="math inline"><em>Q</em></span>。</li></ul></li><li><p><strong>真值表</strong>：</p><table><thead><tr><th><span class="math inline"><em>P</em></span></th><th><span class="math inline"><em>Q</em></span></th><th><span class="math inline"><em>P</em> ∨ <em>Q</em></span></th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>T</td></tr><tr><td>F</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>F</td></tr></tbody></table></li></ul><h4 id="蕴涵词-rightarrow">蕴涵词 <span class="math inline">→</span></h4><ul><li><p><strong>定义</strong>：蕴涵词（implication）<span class="math inline">→</span> 也是个二元命题联结词，亦称推断符号。</p><ul><li>将两个命题 <span class="math inline"><em>P</em>, <em>Q</em></span>联结起来，构成一个新的命题 <span class="math inline"><em>P</em> → <em>Q</em></span>，读作如果 <span class="math inline"><em>P</em></span> 则 <span class="math inline"><em>Q</em></span>，或读作 <span class="math inline"><em>P</em></span> 蕴涵 <span class="math inline"><em>Q</em></span>。</li><li>如果 <span class="math inline"><em>P</em></span> 那么 <span class="math inline"><em>Q</em></span>，其中 <span class="math inline"><em>P</em></span> 称前件（前项、条件），<span class="math inline"><em>Q</em></span> 称后件（后项、结论）</li></ul></li><li><p><strong>真值规定</strong>：规定只有当 <span class="math inline"><em>P</em></span> 为 <span class="math inline">T</span> 而 <span class="math inline"><em>Q</em></span> 为 <span class="math inline">F</span> 时，<span class="math inline"><em>P</em> → <em>Q</em> = F</span>，而 <span class="math inline"><em>P</em> = F</span>、<span class="math inline"><em>Q</em></span> 任意，或 <span class="math inline"><em>P</em> = T</span>、<span class="math inline"><em>Q</em> = T</span> 时，<span class="math inline"><em>P</em> → <em>Q</em></span> 均取值为 <span class="math inline"><em>T</em></span>。</p></li><li><p><strong>真值表</strong>：</p><table><thead><tr><th><span class="math inline"><em>P</em></span></th><th><span class="math inline"><em>Q</em></span></th><th><span class="math inline"><em>P</em> → <em>Q</em></span></th><th><span class="math inline">¬<em>P</em> ∨ <em>Q</em></span></th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>T</td><td>T</td></tr><tr><td>F</td><td>F</td><td>T</td><td>T</td></tr></tbody></table></li><li><p><strong>等值</strong>：<span class="math inline"><em>P</em> → <em>Q</em> = ¬<em>P</em> ∨ <em>Q</em></span></p></li><li><p>蕴涵词 <span class="math inline">→</span>与自然用语“如果……那么……” 有一致的一面，可表示因果关系。然而 <span class="math inline"><em>P</em>, <em>Q</em></span> 是无关的命题时，逻辑上允许讨论 <span class="math inline"><em>P</em> → <em>Q</em></span>。 并且 <span class="math inline"><em>P</em> = <em>F</em></span> 则 <span class="math inline"><em>P</em> → <em>Q</em> = <em>T</em></span>，这在自然用语中是不大使用的。</p></li><li><p>蕴含式 <span class="math inline"><em>P</em> → <em>Q</em></span>可以用多种方式陈述：</p><ul><li><span class="math inline"><em>P</em></span> 是 <span class="math inline"><em>Q</em></span> 的充分条件</li><li><span class="math inline"><em>Q</em></span> 是 <span class="math inline"><em>P</em></span> 的必要条件</li><li>若 <span class="math inline"><em>P</em></span>，则 <span class="math inline"><em>Q</em></span></li><li>除非 <span class="math inline"><em>Q</em></span>，才 <span class="math inline"><em>P</em></span></li><li>只要 <span class="math inline"><em>P</em></span>，就 <span class="math inline"><em>Q</em></span></li><li>只有 <span class="math inline"><em>Q</em></span>，才 <span class="math inline"><em>P</em></span></li><li><span class="math inline"><em>Q</em></span> 每当 <span class="math inline"><em>P</em></span></li><li><span class="math inline"><em>P</em></span> 仅当 <span class="math inline"><em>Q</em></span></li><li>除非 <span class="math inline"><em>Q</em></span>，否则非 <span class="math inline"><em>P</em></span></li></ul></li><li><p>给定命题 <span class="math inline"><em>P</em> → <em>Q</em></span></p><ul><li><strong>逆命题</strong>：<span class="math inline"><em>Q</em> → <em>P</em></span></li><li><strong>否命题</strong>：<span class="math inline">¬<em>P</em> → ¬<em>Q</em></span></li><li><strong>逆否命题</strong>：<span class="math inline">¬<em>Q</em> → ¬<em>P</em></span></li></ul></li></ul><h4 id="双条件词-leftrightarrow">双条件词 <span class="math inline">↔︎</span></h4><ul><li><p><strong>定义</strong>：双条件词（biconditional）<span class="math inline">↔︎</span> 是个二元命题联结词，亦称等价符号。</p><ul><li>将两个命题 <span class="math inline"><em>P</em>, <em>Q</em></span>联结起来构成新命题 <span class="math inline"><em>P</em> ↔︎ <em>Q</em></span>，读作 <span class="math inline"><em>P</em></span> 当且仅当 <span class="math inline"><em>Q</em></span>，或读作 <span class="math inline"><em>P</em></span> 等价于 <span class="math inline"><em>Q</em></span>。</li></ul></li><li><p><strong>真值表</strong>：</p><table><thead><tr><th><span class="math inline"><em>P</em></span></th><th><span class="math inline"><em>Q</em></span></th><th><span class="math inline"><em>P</em> ↔︎ <em>Q</em></span></th></tr></thead><tbody><tr><td>T</td><td>T</td><td>T</td></tr><tr><td>T</td><td>F</td><td>F</td></tr><tr><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td></tr></tbody></table></li><li><p><strong>等值</strong>： <span class="math display">$$  \begin{aligned}  P \leftrightarrow Q &amp;= (P \wedge Q) \vee (\neg P \wedge \neg Q)\\  &amp;= (P \vee \neg Q) \wedge (\neg P \vee Q)\\  &amp;= (P \rightarrow Q) \wedge (Q \rightarrow P)  \end{aligned}  $$</span></p></li></ul><h4 id="其他条件词">其他条件词</h4><ul><li><strong>异或</strong> <span class="math inline">$\bar{\vee}：P\bar{\vee} Q=(\neg P \wedge Q) \vee(P \wedge \neg Q)$</span></li><li><strong>与非</strong> <span class="math inline"> ↑ ：<em>P</em> ↑ <em>Q</em> = ¬(<em>P</em> ∧ <em>Q</em>)</span></li><li><strong>或非</strong> <span class="math inline"> ↓ ：<em>P</em> ↓ <em>Q</em> = ¬(<em>P</em> ∨ <em>Q</em>)</span></li></ul><h3 id="合式公式">合式公式</h3><ul><li><strong>合式公式（简记为 <span class="math inline">Wff</span>）的定义</strong>：<ol type="1"><li>简单命题(包括简单命题常量与命题变项)是合式公式</li><li>如果 <span class="math inline"><em>A</em></span> 是合式公式，那么<span class="math inline">¬<em>A</em></span> 也是合式公式</li><li>如果 <span class="math inline"><em>A</em>, <em>B</em></span>是合式公式，那么 <span class="math inline">(<em>A</em> ∧ <em>B</em>)</span>，<span class="math inline">(<em>A</em> ∨ <em>B</em>)</span>，<span class="math inline">(<em>A</em> → <em>B</em>)</span> 和 <span class="math inline">(<em>A</em> ↔︎ <em>B</em>)</span> 是合式公式</li><li>当且仅当经过有限次地使用1, 2, 3所组成的符号串才是合式公式</li></ol></li><li>这个定义给出了建立合式公式的一般原则，也给出了识别一个符号串是否是合式公式的原则</li><li>在实际使用中，为了减少圆括号的数量，可以引入一些约定<ul><li>如规定联结词优先级的办法，可按 <span class="math inline">¬</span>，<span class="math inline">∧</span>，<span class="math inline">∨</span>，<span class="math inline">→</span>，<span class="math inline">↔︎</span> 的排列次序安排优先的级别</li><li>多个同一联结词按从左到右的优先次序</li></ul></li></ul><h3 id="重言式可满足式和矛盾式">重言式、可满足式和矛盾式</h3><ul><li><strong>重言式</strong>：如果一个公式，对于它的任一解释 <span class="math inline"><em>I</em></span>下其真值都为真，就称为重言式（永真式）<ul><li>如 <span class="math inline"><em>P</em> ∨ ¬<em>P</em></span>是一个重言式</li><li>显然由 <span class="math inline">∨</span>、<span class="math inline">∧</span>、<span class="math inline">→</span> 和<span class="math inline">↔︎</span> 联结的重言式仍是重言式</li></ul></li><li><strong>可满足式</strong>：一个公式，如有某个解释 <span class="math inline"><em>I</em><sub>0</sub></span>，在 <span class="math inline"><em>I</em><sub>0</sub></span>下该公式真值为真，则称这公式是可满足的<ul><li>如 <span class="math inline"><em>P</em> ∨ <em>Q</em></span>， 当取<span class="math inline"><em>I</em><sub>0</sub> = (<em>T</em>, <em>F</em>)</span>，即 <span class="math inline"><em>P</em> = <em>T</em>, <em>Q</em> = <em>F</em></span>时便有 <span class="math inline"><em>P</em> ∨ <em>Q</em> = <em>T</em></span>，所以是可满足的</li><li>重言式都是可满足的</li></ul></li><li><strong>矛盾式</strong>：如果一个公式，对于它的任一解释 <span class="math inline"><em>I</em></span>下真值都是假，便称是矛盾式，又称永假式、不可满足式<ul><li>如 <span class="math inline"><em>P</em> ∧ ¬<em>P</em></span>是矛盾式</li></ul></li><li>三类公式间的关系<ol type="1"><li>公式 <span class="math inline"><em>A</em></span> 永真，当且仅当<span class="math inline">¬<em>A</em></span> 永假</li><li>公式 <span class="math inline"><em>A</em></span> 可满足，当且仅当<span class="math inline">¬<em>A</em></span> 非永真</li><li>不是可满足的公式必永假</li><li>不是永假的公式必可满足</li></ol></li><li>代入规则<ul><li><span class="math inline"><em>A</em></span> 是一个公式，对 <span class="math inline"><em>A</em></span> 使用代入规则得到公式 <span class="math inline"><em>B</em></span>，若 <span class="math inline"><em>A</em></span> 是重言式，则 <span class="math inline"><em>B</em></span> 也是重言式。</li><li>为保证重言式经代入规则仍得到保持，要求：<ul><li>公式中被代换的<strong>只能是命题变元（原子命题）</strong>，<strong>不能是复合命题</strong></li><li>对公式中某命题变项施以代入，必须对该公式中出现的<strong>所有同一命题</strong>变项代换同一公式</li></ul></li></ul></li></ul><h3 id="命题形式化">命题形式化</h3><ul><li><p>简单自然语句的形式化 **** | 自然语言 | 合式公式 | | — | — | |……是…… | <span class="math inline"><em>P</em></span> | | ……不是…… |<span class="math inline">¬<em>P</em></span> | | 既……又…… | <span class="math inline"><em>P</em> ∧ <em>Q</em></span> | | 如果……，那么…… |<span class="math inline"><em>P</em> → <em>Q</em></span> | | ……，但是……| <span class="math inline"><em>P</em> ∧ <em>Q</em></span> | | ……或…… |<span class="math inline"><em>P</em> ∨ <em>Q</em></span> |</p></li><li><p><strong>较复杂自然语句的形式化</strong></p></li></ul><table><thead><tr><th>自然语言</th><th>合式公式</th></tr></thead><tbody><tr><td>……或……都能……</td><td><span class="math inline"><em>P</em> ∧ <em>Q</em></span></td></tr><tr><td>……或……（两者不能同时发生）</td><td><span class="math inline">$P \overline{\vee } Q$</span></td></tr><tr><td>……，除非……</td><td><span class="math inline">¬<em>P</em> → <em>Q</em></span></td></tr></tbody></table><ul><li><strong>波兰表达式</strong><ul><li>使用联结词构成公式的三种方式：<ul><li><strong>中缀式</strong>：<span class="math inline"><em>P</em> ∨ <em>Q</em></span></li><li><strong>前缀式</strong>：<span class="math inline">∨&nbsp;<em>P</em>&nbsp;<em>Q</em></span>，又称<strong>波兰式</strong></li><li><strong>后缀式</strong>：<span class="math inline"><em>P</em>&nbsp;<em>Q</em>&nbsp;∨</span>，又称<strong>逆波兰式</strong></li></ul></li><li>将中缀式化成波兰式/逆波兰式，可由内层括号逐步向外层脱开（或是按运算优先级顺序逐步写成前缀式）</li></ul></li><li><strong>悖论</strong>：悖论是自相矛盾的命题。<ul><li>即如果承认这个命题成立，就可推出它的否定命题成立</li><li>反之，如果承认这个命题的否定命题成立，又可推出这个命题成立</li></ul></li></ul><h2 id="第二章-命题逻辑的等值和推演运算">第二章命题逻辑的等值和推演运算</h2><h3 id="等值定理">等值定理</h3><ul><li><strong>等值的定义</strong>：给定两个命题公式 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，而 <span class="math inline"><em>P</em><sub>1</sub>, ⋯, <em>P</em><sub><em>n</em></sub></span>是出现于 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 中的所有命题变项，那么公式 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 共有 <span class="math inline">2<sup><em>n</em></sup></span>个解释，若在其中的任一解释下，公式 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 的真值都相等，就称 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>是<strong>等值</strong>的（或称<strong>等价</strong>），记作 <span class="math inline"><em>A</em> = <em>B</em></span> 或 <span class="math inline"><em>A</em> ⇔ <em>B</em></span><ul><li>可以根据真值表来判明任何两个公式是否是等值的</li></ul></li><li><strong>等值定理</strong>：对公式 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，<span class="math inline"><em>A</em> = <em>B</em></span> 的充分必要条件是<span class="math inline"><em>A</em> ↔︎ <em>B</em></span> 是重言式</li><li><strong>等价关系</strong>：<span class="math inline">＝</span>作为逻辑关系符是一种等价关系，<span class="math inline"><em>A</em> = <em>B</em></span> 是表示公式 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 的一种关系。 这种关系具有三个性质:<ol type="1"><li>自反性：<span class="math inline"><em>A</em> = <em>A</em></span></li><li>对称性：若 <span class="math inline"><em>A</em> = <em>B</em></span>，则 <span class="math inline"><em>B</em> = <em>A</em></span></li><li>传递性：若 <span class="math inline"><em>A</em> = <em>B</em></span>，<span class="math inline"><em>B</em> = <em>C</em></span>，则 <span class="math inline"><em>A</em> = <em>C</em></span></li></ol></li></ul><h3 id="等值公式">等值公式</h3><h4 id="基本等值公式命题定律">基本等值公式（命题定律）</h4><ul><li>双重否定律 <span class="math display">¬¬<em>P</em> = <em>P</em></span></li><li>结合律 <span class="math display">$$ \begin{aligned}  (P \vee Q) \vee R &amp;= P \vee(Q \vee R)\\\ (P \wedge Q) \wedge R&amp;= P \wedge(Q \wedge R)\\  (P \leftrightarrow Q) \leftrightarrow R &amp;= P \leftrightarrow(Q\leftrightarrow R)  \end{aligned} $$</span></li><li>交换律 <span class="math display">$$ \begin{aligned}  P \vee Q &amp;= Q \vee P \\  P \wedge Q &amp;= Q \wedge P \\  P \leftrightarrow Q &amp;= Q \leftrightarrow P  \end{aligned}$$</span></li><li>分配律 <span class="math display">$$ \begin{aligned}  P \vee(Q \wedge R) &amp;= (P \vee Q) \wedge(P \vee R) \\  P \wedge(Q \vee R) &amp;= (P \wedge Q) \vee(P \wedge R) \\  P \rightarrow(Q \rightarrow R) &amp;= (P \rightarrow Q) \rightarrow(P\rightarrow R) \\  P \leftrightarrow(Q \leftrightarrow R) &amp;\neq(P \leftrightarrow Q)\leftrightarrow(P \leftrightarrow R)  \end{aligned}$$</span></li><li>等幂律（恒等律） <span class="math display">$$ \begin{aligned}  P \vee P &amp;= P \\  P \wedge P &amp;= P \\  P \rightarrow P &amp;= T \\  P \leftrightarrow P &amp;= T  \end{aligned}$$</span></li><li>吸收律 <span class="math display">$$ \begin{aligned}  P \vee(P \wedge Q) &amp;= P \\  P \wedge(P \vee Q) &amp;= P  \end{aligned}$$</span></li><li>摩根律 <span class="math display">$$ \begin{aligned}  \neg(P \vee Q) &amp;= \neg P \wedge \neg Q \\  \neg(P \wedge Q) &amp;= \neg P \vee \neg Q  \end{aligned}$$</span> 对蕴涵词；双条件词作否定有 <span class="math display">$$ \begin{aligned}  \neg(P \rightarrow Q) &amp;= P \wedge \neg Q \\  \neg(P \leftrightarrow Q) &amp;= \neg P \leftrightarrow Q\\  &amp;= P \leftrightarrow \neg Q\\  &amp;= (\neg P \wedge Q) \vee(P \wedge \neg Q)  \end{aligned}$$</span></li><li>同一律 <span class="math display">$$ \begin{aligned}  P \vee F &amp;= P \\  P \wedge T &amp;= P \\  T \rightarrow P &amp;= P \\  T \leftrightarrow P &amp;= P\\  P \rightarrow F &amp;= \neg P \\  F \leftrightarrow P &amp;= \neg P  \end{aligned}$$</span></li><li>零律 <span class="math display">$$ \begin{aligned}  P \vee T &amp;= T \\  P \wedge F &amp;= F\\  P \rightarrow T &amp;= T \\  F \rightarrow P &amp;= T  \end{aligned}$$</span></li><li>补余律 <span class="math display">$$ \begin{aligned}  P \vee \neg P &amp;= T \\  P \wedge \neg P &amp;= F\\  P \rightarrow \neg P &amp;= \neg P \\  \neg P \rightarrow P &amp;= P \\  P \leftrightarrow \neg P &amp;= F  \end{aligned}$$</span></li></ul><h4 id="venn图">Venn图</h4><ul><li>将 <span class="math inline"><em>P</em>, <em>Q</em></span>理解为某总体论域上的子集合，并规定：<ul><li><span class="math inline"><em>P</em> ∧ <em>Q</em></span>为两集合的公共部分(交集合)</li><li><span class="math inline"><em>P</em> ∨ <em>Q</em></span>为两集合的全部(并集合)</li><li><span class="math inline">¬<em>P</em></span> 为总体论域(如矩形域)中<span class="math inline"><em>P</em></span> 的余集</li></ul></li></ul><figure><img src="image-15.webp" srcset="/img/loading/loading3.gif" lazyload alt="Venn图"><figcaption aria-hidden="true">Venn图</figcaption></figure><h4 id="常用等值公式">常用等值公式</h4><ul><li><span class="math inline"><em>P</em> → <em>Q</em> = ¬<em>P</em> ∨ <em>Q</em></span></li><li><span class="math inline"><em>P</em> → <em>Q</em> = ¬<em>Q</em> → ¬<em>P</em></span></li><li><span class="math inline"><em>P</em> → (<em>Q</em> → <em>R</em>) = (<em>P</em> ∧ <em>Q</em>) → <em>R</em></span></li><li><span class="math inline"><em>P</em> ↔︎ <em>Q</em> = (<em>P</em> ∧ <em>Q</em>) ∨ (¬<em>P</em> ∧ ¬<em>Q</em>)</span></li><li><span class="math inline"><em>P</em> ↔︎ <em>Q</em> = (<em>P</em> ∨ ¬<em>Q</em>) ∧ (¬<em>P</em> ∨ <em>Q</em>)</span></li><li><span class="math inline"><em>P</em> ↔︎ <em>Q</em> = (<em>P</em> → <em>Q</em>) ∧ (<em>Q</em> → <em>P</em>)</span></li><li><span class="math inline"><em>P</em> → (<em>Q</em> → <em>R</em>) = <em>Q</em> → (<em>P</em> → <em>R</em>)</span></li><li><span class="math inline">(<em>P</em> → <em>R</em>) ∧ (<em>Q</em> → <em>R</em>) = (<em>P</em> ∨ <em>Q</em>) → <em>R</em></span></li><li><span class="math inline"><em>P</em> ↔︎ <em>Q</em> = ¬<em>P</em> ↔︎ ¬<em>Q</em></span></li><li>归谬论：<span class="math inline">(<em>P</em> → <em>Q</em>) ∧ (<em>P</em> → ¬<em>Q</em>) = ¬<em>P</em></span></li></ul><h4 id="置换规则">置换规则</h4><ul><li><strong>置换的定义</strong>；对公式 <span class="math inline"><em>A</em></span>的子公式，用与之<strong>等值</strong>的公式代换称为<strong>置换</strong></li><li><strong>置换规则</strong><ul><li>公式置换后，<span class="math inline"><em>A</em></span> 化为公式<span class="math inline"><em>B</em></span>，必有 <span class="math inline"><em>A</em> = <em>B</em></span></li><li>当 <span class="math inline"><em>A</em></span>是重言式时，置换后的公式 <span class="math inline"><em>B</em></span>必也是重言式。</li></ul></li><li>置换与代入的区别：<ul><li>置换只要求 <span class="math inline"><em>A</em></span>的某一子公式作代换，置换规则被替换的不一定是简单命题</li><li>等值必须对所有同一的子公式都作代换，代入规则被替换的只能是简单命题</li></ul></li></ul><h3 id="命题公式与真值表关系">命题公式与真值表关系</h3><h4 id="t列写">T列写</h4><ul><li><strong>T列写</strong>：各项间用 <span class="math inline">∨</span>，每项内用 <span class="math inline">∧</span> <span class="math display"><em>A</em> = (⋯)<sub>1</sub> ∨ (⋯)<sub>2</sub> ∨ (⋯)<sub>3</sub></span></li><li>每项内书写方法：<ul><li>例：真值表中 <span class="math inline"><em>P</em> = <em>T</em></span> 且 <span class="math inline"><em>Q</em> = <em>F</em></span> 等价于 <span class="math inline"><em>P</em> ∧ ¬<em>Q</em> = <em>T</em></span></li></ul></li><li>简化方法： 有时 <span class="math inline"><em>A</em></span>的表达通过 <span class="math inline">¬<em>A</em></span> 来描述</li></ul><h4 id="f列写">F列写</h4><ul><li><strong>F列写</strong>：各项间用 <span class="math inline">∧</span>，每项内用 <span class="math inline">∨</span> <span class="math display"><em>A</em> = (⋯)<sub>1</sub> ∧ (⋯)<sub>2</sub> ∧ (⋯)<sub>3</sub></span></li><li>每项内书写方法：<ul><li>例：真值表中 <span class="math inline"><em>P</em> = <em>T</em></span> 且 <span class="math inline"><em>Q</em> = <em>F</em></span> 等价于 <span class="math inline">¬<em>P</em> ∨ <em>Q</em> = <em>F</em></span></li></ul></li><li>简化方法： 有时 <span class="math inline"><em>A</em></span>的表达通过 <span class="math inline">¬<em>A</em></span> 来描述</li></ul><figure><img src="image-16.webp" srcset="/img/loading/loading3.gif" lazyload alt="从真值表写命题公式"><figcaption aria-hidden="true">从真值表写命题公式</figcaption></figure><h3 id="联结词的完备集">联结词的完备集</h3><h4 id="命题联结词的个数">命题联结词的个数</h4><ul><li><p>按照合式公式的定义，由命题变项和命题联结词可以构造出无限多个合式公式.可把所有的合式公式加以分类，将等值的公式视为同一类，从中选一个作代表称之为<strong>真值函项</strong>。对一个真值函项就有一个联结词与之对应。</p></li><li><p><strong>一元联结词</strong>是联结一个命题变项的，如 <span class="math inline"><em>P</em></span>。它取值只有真假 <span class="math inline">2</span> 种情形，于是联结词作用于 <span class="math inline"><em>P</em></span>，可建立 <span class="math inline">2<sup>2</sup> = 4</span>种不同的真值函项，相应的可定义出四个不同的一元联结词 <span class="math inline"><em>f</em><sub>0</sub>, <em>f</em><sub>1</sub>, <em>f</em><sub>2</sub>, <em>f</em><sub>3</sub></span></p><table><thead><tr><th><span class="math inline"><em>P</em></span></th><th><span class="math inline"><em>f</em><sub>0</sub>(<em>P</em>)</span></th><th><span class="math inline"><em>f</em><sub>1</sub>(<em>P</em>)</span></th><th><span class="math inline"><em>f</em><sub>2</sub>(<em>P</em>)</span></th><th><span class="math inline"><em>f</em><sub>3</sub>(<em>P</em>)</span></th></tr></thead><tbody><tr><td>T</td><td>T</td><td>F</td><td>T</td><td>F</td></tr><tr><td>F</td><td>F</td><td>T</td><td>F</td><td>T</td></tr></tbody></table><ul><li><span class="math inline"><em>f</em><sub>0</sub>(<em>P</em>) = <em>F</em></span>(永假式)</li><li><span class="math inline"><em>f</em><sub>1</sub>(<em>P</em>) = <em>P</em></span>(P自身)</li><li><span class="math inline"><em>f</em><sub>2</sub>(<em>P</em>) = ¬<em>P</em></span>(否定词)</li><li><span class="math inline"><em>f</em><sub>3</sub>(<em>P</em>) = <em>T</em></span>(永真式)</li></ul></li><li><p><strong>二元联结词</strong>是联结两个命题变项的，如 <span class="math inline"><em>P</em></span> 和 <span class="math inline"><em>Q</em></span>。它取值有真假 <span class="math inline">4</span> 种情形，于是联结词作用于 <span class="math inline"><em>P</em></span> 和 <span class="math inline"><em>Q</em></span>，可建立 <span class="math inline">2<sup>4</sup> = 16</span>种不同的真值函项，相应的可定义出 <span class="math inline">16</span>个不同的二元联结词 <span class="math inline"><em>f</em><sub>00</sub>, <em>f</em><sub>01</sub>, …, <em>f</em><sub>15</sub></span></p></li></ul><figure><img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload alt="二元联结词"><figcaption aria-hidden="true">二元联结词</figcaption></figure><ul><li><strong>对于 <span class="math inline"><em>n</em></span>个命题变元，有 <span class="math inline">2<sup>2<sup><em>n</em></sup></sup></span>个不同的个真值函项</strong></li></ul><h4 id="联结词的完备集-1">联结词的完备集</h4><ul><li><strong>定义</strong>：如果对任一命题公式都有由 <span class="math inline">C</span> 中的联结词表示出来的公式与之等值，就说<span class="math inline">C</span> 是完备的联结词集合，或说 <span class="math inline">C</span> 是联结词的<strong>完备集</strong></li><li><strong>完备集</strong><ul><li>显然全体联结词的无限集合是完备的</li><li><span class="math inline">{¬,∨, ∧}</span> （不独立）</li><li><span class="math inline">{¬,∨}</span> （独立）</li><li><span class="math inline">{¬,∧}</span> （独立）</li><li><span class="math inline">{¬, → }</span> （独立）</li><li><span class="math inline">{ ↑ }</span> （独立）</li><li><span class="math inline">{ ↓ }</span> （独立）</li></ul></li><li><strong>不完备</strong><ul><li><span class="math inline">{¬}</span></li><li><span class="math inline">{∨, ∧}</span></li><li><span class="math inline">{∨, ∧, →, ↔︎ }</span>的任何子集都是不完备的</li><li><span class="math inline">{¬, ↔︎ }</span> 的任何子集也是不完备的</li><li>如果一个联结词的集合是不完备的，那么它的任何子集都是不完备的</li></ul></li><li><strong>最小的联结词的完备集——基底</strong>：完备的联结词集合的联结词是独立的，也就是说这些联结词不能相互表示。<ul><li>只含一个联结词的:<ul><li>NK；NA</li></ul></li><li>含两个联结词的:<ul><li>N,C；N,K；N,A；N,NC；F,C；T,NC；C,NE；E,NC；C,NC</li></ul></li><li>含三个联结词的:<ul><li>F,K,E；F,A,E；T,K,NE；T,A,NE；K,E,NE；A,E,NE</li></ul></li><li>其中：<ul><li>A=<span class="math inline">∨</span></li><li>K=<span class="math inline">∧</span></li><li>E=<span class="math inline">↔︎</span></li><li>C=<span class="math inline">→</span></li><li>N=<span class="math inline">¬</span></li></ul></li></ul></li></ul><h3 id="对偶式">对偶式</h3><ul><li><strong>对偶式</strong>：将 <span class="math inline"><em>A</em></span> 中出现的 <span class="math inline">∨, ∧, <em>T</em>, <em>F</em></span> 分别以 <span class="math inline">∧, ∨, <em>F</em>, <em>T</em></span> 代换，得到公式<span class="math inline"><em>A</em><sup>⋆</sup></span>，则称 <span class="math inline"><em>A</em><sup>⋆</sup></span> 是 <span class="math inline"><em>A</em></span> 的对偶式，或说 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>A</em><sup>⋆</sup></span> 互为对偶式</li><li><strong>内否式</strong>：若 <span class="math inline"><em>A</em> = <em>A</em>(<em>P</em><sub>1</sub>, ⋯, <em>P</em><sub><em>n</em></sub>)</span>，令<span class="math inline"><em>A</em></span> 的内否式 <span class="math inline"><em>A</em><sup>−</sup> = <em>A</em>(¬<em>P</em><sub>1</sub>, ⋯, ¬<em>P</em><sub><em>n</em></sub>)</span></li><li><strong>定理</strong>：<ul><li><span class="math inline">¬(<em>A</em><sup>⋆</sup>) = (¬<em>A</em>)<sup>⋆</sup></span>，<span class="math inline">¬(<em>A</em><sup>−</sup>) = (¬<em>A</em>)<sup>−</sup></span></li><li><span class="math inline">(<em>A</em><sup>⋆</sup>)<sup>⋆</sup> = <em>A</em></span>，<span class="math inline">(<em>A</em><sup>−</sup>)<sup>−</sup> = <em>A</em></span></li><li><span class="math inline">¬<em>A</em> = <em>A</em><sup>⋆−</sup> = <em>A</em><sup>−⋆</sup></span></li><li>其他：<ul><li><span class="math inline">(<em>A</em> ∨ <em>B</em>)<sup>⋆</sup> = <em>A</em><sup>⋆</sup> ∧ <em>B</em><sup>⋆</sup></span></li><li><span class="math inline">(<em>A</em> ∧ <em>B</em>)<sup>⋆</sup> = <em>A</em><sup>⋆</sup> ∨ <em>B</em><sup>⋆</sup></span></li><li><span class="math inline">(<em>A</em> ∨ <em>B</em>)<sup>−</sup> = <em>A</em><sup>−</sup> ∨ <em>B</em><sup>−</sup></span></li><li><span class="math inline">(<em>A</em> ∧ <em>B</em>)<sup>−</sup> = <em>A</em><sup>−</sup> ∧ <em>B</em><sup>−</sup></span></li></ul></li><li>若 <span class="math inline"><em>A</em> = <em>B</em></span>，必有<span class="math inline"><em>A</em><sup>⋆</sup> = <em>B</em><sup>⋆</sup></span></li><li>若 <span class="math inline"><em>A</em> → <em>B</em></span>永真，必有 <span class="math inline"><em>B</em><sup>⋆</sup> → <em>A</em><sup>⋆</sup></span>永真</li><li><span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>A</em><sup>−</sup></span>同永真，同可满足；<span class="math inline">¬<em>A</em></span> 与 <span class="math inline"><em>A</em><sup>⋆</sup></span> 同永真，同可满足</li></ul></li></ul><h3 id="范式">范式</h3><h4 id="范式-1">范式</h4><ul><li>相关概念：<ul><li><strong>范式</strong>：一种命题公式的统一标准形式</li><li><strong>文字</strong>：简单命题 <span class="math inline"><em>P</em></span> 及其否定式 <span class="math inline">¬<em>P</em></span> 统称为文字</li><li><strong>合取式</strong>：有限个文字的合取称为合取式（也称<strong>短语</strong>）</li><li><strong>析取式</strong>：有限个文字的析取称为析取式（也称<strong>子句</strong>）</li><li><strong>互补对</strong>：<span class="math inline"><em>P</em></span>与 <span class="math inline">¬<em>P</em></span> 称为互补对</li><li><strong>析取范式</strong>：有限个合取式的析取式，形如 <span class="math inline"><em>A</em><sub>1</sub> ∨ <em>A</em><sub>2</sub> ∨ ⋯ ∨ <em>A</em><sub><em>n</em></sub></span>，其中<span class="math inline"><em>A</em><sub><em>i</em></sub>(<em>i</em> = 1, ⋯, <em>n</em>)</span>为合取式</li><li><strong>合取范式</strong>：有限个析取式的合取式，形如 <span class="math inline"><em>A</em><sub>1</sub> ∧ <em>A</em><sub>2</sub> ∧ ⋯ ∧ <em>A</em><sub><em>n</em></sub></span>，其中<span class="math inline"><em>A</em><sub><em>i</em></sub>(<em>i</em> = 1, ⋯, <em>n</em>)</span>为析取式</li></ul></li><li><strong>范式定理</strong>：任一命题公式都存在与之等值的合取范式和析取范式</li><li><strong>求范式的步骤</strong>：<ol type="1"><li>消去已给公式中的联结词 <span class="math inline">→</span> 和 <span class="math inline">↔︎</span>。这可利用如下等值式： <span class="math display">$$ \begin{array}{c}A \rightarrow B=\neg A \vee B \\A \leftrightarrow B=(\neg A \vee B) \wedge(A \vee \neg B) \\=(A \wedge B) \vee(\neg A \wedge \neg B)\end{array} $$</span></li><li>重复使用摩根律和双重否定律，把否定词内移到直接作用于命题变项上。这可利用等值式：<span class="math display">$$ \begin{array}{c}\neg(A \wedge B)=\neg A \vee \neg B \\\neg(A \vee B)=\neg A \wedge \neg B \\\neg \neg A=A\end{array}$$</span>将所有的否定词，都内移到命题变项前，这也是范式的要求</li><li>重复使用分配律的等值变换。这可利用等值式： <span class="math display">$$ \begin{array}{l} A \wedge(B \vee C)=(A \wedge B)\vee(A \wedge C) \\A \vee(B \wedge C)=(A \vee B) \wedge(A \vee C)\end{array}$$</span>将公式化成一些合取式的析取，或化成一些析取式的合取，都必须使用分配律来实现</li></ol></li><li><strong>范式功能</strong><ul><li>判断重言式：合取范式中所有析取式都有互补对</li><li>判断矛盾式：析取范式中所有合取式都有互补对</li><li>判断公式等值：范式不唯一，引入唯一主范式，便于判断公式等值</li></ul></li></ul><h4 id="主析取范式">主析取范式</h4><ul><li><strong>极小项定义与编码</strong>：<span class="math inline"><em>Q</em><sub>1</sub> ∧ ⋯ ∧ <em>Q</em><sub><em>n</em></sub></span>是由 <span class="math inline"><em>n</em></span> 个命题变项 <span class="math inline"><em>P</em><sub>1</sub>, ⋯, <em>P</em><sub><em>n</em></sub></span>组成的公式，其中 <span class="math inline"><em>Q</em><sub><em>i</em></sub> = <em>P</em><sub><em>i</em></sub></span>或 <span class="math inline">¬<em>P</em><sub><em>i</em></sub></span>，我们称其为极小项，一般用<span class="math inline"><em>m</em><sub><em>j</em></sub></span> 表示<span class="math inline">(0 ≤ <em>j</em> ≤ 2<sup><em>n</em></sup> − 1)</span><ul><li>例： <span class="math inline"><em>P</em><sub>1</sub>, <em>P</em><sub>2</sub></span>的极小项有四个<ul><li><span class="math inline">¬<em>P</em><sub>1</sub> ∧ ¬<em>P</em><sub>2</sub>(<em>m</em><sub>0</sub>)</span></li><li><span class="math inline">¬<em>P</em><sub>1</sub> ∧ <em>P</em><sub>2</sub>(<em>m</em><sub>1</sub>)</span></li><li><span class="math inline"><em>P</em><sub>1</sub> ∧ ¬<em>P</em><sub>2</sub>(<em>m</em><sub>2</sub>)</span></li><li><span class="math inline"><em>P</em><sub>1</sub> ∧ <em>P</em><sub>2</sub>(<em>m</em><sub>3</sub>)</span></li></ul></li><li>极小项必须含有 <span class="math inline"><em>Q</em><sub>1</sub>, ⋯, <em>Q</em><sub><em>n</em></sub></span>全部 <span class="math inline"><em>n</em></span> 个文字</li></ul></li><li><strong>主析取范式定义</strong>：仅由极小项构成的析取式</li><li><strong>主析取范式唯一性定理</strong>：任一含有 <span class="math inline"><em>n</em></span> 个命题变项的公式，都有唯一一个与之等值的恰仅含这 <span class="math inline"><em>n</em></span> 个命题变项的主析取范式</li><li><strong>提取主析取范式</strong>：<ul><li>由真值表写主析取范式：从T写</li><li>由析取范式写主析取范式：填满命题变项法, 永真式</li></ul></li><li><strong>极小项性质</strong>：<ul><li>所有可能的极小项个数：<span class="math inline">2<sup><em>n</em></sup></span></li><li>每个极小项只在一个解释下为真，对于每个解释只有一个极小项为真</li><li>极小项两两不等值，而且 <span class="math inline"><em>m</em><sub><em>i</em></sub> ∧ <em>m</em><sub><em>j</em></sub> = F(<em>i</em> ≠ <em>j</em>)</span></li><li>任一含有 <span class="math inline"><em>n</em></span>个变项的公式，都可由 <span class="math inline"><em>k</em></span> 个<span class="math inline">(<em>k</em> ≤ 2<sup><em>n</em></sup>)</span>极小项的析取来表示，或说所有的极小项可建立一个“坐标系”</li><li>恰由 <span class="math inline">2<sup><em>n</em></sup></span>个极小项的析取构成的公式，必为重言式<span class="math display">∨<sub><em>i</em> = 0</sub><sup>2<sup><em>n</em></sup> − 1</sup><em>m</em><sub><em>i</em></sub> = T</span></li><li>若 <span class="math inline"><em>A</em></span> 由 <span class="math inline"><em>k</em></span> 个极小项的析取组成，那么其余的<span class="math inline">2<sup><em>n</em></sup> − <em>k</em></span>个极小项的析取必是公式 <span class="math inline">¬<em>A</em></span></li></ul></li></ul><h4 id="主合取范式">主合取范式</h4><ul><li><strong>极大项定义与编码</strong>：<span class="math inline"><em>Q</em><sub>1</sub> ∨ ⋯ ∨ <em>Q</em><sub><em>n</em></sub></span>是由 <span class="math inline"><em>n</em></span> 个命题变项 <span class="math inline"><em>P</em><sub>1</sub>, ⋯, <em>P</em><sub><em>n</em></sub></span>组成的公式，其中 <span class="math inline"><em>Q</em><sub><em>i</em></sub> = <em>P</em><sub><em>i</em></sub></span>或 <span class="math inline">¬<em>P</em><sub><em>i</em></sub></span>，我们称其为极大项，一般用<span class="math inline"><em>M</em><sub><em>j</em></sub></span> 表示<span class="math inline">(0 ≤ <em>j</em> ≤ 2<sup><em>n</em></sup> − 1)</span><ul><li>例： <span class="math inline"><em>P</em><sub>1</sub>, <em>P</em><sub>2</sub></span>的极大项有四个<ul><li><span class="math inline">¬<em>P</em><sub>1</sub> ∨ ¬<em>P</em><sub>2</sub>(<em>M</em><sub>0</sub>)</span></li><li><span class="math inline">¬<em>P</em><sub>1</sub> ∨ <em>P</em><sub>2</sub>(<em>M</em><sub>1</sub>)</span></li><li><span class="math inline"><em>P</em><sub>1</sub> ∨ ¬<em>P</em><sub>2</sub>(<em>M</em><sub>2</sub>)</span></li><li><span class="math inline"><em>P</em><sub>1</sub> ∨ <em>P</em><sub>2</sub>(<em>M</em><sub>3</sub>)</span></li></ul></li><li>极大项必须含有 <span class="math inline"><em>Q</em><sub>1</sub>, ⋯, <em>Q</em><sub><em>n</em></sub></span>全部 <span class="math inline"><em>n</em></span> 个文字</li></ul></li><li><strong>主合取范式定义</strong>：仅由极大项构成的合取式</li><li><strong>主合取范式唯一性定理</strong>：任一含有 <span class="math inline"><em>n</em></span> 个命题变项的公式，都有唯一一个与之等值的恰仅含这 <span class="math inline"><em>n</em></span> 个命题变项的主合取范式</li><li><strong>提取主合取范式</strong>：<ul><li>由真值表写主合取范式：从F写</li><li>由合取范式写主合取范式：填满命题变项法, 永假式</li></ul></li><li><strong>极大项性质</strong>：<ul><li>所有可能的极大项个数：<span class="math inline">2<sup><em>n</em></sup></span></li><li>每个极大项只在一个解释下为假，对于每个解释只有一个极大项为假</li><li>极大项两两不等值，而且 <span class="math inline"><em>M</em><sub><em>i</em></sub> ∨ <em>M</em><sub><em>j</em></sub> = <em>T</em>(<em>i</em> ≠ <em>j</em>)</span></li><li>任一含有 <span class="math inline"><em>n</em></span>个变项的公式，都可由 <span class="math inline"><em>k</em></span> 个<span class="math inline">(<em>k</em> ≤ 2<sup><em>n</em></sup>)</span>极大项的合取来表示，或说所有的极大项可建立一个“坐标系”</li><li>恰由 <span class="math inline">2<sup><em>n</em></sup></span>个极大项的合取构成的公式，必为矛盾式<span class="math display">∧<sub><em>i</em> = 0</sub><sup>2<sup><em>n</em></sup> − 1</sup><em>M</em><sub><em>i</em></sub> = F</span></li><li>若 <span class="math inline"><em>A</em></span> 由 <span class="math inline"><em>k</em></span> 个极大项的合取组成，那么其余的<span class="math inline">2<sup><em>n</em></sup> − <em>k</em></span>个极大项的合取必是公式 <span class="math inline">¬<em>A</em></span></li></ul></li></ul><h4 id="主析取范式与主合取范式的转换">主析取范式与主合取范式的转换</h4><ul><li><span class="math inline">¬<em>P</em></span> 看成 <span class="math inline">0</span>，<span class="math inline"><em>P</em></span> 看成 <span class="math inline">1</span>，按变项的字典序连起来形成一个二进制数 <span class="math inline"><em>x</em></span><ul><li>极小项简记为 <span class="math inline"><em>m</em></span>，主析取范式可记为 <span class="math inline">∨<sub><em>m</em><sub>1</sub>; <em>m</em><sub>2</sub>; ⋯</sub></span></li><li>极大项简记为 <span class="math inline"><em>M</em></span>，主合取范式可记为 <span class="math inline">∧<sub><em>M</em><sub>1</sub>; <em>M</em><sub>2</sub>; ⋯</sub></span></li></ul></li></ul><figure><img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload alt="主析取范式和主合取范式的转换"><figcaption aria-hidden="true">主析取范式和主合取范式的转换</figcaption></figure><ul><li>注意：<ul><li>从真值表列写公式的主析取范式和主合取范式时，除了分别从T和F列写外，在填写合取式和析取式时是取变项还是其否定是有区别的，这就是主合取范式、主析取范式转换过程要求补的原因</li><li>数字补不同于补集。这里的数字求补是对 <span class="math inline">2<sup><em>n</em></sup> − 1 = 2<sup>3</sup> − 1 = 7</span>而言的，如 <span class="math inline">2</span> 的补是 <span class="math inline">5</span>，因为 <span class="math inline">2 + 5 = 7</span></li></ul></li></ul><h3 id="推理形式">推理形式</h3><ul><li><strong>重言蕴含</strong>：如果给定两个公式 <span class="math inline"><em>A</em>, <em>B</em></span>，只要 <span class="math inline"><em>A</em></span> 取值为真，<span class="math inline"><em>B</em></span> 就必取值为真，便称 <span class="math inline"><em>A</em></span> <strong>重言（永真）蕴涵</strong><span class="math inline"><em>B</em></span>，或称 <span class="math inline"><em>B</em></span> 是 <span class="math inline"><em>A</em></span> 的<strong>逻辑推论</strong>，记为$ A B$<ul><li>符号“<span class="math inline">⇒</span>”表示两个公式间的一种真值关系，它不是逻辑联结词，<span class="math inline"><em>A</em> ⇒ <em>B</em></span> 也不是合式公式</li><li>对以 <span class="math inline"><em>A</em> → <em>B</em></span>表示的推理形式来说，推理形式是正确的，就同 <span class="math inline"><em>A</em></span> 重言蕴涵 <span class="math inline"><em>B</em></span>是同一概念了，于是正确的推理形式便可以 <span class="math inline"><em>A</em> ⇒ <em>B</em></span> 表示了</li></ul></li><li><strong>性质</strong>：<ul><li>如果 <span class="math inline"><em>A</em> ⇒ <em>B</em></span>，<span class="math inline"><em>A</em></span> 为重言式，则 <span class="math inline"><em>B</em></span> 也是重言式</li><li>如果 <span class="math inline"><em>A</em> ⇒ <em>B</em></span>，<span class="math inline"><em>B</em> ⇒ <em>A</em></span> 同时成立，必有 <span class="math inline"><em>A</em> = <em>B</em></span></li><li>反过来，<span class="math inline"><em>A</em> = <em>B</em></span>也必有 <span class="math inline"><em>A</em> ⇒ <em>B</em></span> 和 <span class="math inline"><em>B</em> ⇒ <em>A</em></span></li><li>如果 <span class="math inline"><em>A</em> ⇒ <em>B</em></span>，<span class="math inline"><em>B</em> ⇒ <em>C</em></span>，则 <span class="math inline"><em>A</em> ⇒ <em>C</em></span></li><li>如果 <span class="math inline"><em>A</em> ⇒ <em>B</em></span>，<span class="math inline"><em>A</em> ⇒ <em>C</em></span>，则 <span class="math inline"><em>A</em> ⇒ <em>B</em> ∧ <em>C</em></span></li><li>如果 <span class="math inline"><em>A</em> ⇒ <em>C</em></span>，<span class="math inline"><em>B</em> ⇒ <em>C</em></span>，则 <span class="math inline"><em>A</em> ∨ <em>B</em> ⇒ <em>C</em></span></li></ul></li></ul><h3 id="基本推理公式">基本推理公式</h3><ol type="1"><li>化简律：<span class="math inline"><em>P</em> ∧ <em>Q</em> ⇒ <em>P</em></span></li><li><span class="math inline">¬(<em>P</em> → <em>Q</em>) ⇒ <em>P</em></span></li><li><span class="math inline">¬(<em>P</em> → <em>Q</em>) ⇒ ¬<em>Q</em></span></li><li>附加律：<span class="math inline"><em>P</em> ⇒ <em>P</em> ∨ <em>Q</em></span></li><li><span class="math inline">¬<em>P</em> ⇒ <em>P</em> → <em>Q</em></span></li><li><span class="math inline"><em>Q</em> ⇒ <em>P</em> → <em>Q</em></span></li><li>析取三段论：<span class="math inline">(<em>P</em> ∨ <em>Q</em>) ∧ ¬<em>P</em> ⇒ <em>Q</em></span></li><li>假言推理/分离规则：<span class="math inline">(<em>P</em> → <em>Q</em>) ∧ <em>P</em> ⇒ <em>Q</em></span></li><li>拒取式：<span class="math inline">(<em>P</em> → <em>Q</em>) ∧ ¬<em>Q</em> ⇒ ¬<em>P</em></span></li><li>假言三段论/三段论：<span class="math inline">(<em>P</em> → <em>Q</em>) ∧ (<em>Q</em> → <em>R</em>) ⇒ <em>P</em> → <em>R</em></span></li><li>等价三段论：<span class="math inline">(<em>P</em> ↔︎ <em>Q</em>) ∧ (<em>Q</em> ↔︎ <em>R</em>) ⇒ <em>P</em> ↔︎ <em>R</em></span></li><li>构造性二难（特殊形式）：<span class="math inline">(<em>P</em> → <em>R</em>) ∧ (<em>Q</em> → <em>R</em>) ∧ (<em>P</em> ∨ <em>Q</em>) ⇒ <em>R</em></span></li><li>构造性二难：<span class="math inline">(<em>P</em> → <em>Q</em>) ∧ (<em>R</em> → <em>S</em>) ∧ (<em>P</em> ∨ <em>R</em>) ⇒ <em>Q</em> ∨ <em>S</em></span></li><li>破坏性二难：<span class="math inline">(<em>P</em> → <em>Q</em>) ∧ (<em>R</em> → <em>S</em>) ∧ (¬<em>Q</em> ∨ ¬<em>S</em>) ⇒ ¬<em>P</em> ∨ ¬<em>R</em></span></li><li><span class="math inline">(<em>Q</em> → <em>R</em>) ⇒ ((<em>P</em> ∨ <em>Q</em>) → (<em>P</em> ∨ <em>R</em>))</span></li><li><span class="math inline">(<em>Q</em> → <em>R</em>) ⇒ ((<em>P</em> → <em>Q</em>) → (<em>P</em> → <em>R</em>))</span></li></ol><h4 id="证明推理公式的方法">证明推理公式的方法</h4><ul><li><span class="math inline"><em>A</em> ⇒ <em>B</em></span>成立的充分必要条件是 <span class="math inline"><em>A</em> → <em>B</em></span> （或 <span class="math inline">¬<em>A</em> ∨ <em>B</em></span>）为重言式</li><li><span class="math inline"><em>A</em> ⇒ <em>B</em></span>成立的充分必要条件是 <span class="math inline"><em>A</em> ∧ ¬<em>B</em></span> 是矛盾式</li><li>还可以用：逆否命题法、解释法、真值表法、等值演算、范式</li></ul><h3 id="推理演算">推理演算</h3><ul><li><strong>基本思想</strong>：从前提 <span class="math inline"><em>A</em><sub>1</sub>, ⋯, <em>A</em><sub><em>n</em></sub></span>出发(即 <span class="math inline"><em>A</em> = <em>A</em><sub>1</sub> ∧ <em>A</em><sub>2</sub> ∧ ⋯ ∧ <em>A</em><sub><em>n</em></sub></span>)运用推理规则和基本推理公式，逐步推演出结论<span class="math inline"><em>B</em></span>， 即证明 <span class="math inline"><em>A</em> ⇒ <em>B</em></span></li><li><strong>推理规则</strong><ul><li><strong>前提引入规则</strong>：在推理过程中，可以随时引入前提</li><li><strong>结论引用规则</strong>：在推理过程中所得到的中间结论，可作为后续推理的前提</li><li><strong>代入规则</strong>：在推理过程中，对<strong>重言式</strong>中的命题变项可使用代入规则</li><li><strong>置换规则</strong>：在推理过程中，命题公式中的任何部分公式都可以用与之等值的命题公式来置换</li><li><strong>分离规则</strong>（假言推理）：如果已知命题公式 <span class="math inline"><em>A</em> → <em>B</em></span> 和 <span class="math inline"><em>A</em></span>，则有命题公式 <span class="math inline"><em>B</em></span></li><li><strong>条件证明规则</strong>（附加前提）：<span class="math inline"><em>A</em><sub>1</sub> ∧ <em>A</em><sub>2</sub> ⇒ <em>B</em></span>与 <span class="math inline"><em>A</em><sub>1</sub> ⇒ <em>A</em><sub>2</sub> → <em>B</em></span>是等价的</li></ul></li></ul><h3 id="归结推理">归结推理</h3><ul><li><strong>特点</strong><ul><li>定理机器证明方法</li><li>只有一条归结推理规则</li><li>易于机器实现</li><li>可推广到谓词逻辑推理</li></ul></li><li><strong>基本思想</strong><ul><li>证明 <span class="math inline"><em>A</em> ⇒ <em>B</em></span>等价于证明 <span class="math inline"><em>A</em> ∧ ¬<em>B</em></span>是矛盾式</li><li>用反证法，即假设 <span class="math inline"><em>A</em> ∧ ¬<em>B</em></span>在某种解释下为真，最后导出矛盾，得以证明</li></ul></li><li><strong>归结证明过程</strong><ol type="1"><li>从 <span class="math inline"><em>A</em> ∧ ¬<em>B</em></span>出发建立子句集 <span class="math inline"><em>S</em></span><ul><li>将 <span class="math inline"><em>A</em> ∧ ¬<em>B</em></span>化为合取范式，每个析取式均作为一个子句，构成这些子句的集合，记为 <span class="math inline"><em>S</em></span></li><li>如 <span class="math display">$$ P \wedge(P \vee R) \wedge(\neg P\vee \neg Q) \wedge(\neg P \vee R)\\ S=\{P,(P \vee R),(\neg P \vee \negQ),(\neg P \vee R)\}$$</span></li></ul></li><li>对 <span class="math inline"><em>S</em></span> 作归结 进而对 <span class="math inline"><em>S</em></span> 的子句作归结（消互补对），如子句<span class="math inline"><em>P</em> ∨ <em>R</em></span> 与 <span class="math inline">¬<em>P</em> ∨ ¬<em>Q</em></span> 作归结，得归结式<span class="math inline"><em>R</em> ∨ ¬<em>Q</em></span>，并将这归结式仍放入<span class="math inline"><em>S</em></span> 中。重复这过程。</li><li>直至归结出矛盾式 <span class="math inline">▫</span></li></ol></li><li><strong>归结式定义</strong>：设 <span class="math inline"><em>R</em><sub>1</sub> = <em>P</em> ∨ <em>Q</em><sub>1</sub>, <em>R</em><sub>2</sub> = ¬<em>P</em> ∨ <em>Q</em><sub>2</sub></span>为两个子句，有互补对 <span class="math inline"><em>P</em></span> 和<span class="math inline">¬<em>P</em></span>，则新子句 <span class="math inline"><em>R</em>(<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>) = <em>Q</em><sub>1</sub> ∨ <em>Q</em><sub>2</sub></span>称为 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub></span>的归结式</li><li><strong>推理规则</strong> <span class="math inline"><em>R</em><sub>1</sub> ∧ <em>R</em><sub>2</sub> ⇒ <em>R</em>(<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>)</span><ul><li>设在任一解释下, <span class="math inline"><em>R</em><sub>1</sub> ∧ <em>R</em><sub>2</sub> = <em>T</em></span>,则 <span class="math inline"><em>R</em><sub>1</sub> = <em>T</em></span>且 <span class="math inline"><em>R</em><sub>2</sub> = <em>T</em></span></li><li>若 <span class="math inline"><em>P</em> = <em>T</em></span>, 则<span class="math inline">¬<em>P</em> = <em>F</em></span>, <span class="math inline"><em>Q</em><sub>2</sub> = <em>T</em></span>, <span class="math inline"><em>R</em>(<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>) = <em>Q</em><sub>1</sub> ∨ <em>Q</em><sub>2</sub> = <em>T</em></span></li><li>若 <span class="math inline"><em>P</em> = <em>F</em></span>, 则<span class="math inline">¬<em>P</em> = <em>T</em></span>, <span class="math inline"><em>Q</em><sub>1</sub> = <em>T</em></span>, <span class="math inline"><em>R</em>(<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>) = <em>Q</em><sub>1</sub> ∨ <em>Q</em><sub>2</sub> = <em>T</em></span></li><li>若 <span class="math inline"><em>Q</em><sub>1</sub> = <em>T</em></span> 或者<span class="math inline"><em>Q</em><sub>2</sub> = <em>T</em></span>,都有 <span class="math inline"><em>R</em>(<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>) = <em>Q</em><sub>1</sub> ∨ <em>Q</em><sub>2</sub> = <em>T</em></span></li></ul></li></ul><h2 id="第四章-谓词逻辑的基本概念">第四章 谓词逻辑的基本概念</h2><h3 id="谓词和个体词">谓词和个体词</h3><h4 id="谓词">谓词</h4><ul><li>约定：<ul><li>小写字母表示命题</li><li>大写字母表示谓词</li></ul></li><li><strong>定义</strong>：谓词是给定的个体域到集合 <span class="math inline">{T, F}</span> 上的一个映射。<ul><li><strong>一元谓词</strong>：在一个命题里，如果主词只有一个，这时表示该主词性质或属性的词便称作谓词。这是一元（目）谓词，以<span class="math inline"><em>P</em>(<em>x</em>), <em>Q</em>(<em>x</em>), ⋯</span>表示.</li><li><strong>多元谓词</strong>：在一个命题里，如果主词多于一个，那么表示这几个主词间的关系的词称作谓词。这是多元谓词，以<span class="math inline"><em>P</em>(<em>x</em>, <em>y</em>), <em>Q</em>(<em>x</em>, <em>y</em>), <em>R</em>(<em>x</em>, <em>y</em>, <em>z</em>), ⋯</span>表示</li></ul></li><li>一般地说谓词 <span class="math inline"><em>P</em>(<em>x</em>), <em>Q</em>(<em>x</em>, <em>y</em>)</span>是命题形式而不是命题<ul><li>因为这里没有指定谓词符号 <span class="math inline"><em>P</em>, <em>Q</em></span>的含义，即它们是谓词变项。</li><li>仅当谓词变项取定为某个谓词常项，并且个体词取定为个体常项时，命题形式才化为命题</li><li>谓词的真值依赖于个体变元的论域</li></ul></li></ul><h4 id="个体词">个体词</h4><ul><li><strong>个体词(主词)</strong><ul><li>个体词是一个命题里表示思维对象的词</li><li><span class="math inline"><em>P</em>(<em>张</em><em>三</em>)</span>中的张三是个体词或称个体常项</li><li>谓词 <span class="math inline"><em>P</em>(<em>x</em>)</span>中的变量 <span class="math inline"><em>x</em></span>为个体变项或个体变元</li></ul></li><li><strong>n项(目、元)谓词</strong><ul><li>有 <span class="math inline"><em>n</em></span> 个个体的谓词 <span class="math inline"><em>P</em>(<em>x</em><sub>1</sub>, …, <em>x</em><sub><em>n</em></sub>)</span>称 <span class="math inline"><em>n</em></span> 项(目、元)谓词</li><li>如果 <span class="math inline"><em>P</em></span>是已赋有确定含义的谓词，就称为谓词常项</li><li>如果 <span class="math inline"><em>P</em></span>表示任一谓词时，就称为谓词变项</li></ul></li><li><strong>个体域</strong><ul><li>将个体变项的变化范围称为个体域或论域，以 <span class="math inline"><em>D</em></span> 表示</li><li>论域是重要的概念，同一谓词在不同论域下的描述形式可能不同，所取的真假值也可能不同</li></ul></li><li><strong>约定</strong><ul><li>谓词逻辑的个体域除明确指明外，都认为是包括一切事物的一个最广的集合</li><li>谓词变项的变化范围，不做特别声明时，指一切关系或一切性质的集合</li></ul></li></ul><h4 id="谓词逻辑与命题逻辑">谓词逻辑与命题逻辑</h4><ul><li>可认为谓词逻辑是命题逻辑的推广，命题逻辑是谓词逻辑的特殊情形<ul><li>因为任一命题都可通过引入具有相应含义的谓词(个体词视为常项)来表示</li><li>或认为一个命题是没有个体变元的零元谓词</li></ul></li><li>命题逻辑中的很多概念、规则都可推广到谓词逻辑中延用<ul><li>如联结词可照搬到谓词逻辑，无需再做说明</li><li>有的等值式推理式也可移植到谓词逻辑</li><li>然而谓词逻辑里出现了个体变元，谓词、量词等概念，特别是个体论域常是无限域，加大了处理难度</li><li>最简单又深刻的例子：在命题逻辑里一个公式不难判定它是否是重言式，真值表法是能行的方法．然而<strong>在谓词逻辑里就没有一般的能行算法来判定任一公式是不是普遍有效的</strong>(或称定理、永真式)</li></ul></li></ul><h3 id="函数和量词">函数和量词</h3><h4 id="函数">函数</h4><ul><li><strong>定义</strong>：函数是某个体域（不必是实数）到另一个体域的映射。<ul><li>不同于谓词：将个体映射为真假值</li><li>函数并不单独使用，是嵌入在谓词中</li></ul></li><li><strong>约定</strong>：函数符号用小写字母表示。</li></ul><h4 id="量词">量词</h4><ul><li><strong>定义</strong>：用来表示个体数量的词是量词，可看作是对个体词所加的限制、约束的词。</li><li>量词仅作用于<strong>个体变元</strong>，不允许量词作用于<strong>命题变项</strong>和<strong>谓词变项</strong>。</li></ul><h5 id="全称量词-forall">全称量词 <span class="math inline">∀</span></h5><ul><li>符号 <span class="math inline">(∀<em>x</em>)</span><ul><li>读作所有的 <span class="math inline"><em>x</em></span> 或任一 <span class="math inline"><em>x</em></span>，一切 <span class="math inline"><em>x</em></span>。</li><li>而 <span class="math inline">∀</span> 就是<strong>全称量词</strong>，它所约束的个体是 <span class="math inline"><em>x</em></span>。</li></ul></li><li><strong>定义</strong>：命题 <span class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>)</span>当且仅当对论域中的所有 <span class="math inline"><em>x</em></span>来说，<span class="math inline"><em>P</em>(<em>x</em>)</span>均为真时方为真。</li><li><strong>性质</strong>：<span class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>) = F</span>成立，当且仅当有一个 <span class="math inline"><em>x</em><sub>0</sub> ∈ <em>D</em></span>，使 <span class="math inline"><em>P</em>(<em>x</em><sub>0</sub>) = F</span></li></ul><h5 id="存在量词-exists">存在量词 <span class="math inline">∃</span></h5><ul><li>符号 <span class="math inline">(∃<em>x</em>)</span><ul><li>读作至少有一个 <span class="math inline"><em>x</em></span>或存在一个 <span class="math inline"><em>x</em></span> 或有某些 <span class="math inline"><em>x</em></span>。</li><li>而 <span class="math inline">∃</span>就是对个体词起约束作用的<strong>存在量词</strong> ，所约束的变元是 <span class="math inline"><em>x</em></span>。</li></ul></li><li><strong>定义</strong>：命题 <span class="math inline">(∃<em>x</em>)<em>Q</em>(<em>x</em>)</span>当且仅当在论域中至少有一个 <span class="math inline"><em>x</em><sub>0</sub></span>，<span class="math inline"><em>Q</em>(<em>x</em><sub>0</sub>)</span>为真时方为真。</li><li><strong>性质</strong>：从而 <span class="math inline">(∃<em>x</em>)<em>Q</em>(<em>x</em>) = <em>F</em></span>，当且仅当对所有的<span class="math inline"><em>x</em> ∈ <em>D</em></span> 都有 <span class="math inline"><em>Q</em>(<em>x</em>) = <em>F</em></span>。</li></ul><h4 id="约束变元和自由变元">约束变元和自由变元</h4><ul><li><strong>自由变元</strong>：若 <span class="math inline"><em>P</em>(<em>x</em>)</span> 表示 <span class="math inline"><em>x</em></span> 是有理数，这时的变元 <span class="math inline"><em>x</em></span>不受任何量词约束，便称是自由的。</li><li><strong>约束变元</strong>：而 <span class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>)</span>中的两处出现的变元 <span class="math inline"><em>x</em></span> 都受量词<span class="math inline">∀</span>的约束，便称作约束变元，受约束的变元也称被量词量化了的变元。</li><li>例子：在命题形式 <span class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>) ∨ <em>Q</em>(<em>y</em>)</span>中，变元 <span class="math inline"><em>x</em></span> 是约束的，而变元<span class="math inline"><em>y</em></span> 是自由的。</li></ul><h4 id="辖域">辖域</h4><ul><li><strong>定义</strong>：量词所约束的范围称为量词的辖域</li><li>例子：<ul><li><span class="math inline">(∀<em>x</em>)<em>R</em>(<em>x</em>, <em>y</em>)</span>中，<span class="math inline"><em>R</em>(<em>x</em>, <em>y</em>)</span>是 <span class="math inline">(∀<em>x</em>)</span> 的辖域</li><li><span class="math inline">(∃<em>x</em>)((∀<em>y</em>)<em>P</em>(<em>x</em>, <em>y</em>))</span>中<ul><li><span class="math inline"><em>P</em>(<em>x</em>, <em>y</em>)</span>是 <span class="math inline">(∀<em>y</em>)</span> 的辖域</li><li><span class="math inline">(∀<em>y</em>)<em>P</em>(<em>x</em>, <em>y</em>)</span>是 <span class="math inline">(∃<em>x</em>)</span> 的辖域</li></ul></li></ul></li></ul><h4 id="变元易名规则">变元易名规则</h4><ul><li>变元易名规则： <span class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>) = (∀<em>y</em>)<em>P</em>(<em>y</em>)</span><ul><li>注：<span class="math inline">(∀<em>x</em>)(<em>P</em>(<em>x</em>) → <em>Q</em>(<em>x</em>, <em>y</em>)) ≠ (∀<em>y</em>)(<em>P</em>(<em>y</em>) → <em>Q</em>(<em>y</em>, <em>y</em>))</span></li></ul></li><li>因为在同一论域 <span class="math inline"><em>D</em></span> 上，对一切 <span class="math inline"><em>x</em></span>， <span class="math inline"><em>x</em></span> 具有性质 <span class="math inline"><em>P</em></span>， 同对一切 <span class="math inline"><em>y</em></span>， <span class="math inline"><em>y</em></span> 具有性质 <span class="math inline"><em>P</em></span>， 除变元 <span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>y</em></span> 的区别外并无差异， 从而 <span class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>)</span> 和 <span class="math inline">(∀<em>y</em>)<em>P</em>(<em>y</em>)</span>真值相同</li></ul><h3 id="合式公式-1">合式公式</h3><ul><li>关注一阶谓词逻辑， 而不是高阶谓词逻辑<ul><li>限定在量词仅作用于个体变元</li><li>不允许量词作用于命题变项和谓词变项</li><li>也不讨论谓词的谓词</li></ul></li><li>符号约定<ul><li>命题变项：<span class="math inline"><em>p</em>, <em>q</em>, <em>r</em>, ⋯</span></li><li>个体变项：<span class="math inline"><em>x</em>, <em>y</em>, <em>z</em>, ⋯</span></li><li>个体常项：<span class="math inline"><em>a</em>, <em>b</em>, <em>c</em>, ⋯</span>或者大写英文单词</li><li>谓词变项：<span class="math inline"><em>P</em>, <em>Q</em>, <em>R</em>, ⋯</span></li><li>谓词常项：大写英文字母, 如<span class="math inline"><em>G</em><em>R</em><em>E</em><em>A</em><em>T</em></span></li><li>函数：<span class="math inline"><em>f</em>, <em>g</em>, ⋯</span>或者小写英文单词</li><li>五个联结词： <span class="math inline">¬,∨, ∧, →,↔︎</span></li><li>两个量词： <span class="math inline">∀,∃</span></li><li>小括号： <span class="math inline">(,)</span></li></ul></li><li><strong>合式公式定义</strong>：<ol type="1"><li>命题常项、命题变项和原子谓词公式（不含联结词的谓词）都是合式公式</li><li>如果 <span class="math inline"><em>A</em></span> 是合式公式，则<span class="math inline">¬<em>A</em></span> 也是合式公式</li><li>如果 <span class="math inline"><em>A</em>, <em>B</em></span>是合式公式，而无变元 <span class="math inline"><em>x</em></span> 在<span class="math inline"><em>A</em>, <em>B</em></span>的一个中是约束的而在另一个中是是自由的，则 <span class="math inline">(<em>A</em> ∧ <em>B</em>), (<em>A</em> ∨ <em>B</em>), (<em>A</em> → <em>B</em>), (<em>A</em> ↔︎ <em>B</em>)</span>也是合式公式（最外层括号可省略）</li><li>如果 <span class="math inline"><em>A</em></span> 是合式公式，而<span class="math inline"><em>x</em></span> 在 <span class="math inline"><em>A</em></span> 中是自由变元，则 <span class="math inline">(∀<em>x</em>)<em>A</em>, (∃<em>x</em>)<em>A</em></span>也是合式公式</li><li>只有适合以上 <span class="math inline">4</span>条的才是合式公式</li></ol></li></ul><h3 id="自然语句的形式化">自然语句的形式化</h3><h4 id="常见自然语言的形式化">常见自然语言的形式化</h4><ul><li><strong>“所有的……都是……”</strong><ul><li>所有的有理数都是实数，其意思是说，对任一事物而言，如果它是有理数，那么它是实数。即对任一<span class="math inline"><em>x</em></span> 而言，如果 <span class="math inline"><em>x</em></span> 是有理数，那么 <span class="math inline"><em>x</em></span> 是实数。</li><li>若以 <span class="math inline"><em>P</em>(<em>x</em>)</span> 表示<span class="math inline"><em>x</em></span> 是有理数，<span class="math inline"><em>Q</em>(<em>x</em>)</span> 表示 <span class="math inline"><em>x</em></span> 是实数，这句话的形式描述应为 <span class="math display">(∀<em>x</em>)(<em>P</em>(<em>x</em>) → <em>Q</em>(<em>x</em>))</span></li></ul></li><li><strong>“有的……是”</strong><ul><li>这句话的意思是说，存在一事物它是实数，而且是有理数。即有一个 <span class="math inline"><em>x</em></span>，<span class="math inline"><em>x</em></span> 是实数并且是有理数。、</li><li>仍以 <span class="math inline"><em>P</em>(<em>x</em>)</span> 表<span class="math inline"><em>x</em></span> 是有理数，<span class="math inline"><em>Q</em>(<em>x</em>)</span> 表示 <span class="math inline"><em>x</em></span> 是实数，这句话的形式描述应为 <span class="math display">(∃<em>x</em>)(<em>Q</em>(<em>x</em>) ∧ <em>P</em>(<em>x</em>))</span></li></ul></li><li><strong>“没有……是……”</strong><ul><li>这句话有否定词，意思是对任一 <span class="math inline"><em>x</em></span> 而言，如果 <span class="math inline"><em>x</em></span> 是无理数，那么 <span class="math inline"><em>x</em></span> 不是有理数。</li><li>若以 <span class="math inline"><em>A</em>(<em>x</em>)</span> 表示<span class="math inline"><em>x</em></span> 是无理数，<span class="math inline"><em>B</em>(<em>x</em>)</span> 表示 <span class="math inline"><em>x</em></span> 是有理数，这句话的形式描述为 <span class="math display">¬(∃<em>x</em>)(<em>A</em>(<em>x</em>) ∧ <em>B</em>(<em>x</em>))</span></li><li>也可以逻辑上等价的 <span class="math display">$$ \begin{aligned}  (\forall x)(A(x) \rightarrow \neg B(x)) \\  (\forall x)(B(x) \rightarrow \neg A(x))  \end{aligned}$$</span></li></ul></li><li><strong>“有的……不是……”</strong><ul><li>这句话的意思是有的 <span class="math inline"><em>x</em></span>，它是实数而且不是有理数。</li><li>若以 <span class="math inline"><em>A</em>(<em>x</em>)</span> 表示<span class="math inline"><em>x</em></span> 是实数，<span class="math inline"><em>B</em>(<em>x</em>)</span> 表示 <span class="math inline"><em>x</em></span> 是有理数，那么这句话可形式描述为<span class="math display">(∃<em>x</em>)(<em>A</em>(<em>x</em>) ∧ ¬<em>B</em>(<em>x</em>))</span></li></ul></li></ul><h4 id="自然数集的形式描述">自然数集的形式描述</h4><ul><li>论域是自然数集，来形式化语句<ol type="1"><li>对每个数，有且仅有一个相继后元</li><li>没有这样的数，<span class="math inline">0</span> 是其相继后元</li><li>对除 <span class="math inline">0</span>而外的数，有且仅有一个相继前元（可将这三句话作为建立自然数集合的公理）</li></ol></li><li>引入谓词 <span class="math inline"><em>E</em>(<em>x</em>, <em>y</em>)</span> 表示 <span class="math inline"><em>x</em> = <em>y</em></span>，函数 <span class="math inline"><em>f</em>(<em>x</em>)</span> 表示个体 <span class="math inline"><em>x</em></span> 的相继后元，即 <span class="math inline"><em>f</em>(<em>x</em>) = <em>x</em> + 1</span>。函数<span class="math inline"><em>g</em>(<em>x</em>)</span> 表示个体 <span class="math inline"><em>x</em></span> 的相继前元，即 <span class="math inline"><em>g</em>(<em>x</em>) = <em>x</em> − 1</span></li><li><strong>有且仅有</strong>：如果有两个，那么它们必然相等</li><li><strong>形式化</strong> <span class="math display">$$  \begin{aligned}  &amp;(\forall x)(\exists y)(E(y, f(x)) \wedge(\forall z)(E(z, f(x))\rightarrow E(y, z)))\\  &amp;(\forall x)(\neg E(x, 0) \rightarrow(\exists y)(E(y, g(x))\wedge(\forall z)(E(z, g(x)) \rightarrow E(y, z))))\\  &amp;\neg(\exists x) E(0, f(x))  \end{aligned}  $$</span></li></ul><h4 id="谓词变元多次量化">谓词变元多次量化</h4><p><span class="math display">$$\begin{aligned}(\forall x)(\forall y) P(x, y)=(\forall x)((\forall y) P(x, y)) \\(\forall x)(\exists y) P(x, y)=(\forall x)((\exists y) P(x, y))\\(\exists x)(\forall y) P(x, y)=(\exists x)((\forall y) P(x, y)) \\(\exists x)(\exists y) P(x, y)=(\exists x)((\exists y) P(x, y))\end{aligned}$$</span></p><ul><li>其中：<ul><li>第一个和第四个公式里的约束可交换</li><li>第二个和第三个公式里的约束不可交换，存在依赖关系</li></ul></li></ul><h3 id="论域为有限域时的公式表示法">论域为有限域时的公式表示法</h3><ul><li>约定论域限定为有限集，用 <span class="math inline">{1, 2, ⋯, <em>k</em>}</span> 来代表； <span class="math display">(∀<em>x</em>)(<em>P</em>(<em>x</em>) → <em>Q</em>(<em>x</em>))</span></li><li>论域为有限域时，公式表示法： <span class="math display">$$\begin{aligned}  (\forall x) P(x)=P(1) \wedge P(2) \wedge \cdots \wedge P(k) \\  (\exists x) P(x)=P(1) \vee P(2) \vee \cdots \vee P(k)  \end{aligned}  $$</span></li><li>严格意义上，无限域下，不是合式公式，谓词逻辑公式不能转换为命题逻辑公式</li><li><strong>谓词公式的解释</strong><ul><li>谓词公式的解释与论域，自由个体变元，命题变元，谓词变元，函数都有关系</li><li>对谓词公式 <span class="math inline"><em>I</em></span>的解释包括五个部分<ul><li>非空论域 <span class="math inline"><em>D</em></span></li><li>命题变元指派为 <span class="math inline">{0, 1}</span></li><li>对个体常元和（自由）个体变元指派为 <span class="math inline"><em>D</em></span> 中的元素</li><li>对谓词指派为 <span class="math inline"><em>D</em></span>上的谓词</li><li>对函数指派为 <span class="math inline"><em>D</em></span>上的函数</li></ul></li></ul></li></ul><h3 id="公式的普遍有效性和判定问题">公式的普遍有效性和判定问题</h3><ul><li><strong>公式的普遍有效性</strong><ul><li>对一个谓词公式来说，如果在它的任一解释 <span class="math inline"><em>I</em></span>下真值都为真，便称作普遍有效的</li><li>对一个谓词公式来说，如果在它的某个解释 <span class="math inline"><em>I</em></span> 下真值为真，便称作可满足的</li><li>对一个谓词公式来说，如果在它的任一解释 <span class="math inline"><em>I</em></span>下真值均为假，便称作不可满足的</li><li>有限域上一个公式的可满足性和普遍有效性依赖于个体域个体的个数且仅依赖于个体域个体的数目<ul><li>在某个含 <span class="math inline"><em>k</em></span> 个元素的 <span class="math inline"><em>k</em></span>个体域上普遍有效（或可满足），则在任一 <span class="math inline"><em>k</em></span>个体域上也普遍有效（或可满足）</li><li>如果某公式在 <span class="math inline"><em>k</em></span>个体域上普遍有效，则在 <span class="math inline"><em>k</em> − 1</span>个体域上也普遍有效</li><li>如果某公式在 <span class="math inline"><em>k</em></span>个体域上可满足，则在 <span class="math inline"><em>k</em> + 1</span>个体域上也可满足</li></ul></li></ul></li><li><strong>判定问题</strong>：谓词逻辑的判定问题，指的是任一公式的普遍有效性。若说谓词逻辑是可判定的，就要给出一个能行方法，使得对任一谓词公式都能判断其是否普遍有效。<ul><li>结论：<ol type="1"><li>谓词逻辑是不可判定的；<ul><li>对任一谓词公式而言，没有能行的方法判明它是否是普遍有效的</li><li>并不排除谓词公式有子类是可判定的</li><li>判定问题的困难在于个体域是个无穷集以及对谓词设定的任意性</li></ul></li><li>只含一元谓词变元的公式是可判定的</li><li><span class="math inline">(∀<em>x</em><sub>1</sub>)⋯(∀<em>x</em><sub><em>n</em></sub>)<em>P</em>(<em>x</em><sub>1</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)</span>和 <span class="math inline">(∃<em>x</em><sub>1</sub>)⋯(∃<em>x</em><sub><em>n</em></sub>)<em>P</em>(<em>x</em><sub>1</sub>…<em>x</em><sub><em>n</em></sub>)</span>型公式，若 <span class="math inline"><em>P</em></span>中无量词和其他自由变项时， 也是可判定的</li><li>个体域有穷时的谓词公式是可判定的</li></ol></li></ul></li></ul><h2 id="第五章-谓词逻辑的等值和推理演算">第五章谓词逻辑的等值和推理演算</h2><h3 id="否定型等值式">否定型等值式</h3><ul><li>若给定了两个谓词公式 <span class="math inline"><em>A</em>, <em>B</em></span>，说 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 是等值的，如果在公式 <span class="math inline"><em>A</em>, <em>B</em></span> 的任一解释下，<span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 都有相同的真值。<ul><li>在谓词逻辑中， 需要给出解释的内容包括:<ul><li>论域</li><li>谓词变项</li><li>命题变项</li><li>函数</li><li>自由个体</li></ul></li></ul></li><li>等价的说法:<ul><li><span class="math inline"><em>A</em>, <em>B</em></span> 等值当且仅当<span class="math inline"><em>A</em> ↔︎ <em>B</em></span>是普遍有效的公式</li><li>记作 <span class="math inline"><em>A</em> = <em>B</em></span> 或<span class="math inline"><em>A</em> ⇔ <em>B</em></span></li></ul></li></ul><h4 id="由命题公式移植来的等值式">由命题公式移植来的等值式</h4><p><span class="math display">$$\begin{aligned}&amp; \neg \neg P(x)= P(x)\\&amp; \neg \neg(\forall x) P(x)=(\forall x) P(x)\\&amp; P(x) \rightarrow Q(x)=\neg P(x) \vee Q(x)\\&amp; (\forall x) P(x) \rightarrow(\exists x) Q(x)=\neg(\forall x) P(x)\vee(\exists x) Q(x)\\&amp; (P(x) \wedge Q(x)) \vee R(x)=(P(x) \vee R(x)) \wedge(Q(x) \veeR(x))\\&amp; ((\forall x) P(x) \wedge Q(y)) \vee(\exists z) R(z) =((\forall x)P(x) \vee(\exists z) R(z)) \wedge(Q(y) \vee(\exists z) R(z))\end{aligned}$$</span></p><h4 id="否定型等值式摩根律的推广">否定型等值式(摩根律的推广)</h4><p><span class="math display">$$\begin{arligned}\neg(\forall x) P(x)=(\exists x) \neg P(x) \\\neg(\exists x) P(x)=(\forall x) \neg P(x)\end{arligned}$$</span></p><ul><li>形式上看这对公式，是说否定词“<span class="math inline">¬</span>”可越过量词深入到量词的辖域内，但要把所越过的量词<span class="math inline">∀</span> 转换为 <span class="math inline">∃</span>，<span class="math inline">∃</span> 转换为<span class="math inline">∀</span></li></ul><h3 id="量词分配等值式">量词分配等值式</h3><h4 id="量词对合取析取的分配律">量词对合取、析取的分配律</h4><p><span class="math display">$$\begin{aligned}(\forall x)(P(x) \vee q)=(\forall x) P(x) \vee q \\(\exists x)(P(x) \vee q)=(\exists x) P(x) \vee q \\(\forall x)(P(x) \wedge q)=(\forall x) P(x) \wedge q \\(\exists x)(P(x) \wedge q)=(\exists x) P(x) \wedge q\end{aligned}$$</span></p><h4 id="量词对蕴涵的分配律">量词对蕴涵的分配律</h4><p><span class="math display">$$\begin{aligned}(\forall x)(P(x) \rightarrow q)=(\exists x) P(x)\rightarrow q \\(\exists x)(P(x) \rightarrow q)=(\forall x) P(x) \rightarrowq \\(\forall x)(p \rightarrow Q(x))=p \rightarrow(\forall x) Q(x) \\(\exists x)(p \rightarrow Q(x))=p \rightarrow(\exists x) Q(x)\end{aligned}$$</span></p><h4 id="全称量词对合取存在量词对析取的分配律">全称量词对合取、存在量词对析取的分配律</h4><p><span class="math display">$$\begin{aligned}(\forall x)(P(x) \wedge Q(x))=(\forall x) P(x) \wedge(\forall x) Q(x) \\(\exists x)(P(x) \vee Q(x))=(\exists x) P(x) \vee(\exists x) Q(x)\end{aligned}$$</span></p><h4 id="变元易名后的分配律">变元易名后的分配律</h4><p><span class="math display">$$\begin{aligned}(\forall x)(\forall y)(P(x) \vee Q(y))=(\forall x) P(x) \vee(\forall y)Q(y) \\(\exists x)(\exists y)(P(x) \wedge Q(y))=(\exists x) P(x) \wedge(\existsy) Q(y)\end{aligned}$$</span></p><h3 id="范式-2">范式</h3><ul><li>在命题逻辑里．每一公式都有与之等值的范式。<ul><li>范式是一种统一的表达形式、当研究一个公式的特点(如永真、永假)时，范式起着重要的作用。</li></ul></li><li>对谓词逻辑的公式来说也有范式<ul><li>其中前束范式与原公式是等值的</li><li>其他范式与原公式只有较弱的关系</li></ul></li></ul><h4 id="前束范式">前束范式</h4><ul><li><p><strong>前束范式</strong>：如果 <span class="math inline"><em>A</em></span>中的一切量词都位于该公式的最左边（不含否定词）且这些量词的辖域都延伸到公式的末端，便称<span class="math inline"><em>A</em></span> 为前束范式。</p></li><li><p>前束范式 <span class="math inline"><em>A</em></span> 的一般形式为<span class="math display">(<em>Q</em><sub>1</sub><em>x</em><sub>1</sub>)⋯(<em>Q</em><sub><em>n</em></sub><em>x</em><sub><em>n</em></sub>)<em>M</em>(<em>x</em><sub>1</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)</span></p><p>其中 <span class="math inline"><em>Q</em><sub><em>i</em></sub></span>为量词 <span class="math inline">∀</span> 或 <span class="math inline">∃(<em>i</em> = 1, ⋯, <em>n</em>)</span>，<span class="math inline"><em>M</em></span> 称作公式 <span class="math inline"><em>A</em></span>的<strong>母式</strong>（基式），<span class="math inline"><em>M</em></span> 中不再有量词</p></li><li><p>谓词逻辑的任一公式都可化为与之等值的前束范式，但其前束范式并不唯一</p></li><li><p><strong>步骤</strong>：</p><ol type="1"><li>消除联结词 <span class="math inline">↔︎,→</span></li><li>反复使用摩根律将 <span class="math inline">¬</span> 内移</li><li>使用分配等值式将量词左移</li><li>使用变元易名分配等值式进行变元易名</li></ol></li></ul><h4 id="skolem-标准形">Skolem 标准形</h4><ul><li><strong>定义</strong>：仅保留全称量词的前束形。</li><li>谓词逻辑的任一公式 <span class="math inline"><em>A</em></span>都可以化作 Skolem 标准型，并且 <span class="math inline"><em>A</em></span> 是不可满足的，当且仅当其 Skolem标准型是不可满足的。<ul><li>这定理是说对不可满足的公式，它与其 Skolem标准形是等值的，而一般的公式与其 Skolem 标准形并不是等值的。自然仅当<span class="math inline"><em>A</em></span> 是不可满足的方使用 Skolem标准形</li></ul></li><li><strong>求 Skolem 标准形的步骤</strong>：<ul><li>首先要求出前束形</li><li>从左到右消去存在量词，设要消去 <span class="math inline">(∃<em>x</em>)</span>，则将谓词 <span class="math inline"><em>P</em></span> 中出现的所有变元 <span class="math inline"><em>x</em></span> 均以论域中的某个常项 <span class="math inline"><em>a</em></span> 代入。若 <span class="math inline">(∃<em>x</em>)</span> 的左边有若干全称量词 <span class="math inline">(∀<em>y</em>)⋯(∀<em>z</em>)</span>，需将谓词 <span class="math inline"><em>P</em></span> 中出现的所有变元 <span class="math inline"><em>x</em></span> 均以全称量词 <span class="math inline"><em>y</em>, ⋯, <em>z</em></span> 的某个多元函数<span class="math inline"><em>f</em>(<em>y</em>, ⋯, <em>z</em>)</span>代入。</li><li>这样便得消去全部存在量词的 Skolem 标准形</li></ul></li></ul><h3 id="基本推理公式-1">基本推理公式</h3><p><span class="math display">$$\begin{aligned}&amp;(\forall x) P(x) \vee(\forall x) Q(x) \Rightarrow(\forall x)(P(x)\vee Q(x))\\&amp;(\exists x)(P(x) \wedge Q(x)) \Rightarrow(\exists x) P(x)\wedge(\exists x) Q(x)\\&amp;(\forall x)(P(x) \rightarrow Q(x)) \Rightarrow(\forall x) P(x)\rightarrow(\forall x) Q(x)\\&amp;(\forall x)(P(x) \rightarrow Q(x)) \Rightarrow(\exists x) P(x)\rightarrow(\exists x) Q(x)\\&amp;(\forall x)(P(x) \leftrightarrow Q(x)) \Rightarrow(\forall x) P(x)\leftrightarrow(\forall x) Q(x)\\&amp;(\forall x)(P(x) \leftrightarrow Q(x)) \Rightarrow(\exists x) P(x)\leftrightarrow(\exists x) Q(x)\\&amp;(\forall x)(P(x) \rightarrow Q(x)) \wedge(\forall x)(Q(x)\rightarrow R(x)) \Rightarrow(\forall x)(P(x) \rightarrow R(x))\\&amp;(\forall x)(P(x) \rightarrow Q(x)) \wedge P(a) \Rightarrow Q(a)\\&amp;(\forall x)(\forall y) P(x, y) \Rightarrow(\exists x)(\forall y)P(x, y)\\&amp;(\exists x)(\forall y) P(x, y) \Rightarrow(\forall y)(\exists x)P(x, y)\\\end{aligned}$$</span></p><h3 id="推理演算-1">推理演算</h3><h4 id="推理规则">推理规则</h4><ul><li><strong>全称量词消去规则</strong> <span class="math display">(∀<em>x</em>)<em>P</em>(<em>x</em>) ⇒ <em>P</em>(<em>y</em>)</span><ul><li>其中 <span class="math inline"><em>y</em></span>是论域中一个体<br></li><li>意指如果所有的 <span class="math inline"><em>x</em> ∈ <em>D</em></span> 都具有性质 <span class="math inline"><em>P</em></span>，那么 <span class="math inline"><em>D</em></span> 中任一个体 <span class="math inline"><em>y</em></span> 必具有性质 <span class="math inline"><em>P</em></span>。<ul><li>当 <span class="math inline"><em>P</em>(<em>x</em>)</span>中不再含有量词和其他变项时，这条规则明显成立。</li><li>而当允许 <span class="math inline"><em>P</em>(<em>x</em>)</span>中可出现量词和变项时，需限制 <span class="math inline"><em>y</em></span>不在 <span class="math inline"><em>P</em>(<em>x</em>)</span>中约束出现(即右侧量不在左侧约束出现)。</li></ul></li><li>设 <span class="math inline"><em>P</em>(<em>x</em>)＝(∃<em>y</em>)(<em>x</em> &lt; <em>y</em>)</span>，<ul><li>则 <span class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>)＝(∀<em>x</em>)((∃<em>y</em>)(<em>x</em> &lt; <em>y</em>))</span>在实数上成立</li><li>不应有 <span class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>) ⇒ <em>P</em>(<em>y</em>)</span>，因为<span class="math inline"><em>P</em>(<em>y</em>)＝(∃<em>y</em>)(<em>y</em> &lt; <em>y</em>)</span>是矛盾式。</li><li>这时，<span class="math inline"><em>y</em></span> 在 <span class="math inline"><em>P</em>(<em>x</em>)</span> 中是约束出现了</li></ul></li></ul></li><li><strong>全称量词引入规则</strong> <span class="math display"><em>P</em>(<em>y</em>) ⇒ (∀<em>x</em>)<em>P</em>(<em>x</em>)</span><ul><li>其中 <span class="math inline"><em>y</em></span>是论域中任一个体</li><li>意指如果任一个体 <span class="math inline"><em>y</em></span>（自由变项）都具有性质 <span class="math inline"><em>P</em></span>，那么所有个体 <span class="math inline"><em>x</em></span> 都具有性质 <span class="math inline"><em>P</em></span>。<ul><li>仍需限制 <span class="math inline"><em>x</em></span> 不在 <span class="math inline"><em>P</em>(<em>y</em>)</span>中约束出现(即右侧量不在左侧约束出现)</li></ul></li><li>如 <span class="math inline"><em>P</em>(<em>y</em>)＝(∃<em>x</em>)(<em>x</em> &gt; <em>y</em>)</span>在实数域上成立,<ul><li><span class="math inline">(∀<em>x</em>)<em>P</em>(<em>x</em>)＝(∀<em>x</em>)((∃<em>x</em>)(<em>x</em> &gt; <em>x</em>))</span>是不成立的</li></ul></li></ul></li><li><strong>存在量词消去规则</strong> <span class="math display">(∃<em>x</em>)<em>P</em>(<em>x</em>) ⇒ <em>P</em>(<em>c</em>)</span><ul><li>其中 <span class="math inline"><em>c</em></span>是论域中的一个个体常项</li><li>意指如果论域中存在有个体具有性质 <span class="math inline"><em>P</em></span>，那么必有某个个体 <span class="math inline"><em>c</em></span> 具有性质 <span class="math inline"><em>P</em></span>。<ul><li>需限制 <span class="math inline">(∃<em>x</em>)<em>P</em>(<em>x</em>)</span>中没有自由个体出现<ul><li>如实数域上 <span class="math inline">(∃<em>x</em>)<em>P</em>(<em>x</em>) = (∃<em>x</em>)(<em>x</em> &gt; <em>y</em>)</span>是成立的， <span class="math inline"><em>y</em></span>是自由个体，这时不能推导出 <span class="math inline"><em>P</em>(<em>c</em>) = <em>c</em> &gt; <em>y</em></span></li></ul></li><li>还需限制 <span class="math inline"><em>P</em>(<em>x</em>)</span>中不含有 <span class="math inline"><em>c</em></span>。<ul><li>如在实数域上 <span class="math inline">(∃<em>x</em>)<em>P</em>(<em>x</em>) = (∃<em>x</em>)(<em>c</em> &lt; <em>x</em>)</span>是成立的，<span class="math inline"><em>P</em>(<em>c</em>) = <em>c</em> &lt; <em>c</em></span>不成立</li></ul></li></ul></li><li>思考方式：先定 <span class="math inline"><em>P</em></span>， 再定<span class="math inline"><em>c</em></span>， 最后讨论 <span class="math inline">(∃<em>x</em>)<em>P</em>(<em>x</em>) ⇒ <em>P</em>(<em>c</em>)</span>的正确性</li></ul></li><li><strong>存在量词引入规则</strong> <span class="math display"><em>P</em>(<em>c</em>) ⇒ (∃<em>x</em>)<em>P</em>(<em>x</em>)</span><ul><li>其中 <span class="math inline"><em>c</em></span>是论域中一个个体常项</li><li>意指如果有个体常项 <span class="math inline"><em>c</em></span>具有性质 <span class="math inline"><em>P</em></span>，那么 <span class="math inline">(∃<em>x</em>)<em>P</em>(<em>x</em>)</span> 必真。<ul><li>需限制 <span class="math inline"><em>x</em></span> 不出现在 <span class="math inline"><em>P</em>(<em>c</em>)</span> 中。如实数域上， <span class="math inline"><em>P</em>(0) = (∃<em>x</em>)(<em>x</em> &gt; 0)</span>成立，但 <span class="math inline">(∃<em>x</em>)<em>P</em>(<em>x</em>) = (∃<em>x</em>)(∃<em>x</em>)(<em>x</em> &gt; <em>x</em>)</span>是不成立的。</li></ul></li></ul></li></ul><h4 id="推理演算-2">推理演算</h4><ul><li>命题逻辑中引入推理规则的推理演算，可推广到谓词逻辑；</li><li>有关的推理规则（代入规则需补充说明）都可直接移入到谓词逻辑；</li><li>代入规则需补充说明：命题变项、自由个体变项和谓词变项的代入，要求保持合式公式和普遍有效性不被破坏</li><li>推理演算过程<ol type="1"><li>以自然语句表示的推理问题引入谓词形式化</li><li>使用基本的推理公式</li><li>若不能直接使用基本的推理公式，则消去量词</li><li>在无量词下，使用规则和公式推理</li><li>引入量词以求得结论</li></ol></li></ul><h3 id="谓词逻辑的归结推理法">谓词逻辑的归结推理法</h3><h4 id="归结证明过程">归结证明过程</h4><ol type="1"><li>为证明 <span class="math inline"><em>A</em> → <em>B</em></span>是定理（<span class="math inline"><em>A</em></span>，<span class="math inline"><em>B</em></span> 为谓词公式），等价的是证明 <span class="math inline"><em>A</em> ∧ ¬<em>B</em> = <em>G</em></span>是矛盾式，这是归结法的出发点</li><li>建立子句集 <span class="math inline"><em>S</em></span><ul><li>先将 <span class="math inline"><em>G</em></span>化成等值的前束范式，进而将这前束形化成 Skolem标准形（消去存在量词），得仅含全称量词的公式 <span class="math inline"><em>G</em><sup>′</sup></span>（曾指出 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span>在不可满足的意义下是一致的）</li><li>再将 <span class="math inline"><em>G</em><sup>′</sup></span>中的全称量词省略，<span class="math inline"><em>G</em><sup>′</sup></span>母式（已合取范式化）中的合取词 <span class="math inline">∧</span>以“，”表示，便得 <span class="math inline"><em>G</em></span> 的子句集<span class="math inline"><em>S</em></span></li><li>而 <span class="math inline"><em>S</em></span> 与 <span class="math inline"><em>G</em></span> 是同时不可满足的，<span class="math inline"><em>S</em></span> 中的变元视作有全称量词作用着</li></ul></li><li>对 <span class="math inline"><em>S</em></span> 作归结<ul><li>设 <span class="math inline"><em>C</em><sub>1</sub></span>，<span class="math inline"><em>C</em><sub>2</sub></span> 是 <span class="math inline"><em>S</em></span> 中两个子句：<ul><li><p>若 <span class="math inline"><em>C</em><sub>1</sub></span>，<span class="math inline"><em>C</em><sub>2</sub></span>有互补对，消去互补对，得到新的归结式放入 <span class="math inline"><em>S</em></span> 中；</p></li><li><p>若 <span class="math inline"><em>C</em><sub>1</sub></span>，<span class="math inline"><em>C</em><sub>2</sub></span>没有互补对，且它们无共同个体变元，不妨设 <span class="math inline"><em>L</em><sub>1</sub></span>，<span class="math inline"><em>L</em><sub>2</sub></span> 分别是 <span class="math inline"><em>C</em><sub>1</sub></span>，<span class="math inline"><em>C</em><sub>2</sub></span> 中的文字，如果 <span class="math inline"><em>L</em><sub>1</sub></span> 和 <span class="math inline">¬<em>L</em><sub>2</sub></span> 有合一置换 <span class="math inline"><em>σ</em></span>，则 <span class="math display">(<em>C</em><sub>1</sub><em>σ</em> − {<em>L</em><sub>1</sub><em>σ</em>}) ∪ (<em>C</em><sub>2</sub><em>σ</em> − {<em>L</em><sub>2</sub><em>σ</em>})</span></p><p>称作子句 <span class="math inline"><em>C</em><sub>1</sub></span>，<span class="math inline"><em>C</em><sub>2</sub></span> 的归结式</p></li></ul></li><li>对子句集 <span class="math inline"><em>S</em></span>的任两子句作归结（如果可作归结），并将归结式仍放入 <span class="math inline"><em>S</em></span> 中。</li></ul></li><li>重复这过程直至归结出空子句 <span class="math inline">▫</span>，得到矛盾，证明结束</li></ol><h1 id="集合论">集合论</h1><h2 id="第九章-集合">第九章 集合</h2><h3 id="集合的概念和表示方法">集合的概念和表示方法</h3><h4 id="集合的概念">集合的概念</h4><ul><li><strong>定义</strong>：集合是一些确定的、可以区分的事物汇聚在一起组成的一个整体。组成一个集合的每个事物称为该集合的一个<strong>元素</strong>，或简称一个<strong>元</strong><ul><li>如果 <span class="math inline"><em>a</em></span> 是集合 <span class="math inline"><em>A</em></span> 的一个元素，就说 <span class="math inline"><em>a</em></span> <strong>属于</strong> <span class="math inline"><em>A</em></span>，或者说 <span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>A</em></span> 中，记作 $ a A$</li><li>如果 <span class="math inline"><em>b</em></span> 不是集合 <span class="math inline"><em>A</em></span> 的一个元素，就说 <span class="math inline"><em>b</em></span> <strong>不属于</strong> <span class="math inline"><em>A</em></span>，或者说 <span class="math inline"><em>b</em></span> 不在 <span class="math inline"><em>A</em></span> 中，记作 $ b A$</li></ul></li><li><strong>性质</strong>：<ul><li>集合的元素可以是任何事物，也可以是另外的集合（集合的元素不能是该集合自身）</li><li>一个集合的各个元素是可以互相区分开的。这意味着，在一个集合中不会重复出现相同的元素</li><li>组成一个集合的各个元素在该集合中是无次序的</li><li>任一事物是否属于一个集合，回答是确定的。也就是说，对一个集合来说，任一事物或者是它的元素或者不是它的元素，二者必居其一而不可兼而有之，且结论是确定的</li></ul></li></ul><h4 id="集合的表示方法">集合的表示方法</h4><ul><li>常用集合<ul><li><span class="math inline">ℕ</span> 表示全体自然数的集合</li><li><span class="math inline">ℤ</span> 表示全体整数的集合</li><li><span class="math inline">ℚ</span> 表示全体有理数的集合</li><li><span class="math inline">ℝ</span> 表示全体实数的集合</li><li><span class="math inline">ℂ</span> 表示全体复数的集合</li></ul></li><li><strong>外延表示法</strong>：一一列举集合的全体元素<ul><li><span class="math inline">ℕ = {0, 1, 2, 3, …}</span></li></ul></li><li><strong>内涵表示法</strong>：用谓词来描述集合中元素的性质<ul><li><span class="math inline">ℕ = {<em>x</em> ∣ <em>x</em>是自然数}</span></li></ul></li><li>罗素（Russell）悖论：<ul><li><span class="math inline"><em>H</em> = {<em>x</em> ∣ <em>x</em>是一个集合且 <em>x</em> ∉ <em>x</em>}</span> 不存在</li><li>集合论不能研究“所有集合组成的集合”。</li></ul></li></ul><h3 id="集合间的关系和特殊集合">集合间的关系和特殊集合</h3><h4 id="集合间的关系">集合间的关系</h4><h5 id="相等">相等</h5><ul><li>两个集合是相等的，当且仅当它们有相同的元素。若两个集合 <span class="math inline">A</span> 和 <span class="math inline">B</span>相等，则记作 <span class="math inline"><em>A</em> = <em>B</em></span>；若 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 不相等，则记作 <span class="math inline"><em>A</em> ≠ <em>B</em></span>。</li><li>这个定义也可以写成 <span class="math display">$$ \begin{aligned}  A=B &amp;\Leftrightarrow(\forall x)(x \in A \leftrightarrow x \in B)\\  A \neq B &amp;\Leftrightarrow \neg(\exists x)(x \in A \leftrightarrowx \in B)  \end{aligned}$$</span></li><li>这个定义就是集合论中的<strong>外延公理</strong>，也叫<strong>外延原理</strong>。它实质上是说“一个集合是由它的元素完全决定的”</li></ul><h5 id="子集">子集</h5><ul><li>对任意两个集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，若 <span class="math inline"><em>A</em></span> 的每个元素都是 <span class="math inline"><em>B</em></span> 的元素，就称 <span class="math inline"><em>A</em></span> 为 <span class="math inline"><em>B</em></span> 的<strong>子集合</strong> ，或称<span class="math inline"><em>B</em></span> 包含 <span class="math inline"><em>A</em></span>，或称 <span class="math inline"><em>B</em></span> 是 <span class="math inline"><em>A</em></span> 的<strong>超集合</strong> ，记作<span class="math display"><em>A</em> ⊆ <em>B</em>或<em>B</em> ⊇ <em>A</em></span></li><li>这个定义也可以写成 <span class="math display"><em>A</em> ⊆ <em>B</em> ⇔ (∀<em>x</em>)(<em>x</em> ∈ <em>A</em> → <em>x</em> ∈ <em>B</em>)</span></li><li>当 <span class="math inline"><em>A</em></span> 不是 <span class="math inline"><em>B</em></span> 的子集合时，即 <span class="math inline"><em>A</em> ⊆ <em>B</em></span> 不成立时，记作 <span class="math inline"><em>A</em> ⊈ <em>B</em></span>（子集合可简称为子集）</li><li><strong>定理</strong>：<ul><li><strong>两个集合相等的充要条件是它们互为子集</strong>，即 <span class="math inline"><em>A</em> = <em>B</em> ⇔ (<em>A</em> ⊆ <em>B</em> ∧ <em>B</em> ⊆ <em>A</em>)</span></li><li>对任意的集合 <span class="math inline"><em>A</em>, <em>B</em>, <em>C</em></span>：<ul><li>自反性：<span class="math inline"><em>A</em> ⊆ <em>A</em></span></li><li>反对称性：<span class="math inline">(<em>A</em> ⊆ <em>B</em> ∧ <em>B</em> ⊆ <em>A</em>) ⇒ <em>A</em> = <em>B</em></span></li><li>传递性：<span class="math inline">(<em>A</em> ⊆ <em>B</em> ∧ <em>B</em> ⊆ <em>C</em>) ⇒ <em>A</em> ⊆ <em>C</em></span></li></ul></li></ul></li></ul><h5 id="真子集">真子集</h5><ul><li>对任意两个集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，若 <span class="math inline"><em>A</em> ⊆ <em>B</em></span> 且 <span class="math inline"><em>A</em> ≠ <em>B</em></span>，就称 <span class="math inline"><em>A</em></span> 为 <span class="math inline"><em>B</em></span> 的<strong>真子集</strong> ，或称<span class="math inline"><em>B</em></span> <strong>真包含</strong><span class="math inline"><em>A</em></span>，或称 <span class="math inline"><em>B</em></span> 是 <span class="math inline"><em>A</em></span> 的<strong>真超集合</strong> ，记作<span class="math display"><em>A</em> ⊂ <em>B</em> 或<em>B</em> ⊃ <em>A</em></span></li><li>这个定义也可以写成 <span class="math display"><em>A</em> ⊂ <em>B</em> ⇔ (<em>A</em> ⊆ <em>B</em> ∧ <em>A</em> ≠ <em>B</em>)</span></li></ul><h5 id="不相交">不相交</h5><ul><li>若两个集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 没有公共元素，就称 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 是不相交的。这个定义也可以写成<span class="math display"><em>A</em><em>和</em><em>B</em><em>不</em><em>相</em><em>交</em> ⇔ ¬(∃<em>x</em>)(<em>x</em> ∈ <em>A</em> ∧ <em>x</em> ∈ <em>B</em>)</span></li><li>若 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 不是不相交的，就称 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 是相交的</li></ul><h4 id="特殊集合">特殊集合</h4><h5 id="空集">空集</h5><ul><li>不含任何元素的集合称为空集，记作 <span class="math inline">∅</span>，空集的定义也可以写成 <span class="math display">∅ = {<em>x</em> ∣ <em>x</em> ≠ <em>x</em>}</span></li><li>显然， $(x)(x ) $ 为真。<ul><li><span class="math inline"><em>A</em> = ∅</span> 当且仅当 <span class="math inline">{<em>x</em> ∣ <em>x</em> ≠ <em>x</em>}</span>.</li><li><span class="math inline"><em>A</em> ≠ ∅</span> 当且仅当 <span class="math inline">{<em>x</em> ∣ (∃<em>y</em>)(<em>y</em> ∈ <em>x</em>)}</span></li></ul></li><li><strong>定理</strong>：<ul><li>对于任意的集合 <span class="math inline"><em>A</em></span>，<span class="math inline">∅ ∈ <em>A</em></span></li><li>空集是唯一的</li></ul></li></ul><h5 id="全集">全集</h5><ul><li>在给定的问题中，所考虑的所有事物的集合称为全集，记作 <span class="math inline"><em>E</em></span>，全集的定义也可以写成 <span class="math display"><em>E</em> = {<em>x</em> ∣ <em>x</em> = <em>x</em>}</span></li></ul><h3 id="集合的运算">集合的运算</h3><h4 id="集合的基本运算">集合的基本运算</h4><p>对集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，</p><ul><li>并集 <span class="math inline"><em>A</em> ∪ <em>B</em></span> 定义为<span class="math display"><em>A</em> ∪ <em>B</em> = {<em>x</em> ∣ <em>x</em> ∈ <em>A</em> ∨ <em>x</em> ∈ <em>B</em>}</span></li><li>交集 <span class="math inline"><em>A</em> ∩ <em>B</em></span> 定义为<span class="math display"><em>A</em> ∩ <em>B</em> = {<em>x</em> ∣ <em>x</em> ∈ <em>A</em> ∧ <em>x</em> ∈ <em>B</em>}</span></li><li>差集（又称 <span class="math inline"><em>B</em></span> 对 <span class="math inline"><em>A</em></span> 的相对补集，补集）<span class="math inline"><em>A</em> − <em>B</em></span> 定义为 <span class="math display">$$  \begin{aligned}  A-B &amp;=\{x \mid x \in A \wedge x \notin B\} \\  &amp;= \{x \mid x \in A \wedge \neg(x \in B)\} \\  &amp;= \{x \mid x \in A \wedge x \in -B\} \\  &amp;= A \cap -B \\  &amp;= A - (A \cap B)  \end{aligned}  $$</span></li><li>余集（又称 <span class="math inline"><em>A</em></span>的绝对补集）<span class="math inline">−<em>A</em></span> 定义为 <span class="math display">−<em>A</em> = <em>E</em> − <em>A</em> = {<em>x</em> ∣ <em>x</em> ∉ <em>A</em>} = {<em>x</em> ∣ ¬(<em>x</em> ∈ <em>A</em>)}</span>其中 <span class="math inline"><em>E</em></span> 为全集，<span class="math inline"><em>A</em></span> 的余集就是 <span class="math inline"><em>A</em></span> 对 <span class="math inline"><em>E</em></span> 的相对补集</li><li>对称差 <span class="math inline"><em>A</em> ⊕ <em>B</em></span>定义为 <span class="math display">$$ A \oplus B=(A-B) \cup(B-A)=\{x \midx \in A \overline{\vee} x \in B\}$$</span></li></ul><h4 id="广义交和广义并">广义交和广义并</h4><p>若集合 <span class="math inline"><em>A</em></span>的元素都是集合，则</p><ul><li>把 <span class="math inline"><em>A</em></span>的所有元素的元素组成的集合称为 <span class="math inline"><em>A</em></span> 的<strong>广义并</strong> ，记作<span class="math inline">∪<em>A</em></span></li><li>把 <span class="math inline"><em>A</em></span>的所有元素的公共元素组成的集合称为 <span class="math inline"><em>A</em></span> 的<strong>广义交</strong> ，记作<span class="math inline">∩<em>A</em></span></li></ul><p><span class="math display">$$\begin{aligned}\cup A&amp;=\{x \mid(\exists z)(z \in A \wedge x \in z)\} \\\cap A&amp;=\{x \mid(\forall z)(z \in A \rightarrow x \in z)\}\end{aligned}$$</span></p><ul><li>此外，规定 <span class="math inline">∪∅ = ∅</span>，规定 <span class="math inline">∩∅</span> 无意义</li></ul><h4 id="幂集">幂集</h4><p>若 <span class="math inline"><em>A</em></span> 是集合，则把 <span class="math inline"><em>A</em></span> 的所有子集组成的集合称为 <span class="math inline"><em>A</em></span> 的幂集，记作 <span class="math inline"><em>P</em>(<em>A</em>)</span>，这个定义也可以写成</p><p><span class="math display"><em>P</em>(<em>A</em>) = {<em>x</em> ∣ <em>x</em> ⊆ <em>A</em>}</span></p><ul><li><strong>性质</strong>：<ul><li><span class="math inline"><em>P</em>(<em>A</em>)</span> 有 <span class="math inline">2<sup>|<em>A</em>|</sup></span> 个元素</li><li><span class="math inline">∅ ∈ <em>P</em>(<em>A</em>)</span></li><li><span class="math inline"><em>A</em> ∈ <em>P</em>(<em>A</em>)</span></li></ul></li><li><strong>例子</strong>：<ul><li><span class="math inline"><em>P</em>(∅) = {∅}</span></li><li><span class="math inline"><em>P</em>({∅}) = {∅, {∅}}</span></li><li><span class="math inline"><em>P</em>({<em>a</em>, <em>b</em>}) = {∅, {<em>a</em>}, {<em>b</em>}, {<em>a</em>, <em>b</em>}}</span></li></ul></li></ul><h4 id="笛卡尔积">笛卡尔积</h4><ul><li><strong>有序对</strong>：<ul><li><strong>定义</strong>：两个元素 <span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>y</em></span>（允许 <span class="math inline"><em>x</em> = <em>y</em></span>）按给定次序排列组成的二元组合称为一个有序对，记作<span class="math inline">⟨<em>x</em>, <em>y</em>⟩</span>，其中 <span class="math inline"><em>x</em></span> 是它的第一元素，<span class="math inline"><em>y</em></span> 是它的第二元素。</li><li><strong>性质</strong>：<ul><li><span class="math inline"><em>x</em> ≠ <em>y</em> ⇒ ⟨<em>x</em>, <em>y</em>⟩ ≠ ⟨<em>y</em>, <em>x</em>⟩</span></li><li><span class="math inline">⟨<em>x</em>, <em>y</em>⟩ = ⟨<em>u</em>, <em>v</em>⟩ ⇔ <em>x</em> = <em>u</em> ∧ <em>y</em> = <em>v</em></span></li></ul></li><li>在平面直角坐标系上一个点的坐标就是一个有序对</li><li><strong>用集合定义有序对</strong>：有序对 <span class="math inline">⟨<em>x</em>, <em>y</em>⟩</span> 定义为 <span class="math display">⟨<em>x</em>, <em>y</em>⟩ = {&nbsp;{<em>x</em>}, {<em>x</em>, <em>y</em>}&nbsp;}</span></li><li><strong>定理</strong>：<ul><li><span class="math inline">⟨<em>x</em>, <em>y</em>⟩ = ⟨<em>u</em>, <em>v</em>⟩ ⇔ <em>x</em> = <em>u</em> ∧ <em>y</em> = <em>v</em></span></li><li><span class="math inline"><em>x</em> ≠ <em>y</em> ⇒ ⟨<em>x</em>, <em>y</em>⟩ ≠ ⟨<em>y</em>, <em>x</em>⟩</span></li></ul></li></ul></li><li><strong><span class="math inline"><em>n</em></span> 元组</strong>：<ul><li><strong>定义</strong>：若 <span class="math inline"><em>n</em> ∈ ℕ</span> 且 <span class="math inline"><em>n</em> &gt; 1, <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub></span>是 <span class="math inline"><em>n</em></span> 个元素，则 <span class="math inline"><em>n</em></span> 元组 <span class="math inline">⟨<em>x</em><sub>1</sub>, ⋯, <em>x</em><sub><em>n</em></sub>⟩</span>定义为<ul><li>当 <span class="math inline"><em>n</em> = 2</span>时，二元组是有序对 <span class="math inline">⟨<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>⟩</span></li><li>当 <span class="math inline"><em>n</em> ≠ 2</span> 时，<span class="math inline">⟨<em>x</em><sub>1</sub>, ⋯, <em>x</em><sub><em>n</em></sub>⟩ = ⟨⟨<em>x</em><sub>1</sub>, ⋯, <em>x</em><sub><em>n</em> − 1</sub>⟩, <em>x</em><sub><em>n</em></sub>⟩</span></li></ul></li><li>按照这个定义，有序对就是二元组，<span class="math inline"><em>n</em></span> 元组就是多重有序对。</li></ul></li><li><strong>笛卡尔积</strong>：<ul><li><strong>定义</strong>：两个集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>的笛卡儿积（又称卡氏积、乘积、直积）<span class="math inline"><em>A</em> × <em>B</em></span> 定义为 <span class="math display">$$  \begin{aligned}  A \times B &amp;=\{z \mid x \in A \wedge y \in B \wedge z=\langlex,y\rangle\}\\  &amp;=\{\langle x,y\rangle \mid x \in A \wedge y \in B\}  \end{aligned}  $$</span></li><li>在 <span class="math inline"><em>A</em> = <em>B</em></span> 时，可把<span class="math inline"><em>A</em> × <em>A</em></span> 简写为 <span class="math inline"><em>A</em><sup>2</sup></span></li></ul></li><li><strong><span class="math inline"><em>n</em></span>阶笛卡尔积</strong>：<ul><li><strong>定义</strong>：若 <span class="math inline"><em>n</em> ∈ ℕ</span> 且 <span class="math inline"><em>n</em> &gt; 1</span>，而 <span class="math inline"><em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, ⋯, <em>A</em><sub><em>n</em></sub></span>是 <span class="math inline"><em>n</em></span> 个集合，它们的 <span class="math inline"><em>n</em></span> 阶笛卡儿积记作 <span class="math inline"><em>A</em><sub>1</sub> × <em>A</em><sub>2</sub> × ⋯ × <em>A</em><sub><em>n</em></sub></span>，并定义为<span class="math display"><em>A</em><sub>1</sub> × <em>A</em><sub>2</sub> × ⋯ × <em>A</em><sub><em>n</em></sub> = {⟨<em>x</em><sub>1</sub>, ⋯, <em>x</em><sub><em>n</em></sub>⟩ ∣ <em>x</em><sub>1</sub> ∈ <em>A</em><sub>1</sub> ∧ ⋯ ∧ <em>x</em><sub><em>n</em></sub> ∈ <em>A</em><sub><em>n</em></sub>}</span></li><li>当 <span class="math inline"><em>A</em><sub>1</sub> = <em>A</em><sub>2</sub> = ⋯ = <em>A</em><sub><em>n</em></sub></span>时，它们的 <span class="math inline"><em>n</em></span>阶笛卡儿积可以简写为 <span class="math inline"><em>A</em><sup><em>n</em></sup></span></li></ul></li></ul><h4 id="优先权">优先权</h4><table><thead><tr><th>优先级</th><th>运算符</th><th>运算符</th></tr></thead><tbody><tr><td>1</td><td>一元运算符</td><td><span class="math inline">−<em>A</em>, <em>P</em>(<em>A</em>), ∩<em>A</em>, ∪<em>A</em></span></td></tr><tr><td>2</td><td>二元运算符</td><td><span class="math inline">−, ∩, ∪, ⊕, ×</span></td></tr><tr><td>3</td><td>集合关系符</td><td><span class="math inline">=,⊆,⊂,∈</span></td></tr><tr><td>4</td><td>一元联结词</td><td><span class="math inline">¬</span></td></tr><tr><td>5</td><td>二元联结词</td><td><span class="math inline">∧, ∨, →,↔︎</span></td></tr><tr><td>6</td><td>逻辑关系符</td><td><span class="math inline">⇔,⇒</span></td></tr></tbody></table><ul><li>此外，还使用数学上惯用的括号表示优先权方法、从左到右的优先次序。规定:<ol type="1"><li>括号内的优先于括号外的；</li><li>同一层括号内，按上述优先权，</li><li>同一层括号内，同一优先级的，按从左到右的优先次序。</li></ol></li></ul><h3 id="集合的图形表示法">集合的图形表示法</h3><ul><li><strong>文氏图</strong>：集合的图形表示法通常使用<strong>维恩图/文氏图</strong>（VennDiagram）来表示集合之间的关系。<ul><li>矩形内部的点表示全集的所有元素。</li><li>在矩形内画不同的圆表示不同的集合，用圆内部的点表示相应集合的元素。</li><li>圆形的重叠来表示集合的交集、并集和差集等运算。</li></ul></li></ul><figure><img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload alt="维恩图"><figcaption aria-hidden="true">维恩图</figcaption></figure><ul><li><strong>幂集的图示法</strong>：可以用一个网络图中的各结点表示幂集的各元素。设<span class="math inline"><em>A</em> = {0, 1, 2}</span>，则 <span class="math inline"><em>P</em>(<em>A</em>)</span>的各元素如下图表示。图中结点间的连线表示二者之间有包含关系。</li></ul><figure><img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload alt="幂集的图示法"><figcaption aria-hidden="true">幂集的图示法</figcaption></figure><ul><li><strong>笛卡尔积的图示法</strong>：在平面直角坐标系上，如果用 <span class="math inline"><em>x</em></span> 轴上的线段表示集合 A，并用 <span class="math inline"><em>y</em></span> 轴上的线段表示集合 <span class="math inline"><em>B</em></span>，则由两个线段画出的矩形就可以表示笛卡儿积<span class="math inline"><em>A</em> × <em>B</em></span>，如下图所示。</li></ul><figure><img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload alt="笛卡尔积的图示法"><figcaption aria-hidden="true">笛卡尔积的图示法</figcaption></figure><h3 id="集合运算的性质和证明">集合运算的性质和证明</h3><h4 id="基本运算的性质">基本运算的性质</h4><p>对任意的集合 <span class="math inline"><em>A</em></span>，<span class="math inline"><em>B</em></span> 和 <span class="math inline"><em>C</em></span>，有</p><ul><li>交换律 <span class="math display">$$ \begin{aligned}  A \cup B=B \cup A\\  A \cap B=B \cap A  \end{aligned}$$</span></li><li>结合律 <span class="math display">$$ \begin{aligned}  (A \cup B) \cup C=A \cup(B \cup C)\\  (A \cap B) \cap C=A \cap(B \cap C)  \end{aligned}$$</span></li><li>分配律 <span class="math display">$$ \begin{aligned}  A \cup(B \cap C)=(A \cup B) \cap(A \cup C)\\  A \cap(B \cup C)=(A \cap B) \cup(A \cap C)  \end{aligned}$$</span></li><li>幂等律 <span class="math display">$$ \begin{aligned}  A \cup A=A\\  A \cap A=A  \end{aligned}$$</span></li><li>吸收律 <span class="math display">$$ \begin{aligned}  A \cup(A \cap B)=A\\  A \cap(A \cup B)=A  \end{aligned}$$</span></li><li>摩根律 <span class="math display">$$ \begin{aligned}  A-(B \cup C)&amp;=(A-B) \cap(A-C)\\  A-(B \cap C)&amp;=(A-B) \cup(A-C)\\  -(B \cup C)&amp;=-B \cap-C\\  -(B \cap C)&amp;=-B \cup-C  \end{aligned}$$</span></li><li>同一律 <span class="math display">$$ \begin{aligned}  A \cup \emptyset=A\\  A \cap E=A  \end{aligned}$$</span></li><li>零律 <span class="math display">$$ \begin{aligned}  A \cup E=E\\  A \cap \emptyset=\emptyset\\  -\emptyset=E\\  -E=\emptyset  \end{aligned}$$</span></li><li>补余律 <span class="math display">$$ \begin{aligned}  A \cup-A=E\\  A \cap-A=\emptyset  \end{aligned}$$</span></li><li>双补律 <span class="math display">−(−<em>A</em>) = <em>A</em></span></li><li><span class="math inline"><em>A</em> ∪ <em>B</em> = <em>A</em> ∪ <em>C</em>, <em>A</em> ∩ <em>B</em> = <em>A</em> ∩ <em>C</em> ⇒ <em>B</em> = <em>C</em></span></li></ul><p><strong>证明</strong>：</p><ul><li>谓词法</li><li>集合法</li></ul><h4 id="差集的性质">差集的性质</h4><p>对任意的集合 <span class="math inline"><em>A</em>, <em>B</em></span>和 <span class="math inline"><em>C</em></span>，有</p><ul><li><span class="math inline"><em>A</em> − <em>B</em> = <em>A</em> − (<em>A</em> ∩ <em>B</em>)</span></li><li><span class="math inline"><em>A</em> − <em>B</em> = <em>A</em> ∩ −<em>B</em></span></li><li><span class="math inline"><em>A</em> ∪ (<em>B</em> − <em>A</em>) = <em>A</em> ∪ <em>B</em></span></li><li><span class="math inline"><em>A</em> ∩ (<em>B</em> − <em>C</em>) = (<em>A</em> ∩ <em>B</em>) − <em>C</em></span></li></ul><h4 id="对称差的性质">对称差的性质</h4><p>对任意的集合 <span class="math inline"><em>A</em>, <em>B</em></span>和 <span class="math inline"><em>C</em></span>，有</p><ul><li>交换律 <span class="math inline"><em>A</em> ⊕ <em>B</em> = <em>B</em> ⊕ <em>A</em></span></li><li>结合律 <span class="math inline">(<em>A</em> ⊕ <em>B</em>) ⊕ <em>C</em> = <em>A</em> ⊕ (<em>B</em> ⊕ <em>C</em>)</span></li><li>分配律 <span class="math inline"><em>A</em> ∩ (<em>B</em> ⊕ <em>C</em>) = (<em>A</em> ∩ <em>B</em>) ⊕ (<em>A</em> ∩ <em>C</em>)</span></li><li>同一律 <span class="math inline"><em>A</em> ⊕ ∅ = <em>A</em></span></li><li>零律 <span class="math inline"><em>A</em> ⊕ <em>A</em> = ∅</span></li><li><span class="math inline"><em>A</em> ⊕ (<em>A</em> ⊕ <em>B</em>) = <em>B</em></span></li><li><span class="math inline">(<em>A</em> − <em>B</em>) ⊕ (<em>A</em> − <em>C</em>) = ∅</span>的充要条件是 <span class="math inline"><em>A</em> − <em>B</em> = <em>A</em> − <em>C</em></span></li></ul><h4 id="子集的性质">子集的性质</h4><p>对任意的集合 <span class="math inline"><em>A</em>, <em>B</em>, <em>C</em></span> 和 <span class="math inline"><em>D</em></span>，有</p><ul><li><span class="math inline"><em>A</em> ⊆ <em>B</em> ⇒ (<em>A</em> ∪ <em>C</em>) ⊆ (<em>B</em> ∪ <em>C</em>)</span></li><li><span class="math inline"><em>A</em> ⊆ <em>B</em> ⇒ (<em>A</em> ∩ <em>C</em>) ⊆ (<em>B</em> ∩ <em>C</em>)</span></li><li><span class="math inline">(<em>A</em> ⊆ <em>B</em>) ∧ (<em>C</em> ⊆ <em>D</em>) ⇒ (<em>A</em> ∪ <em>C</em>) ⊆ (<em>B</em> ∪ <em>D</em>)</span></li><li><span class="math inline">(<em>A</em> ⊆ <em>B</em>) ∧ (<em>C</em> ⊆ <em>D</em>) ⇒ (<em>A</em> ∩ <em>C</em>) ⊆ (<em>B</em> ∩ <em>D</em>)</span></li><li><span class="math inline">(<em>A</em> ⊆ <em>B</em>) ∧ (<em>C</em> ⊆ <em>D</em>) ⇒ (<em>A</em> − <em>D</em>) ⊆ (<em>B</em> − <em>C</em>)</span></li><li><span class="math inline"><em>C</em> ⊆ <em>D</em> ⇒ (<em>A</em> − <em>D</em>) ⊆ (<em>A</em> − <em>C</em>)</span></li></ul><h4 id="幂集合的性质">幂集合的性质</h4><p>对任意的集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，有</p><ul><li><span class="math inline"><em>A</em> ⊆ <em>B</em> ⇔ <em>P</em>(<em>A</em>) ⊆ <em>P</em>(<em>B</em>)</span></li><li><span class="math inline"><em>A</em> = <em>B</em> ⇔ <em>P</em>(<em>A</em>) = <em>P</em>(<em>B</em>)</span></li><li><span class="math inline"><em>P</em>(<em>A</em>) ∈ <em>P</em>(<em>B</em>) ⇒ <em>A</em> ∈ <em>B</em></span></li><li><span class="math inline"><em>P</em>(<em>A</em>) ∩ <em>P</em>(<em>B</em>) = <em>P</em>(<em>A</em> ∩ <em>B</em>)</span></li><li><span class="math inline"><em>P</em>(<em>A</em>) ∪ <em>P</em>(<em>B</em>) ⊆ <em>P</em>(<em>A</em> ∪ <em>B</em>)</span></li><li><span class="math inline"><em>P</em>(<em>A</em> − <em>B</em>) ⊆ (<em>P</em>(<em>A</em>) − <em>P</em>(<em>B</em>)) ∪ {∅}</span></li></ul><h4 id="传递集合及其性质">传递集合及其性质</h4><ul><li><strong>定义</strong>：如果集合的集合 <span class="math inline"><em>A</em></span> 的任一元素的元素都是 <span class="math inline"><em>A</em></span> 的元素，就称 <span class="math inline"><em>A</em></span> 为<strong>传递集合</strong> ，即<span class="math display">(∀<em>x</em>)(∀<em>y</em>)((<em>x</em> ∈ <em>y</em> ∧ <em>y</em> ∈ <em>A</em>) → <em>x</em> ∈ <em>A</em>)</span><ul><li>推论：$x A, y A $</li></ul></li><li><strong>定理</strong>：<ul><li>对集合的集合 <span class="math inline"><em>A</em></span>，<span class="math inline"><em>A</em></span> 是传递集合 <span class="math inline"> ⇔ <em>A</em> ⊆ <em>P</em>(<em>A</em>)</span></li><li>对集合的集合 <span class="math inline"><em>A</em></span>，<span class="math inline"><em>A</em></span> 是传递集合 <span class="math inline">⇔</span> <span class="math inline"><em>P</em>(<em>A</em>)</span> 是传递集合</li></ul></li></ul><h4 id="广义并和广义交的性质">广义并和广义交的性质</h4><p>对集合的集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，有</p><ul><li><span class="math inline"><em>A</em> ⊆ <em>B</em> ⇒ ∪<em>A</em> ⊆ ∪<em>B</em></span></li><li><span class="math inline"><em>A</em> ⊆ <em>B</em> ⇒ ∩<em>B</em> ⊆ ∩<em>A</em></span>，其中<span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 非空</li><li><span class="math inline">∪(<em>A</em> ∪ <em>B</em>) = (∪<em>A</em>) ∪ (∪<em>B</em>)</span></li><li><span class="math inline">∩(<em>A</em> ∪ <em>B</em>) = (∩<em>A</em>) ∩ (∩<em>B</em>)</span>，其中<span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span> 非空</li><li><span class="math inline">∪(<em>P</em>(<em>A</em>)) = <em>A</em></span></li><li>若集合 <span class="math inline"><em>A</em></span> 是传递集合，则<span class="math inline">∪<em>A</em></span> 是传递集合</li><li>若集合 <span class="math inline"><em>A</em></span>的元素都是传递集合，则 <span class="math inline">∪<em>A</em></span>是传递集合</li><li>若非空集合 <span class="math inline"><em>A</em></span>是传递集合，则 <span class="math inline">∩<em>A</em></span>是传递集合，且 <span class="math inline">∩<em>A</em> = ∅</span></li><li>若非空集合 <span class="math inline"><em>A</em></span>的元素都是传递集合，则 <span class="math inline">∩<em>A</em></span>是传递集合</li></ul><h4 id="笛卡尔积的性质">笛卡尔积的性质</h4><ul><li><span class="math inline"><em>A</em> × ∅ = ∅ × <em>B</em> = ∅</span></li><li>若 <span class="math inline"><em>A</em> ≠ ∅</span>，<span class="math inline"><em>B</em> ≠ ∅</span> 且 <span class="math inline"><em>A</em> ≠ <em>B</em></span>，则 <span class="math inline"><em>A</em> × <em>B</em> ≠ <em>B</em> × <em>A</em></span></li><li><span class="math inline"><em>A</em> × (<em>B</em> × <em>C</em>) ≠ (<em>A</em> × <em>B</em>) × <em>C</em></span></li><li>若 <span class="math inline"><em>A</em></span> 是集合，<span class="math inline"><em>x</em> ∈ <em>A</em>, <em>y</em> ∈ <em>A</em></span>，则<span class="math inline">⟨<em>x</em>, <em>y</em>⟩ ∈ <em>P</em><em>P</em>(<em>A</em>)</span>。<ul><li><span class="math inline"><em>P</em><em>P</em>(<em>A</em>)</span>表示 <span class="math inline"><em>P</em>(<em>P</em>(<em>A</em>))</span></li></ul></li><li><span class="math inline"><em>A</em> × (<em>B</em> ∪ <em>C</em>) = (<em>A</em> × <em>B</em>) ∪ (<em>A</em> × <em>C</em>)</span></li><li><span class="math inline"><em>A</em> × (<em>B</em> ∩ <em>C</em>) = (<em>A</em> × <em>B</em>) ∩ (<em>A</em> × <em>C</em>)</span></li><li><span class="math inline">(<em>B</em> ∪ <em>C</em>) × <em>A</em> = (<em>B</em> × <em>A</em>) ∪ (<em>C</em> × <em>A</em>)</span></li><li><span class="math inline">(<em>B</em> ∩ <em>C</em>) × <em>A</em> = (<em>B</em> × <em>A</em>) ∩ (<em>C</em> × <em>A</em>)</span></li><li>若 <span class="math inline"><em>C</em> ≠ ∅</span>，则 <span class="math inline">(<em>A</em> ⊆ <em>B</em>) ⇔ (<em>A</em> × <em>C</em> ⊆ <em>B</em> × <em>C</em>) ⇔ (<em>C</em> × <em>A</em> ⊆ <em>C</em> × <em>B</em>)</span></li><li>对任意的非空集合 <span class="math inline"><em>A</em>, <em>B</em>, <em>C</em></span> 和 <span class="math inline"><em>D</em></span>，有 <span class="math inline">(<em>A</em> × <em>B</em> ⊆ <em>C</em> × <em>D</em>) ⇔ (<em>A</em> ⊆ <em>C</em> ∧ <em>B</em> ⊆ <em>D</em>)</span></li></ul><h3 id="有限集合的基数">有限集合的基数</h3><ul><li><strong>定义</strong>：如果存在 <span class="math inline"><em>n</em> ∈ ℕ</span>，使集合 <span class="math inline"><em>A</em></span> 与集合 <span class="math inline">{<em>x</em> ∣ <em>x</em> ∈ ℕ ∧ <em>x</em> &lt; <em>n</em>} = {0, 1, 2, ⋯, <em>n</em> − 1}</span>的元素个数相同，就说集合 <span class="math inline"><em>A</em></span>的<strong>基数</strong> 是 <span class="math inline"><em>n</em></span>，记作 <span class="math inline">#(<em>A</em>) = <em>n</em></span> 或 <span class="math inline">|<em>A</em>| = <em>n</em></span> 或 <span class="math inline">card (<em>A</em>) = <em>n</em></span><ul><li>空集 <span class="math inline">∅</span> 的基数是 <span class="math inline">0</span></li></ul></li><li><strong>有限集合与无限集合</strong>：<ul><li>如果存在 <span class="math inline"><em>n</em> ∈ ℕ</span>，使 <span class="math inline"><em>n</em></span> 是集合 <span class="math inline"><em>A</em></span> 的基数 <span class="math inline">.</span> 就说 <span class="math inline"><em>A</em></span> 是<strong>有限集合</strong>。</li><li>如果不存在这样的 <span class="math inline"><em>n</em></span>，就说<span class="math inline"><em>A</em></span>是<strong>无限集合</strong></li></ul></li></ul><h4 id="幂集和笛卡儿积的基数">幂集和笛卡儿积的基数</h4><ul><li>对于有限集合 <span class="math inline"><em>A</em></span>，<span class="math inline">|<em>P</em>(<em>A</em>)| = 2<sup>|<em>A</em>|</sup></span></li><li>对有限集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，<span class="math inline">|<em>A</em> × <em>B</em>| = |<em>A</em>|⋅|<em>B</em>|</span></li></ul><h4 id="基本运算的基数">基本运算的基数</h4><ul><li><p>对有限集合 <span class="math inline"><em>A</em><sub>1</sub></span> 和 <span class="math inline"><em>A</em><sub>2</sub></span>，有 <span class="math display">$$  \begin{aligned}  \left|A_{1} \cup A_{2}\right| &amp;\leqslant\left|A_{1}\right|+\left|A_{2}\right| \\  \left|A_{1} \cap A_{2}\right| &amp; \leqslant \min\left(\left|A_{1}\right|,\left|A_{2}\right|\right) \\  \left|A_{1}-A_{2}\right| &amp;\geqslant\left|A_{1}\right|-\left|A_{2}\right| \\  \left|A_{1} \oplus A_{2}\right| &amp;=\left|A_{1}\right|+\left|A_{2}\right|-2\left|A_{1} \cap A_{2}\right|  \end{aligned}  $$</span></p></li><li><p><strong>排斥原理</strong>：对有限集合 <span class="math inline"><em>A</em><sub>1</sub></span> 和 <span class="math inline"><em>A</em><sub>2</sub></span>，有 <span class="math display">|<em>A</em><sub>1</sub> ∪ <em>A</em><sub>2</sub>| = |<em>A</em><sub>1</sub>| + |<em>A</em><sub>2</sub>| − |<em>A</em><sub>1</sub> ∩ <em>A</em><sub>2</sub>|</span></p><ul><li>推广到 <span class="math inline"><em>n</em></span> 个集合：若 <span class="math inline"><em>n</em> ∈ ℕ</span> 且 <span class="math inline"><em>n</em> &gt; 1, <em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, …, <em>A</em><sub><em>n</em></sub></span>是有限集合, 则 <span class="math display">$$  \begin{aligned}  |A_{1} \cup A_{2} \cup \ldots \cup A_{n}| &amp;= \sum |A_{i}| - \sum|A_{i} \cap A_{j}| + \sum |A_{i} \cap A_{j} \cap A_{k}| + \\  &amp; \cdots + (-1)^{(n - 1)}|A_{1} \cap A_{2} \cap \ldots \cap A_{n}|  \end{aligned}  $$</span></li></ul></li></ul><h2 id="第十章-关系">第十章 关系</h2><h3 id="二元关系">二元关系</h3><ul><li><strong>定义</strong>：对集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，<span class="math inline"><em>A</em> × <em>B</em></span> 的任一子集称为 <span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>B</em></span> 的一个<strong>二元关系</strong>，一般记作 <span class="math inline"><em>R</em></span>。若 <span class="math inline">⟨<em>x</em>, <em>y</em>⟩ ∈ <em>R</em></span>，可记作<span class="math inline"><em>x</em><em>R</em><em>y</em></span>；若<span class="math inline">⟨<em>x</em>, <em>y</em>⟩ ∉ <em>R</em></span>，可记作<span class="math inline"><em>x</em><em>R̸</em><em>y</em></span>。在<span class="math inline"><em>A</em> = <em>B</em></span> 时，<span class="math inline"><em>A</em> × <em>A</em></span> 的任一子集称为 <span class="math inline"><em>A</em></span>上的一个<strong>二元关系</strong>。二元关系可<strong>简称关系</strong></li><li><strong><span class="math inline"><em>n</em></span>元关系</strong>：若 <span class="math inline"><em>n</em> ∈ <em>N</em></span> 且 <span class="math inline"><em>n</em> &gt; 1, <em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, ⋯, <em>A</em><sub><em>n</em></sub></span>是 <span class="math inline"><em>n</em></span> 个集合，则 <span class="math inline"><em>A</em><sub>1</sub> × <em>A</em><sub>2</sub> × ⋯ × <em>A</em><sub><em>n</em></sub></span>的任一子集称为从 <span class="math inline"><em>A</em><sub>1</sub></span>到 <span class="math inline"><em>A</em><sub><em>n</em></sub></span>上的一个 <strong>n 元关系</strong></li><li><strong>特殊关系</strong>：对任意的集合 <span class="math inline"><em>A</em></span><ul><li><span class="math inline"><em>A</em></span>上的<strong>恒等关系</strong> <span class="math inline"><em>I</em><sub><em>A</em></sub></span> 定义为<span class="math display"><em>I</em><sub><em>A</em></sub> = {⟨<em>x</em>, <em>x</em>⟩ ∣ <em>x</em> ∈ <em>A</em>}</span></li><li><span class="math inline"><em>A</em></span>上的<strong>全域关</strong>系（全关系）<span class="math inline"><em>E</em><sub><em>A</em></sub></span> 定义为<span class="math display"><em>E</em><sub><em>A</em></sub> = {⟨<em>x</em>, <em>y</em>⟩ ∣ <em>x</em> ∈ <em>A</em> ∧ <em>y</em> ∈ <em>A</em>}</span></li><li><span class="math inline">∅</span> 是 <span class="math inline"><em>A</em></span> 上的<strong>空关系</strong></li></ul></li><li><strong>定义域和值域</strong>：对 <span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>B</em></span> 的一个关系 <span class="math inline"><em>R</em></span>，可以定义<ul><li><span class="math inline"><em>R</em></span> 的定义域 <span class="math inline">dom (<em>R</em>)</span> 为 <span class="math display">dom (<em>R</em>) = {<em>x</em> ∣ (∃<em>y</em>)(⟨<em>x</em>, <em>y</em>⟩ ∈ <em>R</em>)}</span></li><li><span class="math inline"><em>R</em></span> 的值域 <span class="math inline">ran (<em>R</em>)</span> 为 <span class="math display">ran (<em>R</em>) = {<em>y</em> ∣ (∃<em>x</em>)(⟨<em>x</em>, <em>y</em>⟩ ∈ <em>R</em>)}</span></li><li><span class="math inline"><em>R</em></span> 的域 <span class="math inline">fld (<em>R</em>)</span> 为 <span class="math display">fld (<em>R</em>) = dom (<em>R</em>) ∪ ran (<em>R</em>)</span></li></ul></li><li><strong>性质</strong>：<ul><li>对 <span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>B</em></span> 的关系 <span class="math inline"><em>R</em></span>，如果 <span class="math inline">⟨<em>x</em>, <em>y</em>⟩ ∈ <em>R</em></span>，则<span class="math display"><em>x</em> ∈ ∪ ∪ <em>R</em>, <em>y</em> ∈ ∪ ∪ <em>R</em></span></li><li>对 <span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>B</em></span> 的关系 <span class="math inline"><em>R</em></span>，则 <span class="math display">fld (<em>R</em>) = ∪ ∪ <em>R</em></span></li></ul></li></ul><h3 id="关系矩阵和关系图">关系矩阵和关系图</h3><h4 id="关系矩阵">关系矩阵</h4><p>设集合 <span class="math inline"><em>X</em> = {<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>m</em></sub>}, <em>Y</em> = {<em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>, ⋯, <em>y</em><sub><em>n</em></sub>}</span></p><ul><li><strong>定义</strong>：<ul><li><p>若 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>X</em></span> 到 <span class="math inline"><em>Y</em></span> 的一个关系，则 <span class="math inline"><em>R</em></span> 的关系矩阵是 <span class="math inline"><em>m</em> × <em>n</em></span> 矩阵 <span class="math display"><em>M</em>(<em>R</em>) = (<em>r</em><sub><em>i</em><em>j</em></sub>)<sub><em>m</em> × <em>n</em></sub></span></p><p>矩阵元素是 <span class="math inline"><em>r</em><sub><em>i</em><em>j</em></sub></span>，且<span class="math display">$$ r_{i j}=\left\{\begin{array}{ll} 1,&amp;\mathrm{当}\left\langle x_{i},y_{j}\right\rangle \in R \\ 0,&amp;\mathrm{当}\left\langle x_{i},y_{j}\right\rangle \notin R\end{array}\right.$$</span></p><p>其中 <span class="math inline">1 ≤ <em>i</em> ≤ <em>m</em>, 1 ≤ <em>j</em> ≤ <em>n</em></span></p></li><li><p>若 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>X</em></span> 上的一个关系，则 <span class="math inline"><em>R</em></span> 的关系矩阵是 <span class="math inline"><em>m</em> × <em>m</em></span> 方阵（<span class="math inline"><em>m</em></span> 行、<span class="math inline"><em>m</em></span> 列的矩阵） <span class="math display"><em>M</em>(<em>R</em>) = (<em>r</em><sub><em>i</em><em>j</em></sub>)<sub><em>m</em> × <em>m</em></sub></span></p><p>矩阵元素是 <span class="math inline"><em>r</em><sub><em>i</em><em>j</em></sub></span>，且</p><p><span class="math display">$$ r_{i j}=\left\{\begin{array}{ll}1,&amp; \mathrm{当}\left\langle x_{i},x_{j}\right\rangle \in R \\0,&amp; \mathrm{当}\left\langle x_{i},x_{j}\right\rangle \notin R\end{array}\right.$$</span></p><p>其中 <span class="math inline">1 ≤ <em>i</em> ≤ <em>m</em>, 1 ≤ <em>j</em> ≤ <em>m</em></span></p></li></ul></li><li><span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>B</em></span> 的关系 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em> × <em>B</em></span> 的子集，<span class="math inline"><em>A</em> × <em>B</em></span> 有 <span class="math inline"><em>m</em> × <em>n</em></span> 个有序对，矩阵 <span class="math inline"><em>M</em>(<em>R</em>)</span> 有 <span class="math inline"><em>m</em></span> 行、<span class="math inline"><em>n</em></span> 列，共有 <span class="math inline"><em>m</em> × <em>n</em></span> 个元素， <span class="math inline"><em>M</em>(<em>R</em>)</span> 的每个元素恰好对应<span class="math inline"><em>A</em> × <em>B</em></span>的一个有序对。用 <span class="math inline"><em>M</em>(<em>R</em>)</span>中元素 <span class="math inline"><em>r</em><sub><em>i</em><em>j</em></sub></span>的值表示有序对 <span class="math inline">⟨<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>⟩</span>是否在 <span class="math inline"><em>R</em></span> 中，因为只有 <span class="math inline">∈</span> 和 <span class="math inline">∉</span>两种情况，所以 <span class="math inline"><em>r</em><sub><em>i</em><em>j</em></sub></span>只取值 <span class="math inline">0</span> 和 <span class="math inline">1</span> 是合理的。</li></ul><h4 id="关系图">关系图</h4><p>设集合 <span class="math inline"><em>X</em> = {<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>m</em></sub>}</span>，<span class="math inline"><em>Y</em> = {<em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>, ⋯, <em>y</em><sub><em>n</em></sub>}</span></p><ul><li><strong>定义</strong><ul><li>若 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>X</em></span> 到 <span class="math inline"><em>Y</em></span> 的一个关系，则 <span class="math inline"><em>R</em></span> 的关系图是一个有向图 <span class="math inline"><em>G</em>(<em>R</em>) = ⟨<em>V</em>, <em>E</em>⟩</span>，它的顶点集是<span class="math inline"><em>V</em> = <em>X</em> ∪ <em>Y</em></span>，边集是<span class="math inline"><em>E</em></span>，从 <span class="math inline"><em>x</em><sub><em>i</em></sub></span> 到 <span class="math inline"><em>y</em><sub><em>j</em></sub></span> 的有向边<span class="math inline"><em>e</em><sub><em>i</em><em>j</em></sub> ∈ <em>E</em></span>，当且仅当<span class="math inline">⟨<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>⟩ ∈ <em>R</em></span></li><li>若 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>X</em></span> 上的一个关系，则 <span class="math inline"><em>R</em></span> 的关系图是一个有向图 <span class="math inline"><em>G</em>(<em>R</em>) = ⟨<em>V</em>, <em>E</em>⟩</span>，它的顶点集是<span class="math inline"><em>V</em> = <em>X</em></span>，边集是 <span class="math inline"><em>E</em></span>，从 <span class="math inline"><em>x</em><sub><em>i</em></sub></span> 到 <span class="math inline"><em>x</em><sub><em>j</em></sub></span> 的有向边<span class="math inline"><em>e</em><sub><em>i</em><em>j</em></sub> ∈ <em>E</em></span>当且仅当 <span class="math inline">⟨<em>x</em><sub><em>i</em></sub>, <em>x</em><sub><em>j</em></sub>⟩ ∈ <em>R</em></span></li></ul></li><li>关系图中一条有向边 <span class="math inline"><em>e</em><sub><em>i</em><em>j</em></sub></span> 与<span class="math inline"><em>R</em></span> 中的一个有序对 <span class="math inline">⟨<em>x</em><sub><em>i</em></sub>, <em>x</em><sub><em>j</em></sub>⟩</span>一一对应</li></ul><h3 id="关系的逆合成限制和象">关系的逆、合成、限制和象</h3><ul><li>对 <span class="math inline"><em>X</em></span> 到 <span class="math inline"><em>Y</em></span> 的关系 <span class="math inline"><em>R</em></span>，<span class="math inline"><em>Y</em></span> 到 <span class="math inline"><em>Z</em></span> 的关系 <span class="math inline"><em>S</em></span>，<strong>定义</strong>：<ul><li><span class="math inline"><em>R</em></span> 的<strong>逆</strong><span class="math inline"><em>R</em><sup>−1</sup></span> 为 <span class="math inline"><em>Y</em></span> 到 <span class="math inline"><em>X</em></span> 的关系 <span class="math display"><em>R</em><sup>−1</sup> = {⟨<em>x</em>, <em>y</em>⟩ ∣ ⟨<em>y</em>, <em>x</em>⟩ ∈ <em>R</em>}</span></li><li><span class="math inline"><em>R</em></span> 与 <span class="math inline"><em>S</em></span> 的<strong>合成</strong> <span class="math inline"><em>S</em> ∘ <em>R</em></span> 为 <span class="math inline"><em>X</em></span> 到 <span class="math inline"><em>Z</em></span> 的关系 <span class="math display"><em>S</em> ∘ <em>R</em> = {⟨<em>x</em>, <em>y</em>⟩ ∣ (∃<em>z</em>)(⟨<em>x</em>, <em>z</em>⟩ ∈ <em>R</em> ∧ ⟨<em>z</em>, <em>y</em>⟩ ∈ <em>S</em>)}</span></li></ul></li><li>对任意的集合 <span class="math inline"><em>A</em></span><strong>定义</strong>：<ul><li><span class="math inline"><em>R</em></span> 在 <span class="math inline"><em>A</em></span> 上的<strong>限制</strong> <span class="math inline"><em>R</em> ↾ <em>A</em></span> 为 <span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>Y</em></span> 的关系 <span class="math display"><em>R</em> ↾ <em>A</em> = {⟨<em>x</em>, <em>y</em>⟩ ∣ ⟨<em>x</em>, <em>y</em>⟩ ∈ <em>R</em> ∧ <em>x</em> ∈ <em>A</em>}</span></li><li><span class="math inline"><em>A</em></span> 在 <span class="math inline"><em>R</em></span> 下的<strong>象</strong> <span class="math inline"><em>R</em>[<em>A</em>]</span> 为集合 <span class="math display"><em>R</em>[<em>A</em>] = {<em>y</em> ∣ (∃<em>x</em>)(<em>x</em> ∈ <em>A</em> ∧ ⟨<em>x</em>, <em>y</em>⟩ ∈ <em>R</em>)}</span></li></ul></li></ul><h4 id="合成的关系矩阵">合成的关系矩阵</h4><ul><li><p><span class="math inline"><em>R</em><sup>−1</sup></span>的关系矩阵 <span class="math inline"><strong>M</strong>(<em>R</em><sup>−1</sup>)</span>就是 <span class="math inline"><em>R</em></span>的关系矩阵的<strong>转置矩阵</strong></p></li><li><p><span class="math inline"><em>S</em> ∘ <em>R</em></span>的关系矩阵就是 <span class="math inline"><em>R</em></span>的关系矩阵左乘 <span class="math inline"><em>S</em></span> 的关系矩阵<span class="math display"><em>M</em>(<em>S</em> ∘ <em>R</em>) = <em>M</em>(<em>R</em>)<em>M</em>(<em>S</em>)</span></p><p>其中 <span class="math display">$$ w_{ij}=\bigvee_{k=1}^{n}\left(r_{i k} \wedge s_{kj}\right)$$</span></p></li></ul><h4 id="关系的运算的性质">关系的运算的性质</h4><ul><li>对 <span class="math inline"><em>X</em></span> 到 <span class="math inline"><em>Y</em></span> 的关系 <span class="math inline"><em>R</em></span> 和 <span class="math inline"><em>Y</em></span> 到 <span class="math inline"><em>Z</em></span> 的关系 <span class="math inline"><em>S</em></span>，则 <span class="math display">$$  \begin{aligned}  \operatorname{dom}\left(R^{-1}\right) &amp;=\operatorname{ran}(R)\\  \operatorname{ran}\left(R^{-1}\right)&amp;=\operatorname{dom}(R)\\  \left(R^{-1}\right)^{-1}&amp;=R\\  (S \circ R)^{-1}&amp;=R^{-1} \circ S^{-1}  \end{aligned}  $$</span></li><li>对 <span class="math inline"><em>X</em></span> 到 <span class="math inline"><em>Y</em></span> 的关系 <span class="math inline"><em>Q</em></span>，<span class="math inline"><em>Y</em></span> 到 <span class="math inline"><em>Z</em></span> 的关系 <span class="math inline"><em>S</em></span>，<span class="math inline"><em>Z</em></span> 到 <span class="math inline"><em>W</em></span> 的关系 <span class="math inline"><em>R</em></span>，则 <span class="math display">(<em>R</em> ∘ <em>S</em>) ∘ <em>Q</em> = <em>R</em> ∘ (<em>S</em> ∘ <em>Q</em>)</span></li><li>对 <span class="math inline"><em>X</em></span> 到 <span class="math inline"><em>Y</em></span> 的关系 <span class="math inline"><em>R</em><sub>2</sub></span> 和 <span class="math inline"><em>R</em><sub>3</sub></span>，<span class="math inline"><em>Y</em></span> 到 <span class="math inline"><em>Z</em></span> 的关系 <span class="math inline"><em>R</em><sub>1</sub></span>，有 <span class="math display">$$  \begin{aligned}  R_{1} \circ\left(R_{2} \cup R_{3}\right) &amp;=R_{1} \circ R_{2} \cupR_{1} \circ R_{3}\\  R_{1} \circ\left(R_{2} \cap R_{3}\right) &amp;\subseteq R_{1} \circR_{2} \cap R_{1} \circ R_{3}  \end{aligned}  $$</span></li><li>对 <span class="math inline"><em>X</em></span> 到 <span class="math inline"><em>Y</em></span> 的关系 <span class="math inline"><em>R</em><sub>3</sub></span>，<span class="math inline"><em>Y</em></span> 到 <span class="math inline"><em>Z</em></span> 的关系 <span class="math inline"><em>R</em><sub>1</sub></span>、<span class="math inline"><em>R</em><sub>2</sub></span>，有 <span class="math display">$$  \begin{aligned}  \left(R_{1} \cup R_{2}\right) \circ R_{3} &amp;=R_{1} \circ R_{3} \cupR_{2} \circ R_{3}\\  \left(R_{1} \cap R_{2}\right) \circ R_{3} &amp;\subseteq R_{1} \circR_{3} \cap R_{2} \circ R_{3}  \end{aligned}  $$</span></li><li>对 <span class="math inline"><em>X</em></span> 到 <span class="math inline"><em>Y</em></span> 的关系 <span class="math inline"><em>R</em></span> 和集合 <span class="math inline"><em>A</em></span>，<span class="math inline"><em>B</em></span>，有 <span class="math display">$$  \begin{aligned}  R[A \cup B] &amp;=R[A] \cup R[B]\\  R[\cup A] &amp;=\cup\{R[B] \mid B \in A\}\\  R[A \cap B] &amp;\subseteq R[A] \cap R[B]\\  R[\cap A] &amp;\subseteq \cap\{R[B] \mid B \in A\}\ (A \neq\emptyset)\\  R[A]-R[B] &amp;\subseteq R[A-B]  \end{aligned}  $$</span></li></ul><h3 id="关系的性质">关系的性质</h3><h4 id="自反性">自反性</h4><ul><li><strong>定义</strong>：对 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em></span>，若对任意的 <span class="math inline"><em>x</em> ∈ <em>A</em></span> 都有 <span class="math inline"><em>x</em><em>R</em><em>x</em></span>，则称 <span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上<strong>自反</strong>的关系；若对任意的 <span class="math inline"><em>x</em> ∈ <em>A</em></span> 都有 <span class="math inline"><em>x</em><em>R̸</em><em>x</em></span>，则称 <span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上<strong>非自反</strong>的关系。</li><li><strong>数学形式</strong>：<ul><li><span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上自反的 <span class="math inline"> ⇔ (∀<em>x</em>)(<em>x</em> ∈ <em>A</em> → <em>x</em><em>R</em><em>x</em>)</span></li><li><span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上非自反的 <span class="math inline"> ⇔ (∀<em>x</em>)(<em>x</em> ∈ <em>A</em> → <em>x</em><em>R̸</em><em>x</em>)</span></li></ul></li><li>性质：<ul><li>在非空集合 <span class="math inline"><em>A</em></span> 上的恒等关系<span class="math inline"><em>I</em><sub><em>A</em></sub></span>和全关系 <span class="math inline"><em>E</em><sub><em>A</em></sub></span>都是自反的</li><li>在非空集合 <span class="math inline"><em>A</em></span> 上的空关系<span class="math inline">∅</span> 是非自反的</li><li>在集合 <span class="math inline">ℕ</span> 上的小于关系 <span class="math inline">&lt;</span> 是非自反的</li><li>在集合 <span class="math inline"><em>A</em></span> 的幂集 <span class="math inline"><em>P</em>(<em>A</em>)</span> 上的真包含关系 <span class="math inline">⫋</span> 是非自反的</li><li>如果 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上自反的，则关系矩阵 <span class="math inline"><em>M</em>(<em>R</em>)</span> 的主对角线元素都是<span class="math inline">1</span>（即 <span class="math inline"><em>r</em><sub><em>i</em><em>i</em></sub></span>都是 <span class="math inline">1</span>），关系图 <span class="math inline"><em>G</em>(<em>R</em>)</span>的每个顶点都有自圈</li><li>如果 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上非自反的，则 <span class="math inline"><em>M</em>(<em>R</em>)</span> 的主对角线元素都是<span class="math inline">0</span>，<span class="math inline"><em>G</em>(<em>R</em>)</span>的每个顶点都没有自圈</li></ul></li><li>三种状态：<ul><li>自反</li><li>非自反</li><li>既不是自反也不是非自反</li></ul></li></ul><h4 id="对称性">对称性</h4><ul><li><strong>定义</strong>：对 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em></span>，对任意的 <span class="math inline"><em>x</em>, <em>y</em> ∈ <em>A</em></span>，若 <span class="math inline"><em>x</em><em>R</em><em>y</em> → <em>y</em><em>R</em><em>x</em></span>，则称<span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上<strong>对称</strong> 的关系；若<span class="math inline">(<em>x</em><em>R</em><em>y</em> ∧ <em>y</em><em>R</em><em>x</em>) → (<em>x</em> = <em>y</em>)</span>，则称<span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上<strong>反对称</strong>的关系。</li><li><strong>数学形式</strong>：<ul><li><span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上对称的 <span class="math inline"> ⇔ (∀<em>x</em>)(∀<em>y</em>)((<em>x</em> ∈ <em>A</em> ∧ <em>y</em> ∈ <em>A</em> ∧ <em>x</em><em>R</em><em>y</em>) → <em>y</em><em>R</em><em>x</em>)</span></li><li><span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上反对称的 <span class="math inline"> ⇔ (∀<em>x</em>)(∀<em>y</em>)((<em>x</em> ∈ <em>A</em> ∧ <em>y</em> ∈ <em>A</em> ∧ <em>x</em><em>R</em><em>y</em> ∧ <em>y</em><em>R</em><em>x</em>) → <em>x</em> = <em>y</em>)</span></li><li><span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上反对称的 <span class="math inline"> ⇔ (∀<em>x</em>)(∀<em>y</em>)((<em>x</em> ∈ <em>A</em> ∧ <em>y</em> ∈ <em>A</em> ∧ <em>x</em><em>R</em><em>y</em> ∧ <em>x</em> ≠ <em>y</em>) → <em>y</em><em>R̸</em><em>x</em>)</span></li></ul></li><li><strong>性质</strong>：<ul><li>在非空集合 <span class="math inline"><em>A</em></span>上的全关系是对称的，不是反对称的</li><li>在 <span class="math inline"><em>B</em> = {<em>x</em> ∣ <em>x</em> ∈ ℕ ∧ <em>x</em> ≠ 0}</span>上的整除关系、小于等于关系、小于关系都是反对称的，且不是对称的</li><li>在非空集合 <span class="math inline"><em>A</em></span>上的恒等关系和空关系都是对称的，也都是反对称的</li><li>如果 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上对称的，则 <span class="math inline"><em>M</em>(<em>R</em>)</span> 是对称矩阵（对任意的<span class="math inline"><em>i</em></span> 和 <span class="math inline"><em>j</em></span>，<span class="math inline"><em>r</em><sub><em>i</em><em>j</em></sub> = <em>r</em><sub><em>j</em><em>i</em></sub></span>），<span class="math inline"><em>G</em>(<em>R</em>)</span>中任意两个顶点之间或者没有有向边，或者互有有向边 <span class="math inline"><em>e</em><sub><em>i</em><em>j</em></sub></span> 和<span class="math inline"><em>e</em><sub><em>j</em><em>i</em></sub></span></li><li>如果 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上反对称的，则 <span class="math inline"><em>M</em>(<em>R</em>)</span> 是反对称矩阵（对任意的<span class="math inline"><em>i</em> ≠ <em>j</em></span>，若 <span class="math inline"><em>r</em><sub><em>i</em><em>j</em></sub> = 1</span>则 <span class="math inline"><em>r</em><sub><em>j</em><em>i</em></sub> = 0</span>），<span class="math inline"><em>G</em>(<em>R</em>)</span>中任意两个顶点之间或者没有有向边，或者仅有一条有向边</li></ul></li><li>四种状态：<ul><li>对称</li><li>反对称</li><li>既不是对称也不是反对称</li><li>既是对称也是反对称</li></ul></li></ul><h4 id="传递性">传递性</h4><ul><li><strong>定义</strong>：<span class="math inline"><em>R</em></span>为 <span class="math inline"><em>A</em></span> 上的关系，对任意的 <span class="math inline"><em>x</em>, <em>y</em>, <em>z</em> ∈ <em>A</em></span>，若<span class="math inline">(<em>x</em><em>R</em><em>y</em> ∧ <em>y</em><em>R</em><em>z</em>) → <em>x</em><em>R</em><em>z</em></span>，则称<span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上<strong>传递</strong>的关系。</li><li><strong>数学形式</strong>：<ul><li><span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上传递的 <span class="math inline"> ⇔ (∀<em>x</em>)(∀<em>y</em>)(∀<em>z</em>)((<em>x</em> ∈ <em>A</em> ∧ <em>y</em> ∈ <em>A</em> ∧ <em>z</em> ∈ <em>A</em> ∧ <em>x</em><em>R</em><em>y</em> ∧ <em>y</em><em>R</em><em>z</em>) → <em>x</em><em>R</em><em>z</em>)</span></li></ul></li><li><strong>性质</strong>：<ul><li>在集合 <span class="math inline"><em>A</em></span>上的全关系、恒等关系、空关系都是传递的</li><li>在 <span class="math inline"><em>B</em> = {<em>x</em> ∣ <em>x</em> ∈ ℕ ∧ <em>x</em> ≠ 0}</span>上的整除关系、小于等于关系、小于关系都是传递的</li></ul></li><li>两种状态：<ul><li>传递</li><li>非传递</li></ul></li></ul><h4 id="相关性质">相关性质</h4><ul><li>若 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub></span>是集合 <span class="math inline"><em>A</em></span> 上自反的关系，则<span class="math inline"><em>R</em><sub>1</sub><sup>−1</sup>, <em>R</em><sub>1</sub> ∩ <em>R</em><sub>2</sub>, <em>R</em><sub>1</sub> ∪ <em>R</em><sub>2</sub>, <em>R</em><sub>1</sub> ∘ <em>R</em><sub>2</sub></span>也是 <span class="math inline"><em>A</em></span> 上自反的关系<ul><li>若 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub></span>是不同集合上的自反关系，则 <span class="math inline"><em>R</em><sub>1</sub> ∩ <em>R</em><sub>2</sub>, <em>R</em><sub>1</sub> ∘ <em>R</em><sub>2</sub></span>的自反性不一定成立</li></ul></li><li>若 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub></span>是集合 <span class="math inline"><em>A</em></span> 上对称的关系，则<span class="math inline"><em>R</em><sub>1</sub><sup>−1</sup>, <em>R</em><sub>1</sub> ∩ <em>R</em><sub>2</sub>, <em>R</em><sub>1</sub> ∪ <em>R</em><sub>2</sub></span>也是 <span class="math inline"><em>A</em></span> 上对称的关系<ul><li><span class="math inline"><em>R</em><sub>1</sub> ∘ <em>R</em><sub>2</sub></span>不一定是对称的</li></ul></li><li>若 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub></span>是集合 <span class="math inline"><em>A</em></span> 上传递的关系，则<span class="math inline"><em>R</em><sub>1</sub><sup>−1</sup>, <em>R</em><sub>1</sub> ∩ <em>R</em><sub>2</sub></span>是 <span class="math inline"><em>A</em></span> 上传递的关系<ul><li><span class="math inline"><em>R</em><sub>1</sub> ∪ <em>R</em><sub>2</sub>, <em>R</em><sub>1</sub> ∘ <em>R</em><sub>2</sub></span>不一定是传递的</li></ul></li><li>若 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub></span>是集合 <span class="math inline"><em>A</em></span> 上反对称的关系，则<span class="math inline"><em>R</em><sub>1</sub><sup>−1</sup>, <em>R</em><sub>1</sub> ∩ <em>R</em><sub>2</sub></span>是 <span class="math inline"><em>A</em></span> 上反对称的关系<ul><li><span class="math inline"><em>R</em><sub>1</sub> ∪ <em>R</em><sub>2</sub>, <em>R</em><sub>1</sub> ∘ <em>R</em><sub>2</sub></span>不一定是反对称的</li></ul></li><li>对 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em></span>，有<ul><li><span class="math inline"><em>R</em></span> 是对称的 <span class="math inline"> ⇔ <em>R</em> = <em>R</em><sup>−1</sup></span></li><li><span class="math inline"><em>R</em></span> 是反对称的 <span class="math inline"> ⇔ <em>R</em> ∩ <em>R</em><sup>−1</sup> ⊆ <em>I</em><sub><em>A</em></sub></span></li></ul></li></ul><h3 id="关系的闭包">关系的闭包</h3><h4 id="多个关系的合成">多个关系的合成</h4><ul><li><strong>关系 <span class="math inline"><em>R</em></span> 的 <span class="math inline"><em>n</em></span> 次幂 <span class="math inline"><em>R</em><sup><em>n</em></sup></span>定义</strong>：对 <span class="math inline"><em>A</em></span> 上的关系<span class="math inline"><em>R</em></span>，<span class="math inline"><em>n</em> ∈ ℕ</span>，关系 <span class="math inline"><em>R</em></span> 的 <span class="math inline"><em>n</em></span> 次幂 <span class="math inline"><em>R</em><sup><em>n</em></sup></span> 定义如下：<ul><li><span class="math inline"><em>R</em><sup>0</sup> = ⟨<em>x</em>, <em>x</em>⟩ ∣ <em>x</em> ∈ <em>A</em> = <em>I</em><sub><em>A</em></sub></span></li><li><span class="math inline"><em>R</em><sup><em>n</em> + 1</sup> = <em>R</em><sup><em>n</em></sup> ∘ <em>R</em>  (<em>n</em> ≥ 0)</span></li></ul></li><li><strong>性质</strong>：<ul><li>设 <span class="math inline"><em>A</em></span> 是有限集合，<span class="math inline">|<em>A</em>| = <em>n</em></span>，<span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上的关系，则存在自然数 <span class="math inline"><em>s</em></span> 和 <span class="math inline"><em>t</em></span>，<span class="math inline"><em>s</em> ≠ <em>t</em></span>，使得 <span class="math inline"><em>R</em><sup><em>s</em></sup> = <em>R</em><sup><em>t</em></sup></span></li><li>设 <span class="math inline"><em>A</em></span> 是有限集合，<span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上的关系，<span class="math inline"><em>m</em></span> 和 <span class="math inline"><em>n</em></span> 是非零自然数，则<ul><li><span class="math inline"><em>R</em><sup><em>m</em></sup> ∘ <em>R</em><sup><em>n</em></sup> = <em>R</em><sup><em>m</em> + <em>n</em></sup></span></li><li><span class="math inline">(<em>R</em><sup><em>m</em></sup>)<sup><em>n</em></sup> = <em>R</em><sup><em>m</em><em>n</em></sup></span></li></ul></li><li>设 <span class="math inline"><em>A</em></span> 是有限集合，<span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上的关系，若存在自然数 <span class="math inline"><em>s</em></span> 和 <span class="math inline"><em>t</em></span>，<span class="math inline"><em>s</em> &lt; <em>t</em></span>，使得 <span class="math inline"><em>R</em><sup><em>s</em></sup> = <em>R</em><sup><em>t</em></sup></span>，则<ul><li><span class="math inline"><em>R</em><sup><em>s</em> + <em>k</em></sup> = <em>R</em><sup><em>t</em> + <em>k</em></sup></span>，其中<span class="math inline"><em>k</em></span> 为自然数；</li><li><span class="math inline"><em>R</em><sup><em>s</em> + <em>k</em><em>p</em> + <em>i</em></sup> = <em>R</em><sup><em>s</em> + <em>i</em></sup></span>，<span class="math inline"><em>k</em></span> 和 <span class="math inline"><em>i</em></span> 为自然数，<span class="math inline"><em>p</em> = <em>t</em> − <em>s</em></span></li><li>令 <span class="math inline"><em>B</em> = {<em>R</em><sup>0</sup>, <em>R</em><sup>1</sup>, ⋯, <em>R</em><sup><em>t</em> − 1</sup>}</span>，则<span class="math inline"><em>R</em></span> 的各次幂均为 <span class="math inline"><em>B</em></span> 的元素，即对任意的自然数 <span class="math inline"><em>q</em></span>，有 <span class="math inline"><em>R</em><sup><em>q</em></sup> ∈ <em>B</em></span></li></ul></li></ul></li></ul><h4 id="闭包的定义">闭包的定义</h4><ul><li><strong>定义</strong>：<ul><li>对非空集合 <span class="math inline"><em>A</em></span> 上的关系<span class="math inline"><em>R</em></span>，如果有 <span class="math inline"><em>A</em></span> 上另一个关系 <span class="math inline"><em>R</em><sup>′</sup></span> 满足：<ul><li><span class="math inline"><em>R</em><sup>′</sup></span>是自反的（对称的，传递的）</li><li><span class="math inline"><em>R</em> ⊆ <em>R</em><sup>′</sup></span></li><li>对 <span class="math inline"><em>A</em></span>上任何自反的（对称的，传递的）关系 <span class="math inline"><em>R</em><sup>′′</sup></span> <span class="math display"><em>R</em> ⊆ <em>R</em><sup>′′</sup> → <em>R</em><sup>′</sup> ⊆ <em>R</em><sup>′′</sup></span></li></ul></li><li>则称关系 <span class="math inline"><em>R</em><sup>′</sup></span> 为<span class="math inline"><em>R</em></span>的自反（对称，传递）闭包，记作 <span class="math inline"><em>r</em>(<em>R</em>)</span>（<span class="math inline"><em>s</em>(<em>R</em>), <em>t</em>(<em>R</em>)</span>）</li></ul></li><li>直观上说：<ul><li><strong>自反闭包</strong> <span class="math inline"><em>r</em>(<em>R</em>)</span> 是有自反性的 <span class="math inline"><em>R</em></span> 的“最小”超集合</li><li><strong>对称闭包</strong> <span class="math inline"><em>s</em>(<em>R</em>)</span> 是有对称性的 <span class="math inline"><em>R</em></span> 的“最小”超集合</li><li><strong>传递闭包</strong> <span class="math inline"><em>t</em>(<em>R</em>)</span> 是有传递性的 <span class="math inline"><em>R</em></span> 的“最小”超集合</li></ul></li></ul><h4 id="必闭包性质">必闭包性质</h4><ul><li>对非空集合 <span class="math inline"><em>A</em></span> 上的关系<span class="math inline"><em>R</em></span>，有<ul><li><span class="math inline"><em>R</em></span> 是自反的 <span class="math inline"> ⇔ <em>r</em>(<em>R</em>) = <em>R</em></span></li><li><span class="math inline"><em>R</em></span> 是对称的 <span class="math inline"> ⇔ <em>s</em>(<em>R</em>) = <em>R</em></span></li><li><span class="math inline"><em>R</em></span> 是传递的 <span class="math inline"> ⇔ <em>t</em>(<em>R</em>) = <em>R</em></span></li></ul></li><li>对非空集合 <span class="math inline"><em>A</em></span> 上的关系<span class="math inline"><em>R</em><sub>1</sub></span>，<span class="math inline"><em>R</em><sub>2</sub></span>，若 <span class="math inline"><em>R</em><sub>1</sub> ⊆ <em>R</em><sub>2</sub></span>，则<ul><li><span class="math inline"><em>r</em>(<em>R</em><sub>1</sub>) ⊆ <em>r</em>(<em>R</em><sub>2</sub>)</span></li><li><span class="math inline"><em>s</em>(<em>R</em><sub>1</sub>) ⊆ <em>s</em>(<em>R</em><sub>2</sub>)</span></li><li><span class="math inline"><em>t</em>(<em>R</em><sub>1</sub>) ⊆ <em>t</em>(<em>R</em><sub>2</sub>)</span></li></ul></li><li>对非空集合 <span class="math inline"><em>A</em></span> 上的关系<span class="math inline"><em>R</em><sub>1</sub></span>、<span class="math inline"><em>R</em><sub>2</sub></span>，则<ul><li><span class="math inline"><em>r</em>(<em>R</em><sub>1</sub>) ∪ <em>r</em>(<em>R</em><sub>2</sub>) = <em>r</em>(<em>R</em><sub>1</sub> ∪ <em>R</em><sub>2</sub>)</span></li><li><span class="math inline"><em>s</em>(<em>R</em><sub>1</sub>) ∪ <em>s</em>(<em>R</em><sub>2</sub>) = <em>s</em>(<em>R</em><sub>1</sub> ∪ <em>R</em><sub>2</sub>)</span></li><li><span class="math inline"><em>t</em>(<em>R</em><sub>1</sub>) ∪ <em>t</em>(<em>R</em><sub>2</sub>) ⊆ <em>t</em>(<em>R</em><sub>1</sub> ∪ <em>R</em><sub>2</sub>)</span></li></ul></li></ul><h4 id="闭包的构造">闭包的构造</h4><ul><li>对非空集合 <span class="math inline"><em>A</em></span> 上的关系<span class="math inline"><em>R</em></span>，有 <span class="math display">$$  \begin{aligned}  r(R)&amp;=R \cup R^{0} \\  s(R)&amp;=R \cup R^{-1} \\  t(R)&amp;=R \cup R^{2} \cup R^{3} \cup \cdots  \end{aligned}  $$</span></li><li>设 <span class="math inline"><em>A</em></span> 为非空有限集合，<span class="math inline">|<em>A</em>| = <em>n</em></span>，<span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上的关系，则存在一个正整数 <span class="math inline"><em>k</em> ≤ <em>n</em></span>，使得 <span class="math display"><em>t</em>(<em>R</em>) = <em>R</em><sup>+</sup> = <em>R</em> ∪ <em>R</em><sup>2</sup> ∪ ⋯ ∪ <em>R</em><sup><em>k</em></sup></span></li><li><strong>Warshall 算法</strong>：令 <span class="math inline"><em>B</em>[<em>j</em>, <em>i</em>]</span> 表示矩阵<span class="math inline"><em>B</em></span> 第 <span class="math inline"><em>j</em></span> 行第 <span class="math inline"><em>i</em></span> 列的元素：<ol type="1"><li>令矩阵 <span class="math inline"><strong>B</strong> = <strong>M</strong>(<em>R</em>)</span></li><li>令 <span class="math inline"><em>i</em> = 1</span>，<span class="math inline"><em>n</em> = |<em>A</em>|</span></li><li>对 <span class="math inline">1 ≤ <em>j</em> ≤ <em>n</em></span>，如果 <span class="math inline"><strong>B</strong>[<em>j</em>, <em>i</em>] = 1</span>，则对<span class="math inline">1 ≤ <em>k</em> ≤ <em>n</em></span>，令 <span class="math display"><strong>B</strong>[<em>j</em>, <em>k</em>] = <strong>B</strong>[<em>j</em>, <em>k</em>] ∨ <strong>B</strong>[<em>i</em>, <em>k</em>]</span></li><li><span class="math inline"><em>i</em></span> 加 <span class="math inline">1</span>，</li><li>若 <span class="math inline"><em>i</em> ≤ <em>n</em></span>，则转到<span class="math inline">(3)</span>，否则停止，且 <span class="math display"><em>M</em>(<em>R</em><sup>+</sup>) = <strong>B</strong></span></li></ol></li><li>对非空集合 <span class="math inline"><em>A</em></span> 上的关系<span class="math inline"><em>R</em></span>，有<ul><li>若 <span class="math inline"><em>R</em></span> 是自反的，则 <span class="math inline"><em>s</em>(<em>R</em>)</span> 和 <span class="math inline"><em>t</em>(<em>R</em>)</span> 是自反的</li><li>若 <span class="math inline"><em>R</em></span> 是对称的，则 <span class="math inline"><em>r</em>(<em>R</em>)</span> 和 <span class="math inline"><em>t</em>(<em>R</em>)</span> 是对称的</li><li>若 <span class="math inline"><em>R</em></span> 是传递的，则 <span class="math inline"><em>r</em>(<em>R</em>)</span> 是传递的</li><li><span class="math inline"><em>r</em>(<em>s</em>(<em>R</em>)) = <em>s</em>(<em>r</em>(<em>R</em>))</span></li><li><span class="math inline"><em>r</em>(<em>t</em>(<em>R</em>)) = <em>t</em>(<em>r</em>(<em>R</em>))</span></li><li><span class="math inline"><em>s</em>(<em>t</em>(<em>R</em>)) ⊆ <em>t</em>(<em>s</em>(<em>R</em>))</span></li></ul></li><li><strong>结论</strong>：由定理可知，若要求出 <span class="math inline"><em>R</em></span> 的自反、对称且传递的闭包，则应先求<span class="math inline"><em>r</em>(<em>R</em>)</span>，再求 <span class="math inline"><em>s</em>(<em>r</em>(<em>R</em>))</span>，最后求<span class="math inline"><em>t</em>(<em>s</em>(<em>r</em>(<em>R</em>)))</span>。</li></ul><h3 id="等价关系和划分">等价关系和划分</h3><h4 id="等价关系">等价关系</h4><ul><li><p><strong>等价关系</strong>：对非空集合 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em></span>，如果 <span class="math inline"><em>R</em></span>是<strong>自反的、对称的和传递的</strong> ，则称 <span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上的等价关系。</p><figure><img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload alt="图形表示等价关系"><figcaption aria-hidden="true">图形表示等价关系</figcaption></figure><ul><li>图 <span class="math inline">(<em>a</em>)</span>：可以用正方形表示<span class="math inline"><em>A</em> × <em>A</em></span>，<span class="math inline"><em>A</em></span> 上的关系是 <span class="math inline"><em>A</em> × <em>A</em></span>的子集，因此可以用正方形的子集表示。</li><li>图 <span class="math inline">(<em>b</em>)</span>：<span class="math inline"><em>A</em></span>上的等价关系可以用正方形的一条对角线和线上的若干正方形表示。</li><li>图 <span class="math inline">(<em>c</em>)</span>：表示的关系不是等价关系。<ul><li>它包括了对角线，所以有自反性。</li><li>它以对角线为对称轴，所以有对称性。</li><li>但它没有传递性。因为 <span class="math inline"><em>R</em></span>中的 <span class="math inline"><em>a</em></span> 和 <span class="math inline"><em>b</em></span> 点对应的有序对，经传递得到 <span class="math inline"><em>c</em></span> 点对应的有序对应在 <span class="math inline"><em>R</em></span> 中，但 <span class="math inline"><em>c</em></span> 点不在 <span class="math inline"><em>R</em></span> 中。</li></ul></li></ul></li><li><p><strong>等价类</strong>：<span class="math inline"><em>R</em></span> 是非空集合 <span class="math inline"><em>A</em></span> 上的等价关系，对任意的 <span class="math inline"><em>x</em> ∈ <em>A</em></span>，令 <span class="math display">[<em>x</em>]<sub><em>R</em></sub> = {<em>y</em> ∣ <em>y</em> ∈ <em>A</em> ∧ <em>x</em><em>R</em><em>y</em>}</span></p><p>则称集合 <span class="math inline">[<em>x</em>]<sub><em>R</em></sub></span> 为 <span class="math inline"><em>x</em></span> 关于 <span class="math inline"><em>R</em></span> 的等价类，简称 <span class="math inline"><em>x</em></span> 的<strong>等价类</strong>，也可记作 <span class="math inline">[<em>x</em>]</span> 或 <span class="math inline"><em>x̄</em></span>，<span class="math inline"><em>x</em></span> 称为等价类 <span class="math inline">[<em>x</em>]<sub><em>R</em></sub></span>的<strong>代表元素</strong></p></li><li><p><strong>性质</strong>：<span class="math inline"><em>R</em></span> 是非空集合 <span class="math inline"><em>A</em></span> 上的等价关系，对任意的 <span class="math inline"><em>x</em>, <em>y</em> ∈ <em>A</em></span></p><ul><li><span class="math inline">[<em>x</em>]<sub><em>R</em></sub> ≠ ∅</span> 且<span class="math inline">[<em>x</em>]<sub><em>R</em></sub> ⊆ <em>A</em></span></li><li>若 <span class="math inline"><em>x</em><em>R</em><em>y</em></span>，则 <span class="math inline">[<em>x</em>]<sub><em>R</em></sub> = [<em>y</em>]<sub><em>R</em></sub></span></li><li>若 <span class="math inline"><em>x</em><em>R̸</em><em>y</em></span>，则 <span class="math inline">[<em>x</em>]<sub><em>R</em></sub> ∩ [<em>y</em>]<sub><em>R</em></sub> = ∅</span></li><li><span class="math inline">∪{[<em>x</em>]<sub><em>R</em></sub> ∣ <em>x</em> ∈ <em>A</em>} = <em>A</em></span></li></ul></li><li><p><strong>商集</strong>：对非空集合 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em></span>，以 <span class="math inline"><em>R</em></span> 的不相交的等价类为元素的集合称为<span class="math inline"><em>A</em></span> 的商集，记作 <span class="math inline"><em>A</em>/<em>R</em></span> <span class="math display"><em>A</em>/<em>R</em> = {<em>y</em> ∣ (∃<em>x</em>)(<em>x</em> ∈ <em>A</em> ∧ <em>y</em> = [<em>x</em>]<sub><em>R</em></sub>)}</span></p></li></ul><h4 id="划分">划分</h4><ul><li><p><strong>定义</strong>：对非空集合 <span class="math inline"><em>A</em></span>，若存在集合 <span class="math inline"><em>π</em></span> 满足下列条件：</p><ul><li><span class="math inline">(∀<em>x</em>)(<em>x</em> ∈ <em>π</em> → <em>x</em> ⊆ <em>A</em>)</span>（A的子集族）</li><li><span class="math inline">∅ ∉ <em>π</em></span> （不空）</li><li><span class="math inline">∪<em>π</em> = <em>A</em></span>（不漏）</li><li><span class="math inline">(∀<em>x</em>)(∀<em>y</em>)((<em>x</em> ∈ <em>π</em> ∧ <em>y</em> ∈ <em>π</em> ∧ <em>x</em> ≠ <em>y</em>) → <em>x</em> ∩ <em>y</em> = ∅)</span>（不交）</li></ul><p>则称 <span class="math inline"><em>π</em></span> 为 <span class="math inline"><em>A</em></span> 的一个<strong>划分</strong> ，称<span class="math inline"><em>π</em></span> 中的元素为 <span class="math inline"><em>A</em></span> 的<strong>划分块</strong></p></li><li><p><span class="math inline"><em>A</em></span> 的一个划分 <span class="math inline"><em>π</em></span> 是 <span class="math inline"><em>A</em></span> 的非空子集的集合（即 <span class="math inline"><em>π</em> ⊆ <em>P</em>(<em>A</em>)</span> 且 <span class="math inline">∅ ∉ <em>π</em></span>），<span class="math inline"><em>A</em></span> 的这些子集互不相交，且它们的并集为<span class="math inline"><em>A</em></span></p></li><li><p><strong>诱导</strong>：</p><ul><li><strong>由等价关系 <span class="math inline"><em>R</em></span>诱导出来的 <span class="math inline"><em>A</em></span> 的划分</strong>：<ul><li>对非空集合 <span class="math inline"><em>A</em></span> 上的等价关系<span class="math inline"><em>R</em></span>，<span class="math inline"><em>A</em></span> 的商集 <span class="math inline"><em>A</em>/<em>R</em></span> 就是 <span class="math inline"><em>A</em></span> 的划分，它称为由等价关系 <span class="math inline"><em>R</em></span> 诱导出来的 <span class="math inline"><em>A</em></span> 的划分，记作 <span class="math inline"><em>π</em><sub><em>R</em></sub></span></li></ul></li><li><strong>划分 <span class="math inline"><em>π</em></span> 诱导出的<span class="math inline"><em>A</em></span> 上的等价关系</strong>：<ul><li><p>对非空集合 <span class="math inline"><em>A</em></span> 的一个划分<span class="math inline"><em>π</em></span>，令 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em><sub><em>π</em></sub></span> 为 <span class="math display"><em>R</em><sub><em>π</em></sub> = {⟨<em>x</em>, <em>y</em>⟩ ∣ (∃<em>z</em>)(<em>z</em> ∈ <em>π</em> ∧ <em>x</em> ∈ <em>z</em> ∧ <em>y</em> ∈ <em>z</em>)}</span></p><p>则 <span class="math inline"><em>R</em><sub><em>π</em></sub></span>为 <span class="math inline"><em>A</em></span> 上的等价关系，它称为划分<span class="math inline"><em>π</em></span> 诱导出的 <span class="math inline"><em>A</em></span> 上的等价关系</p></li></ul></li><li>对非空集合 <span class="math inline"><em>A</em></span> 的一个划分<span class="math inline"><em>π</em></span> 和 <span class="math inline"><em>A</em></span> 上的等价关系 <span class="math inline"><em>R</em></span>，<span class="math inline"><em>π</em></span> 诱导 <span class="math inline"><em>R</em></span> 当且仅当 <span class="math inline"><em>R</em></span> 诱导 <span class="math inline"><em>π</em></span></li></ul></li></ul><h3 id="相容关系和覆盖">相容关系和覆盖</h3><h4 id="相容关系">相容关系</h4><ul><li><strong>相容关系</strong>：对非空集合 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em></span>，如果 <span class="math inline"><em>R</em></span> 是<strong>自反的、对称的</strong>，则称 <span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上的相容关系。</li><li><strong>相容类</strong>：对非空集合 <span class="math inline"><em>A</em></span> 上的相容关系 <span class="math inline"><em>R</em></span>，若 <span class="math inline"><em>C</em> ⊆ <em>A</em></span>，且 <span class="math inline"><em>C</em></span> 中任意两个元素 <span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>y</em></span> 有 <span class="math inline"><em>x</em><em>R</em><em>y</em></span>，则称 <span class="math inline"><em>C</em></span> 是由相容关系 <span class="math inline"><em>R</em></span> 产生的相容类，简称相容类。</li><li><strong>最大相容类</strong>：对非空集合 <span class="math inline"><em>A</em></span> 上的相容关系 <span class="math inline"><em>R</em></span>，一个相容类若不是任何相容类的真子集，就称为最大相容类，记作<span class="math inline"><em>C</em><sub><em>R</em></sub></span>。<ul><li>性质：<ul><li><span class="math inline">(∀<em>x</em>)(∀<em>y</em>)((<em>x</em> ∈ <em>C</em><sub><em>R</em></sub> ∧ <em>y</em> ∈ <em>C</em><sub><em>R</em></sub>) → <em>x</em><em>R</em><em>y</em>)</span></li><li><span class="math inline">(∀<em>x</em>)(<em>x</em> ∈ <em>A</em> − <em>C</em><sub><em>R</em></sub> → (∃<em>y</em>)(<em>y</em> ∈ <em>C</em><sub><em>R</em></sub> ∧ <em>x</em><em>R</em><em>y</em>))</span></li><li>对非空有限集合 <span class="math inline"><em>A</em></span>上的相容关系 <span class="math inline"><em>R</em></span>，若 <span class="math inline"><em>C</em></span> 是一个相容类，则存在一个最大相容类<span class="math inline"><em>C</em><sub><em>R</em></sub></span>，使<span class="math inline"><em>C</em> ⊆ <em>C</em><sub><em>R</em></sub></span></li></ul></li></ul></li></ul><h4 id="覆盖">覆盖</h4><ul><li><p><strong>覆盖</strong>：对非空集合 <span class="math inline"><em>A</em></span>，若存在集合 <span class="math inline"><em>Ω</em></span> 满足下列条件：</p><ul><li><span class="math inline">(∀<em>x</em>)(<em>x</em> ∈ <em>Ω</em> → <em>x</em> ⊆ <em>A</em>)</span></li><li><span class="math inline">∅ ∉ <em>Ω</em></span></li><li><span class="math inline">∪<em>Ω</em> = <em>A</em></span></li></ul><p>则称 <span class="math inline"><em>Ω</em></span> 为 <span class="math inline"><em>A</em></span> 的一个<strong>覆盖</strong> ，称<span class="math inline"><em>Ω</em></span> 中的元素为 <span class="math inline"><em>Ω</em></span>的<strong>覆盖块</strong>。</p></li><li><p>一个划分是一个覆盖，但一个覆盖不一定是一个划分。因为划分中各元素不相交，覆盖中各元素可能相交。</p></li><li><p><strong>完全覆盖</strong>：对非空集合 <span class="math inline"><em>A</em></span> 上的相容关系 <span class="math inline"><em>R</em></span>，最大相容类的集合是 <span class="math inline"><em>A</em></span> 的一个覆盖，称为 <span class="math inline"><em>A</em></span> 的完全覆盖，记作 <span class="math inline"><em>C</em><sub><em>R</em></sub>(<em>A</em>)</span>，而且<span class="math inline"><em>C</em><sub><em>R</em></sub>(<em>A</em>)</span>是唯一的。</p></li><li><p>对非空集合 <span class="math inline"><em>A</em></span> 的一个覆盖<span class="math inline"><em>Ω</em> = {<em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, ⋯, <em>A</em><sub><em>n</em></sub>}</span>，由<span class="math inline"><em>Ω</em></span> 确定的关系 <span class="math display"><em>R</em> = <em>A</em><sub>1</sub> × <em>A</em><sub>1</sub> ∪ <em>A</em><sub>2</sub> × <em>A</em><sub>2</sub> ∪ ⋯ ∪ <em>A</em><sub><em>n</em></sub> × <em>A</em><sub><em>n</em></sub></span></p><p>是 <span class="math inline"><em>A</em></span> 上的相容关系</p></li></ul><h3 id="偏序关系">偏序关系</h3><h4 id="偏序关系和拟序关系">偏序关系和拟序关系</h4><ul><li><strong>偏序关系</strong>：对非空集合 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em></span>，如果 <span class="math inline"><em>R</em></span>是<strong>自反的、反对称的和传递的</strong> ，则称 <span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上的偏序关系。偏序关系 <span class="math inline"><em>R</em></span> 通常记作 <span class="math inline">≤</span>，当 <span class="math inline"><em>x</em><em>R</em><em>y</em></span> 时，可记作<span class="math inline"><em>x</em> ≤ <em>y</em></span>。<ul><li>偏序关系又称<strong>弱偏序关系</strong>，或<strong>半序关系</strong>。</li></ul></li><li><strong>拟序关系</strong>：对非空集合 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em></span>，如果 <span class="math inline"><em>R</em></span>是<strong>非自反的和传递的</strong> （暗含了反对称），则称 <span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上的拟序关系。拟序关系 <span class="math inline"><em>R</em></span> 通常记作 <span class="math inline">&lt;</span> 当 <span class="math inline"><em>x</em><em>R</em><em>y</em></span> 时，可记作<span class="math inline"><em>x</em> &lt; <em>y</em></span>。<ul><li>拟序关系又称<strong>强偏序关系</strong>。</li></ul></li><li><strong>性质</strong>：<ul><li>若 <span class="math inline"><em>R</em></span> 为 <span class="math inline"><em>A</em></span> 上的拟序关系，则 <span class="math inline"><em>R</em></span> 是反对称的</li><li>对 <span class="math inline"><em>A</em></span> 上的拟序关系 <span class="math inline"><em>R</em></span>，<span class="math inline"><em>R</em> ∪ <em>R</em><sup>0</sup></span> 是 <span class="math inline"><em>A</em></span> 上的偏序关系</li><li>对 <span class="math inline"><em>A</em></span> 上的偏序关系 <span class="math inline"><em>R</em></span>，<span class="math inline"><em>R</em> − <em>R</em><sup>0</sup></span> 是 <span class="math inline"><em>A</em></span> 上的拟序关系</li></ul></li><li><strong>偏序结构</strong>：集合 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>A</em></span> 上的关系 <span class="math inline"><em>R</em></span>一起称为一个<strong>结构</strong>。集合 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>A</em></span> 上的偏序关系 <span class="math inline"><em>R</em></span>一起称为一个偏序结构，或称<strong>偏序集</strong> ，并记作 <span class="math inline">⟨<em>A</em>, <em>R</em>⟩</span></li></ul><h4 id="哈斯图">哈斯图</h4><ul><li><strong>盖住关系</strong>：对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，如果 <span class="math inline"><em>x</em>, <em>y</em> ∈ <em>A</em></span>，<span class="math inline"><em>x</em> ≤ <em>y</em></span>，<span class="math inline"><em>x</em> ≠ <em>y</em></span>，且不存在元素 <span class="math inline"><em>z</em> ∈ <em>A</em></span> 使得 <span class="math inline"><em>x</em> ≤ <em>z</em></span> 且 <span class="math inline"><em>z</em> ≤ <em>y</em></span>，则称 <span class="math inline"><em>y</em></span> 盖住 <span class="math inline"><em>x</em></span>。<span class="math inline"><em>A</em></span> 上的盖住关系 <span class="math inline">cov <em>A</em></span> 定义为 <span class="math display">cov <em>A</em> = {⟨<em>x</em>, <em>y</em>⟩ ∣ <em>x</em> ∈ <em>A</em> ∧ <em>y</em> ∈ <em>A</em> ∧ <em>y</em>盖住<em>x</em>}</span></li><li>对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，<span class="math inline"><em>A</em></span> 上的盖住关系 <span class="math inline">cov <em>A</em></span>是唯一的，可以用盖住关系画偏序集的哈斯图，作图规则为：<ul><li>每个顶点代表 <span class="math inline"><em>A</em></span>的一个元素，</li><li>若 <span class="math inline"><em>x</em> ≤ <em>y</em></span> 且 <span class="math inline"><em>x</em> ≠ <em>y</em></span>，则顶点 <span class="math inline"><em>y</em></span> 在顶点 <span class="math inline"><em>x</em></span> 上方，</li><li>若 <span class="math inline">⟨<em>x</em>, <em>y</em>⟩ ∈ cov <em>A</em></span>，则<span class="math inline"><em>x</em>, <em>y</em></span> 间连无向边</li></ul></li></ul><h4 id="上确界和下确界">上确界和下确界</h4><h5 id="最大最小极大极小元">最大/最小/极大/极小元</h5><ul><li><strong>定义</strong>：对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，且 <span class="math inline"><em>B</em> ⊆ <em>A</em></span>，进一步<ul><li>若 <span class="math inline">(∃<em>y</em>)(<em>y</em> ∈ <em>B</em> ∧ (∀<em>x</em>)(<em>x</em> ∈ <em>B</em> → <em>y</em> ≤ <em>x</em>))</span>，则称<span class="math inline"><em>y</em></span> 为 <span class="math inline"><em>B</em></span> 的<strong>最小元</strong>。</li><li>若 <span class="math inline">(∃<em>y</em>)(<em>y</em> ∈ <em>B</em> ∧ (∀<em>x</em>)(<em>x</em> ∈ <em>B</em> → <em>x</em> ≤ <em>y</em>))</span>，则称<span class="math inline"><em>y</em></span> 为 <span class="math inline"><em>B</em></span> 的<strong>最大元</strong>。</li><li>若 <span class="math inline">(∃<em>y</em>)(<em>y</em> ∈ <em>B</em> ∧ (∀<em>x</em>)((<em>x</em> ∈ <em>B</em> ∧ <em>x</em> ≤ <em>y</em>) → <em>x</em> = <em>y</em>))</span>，则称<span class="math inline"><em>y</em></span> 为 <span class="math inline"><em>B</em></span> 的<strong>极小元</strong>。</li><li>若 <span class="math inline">(∃<em>y</em>)(<em>y</em> ∈ <em>B</em> ∧ (∀<em>x</em>)((<em>x</em> ∈ <em>B</em> ∧ <em>y</em> ≤ <em>x</em>) → <em>x</em> = <em>y</em>))</span>，则称<span class="math inline"><em>y</em></span> 为 <span class="math inline"><em>B</em></span> 的<strong>极大元</strong>。</li></ul></li><li><strong>性质</strong>：<ul><li>最小（大）元不一定存在，若存在必唯一。</li><li>在非空有限集合 <span class="math inline"><em>B</em></span>中，极小（大）元必存在，不一定唯一。</li></ul></li><li>直观理解：<ul><li>最小元是哈斯图最下面那个（有多个则没有最小元）</li><li>最大元是哈斯图最上面那个（有多个则没有最大元）</li><li>极大元是哈斯图最上面那个（有多个则全部是极大元）</li><li>极小元是哈斯图最下面那个（有多个则全部是极小元）</li><li>极大和最大的差别在于 <span class="math inline"><em>B</em></span>中是否包含不可比较的元素</li></ul></li></ul><h5 id="上下界">上下界</h5><ul><li><strong>定义</strong>：对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，且 <span class="math inline"><em>B</em> ⊆ <em>A</em></span>，进一步<ul><li>若 <span class="math inline">(∃<em>y</em>)(<em>y</em> ∈ <em>A</em> ∧ (∀<em>x</em>)(<em>x</em> ∈ <em>B</em> → <em>x</em> ≤ <em>y</em>))</span>，则称<span class="math inline"><em>y</em></span> 为 <span class="math inline"><em>B</em></span> 的<strong>上界</strong>。</li><li>若 <span class="math inline">(∃<em>y</em>)(<em>y</em> ∈ <em>A</em> ∧ (∀<em>x</em>)(<em>x</em> ∈ <em>B</em> → <em>y</em> ≤ <em>x</em>))</span>，则称<span class="math inline"><em>y</em></span> 为 <span class="math inline"><em>B</em></span> 的<strong>下界</strong>。</li><li>若集合 <span class="math inline"><em>C</em> = {<em>y</em> ∣ <em>y</em><em>是</em><em>B</em><em>的</em><em>上</em><em>界</em>}</span>，则<span class="math inline"><em>C</em></span> 的最小元称为 <span class="math inline"><em>B</em></span> 的<strong>上确界</strong>或最小上界。</li><li>若集合 <span class="math inline"><em>C</em> = {<em>y</em> ∣ <em>y</em><em>是</em><em>B</em><em>的</em><em>下</em><em>界</em>}</span>，则<span class="math inline"><em>C</em></span> 的最大元称为 <span class="math inline"><em>B</em></span> 的<strong>下确界</strong>或最大下界。</li></ul></li><li><strong>性质</strong>：<ul><li>上下界未必存在，存在时也未必唯一。</li><li>上（下）确界未必存在，存在必唯一。</li><li>存在上（下）界，也未必存在上（下）确界。</li><li>如果 <span class="math inline"><em>b</em></span> 是 <span class="math inline"><em>B</em></span> 的最大（小）元，则 <span class="math inline"><em>b</em></span> 是 <span class="math inline"><em>B</em></span> 的上（下）确界。</li><li>如果 <span class="math inline"><em>b</em></span> 是 <span class="math inline"><em>B</em></span> 的上（下）界，而且 <span class="math inline"><em>b</em> ∈ <em>B</em></span>，则 <span class="math inline"><em>b</em></span> 一定是 <span class="math inline"><em>B</em></span> 的最大（小）元。</li></ul></li></ul><h4 id="全序关系和链">全序关系和链</h4><ul><li><strong>可比</strong>：对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，对任意的 <span class="math inline"><em>x</em></span>，<span class="math inline"><em>y</em> ∈ <em>A</em></span>，若有 <span class="math inline"><em>x</em> ≤ <em>y</em></span> 或 <span class="math inline"><em>y</em> ≤ <em>x</em></span>，则称 <span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>y</em></span> 是可比的</li><li><strong>全序关系</strong>：对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，如果对任意的 <span class="math inline"><em>x</em></span>，<span class="math inline"><em>y</em> ∈ <em>A</em></span>，<span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>y</em></span> 都可比，则称 <span class="math inline">≤</span> 为 <span class="math inline"><em>A</em></span>上的<strong>全序关系</strong>，或称<strong>线序关系</strong> ，并称<span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>为<strong>全序集</strong></li><li><strong>（反）链的长度</strong>：对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，且 <span class="math inline"><em>B</em> ⊆ <em>A</em></span>，进一步<ul><li>如果对任意的 <span class="math inline"><em>x</em>, <em>y</em> ∈ <em>B</em></span>，<span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>y</em></span> 都是可比的，则称 <span class="math inline"><em>B</em></span> 为 <span class="math inline"><em>A</em></span> 上的链，<span class="math inline"><em>B</em></span>中元素个数称为<strong>链的长度</strong></li><li>如果对任意的 <span class="math inline"><em>x</em>, <em>y</em> ∈ <em>B</em></span>，<span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>y</em></span> 都不是可比的，则称 <span class="math inline"><em>B</em></span> 为 <span class="math inline"><em>A</em></span> 上的反链，<span class="math inline"><em>B</em></span>中元素个数称为<strong>反链的长度</strong></li></ul></li><li><strong>定理</strong>：<ul><li>对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，设<span class="math inline"><em>A</em></span> 中最长链的长度是 <span class="math inline"><em>n</em></span>，则将 <span class="math inline"><em>A</em></span>中元素分成不相交的反链，反链个数至少是 <span class="math inline"><em>n</em></span></li><li>对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，若<span class="math inline"><em>A</em></span> 中元素为 <span class="math inline"><em>m</em><em>n</em> + 1</span> 个，则 <span class="math inline"><em>A</em></span> 中或者存在一条长度为 <span class="math inline"><em>m</em> + 1</span> 的反链，或者存在一条长度为<span class="math inline"><em>n</em> + 1</span> 的链</li></ul></li></ul><h4 id="良序关系">良序关系</h4><ul><li><strong>良序关系</strong> ：对偏序集 <span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>，如果 <span class="math inline"><em>A</em></span> 的任何非空子集都有最小元，则称<span class="math inline">≤</span> 为<strong>良序关系</strong> ，称<span class="math inline">⟨<em>A</em>,  ≤ ⟩</span>为<strong>良序集</strong></li><li><strong>性质</strong>：<ul><li>一个良序集一定是全序集</li><li>一个有限的全序集一定是良序集</li><li><strong>良序定理</strong>：任意的集合都是可以良序化的</li></ul></li></ul><h4 id="区间">区间</h4><ul><li>在全序集 <span class="math inline">⟨ℝ,  ≤ ⟩</span> 上，对于 <span class="math inline"><em>a</em>, <em>b</em> ∈ ℝ</span>，<span class="math inline"><em>a</em> ≠ <em>b</em></span>，<span class="math inline"><em>a</em> ≤ <em>b</em></span>，则<ul><li><span class="math inline">[<em>a</em>, <em>b</em>] = {<em>x</em> ∣ <em>x</em> ∈ ℝ ∧ <em>a</em> ≤ <em>x</em> ≤ <em>b</em>}</span>，称为从<span class="math inline"><em>a</em></span> 到 <span class="math inline"><em>b</em></span> 的<strong>闭区间</strong></li><li><span class="math inline">(<em>a</em>, <em>b</em>) = {<em>x</em> ∣ <em>x</em> ∈ ℝ ∧ <em>a</em> ≤ <em>x</em> ≤ <em>b</em> ∧ <em>x</em> ≠ <em>a</em> ∧ <em>x</em> ≠ <em>b</em>}</span>，称为从<span class="math inline"><em>a</em></span> 到 <span class="math inline"><em>b</em></span> 的<strong>开区间</strong></li><li><span class="math inline">[<em>a</em>, <em>b</em>) = {<em>x</em> ∣ <em>x</em> ∈ ℝ ∧ <em>a</em> ≤ <em>x</em> ≤ <em>b</em> ∧ <em>x</em> ≠ <em>b</em>}</span>称为从 <span class="math inline"><em>a</em></span> 到 <span class="math inline"><em>b</em></span> 的<strong>半开区间</strong></li><li><span class="math inline">(<em>a</em>, <em>b</em>] = {<em>x</em> ∣ <em>x</em> ∈ ℝ ∧ <em>a</em> ≤ <em>x</em> ≤ <em>b</em> ∧ <em>x</em> ≠ <em>a</em>}</span>称为从 <span class="math inline"><em>a</em></span> 到 <span class="math inline"><em>b</em></span> 的半开区间</li><li>还可以定义下列区间 <span class="math display">$$ \begin{aligned}  (-\infty,a] &amp;=\{x \mid x \in \mathbb{R} \wedge x \leqslant a\}\\  (-\infty,a) &amp;=\{x \mid x \in \mathbb{R} \wedge x \leqslant a\wedge x \neq a\}\\  [a,\infty) &amp;=\{x \mid x \in \mathbb{R} \wedge a \leqslant x\},\\  (a,\infty) &amp;=\{x \mid x \in \mathbb{R} \wedge a \leqslant x \wedgex \neq a\},\\  (-\infty,\infty) &amp;=\mathbb{R}  \end{aligned}$$</span></li></ul></li></ul><h2 id="第十一章-函数">第十一章 函数</h2><h3 id="函数和选择公理">函数和选择公理</h3><h4 id="函数定义">函数定义</h4><ul><li><strong>定义</strong>：对集合 <span class="math inline"><em>A</em></span> 到集合 <span class="math inline"><em>B</em></span> 的关系 <span class="math inline"><em>f</em></span>，若满足下列条件：<ul><li><strong>单值性</strong>：对任意的 <span class="math inline"><em>x</em> ∈ dom (<em>f</em>)</span>，存在唯一的<span class="math inline"><em>y</em> ∈ ran (<em>f</em>)</span>，使 <span class="math inline"><em>x</em><em>f</em><em>y</em></span> 成立</li><li><strong>定义域</strong>：<span class="math inline">dom (<em>f</em>) = <em>A</em></span></li></ul>则称 <span class="math inline"><em>f</em></span> 为从 <span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>B</em></span> 的<strong>函数</strong> ，或称<span class="math inline"><em>f</em></span> 把 <span class="math inline"><em>A</em></span> 映射到 <span class="math inline"><em>B</em></span></li><li>一个从 <span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>B</em></span> 的函数 <span class="math inline"><em>f</em></span>，可以写成 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>，这时若<span class="math inline"><em>x</em><em>f</em><em>y</em></span>，则可记作<span class="math inline"><em>f</em> : <em>x</em>∣ → <em>y</em></span>或 <span class="math inline"><em>f</em>(<em>x</em>) = <em>y</em></span></li><li>函数的两个条件可以写成：<ul><li><span class="math inline">(∀<em>x</em>)(∀<em>y</em><sub>1</sub>)(∀<em>y</em><sub>2</sub>)((<em>x</em><em>f</em><em>y</em><sub>1</sub> ∧ <em>x</em><em>f</em><em>y</em><sub>2</sub>) → <em>y</em><sub>1</sub> = <em>y</em><sub>2</sub>)</span></li><li><span class="math inline">(∀<em>x</em>)(<em>x</em> ∈ <em>A</em> → (∃<em>y</em>)(<em>y</em> ∈ <em>B</em> ∧ <em>x</em><em>f</em><em>y</em>))</span></li></ul></li><li>如果一个关系是函数，则它的关系矩阵中每行恰好有一个 <span class="math inline">1</span>，其余为 <span class="math inline">0</span>，它的关系图中每个 <span class="math inline"><em>A</em></span> 中的顶点恰好发出一条有向边</li></ul><h4 id="特殊函数">特殊函数</h4><ul><li><p><strong>象</strong>：</p><ul><li>对集合 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>B</em></span>，从 <span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>B</em></span> 的所有函数的集合记为 <span class="math inline"><em>A</em><sub><em>B</em></sub></span> 于是，<span class="math inline"><em>A</em><sub><em>B</em></sub> = {<em>f</em> ∣ <em>f</em> : <em>A</em> → <em>B</em>}</span><br></li><li><strong>象的定义</strong>：设 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>，<span class="math inline"><em>A</em><sub>1</sub> ⊆ <em>A</em></span>，定义<span class="math inline"><em>A</em><sub>1</sub></span> 在 <span class="math inline"><em>f</em></span> 下的象 <span class="math inline"><em>f</em>[<em>A</em><sub>1</sub>]</span> 为 <span class="math display"><em>f</em>[<em>A</em><sub>1</sub>] = {<em>y</em> ∣ (∃<em>x</em>)(<em>x</em> ∈ <em>A</em><sub>1</sub> ∧ <em>y</em> = <em>f</em>(<em>x</em>))}</span></li><li><strong>完全原象</strong>：设 <span class="math inline"><em>B</em><sub>1</sub> ⊆ <em>B</em></span>，定义<span class="math inline"><em>B</em><sub>1</sub></span> 在 <span class="math inline"><em>f</em></span> 下的<strong>完全原象</strong><span class="math inline"><em>f</em><sup>−1</sup>[<em>B</em><sub>1</sub>]</span>为</li></ul><p><span class="math display"><em>f</em><sup>−1</sup>[<em>B</em><sub>1</sub>] = {<em>x</em> ∣ <em>x</em> ∈ <em>A</em> ∧ <em>f</em>(<em>x</em>) ∈ <em>B</em><sub>1</sub>}</span></p></li><li><p><strong>单射双射满射</strong></p><ul><li>对于函数 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>，<ul><li><strong>满射</strong>：<span class="math inline">ran (<em>f</em>) = <em>B</em></span>，则称 <span class="math inline"><em>f</em></span> 是满射的，或称 <span class="math inline"><em>f</em></span> 是 <span class="math inline"><em>A</em></span> 到 <span class="math inline"><em>B</em></span> 上的<ul><li>如果 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>是满射的，则对任意的 <span class="math inline"><em>y</em> ∈ <em>B</em></span>，存在 <span class="math inline"><em>x</em> ∈ <em>A</em></span>，使 <span class="math inline"><em>f</em>(<em>x</em>) = <em>y</em></span></li></ul></li><li><strong>单射</strong>：若对任意的 <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub> ∈ <em>A</em>, <em>x</em><sub>1</sub> ≠ <em>x</em><sub>2</sub></span>，都有<span class="math inline"><em>f</em>(<em>x</em><sub>1</sub>) ≠ <em>f</em>(<em>x</em><sub>2</sub>)</span>，则称<span class="math inline"><em>f</em></span>是单射的，或内射的，或一对一的<ul><li>如果 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>是单射的，则对任意的 <span class="math inline"><em>y</em> ∈ ran (<em>f</em>)</span>，存在唯一的<span class="math inline"><em>x</em> ∈ <em>A</em></span>，使 <span class="math inline"><em>f</em>(<em>x</em>) = <em>y</em></span></li></ul></li><li><strong>双射</strong>：若 <span class="math inline"><em>f</em></span> 是满射的又是单射的，则称 <span class="math inline"><em>f</em></span> 是<strong>双射</strong>的</li></ul></li><li>特别地，<span class="math inline">∅ : ∅ → <em>B</em></span>是单射的，<span class="math inline">∅ : ∅ → ∅</span> 是双射的</li></ul></li></ul><h4 id="常用函数">常用函数</h4><ul><li><strong>常函数</strong>：设 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>，如果存在一个<span class="math inline"><em>y</em> ∈ <em>B</em></span>，使得对所有的<span class="math inline"><em>x</em> ∈ <em>A</em></span>，有 <span class="math inline"><em>f</em>(<em>x</em>) = <em>y</em></span>，即有<span class="math inline"><em>f</em>[<em>A</em>] = {<em>y</em>}</span>，则称<span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>为常函数。</li><li><strong>恒等函数</strong>：<span class="math inline"><em>A</em></span> 上的恒等关系 <span class="math inline"><em>I</em><sub><em>A</em></sub> : <em>A</em> → <em>A</em></span>称为恒等函数。对任意的 <span class="math inline"><em>x</em> ∈ <em>A</em></span>，有 <span class="math inline"><em>I</em><sub><em>A</em></sub>(<em>x</em>) = <em>x</em></span>。</li><li><strong>单调递增/减函数</strong>：<ul><li>对实数集 <span class="math inline">ℝ</span>，设 <span class="math inline"><em>f</em> : ℝ → ℝ</span>，如果 <span class="math inline">(<em>x</em> ≤ <em>y</em>) → (<em>f</em>(<em>x</em>) ≤ <em>f</em>(<em>y</em>))</span>，则称<span class="math inline"><em>f</em></span>为<strong>单调递增</strong>的</li><li>如果 <span class="math inline">(<em>x</em> &lt; <em>y</em>) → (<em>f</em>(<em>x</em>) &lt; <em>f</em>(<em>y</em>))</span>，则称<span class="math inline"><em>f</em></span>为<strong>严格单调递增</strong>的</li><li>类似可定义单调递减和严格单调递减的函数</li></ul></li><li><strong><span class="math inline"><em>n</em></span>元运算</strong>：对集合 <span class="math inline"><em>A</em></span>，<span class="math inline"><em>n</em> ∈ ℕ</span>，把函数 <span class="math inline"><em>f</em> : <em>A</em><sup><em>n</em></sup> → <em>A</em></span>称为 <span class="math inline"><em>A</em></span> 上的 <span class="math inline"><em>n</em></span> 元运算</li><li><strong>泛函</strong>：设 <span class="math inline"><em>A</em>, <em>B</em>, <em>C</em></span>是集合，<span class="math inline"><em>B</em><sub><em>C</em></sub></span>为从 <span class="math inline"><em>B</em></span> 到 <span class="math inline"><em>C</em></span> 的所有函数的集合，则 <span class="math inline"><em>F</em> : <em>A</em> → <em>B</em><sub><em>C</em></sub></span>称为一个<strong>泛函</strong> （有时 <span class="math inline"><em>G</em> : <em>B</em><sub><em>C</em></sub> → <em>A</em></span>称为一个泛函）<ul><li>泛函 <span class="math inline"><em>F</em></span> 也是函数，它把<span class="math inline"><em>A</em></span> 的元素 <span class="math inline"><em>a</em></span> 映射到从 <span class="math inline"><em>B</em></span> 到 <span class="math inline"><em>C</em></span> 的函数 <span class="math inline"><em>f</em> : <em>B</em> → <em>C</em></span>。即函数值<span class="math inline"><em>F</em>(<em>a</em>)</span> 是函数 <span class="math inline"><em>f</em> : <em>B</em> → <em>C</em></span>。</li></ul></li><li><strong>特征函数</strong>：设 <span class="math inline"><em>E</em></span> 是全集，对任意的 <span class="math inline"><em>A</em> ⊆ <em>E</em></span>，<span class="math inline"><em>A</em></span> 的特征函数 <span class="math inline"><em>χ</em><sub><em>A</em></sub></span> 定义为：<span class="math display">$$ \chi_{A}:E\rightarrow\{0,1\},\chi_{A}(a)=\left\{\begin{array}{ll} 1,&amp; a \in A\\ 0,&amp; a \notin A \end{array}\right.$$</span></li><li><strong>自然映射</strong>：设 <span class="math inline"><em>R</em></span> 是 <span class="math inline"><em>A</em></span> 上的等价关系，令 <span class="math inline"><em>g</em> : <em>A</em> → <em>A</em>/<em>R</em></span>，<span class="math inline"><em>g</em>(<em>a</em>) = [<em>a</em>]<sub><em>R</em></sub></span>，则称<span class="math inline"><em>g</em></span> 为从 <span class="math inline"><em>A</em></span> 到商集 <span class="math inline"><em>A</em>/<em>R</em></span>的<strong>典型映射</strong>或<strong>自然映射</strong></li></ul><h4 id="选择公理">选择公理</h4><ul><li>选择公理：对任意的关系 <span class="math inline"><em>R</em></span>，存在函数 <span class="math inline"><em>f</em></span>，使得 <span class="math inline"><em>f</em> ⊆ <em>R</em></span> 且 <span class="math inline">dom (<em>f</em>) = dom (<em>R</em>)</span></li></ul><h3 id="函数的合成和函数的逆">函数的合成和函数的逆</h3><h4 id="函数的合成">函数的合成</h4><ul><li>设 <span class="math inline"><em>g</em> : <em>A</em> → <em>B</em></span>，<span class="math inline"><em>f</em> : <em>B</em> → <em>C</em></span>，则<ul><li><span class="math inline"><em>f</em> ∘ <em>g</em></span> 是函数<span class="math inline"><em>f</em> ∘ <em>g</em> : <em>A</em> → <em>C</em></span></li><li>对任意的 <span class="math inline"><em>x</em> ∈ <em>A</em></span>，有 <span class="math inline">(<em>f</em> ∘ <em>g</em>)(<em>x</em>) = <em>f</em>(<em>g</em>(<em>x</em>))</span></li></ul></li></ul><figure><img src="image-23.webp" srcset="/img/loading/loading3.gif" lazyload alt="函数的合成"><figcaption aria-hidden="true">函数的合成</figcaption></figure><ul><li>设 <span class="math inline"><em>g</em> : <em>A</em> → <em>B</em></span>，<span class="math inline"><em>f</em> : <em>B</em> → <em>C</em></span>，则<ul><li>若 <span class="math inline"><em>f</em>, <em>g</em></span>是满射的，则 <span class="math inline"><em>f</em> ∘ <em>g</em></span>是满射的</li><li>若 <span class="math inline"><em>f</em>, <em>g</em></span>是单射的，则 <span class="math inline"><em>f</em> ∘ <em>g</em></span>是单射的</li><li>若 <span class="math inline"><em>f</em>, <em>g</em></span>是双射的，则 <span class="math inline"><em>f</em> ∘ <em>g</em></span>是双射的</li></ul></li><li>设 <span class="math inline"><em>g</em> : <em>A</em> → <em>B</em></span>，<span class="math inline"><em>f</em> : <em>B</em> → <em>C</em></span>，则<ul><li>若 <span class="math inline"><em>f</em> ∘ <em>g</em></span>是满射的，则 <span class="math inline"><em>f</em></span> 是满射的</li><li>若 <span class="math inline"><em>f</em> ∘ <em>g</em></span>是单射的，则 <span class="math inline"><em>g</em></span> 是单射的</li><li>若 <span class="math inline"><em>f</em> ∘ <em>g</em></span>是双射的，则 <span class="math inline"><em>f</em></span> 是满射的，<span class="math inline"><em>g</em></span> 是单射的</li></ul></li><li>设 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>，则<ul><li><span class="math inline"><em>f</em> = <em>f</em> ∘ <em>I</em><sub><em>A</em></sub> = <em>I</em><sub><em>B</em></sub> ∘ <em>f</em></span></li></ul></li></ul><h4 id="函数的逆">函数的逆</h4><ul><li>一个关系的逆不一定是函数，一个函数的逆也不一定是函数</li><li><strong>逆函数</strong>：若 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>是双射的，则 <span class="math inline"><em>f</em><sup>−1</sup></span>是函数 <span class="math inline"><em>f</em><sup>−1</sup> : <em>B</em> → <em>A</em></span><span class="math display">$$ \begin{aligned}  \left(f^{-1}\right)^{-1}&amp;=f \\  f^{-1} \circ f&amp;=E_{A} \\  f \circ f^{-1}&amp;=E_{B}  \end{aligned}$$</span></li><li>两个可逆函数 <span class="math inline"><em>f</em>, <em>g</em></span>的合成：<span class="math inline">(<em>g</em> ∘ <em>f</em>)<sup>−1</sup> = <em>f</em><sup>−1</sup> ∘ <em>g</em><sup>−1</sup></span></li><li><strong>反函数</strong>：设 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>是双射的，则称 <span class="math inline"><em>f</em><sup>−1</sup> : <em>B</em> → <em>A</em></span>为 <span class="math inline"><em>f</em></span> 的反函数<ul><li>若 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>是双射的，则 <span class="math inline"><em>f</em><sup>−1</sup> : <em>B</em> → <em>A</em></span>是双射的</li></ul></li><li>若 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>是双射的，则对任意的 <span class="math inline"><em>x</em> ∈ <em>A</em></span>，有 <span class="math inline"><em>f</em><sup>−1</sup>(<em>f</em>(<em>x</em>)) = <em>x</em></span>，对任意的<span class="math inline"><em>y</em> ∈ <em>B</em></span>，有 <span class="math inline"><em>f</em>(<em>f</em><sup>−1</sup>(<em>y</em>)) = <em>y</em></span></li><li><strong>左/右逆</strong>：设 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>，<span class="math inline"><em>g</em> : <em>B</em> → <em>A</em></span>，<ul><li>如果 <span class="math inline"><em>g</em> ∘ <em>f</em> = <em>I</em><sub><em>A</em></sub></span>，则称<span class="math inline"><em>g</em></span> 为 <span class="math inline"><em>f</em></span> 的左逆</li><li>如果 <span class="math inline"><em>f</em> ∘ <em>g</em> = <em>I</em><sub><em>B</em></sub></span>，则称<span class="math inline"><em>g</em></span> 为 <span class="math inline"><em>f</em></span> 的右逆</li></ul></li><li>设 <span class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>，<span class="math inline"><em>A</em> ≠ ∅</span>，则<ul><li><span class="math inline"><em>f</em></span> 存在左逆，当且仅当 <span class="math inline"><em>f</em></span> 是单射的</li><li><span class="math inline"><em>f</em></span> 存在右逆，当且仅当 <span class="math inline"><em>f</em></span> 是满射的</li><li><span class="math inline"><em>f</em></span>存在左逆又存在右逆，当且仅当 <span class="math inline"><em>f</em></span>是双射的</li><li>若 <span class="math inline"><em>f</em></span> 是双射的，则 <span class="math inline"><em>f</em></span> 的左逆等于右逆</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 数学 </category>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 离散数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思想道德与法治</title>
      <link href="/_posts/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/"/>
      <url>/_posts/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="绪论-担当复兴大任-成就时代新人">绪论 担当复兴大任成就时代新人</h1><ul><li>新时代是我们理解当前所处历史方位的关键词。</li><li>肩负历史使命，立大志、明大德、成大才、担大任，努力成为堪当民族复兴大任的时代新人。<ul><li><strong>立大志</strong>，就是要有崇高的理想信念，牢记使命，自信自励。</li><li><strong>明大德</strong>，就是要锤炼高尚品格，崇德修身，启润青春。</li><li><strong>成大才</strong>，就是要有高强的本领才干，勤奋学习，全面发展。</li><li><strong>担大任</strong>，就是要有天下兴亡、匹夫有责的担当精神，讲求奉献，实干进取。</li></ul></li></ul><h1 id="第一章-领悟人生真谛-把握人生方向">第一章 领悟人生真谛把握人生方向</h1><h2 id="人生观是对人生的总看法">人生观是对人生的总看法</h2><ul><li>人生观的定义：<ul><li>人生观就是人们关于<strong>人生目的</strong>、<strong>人生态度</strong>、<strong>人生价值</strong>等问题的总观点和总看法。</li></ul></li><li>马克思主义关于人的本质的认识：<ul><li>“人是一切<strong>社会关系</strong>的总和。”<strong>社会属性是人的本质属性</strong>。</li></ul></li><li>个人与社会的辩证关系：<ul><li>个人与社会是<strong>对立统一</strong>的关系，两者相互依存、相互制约、相互促进。</li><li>个人与社会的关系，最<strong>根本</strong>的是个人利益与社会利益的关系。</li><li>人的<strong>社会性</strong>决定了人只有在推动社会进步的过程中，才能实现自我的发展。</li></ul></li><li>人生观的主要内容：<ul><li>人生观的主要内容包括对<strong>人生目的、人生态度和人生价值</strong>等问题的根本看法。</li><li>人生目的是人们在社会实践中关于自身行为的根本指向和人生追求，是人生观的<strong>核心</strong>：<ul><li>首先，人生目的决定人生道路。</li><li>其次，人生目的决定人生态度。</li><li>最后，人生目的决定人生价值选择。</li></ul></li><li>人生态度是指人们通过生活事件形成的对人生问题的一种相对稳定的心理倾向和精神状态。</li><li>人生价值是指人的生命及其实践活动对于社会和个人所具有的作用和意义，内在包含自我价值和社会价值，既相互区别，又密切联系、相互依存。</li></ul></li><li>世界观是人们对生活在其中的世界以及人与世界的关系的总体看法和根本观点，世界观决定人生观，有什么样的世界观，就会有什么样的人生观。</li><li>价值观是人们价值的根本观点，对于人生观的形成和发展有重要的引导作用。</li></ul><h2 id="正确的人生观">正确的人生观</h2><ul><li>高尚的人生追求：<ul><li>服务人民、奉献社会的思想以其科学而高尚的品质，代表了人类社会迄今最先进的人生追求。</li></ul></li><li>积极进取的人生态度：<ul><li>人生须<strong>认真</strong>。</li><li>人生当<strong>务实</strong>。</li><li>人生应<strong>乐观</strong>。</li><li>人生要<strong>进取</strong>。</li></ul></li><li>评价人生价值：<ul><li>根本尺度：实践活动是否符合社会的客观规律，是否促进了历史的进步。</li><li>今天的衡量标准：是否用自己的劳动和聪明才智为国家和社会真诚奉献，为人民尽心尽力服务<ul><li>既要看贡献的大小，又要看尽力的程度；</li><li>既要看物质贡献，又要看精神贡献；</li><li>既要看社会贡献，又要看自身完善。</li></ul></li></ul></li><li>人生价值的实现条件：<ul><li>实现人生价值要从社会客观条件出发。</li><li>实现人生价值要从个体自身条件出发。</li><li>不断增强实现人生价值的能力和本领，努力发挥主观能动性。</li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-e682c201" role="button" aria-expanded="false" aria-controls="collapse-e682c201">        <div class="fold-arrow">▶</div>服务人民、奉献社会的人生追求过时了吗？      </div>      <div class="fold-collapse collapse" id="collapse-e682c201">        <div class="fold-content">          <p>在现实生活中有人提出这样的疑惑：社会主义市场经济条件下，讲究的是按劳分配、等价交换，在这种背景下倡导服务人民、奉献社会的人生追求是否合适？换言之，服务人民、奉献社会的人生追求是否过时了？</p><p>社会主义市场经济鼓励人们追求个人的正当利益，因为只有各市场主体的正当利益得到满足，经济才更有活力。但同时，<strong>各市场主体正当利益的满足，不仅有赖于其他人的劳动和付出，而且需要公平有序的市场环境</strong>。</p><p>只有每个个体尽心尽力地为他人、为社会付出应有劳动，才能<strong>保证社会主义市场经济的良好运行</strong>，个体也才能在为社会发展进步<strong>作贡献的同时满足自身利益</strong>。因此，服务人民、奉献社会的人生追求与社会主义市场经济并不矛盾、并未过时。</p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-d37fae99" role="button" aria-expanded="false" aria-controls="collapse-d37fae99">        <div class="fold-arrow">▶</div>当代青年能否选择“躺平”？      </div>      <div class="fold-collapse collapse" id="collapse-d37fae99">        <div class="fold-content">          <p>近年来，“躺平”在年轻人的社交网络上成为一个热词。关于“躺平”一词的确切含义，目前并未形成共识，甚至还有较大争议。“躺平”作为一种生活态度，往往与年轻人在压力面前主动选择放弃、回避与退却有关。个人在法律和道德允许的范围内选择自己生活方式的权利应受到尊重，但当代青年也应深入思考能否把“躺平”作为生活方式和人生道路来选择。</p><p>人们在成长的过程中，总会面临各种各样的现实压力，甚至还会遭遇挫折，以“躺平”的方式<strong>主动退缩、选择放弃，无益于解决问题，甚至会使问题更加复杂和严重</strong>。唯有树立<strong>积极面对、主动进取的人生态度，才能够克服前进道路上的种种困难</strong>。当代青年正处于探索与奋斗的大好时期，应该发扬自强不息、百折不挠的精神，保持年轻人的蓬勃朝气、昂扬锐气，在创新创造、不断奋斗中，成长为实现中华民族伟大复兴的先锋力量。</p>        </div>      </div>    </div><h2 id="创造有意义的人生">创造有意义的人生</h2><ul><li>辩证对待人生矛盾，正确看待：<ul><li>得与失。</li><li>苦与乐。</li><li>顺与逆。</li><li>生与死。</li><li>荣与辱。</li></ul></li><li>反对错误人生观：<ul><li>拜金主义。</li><li>享乐主义。</li><li>极端个人主义。</li></ul>拜金主义、享乐主义、极端个人主义没有正确地把握个人和社会的辩证关系，忽视或者否认社会性是人的存在和活动的本质属性，对人的需要的理解极端、狭隘和片面，其出发点和落脚点都是一己之私利。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c950e4d" role="button" aria-expanded="false" aria-controls="collapse-9c950e4d">        <div class="fold-arrow">▶</div>消费越多，人生就越幸福吗？      </div>      <div class="fold-collapse collapse" id="collapse-9c950e4d">        <div class="fold-content">          <p>有人认为，人生的意义体现为消费的质和量，消费得越多，人生就越幸福。这属于消费主义思潮的一种观点，这种观点是错误的。从人生观层面来看，消费主义思潮把占有和消费物质产品作为个人自我满足和快乐的第一位要求，通过物质的占有和消耗来达到心理上的满足、感官上的享受，把消费当作人生的终极目标，把消费看作人生最大的幸福。受消费主义思潮影响，一些人会产生错误的想法和做法：一是出现超前消费、攀比消费等非理性消费行为；二是产生错误的<strong>价值观</strong>，表现为贪图享乐、爱慕虚荣、功利心作祟等；三是产生错误的<strong>认同</strong>倾向，表现为通过消费来“从众”或“立异”；四是过度被动消费，影响正常工作生活。</p>        </div>      </div>    </div><h1 id="第二章-追求远大理想-坚定崇高信念">第二章 追求远大理想坚定崇高信念</h1><h2 id="理想信念的内涵及重要性">理想信念的内涵及重要性</h2><ul><li>理想的内涵：<ul><li>理想是人们在<strong>实践中形成</strong>的、<strong>有实现可能性的</strong>、对未来社会和自身发展目标的<strong>向往和追求</strong>，是人们的世界观、人生观和价值观在奋斗目标上的集中体现。</li></ul></li><li>特征：<ul><li><strong>超越性</strong>。</li><li><strong>实践性</strong>。</li><li><strong>时代性</strong>。</li></ul></li><li>信念的内涵：<ul><li>信念是人们在<strong>一定的认识基础</strong>上确立的对某种思想或者事物坚信不疑并身体力行的精神状态。</li></ul></li><li>特征：<ul><li><strong>执着性</strong>。</li><li><strong>支撑性</strong>。</li><li><strong>多样性</strong>。</li></ul></li><li>理想信念是精神之“钙”：<ul><li>理想信念昭示奋斗目标。</li><li>理想信念催生前进动力。</li><li>理想信念提供精神支柱。</li><li>理想信念提高精神境界。</li></ul></li></ul><h2 id="坚定信仰信念信心">坚定信仰信念信心</h2><ul><li>对马克思主义、共产主义的<strong>信仰</strong>。</li><li>对中国特色社会主义的<strong>信念</strong>。</li><li>对实现中华民族伟大复兴的<strong>信心</strong>。</li><li>为什么信仰马克思主义？<ul><li>马克思主义是我们认识世界、改造世界的强大思想武器。</li><li>马克思主义是科学的理论，创造性地揭示了人类社会发展规律。</li><li>马克思主义是人民的理论，第一次创立了人民实现自身解放的思想体系（<strong>人民性是马克思主义的本质属性</strong>）。</li><li>马克思主义是实践的理论，指引着人民改造世界的行动。</li><li>马克思主义是不断发展的开放的理论，始终站在时代前沿。</li></ul></li></ul><h2 id="在实现中国梦的实践中放飞青春梦想">在实现中国梦的实践中放飞青春梦想</h2><ul><li>理想与现实对立统一：<ul><li>对立：二者的矛盾与冲突，是“应然”和“实然”的矛盾。</li><li>统一：理想受现实的规定和制约，是在对现实认识的基础上发展起来的（现实孕育理想的发展，理想包含现实的内容）。</li></ul></li><li>实现理想存在<strong>长期性、艰巨性和曲折性</strong>。<strong>艰苦奋斗</strong>是实现理想的重要条件。</li><li>个人理想：<ul><li>处于一定历史条件和社会关系中的个体对于自己未来的物质生活、精神生活所产生的向往和追求</li></ul></li><li>社会理想：<ul><li>社会集体乃至社会全体成员的共同理想，即在全社会占主导地位的共同奋斗目标</li><li>个人理想与社会理想的关系实质上是个人与社会关系在理想层面的反映</li></ul></li><li>个人理想与社会理想：个人与社会有机地联系在一起，二者相互依存、相互制约、共同发展。<ul><li>个人理想以社会理想为指引。</li><li>社会理想是个人理想的汇聚与升华。</li><li>得其大者可以兼其小。</li></ul></li><li>实现中国梦：<ul><li>立鸿鹄志，做奋斗者。</li><li>心怀“国之大者”，敢于担当。</li><li>自觉躬身实践，知行合一。</li></ul></li></ul><h1 id="第三章-继承优良传统-弘扬中国精神">第三章 继承优良传统弘扬中国精神</h1><h2 id="中国精神是兴国强国之魂">中国精神是兴国强国之魂</h2><ul><li>中国精神作为<strong>兴国强国之魂</strong>，是实现中华民族伟大复兴不可或缺的精神支撑。</li><li>崇尚精神是中华民族的优秀传统：<ul><li>中华民族崇尚精神的优秀传统，首先表现为对物质生活与精神生活相互关系的独到理解。</li><li>中华民族崇尚精神的优秀传统，也表现为对理想的不懈追求。</li><li>中华民族崇尚精神的优秀传统，亦表现为对品格养成的重视。</li></ul></li><li>中国精神：<ul><li><strong>伟大创造精神</strong>。</li><li><strong>伟大奋斗精神</strong>。</li><li><strong>伟大团结精神</strong>。</li><li><strong>伟大梦想精神</strong>。</li></ul></li><li><strong>伟大建党精神</strong>是中国共产党的精神之源：坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民。</li><li>全面建设社会主义现代化国家、全面推进中华民族伟大复兴，必须大力弘扬中国精神，弘扬<strong>以爱国主义为核心的民族精神</strong>和<strong>以改革创新为核心的时代精神</strong>。</li><li>爱国主义的基本内涵：<ul><li>一是爱祖国的大好河山。</li><li>二是爱自己的骨肉同胞。</li><li>三是爱祖国的灿烂文化。</li><li>四是爱自己的国家。</li></ul></li><li>时代精神：<ul><li>一个国家和民族在<strong>新的历史条件下</strong>形成和发展的，<strong>体现民族特质</strong>并<strong>顺应时代潮流</strong>的思想观念、价值取向、精神风貌和社会风尚的总和。</li></ul></li><li>弘扬以改革创新为核心的时代精神：<ul><li>就是要树立突破陈规、大胆探索、敢于创造的思想观念。</li><li>就是要培养不甘落后、奋勇争先、追求进步的责任感和使命感。</li><li>就是要保持坚忍不拔、自强不息、锐意进取的精神状态。</li></ul></li></ul><h2 id="做新时代的忠诚爱国者">做新时代的忠诚爱国者</h2><ul><li>必须坚持：<ul><li>爱国爱党爱社会主义相统一</li><li>维护祖国统一和民族团结</li><li>尊重和传承中华民族历史文化</li><li>坚持立足中国又面向世界</li></ul></li><li>怎么做：<ul><li>坚持爱国爱党爱社会主义相统一。</li><li>维护祖国统一和民族团结。</li><li>尊重和传承中华民族历史文化（反对历史虚无主义）。</li><li>坚持立足中国又面向世界。<ul><li>维护国家发展主体性。</li><li>自觉维护国家安全。</li><li>推动构建人类命运共同体。</li></ul></li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5692881c" role="button" aria-expanded="false" aria-controls="collapse-5692881c">        <div class="fold-arrow">▶</div>经济全球化背景下还需要爱国主义吗？      </div>      <div class="fold-collapse collapse" id="collapse-5692881c">        <div class="fold-content">          <p>当今世界，各国的贸易往来更加频繁，文化交流不断加深，世界正在变成一个“地球村”。虽然经济全球化对爱国主义造成了较大冲击，但是爱国主义在今天仍然有其存在的理由。经济全球化是社会生产力发展的客观要求和科技进步的必然结果。在经济全球化背景下，各个国家之间的利益冲突和竞争强度没有减弱，一定程度上还强化了人们的爱国主义情感。经济全球化不等于政治全球化，更不意味着政治一体化，只要国家存在，爱国主义就有坚实的基础和丰富的意义。</p>        </div>      </div>    </div><h2 id="让改革创新成为青春远航的动力">让改革创新成为青春远航的动力</h2><ul><li>现在，我国已转向高质量发展阶段，全面深化改革，推进国家治理体系和治理能力现代化，必须将改革进行到底。</li><li>创新是推动人类社会发展的重要力量。</li><li>创新能力是当今国际竞争新优势的集中体现。</li><li>改革创新是赢得未来的必然要求。</li><li>做改革创新生力军：<ul><li>树立改革创新的自觉意识<ul><li>增强改革创新的责任感。</li><li>树立大胆探索未知领域的信心。</li></ul></li><li>增强改革创新的能力本领<ul><li>夯实创新基础。</li><li>培养创新思维。</li><li>投身改革创新实践。</li></ul></li></ul></li></ul><h1 id="第四章-明确价值要求践行价值准则">第四章明确价值要求践行价值准则</h1><h2 id="全体人民共同的价值追求">全体人民共同的价值追求</h2><ul><li>价值观定义：价值观就是主体对客体有无价值、价值大小的立场和态度，是对价值及其相关内容的基本观点和看法。<ul><li>价值观反映着特定的<strong>时代精神</strong>。</li><li>价值观体现着鲜明的<strong>民族特色</strong>。</li><li>价值观蕴含着特定的<strong>阶级立场</strong>。</li><li>核心价值观是一定社会形态、社会性质的集中体现，在一个社会的思想观念体系中处于<strong>主导地位</strong>，体现着社会制度的阶级属性、社会运行的基本原则和社会发展的基本方向。</li></ul></li><li>社会主义核心价值观三个层面：国家、社会、公民<ul><li>国家层面：富强、民主、文明、和谐。</li><li>社会层面：自由、平等、公正、法治。</li><li>公民层面：爱国、敬业、诚信、友善。</li></ul></li><li>为什么坚持社会主义核心价值观：<ul><li>坚持和发展中国特色社会主义的价值遵循。</li><li>提高国家文化软实力的迫切要求。</li><li>推进社会团结奋进的“最大公约数”。</li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ec3c25c" role="button" aria-expanded="false" aria-controls="collapse-6ec3c25c">        <div class="fold-arrow">▶</div>为什么只有在社会主义社会，人民才有可能真正实现平等？      </div>      <div class="fold-collapse collapse" id="collapse-6ec3c25c">        <div class="fold-content">          <p>存在剥削制度与剥削阶级的社会中，平等不可能真正实现。资本主义私有制是社会分配不公的制度根源，必然导致社会贫富分化和阶级对立。只有在社会主义社会中，生产资料公有制代替私有制，剥削制度不复存在，人民才有真正实现平等的可能。</p>        </div>      </div>    </div><h2 id="社会主义核心价值观的显著特征">社会主义核心价值观的显著特征</h2><ul><li>社会主义核心价值观的显著特征：<strong>先进性、人民性、真实性</strong>。<ul><li><strong>先进性</strong>：反映人类社会发展进步的价值理念<ul><li>体现社会主义的本质属性：“社会主义”是社会主义核心价值观的“底色”社会主义核心价值观的先进性，集中体现在它是社会主义所坚持和追求的价值理念。</li><li>扎根中华优秀传统文化土壤。</li></ul></li><li><strong>人民性</strong>：彰显人民至上的价值立场。人民性是社会主义核心价值观的<strong>根本特性</strong>。<ul><li>尊重人民群众历史主体地位。</li><li>体现以人民为中心的价值导向。</li></ul></li><li><strong>真实性</strong>：因真实可信而具有强大的道义力量（西方“普世价值”在理论和实践上都是虚伪的，我们的全人类共同价值才是可靠的）。<ul><li>社会主义核心价值观是真实可信的。</li><li>认清西方“普世价值”的实质。</li></ul></li></ul></li><li><strong>全人类共同价值</strong>：和平、发展、公平、正义、民主、自由。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-24573d50" role="button" aria-expanded="false" aria-controls="collapse-24573d50">        <div class="fold-arrow">▶</div>全人类共同价值与所谓“普世价值”存在根本不同      </div>      <div class="fold-collapse collapse" id="collapse-24573d50">        <div class="fold-content">          <p>反对西方所谓的“普世价值”，<strong>并不是说人类社会不存在共同价值</strong>。</p><p>2021年7月1日，习近平强调：“中国共产党将继续同一切爱好和平的国家和人民一道，弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，坚持合作、不搞对抗，坚持开放、不搞封闭，坚持互利共赢、不搞零和博弈，反对箱权主义和强权政治，推动历史车轮向着光明的目标前进！”</p><p>人类生活在同一个地球村里，越来越成为你中有我、我中有你的命运共同体，客观存在共同利益，必然要求共同价值。我们所主张的共同价值，是要倡导<strong>求同存异、和而不同</strong>，充分尊重文明的<strong>多样性</strong>，尊重各国<strong>自主选择</strong>社会制度和发展道路的权利。这与<strong>唯我独尊</strong>、<strong>强施于人</strong>、旨在推行<strong>资本主义</strong>政治理念和制度模式的所谓“普世价值”根本不同。</p><ul><li><strong>理论上的虚伪性</strong><ul><li>资产阶级价值观伪装成普世的</li><li>鼓吹抽象“人性论”</li><li>没有放之四海而皆准的价值</li><li>实质是为资产阶级服务</li></ul></li><li><strong>实践上的虚伪性</strong></li></ul>        </div>      </div>    </div><h2 id="积极践行社会主义核心价值观">积极践行社会主义核心价值观</h2><ul><li>把社会主义核心价值观落细落小落实。<ul><li>勤学。下得苦功夫，求得真学问。</li><li>修德。加强道德修养，注重道德实践。</li><li>明辨。善于明辨是非，善于决断选择。</li><li>笃实。扎扎实实干事，踏踏实实做人。</li></ul></li></ul><h1 id="第五章-遵守道德规范-锤炼道德品格">第五章 遵守道德规范锤炼道德品格</h1><h2 id="社会主义道德的核心与原则">社会主义道德的核心与原则</h2><ul><li>道德是一种特殊的社会意识形态，它是以善恶为评价方式，主要依靠社会舆论、传统习俗和内心信念来发挥作用的行为规范的总和。</li><li>道德的起源与本质：<ul><li><strong>劳动</strong>是道德起源的首要前提。</li><li>社会关系是道德赖以产生的客观条件。</li><li>人的自我意识是道德产生的主观条件。</li></ul></li><li>道德是反映社会经济关系的特殊意识形态：<ul><li>其一，道德的性质和基本原则、规范反映了与之相应的社会经济关系的性质和内容。</li><li>其二，道德随着社会经济关系的变化而变化。</li><li>其三，道德作为一种社会意识，在阶级社会里总是反映着一定阶级的利益，因而不可避免地具有阶级性。</li></ul></li><li>道德是社会利益关系的特殊调节方式。</li><li>道德的<strong>功能</strong>：<ul><li><strong>认识</strong>功能。</li><li><strong>规范</strong>功能。</li><li><strong>调节</strong>功能。</li></ul></li><li>道德的<strong>作用</strong>：<ul><li>道德的认识、规范、调节、激励、导向、教育等功能的发挥和实现所产生的社会影响及实际效果。</li></ul></li><li>人类道德发展的历史过程与社会生产方式的发展进程大体一致，这是<strong>道德发展的基本规律</strong>。</li><li>社会主义道德具有显著的先进性特征：<ul><li>首先，社会主义道德是社会主义经济基础的反映。</li><li>其次，社会主义道德是对人类优秀道德资源的批判继承和创新发展。</li><li>最后，社会主义道德克服了以往阶级社会道德的片面性和局限性，坚持以为人民服务为核心，坚持以集体主义为原则，展现出真实而强大的道义力量。</li></ul></li><li><strong>坚持以为人民服务为核心，坚持以集体主义为原则</strong>。</li><li>道德原则是道德规范体系的总纲。</li><li>三个层次的道德：<ul><li>一是无私奉献、一心为公。</li><li>二是先公后私、先人后己。</li><li>三是顾全大局、遵纪守法、热爱祖国、诚实劳动，以正当合法的手段保障个人利益。</li></ul></li></ul><h2 id="吸收借鉴优秀道德成果">吸收借鉴优秀道德成果</h2><ul><li>中华传统美德的基本精神：<ul><li>重视整体利益，强调责任奉献。</li><li>推崇仁爱原则，注重以和为贵。</li><li>注重人伦关系，重视道德义务。</li><li>追求精神境界，向往理想人格。</li><li>强调道德修养，注重道德践履。</li></ul></li><li><strong>传统道德</strong>是一个矛盾体，具有鲜明的两重性：<ul><li>属于精华的部分，表现出积极、革新、进步的一面；</li><li>属于糟粕的部分，则表现出消极、保守、落后的一面。</li></ul></li><li>在对待传统道德的问题上，要反对两种错误思潮。一种是“复古论”，认为道德建设的最终目标就是要恢复中国“固有文化”，形成以中国传统文化为主体的道德体系；另一种是“虚无论”，认为中国传统道德从整体上来说在今天已经失去了价值和意义，必须从整体上予以全盘否定。</li><li>革命道德：<ul><li>为实现社会主义和共产主义的理想而奋斗。</li><li>全心全意为人民服务。</li><li>始终把革命利益放在首位。</li><li>树立社会新风，建立新型人际关系。</li><li>修身自律，保持节操。</li></ul></li><li>革命道德当代价值：<ul><li>有利于加强和巩固社会主义和共产主义的理想信念。</li><li>有利于培育和践行社会主义核心价值观。</li><li>有利于引导人们树立正确的道德观。</li><li>有利于培育良好的社会道德风尚。</li></ul></li></ul><h2 id="投身崇德向善的道德实践">投身崇德向善的道德实践</h2><ul><li>社会公德：<ul><li>每一个社会成员，都应遵守以文明礼貌、助人为乐、爱护公物、保护环境、遵纪守法为主要内容的社会公德。</li></ul></li><li>网络道德：<ul><li>正确使用网络工具。</li><li>加强网络文明自律。</li><li>营造良好网络道德环境。</li></ul></li><li>职业道德：<ul><li>爱岗敬业、诚实守信、办事公道、热情服务和奉献社会是职业生活中的基本道德规范。</li></ul></li><li>家庭美德：<ul><li>注重家庭、注重家教、注重家风，遵守恋爱、婚姻家庭生活中的道德规范，树立正确的恋爱观和婚姻观，有利于大学生的健康成长、顺利成才。</li></ul></li><li>恋爱道德：<ul><li>尊重人格平等、自觉承担责任和文明相亲相爱。</li></ul></li><li>锤炼个人品德：<ul><li>涵养高尚道德品格。</li><li>道德修养重在践行。</li><li>积极引领社会风尚。</li></ul></li></ul><h1 id="第六章-学习法治思想-提升法治素养">第六章 学习法治思想提升法治素养</h1><h2 id="社会主义法律的特征和运行">社会主义法律的特征和运行</h2><ul><li>定义：<ul><li>法律是由<strong>国家制定或认可</strong>并<strong>由国家强制力保证实施</strong>的，反映由特定社会物质生活条件所决定的<strong>统治阶级意志</strong>的规范体系。<ul><li>强制性：法律是<strong>由国家创制和实施的行为规范</strong></li><li>社会性：法律由一定的<strong>社会物质生活条件</strong>所决定</li><li>阶级性：法律是<strong>统治阶级意志</strong>的体现</li></ul></li></ul></li><li>法律不是从来就有的，也不是永恒存在的。它随着私有制、阶级和国家的产生而产生，也将随着私有制、阶级和国家的消亡而消亡。</li><li>我国社会主义法律的本质特征：<ul><li>我国社会主义法律体现了党的主张和人民意志的统一。</li><li>我国社会主义法律具有科学性和先进性。</li><li>我国社会主义法律是中国特色社会主义建设的重要保障。</li></ul></li><li>法律的运行：<ul><li>法律制定<ul><li>全国人民代表大会和全国人民代表大会常务委员会行使国家立法权。</li><li>国务院有权根据宪法和法律制定行政法规。</li><li>国家监察委员会有权根据宪法和法律制定监察法规。</li><li>中央军事委员会有权根据宪法和法律制定军事法规。</li></ul></li><li>法律执行</li><li>法律适用<ul><li>在我国，司法机关是指国家审判机关和检察机关。人民法院依照法律规定独立行使审判权，人民检察院依照法律规定独立行使检察权。</li></ul></li><li>法律遵守</li></ul></li></ul><h2 id="坚持全面依法治国">坚持全面依法治国</h2><ul><li>坚持中国特色社会主义法治道路必须遵循的原则：<ul><li><strong>坚持中国共产党的领导</strong>。</li><li><strong>坚持人民主体地位</strong>。</li><li><strong>坚持法律面前人人平等</strong>。</li><li><strong>坚持依法治国和以德治国相结合</strong>。<ul><li>既要强化道德对法治的支撑作用，重视发挥道德的教化作用，提高全社会文明程度，为全面依法治国创造良好环境；</li><li>又要把道德要求贯彻到法治建设中，以法治承载道德理念。</li></ul></li><li><strong>坚持从中国实际出发</strong>。</li></ul></li><li>建设中国特色社会主义法治体系：<ul><li>完备的法律规范体系。</li><li>高效的法治实施体系。</li><li>严密的法治监督体系。</li><li>有力的法治保障体系。</li><li>完善的党内法规体系。</li></ul></li><li>坚持全面推进科学立法、严格执法、公正司法、全民守法：<ul><li><strong>科学立法</strong>是全面依法治国的<strong>前提</strong>。</li><li><strong>严格执法</strong>是全面依法治国的<strong>关键</strong>。</li><li><strong>公正司法</strong>是全面依法治国的<strong>重点</strong>。</li><li><strong>全民守法</strong>是全面依法治国的<strong>基础</strong>。</li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6229eb14" role="button" aria-expanded="false" aria-controls="collapse-6229eb14">        <div class="fold-arrow">▶</div>为什么说“党大还是法大”是个伪命题?      </div>      <div class="fold-collapse collapse" id="collapse-6229eb14">        <div class="fold-content">          <p>“党大还是法大”是一个<strong>政治陷阱</strong>，是一个<strong>伪命题</strong>。党的领导和依法治国不是对立的，而是<strong>统一</strong>的。我国法律充分体现了党和人民意志，我们党依法办事，这个关系是相互统一的关系。从逻辑上讲，党的本质是<strong>政治组织</strong>，而法的本质是<strong>行为规则</strong>，<strong>两者不存在谁比谁大的问题</strong>，否则就会落入话语陷阱。如果说党比法大，那就是承认法治、依法治国都是虚假的，法就不存在了；如果说法比党大，那党的领导就难以实施了。因此，在党和法之间不能搞简单的比较。</p><p>当然，我们说不存在“党大还是法大”的问题，是把党作为一个<strong>执政整体、就党的执政地位和领导地位而言</strong>的，具体到<strong>每个党政组织、每个领导干部</strong>，就<strong>必须服从和遵守宪法法律</strong>。“权大还是法大”则是一个真命题。纵观人类政治文明史，权力是一把“双刃剑”，在法治的轨道上行使可以造福人民，在法律之外行使必然祸害国家和人民。</p>        </div>      </div>    </div><h2 id="维护宪法权威">维护宪法权威</h2><ul><li>坚持依法治国首先要坚持依宪治国，坚持依法执政首先要坚持依宪执政。</li><li>1954年宪法是中华人民共和国第一部宪法。</li><li>我国现行宪法即1982年宪法。</li><li>我国宪法的地位：<ul><li>我国宪法是国家的<strong>根本法</strong>，是党和人民意志的集中体现。</li><li>我国宪法是国家各项制度和法律法规的总依据。</li><li>我国宪法规定了国家的根本制度。</li><li>宪法是实现国家认同、凝聚社会共识、促进个人发展的基本准则，是维系一个国家、一个民族凝聚力的根本纽带。</li></ul></li><li>我国宪法的基本原则：<ul><li>党的领导原则。</li><li>尊重和保障人权原则。</li><li>社会主义法治原则。</li><li>民主集中制原则。</li></ul></li></ul><h2 id="自觉尊法学法守法用法">自觉尊法学法守法用法</h2><ul><li>法治思维及其内涵：<ul><li>法治思维是指以法治价值和法治精神为导向，运用法律原则、法律规则、法律方法思考和处理问题的思维模式。</li></ul></li><li>法治思维的基本内容：<ul><li>法律至上。</li><li>权力制约。</li><li>公平正义。</li><li>权利保障。</li><li>程序正当。</li></ul></li><li>在社会生活中，每个人既是享受法律权利的主体，又是承担法律义务的主体。<ul><li>在法治国家，不存在只享受权利的主体，也不存在只承担义务的主体。</li><li>法律权利的实现必须以相应法律义务的履行为条件；</li><li>法律义务的设定和履行也必须以法律权利的行使为根据。</li></ul></li><li>我国宪法法律规定的权利：<ul><li>政治权利、宗教信仰自由、人身权利、财产权利、社会经济权利及文化教育权利。</li></ul></li><li>大学生要尊重法律权威、学习法律知识、养成守法习惯、提高用法能力，不断提升自己的法治素养。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 红课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 思修 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率统计</title>
      <link href="/_posts/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
      <url>/_posts/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-随机事件和概率">第一章 随机事件和概率</h1><h2 id="随机事件和运算">随机事件和运算</h2><h3 id="随机试验与随机事件">随机试验与随机事件</h3><h4 id="随机试验">随机试验</h4><ul><li><strong>随机试验</strong>， 简称<strong>试验</strong> <span class="math inline"><em>E</em></span></li><li><strong>性质</strong>：<ul><li>可在相同条件下重复进行</li><li>所有可能结果不止一个， 且在试验前已知</li><li>每次试验结果应在已知所有可能结果中， 且事先无法预知</li></ul></li></ul><h4 id="随机事件">随机事件</h4><ul><li>试验的每个可能的结果为<strong>随机事件</strong>，简称<strong>事件</strong><ul><li>用大写字母表示</li></ul></li><li><strong>必然事件</strong> <span class="math inline">$\it\Omega$</span><ul><li>每次试验必然出现的结果</li></ul></li><li><strong>不可能事件</strong> <span class="math inline">$\it\Phi$</span><ul><li>每次试验必然不出现的结果</li></ul></li><li><strong>基本事件</strong> / <strong>样本点</strong> <span class="math inline"><em>ω</em>，<em>ν</em>，<em>τ</em>，⋯</span><ul><li>一个试验中最简单的单一事件</li><li>非无穷， 无穷可数， 无穷不可数</li></ul></li></ul><h4 id="样本空间-mathitomegas">样本空间 <span class="math inline"><em>Ω</em>/<em>S</em></span></h4><ul><li>所有样本点组成的集合</li><li>随机事件是样本空间的子集<ul><li>样本点在事件 <span class="math inline"><em>A</em></span> 内， <span class="math inline"><em>ω</em> ∈ <em>A</em></span>， 称事件 <span class="math inline"><em>A</em></span> <strong>发生</strong></li><li>否则 <span class="math inline"><em>ω</em> ∉ <em>A</em></span>，称事件 <span class="math inline"><em>A</em></span> 不发生</li></ul></li><li>由于每次试验中 <span class="math inline">$\it\Omega$</span>必然发生， 因此是必然事件</li><li>空集 <span class="math inline">$\it\Phi$</span> 不包含任何样本点，每次试验必不发生，因此是不可能事件</li></ul><h3 id="随机事件关系与运算">随机事件关系与运算</h3><h4 id="关系">关系</h4><ul><li><strong>包含关系</strong><ul><li>事件 <span class="math inline"><em>B</em></span> 发生， 必然导致事件<span class="math inline"><em>A</em></span> 发生， 事件 <span class="math inline"><em>B</em></span> 包含于事件 <span class="math inline"><em>A</em></span>， 事件 <span class="math inline"><em>A</em></span> 包含事件 <span class="math inline"><em>B</em></span></li><li><span class="math inline"><em>B</em> ⊂ <em>A</em>，<em>A</em> ⊃ <em>B</em></span></li></ul></li><li><strong>相等关系</strong><ul><li>若 <span class="math inline"><em>B</em> ⊂ <em>A</em></span> 且 <span class="math inline"><em>A</em> ⊃ <em>B</em></span>， 则称事件 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 相等</li><li><span class="math inline"><em>A</em> = <em>B</em></span></li></ul></li></ul><h4 id="运算">运算</h4><ul><li>事件的<strong>并</strong><ul><li>使得事件 A 与 B 中至少有一个发生的事件， 这个事件称为 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 的<strong>并</strong></li><li><span class="math inline"><em>A</em> ∪ <em>B</em> = {<em>ω</em>&nbsp;|&nbsp;<em>ω</em> ∈ <em>A</em> ∨ <em>ω</em> ∈ <em>B</em>}</span></li></ul></li><li>事件的<strong>交</strong><ul><li>使得事件 A 与 B 同时发生的事件， 这个事件称为 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 的<strong>交</strong></li><li><span class="math inline"><em>A</em> ∩ <em>B</em> = {<em>ω</em>&nbsp;|&nbsp;<em>ω</em> ∈ <em>A</em> ∧ <em>ω</em> ∈ <em>B</em>}</span></li><li>符号可省略， 读作 A 乘 B</li></ul></li><li>事件的<strong>差</strong><ul><li>使得 A 发生而 B 不发生的事件， 这个事件称为 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 的<strong>差</strong></li><li><span class="math inline"><em>A</em> − <em>B</em> = {<em>ω</em>&nbsp;|&nbsp;<em>ω</em> ∈ <em>A</em> ∧ <em>ω</em> ∉ <em>B</em>}</span></li></ul></li><li><strong>对立事件</strong><ul><li>所有不属于事件 A 的基本事件组成的事件， 称为事件 A 的对立事件</li><li><span class="math inline">$\overline{A} = \{\omega\ |\ \omega \in\mathit\Omega \wedge \omega \not\in A\}$</span></li><li>事件与对立事件<ul><li><span class="math inline"><em>A</em> ∪ <em>A</em> = <em>Ω</em></span></li><li><span class="math inline">$A\overline{A} = \varnothing$</span></li><li><span class="math inline">$\overline{\overline{A}} = A$</span></li><li><span class="math inline">$A - B = A\ \overline{B}$</span></li><li>必然事件与不可能事件互斥</li></ul></li></ul></li><li><strong>互不相容</strong><ul><li>若 <span class="math inline"><em>A</em>&nbsp;<em>B</em> = ⌀</span>，称事件 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span><strong>互不相容</strong>或<strong>互斥</strong></li><li>若 <span class="math inline"><em>n</em></span> 个事件两两交集为空，则 <strong><span class="math inline"><em>n</em></span>个事件互不相容</strong></li><li>互为对立的两事件必为互不相容， 反之未必成立</li><li>两事件互不相容， 则两事件的并读作加， <span class="math inline"><em>A</em> ∪ <em>B</em> = <em>A</em> + <em>B</em></span></li></ul></li></ul><h4 id="运算规律">运算规律</h4><ul><li><strong>交换律</strong> <span class="math display">$$  \begin{aligned}  A\cup B &amp;= B\cup A\\  AB&amp;=BA  \end{aligned}$$</span></li><li><strong>结合律</strong> <span class="math display">$$  \begin{aligned}  (A\cup B)\cup C &amp;= A\cup(B\cup C)\\  (AB)C &amp;= A(BC)  \end{aligned}  $$</span></li><li><strong>分配律</strong> <span class="math display">$$  \begin{aligned}  A\cup(BC) &amp;= (A\cup B)(A\cup C)\\  A(B\cup C) &amp;= (AB)\cup(AC)  \end{aligned}  $$</span></li><li><strong>对偶律</strong> (De Morgan 定理)<ul><li>对于两事件 <span class="math display">$$  \begin{aligned}  \overline{A \cup B} &amp;= \overline{A}\ \overline{B}\\  \overline{AB} &amp;= \overline{A}\cup\overline{B}  \end{aligned}  $$</span></li><li>对于 <span class="math inline"><em>n</em></span> 个或无穷事件 <span class="math display">$$  \overline{\bigcup_{i=1}^nA_i}  $$</span></li></ul></li><li><strong>运算顺序</strong>：对立 &gt; 交 &gt; 并 &amp; 差，括号优先</li></ul><h2 id="概率">概率</h2><h3 id="概率的定义">概率的定义</h3><ul><li>随机事件 <span class="math inline"><em>A</em></span>发生可能性大小的数值度量， 称为 <span class="math inline"><em>A</em></span> 的<strong>概率</strong>，记为<span class="math inline"><em>P</em>(<em>A</em>)</span></li><li>设 <span class="math inline"><em>E</em></span> 是一个随机试验，<span class="math inline">$\it \Omega$</span> 是它的样本空间， 对于<span class="math inline"><em>E</em></span> 的每个事件 <span class="math inline"><em>A</em></span> 赋予一个实数， 记为 <span class="math inline"><em>P</em>(<em>A</em>)</span>， 若 <span class="math inline"><em>P</em>(&nbsp;⋅&nbsp;)</span> 满足以下公理：<ol type="1"><li><strong>非负性</strong>：<ul><li>对于每一个事件 <span class="math inline"><em>A</em></span>， 有<span class="math inline"><em>P</em>(<em>A</em>) ≥ 0</span></li></ul></li><li><strong>规范性</strong><ul><li>对于必然事件 <span class="math inline">$\it\Omega$</span>， 有 <span class="math inline">$P(\it \Omega)=1$</span></li></ul></li><li><strong>可列可加性</strong><ul><li>对于两两互不相容的事件 <span class="math inline"><em>A</em><sub>1</sub>，<em>A</em><sub>2</sub>，⋯，<em>A</em><sub><em>n</em></sub>，⋯</span>，即 <span class="math inline"><em>A</em><sub><em>i</em></sub><em>A</em><sub><em>j</em></sub> = ⌀，<em>i</em> ≠ <em>j</em>，<em>i</em>，<em>j</em> = 1，2，⋯</span>，有 <span class="math display">$$P\left(\bigcup_{i=1}^{+\infty}A_i\right)=\sum_{i=1}^{+\infty}P(A_i)$$</span>则称 <span class="math inline"><em>P</em>(<em>A</em>)</span> 为事件<span class="math inline"><em>A</em></span> 的<strong>概率</strong></li></ul></li></ol></li></ul><h3 id="频率的定义">频率的定义</h3><ul><li>如果事件 <span class="math inline"><em>A</em></span> 在 n次重复试验中发生了 m 次， 则称比值 <span class="math inline">$\dfracmn$</span> 为在这 n 次重复试验中事件 A 发生的<strong>频率</strong>，记为 <span class="math display">$$  f_n(A)=\frac mn  $$</span></li><li><strong>性质</strong>：<ol type="1"><li>对于任意事件 A， <span class="math inline">0 ≤ <em>f</em><sub><em>n</em></sub>(<em>A</em>) ≤ 1</span></li><li><span class="math inline"><em>f</em><sub><em>n</em></sub>(<em>Ω</em>) = 1</span></li><li>若事件 <span class="math inline"><em>A</em><sub>1</sub>，<em>A</em><sub>2</sub>，⋯，<em>A</em><sub><em>n</em></sub></span>两两互不相容， 则 <span class="math display">$$f_n\left(\bigcup_{i=1}^{+\infty}A_i\right)=\sum_{i=1}^{+\infty}f_n(A_i)$$</span></li></ol></li></ul><h3 id="统计概率">统计概率</h3><ul><li>设随机试验 A 在 n 次重复试验中发生了 m 次. 当 n 很大时， 频率 <span class="math inline">$f_n(A) = \dfrac mn$</span> 稳定在某一数值 <span class="math inline"><em>p</em>&nbsp;(0 &lt; <em>p</em> &lt; 1)</span>附近波动， 且随着次数增大， 波动幅度越来越小，则称数值 p 为事件 A 的<strong>(统计) 概率</strong></li></ul><h3 id="古典概率">古典概率</h3><ul><li><strong>定义</strong>：满足以下条件：<ul><li>样本空间包含<strong>有限个样本点</strong>， <span class="math inline"><em>Ω</em> = {<em>ω</em><sub>1</sub>，<em>ω</em><sub>2</sub>，⋯，<em>ω</em><sub><em>N</em></sub>}</span></li><li>每个样本点的发生是<strong>等可能</strong>的， <span class="math inline"><em>P</em>(<em>ω</em><sub>1</sub>) = <em>P</em>(<em>ω</em><sub>2</sub>) = ⋯ = <em>P</em>(<em>ω</em><sub><em>N</em></sub>)</span></li></ul></li><li>样本空间为必然事件， <span class="math inline"><em>P</em>(<em>Ω</em>) = 1</span>， 则有 <span class="math display">$$  P\{\omega_i\}=\frac1N  $$</span></li><li>事件 <span class="math inline"><em>A</em> = {<em>ω</em><sub><em>i</em><sub>1</sub></sub>，<em>ω</em><sub><em>i</em><sub>2</sub></sub>，⋯，<em>ω</em><sub><em>i</em><sub><em>M</em></sub></sub>}</span>的概率为 <span class="math display">$$  P(A)=\frac {M}{N} = \frac{A\ 包含样本点个数}{\mathit\Omega\中样本点的总数}  $$</span></li></ul><h3 id="几何概型">几何概型</h3><ul><li><strong>定义</strong>：满足以下条件：<ul><li>样本空间中每个样本点与一个测度有限的几何区域中的点一一对应;</li><li>任意事件 <span class="math inline"><em>A</em></span> 与区域 <span class="math inline"><em>S</em></span> 的一个子区域 <span class="math inline"><em>G</em></span> 对应， A 的概率 <span class="math inline"><em>P</em>(<em>A</em>)</span> 仅与 G 的测度成正比，与 G 的形状与在 S 中的位置无关，即 <span class="math display">$$  P(A)=\frac{m(G)}{m(S)}  $$</span> 其中 <span class="math inline"><em>m</em>(&nbsp;⋅&nbsp;)</span>表示区域的测度</li></ul></li></ul><h3 id="概率基本性质">概率基本性质</h3><ol type="1"><li><p><span class="math display"><em>P</em>(⌀) = 0</span></p></li><li><p><strong>有限可加性</strong>：<span class="math inline"><em>n</em></span> 个事件 <span class="math inline"><em>A</em><sub>1</sub>，<em>A</em><sub>2</sub>，⋯，<em>A</em><sub><em>n</em></sub></span>满足 <span class="math inline"><em>A</em><sub><em>i</em></sub><em>A</em><sub><em>j</em></sub> = ⌀</span>，<span class="math display">$$P\left(\bigcup_{i=1}^{n}A_i\right)=\sum_{i=1}^{n}P(A_i)$$</span></p></li><li><p><strong>对立事件</strong>：对于任意事件， <span class="math display">$$P(\overline A)=1-P(A)$$</span></p></li><li><p><strong>单调不减性</strong>：对于任意两个事件 <span class="math inline"><em>A</em>，<em>B</em></span>， 若 <span class="math inline"><em>A</em> ⊂ <em>B</em></span>， 则有 <span class="math display"><em>P</em>(<em>B</em> − <em>A</em>) = <em>P</em>(<em>B</em>) − <em>P</em>(<em>A</em>)，<em>P</em>(<em>B</em>) ≥ <em>P</em>(<em>A</em>)</span></p></li><li><p><strong>加法定理</strong>：对于任意两个事件 <span class="math inline"><em>A</em>，<em>B</em></span>， <span class="math display"><em>P</em>(<em>A</em> ∪ <em>B</em>) = <em>P</em>(<em>A</em>) + <em>P</em>(<em>B</em>) − <em>P</em>(<em>A</em><em>B</em>)</span></p><p>一般地， 对于 <span class="math inline"><em>n</em></span> 个事件<span class="math inline"><em>A</em><sub>1</sub>，<em>A</em><sub>2</sub>，⋯，<em>A</em><sub><em>n</em></sub></span>，<span class="math display">$$P\left(\bigcup_{i=1}^{n}A_i\right)=\sum_{i=1}^{n}P(A_i)-\sum_{1\lei&lt;j\le n}P(A_iA_j)+\sum_{1\le i&lt;j&lt;k\len}P(A_iA_jA_k)+\cdots+(-1)^{n-1}P(A_1A_2\cdots A_n)$$</span></p><p>右侧共 <span class="math inline">$\sum\limits_{k=1}^nC_k^n =2^n-1$</span> 项</p></li><li><p><strong>事件差</strong>： <span class="math display"><em>P</em>(<em>B</em> − <em>A</em>) = <em>P</em>(<em>B</em>) − <em>P</em>(<em>A</em><em>B</em>)</span></p></li></ol><h2 id="条件概率">条件概率</h2><ul><li>定义：设 A， B 为两事件， <span class="math inline"><em>P</em>(<em>A</em>) &gt; 0</span>， ，则事件 A发生的条件下事件 B 发生的条件概率为 <span class="math display">$$P(B\ |\A) = \frac{P(AB)}{P(A)}$$</span></li><li>当 <span class="math inline"><em>B</em> ⊂ <em>A</em></span>时，<span class="math display">$$P(B\ |\ A) = \frac{P(AB)}{P(A)} =\frac{P(B)}{P(A)}\ge P(B)$$</span></li></ul><h3 id="乘法公式">乘法公式</h3><p><span class="math display">$$\begin{aligned}P(AB) &amp;= P(A)\ P(B\ |\ A)\quad(P(A)&gt;0)\\&amp;=P(B)\ P(A\ |\ B)\quad(P(B)&gt;0)\end{aligned}$$</span></p><p>推广：</p><p><span class="math display"><em>P</em>(<em>A</em><sub>1</sub><em>A</em><sub>2</sub>⋯<em>A</em><sub><em>n</em></sub>) = <em>P</em>(<em>A</em><sub>1</sub>)&nbsp;<em>P</em>(<em>A</em><sub>2</sub>&nbsp;|&nbsp;<em>A</em><sub>1</sub>)⋯<em>P</em>(<em>A</em><sub><em>n</em></sub>&nbsp;|&nbsp;<em>A</em><sub>1</sub><em>A</em><sub>2</sub>⋯<em>A</em><sub><em>n</em> − 1</sub>)  (<em>P</em>(<em>A</em><sub>1</sub><em>A</em><sub>2</sub>⋯<em>A</em><sub><em>n</em> − 1</sub>) &gt; 0)</span></p><h3 id="全概率公式">全概率公式</h3><p>若事件 <span class="math inline"><em>B</em><sub>1</sub>，<em>B</em><sub>2</sub>，⋯，<em>B</em><sub><em>n</em></sub></span>满足</p><p><span class="math display">$$\bigcup_{i=1}^nB_i = \mathit \Omega， B_iB_j = \varnothing$$</span></p><p>称上述事件组为<strong>完备事件组</strong>， 或样本空间 <span class="math inline">$\it \Omega$</span> 的一个<strong>划分</strong></p><p>若事件 <span class="math inline"><em>A</em></span> 落在样本空间内，与划分中的任意一个 <span class="math inline"><em>B</em><sub><em>i</em></sub></span>都有可能有交集， 则事件 <span class="math inline"><em>A</em></span>的概率与划分有关</p><p><span class="math display">$$A = \bigcup_{i=1}^nAB_i，(AB_i)(AB_j) = \varnothing$$</span></p><p>则 <span class="math inline"><em>P</em>(<em>A</em>)</span>的概率可由全概率公式给出</p><p><span class="math display">$$P(A) = \sum_{i=1}^n P(AB_i) = \sum_{i=1}^n P(B_i)\cdot P(A\ |\ B_i)$$</span></p><ul><li>对于 <span class="math inline"><em>A</em></span>的全体的概率被分解为多个部分之和</li><li>事件 <span class="math inline"><em>A</em></span> 的发生由原因 <span class="math inline"><em>B</em><sub><em>i</em></sub></span> 引起， 则<span class="math inline"><em>P</em>(<em>A</em><em>B</em><sub><em>i</em></sub>) = <em>P</em>(<em>B</em><sub><em>i</em></sub>)&nbsp;<em>P</em>(<em>A</em>&nbsp;|&nbsp;<em>B</em><sub><em>i</em></sub>)</span>，事件 <span class="math inline"><em>A</em></span>的全体为所有原因的总和</li></ul><h3 id="bayes-公式">Bayes 公式</h3><p>在事件 <span class="math inline"><em>A</em></span> 已发生的条件下，求导致 <span class="math inline"><em>A</em></span>发生的每个原因的概率， 可由 Bayes 公式求出</p><p><span class="math display">$$\begin{aligned}P(B_k\ |\ A) = \dfrac{P(AB_k)}{P(A)} &amp;= \dfrac{P(B_k)\ P(A\ |\B_k)}{P(A)} \\&amp;= \dfrac{P(B_k)\ P(A\ |\B_k)}{\displaystyle\sum\limits_{i=1}^nP(B_i)\ P(A\ |\ B_i)}\end{aligned}$$</span></p><ul><li><span class="math inline"><em>P</em>(<em>B</em><sub><em>i</em></sub>)</span>先验概率<ul><li>由以往经验得到</li></ul></li><li><span class="math inline"><em>P</em>(<em>B</em><sub><em>i</em></sub>&nbsp;|&nbsp;<em>A</em>)</span>后验概率<ul><li>得到信息：<span class="math inline"><em>A</em></span> 发生的概率后，对 <span class="math inline"><em>A</em></span>发生的原因的可能性大小进行修正</li></ul></li></ul><h2 id="事件的独立性">事件的独立性</h2><ul><li><p><strong>定义</strong>：任意两个事件 <span class="math inline"><em>A</em>，<em>B</em></span>， 若满足 <span class="math display"><em>P</em>(<em>A</em><em>B</em>) = <em>P</em>(<em>A</em>)&nbsp;<em>P</em>(<em>B</em>)</span>则称事件 A 与事件 B 相互独⽴， 简称 A 与 B <strong>独⽴</strong>，即<span class="math display">$$P(A\ |\ B) = P(A) = P(A\ |\ \overlineB)$$</span></p></li><li><p><strong>推广</strong>：若事件 <span class="math inline"><em>A</em><sub>1</sub>，<em>A</em><sub>2</sub>，<em>A</em><sub>3</sub></span>满足 <span class="math display">$$  \begin{aligned}  &amp;\begin{cases}  P(A_1A_2) = P(A_1)\ P(A_2)\\  P(A_1A_3) = P(A_1)\ P(A_3)\\  P(A_2A_3) = P(A_2)\ P(A_3)  \end{cases}\\  &amp;P(A_1A_2A_3) = P(A_1)\ P(A_2)\ P(A_3)  \end{aligned}  $$</span></p><p>则称三个事件<strong>相互独立</strong></p></li><li><p><strong>辨析</strong>：<strong>两两独立</strong>与<strong>相互独立</strong></p></li><li><p><strong>性质</strong></p><ul><li>对称性：两事件相互独立是相互对称的</li><li><span class="math inline"><em>P</em>(<em>A</em>) &gt; 0</span>， 则<span class="math inline"><em>P</em>(<em>B</em>) = <em>P</em>(<em>B</em>&nbsp;|&nbsp;<em>A</em>)</span></li><li><span class="math inline"><em>P</em>(<em>B</em>) &gt; 0</span>， 则<span class="math inline"><em>P</em>(<em>A</em>) = <em>P</em>(<em>A</em>&nbsp;|&nbsp;<em>B</em>)</span></li><li>若 <span class="math inline"><em>P</em>(<em>A</em>)，<em>P</em>(<em>B</em>) &gt; 0</span>，则 “相互独立” 与 “互斥” <strong>不能同时成立</strong><ul><li>若互斥则一个发生另一个必不发生</li></ul></li><li>若四对事件 <span class="math inline">$A，B;A，\overline B; \overlineA， B;\overline A， \overline B$</span> 任意一对事件相互独立，则其余三对也分别相互独立</li><li>若 <span class="math inline"><em>n</em></span> 个事件相互独立，则将这 <span class="math inline"><em>n</em></span> 个事件任意分成 <span class="math inline"><em>k</em></span> 组，同一事件不能同时属于两个不同的组，则对<strong>每组的事件进行求和、积、差、对立等运算</strong>所得到的<span class="math inline"><em>k</em></span>个事件<strong>也相互独立</strong></li></ul></li></ul><h3 id="利用独立事件的性质计算并事件的概率">利用独立事件的性质计算并事件的概率</h3><p>若 <span class="math inline"><em>A</em><sub>1</sub>，<em>A</em><sub>2</sub>，⋯，<em>A</em><sub><em>n</em></sub></span>相互独立， 则 <span class="math display">$$P\left(\bigcup_{i = 1}^nA_i\right) = 1 - \prod_{i = 1}^n(1 - P(A_i))$$</span></p><p>当 <span class="math inline"><em>P</em>(<em>A</em><sub><em>i</em></sub>) = <em>p</em></span>，<span class="math display">$$P\left(\bigcup_{i = 1}^nA_i\right) = 1-(1-p)^n$$</span></p><h3 id="伯努利试验概型">伯努利试验概型</h3><p><span class="math inline"><em>n</em></span> 重伯努利试验概型：</p><ul><li>重复试验 <span class="math inline"><em>n</em></span> 次</li><li>每次试验只有两种可能的结果 <span class="math inline">$A，\overlineA$</span></li><li>每次试验的结果与其它次试验无关：<span class="math inline"><em>n</em></span> 次试验是相互独立的</li></ul><p>事件 <span class="math inline"><em>A</em></span> 出现 <span class="math inline"><em>k</em></span> 的概率， 记为 <span class="math inline"><em>P</em><sub><em>n</em></sub>(<em>k</em>)</span>，若<span class="math inline"><em>P</em>(<em>A</em>) = <em>p</em>，0 &lt; <em>p</em> &lt; 1</span></p><p><span class="math display"><em>P</em><sub><em>n</em></sub>(<em>k</em>) = C<sub><em>n</em></sub><sup><em>k</em></sup>&nbsp;<em>p</em><sup><em>k</em></sup>&nbsp;(1 − <em>p</em>)<sup><em>n</em> − <em>k</em></sup>，  <em>k</em> = 0，1，2，⋯，<em>n</em></span></p><h1 id="第二章-随机变量及其分布">第二章 随机变量及其分布</h1><h2 id="随机变量及其分布函数">随机变量及其分布函数</h2><h3 id="随机变量">随机变量</h3><ul><li><p><strong>定义</strong>：设随机试验的样本空间是 <span class="math inline"><em>Ω</em></span>， 若 <span class="math inline">∀<em>ω</em> ∈ <em>Ω</em></span>， 按⼀定的法则，存在⼀个实数 <span class="math inline"><em>X</em>(<em>ω</em>)</span>与之对应， 则称 <span class="math inline"><em>Ω</em></span>上的实值单值函数 <span class="math inline"><em>X</em>(<em>ω</em>)</span>为<strong>随机变量</strong></p></li><li><p><span class="math inline"><em>X</em></span> 为 <span class="math inline"><em>Ω</em> → ℝ</span> 的一个映射</p><ul><li>定义域为样本空间</li><li>随机性：可能取值不止一个， 试验前只知道所有可能取值，但不知道具体哪一个</li><li>概率特性：随机变量以一定概率取某个值或某些值</li></ul></li></ul><h3 id="随机变量的分布函数">随机变量的分布函数</h3><ul><li><p><strong>定义</strong>：设 <span class="math inline"><em>X</em></span> 为一随机变量， 对于任意实数 <span class="math inline"><em>x</em></span>， 则 <span class="math inline"><em>X</em></span> 的<strong>分布函数</strong>为：<span class="math display"><em>F</em>(<em>x</em>) = <em>P</em>&nbsp;(<em>X</em> ≤ <em>x</em>)，   − ∞ &lt; <em>x</em> &lt; +∞</span></p><p>有时记作 <span class="math inline"><em>F</em><sub><em>X</em></sub>(<em>x</em>)</span></p></li><li><p><strong>性质</strong>：</p><ul><li><span class="math inline"><em>F</em>(<em>x</em>)</span> 单调不减<span class="math display">∀<em>x</em><sub>1</sub> &lt; <em>x</em><sub>2</sub>，<em>F</em>(<em>x</em><sub>1</sub>) ≤ <em>F</em>(<em>x</em><sub>2</sub>)</span></li><li><span class="math inline">0 ≤ <em>F</em>(<em>x</em>) ≤ 1</span>， 且<span class="math display">lim<sub><em>x</em> → +∞</sub><em>F</em>(<em>x</em>) = 1，lim<sub><em>x</em> → −∞</sub><em>F</em>(<em>x</em>) = 0</span></li></ul></li><li><p><strong>用分布函数表示概率</strong> <span class="math display">$$  \begin{aligned}  P(X\le x_0) &amp;= F(x_0)\\  P(X&lt;x_0) &amp;=\lim_{\Delta x\to0_+}P(X\le x_0-\Delta x)\\  &amp;=\lim_{\Delta x\to0_+}F(x_0-\Delta x)\\  &amp;=F(x_0-0)\\  P(X=x_0) &amp;= F(x_0) - F(x_0-0)\\  P(a&lt;X\le b) &amp;= F(b) - F(a)  \end{aligned}  $$</span></p></li></ul><h2 id="离散型随机变量及其分布律">离散型随机变量及其分布律</h2><h3 id="离散型随机变量概率分布">离散型随机变量概率分布</h3><ul><li><strong>定义</strong>：随机变量 <span class="math inline"><em>X</em></span>的可能取值是有限个或可列无穷多个</li><li><strong>分布律</strong>：设离散型随机变量 <span class="math inline"><em>X</em></span> 的所有可能取值为 <span class="math inline"><em>X</em> = <em>x</em><sub><em>k</em></sub>&nbsp;(<em>k</em> = 1，2，⋯)</span>，不妨设 <span class="math inline"><em>x</em><sub>1</sub> &lt; <em>x</em><sub>2</sub> &lt; ⋯</span>，则 <span class="math inline"><em>X</em></span> 的分布律为 <span class="math display"><em>P</em>(<em>X</em> = <em>x</em><sub><em>k</em></sub>) = <em>p</em><sub><em>k</em></sub>，&nbsp;<em>k</em> = 1，2，⋯</span></li><li><strong>性质</strong>：<ol type="1"><li><span class="math display"><em>p</em><sub><em>k</em></sub> ≥ 0，&nbsp;<em>k</em> = 1，2，⋯</span></li><li><span class="math display">$$\sum_{k=1}^{+\infty}p_k =1$$</span></li></ol></li><li><strong>分布函数</strong>：<ul><li><span class="math display"><em>F</em>(<em>x</em>) = <em>P</em>(<em>X</em> ≤ <em>x</em>) = ∑<sub><em>x</em><sub><em>k</em></sub> ≤ <em>x</em></sub><em>P</em>(<em>X</em> = <em>x</em><sub><em>k</em></sub>)</span></li><li><span class="math display"><em>P</em>(<em>X</em> = <em>x</em><sub><em>k</em></sub>) = <em>p</em><sub><em>k</em></sub> = <em>P</em>(<em>x</em><sub><em>k</em> − 1</sub> &lt; <em>X</em> ≤ <em>x</em><sub><em>k</em></sub>) = <em>F</em>(<em>x</em><sub><em>k</em></sub>) − <em>F</em>(<em>x</em><sub><em>k</em> − 1</sub>)</span></li><li><span class="math inline"><em>F</em>(<em>x</em>)</span>为分段阶梯函数</li><li>在 <span class="math inline"><em>X</em></span>的可能取值处存在第一类跳跃间断点</li></ul></li></ul><h3 id="常见离散型随机变量">常见离散型随机变量</h3><h4 id="分布-两点分布">0-1分布 (两点分布)</h4><p>随机变量只有两个可能取值， 分布律由下表所示 <span class="math display">$$\begin{array}{c|cc}\hline\quad X\quad &amp;\quad 1\quad &amp;\quad 0\quad\\\hlineP&amp;p&amp;1-p\\\hline\end{array}$$</span></p><p>其中 <span class="math inline">0 &lt; <em>p</em> &lt; 1</span>， 称<span class="math inline"><em>X</em></span> 服从参数为 <span class="math inline"><em>p</em></span> 的 <strong>0-1分布</strong></p><p>也可写成 <span class="math display"><em>P</em>(<em>X</em> = <em>k</em>) = <em>p</em><sup><em>k</em></sup>&nbsp;(1 − <em>p</em>)<sup>1 − <em>k</em></sup>，&nbsp;<em>k</em> = 0，1</span></p><h4 id="二项分布-伯努利概型">二项分布 (伯努利概型)</h4><ul><li><p><strong><span class="math inline"><em>n</em></span> 重 Bernoulli试验</strong>：</p><ol type="1"><li>可独立地进行 <span class="math inline"><em>n</em></span> 次(可能性互不影响)</li><li>每次试验的结果仅两个， <span class="math inline"><em>A</em></span>和 <span class="math inline">$\overline A$</span></li></ol><p>对应的概型为 <strong>Bernoulli 概型</strong></p></li><li><p><span class="math inline"><em>n</em></span> 重 Bernoulli 试验中，设一次试验中事件 <span class="math inline"><em>A</em></span>发生的概率为 <span class="math inline"><em>P</em>(<em>A</em>) = <em>p</em>&nbsp;(0 &lt; <em>p</em> &lt; 1)</span>，则事件 <span class="math inline"><em>A</em></span> 发生次数 <span class="math inline"><em>X</em></span> 的分布律为 <span class="math display"><em>P</em>(<em>X</em> = <em>k</em>) = C<sub><em>n</em></sub><sup><em>k</em></sup>&nbsp;<em>p</em><sup><em>k</em></sup>&nbsp;(1 − <em>p</em>)<sup><em>n</em> − <em>k</em></sup>，&nbsp;<em>k</em> = 0，1，⋯，<em>n</em></span></p></li><li><p>称 <span class="math inline"><em>X</em></span> 服从参数为 <span class="math inline">(<em>n</em>，<em>p</em>)</span>的<strong>二项分布</strong>， 记为 <span class="math inline"><em>X</em> ∼ <em>B</em>(<em>n</em>，<em>p</em>)</span><span class="math display">$$  P(X&gt;N) = \sum_{k = N+1}^nP(X = k)  $$</span></p></li><li><p><strong>超几何分布的极限分布是二项分布</strong></p></li></ul><h4 id="负二项分布-pascal-分布">负二项分布 (Pascal 分布)</h4><p>进行一个试验直到成功 <span class="math inline"><em>r</em></span> 次，试验进行了 <span class="math inline"><em>k</em></span> 次的分布律 <span class="math display"><em>P</em>(<em>X</em> = <em>k</em>) = C<sub><em>r</em> − 1</sub><sup><em>k</em> − 1</sup>&nbsp;<em>p</em><sup><em>r</em></sup>&nbsp;(1 − <em>p</em>)<sup><em>k</em> − <em>r</em></sup>，&nbsp;<em>k</em> = <em>r</em>，<em>r</em> + 1，⋯</span></p><h4 id="几何分布">几何分布</h4><p>当 <span class="math inline"><em>r</em> = 1</span>， 有几何分布 <span class="math inline"><em>X</em> ∼ <em>G</em>(<em>p</em>)</span> <span class="math display"><em>P</em>(<em>X</em> = <em>k</em>) = (1 − <em>p</em>)<sup><em>k</em> − 1</sup>&nbsp;<em>p</em>，&nbsp;<em>k</em> = 1，2，⋯</span></p><ul><li>求出最可能出现的次数 <span class="math display">$$  \begin{cases}  \dfrac{P_{k-1}}{P_k} = \dfrac{(1-p)\ k}{p\ (n-k+1)}\le1，\\  \dfrac{P_k}{P_{k+1}} = \dfrac{(1-p)\ (k+1)}{p\ (n-k)}\ge1，  \end{cases}  \implies(n+1)\ p-1\le k \le (n+1)\ p  $$</span></li></ul><h4 id="poisson-分布">Poisson 分布</h4><ul><li><p><strong>Poisson 定理</strong>：设 <span class="math inline">$\lim\limits_{n\to+\infty}np_n = \lambda &gt;0$</span>， 则 <span class="math display">$$  \lim_{n\to+\infty}\mathrm C_n^k\ p_n^k\ (1-p_n)^{n-k} = \mathrme^{-\lambda}\ \dfrac{\lambda^k}{k!}，\ k = 0， 1， 2， \cdots  $$</span></p></li><li><p><strong>推论</strong>：假设 <span class="math inline"><em>n</em><em>p</em><sub><em>n</em></sub> = <em>λ</em> &gt; 0&nbsp;(<em>n</em> = 1，2，⋯)</span>，则上述公式仍成立</p></li><li><p>二项分布的极限分布是 Poisson 分布：当二项分布 <span class="math inline"><em>n</em></span> 较大而 <span class="math inline"><em>p</em></span> 较小时 (<span class="math inline"><em>n</em> ≥ 20，<em>p</em> ≤ 0.05</span>)，有如下近似 <span class="math display">$$  P(X&gt;N) = \sum_{k = N+1}^nP(X = k)\approx\sum_{k=N+1}^\infty\mathrme^{-np}\dfrac{(np)^k}{k!} = 1 - \sum_{0}^{N}\mathrme^{-np}\dfrac{(np)^k}{k!}  $$</span></p></li><li><p><strong>Poisson 分布</strong>：设随机变量 <span class="math inline"><em>X</em></span> 的所有可能取值为 <span class="math inline">0，1，2，⋯</span>， 且分布律为 <span class="math display">$$  P(X=k) = \mathrm e^{-\lambda}\ \dfrac{\lambda^k}{k!}，\ k =0，1，2，\cdots  $$</span></p><p>其中 <span class="math inline"><em>λ</em> &gt; 0</span>，称 <span class="math inline"><em>X</em></span> 服从参数为 <span class="math inline"><em>λ</em></span> 的 <strong>Poisson 分布</strong>，记为 <span class="math inline"><em>X</em> ∼ <em>P</em>(<em>λ</em>)</span> 或 <span class="math inline"><em>π</em>(<em>λ</em>)</span></p></li></ul><h2 id="连续型随机变量及其概率密度">连续型随机变量及其概率密度</h2><h3 id="连续性随机变量的概率密度">连续性随机变量的概率密度</h3><ul><li><p><strong>定义</strong>：设 <span class="math inline"><em>X</em></span> 是⼀随机变量， <span class="math inline"><em>F</em>(<em>X</em>)</span> 是它的分布函数，若存在一个非负可积函数 <span class="math inline"><em>f</em>(<em>x</em>)</span> 使得 <span class="math display"><em>F</em>(<em>x</em>) = ∫<sub>−∞</sub><sup><em>x</em></sup><em>f</em>(<em>t</em>)&nbsp;d<em>t</em>， − ∞ &lt; <em>x</em> &lt; +∞</span></p><p>则称 <span class="math inline"><em>X</em></span>为<strong>连续型随机变量</strong>， <span class="math inline"><em>f</em>(<em>x</em>)</span>为它的<strong>概率密度函数</strong>(<strong>概率密度/密度函数</strong>)， <span class="math inline"><em>f</em>(<em>x</em>)</span> 可记为 <span class="math inline"><em>f</em><sub><em>X</em></sub>(<em>x</em>)</span></p></li><li><p>分布函数连续</p></li><li><p>对于一个随机变量 <span class="math inline"><em>X</em></span>，概率密度 <span class="math inline"><em>f</em>(<em>x</em>)</span>不唯一， 允许其在有限或者可列无穷多个点处的函数值不同</p></li><li><p><strong>性质</strong></p><ol type="1"><li>非负性 <span class="math inline"><em>f</em>(<em>x</em>) ≥ 0</span></li><li>规范性 <span class="math inline">∫<sub>−∞</sub><sup>+∞</sup><em>f</em>(<em>x</em>)&nbsp;d<em>x</em> = <em>F</em>(+∞) = 1</span></li><li>在 <span class="math inline"><em>f</em>(<em>x</em>)</span> 的连续点<span class="math inline"><em>x</em></span> 处， 有 <span class="math inline"><em>f</em>(<em>x</em>) = <em>F</em><sup>′</sup>(<em>x</em>)</span></li><li><span class="math inline"><em>f</em>(<em>x</em>)</span> 描述了 <span class="math inline"><em>X</em></span> 在 <span class="math inline"><em>x</em><sub>0</sub></span>附近单位长度的区间内取值的概率， 即 <span class="math inline"><em>P</em>(<em>x</em><sub>0</sub> &lt; <em>X</em> ≤ <em>x</em><sub>0</sub> + <em>Δ</em><em>x</em>) ≈ <em>f</em>(<em>x</em><sub>0</sub>)&nbsp;<em>Δ</em><em>x</em></span></li><li>若 <span class="math inline"><em>a</em></span> 是随机变量 <span class="math inline"><em>X</em></span> 的⼀个可能的取值， 则 <span class="math inline"><em>P</em>(<em>X</em> = <em>a</em>) = 0</span></li><li>对任意实数 <span class="math inline"><em>a</em>，<em>b</em>&nbsp;(<em>a</em> &lt; <em>b</em>)</span>，有 <span class="math display">$$\begin{aligned}P(a &lt; X \le b) &amp;= P(a \le X \le b) = P(a &lt; X &lt; b)\\&amp;= P(a\le X &lt; b) = \int_a^bf(x)\ \mathrm dx\\P(X\le b) &amp;= P(X&lt;b) = \int_{-\infty}^bf(x)\ \mathrm dx\\P(X&gt;a) &amp;= P(X\ge a) = \int_a^{+\infty}f(x)\ \mathrm dx\end{aligned}$$</span></li></ol></li></ul><h3 id="常见连续型随机变量的分布">常见连续型随机变量的分布</h3><h4 id="均匀分布">均匀分布</h4><p><span class="math inline"><em>X</em></span> 服从区间 <span class="math inline">(<em>a</em>，<em>b</em>)</span>上的<strong>均匀分布</strong>， 记为 <span class="math inline"><em>X</em> ∼ <em>U</em>(<em>a</em>，<em>b</em>)</span></p><ul><li><p><strong>密度函数</strong> <span class="math display">$$f(x) = \begin{cases}\dfrac{1}{b-a}，&amp;a&lt;x&lt;b，\\0，&amp;\rmotherwise.\end{cases}$$</span></p></li><li><p><strong>分布函数</strong> <span class="math display">$$F(X) = \begin{cases}0， &amp;x&lt;a，\\\dfrac{x-a}{b-a}，&amp;a\lex&lt;b，\\1，&amp;x\ge b.\end{cases}$$</span></p></li></ul><h4 id="指数分布">指数分布</h4><p><span class="math inline"><em>X</em></span> 服从参数为 <span class="math inline"><em>λ</em></span> 的<strong>指数分布</strong>， 记为<span class="math inline"><em>X</em> ∼ <em>E</em>(<em>λ</em>)</span></p><ul><li><p><strong>密度函数</strong> <span class="math display">$$f(x) = \begin{cases}\lambda\ \mathrm e^{-\lambda\x}，&amp;x&gt;0，\\0，&amp;x\le 0.\\\end{cases}$$</span></p></li><li><p><strong>分布函数</strong> <span class="math display">$$F(x) = \begin{cases}0，&amp;x&lt;0，\\1-\mathrm e^{-\lambda\x}，&amp;x\ge 0.\end{cases}$$</span></p></li><li><p>对任意 <span class="math inline">0 &lt; <em>a</em> &lt; <em>b</em></span>， <span class="math display"><em>P</em>(<em>a</em> &lt; <em>X</em> &lt; <em>b</em>) = e<sup>−<em>λ</em><em>a</em></sup> − e<sup>−<em>λ</em><em>b</em></sup></span></p></li><li><p>指数分布的<strong>无记忆性</strong>：若 <span class="math inline"><em>X</em> ∼ <em>E</em>(<em>λ</em>)</span>，则已经用了<span class="math inline"><em>s</em></span> 小时， 还能用 <span class="math inline"><em>t</em></span> 小时的概率为 <span class="math display"><em>P</em>(<em>X</em> &gt; <em>s</em> + <em>t</em>&nbsp;|&nbsp;<em>X</em> &gt; <em>s</em>) = <em>P</em>(<em>X</em> &gt; <em>t</em>)</span></p></li><li><p>泊松分布与指数分布关系：一段时间内顾客来的概率服从泊松分布，则时间间隔服从指数分布</p></li></ul><h4 id="正态分布-gaussian-分布">正态分布 (Gaussian 分布)</h4><p><span class="math inline"><em>X</em></span> 服从参数为 <span class="math inline"><em>μ</em>，<em>σ</em></span>的<strong>正态分布</strong>， 记为 <span class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>，<em>σ</em><sup>2</sup>)</span></p><ul><li><p><strong>密度函数</strong> <span class="math display">$$f(x) = \dfrac{1}{\sqrt{2\pi}\ \sigma}\exp(-\dfrac{(x-\mu)^2}{2\sigma^2})，\quad-\infty&lt;x&lt;+\infty$$</span></p></li><li><p><strong>性质</strong></p><ol type="1"><li>直线关于 <span class="math inline"><em>x</em> = <em>μ</em></span>对称：<span class="math inline"><em>f</em>(<em>μ</em> + <em>x</em>) = <em>f</em>(<em>μ</em> − <em>x</em>)</span></li><li>最大值 <span class="math inline">$f(\mu) = \dfrac{1}{\sqrt{2\pi}\\sigma}$</span></li><li>渐近线 <span class="math inline"><em>x</em></span> 轴</li><li>拐点 <span class="math inline"><em>x</em> = <em>μ</em> ± <em>σ</em></span></li><li><span class="math inline"><em>σ</em></span><strong>形状参数</strong><ul><li>与曲线陡峭程度成反比</li><li>与数据分散程度成正比</li></ul></li><li><span class="math inline"><em>μ</em></span><strong>位置参数</strong><ul><li>对称轴的位置</li></ul></li></ol></li></ul><h4 id="标准正态分布">标准正态分布</h4><p><span class="math inline"><em>X</em><sup>*</sup> ∼ <em>N</em>(0，1)</span>为<strong>标准正态分布</strong></p><ul><li><p><strong>密度函数</strong> <span class="math display">$$\varphi(x) = \dfrac{1}{\sqrt{2\pi}}\ \mathrme^{-\frac{x^2}{2}}，\quad-\infty&lt;x&lt;+\infty$$</span></p></li><li><p><strong>分布函数</strong> <span class="math display">$$\mathit\Phi(x) = \dfrac{1}{\sqrt{2\pi}}\int_{-\infty}^x\mathrme^{-\frac{t^2}{2}}\ \mathrm dt，\quad-\infty&lt;x&lt;+\infty$$</span></p></li><li><p><strong>性质</strong>：</p><ul><li><span class="math inline"><em>Φ</em>(−<em>x</em>) = 1 − <em>Φ</em>(<em>x</em>)</span></li><li><span class="math inline"><em>P</em>(|&nbsp;<em>X</em><sup>*</sup>&nbsp;| ≤ <em>a</em>) = 2&nbsp;<em>Φ</em>(<em>a</em>) − 1</span></li><li>一般正态分布可以由线性变换 <span class="math inline">$Y=\dfrac{X-\mu}{\sigma}$</span>转化为标准正态分布：若 <span class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>，<em>σ</em><sup>2</sup>)</span>，则 <span class="math inline">$X^* = \dfrac{X-\mu}{\sigma}$</span></li><li>一般正态分布概率的计算可以转化为标准正态分布的概率来计算：若 <span class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>，<em>σ</em><sup>2</sup>)</span>，则 <span class="math inline">$F(x) =\mathit\Phi\left(\dfrac{x-\mu}{\sigma}\right)$</span></li></ul></li></ul><h2 id="随机变量函数的分布">随机变量函数的分布</h2><h3 id="离散型随机变量函数的分布">离散型随机变量函数的分布</h3><ol type="1"><li>列出 <span class="math inline"><em>X</em></span> 的分布律</li><li>直接由 <span class="math inline"><em>X</em></span> 的取值确定 <span class="math inline"><em>Y</em> = <em>g</em>(<em>X</em>)</span>的全部可能取值</li><li>直接由 <span class="math inline"><em>P</em>(<em>X</em><sub><em>i</em></sub>)</span>得到 <span class="math inline"><em>P</em>(<em>Y</em><sub><em>i</em></sub> = <em>g</em>(<em>X</em><sub><em>i</em></sub>))</span>，于是有 <span class="math inline"><em>Y</em></span> 的分布律</li></ol><h3 id="连续型随机变量的分布">连续型随机变量的分布</h3><ol type="1"><li>由分布函数定义 <span class="math inline"><em>F</em><sub><em>Y</em></sub>(<em>y</em>) = <em>P</em>(<em>Y</em> ≤ <em>y</em>) = <em>P</em>(<em>g</em>(<em>X</em>) ≤ <em>y</em>)</span></li><li>对上式变换， <span class="math inline"> = <em>P</em>(<em>X</em> ≤ <em>g</em><sup>−1</sup>(<em>y</em>)) = <em>F</em>(<em>g</em><sup>−1</sup>(<em>y</em>))</span><ul><li>这里有可能会有平方， 变成 <span class="math inline">$P(X^2 \le y) =P(-\sqrt y \le X \le \sqrt y)$</span></li></ul></li><li>将 <span class="math inline"><em>g</em><sup>−1</sup>(<em>y</em>)</span>作为自变量代入 <span class="math inline"><em>F</em>(<em>x</em>)</span>，得到上式左边的 <span class="math inline"><em>F</em><sub><em>Y</em></sub>(<em>y</em>)</span></li><li>对 <span class="math inline"><em>F</em><sub><em>Y</em></sub>(<em>x</em>)</span>求导得到 <span class="math inline"><em>y</em></span> 的密度函数 <span class="math inline"><em>f</em><sub><em>Y</em></sub>(<em>x</em>)</span></li></ol><h3 id="一般性定理">一般性定理</h3><p>设随机变量 <span class="math inline"><em>X</em></span> 具有概率密度<span class="math inline"><em>f</em><sub><em>X</em></sub>(<em>x</em>)， − ∞ &lt; <em>x</em> &lt; +∞</span>，<span class="math inline"><em>g</em>(<em>x</em>)</span> 为 <span class="math inline">(−∞， + ∞)</span> 内的严格单调的可导函数，则随机变量<span class="math inline"><em>Y</em> = <em>g</em>(<em>X</em>)</span>的概率密度为 <span class="math display">$$f_Y(y) = \begin{cases}|\ h'(y)\ |\cdot f_X[\ h(y)\ ]，&amp;\alpha&lt;y&lt; \beta，\\0，&amp;\text{otherwise.}\end{cases}$$</span></p><p>其中：</p><ul><li><span class="math inline"><em>h</em>(<em>y</em>)</span> 是 <span class="math inline"><em>g</em>(<em>x</em>)</span> 的反函数</li><li><span class="math inline"><em>α</em> = min {<em>g</em>(−∞)，<em>g</em>(+∞)}，<em>β</em> = max {<em>g</em>(−∞)，<em>g</em>(+∞)}</span></li></ul><h1 id="第三章-多维随机变量及其分布">第三章 多维随机变量及其分布</h1><h2 id="二维随机变量">二维随机变量</h2><h3 id="二维随机变量及其联合分布函数">二维随机变量及其联合分布函数</h3><ul><li><p><strong>定义</strong>：设 <span class="math inline"><em>E</em></span> 是⼀个随机试验，<span class="math inline"><em>Ω</em></span> 是其样本空间，若对 <span class="math inline"><em>Ω</em></span> 中的任意⼀个样本点 <span class="math inline"><em>ω</em></span> 按照⼀定的对应法则，存在⼀对实数<span class="math inline"><em>X</em>(<em>ω</em>)，<em>Y</em>(<em>ω</em>)</span>与之对应，简记为 <span class="math inline">(<em>X</em>，<em>Y</em>)</span>，称之为<strong>二维随机变量</strong></p></li><li><p><strong>联合分布函数</strong>： <span class="math display"><em>F</em>(<em>x</em>，<em>y</em>) = <em>P</em>({<em>X</em> ≤ <em>x</em>} ∪ {<em>Y</em> ≤ <em>y</em>}) = <em>P</em>(<em>X</em> ≤ <em>x</em>，<em>Y</em> ≤ <em>y</em>)</span></p></li><li><p><strong>性质</strong></p><ol type="1"><li><span class="math inline">0 ≤ <em>F</em>(<em>x</em>，<em>y</em>) ≤ 1</span>，对于任意固定的<span class="math inline"><em>x</em>，<em>y</em></span>，有 <span class="math display"><em>F</em>(−∞，<em>y</em>) = 0，<em>F</em>(<em>x</em>， − ∞) = 0，<em>F</em>(−∞， − ∞) = 0，<em>F</em>(+∞， + ∞) = 1</span></li><li>对 <span class="math inline"><em>F</em>(<em>x</em>，<em>y</em>)</span>固定其中⼀个变量，它关于另⼀个变量是单调不减的函数</li><li>对 <span class="math inline"><em>F</em>(<em>x</em>，<em>y</em>)</span>固定其中⼀个变量，它关于另⼀个变量是右连续函数 <span class="math display"><em>F</em>(<em>x</em> + 0，<em>y</em>) = <em>F</em>(<em>x</em>，<em>y</em>)，  <em>F</em>(<em>x</em>，<em>y</em> + 0) = <em>F</em>(<em>x</em>，<em>y</em>)</span></li><li>对任意实数 <span class="math inline"><em>a</em> &lt; <em>b</em>，<em>c</em> &lt; <em>d</em></span>，(图形为一个矩形)<span class="math display"><em>F</em>(<em>b</em>，<em>d</em>) − <em>F</em>(<em>a</em>，<em>d</em>) − <em>F</em>(<em>b</em>，<em>d</em>) + <em>F</em>(<em>a</em>，<em>c</em>) = <em>P</em>(<em>a</em> &lt; <em>X</em> ≤ <em>b</em>，<em>c</em> &lt; <em>Y</em> ≤ <em>d</em>) ≥ 0</span></li><li>对于平面右上角的一块无穷区域 <span class="math inline">$\bfI$</span>，计算概率时应当将整个平面减去三个区域 <span class="math inline">$\bf II，III，IV$</span> <span class="math display">$$\begin{aligned}P(X&gt; a，Y&gt;c) &amp;= P(a&lt;X&lt;+\infty，c&lt;y&lt;+\infty)\\&amp;=1-F(+\infty，c) - F(a，+\infty)+F(a，c)\\&amp;\neq 1- F(a，c)\end{aligned}$$</span></li></ol></li><li><p><strong>边缘分布函数</strong>：设⼆维随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span> 的分布函数为 <span class="math inline"><em>F</em>(<em>x</em>，<em>y</em>)</span>，分量<span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span>也都是随机变量，各⾃的分布函数分别记为 <span class="math inline"><em>F</em><sub><em>X</em></sub>(<em>x</em>)，<em>F</em><sub><em>Y</em></sub>(<em>y</em>)</span>，并依次称为随机变量<span class="math inline">(<em>X</em>，<em>Y</em>)</span> 关于 <span class="math inline"><em>X</em>，<em>Y</em></span>的<strong>边缘分布函数</strong> <span class="math display">$$  \begin{aligned}  F_X(x) &amp;= P(X\le x) = F(x，+\infty)\\  F_Y(y) &amp;= P(Y\le y) = F(+\infty，y)  \end{aligned}  $$</span></p></li></ul><h3 id="二维离散型随机变量">二维离散型随机变量</h3><ul><li><strong>定义</strong>：随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span>在⼆维平⾯上所有可能的取值为有限对或可列无穷对，则称 <span class="math inline">(<em>X</em>，<em>Y</em>)</span> 为<strong>⼆维离散型随机变量</strong></li><li>设⼆维随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span> 的所有可能取值为<span class="math inline">(<em>x</em><sub><em>i</em></sub>，<em>y</em><sub><em>i</em></sub>)，<em>i</em>，<em>j</em> = 1，2，⋯</span>，则称<span class="math inline"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>，<em>Y</em> = <em>y</em><sub><em>i</em></sub>) = <em>p</em><sub><em>i</em><em>j</em></sub>，<em>i</em> = <em>j</em> = 1，2，⋯</span>为⼆维离散型随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span>的<strong>联合分布律</strong>或联合分布列，简称为<strong>分布律</strong></li></ul><p><span class="math display">$$\begin{array}{c|c|c}\hline P_{ij}&amp;\begin{array}{ccccc}&amp;&amp;X\\\hline \ x_1&amp;\ x_2\ &amp;\cdots &amp;\ x_i\ &amp;\cdots\end{array}&amp;P_{\bullet j} = \displaystyle\sum_i p_{ij}\\\hline\begin{array}{c|c}&amp;\;\;\;y_1\\&amp;\;\;\;y_2\\Y\ \ \&amp;\;\;\;\vdots\\&amp;\;\;\;y_j\\&amp;\;\;\;\vdots\\\end{array}&amp;\begin{array}{ccccc}p_{11}&amp;p_{21}&amp;\cdots&amp;p_{i1}&amp;\cdots\\p_{12}&amp;p_{22}&amp;\cdots&amp;p_{i2}&amp;\cdots\\\vdots&amp;\vdots&amp;&amp;\vdots&amp;\\p_{1j}&amp;p_{2j}&amp;\cdots&amp;p_{ij}&amp;\cdots\\\vdots&amp;\vdots&amp;&amp;\vdots&amp;\\\end{array}&amp;\begin{array}{c}p_{\bullet1}\\p_{\bullet2}\\\vdots\\p_{\bullet j}\\\vdots\end{array}\\\hlinep_{i\bullet} = \displaystyle\sum_{j} p_{ij}&amp;\begin{array}{ccccc}p_{1\bullet}&amp;p_{2\bullet}&amp;\cdots &amp;p_{i\bullet} &amp;\cdots\end{array}&amp;\displaystyle\sum_i\sum_j p_{ij} = 1\\\hline\end{array}$$</span></p><ul><li><strong>性质</strong>：若某数列满足下列性质，则可以作为某个二维离散型随机变量的分布律<ul><li>非负性 <span class="math display"><em>p</em><sub><em>i</em><em>j</em></sub> ≥ 0&nbsp;(<em>i</em>，<em>j</em> = 1，2，⋯)</span></li><li>规范性 <span class="math display">∑<sub><em>i</em></sub>∑<sub><em>j</em></sub><em>p</em><sub><em>i</em><em>j</em></sub> = 1</span></li></ul></li></ul><h4 id="由分布律求分布函数">由分布律求分布函数</h4><p>⼆维离散型随机变量的分布函数与分布律互为确定 <span class="math display">(<em>x</em>，<em>y</em>) = ∑<sub><em>x</em><sub><em>i</em></sub> ≤ <em>x</em></sub>∑<sub><em>y</em><sub><em>j</em></sub> ≤ <em>y</em></sub><em>p</em><sub><em>i</em><em>j</em></sub></span></p><h4 id="二维离散型随机变量的边缘分布律">二维离散型随机变量的边缘分布律</h4><p>以下分别为 <span class="math inline">(<em>X</em>，<em>Y</em>)</span>关于 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span> 的<strong>边缘分布律</strong><span class="math display">$$\begin{aligned}P(X= x_i) &amp;= \sum_j p_{ij} \xlongequal{记为} p_{i\bullet}，\i=1，2，\cdots\\P(Y= y_j) &amp;= \sum_i p_{ij} \xlongequal{记为} p_{\bullet j}，\j=1，2，\cdots\end{aligned}$$</span></p><h3 id="二维连续型随机变量">二维连续型随机变量</h3><ul><li><p><strong>分布函数</strong>：<strong>⼆维连续型随机变量</strong><span class="math inline">(<em>X</em>，<em>Y</em>)</span> 的分布函数<span class="math inline"><em>F</em>(<em>X</em>，<em>Y</em>)</span> 为<span class="math inline">(<em>X</em>，<em>Y</em>)</span>的联合概率密度函数 <span class="math inline"><em>f</em>(<em>x</em>，<em>y</em>)</span>(⼆元⾮负可积函数) 的二重积分 <span class="math display"><em>F</em>(<em>x</em>，<em>y</em>) = ∫<sub>−∞</sub><sup><em>x</em></sup>∫<sub>−∞</sub><sup><em>y</em></sup><em>f</em>(<em>u</em>，<em>v</em>)&nbsp;d<em>u</em>&nbsp;d<em>v</em></span></p></li><li><p><strong>性质</strong>：</p><ol type="1"><li>非负性 <span class="math display"><em>f</em>(<em>x</em>，<em>y</em>) ≥ 0，  (<em>x</em>，<em>y</em>) ∈ ℝ<sup>2</sup></span></li><li>规范性 <span class="math display">∫<sub>−∞</sub><sup>+∞</sup>∫<sub>−∞</sub><sup>+∞</sup><em>f</em>(<em>x</em>，<em>y</em>)&nbsp;d<em>x</em>&nbsp;d<em>y</em> = 1</span></li><li>样本点落在任一区域 <span class="math inline"><em>D</em></span>的概率 <span class="math display">$$P((X，Y)\in D) = \iint\limits_Df(x，y)\ \mathrm dx\ \mathrm dy$$</span></li><li>根据分布函数求概率密度函数 <span class="math inline"><em>f</em>(<em>x</em>，<em>y</em>)</span> 连续点处<span class="math display">$$\dfrac{\partial^2F}{\partial x\ \partial y}= f(x，y)$$</span></li></ol></li><li><p><strong>边缘概率密度</strong>：已知联合分布可以求得边缘分布，反之不能确定<span class="math display">$$  \begin{aligned}  f_X(x) &amp;= \int_{-\infty}^{+\infty}f(x，y)\ \mathrm dy\\  f_Y(y) &amp;= \int_{-\infty}^{+\infty}f(x，y)\ \mathrm dx\\  \end{aligned}  $$</span></p></li></ul><h4 id="常用连续型二维随机变量分布">常用连续型二维随机变量分布</h4><h5 id="均匀分布-1">均匀分布</h5><p>连续型随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span> 服从二维有界区域<span class="math inline"><em>G</em></span>上的<strong>均匀分布</strong>，记为 <span class="math inline">(<em>X</em>，<em>Y</em>) ∼ <em>U</em>(<em>G</em>)</span>，则其概率密度函数为 <span class="math display">$$f(x，y) = \begin{cases}\dfrac{1}{A_G}，&amp;(x，y)\inG，\\0，&amp;\text{otherwise}.\end{cases}$$</span></p><ul><li><span class="math inline"><em>A</em><sub><em>G</em></sub></span> 为<span class="math inline"><em>G</em></span> 的面积</li></ul><h5 id="二维正态分布">二维正态分布</h5><p>连续型随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span> 服从二维有界区域<span class="math inline"><em>G</em></span>上的<strong>二维正态分布</strong>， 记为 <span class="math inline">(<em>X</em>，<em>Y</em>) ∼ <em>N</em>(<em>μ</em><sub>1</sub>，<em>σ</em><sub>1</sub><sup>2</sup>; <em>μ</em><sub>2</sub>，<em>σ</em><sub>2</sub><sup>2</sup>; <em>ρ</em>)</span>，则其概率密度函数为 <span class="math display">$$f(x，y)=\frac{1}{2 \pi \sigma_{1} \sigma_{2} \sqrt{1-\rho^{2}}} \exp\left\{-\frac{1}{2\left(1-\rho^{2}\right)}\left[\frac{\left(x-\mu_{1}\right)^{2}}{\sigma_{1}^{2}}-2\rho \frac{\left(x-\mu_{1}\right)\left(y-\mu_{2}\right)}{\sigma_{1}\sigma_{2}}+\frac{\left(y-\mu_{2}\right)^{2}}{\sigma_{2}^{2}}\right]\right\}$$</span></p><ul><li>二维正态分布的边缘分布为两个独立的一维正态分布</li></ul><h2 id="二维随机变量的条件分布">二维随机变量的条件分布</h2><h3 id="二维离散型随机变量的条件分布">二维离散型随机变量的条件分布</h3><ul><li><strong>定义</strong>：设有⼆维离散型随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span><ul><li>对于固定的 <span class="math inline"><em>j</em></span>，若 <span class="math inline"><em>P</em>(<em>Y</em> = <em>y</em><sub><em>j</em></sub>) &gt; 0</span>，则<strong>在<span class="math inline">{<em>Y</em> = <em>y</em><sub><em>j</em></sub>}</span>的条件下 <span class="math inline"><em>X</em></span>的条件分布律</strong>为 <span class="math display">$$  P(X = x_i\mid Y = y_j) = \dfrac{P(X = x_i，Y = y_j)}{P(Y = y_j)} =\dfrac{p_{ij}}{p_{\bullet j}}，\ i = 1，2，\cdots  $$</span><ul><li><span class="math inline"><em>P</em>(<em>Y</em> = <em>y</em><sub><em>j</em></sub>)</span>即边缘分布律：分布律表格中将 <span class="math inline"><em>Y</em> = <em>y</em><sub><em>j</em></sub></span>一列的概率全部相加</li></ul></li><li>对于固定的 <span class="math inline"><em>i</em></span>，若 <span class="math inline"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>) &gt; 0</span>，则<strong>在<span class="math inline">{<em>X</em> = <em>x</em><sub><em>i</em></sub>}</span>的条件下 <span class="math inline"><em>Y</em></span>的条件分布律</strong>为 <span class="math display">$$  P(Y = y_j\mid X = x_i) = \dfrac{P(X = x_i，Y = y_j)}{P(X = x_i)} =\dfrac{p_{ij}}{p_{i\bullet}}，\ j = 1，2，\cdots  $$</span><ul><li><span class="math inline"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>)</span>即边缘分布律：分布律表格中将 <span class="math inline"><em>X</em> = <em>x</em><sub><em>i</em></sub></span>一行的概率全部相加</li></ul></li></ul></li><li><strong>性质</strong><ol type="1"><li><span class="math display"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub> ∣ <em>Y</em> = <em>y</em><sub><em>j</em></sub>) ≥ 0</span></li><li><span class="math display">$$\displaystyle\sum_iP(X = x_i\mid Y =y_j) = \sum_i\dfrac{p_{ij}}{p_{\bullet j}} =\dfrac{1}{p_{\bulletj}}\sum_ip_{ij} = 1$$</span></li><li>乘法公式 <span class="math display"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>，<em>Y</em> = <em>y</em><sub><em>j</em></sub>) = <em>P</em>(<em>Y</em> = <em>y</em><sub><em>j</em></sub>)&nbsp;<em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub> ∣ <em>Y</em> = <em>y</em><sub><em>j</em></sub>)，&nbsp;<em>i</em>，<em>j</em> = 1，2，⋯</span></li><li>全概率公式 <span class="math display"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>) = ∑<sub><em>j</em></sub><em>P</em>(<em>Y</em> = <em>y</em><sub><em>j</em></sub>)&nbsp;<em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub> ∣ <em>Y</em> = <em>y</em><sub><em>j</em></sub>)，<em>i</em> = 1，2，⋯</span></li></ol></li></ul><h3 id="维连续型随机变量的条件分布">⼆维连续型随机变量的条件分布</h3><ul><li><strong>定义</strong>：设⼆维随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span> 的联合概率密度为<span class="math inline"><em>f</em>(<em>x</em>，<em>y</em>)</span>，<span class="math inline"><em>X</em>，<em>Y</em></span> 的边缘概率密度分别为<span class="math inline"><em>f</em><sub><em>X</em></sub>(<em>x</em>)，<em>f</em><sub><em>Y</em></sub>(<em>y</em>)</span><ul><li>当 <span class="math inline"><em>f</em><sub><em>Y</em></sub>(<em>y</em>) &gt; 0</span>时<ul><li><strong>在 <span class="math inline">{<em>Y</em> = <em>y</em>}</span> 的条件下 <span class="math inline"><em>X</em></span> 的条件概率密度</strong>为 <span class="math display">$$  f_{X\ |\ Y} (x\mid y) = \dfrac{f(x，y)}{f_Y(y)}，\quad-\infty&lt;x&lt;+\infty  $$</span></li><li><strong>在 <span class="math inline">{<em>Y</em> = <em>y</em>}</span> 的条件下 <span class="math inline"><em>X</em></span> 的条件分布函数</strong>为 <span class="math display">$$  F_{X\ |\ Y} (x\mid y) = \int_{-\infty}^x\dfrac{f(u，y)}{f_Y(y)}\\mathrm du，\quad -\infty&lt;x&lt;+\infty  $$</span></li></ul></li><li>当 <span class="math inline"><em>f</em><sub><em>X</em></sub>(<em>x</em>) &gt; 0</span>时<ul><li><strong>在 <span class="math inline">{<em>X</em> = <em>x</em>}</span> 的条件下 <span class="math inline"><em>Y</em></span> 的条件概率密度</strong>为 <span class="math display">$$f_{Y\ |\ X} (y\mid x) =\dfrac{f(x，y)}{f_X(x)}，\quad -\infty&lt;y&lt;+\infty  $$</span></li><li><strong>在 <span class="math inline">{<em>X</em> = <em>x</em>}</span> 的条件下 <span class="math inline"><em>Y</em></span> 的条件分布函数</strong>为 <span class="math display">$$  F_{Y\ |\ X} (y\mid x) = \int_{-\infty}^y\dfrac{f(x，v)}{f_X(x)}\\mathrm dv，\quad -\infty&lt;y&lt;+\infty  $$</span></li></ul></li></ul></li><li><strong>性质</strong>：<ol type="1"><li>类似乘法公式 <span class="math display">$$\begin{aligned}f(x，y) &amp;= f_X(x)\ f_{Y\ |\ X} (y\mid x)\quad f_X(x)&gt;0\\&amp;= f_Y(y)\ f_{X\ |\ Y} (x\mid y)\quad f_Y(y)&gt;0\end{aligned}$$</span></li><li>类似全概率公式 <span class="math display">$$\begin{aligned}f_X(x) &amp;= \int_{-\infty}^{+\infty}f(x，y)\ \mathrm dy =\int_{-\infty}^{+\infty}f_{X\ |\ Y}(x\mid y)\cdot f_Y(y)\ \mathrm dy\\f_Y(y) &amp;= \int_{-\infty}^{+\infty}f(x，y)\ \mathrm dx =\int_{-\infty}^{+\infty}f_{Y\ |\ X}(y\mid x)\cdot f_X(x)\ \mathrm dx\end{aligned}$$</span></li><li>类似 Bayes 公式 <span class="math display">$$\begin{aligned}f_{X \mid Y}(x \mid y)&amp;=\dfrac{f(x，y)}{f_{Y}(y)}=\dfrac{f_{Y \midX}(y \mid x) \cdot f_{X}(x)}{f_{Y}(y)} \\f_{Y \mid X}(y \mid x)&amp;=\dfrac{f(x，y)}{f_{X}(x)}=\dfrac{f_{X \midY}(x \mid y) \cdot f_{Y}(y)}{f_{X}(x)}\end{aligned}$$</span></li></ol></li></ul><h2 id="二维随机变量的独立性">二维随机变量的独立性</h2><ul><li><strong>定义</strong>：相互独立的二维随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span> 对任意 <span class="math inline"><em>x</em>，<em>y</em></span> 都有 <span class="math display"><em>P</em>(<em>X</em> ≤ <em>x</em>，<em>Y</em> ≤ <em>y</em>) = <em>P</em>(<em>X</em> ≤ <em>x</em>)<em>P</em>(<em>Y</em> ≤ <em>y</em>)</span></li><li><strong>判定独立性</strong>：<ul><li><strong>离散型</strong>： <span class="math display"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>，<em>Y</em> = <em>y</em><sub><em>j</em></sub>) = <em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>) ⋅ <em>P</em>(<em>Y</em> = <em>y</em><sub><em>j</em></sub>)</span></li><li><strong>连续型</strong>： <span class="math display"><em>f</em>(<em>x</em>，<em>y</em>) = <em>f</em><sub><em>X</em></sub>(<em>x</em>) ⋅ <em>f</em><sub><em>Y</em></sub>(<em>y</em>)</span></li></ul></li><li><strong>独立性定理</strong>：若联合概率密度分布函数 <span class="math inline"><em>f</em>(<em>x</em>，<em>y</em>)</span>可以写成<strong>两个函数的乘积</strong>，即 <span class="math inline"><em>f</em>(<em>x</em>，<em>y</em>) = <em>r</em>(<em>x</em>) ⋅ <em>g</em>(<em>y</em>)</span>，则 <span class="math inline"><em>X</em>，<em>Y</em></span>相互独立，且有 <span class="math display">$$  \begin{aligned}f_X(x) &amp;=\dfrac{r(x)}{\displaystyle\int_{-\infty}^{+\infty}r(x)\ \mathrm dx}\\  f_Y(y) &amp;= \dfrac{g(y)}{\displaystyle\int_{-\infty}^{+\infty}g(y)\\mathrm dy}  \end{aligned}  $$</span></li><li><strong>性质</strong>：<ol type="1"><li>如果二维随机变量 <span class="math inline"><em>X</em>，<em>Y</em></span> 相互独立，则有 <span class="math display">$$  \begin{aligned}  f_X(x) &amp;= f_{X\ |\ Y}(x\mid y)，\quad f_Y(y)&gt;0\\  f_Y(y) &amp;= f_{Y\ |\ X}(y\mid x)，\quad f_X(x)&gt;0  \end{aligned}  $$</span></li><li><strong>独立的二维随机变量的连续函数仍独立</strong>：设 <span class="math inline"><em>X</em>，<em>Y</em></span>为相互独立的二维随机变量，<span class="math inline"><em>u</em>(<em>x</em>)，<em>v</em>(<em>y</em>)</span>为连续函数，则 <span class="math inline"><em>U</em> = <em>u</em>(<em>X</em>)，<em>V</em> = <em>v</em>(<em>Y</em>)</span>也相互独立</li></ol></li></ul><h2 id="多维随机变量函数的分布">多维随机变量函数的分布</h2><h3 id="多维离散型随机变量函数的分布">多维离散型随机变量函数的分布</h3><p>设 <span class="math inline">(<em>X</em>，<em>Y</em>)</span>的联合分布律为 <span class="math inline"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>，<em>Y</em> = <em>y</em><sub><em>j</em></sub>) = <em>p</em><sub><em>i</em><em>j</em></sub>，(<em>i</em>，<em>j</em> = 1，2，⋯)</span>，<span class="math inline"><em>z</em> = <em>g</em>(<em>x</em>，<em>y</em>)</span>为一个二元函数，<span class="math inline"><em>Z</em> = <em>g</em>(<em>X</em>，<em>Y</em>)</span>为随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span>的函数。</p><p>假设 <span class="math inline"><em>Z</em></span> 的全部不同取值记为<span class="math inline"><em>z</em><sub><em>k</em></sub></span>，并且所有使得<span class="math inline"><em>g</em>(<em>x</em>，<em>y</em>) = <em>z</em><sub><em>k</em></sub></span>的点记为 <span class="math inline">(<em>x</em><sub><em>i</em><sub><em>k</em></sub></sub>，<em>y</em><sub><em>j</em><sub><em>k</em></sub></sub>)</span>，即<span class="math inline"><em>z</em><sub><em>k</em></sub> = <em>g</em>(<em>x</em><sub><em>i</em><sub><em>k</em></sub></sub>，<em>y</em><sub><em>j</em><sub><em>k</em></sub></sub>)</span>，则<span class="math inline"><em>Z</em></span> 的分布律： <span class="math display"><em>P</em>(<em>Z</em> = <em>z</em><sub><em>k</em></sub>) = <em>P</em>(<em>g</em>(<em>X</em>，<em>Y</em>) = <em>z</em><sub><em>k</em></sub>) = ∑<sub><em>g</em>(<em>x</em><sub><em>i</em><sub><em>k</em></sub></sub>，<em>y</em><sub><em>j</em><sub><em>k</em></sub></sub>) = <em>z</em><sub><em>k</em></sub></sub><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em><sub><em>k</em></sub></sub>，<em>Y</em> = <em>y</em><sub><em>j</em><sub><em>k</em></sub></sub>)，&nbsp;<em>k</em> = 1，2，⋯</span></p><ul><li><p>特别地，当 <span class="math inline"><em>Z</em> = <em>X</em> + <em>Y</em></span> 时，<span class="math display">$$  P(Z=r)=P(X+Y=r)=\sum_{i=0}^{r} P(X=i，Y=r-i)  $$</span></p></li><li><p>进一步，当 <span class="math inline"><em>X</em></span> 与 <span class="math inline"><em>Y</em></span> 相互独立时，若 <span class="math inline"><em>P</em>(<em>X</em> = <em>k</em>) = <em>a</em><sub><em>k</em></sub>，<em>P</em>(<em>Y</em> = <em>k</em>) = <em>b</em><sub><em>k</em></sub>，<em>k</em> = 0，1，2，⋯</span>，则<span class="math inline"><em>Z</em> = <em>X</em> + <em>Y</em></span>的分布律满足<strong>离散卷积公式</strong>： <span class="math display">$$  P(Z=r)=\sum_{i=0}^{r} P(X=i) P(Y=r-i)=\sum_{i=0}^{r} a_{i} b_{r-i}  $$</span></p></li><li><p><strong>性质</strong>：</p><ol type="1"><li><strong>Poisson 分布的可加性</strong>：若随机变量 <span class="math inline"><em>X</em>，<em>Y</em></span><strong>相互独立</strong>，且都服从 Poisson 分布，即 <span class="math inline"><em>X</em> ∼ <em>P</em>(<em>λ</em><sub>1</sub>)，<em>Y</em> ∼ <em>P</em>(<em>λ</em><sub>2</sub>)</span>，则<strong>其和也服从Poisson 分布</strong>，即 <span class="math display"><em>X</em> + <em>Y</em> ∼ <em>P</em>(<em>λ</em><sub>1</sub> + <em>λ</em><sub>2</sub>)</span></li><li>⼆<strong>项分布的可加性</strong>：若随机变量 <span class="math inline"><em>X</em>，<em>Y</em></span><strong>相互独立</strong>，且都服从二项分布，即 <span class="math inline"><em>X</em> ∼ <em>B</em>(<em>n</em>，<em>p</em>)，<em>Y</em> ∼ <em>B</em>(<em>m</em>，<em>p</em>)</span>，则<strong>其和也服从二项分布</strong>，即<span class="math display"><em>X</em> + <em>Y</em> ∼ <em>B</em>(<em>n</em> + <em>m</em>，<em>p</em>)</span></li></ol></li></ul><h3 id="多维连续型随机变量函数的分布">多维连续型随机变量函数的分布</h3><p>设 <span class="math inline">(<em>X</em>，<em>Y</em>)</span>的联合概率密度为 <span class="math inline"><em>f</em>(<em>x</em>，<em>y</em>)</span>，<span class="math inline"><em>g</em>(<em>x</em>，<em>y</em>)</span>是一个二元函数，令 <span class="math inline"><em>Z</em> = <em>g</em>(<em>X</em>，<em>Y</em>)</span>，则<span class="math inline"><em>Z</em></span> 的分布函数： <span class="math display">$$F_{Z}(z)=P(Z \le z)=P(g(X，Y) \le z)=\iint\limits_{g(x，y) \le z}f(x，y) \ \mathrm{d} x \ \mathrm{d} y$$</span></p><p>若有非负可积函数 <span class="math inline"><em>f</em><sub><em>Z</em></sub>(<em>z</em>)</span>，使得<span class="math display"><em>F</em><sub><em>Z</em></sub>(<em>z</em>) = ∫<sub>−∞</sub><sup><em>z</em></sup><em>f</em><sub><em>Z</em></sub>(<em>u</em>)&nbsp;d<em>u</em></span></p><p>则随机变量函数 <span class="math inline"><em>Z</em> = <em>g</em>(<em>X</em>，<em>Y</em>)</span>的概率密度为 <span class="math display"><em>f</em><sub><em>Z</em></sub>(<em>z</em>) = <em>F</em><sup>′</sup><sub><em>Z</em></sub>(<em>z</em>)</span></p><h4 id="和的分布">和的分布</h4><p>和的分布：<span class="math inline"><em>Z</em> = <em>X</em> + <em>Y</em></span> <span class="math display"><em>f</em><sub><em>Z</em></sub>(<em>z</em>) = ∫<sub>−∞</sub><sup>+∞</sup><em>f</em>(<em>x</em>，<em>z</em> − <em>x</em>)&nbsp;d<em>x</em> = ∫<sub>−∞</sub><sup>+∞</sup><em>f</em>(<em>z</em> − <em>y</em>，<em>y</em>)&nbsp;d<em>y</em></span></p><p>若 <span class="math inline"><em>X</em>，<em>Y</em></span>相互独立，则 <span class="math display">$$\begin{aligned}f_Z(z) &amp;= \int_{-\infty}^{+\infty}f_X(x)\cdot f_Y(z-x)\ \mathrm dx\\&amp;=  \int_{-\infty}^{+\infty}f_X(z-y)\cdot f_Y(y)\ \mathrm dy\xlongequal{\triangle}f_X * f_Y(z)\end{aligned}$$</span></p><p>函数 <span class="math inline"><em>f</em><sub><em>Z</em></sub>(<em>z</em>)</span>称为称为函数 <span class="math inline"><em>f</em><sub><em>X</em></sub>(<em>x</em>)</span>与 <span class="math inline"><em>f</em><sub><em>Y</em></sub>(<em>y</em>)</span>的<strong>卷积</strong></p><h4 id="线性函数的分布-za-xb-yc">线性函数的分布 <span class="math inline"><em>Z</em> = <em>a</em><em>X</em> + <em>b</em><em>Y</em> + <em>c</em></span></h4><p>更一般地，设 <span class="math inline"><em>Z</em> = <em>a</em><em>X</em> + <em>b</em><em>Y</em> + <em>c</em></span>，<span class="math inline"><em>a</em>，<em>b</em>，<em>c</em></span>为常数，<span class="math inline"><em>a</em>，<em>b</em> ≠ 0</span>，<span class="math display">$$f_{Z}(z)=\frac{1}{|b|} \int_{-\infty}^{+\infty} f\left(t，\frac{z-at-c}{b}\right) \mathrm{d} t=\frac{1}{|a|} \int_{-\infty}^{+\infty}f\left(\frac{z-b t-c}{a}，t\right) \mathrm{d} t$$</span></p><h4 id="商的分布">商的分布</h4><p>商的分布：<span class="math inline">$Z = \dfrac XY$</span> <span class="math display">$$\begin{aligned}F_Z(z) &amp;= P\left(\dfrac XY\le z\right)\\&amp;= \iint\limits_{\frac xy\le z}f(x，y)\ \mathrm dx\ \mathrm dy\\&amp;= \int_0^{+\infty}\mathrm dy\int_{-\infty}^{yz} f(x，y)\ \mathrmdx + \int^0_{-\infty}\mathrm dy\int_{yz}^{+\infty} f(x，y)\ \mathrm dx\end{aligned}$$</span></p><p>概率密度为 <span class="math display"><em>f</em><sub><em>Z</em></sub>(<em>z</em>) = ∫<sub>−∞</sub><sup>+∞</sup><em>f</em>(<em>y</em><em>z</em>，<em>y</em>)&nbsp;|&nbsp;<em>y</em>&nbsp;|&nbsp;d<em>y</em></span></p><p>若 <span class="math inline"><em>X</em>，<em>Y</em></span>相互独立，则 <span class="math display"><em>f</em><sub><em>Z</em></sub>(<em>z</em>) = ∫<sub>−∞</sub><sup>+∞</sup><em>f</em><sub><em>X</em></sub>(<em>y</em><em>z</em>) ⋅ <em>f</em><sub><em>Y</em></sub>(<em>y</em>)&nbsp;|&nbsp;<em>y</em>&nbsp;|&nbsp;d<em>y</em></span></p><h4 id="平方和的分布">平方和的分布</h4><p>平方和的分布：<span class="math inline"><em>Z</em> = <em>X</em><sup>2</sup> + <em>Y</em><sup>2</sup></span><span class="math display">$$f_{Z}(z)=\begin{cases}0，&amp; z&lt;0 \\\dfrac{1}{2} \displaystyle\int_{0}^{2 \pi} f(\sqrt{z} \cos\theta，\sqrt{z} \sin \theta) \mathrm{d} \theta，&amp; z \geqslant 0\end{cases}$$</span></p><h4 id="极值的分布">极值的分布</h4><p>极值的分布：<span class="math inline"><em>M</em> = max {<em>X</em>，<em>Y</em>}，<em>N</em> = min {<em>X</em>，<em>Y</em>}</span></p><ul><li><p>离散型随机变量： <span class="math display">$$\begin{aligned}  P(M = m) &amp;= P(\max\{X，Y\} = m)\\  &amp;= P(X = m，Y \le m) + P(Y = m，X \le m) - P(X = m，Y = m)\\  &amp;= P(X = m)\cdot P(Y \le m) + P(Y = m)\cdot P(X \le m) - P(X =m)\cdot P(Y = m)\\  P(N = n) &amp;= P(\min\{X，Y\} = n)\\  &amp;= P(X = n，Y \ge n) + P(Y = n，X \ge n) - P(X = n，Y = n)\\  &amp;= P(X = n)\cdot P(Y \ge n) + P(Y = n)\cdot P(X \ge n) - P(X =n)\cdot P(Y = n)\\  \end{aligned}  $$</span></p></li><li><p>连续型随机变量：设 <span class="math inline"><em>X</em>，<em>Y</em></span> 相互独立 <span class="math display">$$  \begin{aligned}  F_M(u) &amp;= P(\max\{X，Y\}\le u)\\  &amp;=P(X\le u，Y\le u)\\  &amp;=P(X\le u)\cdot P(Y\le u)\\  &amp;= F_X(u)\cdot F_Y(u)\\  F_N(v) &amp;= P(\min\{X，Y\}\le v)\\  &amp;=1-P(X&gt;v，Y&gt;v)\\&amp;=1-P(X&gt; v)\cdot P(Y&gt; v)\\  &amp;= 1 - \big(1-F_X(v)\big)\cdot \big(1-F_Y(v)\big)  \end{aligned}  $$</span></p></li></ul><h4 id="变量代换法">变量代换法</h4><p>设已知二维随机变量 <span class="math inline">(<em>X</em>，<em>Y</em>)</span> 的概率密度函数 <span class="math inline"><em>f</em><sub><em>X</em><em>Y</em></sub>(<em>x</em>，<em>y</em>)</span>，构造一个新的二维随机变量<span class="math inline">(<em>Z</em>，<em>V</em>)</span>，满足 <span class="math display">$$\begin{cases}Z=g(X，Y) \\V=r(X，Y)\end{cases}$$</span></p><p>设 <span class="math inline">$\begin{cases} z=g(x，y) \\ v=r(x，y)\end{cases}$</span> 存在唯一的反函数 <span class="math inline">$\begin{cases} x=h(z，v)\\y=s(z，v)\end{cases}$</span>，其中 <span class="math inline"><em>h</em>，<em>s</em></span>有连续偏导数，记雅可比行列式 <span class="math display">$$J = \begin{vmatrix}h_z&amp;h_v\\s_z&amp;s_v\end{vmatrix}$$</span></p><p>则 <span class="math display"><em>f</em><sub><em>Z</em><em>V</em></sub>(<em>z</em>，<em>v</em>) = <em>f</em><sub><em>X</em><em>Y</em></sub>(<em>h</em>(<em>z</em>，<em>v</em>)，<em>s</em>(<em>z</em>，<em>v</em>))&nbsp;|&nbsp;<em>J</em>&nbsp;|</span></p><h1 id="第四章-随机变量的数字特征">第四章 随机变量的数字特征</h1><h2 id="数学期望">数学期望</h2><h3 id="数学期望的概念">数学期望的概念</h3><ul><li><strong>离散型随机变量的期望</strong>：设<strong>离散型</strong>随机变量<span class="math inline"><em>X</em></span> 的分布律为<span class="math inline"><em>P</em>(<em>X</em> = <em>x</em><sub><em>k</em></sub>) = <em>p</em><sub><em>k</em></sub>，  <em>k</em> = 1，2，⋯</span>，若级数<span class="math inline">$\displaystyle\sum_{k=1}^{+\infty} x_{k}p_{k}$</span> 绝对收敛，即 <span class="math inline">$\displaystyle\sum_{k=1}^{+\infty}\left|x_{k}\right|p_{k}&lt;+\infty$</span>，则随机变量 <span class="math inline"><em>X</em></span> 的<strong>数学期望</strong>(<strong>均值</strong>) 为 <span class="math display">$$  E(X) = \sum_{k=1}^{+\infty} x_{k} p_{k}  $$</span><ul><li>若级数不绝对收敛，则数学期望不存在</li></ul></li><li><strong>连续型随机变量的期望</strong>：设 <span class="math inline"><em>X</em></span>为<strong>连续型</strong>随机变量，其概率密度为 <span class="math inline"><em>f</em>(<em>x</em>)</span>若 <span class="math inline">∫<sub>−∞</sub><sup>+∞</sup><em>x</em><em>f</em>(<em>x</em>)d<em>x</em></span>绝对收敛，即 <span class="math inline">∫<sub>−∞</sub><sup>+∞</sup>|<em>x</em>|<em>f</em>(<em>x</em>)d<em>x</em> &lt; +∞</span>，则随机变量<span class="math inline"><em>X</em></span> 的<strong>数学期望</strong>(<strong>均值</strong>) 为 <span class="math display"><em>E</em>(<em>X</em>) = ∫<sub>−∞</sub><sup>+∞</sup><em>x</em><em>f</em>(<em>x</em>)d<em>x</em></span></li></ul><h3 id="数学期望的性质">数学期望的性质</h3><ul><li><p><strong>存在性充要条件</strong>：设 <span class="math inline"><em>X</em></span> 是任意随机变量，则 <span class="math inline"><em>X</em></span> 的数学期望存在的充要条件是 <span class="math display"><em>E</em>(|&nbsp;<em>X</em>&nbsp;|) &lt; +∞</span></p></li><li><p><strong>有序性</strong>：设 <span class="math inline"><em>X</em>，<em>Y</em></span>是任意两个数学期望存在的随机变量，且 <span class="math inline"><em>X</em> ≤ <em>Y</em></span>，则 <span class="math display"><em>E</em>(<em>X</em>) ≤ <em>E</em>(<em>Y</em>)</span></p><ul><li>若存在数 <span class="math inline"><em>a</em></span> 使得 <span class="math inline"><em>P</em>(<em>X</em> ≥ <em>a</em>) = 1</span>，则<span class="math display"><em>E</em>(<em>X</em>) ≥ <em>a</em></span></li><li>若存在数 <span class="math inline"><em>b</em></span> 使得 <span class="math inline"><em>P</em>(<em>X</em> ≤ <em>b</em>) = 1</span>，则<span class="math display"><em>E</em>(<em>X</em>) ≤ <em>b</em></span></li></ul></li><li><p><strong>线性性</strong>：</p><ul><li>设 <span class="math inline"><em>X</em></span> 是任意满足 <span class="math inline"><em>E</em>(|&nbsp;<em>X</em>&nbsp;|) &lt; +∞</span>的随机变量，<span class="math inline"><em>C</em></span> 是任意常数，则<span class="math display"><em>E</em>(<em>C</em><em>X</em>) = <em>C</em><em>E</em>(<em>X</em>)</span></li><li>设 <span class="math inline"><em>X</em>，<em>Y</em></span>是<strong>任意</strong>两个数学期望存在的随机变量，则 <span class="math inline"><em>X</em> + <em>Y</em></span> 的数学期望也存在，且<span class="math display"><em>E</em>(<em>X</em> + <em>Y</em>) = <em>E</em>(<em>X</em>) + <em>E</em>(<em>Y</em>)</span></li></ul></li><li><p><strong>正向可乘性</strong>：设 <span class="math inline"><em>X</em>，<em>Y</em></span>是<strong>相互独立</strong>的两个数学期望存在的随机变量，则 <span class="math inline"><em>X</em><em>Y</em></span> 的数学期望也存在，且<span class="math display"><em>E</em>(<em>X</em><em>Y</em>) = <em>E</em>(<em>X</em>)&nbsp;<em>E</em>(<em>Y</em>)</span></p></li><li><p><strong>柯西－施瓦茨不等式</strong>： <span class="math display"><em>E</em><sup>2</sup>(<em>X</em><em>Y</em>) ≤ <em>E</em>(<em>X</em><sup>2</sup>)<em>E</em>(<em>Y</em><sup>2</sup>)</span></p><p>当 <span class="math inline"><em>E</em>(<em>X</em><sup>2</sup>) &gt; 0，<em>E</em>(<em>Y</em><sup>2</sup>) &gt; 0</span>，iff<span class="math inline"><em>P</em>(<em>Y</em> = <em>t</em><sub>0</sub><em>X</em>) = 1</span>时，等式成立</p></li></ul><h3 id="随机变量函数的数学期望">随机变量函数的数学期望</h3><h4 id="一维随机变量">一维随机变量</h4><p>设 <span class="math inline"><em>X</em></span> 为随机变量，<span class="math inline"><em>Y</em> = <em>g</em>(<em>X</em>)</span>，其中<span class="math inline"><em>g</em>(<em>x</em>)</span>是一个确定函数</p><ul><li><p><strong>离散型</strong>：设 <span class="math inline"><em>X</em></span> 为离散型随机变量，其分布律为 <span class="math inline"><em>P</em>(<em>X</em> = <em>x</em><sub><em>k</em></sub>) = <em>p</em><sub><em>k</em></sub>，<em>k</em> = 1，2，⋯</span>，若级数<span class="math inline">$\displaystyle\sum_{k=1}^{+\infty}g\left(x_{k}\right) p_{k}$</span> 绝对收敛，则 <span class="math display">$$  E(Y)=E\big(g(X)\big)=\sum_{k=1}^{+\infty} g\left(x_{k}\right)\  p_{k}  $$</span></p></li><li><p><strong>连续型</strong>：设 <span class="math inline"><em>X</em></span> 为连续型随机变量，其概率密度为<span class="math inline"><em>f</em>(<em>x</em>)</span>，若积分 <span class="math inline">∫<sub>−∞</sub><sup>+∞</sup><em>g</em>(<em>x</em>)<em>f</em>(<em>x</em>)d<em>x</em></span>绝对收敛，则 <span class="math display"><em>E</em>(<em>Y</em>) = <em>E</em>(<em>g</em>(<em>X</em>)) = ∫<sub>−∞</sub><sup>+∞</sup><em>g</em>(<em>x</em>)&nbsp;<em>f</em>(<em>x</em>)&nbsp;d<em>x</em></span></p></li></ul><h4 id="二维随机变量-1">二维随机变量</h4><p>设 <span class="math inline"><em>X</em>，<em>Y</em></span>为随机变量，<span class="math inline"><em>Z</em> = <em>g</em>(<em>X</em>，<em>Y</em>)</span>，其中<span class="math inline"><em>g</em>(<em>x</em>，<em>y</em>)</span>是一个确定函数</p><ul><li><p><strong>离散型</strong>：设 <span class="math inline">(<em>X</em>，<em>Y</em>)</span>为离散型随机变量，其分布律为 <span class="math inline"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>，<em>Y</em> = <em>y</em><sub><em>j</em></sub>) = <em>p</em><sub><em>i</em><em>j</em></sub>，<em>i</em>，<em>j</em> = 1，2，⋯</span>，若级数<span class="math inline">$\displaystyle\sum_{i=1}^{+\infty}\sum_{j=1}^{+\infty} g\left(x_{i}，y_{j}\right) p_{i j}$</span>绝对收敛，则 <span class="math display">$$  E(Z)=E\big(g(X，Y)\big)=\sum_{i=1}^{+\infty} \sum_{j=1}^{+\infty}g\left(x_{i}，y_{j}\right)\ p_{i j}  $$</span></p></li><li><p><strong>连续型</strong>：设 <span class="math inline">(<em>X</em>，<em>Y</em>)</span>为连续型随机变量，其联合概率密度为 <span class="math inline"><em>f</em>(<em>x</em>，<em>y</em>)</span>，若积分<span class="math inline">∫<sub>−∞</sub><sup>+∞</sup>∫<sub>−∞</sub><sup>+∞</sup><em>g</em>(<em>x</em>，<em>y</em>)<em>f</em>(<em>x</em>，<em>y</em>)&nbsp;d<em>x</em>&nbsp;d<em>y</em></span>绝对收敛，则 <span class="math display"><em>E</em>(<em>Z</em>) = <em>E</em>(<em>g</em>(<em>X</em>，<em>Y</em>)) = ∫<sub>−∞</sub><sup>+∞</sup>∫<sub>−∞</sub><sup>+∞</sup><em>g</em>(<em>x</em>，<em>y</em>)&nbsp;<em>f</em>(<em>x</em>，<em>y</em>)&nbsp;d<em>x</em>&nbsp;d<em>y</em></span></p></li></ul><h2 id="方差">方差</h2><h3 id="方差的概念">方差的概念</h3><p>设 <span class="math inline"><em>X</em></span> 是一个随机变量，若<span class="math inline"><em>E</em>{[<em>X</em> − <em>E</em>(<em>X</em>)]<sup>2</sup>}</span>存在，则称其为 <span class="math inline"><em>X</em></span>的<strong>方差</strong>，记为 <span class="math inline"><em>D</em>(<em>X</em>)</span> 或 <span class="math inline"><em>V</em><em>a</em><em>r</em>(<em>X</em>)</span>，即<span class="math display">$$\begin{aligned}D(X)&amp;=E\left\{[X-E(X)]^{2}\right\}\\&amp;=E\left(X^{2}\right)-[E(X)]^{2}\end{aligned}$$</span></p><ul><li><p><strong>离散型</strong>：设 <span class="math inline"><em>X</em></span>为<strong>离散型</strong>随机变量，其分布律为 <span class="math inline"><em>P</em>(<em>X</em> = <em>x</em><sub><em>i</em></sub>) = <em>p</em><sub><em>i</em></sub>，<em>i</em> = 1，2，⋯</span>，则<span class="math display">$$  D(X)=\sum_{i=1}^{+\infty}\left[x_{i}-E(X)\right]^{2} p_{i}  $$</span></p></li><li><p><strong>连续型</strong>：设 <span class="math inline"><em>X</em></span>为<strong>连续型</strong>随机变量，其概率密度为 <span class="math inline"><em>f</em>(<em>x</em>)</span>，则 <span class="math display"><em>D</em>(<em>X</em>) = ∫<sub>−∞</sub><sup>+∞</sup>[<em>x</em> − <em>E</em>(<em>X</em>)]<sup>2</sup><em>f</em>(<em>x</em>)d<em>x</em></span></p></li></ul><h3 id="方差的性质">方差的性质</h3><ul><li><strong>平方线性</strong> <span class="math display"><em>D</em>(<em>a</em><em>X</em> + <em>b</em>) = <em>a</em><sup>2</sup><em>D</em>(<em>X</em>)</span></li><li><strong>常值函数的方差为零</strong> <span class="math display"><em>D</em>(<em>C</em>) = 0</span></li><li><strong>两方差相加</strong> <span class="math display">$$  \begin{aligned}  D(X \pm Y) &amp;=D(X)+D(Y) \pm 2 E((X-E(X))(Y-E(Y)))\\  &amp;=D(X)+D(Y) \pm 2 (E(XY)-E(X)E(Y))\\  &amp;=D(X)+D(Y) \pm 2 \operatorname{Cov}(X， Y)  \end{aligned}  $$</span></li><li><strong>相互独立的随机变量相加</strong> <span class="math display"><em>D</em>(<em>X</em> ± <em>Y</em>) = <em>D</em>(<em>X</em>) + <em>D</em>(<em>Y</em>)</span><ul><li><strong>逆命题不成立</strong></li><li>事实上， 对于任意随机变量， <span class="math inline"><em>D</em>(<em>X</em> ± <em>Y</em>) = <em>D</em>(<em>X</em>) ± 2Cov(<em>X</em>，<em>Y</em>) + <em>D</em>(<em>Y</em>)</span></li><li>当 <span class="math inline"><em>X</em>，<em>Y</em></span> 独立，则其不相关， 协方差为零</li></ul></li><li><strong>方差定义式与意义的扩展</strong>：设 <span class="math inline"><em>X</em></span> 为一个方差存在的随机变量，则对任意实数 <span class="math inline"><em>C</em></span>， 有 <span class="math display"><em>D</em>(<em>X</em>) ≤ <em>E</em>[(<em>X</em> − <em>C</em>)<sup>2</sup>]</span></li><li><strong>方差为零的充要条件</strong>：设 <span class="math inline"><em>X</em></span> 为一个随机变量， <span class="math inline"><em>C</em> = <em>E</em>(<em>X</em>)</span> 为常数<span class="math display"><em>D</em>(<em>X</em>) = 0 ⇔ <em>P</em>(<em>X</em> = <em>C</em>) = 1</span></li></ul><h3 id="标准化随机变量的方差">标准化随机变量的方差</h3><p>对于存在 <span class="math inline"><em>E</em>(<em>X</em>)，<em>D</em>(<em>X</em>) &gt; 0</span>的任意随机变量 <span class="math inline"><em>X</em></span>，有<strong>标准化随机变量</strong> <span class="math display">$$X^{\star}=\frac{X-E(X)}{\sqrt{D(X)}}$$</span></p><ul><li>期望为 0：<span class="math inline"><em>E</em>(<em>X</em><sup>*</sup>) = 0</span></li><li>方差为 1：<span class="math inline"><em>D</em>(<em>X</em><sup>*</sup>) = 1</span></li><li>对于 <span class="math inline"><em>X</em></span> 的线性组合 <span class="math inline"><em>Y</em> = <em>a</em><em>X</em> + <em>b</em></span>，则有<span class="math inline"><em>X</em><sup>*</sup> = <em>Y</em><sup>*</sup></span></li></ul><h2 id="常见分布的期望与方差">常见分布的期望与方差</h2><table><thead><tr><th style="text-align: center;">分布</th><th style="text-align: center;">分布律</th><th style="text-align: center;">期望</th><th style="text-align: center;">方差</th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">0 − 1</span>分布<br><span class="math inline"><em>B</em>(1，<em>p</em>)</span></td><td style="text-align: center;"><span class="math inline"><em>P</em>(<em>X</em> = <em>k</em>) = <em>p</em><sup><em>k</em></sup>&nbsp;(1 − <em>p</em>)<sup>1 − <em>k</em></sup></span><br><span class="math inline"><em>k</em> = 0，1，  0 &lt; <em>p</em> &lt; 1</span></td><td style="text-align: center;"><span class="math inline"><em>p</em></span></td><td style="text-align: center;"><span class="math inline"><em>p</em>&nbsp;(1 − <em>p</em>)</span></td></tr><tr><td style="text-align: center;">二项分布<br><span class="math inline"><em>B</em>(<em>n</em>，<em>p</em>)</span></td><td style="text-align: center;"><span class="math inline"><em>P</em>(<em>X</em> = <em>k</em>) = C<sub><em>n</em></sub><sup><em>k</em></sup>&nbsp;<em>p</em><sup><em>k</em></sup>&nbsp;(1 − <em>p</em>)<sup><em>n</em> − <em>k</em></sup></span><br><span class="math inline"><em>k</em> = 0，1，⋯，<em>n</em>，  0 &lt; <em>p</em> &lt; 1</span></td><td style="text-align: center;"><span class="math inline"><em>n</em><em>p</em></span></td><td style="text-align: center;"><span class="math inline"><em>n</em><em>p</em>&nbsp;(1 − <em>p</em>)</span></td></tr><tr><td style="text-align: center;">泊松分布<br><span class="math inline"><em>P</em>(<em>λ</em>)</span></td><td style="text-align: center;"><span class="math inline">$P(X=k) =\mathrm e^{-\lambda}\ \dfrac{\lambda^k}{k!}$</span><br><span class="math inline"><em>k</em> = 0，1，2，⋯，  <em>λ</em> &gt; 0</span><br></td><td style="text-align: center;"><span class="math inline"><em>λ</em></span></td><td style="text-align: center;"><span class="math inline"><em>λ</em></span></td></tr><tr><td style="text-align: center;">几何分布<br><span class="math inline"><em>G</em>(<em>p</em>)</span></td><td style="text-align: center;"><span class="math inline"><em>P</em>(<em>X</em> = <em>k</em>) = (1 − <em>p</em>)<sup><em>k</em> − 1</sup><em>p</em></span><br><span class="math inline"><em>k</em> = 1，2，⋯，  0 &lt; <em>p</em> &lt; 1</span></td><td style="text-align: center;"><span class="math inline">$\dfrac1p$</span></td><td style="text-align: center;"><span class="math inline">$\dfrac1{p^2}- \dfrac1p$</span></td></tr><tr><td style="text-align: center;">超几何分布<br><span class="math inline"><em>H</em>(<em>n</em>，<em>M</em>，<em>N</em>)</span></td><td style="text-align: center;"><span class="math inline">$P(X = k) =\dfrac{\mathrm C_M^k\ \mathrm C_{N-M}^{n-k}}{\mathrmC_N^n}$</span><br><span class="math inline"><em>k</em> = 0，1，⋯，min (<em>M</em>，<em>n</em>)</span><br><span class="math inline">0 ≤ <em>M</em> ≤ <em>N</em></span></td><td style="text-align: center;"><span class="math inline">$\dfrac{nM}{N}$</span></td><td style="text-align: center;"><span class="math inline">$\dfrac{nM(N-M)}{N^2(N-1)}$</span></td></tr><tr><td style="text-align: center;">负二项分布<br>(Pascal 分布)</td><td style="text-align: center;"><span class="math inline"><em>P</em>(<em>X</em> = <em>k</em>) = C<sub><em>k</em> − 1</sub><sup><em>r</em> − 1</sup>&nbsp;<em>p</em><sup><em>r</em></sup>&nbsp;(1 − <em>p</em>)<sup><em>k</em> − <em>r</em></sup></span><br><span class="math inline"><em>k</em> = <em>r</em>，<em>r</em> + 1，⋯，  0 &lt; <em>p</em> &lt; 1</span></td><td style="text-align: center;"><span class="math inline">$\dfracrp$</span></td><td style="text-align: center;"><span class="math inline">$r\left(\dfrac1{p^2} - \dfrac1p\right)$</span></td></tr><tr><td style="text-align: center;">均匀分布<br><span class="math inline"><em>U</em>(<em>a</em>，<em>b</em>)</span></td><td style="text-align: center;"><span class="math inline">$\displaystylef(x) = \begin{cases}\dfrac{1}{b-a}， &amp;a&lt;x&lt;b，\\0，&amp;\text{otherwise}.\end{cases}$</span></td><td style="text-align: center;"><span class="math inline">$\dfrac{a+b}{2}$</span></td><td style="text-align: center;"><span class="math inline">$\dfrac{(b-a)^2}{12}$</span></td></tr><tr><td style="text-align: center;">指数分布<br><span class="math inline"><em>E</em>(<em>λ</em>)</span></td><td style="text-align: center;"><span class="math inline">$f(x) =\begin{cases}\lambda\ \mathrm e^{-\lambda x}， &amp;x&gt;0，\\0，&amp;\text{otherwise}.\end{cases}$</span></td><td style="text-align: center;"><span class="math inline">$\dfrac1\lambda$</span></td><td style="text-align: center;"><span class="math inline">$\dfrac{1}{\lambda^2}$</span></td></tr><tr><td style="text-align: center;">正态分布<br><span class="math inline"><em>N</em>(<em>μ</em>，<em>σ</em><sup>2</sup>)</span></td><td style="text-align: center;"><span class="math inline">$f(x) =\dfrac{1}{\sqrt{2\pi}\sigma}\exp\left(-\dfrac{(x-\mu)^2}{2\sigma^2}\right)$</span><br><span class="math inline">−∞ &lt; <em>x</em> &lt; +∞， − ∞ &lt; <em>μ</em> &lt; ∞，<em>σ</em> &gt; 0</span></td><td style="text-align: center;"><span class="math inline"><em>μ</em></span></td><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup></span></td></tr></tbody></table><h2 id="协方差与相关系数">协方差与相关系数</h2><h3 id="协方差与相关系数的概念">协方差与相关系数的概念</h3><ul><li><strong>协方差</strong>：随机变量 <span class="math inline"><em>X</em>，<em>Y</em></span> 的协方差为 <span class="math display">Cov(<em>X</em>，<em>Y</em>) = <em>E</em>[(<em>X</em> − <em>E</em>(<em>X</em>))(<em>Y</em> − <em>E</em>(<em>Y</em>))]</span><ul><li><span class="math inline"><em>D</em>(<em>X</em>) = Cov(<em>X</em>，<em>X</em>)</span></li></ul></li><li><strong>相关系数</strong>：当 <span class="math inline"><em>D</em>(<em>X</em>) &gt; 0，<em>D</em>(<em>Y</em>) &gt; 0</span>，则有 <span class="math inline"><em>X</em></span> 与 <span class="math inline"><em>Y</em></span> 的相关系数 <span class="math display">$$  \rho_{X Y}=\frac{\operatorname{Cov}(X，Y)}{\sqrt{D(X)} \sqrt{D(Y)}}  $$</span><ul><li>相关系数为标准化的协方差 <span class="math inline"><em>ρ</em><sub><em>X</em><em>Y</em></sub> = Cov(<em>X</em><sup>*</sup>，<em>Y</em><sup>*</sup>)</span></li><li><span class="math inline"><em>ρ</em><sub><em>X</em><em>Y</em></sub> = 0</span>时， <span class="math inline"><em>X</em></span> 与 <span class="math inline"><em>Y</em></span> <strong>不相关</strong></li></ul></li><li><strong>协方差矩阵</strong> <span class="math display">$$  \left(\begin{array}{cc}  D(X) &amp; \operatorname{Cov}(X， Y) \\  \operatorname{Cov}(X， Y) &amp; D(Y)  \end{array}\right)  $$</span></li></ul><h3 id="协方差的计算">协方差的计算</h3><ul><li><strong>定义</strong>： <span class="math display">$$  \begin{aligned}  \operatorname{Cov}(X，Y)&amp;=E(X Y)-E(X) E(Y)\\  D(X \pm Y)&amp;=D(X)+D(Y) \pm 2 \operatorname{Cov}(X， Y)  \end{aligned}  $$</span></li><li><strong>离散型</strong>： <span class="math display">$$  \operatorname{Cov}(X，Y)=\sum_{i=1}^{+\infty}\sum_{j=1}^{+\infty}\left[x_{i}-E(X)\right]\left[y_{j}-E(Y)\right] p_{ij}  $$</span></li><li><strong>连续型</strong>：<ul><li>设 <span class="math inline"><em>X</em>，<em>Y</em></span>的联合概率密度为 <span class="math inline"><em>f</em>(<em>x</em>，<em>y</em>)</span>，则 <span class="math display">$$  \begin{aligned}  \operatorname{Cov}(X，Y)&amp;=E(XY)-E(X)E(Y)\\  &amp;=\int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} x y f(x，y)\mathrm{d} x \mathrm{d} y - E(X)E(Y)\\  &amp;=\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}[x-E(X)][y-E(Y)] f(x，y) \mathrm{d} x \mathrm{d}y\\  \end{aligned}  $$</span></li></ul></li></ul><h3 id="协方差的性质">协方差的性质</h3><ul><li><strong>可换性</strong>： <span class="math display">Cov (<em>X</em>，<em>Y</em>) = Cov (<em>Y</em>，<em>X</em>)</span></li><li><strong>变量与常数的协方差</strong>： <span class="math display">Cov (<em>X</em>，<em>C</em>) = 0</span></li><li><strong>变量与自己的协方差为方差</strong>： <span class="math display">Cov(<em>X</em>，<em>X</em>) = <em>D</em>(<em>X</em>)</span></li><li><strong>线性性</strong>： <span class="math display">$$  \begin{aligned}  \operatorname{Cov}(a X，b Y)&amp;=a b \operatorname{Cov}(X，Y)\\  \operatorname{Cov}(X，Y)&amp;=\operatorname{Cov}(X-a，Y-b)  \end{aligned}  $$</span></li><li><strong>线性可加性</strong>： <span class="math display">Cov (<em>X</em> + <em>Y</em>，<em>Z</em>) = Cov (<em>X</em>，<em>Z</em>) + Cov (<em>Y</em>，<em>Z</em>)</span></li><li><strong>柯西施瓦茨不等式</strong>： <span class="math display">$$  |\operatorname{Cov}(X，Y)| \leqslant \sqrt{D(X)} \sqrt{D(Y)}  $$</span></li></ul><h3 id="相关系数的性质">相关系数的性质</h3><ul><li><strong>规范性</strong>： <span class="math display">|<em>ρ</em><sub><em>X</em><em>Y</em></sub>| ≤ 1</span></li><li><strong>随机变量完全相关</strong>： <span class="math display">|<em>ρ</em><sub><em>X</em><em>Y</em></sub>| = 1 ⇔ <em>P</em>(<em>Y</em><sup>*</sup> = ±<em>X</em><sup>*</sup>) = 1</span><ul><li><span class="math inline"><em>ρ</em><sub><em>X</em><em>Y</em></sub> = 1 ⇔ <em>P</em>(<em>Y</em><sup>*</sup> = <em>X</em><sup>*</sup>) = 1</span>此时 <span class="math inline"><em>X</em>，<em>Y</em></span><strong>完全正相关</strong></li><li><span class="math inline"><em>ρ</em><sub><em>X</em><em>Y</em></sub> = −1 ⇔ <em>P</em>(<em>Y</em><sup>*</sup> = −<em>X</em><sup>*</sup>) = 1</span>此时 <span class="math inline"><em>X</em>，<em>Y</em></span><strong>完全负相关</strong></li><li>即 <span class="math inline">|<em>ρ</em><sub><em>X</em><em>Y</em></sub>|</span>反映了由 <span class="math inline"><em>X</em></span> 的线性函数 <span class="math inline"><em>a</em><em>X</em> + <em>b</em></span> 估计 <span class="math inline"><em>Y</em></span> 所产生的均方误差的大小</li></ul></li><li><strong>均方误差</strong>： <span class="math display">$$  \min\limits_{a，b} E\left\{\left[Y - (a + bX) \right]^2\right\}=E\left\{\left[Y - (a_0 + b_0X) \right]^2\right\}=\left(1 -\rho_{XY}^2\right) D(Y)  $$</span><ul><li><span class="math inline">$b_0 =\dfrac{\mathrm{Cov}(X，Y)}{D(X)}$</span></li><li><span class="math inline"><em>a</em><sub>0</sub> = <em>E</em>(<em>Y</em>) − <em>b</em><sub>0</sub><em>E</em>(<em>X</em>)</span></li><li>均方误差为关于 <span class="math inline">|&nbsp;<em>ρ</em><sub><em>X</em><em>Y</em></sub>&nbsp;|</span>的严格递减函数</li></ul></li></ul><h2 id="随机变量的高阶矩">随机变量的高阶矩</h2><h3 id="原点矩与中心矩">原点矩与中心矩</h3><ul><li><strong>原点矩</strong>：设 <span class="math inline"><em>X</em>，<em>Y</em></span> 都是随机变量，若 <span class="math inline"><em>E</em>(|<em>X</em>|<sup><em>k</em></sup>) &lt; +∞(<em>k</em> = 1，2，⋯)</span>，则 <span class="math inline"><em>X</em></span> 的 <strong><span class="math inline"><strong>k</strong></span> 阶原点矩</strong> 为 <span class="math display"><em>E</em>(<em>X</em><sup><em>k</em></sup>)</span></li><li><strong>中心矩</strong>：设 <span class="math inline"><em>X</em></span> 是一个随机变量，若 <span class="math inline"><em>E</em>(|<em>X</em>|<sup><em>k</em></sup>) &lt; +∞(<em>k</em> = 1，2，⋯)</span>，则 <span class="math inline"><em>X</em></span> 的 <strong><span class="math inline"><strong>k</strong></span> 阶原点矩</strong> 为 <span class="math display"><em>E</em>{[&nbsp;<em>X</em> − <em>E</em>(<em>X</em>)&nbsp;]<sup><em>k</em></sup>}</span></li><li><strong>混合原点矩与混合中心矩</strong>：设 <span class="math inline"><em>X</em>，<em>Y</em></span> 都是随机变量，且 <span class="math inline"><em>E</em>(|<em>X</em>|<sup><em>k</em></sup>|<em>Y</em>|<sup><em>l</em></sup>) &lt; +∞(<em>k</em>，<em>l</em> = 1，2，⋯)</span>，若 <span class="math inline"><em>E</em>(|<em>X</em>|<sup><em>k</em></sup>|<em>Y</em>|<sup><em>l</em></sup>) &lt; +∞(<em>k</em>，<em>l</em> = 1，2，⋯)</span>，则<ul><li><span class="math inline"><em>X</em>，<em>Y</em></span> 的<strong><span class="math inline"><strong>k</strong> <strong>+</strong> <strong>l</strong></span>阶混合原点矩</strong> 为 <span class="math display"><em>E</em>(<em>X</em><sup><em>k</em></sup><em>Y</em><sup><em>l</em></sup>)</span></li><li><span class="math inline"><em>X</em>，<em>Y</em></span> 的<strong><span class="math inline"><strong>k</strong> <strong>+</strong> <strong>l</strong></span>阶混合中心矩</strong> 为 <span class="math display"><em>E</em>{[<em>X</em> − <em>E</em>(<em>X</em>)]<sup><em>k</em></sup>[<em>Y</em> − <em>E</em>(<em>Y</em>)]<sup><em>l</em></sup>}</span></li></ul></li></ul><h3 id="协方差矩阵">协方差矩阵</h3><ul><li><p><strong>定义</strong>：设 <span class="math inline">(<em>X</em><sub>1</sub>，<em>X</em><sub>2</sub>，⋯，<em>X</em><sub><em>n</em></sub>)</span>是 <span class="math inline"><em>n</em></span> 维随机变量，且其分别都存在二阶矩， 记 <span class="math inline"><em>c</em><sub><em>i</em><em>j</em></sub> = cov (<em>X</em><sub><em>i</em></sub>，<em>X</em><sub><em>j</em></sub>)，<em>i</em>，<em>j</em> = 1，2，⋯，<em>n</em></span>，则 <span class="math inline"><em>n</em></span>维随机变量的<strong>协方差矩阵</strong>为 <span class="math display">$$\boldsymbol{C}=\begin{pmatrix}c_{11} &amp; c_{12} &amp; \cdots &amp; c_{1 n} \\c_{21} &amp; c_{22} &amp; \cdots &amp; c_{2 n} \\\vdots &amp; \vdots &amp; &amp; \vdots \\c_{n 1} &amp; c_{n 2} &amp; \cdots &amp; c_{n n}\end{pmatrix}$$</span></p></li><li><p><strong>性质</strong>：</p><ol type="1"><li><span class="math inline"><strong>C</strong></span> 为对称矩阵，因为 <span class="math inline"><em>c</em><sub><em>i</em><em>j</em></sub> = <em>c</em><sub><em>j</em><em>i</em></sub></span></li><li><span class="math inline"><strong>C</strong></span>为半正定矩阵</li><li>对任意实数 <span class="math inline"><em>t</em><sub>1</sub>，<em>t</em><sub>2</sub>，⋯，<em>t</em><sub><em>n</em></sub></span>，<span class="math display">$$D\left(t_{1} X_{1}+t_{2} X_{2}+\cdots+t_{n}X_{n}\right)=\left(t_{1}，t_{2}，\cdots，t_{n}\right)\boldsymbol{C}\left(\begin{array}{c}t_{1} \\ t_{2} \\ \vdots \\t_{n}\end{array}\right)$$</span></li></ol></li></ul><h1 id="第五章-大数定律和中心极限定理">第五章大数定律和中心极限定理</h1><h2 id="大数定律预备知识">大数定律预备知识</h2><h3 id="关于期望的重要不等式">关于期望的重要不等式</h3><p>设非负连续性随机变量 <span class="math inline"><em>X</em></span>的期望 <span class="math inline"><em>E</em>(<em>X</em>)</span>存在，则对于任意实数 <span class="math inline"><em>ε</em> &gt; 0</span>，有 <span class="math display">$$P(X \geq \varepsilon) \leq \frac{E(X)}{\varepsilon}$$</span></p><h3 id="马尔可夫markov不等式">马尔可夫（Markov）不等式</h3><p>马尔可夫不等式描述的是非负随机变量绝对位置的概率上限，设随机变量<span class="math inline"><em>X</em></span> 的 <span class="math inline"><em>k</em></span> 阶绝对原点矩 <span class="math inline"><em>E</em>(|<em>X</em>|<sup><em>k</em></sup>)</span>存在，则对于任意实数 <span class="math inline"><em>ε</em> &gt; 0</span>，则有 <span class="math display">$$P(|X| \geq \varepsilon) \leq\frac{E\left(|X|^{k}\right)}{\varepsilon^{k}}$$</span></p><h3 id="切比雪夫chebyshev不等式">切比雪夫（Chebyshev）不等式</h3><p>切比雪夫不等式描述的是随机变量距期望相对位置偏离的概率上限，设随机变量<span class="math inline"><em>X</em></span> 的期望 <span class="math inline"><em>E</em>(<em>X</em>) = <em>μ</em></span> ，方差<span class="math inline"><em>D</em>(<em>X</em>) = <em>σ</em><sup>2</sup></span>，则对于任意实数<span class="math inline"><em>ε</em> &gt; 0</span>，恒有 <span class="math display">$$P(|X-\mu| \geqslant \varepsilon) \leqslant\frac{\sigma^{2}}{\varepsilon^{2}}$$</span></p><p>或 <span class="math display">$$P(|X-\mu|&lt;\varepsilon)&gt;1-\frac{\sigma^{2}}{\varepsilon^{2}}$$</span></p><h3 id="依概率收敛">依概率收敛</h3><p>设 <span class="math inline"><em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>n</em></sub>, ⋯</span>是一个随机变量序列，<span class="math inline"><em>X</em></span>是一个随机变量，若 <span class="math inline">∀<em>ε</em> &gt; 0</span>，有 <span class="math display">lim<sub><em>n</em> → +∞</sub><em>P</em>(|<em>Y</em><sub><em>n</em></sub> − <em>X</em>| ≥ <em>ε</em>) = 0</span></p><p>或 <span class="math display">lim<sub><em>n</em> → +∞</sub><em>P</em>(|<em>Y</em><sub><em>n</em></sub> − <em>X</em>| &lt; <em>ε</em>) = 1</span></p><p>则称随机变量序列 <span class="math inline"><em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>n</em></sub>, ⋯</span>依概率收敛于 <span class="math inline"><em>X</em></span>，记作 <span class="math inline">$Y_{n} \underset{n\rightarrow+\infty}{\stackrel{P}{\longrightarrow}} X$</span></p><h2 id="大数定律">大数定律</h2><h3 id="定义">定义</h3><p>若随机变量序列 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>, ⋯</span>满足 <span class="math inline">∀<em>ε</em> &gt; 0</span>，有 <span class="math display">$$\lim _{n \rightarrow+\infty} P\left(\left|\frac{1}{n} \sum_{k=1}^{n}X_{k}-\frac{1}{n} \sum_{k=1}^{n}E\left(X_{k}\right)\right|&lt;\varepsilon\right)=1$$</span></p><p>则称该序列服从<strong>大数定律</strong></p><ul><li>当试验次数进行到无穷大时，某一随机变量取值的邻域内概率收敛至 1</li></ul><h3 id="伯努利bernoulli大数定律">伯努利（Bernoulli）大数定律</h3><p>设 <span class="math inline"><em>n</em><sub><em>A</em></sub></span>表示 <span class="math inline"><em>n</em></span> 次独立重复试验中事件<span class="math inline"><em>A</em></span> 发生的次数，<span class="math inline"><em>p</em></span> 是每次试验中 <span class="math inline"><em>A</em></span> 发生的概率(即<strong>伯努利</strong>试验)，则 <span class="math inline">∀<em>ε</em> &gt; 0</span>，有 <span class="math display">$$\lim _{n \rightarrow+\infty} P\left(\left|\frac{n_{A}}{n}-p\right|\geqslant \varepsilon\right)=0$$</span></p><p>或 <span class="math display">$$\lim _{n \rightarrow+\infty}P\left(\left|\frac{n_{A}}{n}-p\right|&lt;\varepsilon\right)=1$$</span></p><p>即随机事件 <span class="math inline"><em>A</em></span> 在 <span class="math inline"><em>n</em></span>次试验中发生的<strong>频率</strong> <span class="math inline">$\dfrac{n_A}{n}$</span><strong>依概率收敛</strong>于 <span class="math inline"><em>A</em></span>在一次试验中发生的<strong>概率</strong> <span class="math inline"><em>p</em></span></p><h3 id="切比雪夫chebyshev大数定律">切比雪夫（Chebyshev）大数定律</h3><p>若满足以下条件：</p><ul><li>随机变量序列 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>, ⋯</span><strong>两两不相关</strong>：<span class="math inline"><em>ρ</em><sub><em>X</em><sub><em>i</em></sub><em>X</em><sub><em>j</em></sub></sub> = 0&nbsp;(<em>i</em> ≠ <em>j</em>)</span></li><li><strong>方差</strong>存在且<strong>有共同上界</strong>：<span class="math inline"><em>D</em>(<em>X</em><sub><em>k</em></sub>) = <em>σ</em><sub><em>k</em></sub><sup>2</sup> ≤ <em>σ</em><sup>2</sup>, <em>k</em> = 1, 2, ⋯, <em>n</em>, ⋯</span></li></ul><p>则该序列服从大数定律，记 <span class="math inline"><em>E</em>(<em>X</em><sub><em>k</em></sub>) = <em>μ</em><sub><em>k</em></sub></span>，则<span class="math inline">∀<em>ε</em> &gt; 0</span>，则有 <span class="math display">$$\lim _{n \rightarrow+\infty} P\left(\left|\frac{1}{n} \sum_{k=1}^{n}X_{k}-\frac{1}{n} \sum_{k=1}^{n} \mu_{k}\right|&lt;\varepsilon\right)=1$$</span></p><h3 id="辛钦khintchine大数定律">辛钦（Khintchine）大数定律</h3><p>随机变量序列 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>, ⋯</span>满足以下条件：</p><ul><li><strong>独立同分布</strong>（i.i.d.）</li><li>数学期望存在，<span class="math inline"><em>E</em>(<em>X</em><sub><em>k</em></sub>) = <em>μ</em>，<em>k</em> = 1, 2, ⋯</span></li></ul><p>则该序列服从大数定律，对 <span class="math inline">∀<em>ε</em> &gt; 0</span>，有 <span class="math display">$$\lim _{n \rightarrow+\infty} P\left(\left|\frac{1}{n} \sum_{k=1}^{n}X_{k}-\mu\right|&lt;\varepsilon\right)=1$$</span></p><h3 id="马尔科夫markov大数定律">马尔科夫（Markov）大数定律</h3><p>设一个随机变量序列满足 <span class="math display">$$D\left(\dfrac1n\sum_{k=1}^{n} X_{k}\right) = \frac{1}{n^{2}}D\left(\sum_{k=1}^{n} X_{k}\right) \stackrel{n \rightarrow\infty}{\longrightarrow } 0$$</span></p><p>则该随机变量序列服从大数定律，即对 <span class="math inline">∀<em>ε</em> &gt; 0</span>，有</p><p><span class="math display">$$ \lim_{n \rightarrow \infty}P\left(\left|\frac{1}{n} \sum_{i=1}^{n}X_{i}-\frac{1}{n} \sum_{i=1}^{n}E\left(X_{i}\right)\right|&lt;\varepsilon\right)=1$$</span></p><h2 id="中心极限定理">中心极限定理</h2><h3 id="独立同分布的中心极限定理">独立同分布的中心极限定理</h3><p>设 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>, ⋯</span>为独立同分布的随机变量序列，<span class="math inline"><em>E</em>(<em>X</em><sub><em>k</em></sub>) = <em>μ</em>，<em>D</em>(<em>X</em><sub><em>k</em></sub>) = <em>σ</em><sup>2</sup>，<em>k</em> = 1, 2, ⋯, <em>n</em>, ⋯</span>，记<span class="math inline">$\displaystyle\sum_{k=1}^n X_k$</span>的标准化随机变量为 <span class="math display">$$Y_n = \dfrac{\displaystyle\sum_{k=1}^nX_k-n\mu}{\sqrt{n}\ \sigma}$$</span></p><p>则 <span class="math display">$$\lim_{n\to \infty}P(Y_n\le y) \approx \mathit \Phi (y) =\dfrac{1}{\sqrt{2\pi}}\int_{-\infty}^y\mathrm e^{-\frac{t^2}{2}}\\mathrm dt$$</span></p><p>即 <span class="math inline"><em>n</em> → ∞</span> 时，<span class="math inline"><em>Y</em><sub><em>n</em></sub> ∼ <em>N</em>(0, 1)</span>或 <span class="math inline">$\displaystyle\sum_{k=1}^n X_k \simN(n\mu，n\sigma^2)$</span> <span class="math display">$$P\left(\sum_{k=1}^n X_k \le x\right)\approx \mathit\Phi\left(\dfrac{x -n\mu}{\sqrt n\ \sigma}\right)$$</span></p><h3 id="棣莫弗拉普拉斯de-moivre-laplace中心极限定理">棣莫弗—拉普拉斯（DeMoivre-Laplace）中心极限定理</h3><p>随机变量 <span class="math inline"><em>Y</em><sub><em>n</em></sub> ∼ <em>B</em>(<em>n</em>, <em>p</em>), 0 &lt; <em>p</em> &lt; 1, <em>n</em> = 1, 2, ⋯</span>，则<span class="math display">$$Y_n\sim N(np,np(1-p)) 或 \dfrac{Y_n - np}{\sqrt{np(1-p)}}\sim N(0,1)$$</span></p><h3 id="用频率估计概率">用频率估计概率</h3><p>可以用切比雪夫不等式估计概率，但是用中心极限定理通过频率估计得到的结果更精确<span class="math display">$$\begin{aligned}&amp;P\left\{\left|\dfrac{\eta_{n}}{n}-p\right|&lt;\varepsilon\right\}\\=&amp;P\left\{\left|\dfrac{\eta_{n}-np}{n}\right|&lt;\varepsilon\right\} \\=&amp;P\left\{-\varepsilon \sqrt{\dfrac{n}{p q}}&lt;\dfrac{\eta_{n}-np}{\sqrt{n p q}}&lt;\varepsilon \sqrt{\dfrac{n}{p q}}\right\} \\\approx &amp;\Phi\left(\varepsilon \sqrt{\dfrac{n}{pq}}\right)-\Phi\left(-\varepsilon \sqrt{\dfrac{n}{p q}}\right)\\=&amp; 2 \Phi\left(\varepsilon \sqrt{\dfrac{n}{p q}}\right)-1\end{aligned}$$</span></p><h1 id="第六章-数理统计的预备知识">第六章 数理统计的预备知识</h1><h2 id="数理统计基本知识">数理统计基本知识</h2><h3 id="总体和个体">总体和个体</h3><ul><li>一般地，所研究对象的某个（或某些）数量指标的全体称为<strong>总体</strong>。</li><li>如果所研究的问题只有一个数量指标，就是一个<strong>随机变量</strong>，如果所研究的问题有多个数量指标，就是<strong>多维随机变量</strong>。</li><li><strong>个体</strong>就是总体的每个数量指标。</li></ul><h3 id="样本和样本空间">样本和样本空间</h3><ul><li>一般地，为研究总体的特征，从总体中抽取部分个体，称为<strong>样本</strong></li><li>若从某个总体 <span class="math inline"><em>X</em></span> 中抽取了<span class="math inline"><em>n</em></span> 个个体，记为 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>，则称其为总体<span class="math inline"><em>X</em></span> 的一个容量为 <span class="math inline"><em>n</em></span> 的样本.</li><li>依次对它们进行观察得到 <span class="math inline"><em>n</em></span>个数据 <span class="math inline">(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)</span>，称这<span class="math inline"><em>n</em></span> 个数据 (<span class="math inline"><em>n</em></span> 维实向量) 为总体 <span class="math inline"><em>X</em></span> 的一个容量为 <span class="math inline"><em>n</em></span>的<strong>样本观测值</strong>，简称<strong>样本值</strong></li><li>可以将它们看作 <span class="math inline"><em>n</em></span>维随机向量 <span class="math inline"><em>X</em></span>的一组可能的取值，样本 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>的所有可能取值的集合称为<strong>样本空间</strong>，记为 <span class="math inline"><em>χ</em></span></li></ul><h3 id="样本与函数">样本与函数</h3><ul><li><strong>简单随机样本</strong>：若来自总体 <span class="math inline"><em>X</em></span> 的一个样本 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>为 <span class="math inline"><em>X</em></span>的一个<strong>简单随机样本</strong>，则其满足：<ul><li><strong>同分布性</strong>，即 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>都与 <span class="math inline"><em>X</em></span> 服从相同的分布</li><li><strong>独立性</strong>，即 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>相互独立</li></ul></li><li><strong>分布函数</strong>：总体的分布函数为 <span class="math inline"><em>F</em>(<em>x</em>)</span>，则 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>的联合分布函数为 <span class="math display">$$  F\left(x_{1},x_{2},\cdots,x_{n}\right)=\prod_{i=1}^{n}F\left(x_{i}\right)  $$</span></li><li><strong>概率密度</strong>：总体的概率密度为 <span class="math inline"><em>f</em>(<em>x</em>)</span>，则 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>的联合概率密度为 <span class="math display">$$  f\left(x_{1},x_{2},\cdots,x_{n}\right)=\prod_{i=1}^{n}f\left(x_{i}\right)  $$</span></li></ul><h3 id="统计量">统计量</h3><ul><li><strong>统计量</strong>：总体 <span class="math inline"><em>X</em></span> 的简单随机样本 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>，有不含除自变量之外的未知参数的实连续函数<span class="math inline"><em>g</em>(<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, ⋯, <em>r</em><sub><em>n</em></sub>)</span>，使随机变量<span class="math inline"><em>g</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>为<strong>统计量</strong></li><li><strong>样本值</strong>：统计量 <span class="math inline"><em>g</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>的一个<strong>样本值</strong>：<span class="math inline"><em>g</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)</span></li></ul><h4 id="常用统计量">常用统计量</h4><p>设 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>为总体 <span class="math inline"><em>X</em></span> 的一个容量为 <span class="math inline"><em>n</em></span> 的样本</p><ul><li><strong>样本均值</strong> <span class="math display">$$  \bar{X}=\frac{1}{n} \sum_{i=1}^{n} X_{i}  $$</span><ul><li><span class="math inline"><em>X̄</em></span> 的样本值记为 <span class="math inline"><em>x̄</em></span></li><li>与数学期望的区别<ul><li>样本均值是随机变量，具有分布</li><li>数学期望是常数</li><li>依概率收敛到数学期望</li></ul></li></ul></li><li><strong>样本方差</strong> <span class="math display">$$  S^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}  $$</span><ul><li><span class="math inline"><em>S</em><sup>2</sup></span> 的样本值记为<span class="math inline"><em>s</em><sup>2</sup></span></li></ul></li><li><strong>样本标准差</strong> <span class="math display">$$  S=\sqrt{\frac{1}{n-1} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}}  $$</span><ul><li><span class="math inline"><em>S</em></span> 的样本值记为 <span class="math inline"><em>s</em></span></li><li>样本均值、样本方差与期望、方差的关系 <span class="math display">$$  \begin{aligned}  E(\bar{X})&amp;=E(X)\\  D(\bar{X})&amp;=\dfrac{D(X)}{n}\\  E(S^2)&amp;=D(X)\\  \end{aligned}  $$</span></li></ul></li><li><strong>样本 k 阶原点矩</strong> <span class="math display">$$  M_{k}=\frac{1}{n} \sum_{i=1}^{n} X_{i}^{k}(k=1,2,\cdots)  $$</span><ul><li><span class="math inline"><em>M</em><sub><em>k</em></sub></span>的样本值记为 <span class="math inline"><em>m</em><sub><em>k</em></sub></span></li><li><span class="math inline"><em>M</em><sub>1</sub> = <em>X̄</em></span></li></ul></li><li><strong>样本 k 阶中心矩</strong> <span class="math display">$$  (C M)_{k}=\frac{1}{n}\sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{k}(k=1,2,\cdots)  $$</span><ul><li><span class="math inline">(<em>C</em><em>M</em>)<sub><em>k</em></sub></span>的样本值记为 <span class="math inline">(cm)<sub><em>k</em></sub></span></li><li><span class="math inline">(<em>C</em><em>M</em>)<sub>2</sub> = <em>M</em><sub>2</sub> − <em>X̄</em><sup>2</sup></span><ul><li>由均值和平方的均值即可求 2 阶中心矩</li></ul></li><li><span class="math inline">$(CM)_2 = \dfrac{n-1}{n}S^2\triangleqS_n^2$</span><ul><li>由 2 阶中心矩即可求方差</li></ul></li><li>样本方差 <span class="math inline"><strong>S</strong><sup><strong>2</strong></sup></span>与样本二阶中心矩 <span class="math inline"><strong>S</strong><sub><strong>n</strong></sub><sup><strong>2</strong></sup></span>的关系： <span class="math display">$$  \begin{aligned}  S^2 = \dfrac{n}{n-1}S_n^2 \\  E(S_n^2) = \dfrac{n-1}{n}\ \sigma^2\quad E(S^2) = \sigma^2  \end{aligned}  $$</span></li></ul></li></ul><h4 id="顺序统计量">顺序统计量</h4><p>将一组样本的样本值 <span class="math inline">(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯，<em>x</em><sub><em>n</em></sub>)</span>从小到大排序后记为 <span class="math inline"><em>x</em><sub>1</sub><sup>⋆</sup> ≤ <em>x</em><sub>2</sub><sup>⋆</sup> ≤ ⋯ ≤ <em>x</em><sub><em>n</em></sub><sup>⋆</sup></span>，定义<span class="math inline"><em>X</em><sub>(<em>k</em>)</sub> = <em>x</em><sub><em>k</em></sub><sup>⋆</sup>, <em>k</em> = 1, 2, ⋯, <em>n</em></span>，<span class="math inline"><em>X</em><sub>(<em>k</em>)</sub></span>的取值为样本中从小到大排第 <span class="math inline"><em>k</em></span>位的数，则称 <span class="math inline"><em>X</em><sub>(1)</sub>, <em>X</em><sub>(2)</sub>, ⋯, <em>X</em><sub>(<em>n</em>)</sub></span>为<strong>顺序统计量</strong></p><ul><li><p><strong>极差</strong> <span class="math display"><em>D</em><sub><em>n</em></sub> = <em>X</em><sub>(<em>n</em>)</sub> − <em>X</em><sub>(1)</sub></span></p></li><li><p><strong>样本中位数</strong> <span class="math display">$$  \tilde{X}=\left\{\begin{array}{cc}  X_{\left(\frac{\mathrm{n}+1}{2}\right)}，&amp; \mathrm{n} \text {为奇数 } \\  \dfrac{1}{2}\left(X_{\left(\frac{\mathrm{n}}{2}\right)}+X_{\left(\frac{\mathrm{n}}{2}+1\right)}\right)，&amp;\mathrm{n} \text { 为偶数 }  \end{array}\right.  $$</span></p></li><li><p><strong>样本经验分布函数</strong> <span class="math display">$$  F_{n}(x)=\left\{\begin{array}{lc}  0，&amp; x&lt;x_{(1)} \\  \dfrac{k}{n}，&amp; x_{(k)} \leq x&lt;x_{(k+1)} \\  1，&amp; x \geq x_{(n)}  \end{array} \quad k=1,2，\cdots，n-1\right.  $$</span></p><ul><li><span class="math inline"><em>n</em> → ∞</span>，<span class="math inline">$F_n(x)\xrightarrow[n\to \infty]{p=1}F(x)$</span>，<span class="math inline"><em>F</em><sub><em>n</em></sub>(<em>x</em>)</span>以概率 1 一致收敛于分布函数 <span class="math inline"><em>F</em>(<em>x</em>)</span></li></ul></li><li><p><strong><span class="math inline"><strong>α</strong></span>分位数</strong>：</p><ul><li><p><strong>上侧 <span class="math inline"><strong>α</strong></span>分位数 <span class="math inline"><strong>x</strong><sub><em>α</em></sub></span></strong>：<span class="math display"><em>P</em>(<em>X</em> &gt; <em>x</em><sub><em>α</em></sub>) = <em>α</em></span></p><ul><li><span class="math inline"><em>α</em></span> 为 <span class="math inline">(0, 1)</span> 内的给定常数</li></ul></li><li><p><strong>双侧 <span class="math inline"><strong>α</strong></span>分位数 <span class="math inline"><strong>x</strong><sub><em>α</em>/2</sub></span></strong>(对于偶函数)： <span class="math display"><em>P</em>(|&nbsp;<em>X</em>&nbsp;| &gt; <em>x</em><sub><em>α</em>/2</sub>) = <em>α</em></span></p><ul><li><span class="math inline"><em>α</em></span> 为 <span class="math inline">$\left(0,\dfrac12\right)$</span> 内的给定常数</li></ul></li></ul></li></ul><h2 id="抽样检验常用统计量的分布">抽样检验（常用统计量的分布）</h2><h3 id="正态分布x-sim-nmusigma2">正态分布：<span class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>，<em>σ</em><sup>2</sup>)</span></h3><p>若随机变量 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>相互独立，且 <span class="math inline"><em>X</em><sub><em>i</em></sub> ∼ <em>N</em>(<em>μ</em><sub><em>i</em></sub>, <em>σ</em><sub><em>i</em></sub><sup>2</sup>)(<em>i</em> = 1, 2, ⋯, <em>n</em>)</span>，则<span class="math display">$$\sum_{i=1}^{n} a_{i} X_{i} \sim N\left(\sum_{i=1}^{n} a_{i}\mu_{i},\sum_{i=1}^{n} a_{i}^{2} \sigma_{i}^{2}\right)$$</span></p><p>特别地，当 <span class="math inline"><em>X</em><sub><em>i</em></sub> ∼ <em>N</em>(<em>μ</em>, <em>σ</em><sup>2</sup>)(<em>i</em> = 1, 2, ⋯, <em>n</em>)</span>,<span class="math display">$$\frac{1}{n} \sum_{i=1}^{n} X_{i} \simN\left(\mu,\frac{\sigma^{2}}{n}\right)$$</span></p><ul><li>均值的期望与方差： <span class="math display">$$  E\left(\frac{1}{n} \sum_{i=1}^{n} X_{i}\right) = \mu,\quadD\left(\frac{1}{n} \sum_{i=1}^{n} X_{i}\right) = \frac{\sigma^{2}}{n}  $$</span></li></ul><h3 id="卡方分布sum_i1n-x_i2-simchi2n">卡方分布：<span class="math inline">$\sum_{i=1}^{n} X_{i}^{2}\sim\chi^{2}(n)$</span></h3><p>设随机变量 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>相互独立，且均服从标准正态分布 <span class="math inline"><em>N</em>(0, 1)</span>，则称统计量 <span class="math inline">$\chi^{2}=\displaystyle\sum_{i=1}^{n}X_{i}^{2}$</span> 服从自由度为 <span class="math inline"><em>n</em></span> 的 <span class="math inline"><em>χ</em><sup>2</sup></span> 分布，记为 <span class="math inline">$\displaystyle\sum_{i=1}^{n} X_{i}^{2}\sim\chi^{2}(n)$</span>，其概率密度为 <span class="math display">$$f_{\chi^{2}}(x)=\left\{\begin{array}{ll}\displaystyle\frac{1}{2^{\frac{n}{2}} \Gamma\left(\dfrac{n}{2}\right)}\mathrm{e}^{-\frac{x}{2}} x^{\frac{n}{2}-1},&amp; x&gt;0,\\0,&amp; x \leqslant 0,\end{array}\right.$$</span></p><p>其中 <span class="math inline"><em>Γ</em>(<em>x</em>) = ∫<sub>0</sub><sup>+∞</sup><em>t</em><sup><em>x</em> − 1</sup>e<sup>−<em>t</em></sup>d<em>t</em></span></p><ul><li><span class="math inline"><em>n</em> = 2</span> 时，<span class="math inline">$\Gamma(\dfrac{n}{2}) = \Gamma(1) = 1$</span>，则<span class="math inline"><em>χ</em><sup>2</sup>(2)</span> 的概率密度为<span class="math display">$$  f_{\chi^{2}}(x)=\left\{\begin{array}{ll}\displaystyle  \frac{1}{2} \mathrm{e}^{-\frac{x}{2}},&amp; x&gt;0,\\  0,&amp; x \leqslant 0,  \end{array}\right.  $$</span></li></ul><figure><img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="chi-square distribution"><figcaption aria-hidden="true">chi-square distribution</figcaption></figure><h4 id="性质">性质</h4><ol type="1"><li>对于<span class="math inline">$\chi^{2}=\displaystyle\sum_{i=1}^{n}X_{i}^{2},X_{i} \sim N(0,1),i=1,2,\cdots,n$</span>， <span class="math display"><em>E</em>(<em>χ</em><sup>2</sup>) = <em>n</em>,  <em>D</em>(<em>χ</em><sup>2</sup>) = 2<em>n</em></span></li><li>若 <span class="math inline"><em>X</em><sub>1</sub> ∼ <em>χ</em><sup>2</sup>(<em>n</em><sub>1</sub>)，<em>X</em><sub>2</sub> ∼ <em>χ</em><sup>2</sup>(<em>n</em><sub>2</sub>)</span>，且两者相互独立，则<span class="math display"><em>X</em><sub>1</sub> + <em>X</em><sub>2</sub> ∼ <em>χ</em><sup>2</sup>(<em>n</em><sub>1</sub> + <em>n</em><sub>2</sub>)</span></li><li>当 <span class="math inline"><em>n</em></span> 很大时，<span class="math inline">$\displaystyle\chi^{2}=\sum_{i=1}^{n}X_{i}^{2}$</span> 近似服从正态分布 <span class="math inline"><em>N</em>(<em>n</em>，2<em>n</em>)</span></li><li><span class="math inline"><em>χ</em><sup>2</sup>(<em>n</em>)</span>的上侧 <span class="math inline"><em>α</em></span> 分位数 <span class="math inline"><em>χ</em><sub><em>α</em></sub><sup>2</sup>(<em>n</em>)&nbsp;(<em>P</em>(<em>χ</em><sup>2</sup> &gt; <em>χ</em><sub><em>α</em></sub><sup>2</sup>(<em>n</em>)) = <em>α</em>)</span>可查表</li></ol><h3 id="t-分布tsim-tn">t 分布：<span class="math inline"><em>T</em> ∼ <em>t</em>(<em>n</em>)</span></h3><p>设 <span class="math inline"><em>X</em> ∼ <em>N</em>(0, 1), <em>Y</em> ∼ <em>χ</em><sup>2</sup>(<em>n</em>)</span>且 <span class="math inline"><em>X</em>, <em>Y</em></span>相互独立，则称随机变量 <span class="math inline">$T =\dfrac{X}{\sqrt{\dfrac{Y}{n}}}$</span> 服从自由度为 <span class="math inline"><em>n</em></span> 的 <span class="math inline"><em>t</em></span> 分布 (又称为 student 分布)，记为<span class="math inline"><em>T</em> ∼ <em>t</em>(<em>n</em>)</span>，其概率密度为<span class="math display">$$f(t)=\frac{\Gamma\left(\dfrac{n+1}{2}\right)}{\sqrt{n \pi} \\Gamma\left(\dfrac{n}{2}\right)}\left(1+\frac{t^{2}}{n}\right)^{-\frac{n+1}{2}},\quad-\infty&lt;t&lt;+\infty$$</span> <img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload alt="t distribution"></p><h4 id="性质-1">性质</h4><ol type="1"><li><p><span class="math inline"><em>t</em></span> 分布的概率密度 <span class="math inline"><em>f</em>(<em>t</em>)</span> 为偶函数，且当 <span class="math inline"><em>n</em> → +∞</span> 时, <span class="math display">$$f(t) \rightarrow \varphi(t)=\frac{1}{\sqrt{2 \pi}}\mathrm{e}^{-\frac{t^{2}}{2}}$$</span></p><p>即当自由度 <span class="math inline"><em>n</em></span>充分大时，<span class="math inline"><em>t</em></span>分布近似服从标准正态分布，当 <span class="math inline"><em>n</em> &gt; 45</span> 时，<span class="math inline"><em>t</em></span> 分布可用标准正态分布近似</p></li><li><p><span class="math inline"><em>t</em></span> 分布的上侧 <span class="math inline"><em>α</em></span> 分位数 <span class="math inline"><em>t</em><sub><em>α</em></sub>(<em>n</em>)&nbsp;(<em>P</em>(<em>T</em> &gt; <em>t</em><sub><em>α</em></sub>(<em>n</em>)) = <em>α</em>)</span>可查附表，且 <span class="math display"><em>t</em><sub>1 − <em>α</em></sub>(<em>n</em>) = −<em>t</em><sub><em>α</em></sub>(<em>n</em>)</span></p></li></ol><h3 id="f-分布f-sim-fmn">F 分布：<span class="math inline"><em>F</em> ∼ <em>F</em>(<em>m</em>, <em>n</em>)</span></h3><p>设 <span class="math inline"><em>U</em> ∼ <em>χ</em><sup>2</sup>(<em>m</em>), <em>V</em> ∼ <em>χ</em><sup>2</sup>(<em>n</em>)</span>，且 <span class="math inline"><em>U</em>, <em>V</em></span>相互独立，则称随机变量 <span class="math inline">$F = \dfrac{U / m}{V /n}$</span> 服从第一自由度为 <span class="math inline"><em>m</em></span>，第二自由度为 <span class="math inline"><em>n</em></span> 的 <span class="math inline"><em>F</em></span> 分布，记为 <span class="math inline"><em>F</em> ∼ <em>F</em>(<em>m</em>, <em>n</em>)</span>，其概率密度为<span class="math display">$$f_{F}(t)=\left\{\begin{array}{ll}\frac{\Gamma\left(\dfrac{m+n}{2}\right)}{\Gamma\left(\dfrac{m}{2}\right)\Gamma\left(\dfrac{n}{2}\right)}\left(\dfrac{m}{n}\right)^{\frac{m}{2}}t^{\frac{m}{2}-1}\left(1+\dfrac{m}{n} t\right)^{-\frac{m+n}{2}},&amp;t&gt;0,\\0,&amp; t \leqslant 0\end{array}\right.$$</span></p><h4 id="性质-2">性质</h4><ol type="1"><li>若 <span class="math inline"><em>F</em> ∼ <em>F</em>(<em>m</em>，<em>n</em>)</span>，则<span class="math inline">$\dfrac{1}{F} \sim F(n,m)$</span></li><li><span class="math inline"><em>F</em>(<em>m</em>, <em>n</em>)</span>的上侧 <span class="math inline"><em>α</em></span> 分位数 <span class="math inline"><em>F</em><sub><em>α</em></sub>(<em>m</em>, <em>n</em>)(<em>P</em>(<em>F</em> &gt; <em>F</em><sub><em>α</em></sub>(<em>m</em>, <em>n</em>)) = <em>α</em>)</span>可查附表，且 <span class="math display">$$F_{1-\alpha}(m,n)=\frac{1}{F_{\alpha}(n,m)}$$</span></li><li>与 <span class="math inline"><em>t</em></span> 分布关系 <span class="math display">$$t_{1-\frac{\alpha}{2}}^{2}(n)=F_{\alpha}(1，n)$$</span></li></ol><h2 id="正态总体的抽样分布">正态总体的抽样分布</h2><h3 id="单个正态总体的抽样分布">单个正态总体的抽样分布</h3><p>设 <span class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>, <em>σ</em><sup>2</sup>)</span>，<span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>是来自总体<span class="math inline"><em>X</em></span> 的一个简单随机样本，<span class="math inline"><em>X̄</em>，<em>S</em><sup>2</sup></span>分别是样本均值与样本方差，则</p><ol type="1"><li><p>样本均值的分布 <span class="math display">$$\bar{X} \sim N\left(\mu,\frac{\sigma^{2}}{n}\right)$$</span></p><p>或者 <span class="math display">$$\frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \sim N(0,1)$$</span></p></li><li><p>样本方差的分布 <span class="math display">$$\frac{(n-1)S^{2}}{\sigma^{2}}=\sum_{i=1}^{n}\left(\frac{X_{i}-\bar{X}}{\sigma}\right)^{2}\sim \chi^{2}(n-1)$$</span></p><p>注意区分 <span class="math display">$$\sum_{i=1}^{n}\left(\frac{X_{i}-\mu}{\sigma}\right)^{2} \sim \chi^{2}(n)$$</span></p></li><li><p>样本均值与样本方差的独立性</p><ul><li>样本均值 <span class="math inline"><em>X̄</em></span> 与 <span class="math inline">$\dfrac{(n-1) S^{2}}{\sigma^{2}}$</span>相互独立</li></ul></li><li><p>推论：设 <span class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>, <em>σ</em><sup>2</sup>), (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>是来自总体 <span class="math inline"><em>X</em></span>的一个简单随机样本，<span class="math inline"><em>X̄</em>，<em>S</em><sup>2</sup></span>分别是样本均值与样本方差，则 <span class="math display">$$\frac{\bar{X}-\mu}{\dfrac{S}{\sqrt{n}}} \sim t(n-1)$$</span></p></li></ol><h2 id="两个正态总体的抽样分布">两个正态总体的抽样分布</h2><p>设 <span class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em><sub>1</sub>, <em>σ</em><sub>1</sub><sup>2</sup>), (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>是来自总体 <span class="math inline"><em>X</em></span>的一个简单随机样本，<span class="math inline"><em>Y</em> ∼ <em>N</em>(<em>μ</em><sub>2</sub>, <em>σ</em><sub>2</sub><sup>2</sup>), (<em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>m</em></sub>)</span>是来自总体 <span class="math inline"><em>Y</em></span>的一个简单随机样本，且 <span class="math inline"><em>X</em>，<em>Y</em></span> 相互独立，则 <span class="math display">$$\begin{aligned}\bar{X}&amp;=\frac{1}{n} \sum_{i=1}^{n} X_{i}\quadS_{1}^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}\\\bar{Y}&amp;=\frac{1}{m} \sum_{j=1}^{m} Y_{j}\quad S_{2}^{2}=\frac{1}{m-1} \sum_{j=1}^{m}\left(Y_{j}-\bar{Y}\right)^{2}\end{aligned}$$</span></p><p>则有</p><ol type="1"><li><p>样本方差的商的分布 <span class="math display">$$\frac{S_{1}^{2}}{S_{2}^{2}} \Bigg/ \frac{\sigma_{1}^{2}}{\sigma_{2}^{2}}\sim F(n-1,m-1)$$</span></p><p>当 <span class="math inline"><em>σ</em><sub>1</sub> = <em>σ</em><sub>2</sub></span>时， <span class="math display">$$\frac{S_{1}^{2}}{S_{2}^{2}} \sim F(n-1,m-1)$$</span></p></li><li><p>当 <span class="math inline"><em>σ</em><sub>1</sub> = <em>σ</em><sub>2</sub> = <em>σ</em></span>时, <span class="math display">$$\frac{(\bar{X}-\bar{Y})-\left(\mu_{1}-\mu_{2}\right)}{\sqrt{\dfrac{1}{n}+\dfrac{1}{m}}\sqrt{\dfrac{(n-1) S_{1}^{2}+(m-1) S_{2}^{2}}{n+m-2}}} \sim t(n+m-2)$$</span></p></li></ol><h1 id="第七章-参数估计">第七章 参数估计</h1><h2 id="点估计">点估计</h2><h3 id="定义-1">定义</h3><p>对于一个已知分布函数形式的总体 <span class="math inline"><em>X</em></span>，令 <span class="math display"><em>F</em>(<em>x</em>; <em>θ</em><sub>1</sub>, <em>θ</em><sub>2</sub>, ⋯, <em>θ</em><sub><em>k</em></sub>)</span></p><p>但存在未知参数的情况，对于样本 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>构造统计量 <span class="math display"><em>θ̂</em><sub><em>j</em></sub> = <em>θ̂</em><sub><em>j</em></sub>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>), <em>j</em> = 1, 2, ⋯, <em>k</em></span></p><p>再代入样本数据 <span class="math inline">(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)</span>，对未知参数<span class="math inline"><em>θ</em><sub><em>j</em></sub>(<em>j</em> = 1, 2, ⋯, <em>k</em>)</span>进行估计</p><p>这种用 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>构造统计量去估计未知参数的方法称为<strong>点估计法</strong></p><h3 id="频率估计法">频率估计法</h3><p>对于仅有一个未知量 <span class="math inline"><em>p</em></span>的情况，利用事件 <span class="math inline"><em>A</em></span> 在 <span class="math inline"><em>n</em></span> 次试验中发生的频率 <span class="math inline">$\dfrac{n_A}{n}$</span> 作为事件 <span class="math inline"><em>A</em></span> 发生的概率 <span class="math inline"><em>p</em></span> 的估计量 <span class="math display">$$\dfrac{n_A}{n}\xrightarrow{\ p\ }p$$</span></p><h3 id="矩估计法">矩估计法</h3><p>用<strong>样本矩估计总体矩</strong>，从而得到总体分布中的参数，即用样本的经验分布和样本矩去替换总体的理论分布和总体矩</p><ul><li><strong>特点</strong>：<ul><li>矩估计法的<strong>优点</strong>是简单易行，并不需要事先知道总体是什么分布</li><li>其<strong>缺点</strong>是当总体类型已知时，没有充分利用分布提供的信息</li><li>在一般情况下，矩估计量<strong>不具有唯一性</strong></li></ul></li></ul><h4 id="估计方法">估计方法</h4><p>设总体 <span class="math inline"><em>X</em></span> 的分布函数为 <span class="math inline"><em>F</em>(<em>x</em>; <em>θ</em><sub>1</sub>, <em>θ</em><sub>2</sub>, ⋯, <em>θ</em><sub><em>k</em></sub>)</span>，其中待估计的参数为<span class="math inline"><em>θ</em><sub>1</sub>, <em>θ</em><sub>2</sub>, ⋯, <em>θ</em><sub><em>k</em></sub></span>，假设<span class="math inline"><em>k</em></span> 阶原点矩存在，则记 <span class="math display"><em>E</em>(<em>X</em><sup><em>r</em></sup>) = <em>μ</em><sub><em>r</em></sub>(<em>θ</em><sub>1</sub>, <em>θ</em><sub>2</sub>, ⋯, <em>θ</em><sub><em>k</em></sub>), <em>r</em> = 1, 2, ⋯, <em>k</em></span></p><p>根据大数定律，列出如下方程 <span class="math display">$$\displaystyle\left\{\begin{array}{c}\displaystyle\mu_{1}\left(\theta_{1},\theta_{2},\cdots,\theta_{k}\right)=\frac{1}{n}\sum_{i=1}^{n} X_{i},\\\displaystyle\mu_{2}\left(\theta_{1},\theta_{2},\cdots,\theta_{k}\right)=\frac{1}{n}\sum_{i=1}^{n} X_{i}^{2},\\\vdots \\\displaystyle\mu_{k}\left(\theta_{1},\theta_{2},\cdots,\theta_{k}\right)=\frac{1}{n}\sum_{i=1}^{n} X_{i}^{k}\end{array}\right.$$</span></p><p>如果方程组有解(事实上，上述方程都是近似方程)，可以得到<strong>矩估计量</strong> <span class="math display">$$\begin{array}{c}\hat{\theta}_{1}=\hat{\theta}_{1}\left(X_{1},X_{2},\cdots,X_{n}\right),\\\hat{\theta}_{2}=\hat{\theta}_{2}\left(X_{1},X_{2},\cdots,X_{n}\right),\\\vdots \\\hat{\theta}_{k}=\hat{\theta}_{k}\left(X_{1},X_{2},\cdots,X_{n}\right),\end{array}$$</span></p><p>代入样本值可得矩估计量的样本值即<strong>矩估计值</strong> <span class="math display">$$\begin{array}{c}\hat{\theta}_{1}=\hat{\theta}_{1}\left(x_{1},x_{2},\cdots,x_{n}\right),\\\hat{\theta}_{2}=\hat{\theta}_{2}\left(x_{1},x_{2},\cdots,x_{n}\right),\\\vdots \\\hat{\theta}_{k}=\hat{\theta}_{k}\left(x_{1},x_{2},\cdots,x_{n}\right),\end{array}$$</span></p><h4 id="常见分布的矩估计量">常见分布的矩估计量</h4><ul><li><strong>正态分布</strong> <span class="math display">$$  \begin{cases}  \hat{\mu}_{\text {矩 }} =\bar{X}\\  \hat{\sigma}_{\text {矩 }}^{2} =\displaystyle\frac{1}{n}\sum_{i=1}^{n} X_{i}^{2}-\bar{X}^{2}  \end{cases}  $$</span></li><li><strong>指数分布</strong> <span class="math display">$$  \hat{\lambda}_{\text {矩 }} = \frac{1}{\bar{X}}  $$</span></li><li><strong>泊松分布</strong> <span class="math display">$$  \hat{\lambda}_{\text {矩 }} =\displaystyle\frac{1}{n} \sum_{i=1}^{n}x_{i}  $$</span></li><li><strong>均匀分布</strong> <span class="math display">$$  \begin{cases}  \hat{a}_{\text {矩 }}=\bar{X}-\sqrt{3\left(\displaystyle\frac{1}{n}\sum_{i=1}^{n}X_{i}^{2}-\bar{X}^{2}\right)}=\bar{X}-\sqrt{\displaystyle\frac{3}{n}\sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}} = \bar{X}-\sqrt{3 S^2}\\  \hat{b}_{\text {矩 }}=\bar{X}+\sqrt{3\left(\displaystyle\frac{1}{n}\sum_{i=1}^{n}X_{i}^{2}-\bar{X}^{2}\right)}=\bar{X}+\sqrt{\displaystyle\frac{3}{n}\sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}} = \bar{X}+\sqrt{3 S^2}  \end{cases}  $$</span></li></ul><h3 id="最大似然估计法">最大似然估计法</h3><ul><li>估计量 <span class="math inline"><em>θ̂</em><sub><em>M</em><em>L</em><em>E</em></sub></span></li><li>估计值 <span class="math inline"><em>θ̂</em><sub><em>m</em><em>l</em><em>e</em></sub></span>#### 估计方法</li></ul><ol type="1"><li><p><strong>构造似然函数</strong>：</p><ul><li><strong>离散型</strong> <span class="math display">$$  \begin{aligned}  L\left(\theta_{1},\theta_{2},\cdots,\theta_{k}\right)  &amp;=P\left(X_{1}=x_{1},X_{2}=x_{2},\cdots,X_{n}=x_{n}\right)\\  &amp;=\prod_{i=1}^{n}P\left(x_{i};\theta_{1},\theta_{2},\cdots,\theta_{k}\right)  \end{aligned}  $$</span></li><li><strong>连续型</strong> <span class="math display">$$  L\left(\theta_{1},\theta_{2},\cdots,\theta_{k}\right)=\prod_{i=1}^{n}f\left(x_{i};\theta_{1},\theta_{2},\cdots,\theta_{k}\right)  $$</span></li></ul></li><li><p><strong>列出似然方程组</strong>：求 <span class="math inline">(<em>θ̂</em><sub>1</sub>, <em>θ̂</em><sub>2</sub>, ⋯, <em>θ̂</em><sub><em>k</em></sub>)</span>使得 <span class="math inline"><em>L</em>(<em>θ̂</em><sub>1</sub>, <em>θ̂</em><sub>2</sub>, ⋯, <em>θ̂</em><sub><em>k</em></sub>) = max <em>L</em>(<em>θ</em><sub>1</sub>, <em>θ</em><sub>2</sub>, ⋯, <em>θ</em><sub><em>k</em></sub>)</span>，得到<strong>似然方程组</strong> <span class="math display">$$\frac{\partialL\left(\theta_{1},\theta_{2},\cdots,\theta_{k}\right)}{\partial\theta_{i}}=0,i=1,2,\cdots,k$$</span></p><p>双边求对数得到<strong>对数似然方程组</strong> <span class="math display">$$\frac{\partial \lnL\left(\theta_{1},\theta_{2},\cdots,\theta_{k}\right)}{\partial\theta_{i}}=0,i=1,2,\cdots,k$$</span></p></li><li><p><strong>求解极大值点</strong>：解以上方程组，求出 <span class="math inline">(<em>θ̂</em><sub>1</sub>, <em>θ̂</em><sub>2</sub>, ⋯, <em>θ̂</em><sub><em>k</em></sub>)</span></p></li></ol><h4 id="常见分布的极大似然估计">常见分布的极大似然估计</h4><ul><li><p><strong>正态分布</strong> <span class="math display">$$  \begin{cases}  \hat{\mu}_{m l e} = \displaystyle\frac{1}{n} \sum_{i=1}^{n}x_{i}=\bar{x}\\  \hat{\sigma}^{2}_{m l e} = \displaystyle\frac{1}{n}\sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}  \end{cases}  $$</span></p></li><li><p><strong>均匀分布</strong> <span class="math display">$$  \begin{cases}  \hat{a}=x_{\min }\\  \hat{b}=x_{\max }  \end{cases}  $$</span></p></li><li><p><strong>指数分布</strong> <span class="math display">$$  \hat{\lambda}_{m l e}=\displaystyle\frac{1}{\bar{x}}=\displaystyle\frac{n}{\sum_{i=1}^{n}x_{i}}  $$</span></p></li><li><p><strong>泊松分布</strong> <span class="math display">$$  \hat{\lambda}_{m l e} =\displaystyle\frac{1}{n} \sum_{i=1}^{n} x_{i}  $$</span></p></li></ul><h4 id="性质-3">性质</h4><ul><li><strong>最大似然估计不变性原理</strong>：若 <span class="math inline"><em>θ̂</em></span> 是未知参数 <span class="math inline"><em>θ</em></span> 的最大似然估计，又 <span class="math inline"><em>g</em>(<em>θ</em>)</span> 是 <span class="math inline"><em>θ</em></span> 的连续函数，且有单值反函数 <span class="math inline"><em>θ</em> = <em>θ</em>(<em>g</em>)</span>，则 <span class="math inline"><em>g</em> = <em>g</em>(<em>θ</em>)</span>的最大似然估计为 <span class="math display"><em>ĝ</em> = <em>g</em>(<em>θ̂</em>)</span><ul><li>不变性原理对矩估计一般不成立</li></ul></li><li><strong>存在性与唯一性</strong>：<ul><li>极大似然估计不一定存在</li><li>极大似然估计不一定唯一</li></ul></li></ul><h2 id="估计量的评价标准">估计量的评价标准</h2><h3 id="无偏性">无偏性</h3><ul><li><p><strong>无偏估计量</strong>：<span class="math inline"><em>θ</em></span> 的无偏估计量 <span class="math inline"><em>θ̂</em> = <em>θ̂</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯<em>X</em><sub><em>n</em></sub>)</span>满足 <span class="math display"><em>E</em>(<em>θ̂</em>) = <em>θ</em></span></p></li><li><p><strong>偏差</strong>：若 <span class="math inline"><em>E</em>(<em>θ̂</em>) ≠ <em>θ</em></span>，则估计量<span class="math inline"><em>θ̂</em></span> 的偏差 <span class="math display"><em>ε</em> = <em>E</em>(<em>θ̂</em>) − <em>θ</em></span></p></li><li><p><strong>常见估计量的无偏性</strong>：样本的 n 阶原点矩都是总体的n 阶原点矩的无偏估计量</p><ul><li><span class="math inline"><em>X̄</em></span> 为 <span class="math inline"><em>μ</em></span> 的无偏估计量</li><li><span class="math inline"><em>S</em><sup>2</sup></span> 为 <span class="math inline"><em>σ</em><sup>2</sup></span> 的无偏估计量</li><li><span class="math inline"><em>C</em><em>M</em><sub>2</sub></span>需要修正为 <span class="math inline">$\dfrac{n}{n-1}CM_2$</span> 才是<span class="math inline"><em>σ</em><sup>2</sup></span>的无偏估计量</li></ul></li><li><p><strong>性质</strong>：</p><ul><li>估计量的无偏性与其函数的无偏性无关<ul><li>即 <span class="math inline"><em>θ̂</em></span> 是 <span class="math inline"><em>θ</em></span> 的无偏估计量，但 <span class="math inline"><em>g</em>(<em>θ̂</em>)</span> 不一定是 <span class="math inline"><em>g</em>(<em>θ</em>)</span> 的</li><li>如 <span class="math inline"><em>X̄</em></span> 与 <span class="math inline">$\overline {X^2}$</span></li></ul></li><li>线性性<ul><li>由无偏性的公式得到</li><li>若某个参数的估计量为两个参数的估计量的线性组合，则这两个参数的无偏估计量按照相同的线性组合即为该参数的无偏估计量</li></ul></li></ul></li><li><p><strong>求无偏估计量的方法</strong>：由于样本矩是总体矩的无偏估计量，由数学期望线性性，<strong>将未知参数表示为总体矩的线性函数，用样本矩作为总体矩的估计量</strong></p></li></ul><h3 id="有效性">有效性</h3><ul><li><p><strong>定义</strong>：对于参数 <span class="math inline"><em>θ</em></span> 的两个<strong>无偏</strong>估计量<span class="math inline"><em>θ̂</em><sub>1</sub> = <em>θ̂</em><sub>1</sub>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)，<em>θ̂</em><sub>2</sub> = <em>θ̂</em><sub>2</sub>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>，利用有效性评判其好坏<span class="math display"><em>D</em>(<em>θ̂</em><sub>1</sub>) &lt; <em>D</em>(<em>θ̂</em><sub>2</sub>)</span></p><p>则估计量 <span class="math inline"><em>θ̂</em><sub>1</sub></span> 比<span class="math inline"><em>θ̂</em><sub>2</sub></span><strong>有效</strong></p></li><li><p><strong>无偏估计的方差下界</strong>：无偏估计的方差不是任意小，下界<span class="math inline"><em>I</em>(<em>θ</em>)</span> 由下列Rao-Cramer 不等式确定</p><ul><li><strong>离散型</strong>：<span class="math inline"><em>P</em>(<em>X</em>; <em>θ</em>)</span> 为 <span class="math inline"><em>X</em></span> 的分布律，<span class="math inline"><em>θ</em></span> 为未知参数 <span class="math display">$$  D(\hat\theta)\ge I(\theta) =\dfrac{1}{nE\left[\left(\dfrac{\partial\lnP(X;\theta)}{\partial\theta}\right)^2\right]} &gt; 0  $$</span></li><li><strong>连续型</strong>：<span class="math inline"><em>f</em>(<em>X</em>; <em>θ</em>)</span>为连续性随机变量 <span class="math inline"><em>X</em></span>的概率密度函数 <span class="math display">$$  D(\hat\theta)\ge I(\theta) =\dfrac{1}{nE\left[\left(\dfrac{\partial\lnf(X;\theta)}{\partial\theta}\right)^2\right]} &gt; 0  $$</span></li></ul></li><li><p><strong>有效估计量</strong>：未知参数 <span class="math inline"><em>θ</em></span> 的<strong>有效估计量</strong><span class="math inline"><em>θ̂</em><sub>0</sub></span> 需要满足：</p><ul><li>在所有<strong>无偏</strong>估计量 <span class="math inline"><em>θ̂</em></span> 中均有 <span class="math display"><em>D</em>(<em>θ̂</em><sub>0</sub>) = <em>I</em>(<em>θ</em>) ≤ <em>D</em>(<em>θ̂</em>)</span></li><li>即某个无偏估计量的<strong>方差达到下界</strong></li></ul></li></ul><h3 id="一致性">一致性</h3><ul><li><p><strong>定义</strong>：参数 <span class="math inline"><em>θ</em></span> 的<strong>一致 (相合)估计量</strong> <span class="math inline"><em>θ̂</em><sub><em>n</em></sub> = <em>θ̂</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯<em>X</em><sub><em>n</em></sub>)</span>满足：<strong>随机变量序列 <span class="math inline">{<em>θ̂</em><sub><em>n</em></sub>}</span>依概率收敛于 <span class="math inline"><em>θ</em></span></strong>，即<span class="math inline">∀<em>ε</em> &gt; 0</span>，有 <span class="math display">lim<sub><em>n</em> → +∞</sub><em>P</em>(|<em>θ̂</em><sub><em>n</em></sub> − <em>θ</em>| &lt; <em>ε</em>) = 1</span></p><p>或 <span class="math display">lim<sub><em>n</em> → +∞</sub><em>P</em>(|<em>θ̂</em><sub><em>n</em></sub> − <em>θ</em>| ≥ <em>ε</em>) = 0</span></p></li><li><p><strong>性质</strong>：</p><ul><li><strong>矩法估计量的一致性</strong>：样本 <span class="math inline"><em>k</em></span> 阶矩是总体 <span class="math inline"><em>k</em></span> 阶矩的一致性估计量<ul><li>矩法得到的估计量一般为一致性估计量</li><li><span class="math inline"><em>S</em><sub><em>n</em></sub><sup>2</sup></span>为 <span class="math inline"><em>D</em>(<em>X</em>)</span>的一致性估计量</li></ul></li><li><strong>一致估计的不变性原理</strong>：若 <span class="math inline"><em>θ̂</em></span> 为 <span class="math inline"><em>θ</em></span> 的一致估计，则 <span class="math inline"><em>ĝ</em>(<em>θ</em>)</span> 也为 <span class="math inline"><em>g</em>(<em>θ</em>)</span> 的一致估计</li></ul></li><li><p><strong>一致估计量的判定</strong>：设 <span class="math inline"><em>θ̂</em><sub><em>n</em></sub> = <em>θ̂</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯<em>X</em><sub><em>n</em></sub>)</span>为未知参数 <span class="math inline"><em>θ</em></span> 的无偏估计量，若<span class="math display">lim<sub><em>n</em> → ∞</sub><em>D</em>(<em>θ̂</em><sub><em>n</em></sub>) = 0</span></p><p>则 <span class="math inline"><em>θ̂</em><sub><em>n</em></sub></span>为 <span class="math inline"><em>θ</em></span> 的一致估计量</p></li></ul><h2 id="区间估计">区间估计</h2><h3 id="单个正态总体参数的置信区间">单个正态总体参数的置信区间</h3><h4 id="均值-mu-的置信区间">均值 <span class="math inline"><em>μ</em></span> 的置信区间</h4><h5 id="方差-sigma2-已知">1. 方差 <span class="math inline"><em>σ</em><sup>2</sup></span> 已知</h5><ul><li><strong>枢轴量</strong> <span class="math display">$$  U = \dfrac{\bar X - \mu}{\sigma/\sqrt n}\sim N(0,1)  $$</span></li><li><strong>置信区间</strong> (<span class="math inline">1 − <em>α</em></span>) <span class="math display">$$  \left(\bar{X}-u_{\alpha / 2} \frac{\sigma}{\sqrt{n}},\bar{X}+u_{\alpha/ 2} \frac{\sigma}{\sqrt{n}}\right)  $$</span></li></ul><h5 id="方差未知">2. 方差未知</h5><ul><li><strong>枢轴量</strong>：用 <span class="math inline">$S =\sqrt{S^2}$</span> 代替均方差 <span class="math inline"><em>σ</em></span> <span class="math display">$$  T=\frac{\bar{X}-\mu}{S / \sqrt{n}} \sim t(n-1)  $$</span></li><li><strong>置信区间</strong> (<span class="math inline">1 − <em>α</em></span>) <span class="math display">$$  \left(\bar{X}-t_{\alpha / 2}(n-1) \frac{S}{\sqrt{n}},\bar{X}+t_{\alpha/ 2}(n-1) \frac{S}{\sqrt{n}}\right)  $$</span></li></ul><h4 id="方差-sigma2-的置信区间">方差 <span class="math inline"><em>σ</em><sup>2</sup></span> 的置信区间</h4><h5 id="均值-mu-未知">1. 均值 <span class="math inline"><em>μ</em></span> 未知</h5><ul><li><strong>枢轴量</strong> <span class="math display">$$  \chi^2 = \dfrac{(n-1)S^2}{\sigma^2}\sim\chi^2(n-1)  $$</span></li><li><strong>置信区间</strong> (<span class="math inline">1 − <em>α</em></span>) <span class="math display">$$  \left(\frac{(n-1) S^{2}}{\chi_{\alpha / 2}^{2}(n-1)},\frac{(n-1)S^{2}}{\chi_{1-\alpha / 2}^{2}(n-1)}\right)  $$</span></li></ul><h5 id="均值-mu-已知">2. 均值 <span class="math inline"><em>μ</em></span> 已知</h5><ul><li><strong>枢轴量</strong> <span class="math display">$$  \chi^2 = \dfrac{1}{\sigma^2}\sum_{i = 1}^n(X_i - \mu)^2 = \sum_{i =1}^n\left(\dfrac{X_i - \mu}{\sigma}\right)^2\sim\chi^2(n)  $$</span></li><li><strong>置信区间</strong> (<span class="math inline">1 − <em>α</em></span>) <span class="math display">$$  \left(\frac{\sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}}{\chi_{\alpha /2}^{2}(n)},\frac{\sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}}{\chi_{1-\alpha/ 2}^{2}(n)}\right)  $$</span></li></ul><h3 id="两个正态总体参数的置信区间">两个正态总体参数的置信区间</h3><h4 id="均值差-mu_1---mu_2">均值差 <span class="math inline"><em>μ</em><sub>1</sub> − <em>μ</em><sub>2</sub></span></h4><h5 id="sigma_12sigma_22-均已知">1. <span class="math inline"><em>σ</em><sub>1</sub><sup>2</sup>，<em>σ</em><sub>2</sub><sup>2</sup></span>均已知</h5><ul><li><strong>枢轴量</strong>：由 <span class="math inline">$\bar X - \barY \sim N\left(\mu_1 -\mu_2，\dfrac{\sigma_1^2}{n_1}+\dfrac{\sigma_2^2}{n_2}\right)$</span>,<span class="math display">$$  U = \dfrac{\bar X - \bar Y - (\mu_1 -\mu_2)}{\sqrt{\dfrac{\sigma_1^2}{n_1}+\dfrac{\sigma_2^2}{n_2}}}\simN(0,1)  $$</span></li><li><strong>置信区间</strong> (<span class="math inline">1 − <em>α</em></span>) <span class="math display">$$  \left(\bar{X}-\bar{Y}-u_{\alpha / 2}\sqrt{\frac{\sigma_{1}^{2}}{n_{1}}+\frac{\sigma_{2}^{2}}{n_{2}}},\bar{X}-\bar{Y}+u_{\alpha/ 2}\sqrt{\frac{\sigma_{1}^{2}}{n_{1}}+\frac{\sigma_{2}^{2}}{n_{2}}}\right)  $$</span></li></ul><h5 id="方差均未知但-sigma_12-sigma_22">2. 方差均未知，但 <span class="math inline"><em>σ</em><sub>1</sub><sup>2</sup> = <em>σ</em><sub>2</sub><sup>2</sup></span></h5><ul><li><p><strong>枢轴量</strong> <span class="math display">$$  T=\frac{\bar{X}-\bar{Y}-\left(\mu_{1}-\mu_{2}\right)}{S_{W}\sqrt{\dfrac{1}{n_{1}}+\dfrac{1}{n_{2}}}} \simt\left(n_{1}+n_{2}-2\right)  $$</span></p><p>其中 <span class="math inline">$S_W =\sqrt{\dfrac{(n_1-1)S_{1}^{2}+(n_2-1) S_{2}^{2}}{n_1+n_2-2}}$</span></p></li><li><p><strong>置信区间</strong> (<span class="math inline">1 − <em>α</em></span>) <span class="math display">$$  \left(\bar{X}-\bar{Y}-t_{\alpha / 2}\left(n_{1}+n_{2}-2\right) S_{W}\sqrt{\frac{1}{n_{1}}+\frac{1}{n_{2}}},\bar{X}-\bar{Y}+t_{\alpha /2}\left(n_{1}+n_{2}-2\right) S_{W}\sqrt{\frac{1}{n_{1}}+\frac{1}{n_{2}}}\right)  $$</span></p></li></ul><h5 id="已知-n_1-n_2">3. 已知 <span class="math inline"><em>n</em><sub>1</sub> = <em>n</em><sub>2</sub></span></h5><ul><li><strong>枢轴量</strong>：由配对 <span class="math inline"><em>Z</em><sub><em>i</em></sub> = <em>X</em><sub><em>i</em></sub> − <em>Y</em><sub><em>i</em></sub> ∼ <em>N</em>(<em>μ</em><sub>1</sub> − <em>μ</em><sub>2</sub>，<em>σ</em><sub>1</sub><sup>2</sup> + <em>σ</em><sub>2</sub><sup>2</sup>)</span><span class="math display">$$  T=\frac{\bar{Z}-\left(\mu_{1}-\mu_{2}\right)}{S_{z} / \sqrt{n}} \simt(n-1)  $$</span></li><li><strong>置信区间</strong> (<span class="math inline">1 − <em>α</em></span>) <span class="math display">$$  \left(\bar{Z}-t_{\alpha / 2}(n-1) S_{z} / \sqrt{n},\quad\bar{Z}+t_{\alpha / 2}(n-1) S_{z} / \sqrt{n}\right)  $$</span></li></ul><h4 id="方差比-dfracsigma_12sigma_22">方差比 <span class="math inline">$\dfrac{\sigma_1^2}{\sigma_2^2}$</span></h4><h5 id="mu_1mu_2-未知">1. <span class="math inline"><em>μ</em><sub>1</sub>, <em>μ</em><sub>2</sub></span>未知</h5><ul><li><p><strong>枢轴量</strong> <span class="math display">$$  F=\frac{S_{1}^{2} / \sigma_{1}^{2}}{S_{2}^{2} /\sigma_{2}^{2}}=\frac{S_{1}^{2} / S_{2}^{2}}{\sigma_{1}^{2} /\sigma_{2}^{2}} \sim F\left(n_{1}-1,n_{2}-1\right)  $$</span></p></li><li><p><strong>置信区间</strong> (<span class="math inline">1 − <em>α</em></span>) <span class="math display">$$  \left(\frac{S_{1}^{2} / S_{2}^{2}}{F_{\alpha /2}\left(n_{1}-1,n_{2}-1\right)},\quad \frac{S_{1}^{2} /S_{2}^{2}}{F_{1-\alpha / 2}\left(n_{1}-1,n_{2}-1\right)}\right)  $$</span></p></li></ul><h5 id="mu_1mu_2-已知">2. <span class="math inline"><em>μ</em><sub>1</sub>, <em>μ</em><sub>2</sub></span>已知</h5><ul><li><p><strong>枢轴量</strong> <span class="math display">$$  F=\frac{\dfrac{1}{n}\dfrac{\sum_{i=1}^{n}\left(X_{i}-\mu_{1}\right)^{2}}{\sigma_{1}^{2}}}{\dfrac{1}{m}\dfrac{\sum_{j=1}^{m}\left(Y_{j}-\mu_{2}\right)^{2}}{\sigma_{2}^{2}}}=\dfrac{\dfrac{m}{n}\dfrac{\sum_{i=1}^{n}\left(X_{i}-\mu_{1}\right)^{2}}{\sum_{j=1}^{m}\left(Y_{j}-\mu_{2}\right)^{2}}}{\dfrac{\sigma_{1}^{2}}{\sigma_{2}^{2}}}\sim F(n，m)  $$</span></p></li><li><p><strong>置信区间</strong> (<span class="math inline">1 − <em>α</em></span>) <span class="math display">$$  \left(\frac{\frac{m}{n} \cdot\frac{\sum_{i=1}^{n}\left(X_{i}-\mu_{1}\right)^{2}}{\sum_{j=1}^{m}\left(Y_{j}-\mu_{2}\right)^{2}}}{F_{\frac{\alpha}{2}}(n，m)}，\frac{\frac{m}{n}\cdot\frac{\sum_{i=1}^{n}\left(X_{i}-\mu_{1}\right)^{2}}{\sum_{j=1}^{m}\left(Y_{j}-\mu_{2}\right)^{2}}}{F_{1-\frac{\alpha}{2}}(n，m)}\right)  $$</span></p></li></ul><h3 id="正态总体均值的单侧区间估计">正态总体均值的单侧区间估计</h3><ul><li><p>单侧置信区间：令 <span class="math display"><em>P</em>(<em>θ</em> &gt; <em>θ̂</em><sub>1</sub>) = 1 − <em>α</em>或<em>P</em>(<em>θ</em> &lt; <em>θ̂</em><sub>2</sub>) = 1 − <em>α</em></span></p><p>得 <span class="math display">(<em>θ̂</em><sub>1</sub>， + ∞) 或(−∞，<em>θ̂</em><sub>2</sub>)</span></p><ul><li><span class="math inline"><em>θ̂</em><sub>1</sub></span>单侧置信下限</li><li><span class="math inline"><em>θ̂</em><sub>2</sub></span>单侧置信上限</li></ul></li></ul><h4 id="均值-mu-的置信区间-1">均值 <span class="math inline"><em>μ</em></span> 的置信区间</h4><h5 id="方差-sigma2-已知均值的单侧置信区间">方差 <span class="math inline"><em>σ</em><sup>2</sup></span>已知，均值的单侧置信区间</h5><p><span class="math display">$$\begin{aligned}\left(\bar{X}-u_{\alpha} \frac{\sigma}{\sqrt{n}},+\infty\right)\\\left(-\infty,\bar{X}+u_{\alpha} \frac{\sigma}{\sqrt{n}}\right)\end{aligned}$$</span></p><h5 id="方差-sigma2-未知均值的单侧置信区间">方差 <span class="math inline"><em>σ</em><sup>2</sup></span>未知，均值的单侧置信区间</h5><p><span class="math display">$$\begin{aligned}\left(\bar{X}-t_{\alpha}(n-1) \frac{S}{\sqrt{n}},+\infty\right)\\\left(-\infty,\bar{X}+t_{\alpha}(n-1) \frac{S}{\sqrt{n}}\right)\end{aligned}$$</span></p><h4 id="方差-sigma2-的置信区间-1">方差 <span class="math inline"><em>σ</em><sup>2</sup></span> 的置信区间</h4><h5 id="均值-mu-已知方差的单侧置信区间">均值 <span class="math inline"><em>μ</em></span> 已知，方差的单侧置信区间</h5><p><span class="math display">$$\begin{aligned}\left(\frac{\sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}}{\chi_{\alpha}^{2}(n)},+\infty\right)\\\left(-\infty,\frac{\sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}}{\chi_{1-\alpha}^{2}(n)}\right)\end{aligned}$$</span></p><h5 id="均值-mu-未知方差的单侧置信区间">均值 <span class="math inline"><em>μ</em></span> 未知，方差的单侧置信区间</h5><p><span class="math display">$$\begin{aligned}\left(\frac{(n-1) S^{2}}{\chi_{\alpha}^{2}(n-1)},+\infty\right)\\\left(-\infty,\frac{(n-1) S^{2}}{\chi_{1-\alpha}^{2}(n-1)}\right)\end{aligned}$$</span></p><h1 id="第八章-假设检验">第八章 假设检验</h1><h2 id="假设检验">假设检验</h2><h3 id="相关概念">相关概念</h3><ul><li><strong>基本思想</strong>：<ul><li>基于概率的反证法：假设 <span class="math inline"><em>H</em><sub>0</sub></span>成立，然后基于这个假设构造一个小概率事件，保证这个小概率事件在 <span class="math inline"><em>H</em><sub>0</sub></span>成立时<strong>几乎不会</strong>在一次抽样（或试验）中发生。如果根据样本数据，发现这个小概率事件发生了，那么就有理由认为<span class="math inline"><em>H</em><sub>0</sub></span>不成立，即做出拒绝 <span class="math inline"><em>H</em><sub>0</sub></span> 而接受 <span class="math inline"><em>H</em><sub>1</sub></span>的决策；否则就没有充分的理由拒绝 <span class="math inline"><em>H</em><sub>0</sub></span>，从而接受 <span class="math inline"><em>H</em><sub>0</sub></span></li><li>这个反证法用到了一个符合常规的基本原理，即概率很小的事件在一次实验中几乎不会发生，通常称其为<strong>小概率事件原理</strong>，它是进行假设检验的基本法则</li></ul></li><li><strong>显著性水平与临界值</strong>：<ul><li><strong>显著性水平</strong>：为了体现小概率事件的“小”和差距的“大”，我们引入<span class="math inline"><em>α</em></span>表示这个小概率，并称其为<strong>显著性水平</strong> （<span class="math inline"><em>α</em></span> 一般取 <span class="math inline">0.1, 0.05, 0.01</span> 等）</li><li><strong>临界值</strong>：同时引入 <span class="math inline"><em>C</em></span>表示差距，并称其为<strong>临界值</strong> ，它们满足 <span class="math inline"><em>P</em>(|<em>X̄</em> − <em>X</em><sub>0</sub>| &gt; <em>C</em>) = <em>α</em></span></li><li><strong>一旦显著性水平给定，临界值就成为判断小概率事件是否发生的一个分界线</strong></li></ul></li><li><strong>拒绝域</strong>：为处理实际问题更直观方便，我们定义一个区域，当样本观测值落入这个区域，就拒绝<span class="math inline"><em>H</em><sub>0</sub></span>，否则就接受<span class="math inline"><em>H</em><sub>0</sub></span>，称这个区域为<strong>拒绝域</strong></li><li>在给定显著性水平 <span class="math inline"><em>α</em></span>时，确定临界值和拒绝域使用类似参数估计的方法确定。我们构造一个含有参数的样本函数，把这样构造的样本函数称为<strong>检验统计量</strong>，代入样本观测值即得到<strong>检验统计量的值</strong></li><li><strong>参数假设检验与非参数假设检验</strong>：<ul><li>总体的分布类型是已知的，仅涉及总体末知参数的检验称为<strong>参数假设检验</strong></li><li>对总体的末知分布的类型或某些特征的检验称为<strong>非参数假设检验</strong></li></ul></li><li><strong>双侧检验与单侧检验</strong>：<ul><li>拒绝域 <span class="math inline">𝒲</span>位于两侧，这类假设检验称为<strong>双侧检验</strong></li><li>拒绝域 <span class="math inline">𝒲</span>在左侧，这类假设检验称为<strong>左侧检验</strong> ，而拒绝域 <span class="math inline">𝒲</span>在右侧的假设检验称为<strong>右侧检验</strong>，左侧检验和右侧检验统称为<strong>单侧检验</strong></li></ul></li></ul><h3 id="参数假设检验的基本步骤">参数假设检验的基本步骤</h3><p>设总体 <span class="math inline"><em>X</em></span> 的分布函数为 <span class="math inline"><em>F</em>(<em>x</em>)</span>，一般来说 <span class="math inline"><em>F</em>(<em>x</em>)</span> 完全或部分末知，又设<span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>为总体 <span class="math inline"><em>X</em></span>的一个简单随机样本，相应的样本观测值为 <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub></span></p><ol type="1"><li><p>把实际问题转换为假设检验问题，提出<strong>原假设</strong> <span class="math inline"><em>H</em><sub>0</sub></span>和<strong>备择假设</strong> <span class="math inline"><em>H</em><sub>1</sub></span>（通常把研究者要证明的假设作为<strong>备择假设</strong>；将所作出的声明/现状/不能轻易否定的假设作为<strong>原假设</strong>）</p></li><li><p>在 <span class="math inline"><em>H</em><sub>0</sub></span>成立的条件下，构造适当的<strong>检验统计量</strong> ，例如 <span class="math inline"><em>U</em> = <em>g</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>，要求<span class="math inline"><em>U</em></span>的分布完全已知（不含末知参数）</p></li><li><p>给定一个很小的 <span class="math inline"><em>α</em></span>（称为<strong>显著性水平</strong>），由 <span class="math inline"><em>U</em></span> 构造拒绝域 <span class="math inline">𝒲</span>，使得当 <span class="math inline"><em>H</em><sub>0</sub></span> 成立时， <span class="math display"><em>P</em>((<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>) ∈ 𝒲) ≤ <em>α</em></span></p><p>即构造一个小概率事件“<span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>) ∈ 𝒲</span>”</p></li><li><p>代入样本数据，计算检验统计量 <span class="math inline"><em>U</em></span> 的观测值 <span class="math inline"><em>Û</em> = <em>g</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)</span>，由此判断<span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)</span>是否落在 <span class="math inline">𝒲</span> 中，从而做出决策，即</p><ul><li>若 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>) ∈ 𝒲</span>，则拒绝<span class="math inline"><em>H</em><sub>0</sub></span></li><li>若 <span class="math inline">(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>) ∉ 𝒲</span>，则接受<span class="math inline"><em>H</em><sub>0</sub></span></li></ul></li></ol><h3 id="决策错误">决策错误</h3><h4 id="第一类错误">第一类错误</h4><p>如果原假设 <span class="math inline"><em>H</em><sub>0</sub></span>为真，由于样本的随机性，恰巧使所构造的小概率事件发生了，根据上述方法做出拒绝<span class="math inline"><em>H</em><sub>0</sub></span>的决策，此时就犯了错误，称这类错误为<strong>第Ⅰ类错误</strong>（又称为<strong>“弃真”错误</strong>）</p><ul><li>犯第Ⅰ类错误的概率为 <span class="math display"><em>P</em>(拒绝<em>H</em><sub>0</sub> ∣ <em>H</em><sub>0</sub>为真) ≤ <em>α</em></span></li><li>犯第Ⅰ类错误的概率不会超过显著性水平 <span class="math inline"><em>α</em></span>，<span class="math inline"><em>α</em></span> 越小，犯第 Ⅰ 类错误的概率就越小<ul><li>当 <span class="math inline"><em>α</em> = 0.05</span> 时，拒绝 <span class="math inline"><em>H</em><sub>0</sub></span>称为是“<strong>显著</strong>”的</li><li>当 <span class="math inline"><em>α</em> = 0.01</span> 时，拒绝 <span class="math inline"><em>H</em><sub>0</sub></span>称为是“<strong>高度显著</strong>”的</li></ul></li></ul><h4 id="第二类错误">第二类错误</h4><p>而如果 <span class="math inline"><em>H</em><sub>0</sub></span>实际上为假（即 <span class="math inline"><em>H</em><sub>1</sub></span>为真），但根据样本错误地接受了 <span class="math inline"><em>H</em><sub>0</sub></span>，此时也犯了错误，称这类错误为<strong>第Ⅱ类错误</strong>（又称为<strong>“存伪”错误</strong>）</p><ul><li>犯第Ⅱ类错误的概率为 <span class="math display"><em>P</em>(接受<em>H</em><sub>0</sub> ∣ <em>H</em><sub>0</sub>为假) = <em>P</em>(接受<em>H</em><sub>0</sub> ∣ <em>H</em><sub>1</sub>为真) = <em>β</em></span></li></ul><h4 id="两种情况">两种情况</h4><table><tbody><tr><td colspan="2" rowspan="2"></td><td colspan="2"><div style="text-align：center">所做判断</div></td></tr><tr><td>接受 <span class="math inline"><em>H</em><sub>0</sub></span></td><td>拒绝 <span class="math inline"><em>H</em><sub>0</sub></span></td></tr><tr><td rowspan="2">实际情况</td><td><span class="math inline"><em>H</em><sub>0</sub></span> 为真</td><td>正确（<span class="math inline">1 − <em>α</em></span>）</td><td>犯第Ⅰ类错误（<span class="math inline"> ≤ <em>α</em></span>）</td></tr><tr><td><span class="math inline"><em>H</em><sub>0</sub></span> 为假</td><td>犯第Ⅱ类错误（<span class="math inline"><em>β</em></span>）</td><td>正确（<span class="math inline">1 − <em>β</em></span>）</td></tr></tbody></table><h3 id="p-检验法">p 检验法</h3><p>在 <span class="math inline"><em>p</em></span>值检验法中，无须事先给出显著性水平，在原假设 <span class="math inline"><em>H</em><sub>0</sub></span>成立的基础上所构造的检验统计量 <span class="math inline"><em>U</em></span> 以及拒绝域 <span class="math inline">𝒲</span> 都与经典方法相同</p><ul><li><strong>p 检验的基本步骤</strong><ul><li>首先算出检验统计量的观测值（把它记为 <span class="math inline"><em>u</em><sub>0</sub></span>），再计算事件 <span class="math inline">|<em>U</em>| &gt; |<em>u</em><sub>0</sub>|</span>的概率，假设 <span class="math inline"><em>P</em>(|<em>U</em>| &gt; |<em>u</em><sub>0</sub>|) = <em>p</em></span>，这个<span class="math inline"><em>p</em></span>值就等于拒绝原假设的概率</li><li>如果这个 <span class="math inline"><em>p</em></span>值很小，我们认为发生这个事件的可能性非常小，因而拒绝 <span class="math inline"><em>H</em><sub>0</sub></span>；如果这个概率不算太小，则接受原假设</li></ul></li><li>p 值检验法和经典方法的关联：<ul><li>假设设定了一个显著性水平 <span class="math inline"><em>α</em></span>，此时如果 <span class="math inline"><em>p</em> ≤ <em>α</em></span>，则表明比 <span class="math inline"><em>α</em></span> 更小概率值的事件发生了，故拒绝<span class="math inline"><em>H</em><sub>0</sub></span>；</li><li>反之，若 <span class="math inline"><em>p</em> &gt; <em>α</em></span>，则接受 <span class="math inline"><em>H</em><sub>0</sub></span></li></ul></li></ul><h2 id="单个正态总体参数的假设检">单个正态总体参数的假设检</h2><h3 id="单个正态总体均值的假设检验">单个正态总体均值的假设检验</h3><h3 id="方差已知-u-检验法">方差已知 (U 检验法)</h3><p>检验统计量： <span class="math display">$$U=\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}} \sim N(0,1)$$</span></p><table><thead><tr><th style="text-align: center;">原假设 <span class="math inline"><em>H</em><sub>0</sub></span></th><th style="text-align: center;">备择假设 <span class="math inline"><em>H</em><sub>1</sub></span></th><th style="text-align: center;">拒绝域 <span class="math inline">𝒲</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline"><em>μ</em> = <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>μ</em> ≠ <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline">$\mid U\mid\gez_\frac{\alpha}{2}$</span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>μ</em> ≥ <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>μ</em> &lt; <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>U</em> ≤ −<em>z</em><sub><em>α</em></sub></span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>μ</em> ≤ <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>μ</em> &gt; <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>U</em> ≥ <em>z</em><sub><em>α</em></sub></span></td></tr></tbody></table><h3 id="方差未知-1">方差未知</h3><p>小样本 (<span class="math inline"><em>n</em> &lt; 30</span>)情况下，用 t 分布来检验总体均值，通常称为 t 检验，统计量 <span class="math display">$$T=\frac{\bar{X}-\mu_{0}}{S / \sqrt{n}} \sim t(n-1)$$</span></p><table><thead><tr><th style="text-align: center;">原假设 <span class="math inline"><em>H</em><sub>0</sub></span></th><th style="text-align: center;">备择假设 <span class="math inline"><em>H</em><sub>1</sub></span></th><th style="text-align: center;">拒绝域 <span class="math inline">𝒲</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline"><em>μ</em> = <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>μ</em> ≠ <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline">$\mid T\mid\get_\frac{\alpha}{2}(n-1)$</span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>μ</em> ≥ <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>μ</em> &lt; <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>T</em> ≤ −<em>t</em><sub><em>α</em></sub>(<em>n</em> − 1)</span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>μ</em> ≤ <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>μ</em> &gt; <em>μ</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>T</em> ≥ <em>t</em><sub><em>α</em></sub>(<em>n</em> − 1)</span></td></tr></tbody></table><h3 id="单个正态总体方差的假设检验">单个正态总体方差的假设检验</h3><h4 id="均值已知">均值已知</h4><p>选取检验统计量 <span class="math display">$$\chi^{2}=\frac{\sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}}{\sigma_{0}^{2}}\sim \chi^{2}(n)$$</span></p><table><thead><tr><th style="text-align: center;">原假设 <span class="math inline"><em>H</em><sub>0</sub></span></th><th style="text-align: center;">备择假设 <span class="math inline"><em>H</em><sub>1</sub></span></th><th style="text-align: center;">拒绝域 <span class="math inline">𝒲</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> = <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> ≠ <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline">$\chi^2\ge\chi_\frac{\alpha}{2}(n)$</span> 或 <span class="math inline">$\chi^2\le\chi_{1-\frac{\alpha}{2}}(n)$</span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> ≥ <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> &lt; <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>χ</em><sup>2</sup> ≤ <em>χ</em><sub>1 − <em>α</em></sub>(<em>n</em>)</span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> ≤ <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> &gt; <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>χ</em><sup>2</sup> ≥ <em>χ</em><sub><em>α</em></sub>(<em>n</em>)</span></td></tr></tbody></table><h4 id="均值未知">均值未知</h4><p>选取检验统计量 <span class="math display">$$\chi^{2}=\frac{(n-1)S^{2}}{\sigma_{0}^{2}}=\frac{\sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}}{\sigma_{0}^{2}}\sim \chi^{2}(n-1)$$</span></p><table><thead><tr><th style="text-align: center;">原假设 <span class="math inline"><em>H</em><sub>0</sub></span></th><th style="text-align: center;">备择假设 <span class="math inline"><em>H</em><sub>1</sub></span></th><th style="text-align: center;">拒绝域 <span class="math inline">𝒲</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> = <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> ≠ <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline">$\chi^2\ge\chi_\frac{\alpha}{2}(n-1)$</span> 或 <span class="math inline">$\chi^2\le\chi_{1-\frac{\alpha}{2}}(n-1)$</span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> ≥ <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> &lt; <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>χ</em><sup>2</sup> ≤ <em>χ</em><sub>1 − <em>α</em></sub>(<em>n</em> − 1)</span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> ≤ <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>σ</em><sup>2</sup> &gt; <em>σ</em><sub>0</sub><sup>2</sup></span></td><td style="text-align: center;"><span class="math inline"><em>χ</em><sup>2</sup> ≥ <em>χ</em><sub><em>α</em></sub>(<em>n</em> − 1)</span></td></tr></tbody></table><h3 id="随机事件概率-p-的假设检验">随机事件概率 p 的假设检验</h3><p>选取检验统计量 <span class="math display">$$U=\frac{\bar{X}-p_{0}}{\sqrt{p_{0}\left(1-p_{0}\right) / n}}\stackrel{\text { 近似 }}{\sim} N(0,1)$$</span></p><table><thead><tr><th style="text-align: center;">原假设 <span class="math inline"><em>H</em><sub>0</sub></span></th><th style="text-align: center;">备择假设 <span class="math inline"><em>H</em><sub>1</sub></span></th><th style="text-align: center;">拒绝域 <span class="math inline">𝒲</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline"><em>p</em> = <em>p</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>p</em> ≠ <em>p</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline">$\mid U\mid\gez_\frac{\alpha}{2}$</span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>p</em> ≥ <em>p</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>p</em> &lt; <em>p</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>U</em> ≤ −<em>z</em><sub><em>α</em></sub></span></td></tr><tr><td style="text-align: center;"><span class="math inline"><em>p</em> ≤ <em>p</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>p</em> &gt; <em>p</em><sub>0</sub></span></td><td style="text-align: center;"><span class="math inline"><em>U</em> ≥ <em>z</em><sub><em>α</em></sub></span></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 概率统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络空间安全导论</title>
      <link href="/_posts/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/"/>
      <url>/_posts/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-网络空间安全概述">第一章 网络空间安全概述</h1><h2 id="第一节-信息时代及信息安全">第一节 信息时代及信息安全</h2><h3 id="网络空间安全-初步接触">网络空间安全-初步接触</h3><p>信息时代特征</p><ol type="1"><li>新摩尔定律</li><li>吉尔德定律</li><li>千倍定律</li></ol><h3 id="当前网络信息安全态势">当前网络信息安全态势</h3><ol type="1"><li><strong>信息技术与产业空前繁荣</strong></li><li><strong>量子信息技术高速发展</strong></li><li><strong>信息安全形势严峻，危机四伏的网络世界</strong></li><li><strong>敌对势力破坏</strong></li><li><strong>黑客组织攻击</strong></li><li><strong>计算机病毒入侵</strong></li><li><strong>利用计算机进行经济犯罪</strong></li><li><strong>有害内容泛滥、隐私保护问题严重</strong></li><li><strong>网络安全形式严峻</strong><ul><li>信息战 网络战</li><li>网络空间安全对抗愈益加剧</li><li>信息技术对信息安全的挑战</li></ul></li><li><strong>国家对信息安全的重视</strong></li></ol><h3 id="网络信息安全发展趋势">网络信息安全发展趋势</h3><ol type="1"><li>网络信息安全已成为关系社会、文化、经济、军事乃至国家安全的重大战略问题。<ul><li>网络信息安全成为重大战略问题，涉及国家安全各方面，网络犯罪造成巨大经济损失，美国成立网络司令部加强网络空间争夺。</li></ul></li><li>网络安全威胁层出不穷，网络关键基础设施隐患重重。<ul><li>网络安全威胁不断，关键基础设施受攻击影响重大，黑客攻击针对性增强，恶意代码增长迅速。</li></ul></li><li>网络空间国家间的竞争与合作日趋凸显。<ul><li>网络空间国家间竞争合作凸显，“军备竞赛”开始，多国组建网络战部队，斯诺登事件引发网络空间新型对抗。</li></ul></li><li>国际互联网治理领域迎来新热潮，信息资源保护成为各国焦点<ul><li>国际互联网治理成热潮，信息资源保护受关注，网络基础设施漏洞威胁全球，各国重视互联网治理权。</li></ul></li></ol><h2 id="第二节-法律法规及标准概述">第二节 法律法规及标准概述</h2><h3 id="学科内涵">学科内涵</h3><ul><li><p><strong>网络空间安全的定义与内涵</strong></p><ul><li>网络空间是信息时代人类赖以生存的信息环境，是所有信息系统的集合。它以计算机和网络系统实现的信息化为特征。</li><li>网络空间是人的生存环境，也是信息的生存环境。</li><li>网络空间安全研究网络空间中安全威胁与防护问题。</li><li>核心内涵为信息安全。</li></ul></li><li><p><strong>信息的安全属性—C.I.A三要素</strong></p><ul><li><strong>机密性</strong>是指保证信息与信息系统不被非授权者截获和未经授权使用。</li><li><strong>完整性</strong>是指信息是完整的，真实的、未被篡改的、正确的。</li><li><strong>可用性</strong>是指信息与信息系统服务可被授权人正常使用</li><li>其它基本要素：非否认性、可控性</li></ul></li><li><p><strong>信息系统安全层次结构</strong></p><ul><li><strong>设备安全</strong>：信息系统设备的安全是是信息系统安全的物质基础，是信息系统安全的首要问题，软硬件系统的安全（稳定、可靠、可用）</li><li><strong>行为安全</strong>：主体行为的过程和结果来考察是否会危害信息安全，数据安全本质上是一种静态的安全，而行为体现在过程和结果之中，行为安全是一种动态安全。</li><li><strong>数据安全</strong>：数据免受未授权的泄露、篡改和毁坏。数据安全本质上是一种静态的安全，而行为体现在过程和结果之中，行为安全是一种动态安全。</li><li><strong>内容安全</strong>：信息安全在政治、法律、道德层次上的要求，是语义层次的安全，内容安全还包括信息内容保密、知识产权保护、信息隐藏和隐私保护等诸多方面</li></ul></li><li><p><strong>信息安全三大定律</strong></p><ul><li>普遍性定律指出有信息就有安全问题；</li><li>折中性定律表明安全与方便是矛盾体；</li><li>就低性定律说明系统安全性取决于最薄弱部分（木桶原理）。</li></ul></li><li><p><strong>网络空间安全学科定义</strong></p><ul><li>网络空间安全学科是研究信息获取、信息存储、信息传输和信息处理领域中信息安全保障问题的一门新兴学科。</li></ul></li><li><p><strong>理论基础</strong></p><ul><li>数学：数论、代数、组合数学、概率统计等数学分支，是密码学的理论基础</li><li>逻辑学是网络协议安全基础：协议是网络的核心，协议安全是网络安全的核心。</li><li>博弈论是网络空间安全特有理论</li><li>信息论、控制论和系统论是现代科学的理论基础：信息论是密码学和信息隐藏基础，系统论核心是整体观念，控制论体现于信息安全PDR策略。</li></ul></li><li><p><strong>方法论基础</strong></p><ul><li>以解决网络空间安全问题为目标、以适应网络空间安全需求为特征的具体科学方法论</li><li><strong>逆向分析</strong>是网络空间安全学科特有的方法论，该学科领域斗争具攻防对抗性</li><li>方法论的应用：强调底层性、系统性，综合治理追求整体效能，坚持“以人为核心”，注重定性定量分析相结合。</li></ul></li></ul><h3 id="立法现状">立法现状</h3><ol type="1"><li><strong>国际立法现状</strong><ul><li>美国通过多部法律，如信息自由法等，还有总统令及相关法案；俄罗斯颁布联邦信息相关法律；欧盟建立一系列法律，如数据保护法等，近年通过网络安全相关指令和条例。</li></ul></li><li><strong>我国立法现状</strong><ul><li>早期我国计算机信息安全立法属“渗透型”，将相关规范融入其他法律法规，初步形成法律规范体系。现有法律法规众多，包括国务院令发布的条例、全国人大通过的决定、网络安全法等一系列法律，还有部门规范如计算机信息网络国际联网安全保护管理办法等。</li><li><figure><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="相关法律法规"><figcaption aria-hidden="true">相关法律法规</figcaption></figure></li></ul></li><li><strong>我国立法不足与体系</strong><ul><li>我国立法存在规范需完善升级、部分应用缺法律支持、执法需高技术支撑等问题，立法体系涵盖法律、行政法规、部门规章等不同层次。</li></ul></li></ol><h3 id="计算机犯罪有关刑法条款">计算机犯罪有关刑法条款</h3><ol type="1"><li><strong>相关法律条款发展历程</strong><!-- - 随着计算机技术发展，计算机犯罪相关法律条款不断演进，经历多次刑法修正案完善，包括对计算机信息系统的非法侵入、控制，对系统功能、数据和程序的破坏，以及利用计算机实施的各类犯罪等方面的规定。 --></li><li><strong>具体刑法条款内容</strong><!-- - 如《刑法》第二百八十五条规定了非法侵入特定计算机信息系统及获取数据、非法控制的刑罚；第二百八十六条规定了对计算机信息系统功能、数据和程序进行破坏以及制作传播病毒的刑罚；第二百八十七条规定利用计算机实施其他犯罪依照相关规定定罪处罚。此外，还有《全国人民代表大会常务委员会关于维护互联网安全的决定》对互联网运行安全、国家安全、市场经济秩序等方面的刑事责任作出规定，以及《中华人民共和国计算机信息系统安全保护条例》确立了信息系统安全保护的多项制度，包括等级保护、机房标准、联网备案等，同时对违反规定的行为设定了相应处罚措施。 --></li></ol><h3 id="标准的基本知识">标准的基本知识</h3><ol type="1"><li><strong>标准的定义与分类</strong><ul><li>标准是通过标准化活动，按照规定的程序协商一致制定，为各种活动或其结果提供规则、指南或特性，供共同使用和重复使用的文件。</li><li>《中华人民共和国标准化法》将标准划分为：<strong>国家标准、行业标准、地方标准和企业标准</strong></li><li>国家标准、行业标准均可分为：<strong>强制性和推荐性</strong>两种属性的标准。强制性国家标准代号：GB，推荐性国家标准代号：GB/T</li><li>标准、规范、规程都是标准的一种表现形式,习惯上统称为标准。</li></ul></li><li><strong>国际标准化组织</strong><ul><li>国际电工委员会（IEC）是最早的国际性电工标准化组织；国际标准化组织（ISO）及其从事信息安全标准化工作的分技术委员会（SC27）；互联网工程任务组（IETF）也在相关领域发挥作用。</li></ul></li><li><strong>我国标准化组织</strong><ul><li>全国信息安全标准化技术委员会（信安标委）负责全国信息安全标准化工作；密码行业标准化技术委员会（密标委CSTC）负责密码领域标准化工作。</li></ul></li></ol><h3 id="信息安全标准">信息安全标准</h3><ol type="1"><li><strong>涉密信息系统分级保护管理办法</strong><ul><li>涉密信息系统分级保护依据涉密程度分为<strong>秘密级、机密级、绝密级</strong>，<strong>国家保密局</strong>是涉密信息系统分级保护工作的主管部门。</li></ul></li><li><strong>信息系统等级保护基本要求</strong><ul><li>信息安全等级保护的核心是分级及保护</li><li>信息系统安全等级保护的内容可分为<strong>系统定级、系统备案、建设整改、测评、监督检查</strong>五个方面</li><li>信息系统的分级主要是依据对国家、社会、法人及组织的损害程度及范围来确定的。损害小、范围也小的，级别低、保护要求也低；损害大、范围大的，级别高，保护的要求就相应增加</li><li>等级保护1.0 vs 2.0<ul><li>安全分类变化：<img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="安全分类变化"></li><li>标准名称变化：信息安全等级保护基本要求 →网络安全等级保护基本要求</li><li>等级保护对象变化：信息系统 →增加云计算平台、大数据平台、移动互联、物联网和工业控制系统等要求</li><li>安全要求变化：安全要求 → 安全通用要求+安全扩展要求</li><li>安全管理中心：2.0在二级及以上增加了“安全管理中心”</li><li>可信验证：2.0在多个技术环节增加了“可信验证”控制点</li></ul></li></ul></li><li><strong>商用密码标准</strong><ul><li>商用密码的行业标准分为基础类标准、应用类标准、检测类标准和管理类标准。</li><li>基础类标准为其他三类标准提供了底层、共性支撑（如术语、算法、协议、产品等）；</li><li>应用类标准为上层具体的密码产品、服务应用提供支持；</li><li>检测类标准为基础类标准和应用类标准提供了合法性检测的功能，保障商用密码使用的合法性；</li><li>管理类标准为其他三类标准提供了管理功能；</li><li>我国多个商用密码算法成为国际标准，如SM2、SM3、SM4、SM9和ZUC算法等，ZUC（祖冲之）算法还被3GPP采纳为国际标准并成为国家和行业标准。</li></ul></li></ol><h2 id="第三节-保密法及密码法">第三节 保密法及密码法</h2><h3 id="保密法概述">保密法概述</h3><ol type="1"><li><strong>保密法历史</strong><ul><li>1951年6月8日，周恩来总理签署中央人民政府政密字377号命令，公布实行《保守国家机密暂行条例》。</li><li>1988年9月5日，第七届全国人民代表大会常务委员会第三次会议审议通过了《中华人民共和国保守国家秘密法》，自1989年5月1日起实行。</li><li>2010年4月29日，第十一届全国人民代表大会常务委员会第十四次会议修订通过《中华人民共和国保守国家秘密法》，自2010年10月1日起施行。</li><li>最新修订在2024年2月27日，由第十四届全国人民代表大会常务委员会第八次会议通过，自2024年5月1日起施行。</li></ul></li><li><strong>保密法结构</strong><ul><li>《中华人民共和国保守国家秘密法》共六章65条。</li><li>包括总则、国家秘密的范围和密级、保密制度、监督管理、法律责任和附则。</li></ul></li></ol><h3 id="保密法内容解读">保密法内容解读</h3><ol type="1"><li><p><strong>一些案例</strong><!-- - 2003年铁矿石交易事件导致中国经济损失高达7000亿人民币。- 2009年7月5日，胡士泰等四名力拓员工因侵犯商业秘密罪、非国家工作人员受贿罪被刑事拘留。- GoogleEarth地球服务暴露了许多国家的政府大楼、军事设施以及敏感地点。- 1964年《中国画报》封面刊出的照片泄露了大庆油田的位置、储量和产量。- 2016年，俄罗斯士兵手机拍照泄露了航母“库兹涅佐夫”号内机库细节。 --></p></li><li><p><strong>国家秘密及范围</strong></p><ul><li>国家秘密是关系国家安全和利益，依照法定程序确定，在一定时间内只限一定范围的人员知悉的事项。</li><li>包括国家事务、国防建设、外交外事、国民经济和社会发展、科学技术、国家安全活动和追查刑事犯罪等事项。</li></ul></li><li><p><strong>国家秘密的范围及密级</strong></p><ul><li>国家秘密及其密级的具体范围，即保密事项范围，由国家保密行政管理部门单独或会同有关中央国家机关规定。</li><li>国家秘密的密级分为<strong>绝密、机密、秘密</strong>三级。</li><li>国家秘密的保密期限，应当根据事项的性质和特点，按照维护国家安全和利益的需要，限定在必要的期限内；不能确定期限的，应当确定解密的条件。</li><li>国家秘密的保密期限，除另有规定外，绝密级不超过三十年，机密级不超过二十年，秘密级不超过十年。</li></ul></li><li><p><strong>保密制度</strong></p><ul><li>国家秘密载体的制作、收发、传递、使用、复制、保存、维修和销毁应符合国家保密规定。</li><li>存储、处理国家秘密的计算机信息系统应实行<strong>分级保护</strong>，并配备保密设施、设备。</li></ul></li><li><p><strong>涉密人员管理</strong></p><ul><li>涉密人员按照涉密程度分为<strong>核心涉密人员、重要涉密人员和一般涉密人员</strong>，实行分类管理。</li><li>涉密人员离岗离职应当遵守国家保密规定。机关、单位应当开展保密教育提醒，清退国家秘密载体，<strong>实行脱密期管理</strong>。</li></ul></li><li><p><strong>涉密计算机和涉密载体保密管理</strong></p><ul><li>加强对信息系统、信息设备的保密管理，建设保密自监管设施。</li><li>加强对国家秘密载体的管理，禁止非法获取、持有、买卖、转送或私自销毁国家秘密载体。</li></ul></li><li><p><strong>12种违规行为</strong></p><ul><li>（一）非法获取、持有国家秘密载体的；</li><li>（二）买卖、转送或者私自销毁国家秘密载体的；</li><li>（三）通过普通邮政、快递等无保密措施的渠道传递国家秘密载体的；</li><li>（四）寄递、托运国家秘密载体出境，或者未经有关主管部门批准，携带、传递国家秘密载体出境的；</li><li>（五）非法复制、记录、存储国家秘密的；</li><li>（六）在私人交往和通信中涉及国家秘密的；</li><li>（七）未按照国家保密规定和标准采取有效保密措施，在互联网及其他公共信息网络或者有线和无线通信中传递国家秘密的；</li><li>（八）未按照国家保密规定和标准采取有效保密措施，将涉密信息系统、涉密信息设备接入互联网及其他公共信息网络的；</li><li>（九）未按照国家保密规定和标准采取有效保密措施，在涉密信息系统、涉密信息设备与互联网及其他公共信息网络之间进行信息交换的；</li><li>（十）使用非涉密信息系统、非涉密信息设备存储、处理国家秘密的；</li><li>（十一）擅自卸载、修改涉密信息系统的安全技术程序、管理程序的</li><li>（十二）将未经安全技术处理的退出使用的涉密信息设备赠送、出售、丢弃或者改作其他用途的；</li><li>（十三）其他违反本法规定的情形。</li></ul></li><li><p><strong>法律责任</strong><!-- - 违反本法规定，发生重大泄密案件的，对直接负责的主管人员和其他直接责任人员给予处分。 --></p></li></ol><h3 id="密码法概述">密码法概述</h3><ol type="1"><li><strong>密码重要性</strong><ul><li>密码是党和国家的“命门”、“命脉”，是国家重要战略资源。密码工作是党和国家的一项特殊重要工作，直接关系国家政治、经济、国防和信息安全。</li></ul></li><li><strong>密码法发展历程</strong><ul><li>1999年国务院颁布《商用密码管理条例》，2005年国家密码管理局正式成立。</li><li>2019年10月26日，《中华人民共和国密码法》通过，习近平主席签署第35号主席令予以公布。</li><li>密码法的颁布实施，是我国密码发展史上具有里程碑意义的大事，有助于提升我国密码工作的规范化、科学化、法治化水平：一是规范密码应用和管理，促进密码事业发展；二是保障网络与信息安全，维护国家安全和社会公共利益，保护公民、法人和其他组织的合法权益。</li><li>对维护我国网络空间安全、促进信息化发展具有重要意义，也直接关系企业商业秘密的依法保护，关系社会公众在网络空间生活的安全和便利。</li></ul></li><li><strong>密码的应用</strong><ul><li>区块链技术是分布式账本技术，核心是密码技术。</li><li>增值税防伪税控系统采用商用密码技术保护涉税信息，减少税收流失。</li></ul></li></ol><h3 id="密码法内容解读">密码法内容解读</h3><ol type="1"><li><strong>中华人民共和国密码法内容</strong><ul><li>《中华人民共和国密码法》自2020年1月1日起施行，共五章44条。</li><li>密码是国家重要战略资源，是保障网络与信息安全的核心技术和基础支撑。</li><li><ol type="1"><li>什么是密码</li></ol><ul><li>“是指采用特定变换的方法对信息等进行加密保护、安全认证的技术、产品和服务”</li><li>核心密码用于保护国家绝密级、机密级、秘密级信息</li><li>普通密码用于保护国家机密级、秘密级信息</li><li>商用密码用于保护不属于国家秘密的信息</li><li>对密码实行分类管理，是党中央确定的密码管理根本原则，是保障密码安全的基本策略</li></ul></li><li><ol start="2" type="1"><li>谁来管密码</li></ol><ul><li>坚持党管密码根本原则</li><li>中央密码工作领导小组（国家密码管理委员会），对全国密码工作实行统一领导</li><li>国家、省、市、县四级密码工作管理体制</li></ul></li><li><ol start="3" type="1"><li>怎么管密码</li></ol><ul><li>第二章（第十三条至第二十条）规定了核心密码、普通密码的主要管理制度：密码管理部门依法对核心密码、普通密码实行严格统一管理，并规定了核心密码、普通密码使用要求安全管理制度以及国家加强核心密码、普通密码工作的一系列特殊保障制度和措施。核心密码、普通密码本身就是国家秘密，一旦泄密，将危害国家安全和利益</li><li>第三章（第二十一条至第三十一条）规定了商用密码的主要管理制度：商用密码的主要管理制度，包括商用密码标准化制度、检测认证制度、市场准入管理制度、使用要求、进出口管理制度、电子政务电子认证服务管理制度以及商用密码事中事后监管制度</li></ul></li><li><ol start="4" type="1"><li>怎么用密码</li></ol><ul><li>第十四条要求在有线、无线通信中传递的国家秘密信息，以及存储、处理国家秘密信息的信息系统，应当依法使用核心密码、普通密码进行加密保护、安全认证</li><li>第八条规定公民、法人和其他组织可以依法使用商用密码保护网络与信息安全，对一般用户使用商用密码没有强制性要求</li><li>为了保障关键信息基础设施安全稳定运行，维护国家安全和社会公共利益，第二十七条要求关键信息基础设施必须依法使用商用密码进行保护</li><li>党政机关存在大量的涉密信息、信息系统和关键信息基础设施，都必须依法使用密码进行保护</li></ul></li></ul></li><li><strong>商用密码标准体系</strong><ul><li>国家建立和完善商用密码标准体系，推进商用密码检测认证体系建设。</li><li>商用密码检测、认证机构应当依法取得相关资质，并依照法律、行政法规的规定和商用密码检测认证技术规范、规则开展商用密码检测认证。</li></ul></li><li><strong>商用密码产品</strong><ul><li>涉及国家安全、国计民生、社会公共利益的商用密码产品，应列入网络关键设备和网络安全专用产品目录。</li><li>商用密码产品检测认证适用《中华人民共和国网络安全法》的有关规定，避免重复检测认证。</li></ul></li><li><strong>法律责任</strong><ul><li>违反密码法规定的行为，将依法追究法律责任。</li></ul></li></ol><h2 id="第四节-网络安全法">第四节 网络安全法</h2><h3 id="网络安全立法背景">网络安全立法背景</h3><ol type="1"><li><p><strong>全球性问题</strong></p><ul><li>应对网络安全威胁已是全球性问题，国际网络安全的法治环境正发生巨大变革。</li><li>美欧等网络强国纷纷建立全方位、立体化、更具弹性与前瞻性的网络安全立法体系。</li><li><strong>网络安全立法已演变为全球范围内的国家主权与利益的斗争，有法可依成为了谈判与对抗的必要条件。</strong></li></ul></li><li><p><strong>国际背景</strong>：合作与共赢、冲突与对抗</p></li><li><p><strong>国内背景</strong></p><ul><li>网络安全人才建设滞后，人才缺乏。</li><li>大量网络安全事件和经济损失。</li><li>新技术持续发展与应用。</li><li>地下黑产不断扩大，网络攻击频繁发生。</li><li>我国信息化建设的突飞猛进。</li><li>法律法规条纹分散、监管滞后。</li></ul></li><li><p><strong>网络安全事件特点</strong></p><ul><li>目标明确：<ul><li>信息安全事件大多为敌对国家或利益集团为达到某种目的而发起的网络攻击。往往是向指定的目标发起特定的网络攻击，具有极强的针对性。</li></ul></li><li>隐蔽性强：<ul><li>攻击工业控制系统的病毒和黑客，异常熟悉工业控制系统的网络情况，攻击方法独特导致无法及时发现，具有极强的隐蔽能力，可以长时间隐藏于工业控制系统中。</li></ul></li><li>破坏严重：<ul><li>电力、能源、金融等系统如果遭到破坏，轻则造成经济损，重则会造成人身伤亡，甚至会影响地区和国家的安定，乃至国家战略和重大计划的执行都会受到阻挠。</li></ul></li></ul></li><li><p><strong>网络安全立法的需求</strong></p></li><li><p><strong>国外网络安全立法状况</strong></p></li><li><p><strong>网络空间安全顶层设计</strong></p></li><li><p><strong>国家高度重视</strong></p></li><li><p><strong>立法进程</strong></p></li></ol><h3 id="网络安全法的重大意义">网络安全法的重大意义</h3><ol type="1"><li><strong>立法里程碑</strong><ul><li>《网络安全法》的出台具有里程碑式的意义，是全面落实党的十八大和十八届三中、四中、五中、六中全会相关决策部署的重大举措。</li><li>我国<strong>第一部网络安全的专门性综合性立法</strong>，提出了应对网络安全挑战这一全球性问题的中国方案。</li><li>立法进程的快速推进，显示了党和国家对网络安全问题的高度重视，是我国网络安全法治建设的一个重大战略契机。</li><li>网络安全有法可依，信息安全行业将<strong>由合规性驱动过渡到合规性和强制性驱动并重</strong>。</li></ul></li><li><strong>服务与国家网络安全战略和网络强国建设</strong><ul><li>网络空间逐步成为世界主要国家展开竞争和战略博弈的新领域。确立网络空间行为准则和模式已是当务之急。</li><li>《网络安全法》中明确提出了有关国家网络空间安全战略和重要领域安全规划等问题的法律要求，这有助于实现推进中国在国家网络安全领域明晰战略意图，确立清晰目标，厘清行为准则，不仅能够提升我国保障自身网络安全的能力，还有助于推进与其他国家和行为体就网络安全问题展开有效的战略博弈。</li></ul></li><li><strong>助力网络空间治理，护航“互联网+”</strong><ul><li>我国是名符其实的网络大国，但现实的网络环境十分堪忧。</li><li>《网络安全法》将成为新的起点和转折点。</li></ul></li><li><strong>构建我国首部网络空间管辖基本法</strong><ul><li>《网络安全法》属于国家基本法律，是网络安全法制体系的重要基础。</li><li>《网络安全法》规定了信息安全法的总体目标和基本原则；规范网络社会中不同主体所享有的权力义务及其地位；建立网站身份认证制度，实施后台实名；建立网络信息保密制度，保护网络主体的隐私权；建立行政机关对网络信息安全的监管程序和制度，规定对网络信息安全犯罪的惩治和打击；规定具体的诉讼救济程序等等。</li><li>《网络安全法》的出台从根本上填补了<strong>我国综合性网络信息安全基本大法</strong>、核心的网络信息安全法和专门法律的三大空白。</li></ul></li><li><strong>提供维护国家网络主权的法律依据</strong><ul><li>我国在2016年7月推出了《国家安全法》，首次以法律的形式明确提出了“维护国家网络空间主权”。</li><li>《网络安全法》是《国家安全法》在网络安全领域的体现和延伸，为我国维护网络主权、国家安全提供了最主要的法律依据。</li></ul></li><li><strong>在网络空间领域贯彻落实依法治国精神</strong><ul><li>十八届四中全会通过了《中共中央关于全面推进依法治国若干重大问题的决定》。</li><li>《网络安全法》则开启了依法治网的崭新局面，成为依法治国顶层设计下一项共建共享的路径实践。</li><li>依法治网成为我国网络空间治理的主线和引领，依法治谋求网治的长治久安。</li></ul></li><li><strong>成为网络参与者普遍遵守的法律准则和依据</strong><ul><li>《网络安全法》的执行，成为各方参与互联网上的行为提供非常重要的准则。</li><li>《网络安全法》对网络产品和服务提供者的安全义务有了明确的规定，将现行的安全认证和安全检测制度上升成为了法律</li></ul></li></ol><h3 id="网络安全法概览及亮点">网络安全法概览及亮点</h3><ol type="1"><li><strong>概览</strong><ul><li>《网络安全法》亮点包括：<ul><li>监测预警与应急处置措施的制度化、法制化</li><li>明确了网络空间主权的原则</li><li>建立了关键信息基础设施安全保护制度</li><li>明确了网络产品和服务提供者的安全义务</li><li>进一步完善了个人信息保护规则</li><li>明确了网络运营者的安全义务</li></ul></li></ul></li><li><strong>亮点</strong><ul><li>全面性：<ul><li>全面和系统地确立了各个主体包括国家有关主管部门、网络运营者、网络使用者在网络安全保护方面的义务和责任；</li><li>确立了保障网络的设备设施安全、网络运行安全、网络数据安全以及网络信息安全等方面的基本制度。</li></ul></li><li>针对性：<ul><li>从我国的国情出发，坚持问题的导向，总结实践经验，也借鉴了其他国家的一些做法，建立保障网络安全的各项制度，重在管用，重在解决实际问题</li></ul></li><li>协调性：<ul><li>始终坚持安全与发展并重的原则，协调推进网络安全和发展，注重保护网络主体的合法权益，保障网络信息依法、有序、自由的流动，促进网络技术创新，最终实现以安全促发展，以发展来促安全的目的。</li></ul></li></ul></li></ol><h3 id="网络安全法重要条款解读">网络安全法重要条款解读</h3><ol type="1"><li><strong>第一章 总则</strong><ul><li>描述制定网络安全法的目的和适用范围，保障网络安全的目标以及各部门、企业、个人所承担的责任义务，并强调将大力宣传普及，加快配套制度建设，加强基础支撑力量建设，确保网络安全法有效贯彻实施。</li></ul></li><li><strong>第二章 网络安全支持与促进</strong><ul><li>要求政府、企业和相关部门通过多种形式对企业和公众开展网络安全宣传教育，提高安全意识。鼓励企业、高校等单位加强对网络安全人才的培训和教育，解决目前网络安全人才严重不足问题。另外鼓励和支持通过创新技术来提升安全管理，保护企业和个人的重要数据。</li></ul></li><li><strong>第三章 网络运行安全</strong><ul><li>特别强调要保障关键信息基础设施的运行安全。安全是重中之重，与国家安全和社会公共利益息息相关。《网络安全法》强调在网络安全等级保护制度的基础上，对关键信息基础设施实行重点保护，明确关键信息基础设施的运营者负有更多的安全保护义务，并配以国家安全审查、重要数据强制本地存储等法律措施，确保关键信息基础设施的运行安全。</li></ul></li><li><strong>第四章 网络信息安全</strong><ul><li>从三个方面要求加强网络数据信息和个人信息的安全：第一是要求网络运营者对个人信息采集和提取方面采取技术措施和管理办法，加强对公民个人信息的保护，防止公民个人信息数据被非法获取、泄露或者非法使用；第二、赋予监管部门、网络运营者、个人或组织的职责和权限并规范网络合规行为，彼此互相监督管理；第三在有害或不当信息发布和和传输过程中分别对监管者、网络运营商、个人和组织提出了具体处理办法。</li></ul></li><li><strong>第五章 监测预警与应急处置</strong><ul><li>将监测预警与应急处置工作制度化、法制化，明确国家建立网络安全监测预警和信息通报制度，建立网络安全风险评估和应急工作机制，制定网络安全事件应急预案并定期演练。这为建立统一高效的网络安全风险报告机制、情报共享机制、研判处置机制提供了法律依据，为深化网络安全防护体系，实现全天候全方位感知网络安全态势提供了法律保障。</li></ul></li><li><strong>第六章 法律责任</strong><ul><li>规定了违反网络安全法的法律责任，包括行政处罚、民事责任、治安管理处罚和刑事责任。<ul><li>行政处罚：责令改正、警告、罚款，有关机关还可以把违法行为记录到信用档案，对于“非法入侵”等，法律还建立了职业禁入的制度。&nbsp;</li><li>民事责任：违法《网络安全法》的行为给他人造成损失的，网络运营者应当承担相应的民事责任。</li><li>治安管理处罚/刑事责任：违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。</li></ul></li></ul></li></ol><h2 id="第五节-数据安全法">第五节 数据安全法</h2><h3 id="立法背景">立法背景</h3><ol type="1"><li><strong>国内外背景</strong><ul><li>数据价值凸显：随着5G、IoT、AI等信息技术革命的推进，数据量进入ZB级别，数据成为数字经济发展的新生产要素。</li><li>数据泄露事件频发：如美国棱镜事件、Facebook数据泄漏事件等，引发全球对数据安全的关注。</li><li>经济利益与数据安全发生冲突：数据跨境流动的隐蔽性削弱国家对本国数据的控制，危及数据主权。</li><li>国内外相关法律法规：巴西、欧盟、美国等国家和地区已制定数据安全和隐私保护法律。</li></ul></li></ol><h3 id="立法意义">立法意义</h3><ol type="1"><li><strong>规范数据处理，保护合法权益</strong><ul><li>规范数据活动，保障数据安全，促进数据开发利用，保护个人、组织的合法权益，维护国家主权、安全和发展利益。</li></ul></li><li><strong>对数据的有效监管实现有法可依、填补数据安全保护立法的空白</strong><ul><li>《数据安全法》构成了数字经济时代的法治基石，是构建国家安全法律制度体系的重要举措，有助于提高我国应对数据风险与挑战的能力。</li></ul></li><li><strong>提升国家数据安全保障能力</strong><ul><li>随着新技术的使用，全场景、大规模的数据应用对国家安全造成严重威胁，数据安全是国家安全的重要组成部分，通过法律的立法和实施，可以有效提升数据安全的保障能力。</li><li>为我国数字化转型的健康发展提供法治保障，为构建智慧城市、数字政务、数字社会提供法律依据。</li><li>《数据安全法》进一步提升了国家数据安全保障体系和能力建设，推动形成安全有序、公正合理的数据治理新格局，切实全面维护国家主权、安全和发展利益。</li></ul></li><li><strong>激活数字经济创新，提升数据利用价值</strong><ul><li>数据作为关键生产要素，其自身具有很大的经济价值，法律的发布标志着国家鼓励数据依法合理有效利用。</li><li>《数据安全法》的正式实施将为我国在国际数据经济市场中提供坚实有力的保障。<br></li></ul></li><li><strong>扩大数据保护范围</strong><ul><li>法律明确了数据的定义，包括电子数据和非电子形式的数据，这对数据安全保障的范围提出了更广泛的要求，比《网络安全法》中的数据范围有所扩大。</li></ul></li></ol><h3 id="概览及特点">概览及特点</h3><ol type="1"><li><strong>数据安全法概况</strong></li></ol><ul><li>总计7章55条，包括数据安全与发展、数据安全制度、数据安全保护义务、政务数据安全与开放等内容。</li><li><figure><img src="image-16.webp" srcset="/img/loading/loading3.gif" lazyload alt="数据安全法"><figcaption aria-hidden="true">数据安全法</figcaption></figure></li></ul><ol start="2" type="1"><li><strong>主要亮点</strong></li></ol><ul><li>数据安全与数字经济发展的动态化平衡<ul><li>提出了数据安全制度、数据安全保护义务等确保数据活动符合安全要求</li><li>推动政务数据开放利用，利用数据提升公共服务智能化水平</li><li>家统筹发展和安全理念</li><li>数据交易制度的确立使得数据依法有序流动成为现实</li></ul></li><li>重视数据安全制度的建设<ul><li>明确提出了数据分类分级保护制度，确定重要数据具体目录，并提出了核心数据的概念。</li><li>明确了数据安全风险评估、信息共享、监测预警机制、安全审查制度等，强化内控制度建设，防控数据安全风险</li><li>《数据安全法》对数据的出境管理进行了补充和完善</li></ul></li><li>加强国家对数据安全工作的统筹<ul><li>明确了监管职责，确定给地区、各部门的主题责任，网信部门发挥统筹协调职能</li><li>通过明确国家层面的统筹协调职能，确保后续国家数据安全战略和重大方针政策的有效落地和执行。</li></ul></li><li>增加对数据泄露危及国家安全的处罚力度<ul><li>对数据安全风险设置了基本“红线”。</li></ul></li></ul><h3 id="重要条款解读">重要条款解读</h3><ol type="1"><li><strong>扩大数据保护范坚持总体国家安全发展观</strong><ul><li>第一条确立该法的立法目的：“为了规范数据处理活动，保障数据安全，促进数据开发利用，保护个人、组织的合法权益，维护国家主权、安全和发展利益，制定本法。”</li><li>规范数据处理活动的目的，是为了保障数据的安全，只有在确保数据安全的基础上，方能促进数据的有序开发和利用。</li></ul></li><li><strong>我国数据保护的域外法律效力</strong><ul><li>第二条第二款明确规定：“在中华人民共和国境外开展数据处理活动，损害中华人民共和国国家安全、公共利益或者公民、组织合法权益的，依法追究法律责任。”</li><li>“境外开展数据处理数据活动”的主体既包括位于中国境外的数据处理者，也包括位于中国境内的数据处理者，但其数据处理行为在境外。</li><li>只要损害了我国国家安全、公共利益以及公民和组织的合法数据权益，均由我国法律管辖，并追究法律责任。</li></ul></li><li><strong>促进以数据为关键要素的数字经济发展</strong><ul><li>第七条规定：“国家保护个人、组织与数据有关的权益，鼓励数据依法合理有效利用，保障数据依法有序自由流动，促进以数据为关键要素的数字经济发展。”</li><li>数据作为生产要素由市场评价贡献、按贡献决定报酬，这是党的十九届四中全会首次提出的一项重大产权创新制度。</li><li>在个人和组织与数据有关的权益得到充分保护的基础上，依法推动数据合理有效利用和依法有序自由流动</li></ul></li><li><strong>数据可以合法交易</strong><ul><li>第十三条和第十九条明确数据的合法交易可以有效推动和促进数字经济和社会的发展。</li><li>并非一味就是强调“监管”或“制约”，在保护国家安全和数据安全的前提下，可以合法交易</li><li>数据的合法交易可以有效推动和促进数字经济和社会的发展</li></ul></li><li><strong>国家数据分类分级保护</strong><ul><li>第二十一条规定：“国家建立数据分类分级保护制度，根据数据在经济社会发展中的重要程度，以及一旦遭到篡改、破坏、泄露或者非法获取、非法利用，对国家安全、公共利益或者个人、组织合法权益造成的危害程度，对数据实行分类分级保护。”</li><li>“数据分类”，采用了数据的“重要程度”＋“危害程度”的立法手段，对数据实行分类分级保护。</li><li>从国家层面提出了数据分类分级，是确定数据保护和利用之间平衡点的一个重要依据</li></ul></li><li><strong>国家数据安全审查制度</strong><ul><li>第二十四条规定：“国家建立数据安全审查制度，对影响或者可能影响国家安全的数据处理活动进行国家安全审查。”</li><li>数据安全审查制度与网络安全审查是依法确立的国家安全审查制度中两项重要的安全审查制度。</li><li>数据安全审查制度的审查对象主要针对影响或者可能影响国家安全的数据处理活动，数据处理活动包括：数据的收集、存储、使用、加工、传输、提供、公开等。</li></ul></li><li><strong>国家数据安全应急处置机制</strong><ul><li>第二十三条规定了“国家建立数据安全应急处置机制”，并要求“发生数据安全事件，有关主管部门应当依法启动应急预案，采取相应的应急处置措施，防止危害扩大，消除安全隐患，并及时向社会发布与公众有关的警示信息”</li><li>“有关单位”应当按照“谁主管谁负责、谁运行谁负责”的原则确定</li><li>采取最有效的应急处置措施，防止危害扩大，要消除安全隐患，同时要组织研判，保存证据，并做好信息通报工作</li><li>及时向社会发布与公众有关的警示信息</li><li>分为四级：由高到低依次用红色、橙色、黄色和蓝色标示，分别对应可能发生特别重大、重大、较大和一般网络安全突发事件。</li></ul></li><li><strong>数据处理者的合规义务</strong><ul><li>第二十七条到第三十条明确了数据处理者履行数据安全的四项重要合规义务。</li></ul></li><li><strong>重要数据的出境安全管理制度</strong><ul><li>第三十一条规定了关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的重要数据的出境安全管理。</li><li>关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的重要数据的出境安全管理，适用《中华人民共和国网络安全法》。</li><li>除关键信息基础设施的运营者处理的重要数据外，其他数据处理者在中华人民共和国境内运营中收集和产生的重要数据的出境安全管理办法，由国家网信部门会同国务院有关部门制定</li><li>数据出境，要求出境前必须经过“安全评估”。</li></ul></li><li><strong>提供数据处理服务的行政许可准入制度</strong><ul><li>第三十四条规定：“法律、行政法规规定提供数据处理相关服务应当取得行政许可的，服务提供者应当依法取得许可。”</li><li>许可（license）含有准许、允许或授权的意思，数据处理相关服务的行政许可，其基本性质是行政机关对特定的数据处理服务活动事前进行控制的一种管理行为。。</li></ul></li><li><strong>加大违法处罚力度</strong><ul><li>第四十五条对违反数据安全保护义务的组织、个人规定了严格的处罚措施。</li></ul></li></ol><h3 id="个人信息保护法">个人信息保护法</h3><ol type="1"><li><strong>中华人民共和国个人信息保护法</strong><ul><li>2021年8月20日通过，2021年11月1日施行，共八章74条。</li></ul></li><li><strong>立法进程</strong><ul><li>个人信息保护法的立法进程，旨在保护个人信息权益，促进个人信息合理利用。</li></ul></li><li><strong>术语界定</strong><ul><li>个人信息：是以电子或者其他方式记录的与已识别或者可识别的自然人有关的各种信息，不包括匿名化处理后的信息。</li><li>个人信息的处理：包括个人信息的收集、存储、使用、加工、传输、提供、公开、删除等。</li><li>敏感个人信息：一旦泄露或者非法使用，容易导致自然人的人格尊严受到侵害或者人身、财产安全受到危害的个人信息，包括生物识别、宗教信仰、特定身份、医疗健康、金融账户、行踪轨迹等信息，以及不满十四周岁未成年人的个人信息。</li></ul></li><li><strong>范围界定</strong><ul><li>境内：组织、个人再中华人民共和国境内处理自然人个人信息的活动。</li><li>境外：在中华人民共和国境外处理中华人民共和国境内自然人个人信息的活动，有下列情形之一的：<ul><li>以向境内自然人提供产品或者服务为目的的</li><li>分析、评估境内自然人的行为</li><li>法律、行政法规规定的其它情形</li></ul></li></ul></li><li><strong>处理规则</strong><ul><li>规定了个人信息处理的合法、正当、必要和诚信原则，以及个人信息处理者的义务。</li><li>任何组织、个人不得 非法收集、使用、加工、传输 他人个人信息，不得非法买卖、提供或者公开 他人个人信息；不得从事 危害国家安全、公共利益的个人信息处理活动。</li><li>处理个人信息应当取得个人的同意。</li><li>设专节对处理敏感个人信息作出更严格的限制</li></ul></li><li><strong>个人信息跨境提供规则</strong><ul><li>明确了个人信息跨境提供的规则和要求。</li><li>未经中华人民共和国主管机关批准，个人信息处理者不得向外国司法或者执法机构提供存储于中华人民共和国境内的个人信息。</li></ul></li><li><strong>个人信息处理活动中个人的权利和处理者义务</strong><ul><li>明确了个人在个人信息处理活动中的权利，如知情权、决定权、查询权、更正权、删除权等。</li></ul></li><li><strong>履行个人信息保护职责的部门</strong><ul><li>明确了个人信息保护职责部门的定义和职责。</li></ul></li><li><strong>法律责任</strong><ul><li>规定了违反个人信息保护法的法律责任，包括责令改正、警告、罚款等措施。</li></ul></li></ol><h1 id="第二章-密码学基础">第二章 密码学基础</h1><h2 id="第一节-密码学概述">第一节 密码学概述</h2><h3 id="密码的起源">密码的起源</h3><ol type="1"><li>原始符号</li><li>古代隐写术</li><li>古代语言隐写术</li><li>斯巴达密码棒</li><li>达·芬奇密码筒</li></ol><h3 id="古典密码">古典密码</h3><ol type="1"><li><strong>古典替换</strong>：将明文字母替换成其他的字母、数字和符号<ul><li><p><strong>凯撒密码</strong>：单表替换密码，每个字母用其后第3个字母替换（广义为移动K个位置），如“Caesarcipher is a shift substitution”加密后为“FDHVDU FLSKHU LV D VKLIWVXEVWLWXWLRQ”。</p></li><li><p><strong>维吉尼亚密码</strong>：多表替换密码，引入密钥概念，根据密钥决定用哪一行密表代换，掩盖字母频率特征，如明文“polyalphabeticcipher”，密钥“RADIO”，加密后为“GOOGOCPKTP NTLKQZPKMF”。</p></li><li><figure><img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload alt="维吉尼亚密码"><figcaption aria-hidden="true">维吉尼亚密码</figcaption></figure></li><li><figure><img src="image-4.webp" srcset="/img/loading/loading3.gif" lazyload alt="维吉尼亚密码"><figcaption aria-hidden="true">维吉尼亚密码</figcaption></figure></li><li><p><strong>普莱费尔密码</strong>：多字母代换密码，基于5×5字母矩阵，将明文中双字母组合转换为密文双字母组合</p><ul><li>加密规则:按成对字母加密</li><li>相同对中的字母加分隔符(任意字符，如X)，对明文进行分组，每2个字母一组，如果明文的字母数为奇数，在最后加上一个无效字母补位(如x)。</li><li>balloon → ba lx lo on</li><li>同行取右边: he → EC</li><li>同列取下边: dm → MT</li><li>其他取交叉: kt → MQ；OD → TR</li></ul></li><li><p><strong>Hill密码（仿射密码）</strong>：m个连续明文字母用m个密文字母代替，由m个线性方程决定，如m= 2时，对明文“july”加密，密钥K为特定矩阵，加密结果为“DELW”。</p></li></ul></li><li><strong>古典置换（换位密码）</strong>：通过重新排列明文字符位置实现加密<ul><li><strong>栅格换位</strong></li><li><figure><img src="image-5.webp" srcset="/img/loading/loading3.gif" lazyload alt="栅格换位"><figcaption aria-hidden="true">栅格换位</figcaption></figure></li><li><strong>矩形换位</strong></li><li><figure><img src="image-6.webp" srcset="/img/loading/loading3.gif" lazyload alt="矩形换位"><figcaption aria-hidden="true">矩形换位</figcaption></figure></li></ul></li><li><strong>一次一密密码</strong>：密钥本身随机，而且密钥只使用一次。<ul><li>即使获得了上次通信的密文和密钥，攻击者仍然无法确定下次通信的真正密钥；</li><li>需要建立庞大的随机字母集，工作量巨大，而且存在密钥分发的问题。</li><li><strong>费纳姆密码</strong>：将明文与密钥进行模2加法（比特XOR，即异或）运算，若密钥只使用一次，为一次一密密码。</li></ul></li></ol><h3 id="机械密码">机械密码</h3><ol type="1"><li><p><strong>转轮密码机ENIGMA</strong>：德国发明家亚瑟·谢尔乌比斯发明，二战期间德军使用，安全性高，有多个转轮，组合可能性众多，后被数学家艾伦·图灵破解，其设计体现了加密系统保密性基于密钥保密的理念。</p></li><li><p><strong>紫色密码机</strong>：日本外务省在二战期间使用的机械式密码机，工作原理与Enigma机类似，被美国威廉·弗里德曼破译小组破解，对美军在中途岛海战及击毙山本五十六等事件中发挥重要作用。</p></li><li><p><strong>其他机械密码机</strong>：包括从未被破解的Sigaba（与Enigma工作原理相似）、C- 36（瑞典海军使用）、M - 209（美军二战及朝鲜战争中使用）。</p></li></ol><h3 id="现代密码">现代密码</h3><ol type="1"><li><strong>现代密码理论基础</strong>：1949年ClaudeShannon发表保密系统的通信理论，奠定现代密码理论基础，用信息论观点分析密码系统相关概念。</li><li><strong>保密通信系统的数学模型</strong>：信源、加密器、信道、解密器、信宿。<ul><li><figure><img src="image-7.webp" srcset="/img/loading/loading3.gif" lazyload alt="数学模型"><figcaption aria-hidden="true">数学模型</figcaption></figure></li></ul></li><li><strong>信息隐藏和信息保密</strong>：<ul><li>信息隐藏（隐匿信息存在）：将秘密信息嵌入表面上看起来无害的宿主信息中，使攻击者无法直观地判断他所监视的信息中是否含有秘密信息，目的是使攻击者不知道哪里有秘密,它隐藏了信息的存在形式。</li><li>信息保密（隐匿信息真意）：信息加密是利用单钥或双钥密码算法把明文变换成密文并通过公开信道送到接收者手中，保护的是信息的内容。</li></ul></li><li><strong>DES数据加密标准</strong>：组合、混乱、扩散、分组密码设计<ul><li>组合（Combine）：由简单易于实现的密码系统进行组合，构造较复杂的、密钥量较大的密码系统，如加权和及乘积法。</li><li>混乱(Confusion)：为了避免密码分析者利用明文与密文之间的依赖关系进行破译，密码的设计应该保证这种依赖关系足够复杂，使明文和密文、密钥之间的统计相关性极小化。通常的方法是“替换(Substitution)”</li><li>扩散(Diffusion)：为避免密码分析者对密钥逐段破译，密码的设计应该保证密钥的每位数字能够影响密文中的多位数字；同时，为了避免密码分析者利用明文的统计特性，密码的设计应该保证明文的每位数字能够影响密文中的多位数字，即将每一位明文及密钥尽可能迅速地散布到较多位密文数字中去，从而隐藏明文的统计特性。通常的方法是“换位(Permutation)”</li><li>分组密码设计：输入分段处理、非线性变换、左右交换和密钥控制下的多次迭代，如Feistel结构。</li></ul></li><li><strong>公钥密码体制</strong>：又称双钥密码体制或非对称密码体制（Two-key/AsymmetricCryptosystem），就是在加密和解密的过程中分别使用不同的密钥</li><li><strong>密码技术分支</strong>：包括数字签名、认证码、Hash函数、密码协议等，现代密码学研究建立安全密码体制和破译敌方密码体制。</li><li><strong>密码体制五大特性</strong>：保密性、完整性、可用性、认证性、不可否认性</li><li><strong>量子密码</strong>：利用量子态作为信息载体，基于量子力学原理（如薛定谔方程、测不准原理、不可克隆定理）实现量子密钥分发，具有不可窃听性和一次一密不可破译性，但未超出Shannon的信息理论和密码理论范畴。</li></ol><h3 id="密码学面临的挑战">密码学面临的挑战</h3><ol type="1"><li><strong>云计算/存储</strong>：用户担心云上数据丢失、失效、泄密、篡改及隐私泄露，云计算对密码有新需求，如感知数据存在、确保数据安全和隐私，研究热点包括数据持有证明、完全同态加密。</li><li><strong>大数据</strong>：数据量巨大且增长迅速，具有4V特点（Volume、Velocity、Variety、Value），密码算法需处理大规模数据，提高效率和适应性，在存储、传输处理等方面带来新挑战和需求。</li><li><strong>物联网</strong>：万物互联面临数据、网络、系统安全及隐私保护问题。<ul><li>物联网的安全要求：<ul><li>密码要适应数据多样性（物体多样性使数据多样性）</li><li>密码要适应网络多样性、多层次(传感网、无线网、有线网、内网和外网)</li><li>密码要适应各层次的资源差异较大(感知层资源弱，管理层资源强)，因此需要多密码、多密钥、多安全级别、跨域互联互通。</li></ul></li></ul></li><li><strong>新型计算机</strong>：量子计算机（如D -Wave公司产品）可在多项式时间内解决大整数分解难题，冲击RSA等加密算法，加快密钥搜索速度，量子计算机和DNA计算机发展对现有密码算法构成威胁。</li><li><strong>区块链技术</strong>：一方面区块链需要在众多节点间通过共识机制达成一致导致其性能低下；另一方面区块链核心技术的突破还需要依赖密码技术底层算法、协议的突破；密码技术是区块链基础核心，但专业人才匮乏。</li></ol><h2 id="第二节-密码学基本概念">第二节 密码学基本概念</h2><h3 id="密码体制">密码体制</h3><ol type="1"><li><strong>密码体制基本概念</strong><ul><li><strong>密码学的定义</strong>：<ul><li>保密学（密码学Cryptology）：研究信息系统安全保密的科学，包括秘密通信和破译密码的方法。</li><li>密码编码学（Cryptography）：研究对信息进行编码，实现信息隐蔽的学科。</li><li>密码分析学（Cryptanalytics）：研究加密消息的破译或消息的伪造，恢复被隐藏信息的本来面目。</li></ul></li><li><strong>密码系统组成</strong>：<ul><li>明文字母空间、密文字母空间、密钥空间和算法。</li><li>两个基本单元是算法和密钥。</li></ul></li></ul></li><li><strong>密码体制基本概念</strong><ul><li><strong>明文与密文</strong>：<ul><li>明文：需要秘密传送的可读消息，构成明文消息空间M。</li><li>密文：明文经过密码变换后的不可读消息，构成密文消息空间C。</li></ul></li><li><strong>加密与解密</strong>：<ul><li>加密：由明文到密文的数学变换。</li><li>解密：从密文恢复出明文的数学变换。</li></ul></li><li><strong>加密算法与解密算法</strong>：<ul><li>加密算法：对明文进行加密时采用的规则。</li><li>解密算法：对密文进行解密时采用的规则。</li></ul></li><li><strong>密钥</strong>：<ul><li>密钥：加密和解密时使用的秘密信息，包括加密密钥空间K和解密密钥空间K’。</li></ul></li><li><strong>加密/解密过程</strong>：<ul><li>加密算法E：M × K → C；解密算法D：C × K’ → M。</li><li>加密/解密关系：对于所有m ∈ M, c ∈ C, c = Eke(m), m = Dkd(c) =Dkd(Eke(m))。</li></ul></li></ul></li><li><strong>对称加密与非对称加密</strong><ul><li><strong>单钥加密体制（对称加密体制）</strong>：<ul><li>加密密钥ke等于解密密钥kd。</li><li>对称加密算法使用起来简单快捷，密钥较短，且破译困难。如：DES、IDEA、TDEA（即3DES）、AES</li></ul></li><li><strong>双钥加密体制（非对称加密体制）</strong>：<ul><li>加密密钥ke不等于解密密钥kd。</li><li>特点：实现多个用户加密的消息只能由一个用户解读（加密）；一个用户加密消息而使多个用户可以解读（数字签名）。</li><li>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。</li><li>加密算法可以把加密密钥和算法公开，所以任何人都可用之来加密要传送的明文信息。但只有拥有解密密钥的人才能将传送过来的已经加了密的消息解密，还原原信息。</li></ul></li></ul></li></ol><h3 id="密码分析">密码分析</h3><ol type="1"><li><strong>密码分析与密码安全性</strong><ul><li><strong>密码分析</strong>：<ul><li>密钥分析的实质是在攻击者不知道密钥的情况下，对所截获的密文或明-密文对采用各种不同的密码分析方法试图恢复出明文或密钥。</li></ul></li><li><strong>密码设计的安全性</strong>：<ul><li>无条件安全：无论破译者有多少密文，他也无法解出对应的明文，即使他解出了，他也无法验证结果的正确性；具有无限计算资源（诸如时间、空间、资金和设备等）的密码分析者也无法破译某个密码系统</li><li>计算上安全：理论上可破译，但实际运用时破译的代价超出信息本身的价值，破译的时间超出了信息的有用寿命</li></ul></li><li><strong>密码分析类型</strong>：<ul><li>唯密文攻击、已知明文攻击、选择明文攻击、选择密文攻击、选择文本攻击</li><li><figure><img src="image-8.webp" srcset="/img/loading/loading3.gif" lazyload alt="密码分析"><figcaption aria-hidden="true">密码分析</figcaption></figure></li></ul></li><li><strong>密码分析方法</strong>：<ul><li>穷举攻击法<ul><li>穷尽密钥搜索攻击（完全试凑法）</li></ul></li><li>数学攻击法<ul><li>差分密码分析：通过分析明文对的差值对密文对的差值的影响来恢复某些密钥比特.（针对分组密码）</li><li>确定性分析法–线性密码分析：本质上是一种已知明文攻击方法,通过寻找一个给定密码算法的有效的线性近似表达式来破译密码系统</li><li>确定性分析法–插值攻击方法：使用一个代数函数来代表一个S-Box，此函数可以用已知明文攻击法取得样本点，再用拉格朗日插值法产生。这个代数函数可能是在有限体上的二次函数、多项式函数或有理函数。</li><li>统计分析法：利用明文的已知统计规律进行破译的方法。</li></ul></li><li>物理攻击法<ul><li>侧信道攻击：针对密码实现（包括密码芯片、密码模块、密码系统等）的物理攻击方法。</li><li>本质上是利用密码实现在执行密码相关操作的过程中产生的侧信息来恢复出密码实现中所使用的密钥。</li><li>侧信息（Side ChannelInformation）：除了攻击者通过除主通信信道以外的途径获取到的关于密码实现运行状态相关的信息，典型的侧信息包括密码实现运行过程中的能量消耗、电磁辐射、运行时间等信息。</li><li>侧信道攻击主要面向密码实现的物理安全性，采用能量分析攻击、电磁分析攻击、计时攻击、缓存攻击、故障攻击等一系列方法对其实现安全性进行分析</li></ul></li></ul></li></ul></li></ol><h3 id="密码学理论基础">密码学理论基础</h3><ul><li>密码学基本数学知识<ul><li><strong>模运算</strong>：求余运算，包括取模运算、模加法、模减法、模乘法、模指数、求逆运算（若存在𝑎𝑏=1𝑚od𝑛 ，则a、b互为逆元）。</li><li><strong>整数分解</strong>：又称为素因数分解，是将一个大于1的自然数写成素数乘积的形式。</li><li><strong>欧几里得算法</strong>：求两个整数最大公因子的快速算法。设a和b是两个任意正整数，gcd(a,b)为它们的最大公因子，gcd(a, b)= gcd(b, a mod b)</li><li><strong>有限域</strong>：元素个数有限的域，又被称为Galois域。域内定义了加法和乘法，集合内的元素经过加法和乘法计算，结果仍然在集合内。计算符合交换率、结合率、分配率，加法和乘法有单位元素（所有的集合内的值都有对应的负数，所有集合内非零值都有倒数）</li><li><strong>中国剩余定理</strong>：求解一次同余式组的方法。</li><li><strong>椭圆曲线</strong>：定义在实数域上的椭圆曲线，可以构成一个Abel群。</li></ul></li></ul><h3 id="国内外密码算法概览">国内外密码算法概览</h3><ol type="1"><li><strong>序列密码原理（流密码）</strong><ul><li>定义：明文m与伪随机序列k结合，通过加密变换生成密文c，解密过程与加密过程相同且互逆。</li><li>数学表达：由种子密钥通过密钥流发生器得到的密钥流K，加密变换为C，其中ci= mi ⊕ ki。</li><li><figure><img src="image-9.webp" srcset="/img/loading/loading3.gif" lazyload alt="序列密码"><figcaption aria-hidden="true">序列密码</figcaption></figure></li><li>特点：实现简单、便于硬件实施、加解密处理速度快、没有或只有有限的错误传播</li><li>由有限状态机产生的序列是伪随机序列</li><li>典型算法：RC4</li></ul></li><li><strong>分组密码</strong><ul><li>定义：将明文消息编码表示后的数字序列划分成长度为n的组，在密钥k的控制下变换成等长的输出数字序列。</li><li>典型分组密码：DES、IDEA、RC5、RC6、CAST-128等。</li><li>设计要求：分组长度足够大，密钥量足够大，算法足够复杂，加密、解密算法简单，数据无扩展，差错传播尽可能小。</li></ul></li><li><strong>Feistel密码结构</strong><ul><li>定义：Feistel密码结构是一种迭代密码结构，由HorstFeistel提出，用于设计分组密码。</li><li>安全性：单个循环（轮）的Feistel结构不能提供足够的安全性，但多个循环（轮）可以显著提高安全性。</li><li>特点：<ul><li><strong>分组大小</strong>：明文消息编码表示后的数字序列划分成长度为n的组。</li><li><strong>密钥大小</strong>：密钥有不同的产生算法，密钥的长度影响密文的安全性。</li><li><strong>迭代轮数</strong>：多轮重复循环处理，典型的循环次数是16次。</li><li><strong>子密钥产生算法</strong>：用于产生加密过程中的密钥。</li><li><strong>轮函数</strong>：函数越复杂，安全性越好，更能抵抗密码分析，包括加法、减法和异或，固定循环/移位等。</li></ul></li></ul></li><li><strong>DES算法</strong><ul><li>定义：DES（Data EncryptionStandard）是一种分组密码，假设明文m是有0和1组成的长度为64比特的符号串，密钥k也是64比特的0,1符号串。</li><li>有效密钥：64比特密钥k只有56比特有效，其余8位是奇偶校验位，在算法中不起作用。</li><li>DES算法细节：<ul><li><strong>初始置换IP和初始逆置换IP<span class="math inline"><sup>−1</sup></span></strong>：DES过程中的初始和最终步骤，用于重新排列明文和密文的比特。</li><li><strong>S盒替代</strong>：DES中的关键步骤，使用固定的替换表（S盒）对数据进行非线性变换。</li></ul></li></ul></li><li><strong>三重DES算法(TDEA)</strong><ul><li>定义：三重DES（TripleDES）算法使用3倍DES密钥长度的密钥，执行3次DES算法，以提高安全性。</li><li>TDEA算法模式：<ul><li><strong>DES-EEE3模式</strong>：使用三个不同的密钥（k1, k2,k3），进行三次加密。</li><li><strong>DES-EDE3模式</strong>：使用三个不同的密钥（k1, k2,k3），采用加密-解密-加密模式。</li><li><strong>DES-EEE2模式</strong>：使用两个不同的密钥（k1= k3,k2），进行三次加密。</li><li><strong>DES-EDE2模式</strong>：使用两个不同的密钥（k1= k3,k2），采用加密-解密-加密模式。</li></ul></li></ul></li><li><strong>高级加密标准AES</strong><ul><li>定义: AES（Advanced EncryptionStandard）是NIST于2001年公布的加密标准，取代DES算法。</li><li>AES算法特点：<ul><li><strong>结构</strong>：AES不具有Feistel结构，而是采用基于块的密码结构。</li><li><strong>操作</strong>：每轮进行“字节替换”、“行移位”、“列混淆”、“轮密钥加”，共10轮迭代。</li></ul></li><li>AES算法举例：<ul><li>分组 16字节 128位</li><li>子秘钥 44个，每个 32位，每轮使用4个字，128位</li><li>每轮进行“字节替换”、“行移位”、“列混淆”、“轮密钥加”</li><li>10轮迭代，但是非Feistel结构</li><li>每一步都简单可逆A⊕B⊕B = A</li></ul></li></ul></li><li><strong>公钥加密体制</strong><ul><li>定义：公钥技术是加密史上的一个革命性进步，改变了密钥分发的方式，具备密钥分配和管理、数字签名和身份认证、数据加解密等功能。</li><li>特点：<ul><li>基于数学函数而不是对“位”的形式的简单操作（如替换和置换、逻辑加、乘和异或）</li><li>加/解密钥是<strong>非对称</strong>的：公钥密码体制使用两个不同的密钥，在机密性、密钥分配及认证领域中，具有深远的影响。</li><li><strong>密钥管理</strong>：私钥为密码拥有者保管，不涉及分发问题，公钥通过公开渠道分发而不影响安全性。</li><li>通常要求足够大的密钥长度 (&gt;1024 bits)，密钥太长会导致加密速度缓慢，因此公钥算法常用于密钥传递，而一般不用于实时的数据加密</li></ul></li><li>单向陷门函数<ul><li>公钥密码体制是基于单向陷门函数的概念。</li><li><strong>单向函数</strong>是一些易于计算但难于求逆的函数</li><li><strong>单向陷门函数</strong>就是在已知一些额外信息的情况下易于求逆的单向函数，这些额外信息就是所谓的陷门。</li><li>构造公钥密码系统的关键是如何在求解某个单向函数的逆函数的NP完全问题中设置合理的“陷门”。</li></ul></li><li>典型公钥算法：<ul><li>RSA算法三种方式都适合</li><li>Diffe-Hellman算法只适合于密钥交换</li><li>DSS（数字签名标准）适合于数字签名</li><li>EIGamal适合于前两种</li><li>椭圆曲线算法（ECC）三种都适合。</li></ul></li><li>加密方案：<ul><li><strong>公钥加密方案</strong><ol type="1"><li><strong>基于公开密钥的加密过程</strong>：<ul><li><strong>加密过程</strong>：当Alice给Bob发信息时，她使用Bob的公钥KB对消息加密，Bob使用自己的私钥KSB对密文解密。</li></ul></li><li><strong>公钥算法应用——认证</strong>：<ul><li><strong>认证过程</strong>：当Alice给Bob发信息时，她使用自己的私钥KSA对消息加密（签名），Bob使用Alice的公钥KAP对密文解密，认证。</li></ul></li></ol></li><li><strong>公钥+常规密钥结合的加密方案</strong><ol type="1"><li><strong>结合加密方案原理</strong>：<ul><li><strong>方案概述</strong>：利用公开加密的方法来保护常规加密密钥的传送，保证常规加密密钥的安全性，然后用常规加密方法来保护传送的数据。</li></ul></li><li><strong>结合加密方案特点</strong>：<ul><li><strong>效率与安全性</strong>：这种方法利用了公开加密方法的安全性特点和常规加密方法的速度快和适应性强的特点，同时避免了公开加密方法加/解密速度慢的缺点。</li></ul></li></ol></li></ul></li></ul></li><li><strong>RSA算法</strong><ul><li>定义：RSA算法是一种公钥密码算法，涉及两个素数p和q，计算n=pq，φ(n)=(p–1)(q–1)，随机选取整数e，计算d，满足de≡1(modφ(n))。</li><li><strong>RSA算法加密解密</strong>：<ul><li><strong>加密算法</strong>：c=E(m)≡me(mod n)</li><li><strong>解密算法</strong>：D(c)≡cd(mod n)</li></ul></li></ul></li><li><strong>Rabin公钥密码算法</strong><ul><li>定义：Rabin公钥密码算法的安全性基于<strong>模合数平方根困难的困难性</strong>。</li><li><figure><img src="image-10.webp" srcset="/img/loading/loading3.gif" lazyload alt="RABIN"><figcaption aria-hidden="true">RABIN</figcaption></figure></li></ul></li><li><strong>Diffie-Hellman算法——密钥交换</strong></li></ol><ul><li>定义：Diffie-Hellman算法允许两个用户可以安全地交换一个秘密信息，用于后续的通讯过程。</li><li>算法的安全性依赖于<strong>计算离散对数的难度</strong>。</li><li>Diffie-Hellman算法过程：<ul><li>密钥交换过程：双方获得a及p：p是一个素数，a是P的原根，通过计算得到共享密钥K。</li></ul></li></ul><ol start="11" type="1"><li><strong>ElGamal公钥密码算法</strong></li></ol><ul><li>定义：ElGamal公钥密码体制安全性是基于<strong>有限域上计算离散对数的困难性</strong>。</li></ul><ol start="12" type="1"><li><strong>椭圆曲线公钥密码算法（ECC）</strong></li></ol><ul><li>定义：ECC实际上是将原有的经典的加密算法通过某些运算移植到安全的椭圆曲线方程上。</li><li>特点：<ul><li><strong>安全性与效率</strong>：椭圆曲线离散对数问题（ECDLP）是椭圆曲线密码学的基础，具有安全性高、密钥尺度小、实现速度快的优点。</li></ul></li></ul><ol start="13" type="1"><li><strong>单向散列算法</strong></li></ol><ul><li>定义：单向散列函数是根据输入消息输出固定长度数值的算法，输出数值也称为“散列值”或“消息摘要”。</li><li>特点：<ul><li><p>散列函数h=H（M），其中，M是发长的报文，h是定长的散列值。设x、x′是两个不同的消息，如果H（x）=H（x′），则称x和x′是哈希函数H的一个（对）碰撞（collision）</p></li><li><p><strong>安全性设计</strong>：强加密单向散列函数是这样设计的：不可能通过计算找出两条散列值相同的消息。</p></li></ul></li><li><strong>MD5和SHA-1</strong>：<ul><li><strong>MD5</strong>：生成128位的散列值。</li><li><strong>SHA-1</strong>：生成160位的散列值。</li></ul></li><li><strong>SHA-2系列算法</strong>：<ul><li><strong>SHA-2系列</strong>：包括SHA-224、SHA-256、SHA-384和SHA-512。</li></ul></li></ul><ol start="14" type="1"><li><strong>国产密码</strong></li></ol><ul><li>定义：国密算法是国家商用密码管理办公室指定的一系列密码标准，包括SM1、SM4、SM2、SM3、ZUC等。</li><li>特点：<ul><li><strong>自主性与安全性</strong>：从根本上摆脱对国外密码技术和产品的过度依赖，实现加密、解密和认证等功能。</li></ul></li></ul><h2 id="第三节-密码学新进展及研究方向">第三节密码学新进展及研究方向</h2><h3 id="公钥密码">公钥密码</h3><ol type="1"><li><strong>公钥基础设施 (PKI)</strong><ul><li>定义：用公钥概念与技术来实施和提供安全服务的具有普适性的安全基础设施</li><li>PKI是生成、管理、存储、分发和吊销基于公钥密码学的公钥证书所需要的硬件、软件、人员、策略和规程的总和。<strong>其最基本的元素是数字证书。</strong></li><li>证书权威（CA）对用户证书带来了复杂的管理问题</li><li><figure><img src="image-11.webp" srcset="/img/loading/loading3.gif" lazyload alt="CA"><figcaption aria-hidden="true">CA</figcaption></figure></li></ul></li><li><strong>公钥证书(数字证书)</strong><ul><li>公钥证书由证书管理机构CA为用户建立，其中的数据项包括与该用户的秘密钥相匹配的公开钥及用户的身份和时间戳等，<strong>所有的数据项经CA用自己的秘密钥签字后就形成证书</strong>。</li><li><figure><img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload alt="公钥证书"><figcaption aria-hidden="true">公钥证书</figcaption></figure></li><li>公钥证书是用来绑定实体姓名以及该实体的其它相关属性和相应公钥的凭证。s是网络环境中的一种身份证，用于证明某一用户的身份及其公开密钥的合法性。</li><li>使用X.509协议，广泛应用在网络安全设施：IP安全协议、SSL、SET和S/MIME。</li></ul></li><li><strong>身份基公钥密码 (IBC)</strong><ul><li>使用能唯一标识用户身份的信息作为公钥，例如电话号码或Email地址等，简化了传统公钥密码体系中的用户证书管理。</li><li>在身份基公钥密码中，用户公钥可以为任意的比特串。用户私钥通过可信第三方，即PKG生成。</li><li>身份基公钥密码密钥生成过程：</li><li><figure><img src="image-12.webp" srcset="/img/loading/loading3.gif" lazyload alt="IBC"><figcaption aria-hidden="true">IBC</figcaption></figure></li><li><figure><img src="image-13.webp" srcset="/img/loading/loading3.gif" lazyload alt="IBC"><figcaption aria-hidden="true">IBC</figcaption></figure></li><li>(pk,sk)：用户的公私钥对 ID：用户的公钥身份字符串PKG：私钥生成中（PrivateKeyGenerator ）</li><li>一个身份基加密方案包含四个算法：<ul><li>系统建立算法：PKG生成系统公开参数和主密钥；</li><li>密钥提取算法：用户将ID提交给PKG，PKG生成ID对应的私钥；</li><li>加密算法：利用用户身份ID加密消息，生成加密密文；</li><li>解密算法：利用身份ID对应的私钥解密密文，得到明文消息。</li></ul></li><li>身份基加密方案扩展了身份基公钥密码体制，能够较好地解决PKI证书管理复杂问题，被广泛应用于安全电子邮件、AdHoc网络密钥管理等应用场景。</li><li>优点：<ul><li>无需公钥证书，加密或签名验证不需要知道除身份外的其他信息；</li><li>无需证书机构，存在可信第三方私钥生成中心(PKG)向用户提供服务；</li></ul></li><li>缺点：<ul><li>密钥托管问题：恶意的PKG可能存储用户私钥的副本，使其有能力解密任何一个用户发送给用户ID的密文或伪造用户ID的数字签名。</li></ul></li></ul></li><li><strong>属性基公钥密码 (ABE)</strong><ul><li>数据拥有者根据用户的属性来加密数据，并且只有当用户拥有特定属性组合时才能解密数据，这种加密方式为数据共享和访问控制提供了一种细粒度的控制机制。</li><li>在属性基加密中，系统的每个权限都可以用一个<strong>属性</strong>来表示。系统中存在一个属性权威(AttributeAuthority，AA)，属性权威对每个用户的属性进行认证，并颁发相应密钥。</li><li>密钥和密文都与<strong>一组属性</strong>相关联，属性集合表示用户身份。加密者根据将要加密的消息和接收者的属性构造一个<strong>加密策略</strong>，当属性满足加密策略时，解密者才能够解密。</li><li><figure><img src="image-14.webp" srcset="/img/loading/loading3.gif" lazyload alt="ABE"><figcaption aria-hidden="true">ABE</figcaption></figure></li><li>属性基签名（Attribute-BasedSignature，ABS）是由模糊身份签名发展而来的；<ul><li>根据签名的生成过程分为：密钥策略属性基签名（KP-ABS）、签名策略属性基签名（SP-ABS）</li><li>当且仅当属性集合满足访问结构时，签名者可以对消息生成合法签名</li><li>特点：匿名性</li></ul></li></ul></li></ol><h3 id="同态密码">同态密码</h3><ol type="1"><li><strong>同态密码</strong><ul><li>同态密码可以在不泄露敏感信息的前提下完成对密文的处理，成为保护数据安全，提高密文处理分析能力的关键技术。</li><li>同态是一个数学概念，如果E(f(a， b)) = f(E(a)，E(b))，则E(.)是一个同态映射。</li><li>假设加密操作为E(.)，明文为m，密文为e，如果针对明文的操作f，可以根据E构造出f，使得E(f(m)) = f(e)。 那么E就是一个针对f的同态加密算法。</li><li>同态加密是指在不知道解密算法和密钥情况下，可以对密文直接进行特定运算，而其运算结果解密后与用明文进行相同运算所得的结果一致。</li></ul></li><li><strong>同态密码技术的优缺点</strong><ul><li>优点：无密钥方的计算处理，既可以减少通信代价，又可以避免每一个密文解密后再计算而花费高昂的计算代价。</li><li>缺点：<ul><li>只能实现单比特加密，效率较低；</li><li>困难性假设未论证，寻找可论证的困难问题是个难题；</li><li>需要额外的消除噪音算法，依然不是自然同态。</li></ul></li></ul></li></ol><h3 id="抗量子密码">抗量子密码</h3><ol type="1"><li><strong>抗量子密码分类</strong><ul><li>基于量子物理学的量子密码：<ul><li>主要集中在量子密钥分配、量子秘密共享、量子认证、量子密码算法和量子密码算法的安全性等方面的研究；</li><li>安全性是基于<strong>量子物理设备</strong>的。</li></ul></li><li>基于生物学的DNA密码：<ul><li>是随着基因工程和生物计算的发展而诞生的；</li><li>安全性是建立在<strong>生物困难问题</strong>上的。</li></ul></li><li>基于数学的抗量子计算密码;<ul><li>基于量子计算机不擅长计算的<strong>数学困难问题</strong>构造的；</li><li>研究方向主要有：基于格的密码、基于Hash的数字签名、基于纠错编码的密码和基于多变量的密码。</li></ul></li></ul></li><li><strong>基于数学的抗量子密码</strong><ul><li>NIST PQC标准征集工作聚焦于以下3类抗量子密码算法的征集：加密、密钥交换、数字签名。</li><li>在 69 个候选草案中，主要包括以下 4 种数学方法构造的抗量子密码算法：<ul><li><strong>格 (Lattice-based)</strong>：<ul><li>最早出现于 1996年，主要用于构造加密、数字签名、密钥交换，以及众多高级密码学应用，如：<strong>属性加密(Attribute-based encryption)</strong>、陷门函数 (Trapdoorfunctions)、伪随机函数 (Pseudorandom functions)、同态加密 (HomomorphicEncryption) 等。代表算法：NTRU 系列、NewHope 、一系列同态加密算法(BGV、GSW、FV等)。由于其计算速度快、通信开销较小，且能被用于构造各类密码学算法和应用，因此被认为是<strong>最有希望的抗量子密码技术</strong></li></ul></li><li><strong>编码 (Code-based)</strong>：<ul><li>最早出现于 1978 年，主要用于构造加密算法。代表算法：McEliece</li></ul></li><li><strong>多变量 (Multivariate-based)</strong>：<ul><li>最早出现于 1988年，主要用于构造数字签名、加密、密钥交换等。代表算法：HFE (Hidden FieldEquations)、Rainbow (Unbalanced Oil and Vinegar (UOV) 方法)、HFEv-等</li></ul></li><li><strong>哈希 (Hash-based)</strong>：<ul><li>最早出现于 1979 年，主要用于构造数字签名。代表算法：Merkle哈希树签名、XMSS、Lamport 签名等</li></ul></li></ul></li></ul></li></ol><h3 id="轻量级密码">轻量级密码</h3><ol type="1"><li>轻量级密码概述<ul><li>轻量级密码的特性<ul><li>目标：为资源受限的设备定制专属的密码解决方案；</li><li>特点：对吞吐率的要求比普通密码算法低；</li><li>实用性：部分轻量密码采用机器内置密钥。</li></ul></li><li>轻量级密码的设计方法实现<ul><li>设计要求：存储计算开销小、能耗低、安全性；</li><li>第一种方法：在现有的密码方案上进行轻量化改进；</li><li>第二种方法：设计一个全新的轻量密码方案。</li></ul></li><li>轻量级密码的性能评估<ul><li>硬件开销：延迟、功耗、吞吐率</li><li>软件开销：寄存器、RAM、ROM的空间使用</li></ul></li></ul></li><li>轻量级密码研究现状</li></ol><h3 id="密码学主要研究方向">密码学主要研究方向</h3><ol type="1"><li>研究方向<ul><li>密码学是研究密码编码、密码分析、密码工程、密码应用、密码管理、密码安全防护等问题的一门科学，是多个学科融合形成的交叉学科。</li><li><figure><img src="image-15.webp" srcset="/img/loading/loading3.gif" lazyload alt="研究方向"><figcaption aria-hidden="true">研究方向</figcaption></figure></li></ul></li></ol><h1 id="第三章-网络安全基础">第三章 网络安全基础</h1><h2 id="第一节-网络安全概述">第一节 网络安全概述</h2><h3 id="网络安全事件回放">网络安全事件回放</h3><ol type="1"><li><strong>网络的定义</strong><ul><li>定义：计算机网络是指将地理位置不同，具有<strong>独立功能(或自治能力)</strong>的多个计算机系统用<strong>通信设备和线路连接起来</strong>，并以功能完善的网络软件(网络协议、网络操作系统等)进行信息交换，实现<strong>资源共享和协同工作</strong>的系统。</li><li>特征：<ul><li>网络中包含两台以上的地理位置不同具有“自治能力”的计算机。</li><li>网络中各结点之间的连接需要有一条通道，由传输介质实现物理互联。</li><li>网络中各结点之间互相通信或交换信息，需要有某些约定和规则，实现各结点的逻辑互联。</li><li>计算机网络是以实现数据通信和网络资源(包括硬件资源和软件资源)共享和协作为目的。</li></ul></li></ul></li><li><strong>网络的结构</strong><ul><li>OSI参考模型是国际标准化组织(ISO)为解决异种机互连而制定的开放式计算机网络层次结构模型，它的最大优点是将服务、接口和协议这三个概念明确地区分开来。</li><li>网络通信分为七层，从下到上分别是：物理层(PhysicalLayer)、数据链路层(Data Link Layer，简称为链路层)、网络层(NetWorkLayer)、传输层(Transport Layer)、会话层(SessionLayer)、表示层(Presentation Layer)以及应用层(Application Layer)。</li><li><figure><img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload alt="OSI"><figcaption aria-hidden="true">OSI</figcaption></figure></li></ul></li><li><strong>网络安全现状</strong><ul><li>计算机病毒层出不穷，并呈现新的传播态势和特点</li><li>黑客对全球网络的恶意攻击势头逐年攀升</li><li>由于技术和设计上的不完备，导致系统存在缺陷或安全漏洞</li><li>世界各国军方都在加紧进行信息战的研究</li></ul></li><li><strong>网络安全事件</strong><ol type="1"><li><strong>海湾战争网络安全事件</strong>：1991年，美国特工人员在安曼将伊拉克从德国进口的打印机设备中换上含有可控“计算机病毒”的芯片，导致伊方计算机系统全面瘫痪。</li><li><strong>Microsoft公司网站遭袭</strong>：2000年10月25日，Microsoft公司网站遭到来自俄罗斯黑客的袭击，系统瘫痪，部分源代码丢失。</li><li><strong>中美黑客大战</strong>：2001年4月4日，美国黑客组织攻击中国网站，随后中国黑客发起网络反击战。</li><li><strong>ATM机被黑客攻击</strong>：2010年黑帽大会上，美国安全公司IOActive展示ATM机被黑客攻击，导致现金被非法取出。</li><li><strong>飞机电脑系统被黑客攻击</strong>：2013年荷兰黑客安全大会上，德国网络安全工程师HugoTeso展示绕过飞机安全检查系统接管飞机电脑系统。</li><li><strong>特斯拉ModelS系统被攻破</strong>：2014年10月黑客大赛，特斯拉ModelS系统被攻破，实现远程操控。</li><li><strong>微信等苹果APP发现Xcode恶意后门</strong>：2015年9月14日，微信等近350款苹果APP发现存在Xcode恶意后门。</li><li><strong>汇丰银行遭受DDoS攻击</strong>：2016年1月4日和1月29日，汇丰银行遭受DDoS攻击，服务中断。</li><li><strong>WannaCry勒索病毒爆发</strong>：2017年5月12日，WannaCry勒索病毒利用“永恒之蓝”漏洞传播，影响超过10万台电脑。</li><li><strong>万豪国际酒店客户资料泄露</strong>：2018年11月30日，万豪国际酒店客户系统被黑客侵入，约5亿客户资料泄露。</li></ol></li></ol><h3 id="网络安全威胁与防护措施">网络安全威胁与防护措施</h3><ol type="1"><li><strong>网络安全概念</strong><ul><li>定义：网络安全指网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。</li><li>本质：网络上的信息系统安全。</li><li>网络安全包括<strong>系统安全运行</strong>和<strong>系统信息安全保护</strong>两方面：<ul><li>信息系统的安全运行是信息系统提供有效服务(即可用性)的前提</li><li>信息的安全保护主要是确保数据信息的机密性和完整性</li></ul></li><li>涉及内容：技术方面侧重于防范外部的入侵，管理方面则侧重于内部人为因素的管理。</li><li>安全领域普遍认为“最大的漏洞就是人”。</li><li>目标：<strong>机密性、完整性、可用性、非否认性、可靠性、可控性、可审查性</strong></li></ul></li><li><strong>安全威胁和攻击概念</strong><ul><li><strong>安全威胁</strong>：<ul><li>指对某一资源的保密性、完整性、可用性或合法使用所造成的危险。</li></ul></li><li>脆弱性：指在实施防护措施中或缺少防护措施时系统所具有的弱点。</li><li>风险：是对某个已知的、可能引发某种成功攻击的脆弱性的代价的测度。风险分析能够提供定量的方法，以确定是否应保证在防护措施方面的投入。</li><li>漏洞：从广义上讲，硬件、软件、协议的具体实现或系统安全策略以及人为因素上存在的缺陷，从而可以使攻击者能够在未经系统合法用户授权的情况下访问或破坏系统。</li><li><strong>攻击</strong>：<ul><li>一种故意逃避安全服务(特别是从方法和技术上)并且破坏系统安全策略的智能行为；任何可能危及机构信息安全，破坏系统安全属性的行为；攻击就是某个安全威胁的具体实施</li></ul></li></ul></li><li><strong>网络信息安全的典型威胁</strong><ul><li>包括窃听、信息泄露、病毒感染、非法使用、完整性侵犯、拒绝服务、假冒、流量分析等。</li><li>分类：<ul><li>物理威胁</li><li>操作系统缺陷</li><li>网络协议缺陷</li><li>体系结构缺陷</li><li>黑客程序</li><li>计算机病毒</li></ul></li></ul></li><li><strong>典型威胁及其相互关系</strong><ul><li><figure><img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload alt="典型威胁及其关系"><figcaption aria-hidden="true">典型威胁及其关系</figcaption></figure></li></ul></li><li><strong>安全防护措施</strong><ul><li>包括技术防护和管理措施，以防范外部入侵和内部人为因素的管理。</li></ul></li></ol><h3 id="安全攻击的分类及常见形式">安全攻击的分类及常见形式</h3><ol type="1"><li><strong>安全攻击的种类</strong><ul><li>包括被动攻击和主动攻击。</li><li>被动攻击：对所传输的信息进行窃听和监测；</li><li>主动攻击：恶意篡改数据流或伪造数据流等攻击行为；</li><li>被动攻击虽然难以检测，但采取某些安全防护措施就可以有效阻止；而主动攻击虽然易于检测，但却难以阻止。</li><li><figure><img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload alt="攻击"><figcaption aria-hidden="true">攻击</figcaption></figure><ul><li>Interruption 中断 破坏可用性</li><li>Interception 截取 破坏机密性</li><li>Modification 修改 破坏完整性</li><li>Fabrication 伪造 破坏真实性</li></ul></li></ul></li><li><strong>攻击树</strong><ul><li>攻击树是一种<strong>以分支模型直观地表示计算机安全威胁的方法(或威胁建模)</strong>，用来确定哪些威胁最有可能，以及如何有效地阻止威胁。</li><li>攻击的目标，如访问机密文件，是攻击树的根。</li><li>每个分支代表实现该目标的不同方法，这些分支机构可能会从多个方向跳出，有各种不同的选择来实施这些方法</li></ul></li><li><strong>攻击过程分析</strong><ul><li><strong>预攻击(踩点和扫描)</strong><ul><li>目的：收集信息，进行进一步攻击决策</li><li>内容：<ul><li>获得域名及IP分布</li><li>获得拓扑及OS等</li><li>获得端口和服务</li><li>获得应用系统情况</li><li>跟踪新漏洞发布</li></ul></li></ul></li><li><strong>攻击(入侵、获取权限、提升权限)</strong><ul><li>目的：进行攻击，获得系统的一定权限</li><li>内容：<ul><li>获得远程权限</li><li>进入远程系统</li><li>提升本地权限</li><li>进一步扩展权限</li><li>进行实质性操作</li></ul></li></ul></li><li><strong>后攻击(清除日志、安插后门)</strong><ul><li>目的：消除痕迹，长期维持一定的权限</li><li>内容：<ul><li>植入后门木马</li><li>删除日志</li><li>修补明显的漏洞</li><li>进一步渗透扩展</li></ul></li></ul></li></ul></li><li><strong>安全攻击常见八种形式</strong><ul><li>包括口令窃取、欺骗攻击、缺陷和后门攻击、认证失效攻击、协议缺陷攻击、信息泄漏攻击、指数攻击、拒绝服务攻击等。</li></ul><ol type="1"><li><strong>口令窃取</strong><ul><li><strong>口令猜测攻击的三种基本方式：</strong><ul><li>利用已知或假定的口令尝试登录(口令字典、暴力破解、社会工程学字典攻击)；</li><li>根据窃取的口令文件进行猜测；</li><li>窃听某次合法终端之间的会话，并记录所使用的口令；</li></ul></li><li><strong>抵御口令猜测攻击方式：</strong><ul><li>阻止选择低级口令，采用更为复杂的口令；</li><li>对口令文件严格保护；</li></ul></li><li><strong>彻底解决口令机制的弊端：</strong><ul><li>使用基于令牌的机制，例如一次性口令方案(OTP-One-Time Password)。</li></ul></li></ul></li><li><strong>欺骗攻击</strong><ul><li>采用欺骗的方式(假冒、伪装等)获取合法信息并加以利用，获得权限：<ul><li>Web欺骗(钓鱼邮件)；</li><li>IP欺骗；</li><li>DNS欺骗(域名劫持)；</li><li>ARP欺骗。</li></ul></li></ul></li><li><strong>缺陷和后门攻击</strong><ul><li><strong>缺陷：</strong> 指程序中某些代码不能满足特定需求。</li><li><strong>后门：</strong>指能绕开正常的安全访问机制而直接访问程序的程序代码。</li><li><strong>缓冲器溢出(堆栈粉碎)攻击：</strong>程序对接受的输入数据没有进行有效检测导致的错误，可能造成程序崩溃或者是执行攻击者的命令。<ul><li>一种扰乱程序的攻击方法</li><li>在堆栈上执行代码时出现程序指针紊乱<br></li></ul></li><li><strong>网络蠕虫攻击</strong>：利用操作系统和应用程序<strong>漏洞</strong>传播，通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序，可以造成网络服务遭到拒绝并发生死锁。<strong>蠕虫是一段独立的可执行程序，它可以通过计算机网络把自身的拷贝(复制品)传给其他的计算机。</strong><ul><li>方式之一是向守护程序发送新的代码</li><li>蠕虫向“读”缓冲区内注入大量的数据</li></ul></li></ul></li><li><strong>缓冲区溢出</strong><ul><li>这种攻击可以使一个匿名的Internet用户有机会获得一台主机的部分或全部的控制权。</li><li>攻击者向一个有限空间的缓冲区中复制过长的字符串，可能造成程序瘫痪或系统崩溃，或让攻击者运行恶意代码，执行任意指令，甚至获得管理员用户的权限。</li></ul></li><li><strong>网络蠕虫攻击</strong><ul><li>网络蠕虫攻击是一种通过某种网络媒介，无须计算机使用者干预即可运行的独立程序，通过主动寻找目标计算机，不停的获得网络中存在漏洞的计算机上的部分或全部控制权来将代码副本进行传播。</li><li>蠕虫攻击大量地消耗计算机时间和网络通信带宽，导致整个计算机系统及其网络的崩溃，成为拒绝服务攻击的工具。</li><li>蠕虫会搜集、扩散、暴露系统敏感信息(如用户信息等)，并在系统中留下后门。这些都会导致未来的安全隐患。</li></ul></li><li><strong>认证失效攻击</strong><ul><li><strong>认证机制的失效</strong>易导致服务器被攻击者欺骗，此攻击会使系统对访问者所采取的<strong>身份认证措施无效</strong>。</li></ul></li><li><strong>协议缺陷攻击</strong><ul><li>协议本身的缺陷导致攻击的发生<ul><li>TCP/IP协议、DNS和许多基于RPC的协议易遭到序列号攻击</li><li>IP协议易遭受地址欺骗攻击</li><li>HTTP协议、FTP协议等无安全考虑，易遭受攻击</li><li>802.11无线数据通信标准中的WEP协议也存在缺陷</li></ul></li><li>通过改进协议设计消除此缺陷，如我国的WAPI标准</li></ul></li><li><strong>信息泄漏攻击</strong><ul><li>信息泄露的方式包括利用协议缺陷攻破系统、获得信息，软硬件故障导致意外泄密，病毒侵袭，以及内部信息安全管理不善所导致。</li><li>信息泄露会使攻击者获得有价值的系统相关信息，并用之攻破系统</li></ul></li><li><strong>指数攻击</strong><ul><li>指数攻击通常指的是攻击者利用系统或网络的某个特性，以极快的速度增长攻击力度，使得防御措施难以跟上攻击的变化。</li></ul></li><li><strong>拒绝服务攻击(DOS攻击)</strong><ul><li>拒绝服务攻击(DoS)指攻击者利用系统缺陷，通过执行一些恶意的操作而使得合法的系统用户不能及时地得到应得的服务或系统资源。</li><li>分布式拒绝服务攻击(Distributed Denial of Service，DDoS)是一种基于DoS攻击、但形式特殊的拒绝服务攻击，采用一种分布、协作的大规模攻击方式。</li></ul></li><li><strong>SYN Flood(泛洪)攻击</strong><ul><li>SYNFlood攻击是一种常见的DoS攻击，通过发送大量的SYN请求来消耗服务器的资源，导致服务器无法处理正常的请求。</li></ul></li><li><strong>Smurf 攻击</strong><ul><li>Smurf攻击是一种拒绝服务攻击，攻击者发送大量的ICMP回显请求数据包到一个广播地址，使得网络上的所有主机都向被攻击的主机发送ICMP回显应答。</li></ul></li><li><strong>社会工程学攻击</strong><ul><li>社会工程学攻击是一种通过受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行欺骗、伤害等危害手段，取得自身利益的手法。</li><li>社会工程学是非传统的信息安全</li><li>常用的手段：环境渗透、引诱、伪装、恐吓、恭维、说服</li></ul></li></ol></li></ol><h3 id="osi模型与安全体系结构">OSI模型与安全体系结构</h3><ol type="1"><li><strong>ISO 7498-2标准</strong><ul><li>确定了OSI开放系统互连参考模型的信息安全体系结构。</li><li>充分体现信息安全层次性和结构性特点，是一个以防护为主的静态的安全体系结构。</li></ul></li><li><strong>OSI安全体系结构模型</strong><ul><li>包括安全服务、安全机制和安全攻击。</li><li><figure><img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload alt="OSI"><figcaption aria-hidden="true">OSI</figcaption></figure></li></ul></li><li><strong>安全服务</strong><ul><li>分为认证服务、访问控制服务、数据机密性服务、数据完整性服务和非否认服务。</li></ul><ol type="1"><li><strong>认证服务</strong><ul><li><strong>定义：</strong>提供关于某个实体(人或事物)身份的保证，证实实体声明的身份。</li><li>认证服务是可控性服务的重要组成部分，通常使用在需要提交人或者事物的身份的这一类特殊的通信过程中。</li><li><strong>类型：</strong><ul><li><strong>对等实体认证(Peer Entity Authentication)：</strong>确认通信过程中远端用户的身份。</li><li><strong>数据起源认证(Data Origin Authentication)：</strong>确认数据发送者的身份，保证数据的真正起源。</li></ul></li></ul></li><li><strong>访问控制服务</strong><ul><li><strong>定义：</strong>实施授权的一种方法，防止对资源的未授权使用。</li><li><strong>作用：</strong><ul><li>保护资源以防止非授权访问和操纵。</li><li>保护敏感信息不经过有风险的环境传送。</li><li>限制实体的访问权限，通常是经过认证的合法实体。</li></ul></li></ul></li><li><strong>数据机密性服务</strong><ul><li><strong>定义：</strong> 保护信息不泄露或不暴露给未授权的实体。</li><li><strong>保密粒度：</strong>流(stream)、消息(message)、选择字段(field)</li><li><strong>内容：</strong><ul><li><strong>数据的机密性服务：</strong>使用加密手段保护数据不被未授权者推断出敏感信息。</li><li><strong>业务流机密性服务：</strong>防止攻击者从分析网络业务流中得到敏感信息。</li></ul></li></ul></li><li><strong>数据完整性服务</strong><ul><li><strong>定义：</strong>确保数据的价值和存在性没有改变，对抗数据篡改攻击。</li><li><strong>内容：</strong><ul><li><strong>单个数据单元或字段的完整性：</strong>保护数据单元不被非授权者修改。</li><li><strong>数据单元流或字段流的完整性：</strong>保护数据单元序列的完整性，防止数据单元的重放。</li></ul></li></ul></li><li><strong>非否认服务(不可抵赖性)</strong><ul><li><strong>定义：</strong>阻止参与某次通信交换的一方在事后否认曾经发生过本次交换的事实。</li><li><strong>类型：</strong><ul><li><strong>起源的否认：</strong>向数据接收者提供数据源的证据，防止发送者否认发送过数据。</li><li><strong>传递的否认：</strong>向数据发送者提供数据已交付给接收者的证据，防止接收者否认收到数据。</li></ul></li></ul></li></ol></li><li><strong>安全机制</strong><ul><li>安全服务与安全机制关系：<ul><li>安全服务体现了安全系统的功能；而安全机制则是安全服务的实现。</li><li>一个安全服务可以由多个安全机制实现；而一个安全机制也可以用于实现多个安全服务中。</li><li><figure><img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload alt="安全服务与安全机制关系"><figcaption aria-hidden="true">安全服务与安全机制关系</figcaption></figure></li></ul></li></ul></li></ol><h3 id="网络安全模型">网络安全模型</h3><ol type="1"><li><strong>网络安全模型-网络通信</strong><ul><li>保护信息传输，需要提供<strong>安全机制和安全服务</strong>。<ul><li>一部分是对发送的信息进行与安全相关的转换。例如，消息的加密，使开放网络对加密的消息不可读；又如附加一些基于消息内容的码，用来验证发送者的身份。</li><li>另一部分是由两个主体共享的秘密信息，而对开放网络是保密的。例如，用以加密转换的密钥，用于发送前的加密和接收前的解密。</li></ul></li><li>需要可信的第三方</li><li>一种能被通信主体使用的协议，这种协议使用安全算法和秘密信息以便获得特定的安全服务。</li><li><figure><img src="image-23.webp" srcset="/img/loading/loading3.gif" lazyload alt="网络通信"><figcaption aria-hidden="true">网络通信</figcaption></figure></li></ul></li><li><strong>网络安全模型-访问安全</strong><ul><li>考虑了黑客攻击、病毒与蠕虫等的非授权访问。</li><li>黑客攻击可以形成两类威胁：一类是<strong>信息访问威胁</strong>，即非授权用户截获或修改数据；另一类是<strong>服务威胁</strong>，即服务缺陷以禁止合法用户使用。</li><li>病毒和蠕虫是软件攻击的两个实例，这类攻击通常是通过移动存储介质引入系统，并隐藏在有用软件中；也可通过网络接入系统。</li><li>两个层次：<ul><li><strong>网闸或看门人功能</strong>，阻止非授权用户访问</li><li><strong>内部安全控制(监控)</strong>：监测有害入侵者的存在</li></ul></li><li><figure><img src="image-24.webp" srcset="/img/loading/loading3.gif" lazyload alt="访问安全"><figcaption aria-hidden="true">访问安全</figcaption></figure></li></ul></li><li><strong>网络安全模型- P2DR-时间模型</strong><ul><li>P2DR模型是可量化的、可由数学证明的、基于时间的的安全模型，</li><li>包含安全策略(Policy)、防护(Protection)、检测(Detection)和响应(Response)。<ul><li>安全策略是P2DR安全模型的核心，所有的防护、检测、响应都是依据策略实施的；</li><li>防护主要是预防安全事件的发生，发现存在的系统脆弱性和防止意外威胁和恶意威胁；</li><li>检测是P2DR中一个非常重要的环节，是<strong>静态防护转化为动态防护的关键</strong>，动态响应和加强防护的依据，同时也是强制落实安全策略的工具；</li><li>响应在安全系统中占有重要的地位，是解决安全潜在威胁最有效的方法。</li></ul></li><li>基本思想：信息安全相关的所有活动，无论是攻击、防护、检测和响应行为，都要消耗时间，因此可以用<strong>时间尺度</strong>来衡量一个体系的能力和安全性。</li><li>理论：系统的检测时间与响应时间越长，或对系统的攻击时间越短，则系统的暴露时间越长，系统就越不安全；如果系统的暴露时间<span class="math inline"><em>E</em><sub><em>t</em></sub> &lt;  = 0</span>(即<span class="math inline"><em>D</em><sub><em>t</em></sub> + <em>R</em><sub><em>t</em></sub> &lt;  = <em>P</em><sub><em>t</em></sub></span>)，那么认为系统是安全的</li><li>安全的目标：尽可能地增大保护时间，尽量地减少检测时间和响应时间。</li></ul></li><li><strong>网络安全模型- PDRR</strong><ul><li>包括防护(Protection)、检测(Detection)、响应(Response)、恢复(Recovery)</li><li>这4个部分构成了一个<strong>动态的信息安全周期</strong></li><li><figure><img src="image-25.webp" srcset="/img/loading/loading3.gif" lazyload alt="PDRR"><figcaption aria-hidden="true">PDRR</figcaption></figure></li></ul></li></ol><h2 id="第二节-网络安全防护技术">第二节 网络安全防护技术</h2><h3 id="防火墙">防火墙</h3><ol type="1"><li><strong>防火墙概述</strong><ul><li><strong>定义</strong>：防火墙是在两个网络之间执行访问控制策略的一个或一组安全系统。由软件和硬件组成的系统集合，是实现网络安全策略的有效工具之一，位于安全的网络和不安全的网络之间，属于<strong>边界防护设备</strong>。</li><li><strong>功能</strong>：<ul><li>通过设置访问控制规则，对进出网络边界的<strong>数据流进行过滤</strong>。</li><li>防火墙是建立在内外网络边界上的<strong>过滤封锁机制</strong>，是一种用于保护本地系统或者网络不受基于网络的安全威胁的有效方法。<ul><li><strong>内部网络</strong>(受信网络)被认为是安全和可信赖的，而<strong>外部网络</strong>(通常是Internet，非受信网络)被认为是不安全和不可信赖的。</li><li><strong>非军事化区(DMZ)</strong>：为了配置管理方便，内网中需要向外提供服务的服务器往往放在一个单独的网段，这个网段便是非军事化区。</li></ul></li></ul></li><li><figure><img src="image-26.webp" srcset="/img/loading/loading3.gif" lazyload alt="防火墙概述"><figcaption aria-hidden="true">防火墙概述</figcaption></figure></li></ul></li><li><strong>防火墙的要求</strong><ul><li>所有进出网络数据流都必须经过防火墙。</li><li>只允许经授权的数据流通过防火墙。</li><li>防火墙自身对入侵免疫，即确保自身安全。</li></ul></li><li><strong>防火墙提供的四种控制机制</strong><ul><li><strong>服务控制</strong>：确定了可访问的Internet服务类型，这种控制是双向的，如防火墙可以<strong>以IP地址和TCP端口号为基础对流量进行过滤</strong>；可以提供委托代理软件对收到的每一个服务请求进行解释之后才允许通过。</li><li><strong>方向控制</strong>：确定特定的服务请求可以发起和通过的方向，即允许通过防火墙进入或离开。</li><li><strong>用户控制</strong>：控制特定用户对某些服务的访问权限。</li><li><strong>行为控制</strong>：控制特定服务的应用方式，如控制外部用户只能访问只能访问本地web服务器的部分信息。</li></ul></li><li><strong>防火墙的发展</strong><ul><li><figure><img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload alt="防火墙发展"><figcaption aria-hidden="true">防火墙发展</figcaption></figure></li></ul></li><li><strong>防火墙分类及设计结构</strong><ul><li>防火墙分类<ul><li><figure><img src="image-27.webp" srcset="/img/loading/loading3.gif" lazyload alt="防火墙分类"><figcaption aria-hidden="true">防火墙分类</figcaption></figure></li></ul></li><li>防火墙设计结构<ul><li><figure><img src="image-28.webp" srcset="/img/loading/loading3.gif" lazyload alt="防火墙设计结构"><figcaption aria-hidden="true">防火墙设计结构</figcaption></figure></li></ul></li></ul></li><li><strong>OSI模型与防火墙类型的关系</strong><ul><li>防火墙工作于OSI模型的层次越高，能提供的安全保护等级就越高。</li><li><figure><img src="image-29.webp" srcset="/img/loading/loading3.gif" lazyload alt="OSI"><figcaption aria-hidden="true">OSI</figcaption></figure></li><li>防火墙通常建立在<strong>TCP/IP模型</strong>基础上，OSI模型与TCP/IP模型之间<strong>并不存在一一对应</strong>的关系</li><li><figure><img src="image-30.webp" srcset="/img/loading/loading3.gif" lazyload alt="OSI"><figcaption aria-hidden="true">OSI</figcaption></figure></li></ul></li><li><strong>防火墙能与不能</strong><ul><li><figure><img src="image-32.webp" srcset="/img/loading/loading3.gif" lazyload alt="防火墙能与不能"><figcaption aria-hidden="true">防火墙能与不能</figcaption></figure></li></ul></li><li><strong>防火墙原理</strong><ol type="1"><li><strong>静态包过滤防火墙</strong>：<ul><li><strong>包过滤(PacketFiltering)技术</strong>是防火墙利用对数据包的分析能力，在<strong>网络层</strong>中根据数据包中包头信息有选择地实施允许通过或阻断。</li><li><figure><img src="image-33.webp" srcset="/img/loading/loading3.gif" lazyload alt="静态包过滤"><figcaption aria-hidden="true">静态包过滤</figcaption></figure></li><li>作用过程：<ul><li>防火墙接收到从外部网络到达防火墙的数据包，对数据包过滤。</li><li>对数据包施加过滤规则，对数据包IP头和传输字段内容进行检查。</li><li>如果没有规则与数据包头信息匹配，则对数据包施加默认规则。</li></ul></li><li>判断依据(只考虑IP包)：<ul><li>数据包<strong>封装协议类型</strong>：TCP、UDP、ICMP、IGMP等</li><li><strong>源、目的IP地址</strong>，数据包的TCP/UDP源、目的端口</li><li><strong>服务类型(端口)</strong>：FTP(21)、HTTP(80)、DNS(53)等</li><li>IP选项：源路由、记录路由等</li><li>TCP选项：SYN、ACK、FIN、RST等</li><li>其它协议选项：ICMP ECHO、ICMP ECHO REPLY等</li><li><strong>数据包流向</strong>：in或out</li><li><strong>数据包流经网络接口</strong>：eth0、eth1</li></ul></li></ul></li><li><strong>动态包过滤防火墙</strong>：<ul><li>与普通包过滤防火墙相似，大部分工作于<strong>网络层</strong>。有些安全性高的动态包过滤防火墙，则工作于<strong>传输层</strong>。</li><li><strong>动态包过滤防火墙的不同点</strong>：<ul><li>对外出数据包进行<strong>身份记录</strong>，便于下次让具有相同连接的数据包通过。</li><li>动态包过滤防火墙需要<strong>对已建连接和规则表进行动态维护</strong>，因此是动态的和有状态的。</li></ul></li><li>两种实现方式：<ul><li>实时地改变普通包过滤器的规则集</li><li>采用类似电路级网关的方式转发数据包</li></ul></li></ul></li><li><strong>电路级网关防火墙</strong>：<ul><li>被称为线路级网关，工作在<strong>会话层</strong>，通常作为<strong>应用代理服务器</strong>的一部分，在应用代理类型的防火墙中实现，在<strong>两个主机首次建立TCP连接时创立一个电子屏障</strong>。</li><li>电路级网关不<strong>允许端到端TCP直接连接</strong>，相反，电路级网关充当中介，<strong>接收外来请求，转发请求</strong>。<ul><li>监视两主机建立连接时的握手信息，如通过在TCP3次握手建立连接的过程中，SYN、ACK等标志和序列号等是否合乎逻辑，判定该会话请求是否合法。</li><li><strong>一旦会话连接有效后网关在客户和服务器间中转数据</strong>。</li></ul></li><li>电路级网关的防火墙的安全性比较高，但它仍<strong>不能检查应用层的数据包</strong>以消除应用层攻击的威胁。</li><li><figure><img src="image-34.webp" srcset="/img/loading/loading3.gif" lazyload alt="电路级网关"><figcaption aria-hidden="true">电路级网关</figcaption></figure></li></ul></li><li><strong>应用层网关防火墙</strong>：<ul><li>代理对整个数据包进行检查，因此能在<strong>应用层</strong>上对数据包进行过滤。</li><li>工作特点：<ul><li>必针对每个服务运行一个代理。</li><li>对数据包进行逐个检查和过滤。</li><li><strong>采用“强应用代理”</strong></li><li>在更高层上过滤信息自动创建必要的包过滤规则</li><li>当前最安全的防火墙结构之一。</li></ul></li><li><strong>应用代理与电路级网关两个重要区别</strong>：<ul><li>代理是针对应用的。</li><li>代理对整个数据包进行检查，因此能在OSI模型的应用层上对数据包进行过滤。</li></ul></li></ul></li><li><strong>状态检测包过滤防火墙</strong>：<ul><li>状态检测是一种相当于4.5层的过滤技术，建立状态连接表，并将进出网络的数据当成一个个的会话，利用状态表跟踪每一个会话状态。</li><li><figure><img src="image-35.webp" srcset="/img/loading/loading3.gif" lazyload alt="状态检测"><figcaption aria-hidden="true">状态检测</figcaption></figure></li><li>优点：不限于包过滤防火墙的3/4层的过滤，又不需要应用层网关防火墙的5层过滤，既提供了比包过滤防火墙更高的安全性和更灵活的处理，也避免了应用层网关防火墙带来的速度降低的问题。</li><li>作用过程：<ul><li>要实现状态检测，最重要的是<strong>实现连接的跟踪功能，实现多个包的关联分析</strong>。能够进一步分析主连接中的内容信息，识别出所协商的子连接的端口而在防火墙上将其动态打开，连接结束时自动关闭。</li><li>通过<strong>建立一个出站的TCP连接目录</strong>加强了TCP数据流的监测规则，对网络通信的各层实施监测分析，提取相关的通信和状态信息，并在动态连接表中进行状态及上下文信息的存储和更新</li></ul></li></ul></li><li><strong>空气隙防火墙</strong><ul><li>物理隔离，通过断开网络连接来保护内部网络不受外部网络的威胁。</li><li><figure><img src="image-36.webp" srcset="/img/loading/loading3.gif" lazyload alt="空气隙"><figcaption aria-hidden="true">空气隙</figcaption></figure></li></ul></li></ol></li></ol><h3 id="入侵检测系统">入侵检测系统</h3><ol type="1"><li><strong>入侵检测系统发展史</strong><ul><li><figure><img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload alt="发展史"><figcaption aria-hidden="true">发展史</figcaption></figure></li></ul></li><li><strong>通用的入侵检测系统模型</strong><ul><li><figure><img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload alt="系统模型"><figcaption aria-hidden="true">系统模型</figcaption></figure></li></ul></li><li><strong>功能任务</strong><ul><li><strong>入侵检测系统定义</strong><ul><li>入侵检测系统（IDS）是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备。</li></ul></li><li><strong>入侵检测定义</strong><ul><li>入侵检测(IDS : Intrusion DetectionSystem)是通过从计算机网络或系统中的若干关键点<strong>收集信息并对其进行分析</strong>，从中发现网络或系统中是否有违反安全策略的行为和遭到袭击迹象的一种机制，基本上<strong>不具有访问控制的能力</strong>，单独使用不能起到保护网络的作用，也<strong>不能独立地防止任何一种攻击</strong>。</li></ul></li><li>功能任务<ul><li>信息收集：用户在网络、系统、数据库及应用系统中活动的状态和行为。<ul><li>系统和网络的日志文件</li><li>目录和文件中的异常改变</li><li>程序执行中的异常行为</li><li>物理形式的入侵信息</li></ul></li><li>信息分析<ul><li>模式匹配</li><li>统计分析</li><li>完整性分析</li></ul></li><li>安全响应<ul><li>主动响应</li><li>被动响应</li></ul></li></ul></li></ul></li><li><strong>系统结构</strong><ul><li>事件提取：负责提取相关运行数据或记录，并对数据进行简单过滤。</li><li>入侵分析：找出入侵痕迹，发现异常行为，分析入侵行为并定位入侵者。</li><li>入侵响应：分析出入侵行为后被触发，根据入侵行为产生响应。</li><li>远程管理：在一台管理站上实现统一的管理监控。</li><li><figure><img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload alt="系统结构"><figcaption aria-hidden="true">系统结构</figcaption></figure></li></ul></li><li><strong>分类</strong><ul><li><strong>按照数据来源分类</strong><ol type="1"><li><em>基于网络的IDS(NIDS)</em>：截获数据包，提取特征并与知识库中已知的攻击签名相比较。<ul><li>主要优点：<ul><li>拥有成本低。</li><li>攻击者转移证据困难。</li><li>实时检测和响应。</li><li>能够检测未成功的攻击企图。</li><li>操作系统独立。</li></ul></li><li>运作方式<ul><li>根据网络流量、网络数据包和协议来分析入侵检测。</li><li>通常利用一个运行在随机模式下的网络适配器来监视并分析通过网络的所有通信业务。</li></ul></li><li>常用技术<ul><li>攻击模式、表达式或字节匹配。</li><li>频率或穿越阈值。</li><li>低级事件的相关性。</li><li>统计学意义上的非常规现象检测。</li></ul></li><li><figure><img src="image-43.webp" srcset="/img/loading/loading3.gif" lazyload alt="NIDS部署"><figcaption aria-hidden="true">NIDS部署</figcaption></figure></li></ul></li><li><em>基于主机的IDS(HIDS)</em>：通过对日志和审计记录的监控分析来发现攻击后的误操作。</li><li><em>分布式IDS(DIDS)</em>：同时分析来自主机系统审计日志和网络数据流。</li></ol></li><li><strong>按照检测策略分类</strong><ol type="1"><li><strong><em>误用检测</em>：将收集的信息与数据库作比较</strong></li></ol><ul><li><figure><img src="image-42.webp" srcset="/img/loading/loading3.gif" lazyload alt="误用检测"><figcaption aria-hidden="true">误用检测</figcaption></figure></li><li>原理：误用检测技术又称为<strong>基于知识(或规则)的检测技术</strong>或者<strong>模式匹配检测技术</strong>，收集非正常操作的行为特征，建立相关的特征库，当监测的用户或系统行为与库中的记录相匹配时，系统就认为这种行为是入侵。<ul><li>假设所有的网络攻击行为和方法都具有一定的模式或特征。入侵模式说明了那些导致安全突破或其它误用的事件中的特征、条件、排列和关系。</li></ul></li><li>入侵检测方法：<ul><li>基于条件概率误用检测</li><li>基于专家系统误用检测</li><li>基于状态迁移误用检测</li><li>基于键盘监控误用检测</li><li>基于Petri网状态转换检测</li></ul></li></ul><ol start="2" type="1"><li><strong><em>异常检测</em>：测量属性的平均值，并用来与系统行为比较</strong></li></ol><ul><li><figure><img src="image-41.webp" srcset="/img/loading/loading3.gif" lazyload alt="异常检测"><figcaption aria-hidden="true">异常检测</figcaption></figure></li><li>原理：异常检测技术又称为<strong>基于行为的入侵检测技术</strong>，用来识别主机和网络中的<strong>异常行为</strong>。该技术假设攻击与正常合法的活动有明显的差异，首先假设网络攻击行为是不常见的或是异常的，区别于所有的正常行为。<ul><li><strong>阈值检测</strong>：异常检测技术先<strong>定义一组系统正常活动的阈值</strong>，如CPU利用率、内存利用率、文件校验和等，然后将系统运行时的数值与所定义的“正常”情况比较，得出是否有被攻击的迹象。</li><li><strong>用户轮廓(Profile)</strong>:通常定义为各种行为参数及其阀值的集合，用于描述正常行为范围。</li></ul></li><li>入侵检测方法：<ul><li>统计异常检测方法</li><li>特征选择异常检测方法</li><li>基于贝叶斯推理异常检测方法</li><li>基于贝叶斯网络异常检测方法</li><li>基于模式预测异常检测方法</li></ul></li></ul><ol start="3" type="1"><li><strong><em>完整性分析</em>：关注是否被更改</strong></li></ol></li></ul></li><li><strong>网络诱骗系统</strong><ul><li>密罐技术(Honeypot)就是建立一个虚假的网络，诱惑黑客攻击这个虚假的网络，从而达到保护真正网络的目的。<ul><li>蜜罐系统是一个包含漏洞的诱骗系统，通过模拟一个或多个易攻击的主机，给攻击者提供一个容易攻击的目标</li><li>观测黑客如何探测并最终入侵系统</li><li>拖延攻击者对真正目标的攻击</li></ul></li><li>分类：<ul><li><figure><img src="image-44.webp" srcset="/img/loading/loading3.gif" lazyload alt="Honeypot"><figcaption aria-hidden="true">Honeypot</figcaption></figure></li></ul></li></ul></li></ol><h3 id="虚拟专网vpn">虚拟专网VPN</h3><ol type="1"><li><strong>虚拟专网VPN概述</strong><ul><li><strong>定义</strong>：VPN(虚拟专网，Virtual PrivateNetwork)：将物理上分布在不同地点的网络通过公用网络连接而构成<strong>逻辑上的虚拟子网</strong>。</li><li><strong>原理</strong>：VPN基于Internet/Intranet等公用开放的传输媒体，通过<strong>加密和认证</strong>等安全机制建立虚拟的数据传输通道，以保障在公共网上传输私有数据信息不被窃取、篡改，是目前广泛应用于电子商务、电子政务等应用安全保护的安全技术。</li><li>三个基本安全功能<ul><li><strong>加密数据</strong>：以保证通过公网传输的信息即使被他人截获也不会泄露。</li><li><strong>信息认证和身份认证</strong>：保证信息的完整性、合法性，并能鉴别用户的身份。</li><li><strong>访问控制</strong>：不同的用户有不同的访问权限。</li></ul></li></ul></li><li><strong>VPN特点</strong><ul><li>费用低</li><li>安全保障</li><li>服务质量保证(QoS)</li><li>可扩充性和灵活性</li><li>可管理性</li></ul></li><li><strong>VPN分类</strong><ul><li><strong>远程访问VPN(Access VPN)，也称为VPDN(拨号VPN)</strong><ul><li>移动用户在任何地方、时间与公司总部、公司内联网的VPN设备建立起隧道或秘密信道，实现访问连接。</li></ul></li><li><strong>网关-网关VPN</strong>：<ul><li>组建内联网(Intranet VPN，企业内部虚拟专网)<ul><li>在公司远程分支机构的LAN和公司总部LAN之间的VPN</li></ul></li><li>组建外联网(Extranet VPN，扩展的企业内部虚拟专网)。<ul><li>在供应商、商业合作伙伴的LAN和公司的LAN之间的VPN</li></ul></li></ul></li><li><figure><img src="image-45.webp" srcset="/img/loading/loading3.gif" lazyload alt="VPN分类"><figcaption aria-hidden="true">VPN分类</figcaption></figure></li></ul></li><li><strong>VPN关键技术</strong><ul><li>隧道技术</li><li>加/解密技术</li><li>密钥管理技术</li><li>身份认证技术</li><li>访问控制技术</li></ul></li><li><strong>IPSEC协议</strong><ol type="1"><li><strong>概述</strong><ul><li><strong>定义</strong>：IPSec是一种由IETF设计的端到端的<strong>确保IP层通信安全</strong>的机制，为保证在Internet上传送数据的安全保密性能的<strong>三层隧道加密协议</strong>，弥补IPv4设计时缺乏安全性考虑的不足，将安全服务集成到IP协议中(<strong>加强IP协议的安全</strong>)。</li><li><strong>IPSec对IPV4是可选的，对IPV6是必须的</strong></li><li><strong>地位</strong>：IPSec定义了一种标准的、健壮的以及包容广泛的机制，为IP以及上层协议（比如TCP或者UDP）提供安全保证。<br></li><li>IPSec由三种机制共同保障:<ul><li>认证</li><li>数据机密性</li><li>密钥管理</li></ul></li><li>IPSec实现两个基本目标：<ul><li>保护IP数据包安全</li><li>为抵御网络攻击提供防护措施。</li></ul></li><li>IpSec提供服务：<ul><li>机密性（加密）</li><li>数据完整性（接收方可以检验通过 Internet传输的数据是否没有以任何方式更改或篡改过）</li><li>身份验证（检验数据来源的身份）</li><li>反重播保护（能够检测并拒绝重播的数据包以防止被欺骗）</li></ul></li></ul></li><li><strong>体系结构</strong><ul><li>IPSec由两大部分，三类协议构成：<ul><li>AH(Authentication Header，认证头)<ul><li>AH提供认证和数据完整性</li></ul></li><li>ESP(Encapsulating Security Payload，封装安全载荷)<ul><li>ESP具有所有AH的功能，还可以利用加密技术实现通信保密</li></ul></li><li>IKE(Internet Key Exchange，密钥协商及交换协议)构成。<ul><li>IKE定义了通信实体间进行身份认证、创建安全关联SA、协商加密算法以及生成共享会话密钥的方法。</li></ul></li></ul></li><li><figure><img src="image-46.webp" srcset="/img/loading/loading3.gif" lazyload alt="IPSec"><figcaption aria-hidden="true">IPSec</figcaption></figure></li><li>两种操作模式：<ul><li>传输模式(主机与主机的直接通信)</li><li>隧道模式(常用于关联到多台主机的网络访问连入设备间使用)</li></ul></li><li><strong>安全关联SA</strong>(SecurityAssociation)：是通信对等方对某些要素的一种协定</li><li><strong>两个重要数据库</strong>：安全策略数据库SPD，安全关联数据库SAD</li></ul></li><li><strong>工作模式</strong><ul><li><strong>传输模式</strong>：<ul><li><figure><img src="image-47.webp" srcset="/img/loading/loading3.gif" lazyload alt="传输模式"><figcaption aria-hidden="true">传输模式</figcaption></figure></li><li>保护的是<strong>IP载荷</strong>，通常应用于<strong>两台主机之间，保护传输层协议头，实现端到端通信的安全性</strong>，该模式要求主机支持IPSec。</li><li>当数据包从传输层传送给网络层时，AH和ESP会进行拦截，在IP头与上层协议之间需插入一个IPSec头。当同时应用AH和ESP到传输模式时，应该先应用ESP，再应用AH。</li><li><figure><img src="image-49.webp" srcset="/img/loading/loading3.gif" lazyload alt="传输模式"><figcaption aria-hidden="true">传输模式</figcaption></figure><ul><li>采用传输模式时，IPSec只对IP数据包的净荷进行加密或认证；</li><li>封装数据包继续使用原IP头部，只对部分域进行修改；</li><li>IPSec协议头部插入到原IP头部和传送层头部之间。</li></ul></li></ul></li><li><strong>隧道模式</strong>：<ul><li><figure><img src="image-48.webp" srcset="/img/loading/loading3.gif" lazyload alt="隧道模式"><figcaption aria-hidden="true">隧道模式</figcaption></figure></li><li>保护的是<strong>整个IP包</strong>，应用于<strong>网关模式中</strong>，即在主机与网关(防火墙、路由器)或两个网关之间加载IPSec。</li><li>把一个包封装在另一个新包里面，整个源数据包作为新包的载荷部分，并在前面添加一个新的IP对。被封装的数据包在隧道的两个端点之间通过公共互联网络进行路由。</li><li>被封装的数据包在公共互联网络上传递时所经过的逻辑路径称为<strong>隧道</strong>。一旦到达网络终点，数据将被解包并转发到最终目的地。</li><li><figure><img src="image-50.webp" srcset="/img/loading/loading3.gif" lazyload alt="隧道模式"><figcaption aria-hidden="true">隧道模式</figcaption></figure><ul><li>采用隧道模式时，IPSec对整个IP数据包进行加密或认证；</li><li>产生一个新的IP头，IPSec头被放在新IP头和原IP数据包之间，组成一新IP头。</li></ul></li></ul></li><li><figure><img src="image-51.webp" srcset="/img/loading/loading3.gif" lazyload alt="工作模式"><figcaption aria-hidden="true">工作模式</figcaption></figure></li></ul></li></ol></li><li><strong>TLS协议概述</strong><ul><li><strong>定义</strong>： SSL VPN也称做传输层安全协议(TLS)VPN。</li><li>TLS：基于会话的<strong>加密和认证</strong>的Internet协议，为通信的两个实体提供了一个安全的通道。</li><li>TLS协议主要用于HTTPS协议中，TLS也可以作为构造VPN的技术。</li><li>TLS VPN最大优点是用户不需要安装和配置客户端软件。</li><li>由于TLS协议允许使用<strong>数字签名和证书</strong>，所以它可以提供强大的认证功能。</li></ul></li></ol><h3 id="计算机病毒防护技术">计算机病毒防护技术</h3><ol type="1"><li><strong>计算机病毒特征</strong><ul><li><strong>传染性</strong>：计算机病毒会通过各种渠道扩散到更多的计算机系统上。</li><li><strong>隐蔽性</strong>：病毒通常会采用隐藏进程、文件等手段延长自己的生命周期，隐藏自己的行迹，以防被发现、被删除。</li><li><strong>寄生性</strong>：病毒通常附着在其它正常程序之中，当调用程序时窃取到系统的控制权，先于正常程序执行。<strong>现在这个特性正在变化</strong></li><li><strong>潜伏性</strong>：大部分病毒感染系统之后不会马上发作，可长期隐藏在系统中，只有在满足其特定条件时才启动其表现（破坏）模块。</li><li><strong>破坏性</strong>：侵入系统后会对系统及应用程序产生不同程度的影响，如降低计算机工作效率，占用系统资源，导致系统崩溃。</li></ul></li><li><strong>计算机病毒传播方式</strong><ul><li>通过共享目录攻击</li><li>通过漏洞攻击</li><li>通过WEB方式攻击</li><li>通过FIP方式攻击</li><li>通过邮件攻击</li><li>通过光盘读写攻击</li><li>通过软盘读写攻击</li></ul></li><li><strong>计算机反病毒技术与发展历史</strong><ul><li>反病毒的核心思想：在病毒的存储、传播和执行等阶段，基于“发现”、“拦截”、“清除”等基本手段来对抗病毒</li><li>反病毒技术和形式经历了三个主要阶段：<ul><li>基于<strong>简单特征码</strong>查杀的单一专杀工具阶段</li><li>基于<strong>广谱特征码</strong>查杀、主动防御拦截的综合杀毒软件阶段</li><li>基于<strong>云、人工智能和大数据</strong>技术的互联网查杀阶段。</li></ul></li></ul></li><li><strong>计算机病毒分类</strong><ul><li>木马型病毒</li><li>感染性病毒</li><li>蠕虫型病毒</li><li>后门型病毒</li><li>恶意软件</li></ul></li><li><strong>计算机病毒主流检测技术</strong><ul><li>病毒检测原理<ul><li><strong>采样、匹配、基准</strong></li></ul></li><li>主流检测技术<ul><li>基于特征码的传统检测技术<ul><li>采样为固定位置、采用精准匹配方式技术简单、易于实现、查杀精准速度慢、无法查杀未知病毒</li></ul></li><li>基于行为的传统检测技术<ul><li>针对病毒动态行为进行检测，针对隐蔽性强的病毒有更好检测能力，具备查杀未知病毒能力</li></ul></li><li>基于云技术的云查杀技术<ul><li>将“匹配”和“基准”放在云端进行，反应速度快，终端资源使用大大减小<br></li></ul></li><li>基于大数据与人工智能的查杀技术<ul><li>将“匹配”和“基准”放在云端进行，可以根据模型匹配已知与未知病毒</li></ul></li></ul></li></ul></li></ol><h3 id="安全漏洞扫描技术">安全漏洞扫描技术</h3><ol type="1"><li><strong>漏洞概述</strong><ul><li><strong>定义</strong>：漏洞(Vulnerability)又叫脆弱性，是信息技术、信息产品、信息系统在设计、实现、配置、<strong>运行等过程中有意或无意产生的缺陷</strong>，一旦被恶意主体所利用，就会造成对信息系统的安全损害，从而影响构建于信息系统之上正常服务的运行，危害信息系统及信息的安全属性。</li><li><strong>特点</strong>：<ul><li>漏洞是信息系统<strong>自身的弱点和缺陷</strong>；</li><li>漏洞<strong>存在于一定的环境中</strong>，寄生在一定的客体上；</li><li>具有<strong>可利用性和违规性；本身的存在虽不会造成破坏，但是可以被攻击者利用</strong>，从而给信息系统安全带来威胁和损失</li></ul></li></ul></li><li><strong>漏洞扫描技术概述</strong><ul><li>漏洞扫描即针对通用漏洞的检测，需要依据通用漏洞的形成原理和其造成的外部表现来判断。由系统维护人员识别安全风险，依据结果对漏洞实施有针对性的防护或修补。</li><li>漏洞按照被公布时间的不同阶段，可分为<ul><li>1 Day 漏洞<ul><li>发现并公布的最新漏洞</li></ul></li><li>N Day 漏洞<ul><li>被公布的历史漏洞</li></ul></li><li>0 Day 漏洞<ul><li>未被公开的漏洞</li></ul></li></ul></li><li>各类漏洞管理标准<ul><li>国外：MITRE CVE、CWE、NIST NVD、Symantec BUGTRAQ等</li><li>国内：中国信息安全测评中心维护的CNNVD国家信息安全漏洞库，国家互联网应急中心CNCERT维护的CNCVE、CNVD国家信息安全漏洞共享平台等</li></ul></li></ul></li><li><strong>漏洞扫描技术分类</strong><ol type="1"><li>按照漏洞扫描的目标对象类型维度划分</li></ol><ul><li><strong>系统扫描</strong>：扫描目标是已规模化发布的系统、应用软件或者设备。<ul><li><figure><img src="image-52.webp" srcset="/img/loading/loading3.gif" lazyload alt="系统扫描"><figcaption aria-hidden="true">系统扫描</figcaption></figure></li></ul></li><li><strong>应用扫描</strong>：扫描目标是各种应用，以Web应用居多。<ul><li><figure><img src="image-53.webp" srcset="/img/loading/loading3.gif" lazyload alt="应用扫描"><figcaption aria-hidden="true">应用扫描</figcaption></figure></li></ul></li><li><figure><img src="image-54.webp" srcset="/img/loading/loading3.gif" lazyload alt="按照漏洞扫描的目标对象类型维度划分"><figcaption aria-hidden="true">按照漏洞扫描的目标对象类型维度划分</figcaption></figure></li></ul><ol start="2" type="1"><li>按照漏洞扫描的技术执行形式的维度划分</li></ol><ul><li><figure><img src="image-55.webp" srcset="/img/loading/loading3.gif" lazyload alt="漏洞扫描技术"><figcaption aria-hidden="true">漏洞扫描技术</figcaption></figure></li></ul></li><li><strong>漏洞扫描原理简介</strong><ul><li>漏洞扫描基本流程原理<ul><li>存活判断：探测目标系统是否存活。</li><li>端口扫描：对已经存活的主机，探测主机上开启了哪些端口。</li><li>系统和服务识别：采用黑盒测试方法，通过研究其对各种探测的响应形成识别指纹，进而识别目标主机运行的操作系统。</li><li>漏洞检测：扫描器根据识别的系统与服务信息调用内置或用户外挂的口令字典进行口令猜测，并同时启动远程非登陆漏洞扫描。</li></ul></li><li><figure><img src="image-56.webp" srcset="/img/loading/loading3.gif" lazyload alt="漏洞扫描原理"><figcaption aria-hidden="true">漏洞扫描原理</figcaption></figure></li><li>原理检测和版本检测<ul><li>原理检测(POC检测)：对目标机的相关端口发送请求构造的特殊数据包，判断漏洞是否存在。<ul><li>POC全称“proof of concept”，中文意思是漏洞概念验证。</li><li>通常由一段漏洞验证代码或者漏洞检测数据。通过对检测目标发送此代码或数据后，通过被检测目标返回的信息特殊性，判断漏洞的实际存在与否。</li></ul></li><li>版本检测：依照漏洞库标准实施，在漏洞与系统版本之间存在关联关系。</li></ul></li></ul></li></ol><h2 id="第三节-网络安全工程与管理">第三节 网络安全工程与管理</h2><h3 id="网络安全等级保护">网络安全等级保护</h3><ol type="1"><li><strong>网络安全等级保护制度</strong><ul><li>《网络安全法》第二十一条规定，国家实行网络安全等级保护制度，核心是对网络实施等级保护和分等级监督。</li><li>网络分为<strong>五个安全保护等级</strong>，根据网络在国家安全、经济建设、社会生活中的重要程度，以及其一旦遭到破坏、丧失功能或者数据被篡改、泄露、丢失、损毁后，对国家安全、社会秩序、公共利益以及相关公民、法人和其他组织的合法权益的危害程度等因素。</li></ul></li><li><strong>网络安全等级保护相关政策</strong><ul><li>信息安全等级保护是党中央国务院决定在信息系统安全领域实施的基本国策。</li><li>信息安全等级保护是国家信息安全保障工作的基本制度。</li><li>信息安全等级保护是国家信息安全保障工作的基本方法。</li><li><figure><img src="image-57.webp" srcset="/img/loading/loading3.gif" lazyload alt="网络安全等级保护"><figcaption aria-hidden="true">网络安全等级保护</figcaption></figure></li></ul></li><li><strong>安全等级划分</strong><ul><li>第一级 用户自主保护级<ul><li>一旦受到破坏会对相关公民、法人和其他组织的合法权益造成损害，但不危害国家安全、社会秩序和公共利益的一般网络</li></ul></li><li>第二级 系统审计保护级<ul><li>一旦受到破坏会对相关公民、法人和其他组织的合法权益造成严重损害，或者对社会秩序和公共利益造成危害，但不危害国家安全的一般网络</li></ul></li><li>第三级 安全标记保护级<ul><li>一旦受到破坏会对相关公民、法人和其他组织的合法权益造成特别严重损害，或者会对社会秩序和社会公共利益造成严重危害，或者对国家安全造成危害的重要网络</li></ul></li><li>第四级 结构化保护级<ul><li>一旦受到破坏会对社会秩序和公共利益造成特别严重危害，或者对国家安全造成严重危害的特别重要网络</li></ul></li><li>第五级 访问验证保护级<ul><li>一旦受到破坏后会对国家安全造成特别严重危害的极其重要网络</li></ul></li></ul></li><li><strong>安全等级设计要素</strong><ul><li><figure><img src="image-58.webp" srcset="/img/loading/loading3.gif" lazyload alt="设计要素"><figcaption aria-hidden="true">设计要素</figcaption></figure></li></ul></li><li><strong>等级保护工作流程</strong><ul><li><figure><img src="image-59.webp" srcset="/img/loading/loading3.gif" lazyload alt="工作流程"><figcaption aria-hidden="true">工作流程</figcaption></figure></li><li>安全定级流程<ul><li><figure><img src="image-60.webp" srcset="/img/loading/loading3.gif" lazyload alt="安全定级流程"><figcaption aria-hidden="true">安全定级流程</figcaption></figure></li><li>业务信息安全保护等级</li><li><figure><img src="image-63.webp" srcset="/img/loading/loading3.gif" lazyload alt="业务信息安全"><figcaption aria-hidden="true">业务信息安全</figcaption></figure></li><li>系统服务安全保护等级</li><li><figure><img src="image-64.webp" srcset="/img/loading/loading3.gif" lazyload alt="系统服务安全"><figcaption aria-hidden="true">系统服务安全</figcaption></figure></li></ul></li></ul></li><li><strong>等级保护2.0标准体系</strong><ul><li><figure><img src="image-65.webp" srcset="/img/loading/loading3.gif" lazyload alt="2.0"><figcaption aria-hidden="true">2.0</figcaption></figure></li></ul></li><li><strong>等级保护安全设计技术框架</strong><ul><li><figure><img src="image-66.webp" srcset="/img/loading/loading3.gif" lazyload alt="技术框架"><figcaption aria-hidden="true">技术框架</figcaption></figure></li></ul></li></ol><h3 id="网络安全管理">网络安全管理</h3><ol type="1"><li><strong>网络安全管理</strong><ul><li>定义：网络安全管理是网络安全工作中的重要概念，包括技术控制措施和管理控制措施。</li><li>网络安全管理是指<strong>把分散的网络安全技术因素和人的因素，通过策略、规则协调整合为一体，服务于网络安全的目标。</strong></li><li>任务和目标：信息安全管理是以管理对象的安全为任务和目标的管理。<ul><li>任务：保证管理对象的安全。</li><li>目标：达到管理对象所需的安全级别，将风险控制在可以接受的程度。</li></ul></li></ul></li><li><strong>网络安全管理体系（ISMS）</strong><ul><li><strong>定义</strong>：<ul><li>信息安全管理体系（Information Security Management Systems,简称ISMS）是组织整体管理体系的一个部分，是基于风险评估建立、实施、运行、监视、评审、保持和持续改进信息安全等一系列的管理活动。<ol type="1"><li>基于<strong>风险管理思想</strong>，建立一个系统化、程序化和文件化的管理体系。</li><li>强调全过程和动态控制。</li><li><strong>控制费用与风险平衡的原则</strong>，保护关键信息资产，使得网络安全风险的发生概率和结果降低到可接受的水平。</li></ol></li></ul></li><li>国外网络安全管理相关标准<ul><li>目前，ISO/IEC2700X标准系列是国际主流，国家标准化组织（ISO）专门为ISMS预留了一批标准序号。该系列的<strong>两个核心、基础标准ISO/IEC27001和ISO/IEC27002</strong>已于2005年10月正式发布第一版，2013年10月正式发布第二版。</li></ul></li><li>我国网络安全管理相关标准<ul><li>我国早期主要采用与国际标准靠拢的方式，近年来加强网络安全管理标准的自主制定，已经开始向国际标准化组织提交国际标准提案。在全国信息安全标准化技术委员会内，第7工作组(WG7)的努力下，我国已经正式发布一系列网络安全管理标准。</li></ul></li><li>网络安全管理控制措施<ul><li>为了对组织所面临的的安全风险实施有效的控制，应针对具体地安全威胁和脆弱性，采取适当的控制措施。ISO/IEC27002标准提出了<strong>14个方面的管理控制措施</strong>，包括网络安全策略、网络安全组织、人力资源安全、资产管理、访问控制、密码、物理和环境安全、运行安全、通信安全、系统获取、开发和维护、供应商关系、网络安全事件管理、业务连续性管理和网络安全方面、符合性</li></ul></li><li>ISO 27000系列<ul><li><figure><img src="image-67.webp" srcset="/img/loading/loading3.gif" lazyload alt="ISO27000"><figcaption aria-hidden="true">ISO27000</figcaption></figure></li></ul></li></ul></li><li><strong>网络安全风险管理</strong><ul><li>定义：一种<strong>在风险评估的基础上对风险进行处理的工程</strong>。网络安全风险管理实质是基于风险的网络安全管理。</li><li>信息安全风险评估</li><li>信息系统安全评估</li></ul></li><li><strong>风险评估</strong>：<ul><li>定义：对信息资产面临的威胁、存在的弱点、造成的影响，以及三者综合作用而带来的风险的可能性的评估。<strong>信息安全风险评估是建立信息安全保障机制中的一种科学方法。</strong></li><li>信息安全风险：<ul><li>人为或自然的威胁利用系统存在的脆弱性引发的安全事件，并由于受损信息资产的重要性而对机构造成的影响。</li></ul></li><li>信息安全风险评估涉及4个主要因素：<ul><li><strong>资产、威胁、脆弱性和风险</strong></li></ul></li><li>基本过程：<ul><li>风险评估准备过程</li><li>资产识别过程、威胁识别过程、脆弱性识别过程</li><li>风险分析过程</li></ul></li><li>主要任务：<ul><li>识别组织面临的各种风险</li><li>评估风险概率和可能带来的负面影响</li><li>确定组织承受风险的能力</li><li>确定风险消减和控制的优先等级</li><li>推荐风险消减对策</li></ul></li><li>关键问题：<ul><li>首先要确定保护的对象（或者资产）是什么？它的直接和间接价值如何？</li><li>其次，资产面临哪些潜在威胁？导致威胁的问题所在？威胁发生的可能性有多大？</li><li>资产中存在哪里弱点可能会被威胁所利用？利用的容易程度又如何？</li><li>一旦威胁事件发生，组织会遭受怎样的损失或者面临怎样的负面影响？</li><li>最后，组织应该采取怎样的安全措施才能将风险带来的损失降低到最低程度？</li></ul></li></ul></li><li><strong>信息系统安全评估</strong>：</li></ol><ul><li>或称为或简称为系统评估，是在具体的操作环境与任务下对一个系统的安全保护能力进行的评估。具体是指依据国家风险评估有关管理要求和技术标准，对信息系统及由其存储、处理和传输的信息的机密性、完整性和可用性等安全属性进行科学、公正的综合评价的过程。</li></ul><ol start="6" type="1"><li><strong>资产的有效保护</strong><ul><li>资产一旦受到威胁和破坏带来两类损失：<ul><li><strong>即时的损失</strong>，如由于系统被破坏，员工无法使用，因而降低了劳动生产率。</li><li><strong>长期的恢复所需花费</strong>，也就是从攻击或失效到恢复正常需要的花费。</li></ul></li><li>为了有效保护资产，应尽可能<strong>降低资产受危害的潜在代价</strong>。由于采取一些安全措施，也要付出安全的操作代价。网络安全最终是一个<strong>折中的方案</strong>，需要对危害和降低危害的代价进行权衡。</li><li><figure><img src="image-68.webp" srcset="/img/loading/loading3.gif" lazyload alt="权衡"><figcaption aria-hidden="true">权衡</figcaption></figure></li></ul></li><li><strong>风险管理实施流程</strong><ul><li><figure><img src="image-69.webp" srcset="/img/loading/loading3.gif" lazyload alt="实施流程"><figcaption aria-hidden="true">实施流程</figcaption></figure></li><li><figure><img src="image-70.webp" srcset="/img/loading/loading3.gif" lazyload alt="原理"><figcaption aria-hidden="true">原理</figcaption></figure></li><li>风险管理的核心部分：<strong>风险分析</strong><ul><li>资产属性：资产价值</li><li>威胁属性：威胁主体、影响对象、出现频率、动机</li><li>脆弱性属性：资产弱点的严重程度</li></ul></li><li>风险识别：<ul><li>漏洞</li><li>威胁</li><li>已有的对策和预防措施</li></ul></li></ul></li><li><strong>风险分析</strong><ul><li>定性分析法<ul><li>定性分析法主要是根据操作者的经验知识、业界的一些标准和惯例等非量化方式对风险状况作出判断的过程</li><li>定性分析法<strong>操作起来相对简单</strong>，为风险管理诸要素（资产价值、威胁出现的概率、弱点被利用的容易度、现有控制措施的效力等）的<strong>大小或高低程度定性分级</strong></li><li>该方法具有<strong>很强的主观性</strong>，同时也会因为操作者的经验和直觉偏差导致分析结果发生偏差，从而出现多次评估结果不一致的情况。</li></ul></li><li>定量分析法<ul><li>是对构成风险的各个要素和潜在损失的水平赋予数值，当度量风险的所有要素（<strong>资产价值、威胁频率、弱点利用程度、安全措施的效率和成本等</strong>）都被赋值，风险评估的整个过程和结果就都可以被量化了。</li><li>定量分析就是试图从<strong>数字上</strong>对安全风险进行分析评估的一种方法，优点是评估结果<strong>用直观的数据来表示</strong>，看起来一目了然。</li><li>缺点是存在为了量化而把复杂事物简单化的问题，甚至有些风险要素因量化而被曲解</li></ul></li></ul></li><li><strong>风险控制</strong><ul><li>风险控制措施<ul><li><strong>风险降低</strong>：实施安全措施，把风险降低到一个可接受的级别</li><li><strong>风险承受</strong>：接受潜在的风险并继续运行网络和信息系统</li><li><strong>风险规避</strong>：通过消除风险的原因或后果，来规避风险，即不介入风险</li><li><strong>风险转移</strong>：通过使用其他措施来补偿损失，从而转移风险，如买保险</li></ul></li></ul></li></ol><h3 id="网络安全事件处置与恢复">网络安全事件处置与恢复</h3><ol type="1"><li><strong>网络安全事件分类与分级</strong><ul><li>网络安全事件<strong>分类</strong>：<ul><li>有害程序事件</li><li>网络攻击事件</li><li>信息破坏事件</li><li>信息内容安全事件</li><li>设备设施故障</li><li>灾难性事件</li><li>其他网络安全事件</li></ul></li><li>网络安全事件<strong>分级</strong>：<ul><li>特别重大事件（I级）</li><li>重大事件（II级）</li><li>较大事件（III级）</li><li>一般事件（IV级）</li></ul></li><li>网络安全事件分级主要考虑三个要素：<ul><li><strong>信息系统的重要程度</strong><ul><li>主要考虑信息系统所承载的业务对国家安全、经济建设、社会生活的重要性以及业务对信息系统的依赖程度划分为特别重要信息系统、重要信息系统和一般信息系统。</li></ul></li><li><strong>系统损失</strong><ul><li>由于信息安全事件对信息系统的软硬件、功能以及数据的破坏，导致系统业务中断，从而给事发组织所造成的损失，其大小主要考虑恢复系统正常运行和消除安全事件负面影响所需付出的代价，划分为特别严重的系统损失、严重的系统损失、较大的系统损失和较小的系统损失</li></ul></li><li><strong>社会影响</strong></li></ul></li></ul></li><li><strong>网络安全应急处理过程</strong><ul><li>准备阶段：主要工作包括建立合理的防御/控制措施、建立适当的策略和程序、获得必要的资源和组建相应队伍等。</li><li>检测阶段：目标是对网络安全事件做出初步的动作与响应，根据获得的初步材料和分析结果，预估事件的范围和影响程度，制定进一步的影响策略，并保留相关证据</li><li>抑制阶段：目标是限制攻击的范围，抑制潜在的或进一步的攻击和破坏。主要工作包括阻止入侵者访问被攻陷系统；限制入侵的程度；防止入侵者进一步破坏等。</li><li>根除阶段：目标是在事件被抑制之后，通过分析有关恶意代码或行为找出事件发生的根源，并予以彻底根除。</li><li>恢复阶段：目标是将网络安全事件所涉及的系统还原到正常状态。</li><li>总结阶段：目标是回顾网络安全事件处理的全过程，整理相关信息，尽可能把所有情况记录到文档中。</li></ul></li><li><strong>网络安全应急响应相关概念</strong><ul><li><strong>网络安全事件</strong>：引起网络系统的安全受到威胁和破坏的任何事件。<ul><li>威胁包括：丢失数据机密性，破坏数据和系统的完整性，破坏系统的可用性使之不能提供服务等等</li></ul></li><li><strong>网络安全应急响应能力</strong>：网络系统的整体的应急事件的处理能力，包括针对于安全事件的技术响应手段，流程管理，人员组织等多个方面。</li><li><strong>计算机安全应急响应团队（CSIRT）</strong>：负责日常情况下安全保障和紧急情况下应急响应任务的组织。</li><li><strong>事件响应和安全团队论坛（FIRST）</strong>：把政府，商业机构，和学术组织的安全应急响应团队联合起来，组成一个有机的整体。</li></ul></li><li><strong>国内安全应急响应组织</strong><ul><li>CCERT（1999年5月），中国教育科研网紧急响应组</li><li>NJCERT（1999年10月），中国教育网华东（北）地区网络-安全事件响应组</li><li>2000年8月，国家计算机病毒应急处理中心</li><li>中国电信ChinaNet安全小组</li><li>解放军，公安部</li><li>商业网络安全服务公司</li><li>中国计算机应急响应处理协调中心CNCERT/CC</li></ul></li><li><strong>信息系统灾难恢复</strong><ul><li>定义：将信息系统从灾难造成的故障或瘫痪状态恢复到可正常运行的状态，并将其支持的业务功能从灾难造成的不正常状态恢复到可接受状态的活动和流程。</li><li>内容：<ul><li>灾难恢复规划和灾难备份中心的日常运行</li><li>关键业务功能在灾难备份中心的恢复和重续运行</li><li>主系统的灾后重建和回退工作</li><li>突发事件发生后的应急响应</li></ul></li><li>关键过程：<ul><li><figure><img src="image-71.webp" srcset="/img/loading/loading3.gif" lazyload alt="关键过程"><figcaption aria-hidden="true">关键过程</figcaption></figure></li></ul></li><li><strong>灾难恢复能力6个级别</strong><ol type="1"><li>基本支持</li><li>备用场地支持</li><li>电子传输和部分设备支持</li><li>电子传输及完整设备支持</li><li>实时数据传输及完整设备支持</li><li>数据零丢失和远程集群支持</li></ol></li></ul></li></ol><h3 id="新兴网络及安全技术">新兴网络及安全技术</h3><ol type="1"><li><strong>工业互联网</strong><ul><li>概念：本质是通过开放式的全球化工业级网络平台，紧密融合物理设备、生产线、工厂、运营商、产品和客户，通过自动化和智能化的生产方式降低成本、提高效率。</li><li>安全挑战：工业互联网含有大量CPS（Cyber-Physical Systems信息物理系统）设备，改进后的蠕虫、病毒和木马等传统攻击方式会严重威胁工业互联网安全，而且由于工业互联网集成多类不同系统，所以<strong>存在多种攻击发起点</strong>，攻击者可以从<strong>物理层、网络层和控制层</strong>分别发起攻击。因此，工业互联网遭受攻击会严重影响国家安全。</li><li><strong>工业互联网主要安全防护技术</strong><ul><li>安全人员培训</li><li>安全需求制定和实施计划</li><li>安全硬件和软件设计</li><li>安全方案部署</li><li>信息反馈测试和升级</li></ul></li></ul></li><li><strong>移动互联网安全防护</strong><ul><li>概念：利用互联网的技术、平台、应用以及商业模式与移动通信技术相结合并实践的活动统称。</li><li>组成部分：移动互联网终端设备、移动互联网通信网络、移动互联网应用和移动互联网相关技术。<ul><li><figure><img src="image-72.webp" srcset="/img/loading/loading3.gif" lazyload alt="相关技术"><figcaption aria-hidden="true">相关技术</figcaption></figure></li></ul></li><li>安全架构：移动互联网终端安全、移动互联网网络安全和移动互联网应用安全。<ul><li><figure><img src="image-73.webp" srcset="/img/loading/loading3.gif" lazyload alt="安全架构"><figcaption aria-hidden="true">安全架构</figcaption></figure></li></ul></li><li>安全挑战：十分严格地强调对用户隐私和用户行为的保护<ul><li>移动互联网涉及大量的用户个人信息（如位置信息、通信信息、日志信息、账户信息、支付信息、设备信息、文件信息等），给移动互联网安全监管和用户隐私保护带来极大的挑战</li><li>当前，移动通信终端智能化程度日益提高，处理的信息更加多样化。因此，终端成为攻击者的重要目标之一，<strong>恶意攻击行为逐步向强制推广、风险传播、越权收集等行为转变</strong>。终端被攻击，容易造成用户经济损失、信息泄漏、业务滥用等问题。</li></ul></li></ul></li><li><strong>物联网</strong><ul><li>定义：依托射频识别RFID技术和设备，按约定的通信协议与互联网相结合，使物品信息实现智能化识别和管理，实现物品信息互联而形成的网络</li><li>概念：物联网是指通过信息传感设备，按照约定的协议，把任何物品与互联网连接起来，进行信息交换和通讯，以实现智能化识别、定位、跟踪、监控和管理的一种网络。它是在互联网基础上延伸和扩展的网络。</li><li>组成架构<ul><li><figure><img src="image-74.webp" srcset="/img/loading/loading3.gif" lazyload alt="组成架构"><figcaption aria-hidden="true">组成架构</figcaption></figure></li></ul></li><li>安全挑战：<ul><li><figure><img src="image-75.webp" srcset="/img/loading/loading3.gif" lazyload alt="安全问题"><figcaption aria-hidden="true">安全问题</figcaption></figure></li><li>感知层：感知层节点：网关节点、普通法节点等容易被恶意控制、捕获，容易受到外部DOS攻击；接入物联网的超大量传感节点的标识、认证易被劫持。</li><li>网络层：异构的物联网应用协议无法被安全设备识别，被篡改和入侵后无法及时发现DOS攻击、假冒攻击、中间人攻击、跨异构网络攻击等</li><li>管理服务层：存在高智能自动化处理系统带来不确定性，人为的干预导致服务不可用，设备丢失来自于超大量终端的海量数据的识别和处理</li><li>应用层：许多应用层平台本身存在漏洞易导致未授权的访问、数据破坏和泄露、用户隐私保护；取证和销毁数据、保护知识产权</li></ul></li><li>安全防护技术<ul><li>安全和隐私保护方面，物联网应用的仍然是互联网或通信网中常规的安全防护技术。</li><li><figure><img src="image-76.webp" srcset="/img/loading/loading3.gif" lazyload alt="安全防护技术"><figcaption aria-hidden="true">安全防护技术</figcaption></figure></li></ul></li></ul></li></ol><h1 id="第四章-系统安全基础">第四章 系统安全基础</h1><h2 id="系统安全思维">系统安全思维</h2><ol type="1"><li><strong>系统安全指导思想</strong><ul><li><strong>系统安全定义</strong>：<ul><li>是指在<strong>系统生命周期内</strong>应用<strong>系统安全工程</strong>和<strong>系统安全管理</strong>方法，辨识系统中的隐患，并采取有效的控制措施使其危险性最小，从而使系统在<strong>规定的性能、时间和成本范围内</strong>达到<strong>最佳</strong>的安全程度。</li></ul></li><li>网络空间系统安全：<ul><li>以系统思维应对安全问题；</li><li>应对系统所面临的安全问题，以整体的观点看待系统。</li></ul></li><li>指导思想：在系统思维的指引下，从<strong>系统建设、使用和全生命周期</strong>应对系统所面临的安全问题，正视系统的<strong>体系结构</strong>对系统安全的影响，以<strong>生态系统的视野</strong>全面审视安全对策。</li></ul></li><li><strong>系统安全的演进</strong><ul><li><figure><img src="image-77.webp" srcset="/img/loading/loading3.gif" lazyload alt="系统安全的演进"><figcaption aria-hidden="true">系统安全的演进</figcaption></figure></li></ul></li><li><strong>系统与系统安全</strong><ul><li><strong>系统定义</strong>：<ul><li>一个系统（System）是由<strong>相互作用</strong>或<strong>相互依赖</strong>的<strong>元素或成份</strong>构成的某种类型的一个<strong>统一整体</strong>，其中的元素完整地关联在一起。</li><li>位于系统边界内部的元素属于系统的<strong>组成元素</strong></li><li>位于系统边界外部的元素属于系统的<strong>环境</strong></li></ul></li><li>观察系统的方法<ul><li>自外观察法：观察者位于系统之外对系统进行观察，通常是通过观察系统的输入和输出来分析系统的行为</li><li>自内观察法，观察者位于系统之内对系统进行观察，此时，观察者属于系统的一个组成部分，通常是通过观察系统的外部环境来分析系统的行为</li></ul></li><li>在<strong>网络空间中观察系统的环境</strong>：系统在风险的包围之中，必须具有一定的安全性，才能正常运转。</li><li><strong>系统的安全性需要以系统化的视野去观察</strong></li></ul></li><li><strong>整体论与还原论</strong><ul><li><strong>还原论</strong>：把大系统分解为小系统，然后通过对小系统的研究去推知大系统的行为。<ul><li>把系统分解成它的组成部分，通过对系统的组成部分的研究去了解原有系统的情况。</li><li><strong>局限性</strong>：某些宏观性质是无法通过其微观组成部分的性质反映出来</li></ul></li><li><strong>整体论</strong>：把一个系统看成一个完整的统一体，一个完整的被观察单位，而不是简单的微观组成元素的集合。<ul><li>整体特性：<ul><li>综合特性：可以分解为系统组成部分的特性</li><li>涌现性：不可还原（即不可分解）为系统组成部分的特性<ul><li><strong>安全性属于涌现性</strong></li></ul></li></ul></li><li>操作系统的分解：进程管理、内存管理、外设管理、文件管理、处理器管理。</li></ul></li></ul></li><li><strong>核心理念及概念</strong><ul><li>网络空间系统安全知识领域的核心理念：<ul><li>保护对象</li><li>思维方法（系统化思维方法）<ul><li><strong>系统化思维方法运用到网络空间安全之中称为系统安全思维</strong></li></ul></li></ul></li></ul></li><li><strong>系统工程及安全工程</strong><ul><li><strong>系统工程</strong>(Systems Engineering)：<ul><li>定义：涵盖系统生命周期的具有关联<strong>活动和任务</strong>的技术性和非技术性过程的<strong>集合</strong>。</li><li>技术性过程应用工程分析与设计原则去建设系统</li><li>非技术性过程通过工程管理去保障系统建设工程项目的顺利实现</li><li>目标：获得总体上可信赖的系统，核心是系统整体思想</li></ul></li><li><strong>系统安全工程</strong>(Systems Security Engineering)：<ul><li>定义：把安全性相关活动和任务融合到系统工程的过程之中，形成的一个系统工程专业分支。</li><li>力求从系统生命周期的全过程去保障系统的安全性</li><li>系统的安全性值得信赖等价于系统具有可信的安全性</li></ul></li></ul></li></ol><h2 id="系统安全原理">系统安全原理</h2><ol type="1"><li><strong>基本原则</strong><ul><li>在系统的设计与实现中应遵守的原则包括<strong>限制性原则、简单性原则、方法性原则</strong></li><li><figure><img src="image-78.webp" srcset="/img/loading/loading3.gif" lazyload alt="基本原则"><figcaption aria-hidden="true">基本原则</figcaption></figure></li></ul></li><li><strong>威胁建模</strong><ul><li>威胁建模(Threat Modeling)：<ul><li><strong>定义</strong>：标识潜在安全威胁并审视风险缓解途径的过程。</li><li>威胁(Threat)：给某物造成伤害或损失的意图</li><li>风险(Risk)：某物遭受伤害或损失的可能性</li><li>安全(Security)：某物能避免或抵御他物带来的潜在伤害或损失</li></ul></li></ul></li><li><strong>威胁建模方法</strong><ul><li>威胁建模目标：<ul><li><strong>为防御者提供系统地分析应采取的控制或防御措施的机会</strong></li></ul></li><li>基本类型：<ul><li>以风险为中心</li><li>以资产为中心</li><li>以攻击者为中心</li><li>以软件为中心</li></ul></li><li>典型方法：<ul><li>STRIDE<ul><li>身份欺骗、数据篡改、抵赖、信息泄露、拒绝服务、特权提升的缩写</li><li>具体步骤：<ol type="1"><li>建立数据流图</li><li>标识系统实体、事件和边界</li><li>发现风险</li></ol></li></ul></li><li>PASTA</li><li>Trike</li><li>VAST等</li></ul></li></ul></li></ol><h2 id="系统安全控制及管理">系统安全控制及管理</h2><ol type="1"><li><strong>安全控制</strong><ul><li><strong>访问行为的形式化表示 (s, o, p)</strong><ul><li>s：主体</li><li>o：客体</li><li>p：操作</li><li>典型操作：read、copy、modify、execute</li></ul></li><li><strong>授权的矩阵表示</strong><ul><li>矩阵<span class="math inline"><em>M</em></span> <img src="image-79.webp" srcset="/img/loading/loading3.gif" lazyload alt="授权的矩阵表示"></li><li>s：主体</li><li>o：客体</li><li>m：操作权限的集合，例如<code>m = {read, write}</code></li></ul></li><li><strong>微调的授权的矩阵表示</strong><ul><li>矩阵<span class="math inline"><em>M</em><sup><em>R</em></sup></span><img src="image-80.webp" srcset="/img/loading/loading3.gif" lazyload alt="微调授权矩阵表示"></li><li>r：角色</li><li>o：客体</li><li>m：操作权限的集合</li></ul></li></ul></li><li><strong>访问控制策略</strong><ul><li>访问控制策略1<ul><li>构造访问控制矩阵 M ，给矩阵 M 中的元素赋值，对于任意 (s, o, p)访问请求，在 M 中找到 s 和 o 交叉位置上的元素 m，当 p∈m 时，允许 (s, o,p) 执行，否则，禁止 (s, o, p) 执行</li></ul></li><li>访问控制策略2<ul><li>构造访问控制矩阵 <span class="math inline"><em>M</em><sup><em>R</em></sup></span>，设计角色分配方案 <span class="math inline"><em>f</em><sub><em>R</em></sub></span> ，给矩阵<span class="math inline"><em>M</em><sup><em>R</em></sup></span>中的元素赋值，按方案 <span class="math inline"><em>f</em><sub><em>R</em></sub></span>给每个用户分配角色，对于任意 (u, o, p) 访问请求，u 表示用户，确定角色<span class="math inline"><em>r</em> = <em>f</em><sub><em>R</em></sub>(<em>u</em>)</span>，在 <span class="math inline"><em>M</em><sup><em>R</em></sup></span>中找到 r 和 o 交叉位置上的元素 m，当 p∈m 时，允许 (u, o, p)执行，否则，禁止 (u, o, p) 执行</li></ul></li><li>访问控制策略3<ul><li>制定主体等级分配方案 <span class="math inline"><em>f</em><sub><em>S</em></sub></span>和客体密级分配方案 <span class="math inline"><em>f</em><sub><em>O</em></sub></span>，设计主体等级与客体密级的对比方法cmp，设定任意操作x 应该满足的条件con(x)，给每个主体分配涉密等级，给每个客体分配保密级别，对于任意 (s, o,p) 访问请求，当 <span class="math inline"><em>c</em><em>m</em><em>p</em>(<em>f</em><sub><em>S</em></sub>(<em>s</em>), <em>f</em><sub><em>O</em></sub>(<em>o</em>))</span>满足条件 con(p) 时，允许(s, o, p) 执行，否则，禁止 (s, o, p) 执行</li></ul></li></ul></li><li><strong>安全控制-强制访问控制MAC模型</strong><ul><li>Bell-Lapadula安全模型<ul><li><figure><img src="image-81.webp" srcset="/img/loading/loading3.gif" lazyload alt="bell-lapadula"><figcaption aria-hidden="true">bell-lapadula</figcaption></figure></li></ul></li><li>Biba安全模型<ul><li><figure><img src="image-82.webp" srcset="/img/loading/loading3.gif" lazyload alt="biba"><figcaption aria-hidden="true">biba</figcaption></figure></li></ul></li></ul></li><li><strong>安全监测</strong><ul><li>系统完整性检查：从开机引导到应用运行，各个环节都进行检查，帮助发现系统中是否有重要组成部分受到篡改或破坏。</li><li>病毒查杀和恶意软件检测：对系统中的各种文件进行扫描，帮助发现或清除进入到系统之中的大多数病毒或恶意软件。</li><li>入侵检测：对恶意行为或违反安全策略的现象进行监测，一旦发现情况就及时报告，必要时发出告警。</li></ul></li><li><strong>安全管理</strong><ul><li>安全管理(Security Management)：<ul><li>定义：在安全策略的指导下进行的一系列管理活动。把一个组织的资产标识出来，并制定、说明和实施保护这些资产的策略和流程。</li><li>资产：系统、信息、机器、建筑物、人员</li><li>安全管理策略<ul><li>管理的任务、目标、对象、原则、程序和方法。</li></ul></li><li>安全管理活动<ul><li>制定计划、建立机构、落实措施、开展培训、检查效果和实施改进等。</li></ul></li></ul></li><li>把风险管理原则应用到安全威胁管理之中<ul><li>标识威胁</li><li>评估现有威胁控制措施的有效性</li><li>确定风险的后果</li><li>基于可能性和影响的评级排定风险优先级</li><li>划分风险类型并选择合适的风险策略或风险响应</li><li>它聚焦系统的日常管理，讨论如何把安全理念贯穿到系统安全管理工作的全过程中，帮助系统管理人员明确和落实系统管理工作中的安全责任以便从系统管理的角度提升系统的安全性。</li></ul></li></ul></li></ol><h2 id="系统安全结构">系统安全结构</h2><ol type="1"><li><strong>硬件系统安全</strong><ul><li>硬件安全关注于给软件提供什么样的安全支持，如何帮助软件实现想要的安全功能，以及硬件自身存在的安全隐患对系统安全的影响。</li><li>处理器硬件从可用指令集和可用内存区域两个方面出发，定义了处理器工作的两种状态：<ul><li>内核态：操作系统用，看到所有的指令和地址空间</li><li>用户态：其他程序用，看到其中部分的指令和地址空间</li><li>用户态程序不能干扰内核态的程序。</li></ul></li><li><strong>硬件安全涉及</strong>：硬件设计、访问控制、安全多方计算、安全密钥存储、密钥真实性保障等方面。</li></ul></li><li><strong>检查程序是否被篡改的基本方法</strong><ul><li>检查程序是否被篡改<ul><li>通过计算程序的摘要并与原始摘要对比来检查程序是否被篡改</li></ul></li><li>硬件防篡改方法：<ol type="1"><li>提供密码计算功能<ul><li>通用处理器提供密码运算指令</li><li>独立的安全密码处理器（密码加速器）<ul><li><strong>硬件安全模块</strong>（HSM）：用安全密码处理器芯片实现的硬件计算设备（密码处理+密钥管理和保护）</li></ul></li></ul></li><li>提供数字指纹（确定机器的身份）<ul><li>使用物理不可克隆函数（PUF）硬件器件实现</li></ul></li></ol></li></ul></li><li><strong>操作系统安全</strong><ul><li><strong>操作系统安全是系统安全的基础</strong>：<ul><li>各种应用软件均建立在操作系统提供的系统软件平台之上，上层的应用软件要想获得运行的高可靠性和信息的完整性、保密性，必须依赖于操作系统提供的系统软件基础</li></ul></li><li>操作系统的安全可信性分为不同的级别<ul><li><figure><img src="image-83.webp" srcset="/img/loading/loading3.gif" lazyload alt="级别"><figcaption aria-hidden="true">级别</figcaption></figure></li></ul></li><li>操作系统建立<strong>可信交互路径</strong>，实现应用系统和加密功能的有效衔接<ul><li><figure><img src="image-84.webp" srcset="/img/loading/loading3.gif" lazyload alt="可信交互路径"><figcaption aria-hidden="true">可信交互路径</figcaption></figure></li></ul></li><li>操作系统安全功能：<ul><li>用户管理与身份认证</li><li>自主访问控制<ul><li>文件的拥有者可以自主确定任何用户对该文件的访问权限</li><li>访问权限既可以授给用户，也可以授给用户组</li></ul></li><li>日志功能<ul><li>记录系统中发生的重要活动的详细信息</li></ul></li><li>强制访问控制<ul><li>实现多级安全策略（MLS）等。</li></ul></li></ul></li></ul></li><li><strong>数据库安全</strong><ul><li>数据库安全控制模型<ul><li><figure><img src="image-85.webp" srcset="/img/loading/loading3.gif" lazyload alt="模型"><figcaption aria-hidden="true">模型</figcaption></figure></li></ul></li><li><strong>数据库系统</strong>：<ul><li>定义：提供通用数据管理功能的软件系统</li><li>构成：<ul><li>有数据库管理系统(DBMS)：为用户及应用程序提供数据访问，并具有对数据库进行管理、维护等多种功能</li><li>数据库应用：按一定的方式存取数据<br></li></ul></li></ul></li><li><strong>存取控制</strong>：<ul><li>防止非授权的数据库存取</li><li>防止非授权的对模式对象的存取</li><li>控制磁盘使用</li><li>控制系统资源使用</li><li>审计用户动作</li></ul></li><li><strong>数据库系统安全</strong>：<ul><li>系统运行安全（法律政策安全；物理控制安全；硬件运行安全；操作系统安全；灾害故障恢复；死锁的避免与解除；电磁信息泄露的防止）</li><li>信息安全（用户口令鉴别；用户存取权限控制；数据存取权限和方式控制；审计跟踪；数据加密）</li></ul></li><li><strong>数据库系统的主要威胁</strong>：<ul><li>非法访问数据库信息；</li><li>恶意破坏数据库或未经授权非法修改数据库；</li><li>用户网络访问数据库时受到各种攻击，如搭线窃听等；</li><li>对数据库不正确的访问导致数据库数据的错误等</li></ul></li><li><strong>数据库系统的安全需求</strong>：<ul><li>完整性、可靠性、有效性、保密性、可审计性及可存取控制与用户身份鉴别等。</li></ul></li><li>在一般的计算机系统中，安全措施是一级一级层层设置的</li></ul></li><li><strong>数据库访问控制</strong><ul><li>自主访问控制<ul><li>访问授权</li><li>撤销授权</li></ul></li><li>数据推理<ul><li>根据<strong>合法的非敏感数据</strong>推导出<strong>非法的敏感数据</strong></li></ul></li><li>对数据库数据进行非法间接访问</li><li>推理威胁源自统计数据库：利用合法的统计数据推导出不合法的敏感数据</li><li>强制访问控制/多级安全数据库<ul><li>根据数据的敏感程度，确定数据的敏感级别</li></ul></li><li>根据用户在工作中应该涉及的数据的敏感程度，为用户分配敏感等级</li><li>可以基于表、字段或记录建立敏感级别</li></ul></li><li><strong>数据库SQL注入攻击</strong><ul><li>SQL注入攻击是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。<ul><li>详细:SQL注入攻击是指Web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句结尾添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</li></ul></li><li>SQL注入一般存在于形如：http://xxx.xxx.xxx/abc.aspx?id=XX等带有参数的asp/aspx/php/jsp等动态网页中。</li><li><strong>应对SQL注入攻击的办法</strong></li><li>在应用系统的代码中添加对用户的输入进行严格检查的功能，禁止在输入中滥用转义字符</li></ul></li><li><strong>基于Web的应用安全——论坛</strong><ul><li>例如，论坛中的跨站脚本（XSS）攻击，用户在评论中嵌入脚本，导致其他用户的敏感信息被传输到攻击者指定的服务器中。</li><li>脚本<ul><li>定义：运行在网页服务器上的，使用一种特定的描述性语言，依据一定的格式编写的纯文本保存的程序，</li><li>例如：ASP、PHP、CGI、JSP等</li><li>一般都是要结合数据库如ACCESS、MSSQL、MYSQL、Oracle等来使用</li></ul></li><li>跨站脚本攻击(XSS):<ul><li>在脚本中加入一些破坏计算机系统的命令，这样当用户浏览网页时，一旦调用这类脚本，便会使用户的系统受到攻击。</li></ul></li><li>安全风险<ul><li>攻击者可以劫持用户会话</li><li>插入恶意内容</li><li>重定向用户</li><li>使用恶意软件劫持用户浏览器</li><li>繁殖XSS蠕虫</li><li>甚至破坏网站、修改路由器配置信息等</li></ul></li></ul></li><li><strong>cookie攻击</strong><ul><li><strong>Cookie</strong><ul><li>浏览器与服务器交互时，由Web服务器建立、发送，由(Web客户端)浏览器保存的一些<strong>赋值信息</strong>，在后续交互时，浏览器会把这些信息返还给服务器，使服务器了解浏览器的过往行为</li><li>简单的文本文件，约由255个字符组成，占4KB空间</li><li>有些WEB服务能够收集有关用户的特定状态信息，用来在以后的会话中使用</li><li>Cookie会帮把在该网站上所输入的文字信息或是一些选择和操作都纪录下来，并将<strong>信息保存在用户的硬盘上</strong>，这些信息将保存在用户的浏览器中，当<strong>下一次用户连接到这个服务器时，浏览器就可以将合适的状态发送给服务器使用</strong>，服务器依据Cookie里的内容来判断使用者，送出特定的网页内容，提高了浏览网页的效率</li></ul></li><li><strong>安全性问题</strong>在于它可能泄露用户的信息，欺骗（攻击者通过修改存放在客户端的cookie来达到欺骗服务器认证目的）等问题。<ul><li>Cookie包含的信息包括用户的IP地址、用户密码个人资料等重要信息，服务器对其检索不是在服务器上进行，而是在用户的硬盘上进行</li></ul></li></ul></li></ol><h2 id="安全生态系统">安全生态系统</h2><ol type="1"><li><strong>生态学系统/生态系统</strong><ul><li>物质循环和能量流动的相互影响以及来自亚系统的反馈共同构成一个自我调整的动态平衡</li><li>生态系统是个控制论系统，包括生态系统中的信息网络、物理和化学信息连接起来的组分等。</li></ul></li><li><strong>数字生态系统</strong><ul><li>数字生态系统是一个分布式的、适应性的、开放的<strong>社会-技术系统</strong>，受自然生态系统启发，具有自组织性、可伸缩性、和可持续性。数字生态系统模型受到了自然生态系统知识的启示，尤其是在形形色色的实体之间的竞争与合作的相关方面。</li></ul></li><li><strong>网络空间生态系统</strong><ul><li>像自然生态系统一样，由形形色色的、出于多种目的进行<strong>交互</strong>的各种<strong>成员</strong>构成，主要成员包括私营企业、非营利组织、政府、个人、过程和网络空间设备等，主要设备包括计算机、软件、通信技术等</li></ul></li><li>生态系统视角下的安全威胁模型<ul><li>问题应对<ul><li>理念方面：把系统的概念拓展到生态系统的范围，重新认识安全威胁，重新构建安全模型；</li></ul></li><li>技术方面：要有新的支撑技术</li><li>模型建立<ul><li>不但要考虑企业自身的安全因素；</li></ul></li><li>还必须考虑合作伙伴的安全因素。</li><li>关键支撑技术<ul><li>自动化Automation：让响应速度跟上攻击速度，而不是以人力的响应速度应对机器的攻击速度；</li></ul></li><li>互操作性Interoperability：由策略而不是技术约束定义网络空间共同体，允许网络空间生态系统成员在自动化的团体防御中无缝地、动态地协作；</li><li>认证Authentication：为在线决策建立基础，由人员认证扩展到包含设备认证，设备可以是计算机、软件、或信息等。</li></ul></li></ol><h1 id="第五章-内容安全基础">第五章 内容安全基础</h1><h2 id="信息内容安全威胁">信息内容安全威胁</h2><ol type="1"><li><strong>信息内容安全概述</strong><ul><li><strong>定义</strong>：信息内容安全(Content-based InformationSecurity)是研究利用计算机从<strong>海量信息且变化迅速</strong>的网络中<strong>自动获取、识别和分析特定安全主题相关信息</strong>的技术，借助人工智能与大数据技术管理网络信息传播，是网络安全系统的核心理论与关键组成部分，对提高网络使用效率、净化网络空间、保障社会稳定意义重大。</li><li><strong>信息内容安全分类</strong><ul><li>政治信息安全</li><li>军事信息安全</li><li>商业信息安全</li></ul></li><li>领域、内涵及关键技术<ul><li><figure><img src="image-86.webp" srcset="/img/loading/loading3.gif" lazyload alt="领域、内涵及关键技术"><figcaption aria-hidden="true">领域、内涵及关键技术</figcaption></figure></li></ul></li></ul></li><li><strong>网络信息内容安全的重要性</strong><ul><li>提高网络用户及网站的使用效率。</li><li>净化网络空间，营造健康文明的网络文化环境。</li><li>提高国家信息安全保障水平，是保障国家安全的重要环节。</li></ul></li><li><strong>信息内容安全威胁</strong><ul><li>内容安全面临<strong>泄露（非授权访问）、欺骗、破坏和篡夺</strong>等威胁。<ul><li><figure><img src="image-87.webp" srcset="/img/loading/loading3.gif" lazyload alt="威胁"><figcaption aria-hidden="true">威胁</figcaption></figure></li></ul></li><li>恶意用户产生传播的<strong>恶意内容</strong>也是网络空间面临的潜在安全威胁。</li></ul></li><li><strong>经典的信息内容安全挑战</strong><ul><li><strong>内容获取</strong><ul><li>动态网络社区信息的深入提取。</li><li>跨网络媒体内容的高性能提取。</li><li>混合网络身份内容获取。</li></ul></li><li><strong>内容分析</strong><ul><li>多源网络媒体信息的数据清洗。</li><li>海量非结构化信息的数据仓储与数据挖掘。</li><li>多媒体群体理解技术有待发展。</li></ul></li><li><strong>内容网络</strong><ul><li>内容中心网络命名攻击。</li><li>内容中心网络缓存污染。</li><li>内容中心网络路由攻击。</li></ul></li></ul></li><li><strong>典型的互联网恶意用户行为攻击</strong><ul><li><strong>Spam用户</strong>：向合法用户发布广告、色情、钓鱼等恶意信息，在开放式在下社交网络上将恶意内容快速而大规模传播。</li><li><strong>Sybil攻击（女巫攻击）</strong>：攻击者利用单个节点来伪造多个身份存在于P2P网络中，从而达到削弱网络的冗余性，降低网络健壮性，监视或干扰网络正常活动等目的。攻击者可以通过只部署一个实体，向网络中广播多个身份ID，来充当多个不同的节点（Sybil节点）。Sybil节点为攻击者争取了更多的网络控制权，一旦用户查询资源的路径经过这些Sybil节点，攻击者可以干扰查询、返回错误结果，甚至拒绝回复。</li><li><strong>水军用户</strong>：通过评论或转发参与热点话题，用大量有情感倾向的评论影响舆情态势，如网络推手、打手、刷粉等行为。</li></ul></li><li><strong>以内容为中心的未来互联网</strong><ul><li><strong>目标与意义</strong><ul><li>以内容为中心的未来互联网旨在<strong>将内容名称而不是IP地址</strong>作为传输内容的标识符，从而实现信息的路由。</li></ul></li><li>内容中心网络意义<ul><li>实施更多优化表示来增强网络性能</li><li>提高未来互联网的智能水平</li></ul></li><li>内容中心攻击分类<ul><li><strong>命名</strong>：攻击者可审查和过滤内容。</li><li><strong>路由</strong>：恶意攻击者能发布/订阅无效内容或路由。</li><li><strong>缓存</strong>：可能污染或破坏缓存系统、侵犯中心网络隐私。</li><li><strong>其他</strong>：传输过程中存在未经授权的访问/更改内容风险。</li></ul></li></ul></li></ol><h2 id="网络信息内容获取">网络信息内容获取</h2><ol type="1"><li><strong>网络信息内容获取技术</strong><ul><li>分类<ul><li>文本信息：始终是网络媒体信息中占比最大的信息类型。</li><li>图像信息</li><li>音频信息</li><li>视频信息</li></ul></li><li>获取范围<ul><li>与面向特定点的网络通讯信息获取不同，网络媒体信息获取理论上可覆盖整个国际互联网。</li></ul></li><li><strong>网络媒体信息获取流程</strong><ul><li>初始URL集合</li><li>信息获取</li><li>信息解析</li><li>信息判重</li><li><figure><img src="image-101.webp" srcset="/img/loading/loading3.gif" lazyload alt="流程"><figcaption aria-hidden="true">流程</figcaption></figure></li><li><figure><img src="image-88.webp" srcset="/img/loading/loading3.gif" lazyload alt="媒体信息获取流程"><figcaption aria-hidden="true">媒体信息获取流程</figcaption></figure></li></ul></li></ul></li><li><strong>基于Cookie机制实现身份认证</strong><ul><li><figure><img src="image-102.webp" srcset="/img/loading/loading3.gif" lazyload alt="基于Cookie机制的HTTP信息交互过程"><figcaption aria-hidden="true">基于Cookie机制的HTTP信息交互过程</figcaption></figure></li><li><figure><img src="image-103.webp" srcset="/img/loading/loading3.gif" lazyload alt="基于Cookie机制实现需身份认证才可访问信息请求"><figcaption aria-hidden="true">基于Cookie机制实现需身份认证才可访问信息请求</figcaption></figure></li></ul></li><li><strong>基于浏览器模拟的获取技术</strong><ul><li>利用JSSh客户端向内嵌JSSh服务器的网络浏览器发送JavaScript指令</li><li>指示网络浏览器进行网络身份认证交互，网页发布信息浏览等操作。</li><li><figure><img src="image-89.webp" srcset="/img/loading/loading3.gif" lazyload alt="网络媒体信息获取"><figcaption aria-hidden="true">网络媒体信息获取</figcaption></figure></li></ul></li><li><strong>信息内容获取的典型工具 - 网络爬虫</strong><ul><li>定义：在互联网上的实施信息内容获取的主要工具，是按照一定的规则，自动的抓取互联网信息的<strong>程序或脚本</strong>。</li><li><strong>分类(选择性)</strong>：<ul><li>服务于搜索引擎等搜索类应用的网络爬虫</li><li>针对性进行信息收集的网络爬虫</li></ul></li><li><strong>分布式机制</strong>：网络爬虫需要采用多进程或者多线程，甚至分布式机制来保证信息获取的全面性和时效性。</li></ul></li><li><strong>信息内容特征抽取与选择</strong><ul><li>地位：信息内容的表示及其特征项的选取是<strong>数据挖掘、信息检索</strong>的一个基本问题，把从信息中抽取的<strong>特征词</strong>进行<strong>量化</strong>表示文本信息。</li></ul><ol type="1"><li><strong>文本信息</strong><ul><li>文本转化为可处理的结构化形式</li><li>文本特征选择以达到降维的目的，主要有字符串匹配、基于统计方法、基于理解方法</li><li>文本特征项的特点：<ol type="1"><li>特征项要能够确实标示文本内容;</li><li>特征项具有将目标文本与其他文本相区分的能力;</li><li>特征项的个数不能太多;</li><li>特征项分离要比较容易实现。</li></ol></li><li>特征抽取的主要功能：在不损伤文本核心信息的情况下尽量减少要处理的单词数，以此来降低向量空间维数，从而简化计算，提高文本处理的速度和效率。</li><li>特征选取方式<ul><li>采用向量空间模型来描述文本向量</li><li>通过特征选择来降维，找到代表性特征</li></ul></li><li>特征选择过程<ul><li>根据特征评估函数计算各个特征的评分值</li><li>按照评分值对这些特征进行排序</li><li>选取若干个评分值最高的作为特征词</li></ul></li><li><figure><img src="image-90.webp" srcset="/img/loading/loading3.gif" lazyload alt="特征抽取与选择"><figcaption aria-hidden="true">特征抽取与选择</figcaption></figure></li></ul></li><li><strong>音频信息</strong><ul><li>提取音频的时域和频域特征</li><li>建立数据库，对音频数据进行特征提取并通过特征对数据聚类</li></ul></li><li><strong>图像信息</strong><ul><li>图像颜色特征提取</li><li>图像纹理特征提取</li><li>其他图像特征提取</li></ul></li></ol></li></ol><h2 id="网络信息内容分析与处理">网络信息内容分析与处理</h2><ol type="1"><li><strong>信息内容分析环节</strong><ul><li>海量信息内容分析基本处理环节可以归结为<strong>分类和过滤</strong>，其他更加复杂的处理问题则是上述简单处理问题的组合。</li><li>在信息检索和文本编辑等应用中，快速对用户定义的模式或者短语进行分类是最常见的需求。<strong>高效的分类和过滤算法</strong>能使信息处理变得迅速而准确，反之，则会使处理过程变得冗长而模糊。</li></ul></li><li><strong>信息内容分类方法</strong><ul><li><figure><img src="image-91.webp" srcset="/img/loading/loading3.gif" lazyload alt="分类方法"><figcaption aria-hidden="true">分类方法</figcaption></figure></li></ul></li><li><strong>信息内容过滤</strong><ul><li><strong>定义</strong>：<ul><li>信息过滤是大规模内容处理的一种典型操作，对陆续到达的信息进行过滤，是满足用户信息需求的信息选择过程。</li><li>根据用户的信息需求，运用一定的标准和工具，从大量的动态网络信息流中选取相关的信息或剔除不相关信息的过程。</li></ul></li><li>说明：<ul><li>过滤系统是为无结构化和半结构化的数据而设计的信息系统；</li><li>信息过滤系统主要用来处理大量的动态的信息；</li><li>过滤是基于对个体或群组的信息偏好的描述，也称为用户取向；</li><li>过滤是从动态的数据流中收集或去掉某些文本信息</li></ul></li><li><figure><img src="image-95.webp" srcset="/img/loading/loading3.gif" lazyload alt="通用信息过滤模型"><figcaption aria-hidden="true">通用信息过滤模型</figcaption></figure></li><li><strong>任务</strong>：<ul><li>信息过滤是提供信息的有效流动，消除或者减少信息过量、信息混乱、信息滥用造成的危害。<strong>为用户剔除不合适的信息</strong>是当前信息过滤的主要任务之一。</li></ul></li><li><strong>技术分类</strong><ul><li><strong>根据过滤方法</strong>：<ul><li>分为基于内容的过滤</li><li>基于用户兴趣的过滤</li><li>协作过滤</li></ul></li><li><strong>根据操作主动性</strong>：<ul><li>主动过滤</li><li>被动过滤</li></ul></li><li><strong>根据过滤位置</strong>：<ul><li>信息的源头过滤</li><li>服务器和客户端过滤</li></ul></li><li><strong>根据过滤的目的</strong><ul><li>用户过滤</li><li>安全过滤</li></ul></li></ul></li><li><strong>主要方法(统计方法)</strong><ul><li><strong>向量中心法</strong>：简单实用，应用广泛</li><li><strong>相关反馈法</strong>：实现较易，受训练集合影响较大</li><li><strong>K近邻法</strong>：原理简单，需要确定k值</li><li><strong>贝叶斯法</strong>：机器学习中应用广泛</li><li><strong>多元回归模型</strong>：运用线性最小平方匹配算法</li><li><strong>支持向量机</strong>：文本分类领域比较成功，训练过程效率不高</li><li><strong>概率模型</strong>：特征加权时融入概率因素</li></ul></li><li><strong>常见应用</strong><ul><li><strong>Internet搜索结果过滤</strong>：如搜索引擎对同一问题返回众多结果时，筛选出更符合用户需求的内容。</li><li><strong>用户电子邮件过滤</strong>：过滤垃圾邮件等。</li><li><strong>浏览器过滤</strong>：定制浏览器按用户偏好过滤内容。</li><li><strong>专为未成年人过滤</strong>：去除不适合未成年人的信息。</li><li><strong>为客户过滤</strong>：根据客户爱好、兴趣进行信息筛选。</li></ul></li></ul></li><li><strong>线性分类器</strong>：<ul><li>定义：通过寻找一个投影方向（线性变换，线性组合），将高维问题降低到一维问题来解决，并且要求变换后的一维数据具有如下性质：同类样本尽可能聚集在一起，不同类的样本尽可能地远。</li><li>X输入，<span class="math inline"><em>X</em><sub><em>i</em></sub></span>表示的是第i个输入；Y表示输出；W表示权向量；<span class="math inline"><em>ω</em><sub>0</sub></span>是阈值，f是一个判别函数。</li><li>基本思想：寻找合理决策超平面（确定投影方向和阈值<span class="math inline"><em>ω</em><sub>0</sub></span>），通过给定训练数据确定线性判别函数。设这个超平面为w，满足以下两式子，即通过给定的训练数据确定线性判别函数。<ul><li><span class="math inline"><em>w</em><sup><em>T</em></sup> * <em>x</em> &gt; 0, ∀<em>x</em> ∈ <em>ω</em><sub>1</sub></span></li><li><span class="math inline"><em>w</em><sup><em>T</em></sup> * <em>x</em> &lt; 0, ∀<em>x</em> ∈ <em>ω</em><sub>2</sub></span></li></ul></li><li><figure><img src="image-92.webp" srcset="/img/loading/loading3.gif" lazyload alt="线性分类器"><figcaption aria-hidden="true">线性分类器</figcaption></figure></li></ul></li><li><strong>最近邻分类法（KNN）</strong><ul><li>定义：<ul><li>K最近邻(k-NearestNeighbor-KNN)分类算法属于监督学习算法，多用于图像分类和识别领域。</li></ul></li><li><strong>核心思想</strong>：<ul><li><strong>确定一个临近度的度量,相似性越高，相异性越低的数据样本，可以认为是同一个数据类别</strong>，即如果一个样本在特征空间中的K个最相近(特征空间中最邻近)的样本中的大多数属于某一个类别，则样本也属于这个类别。</li></ul></li><li><strong>核心步骤</strong>：<ul><li>数据清洗：数据规范化;</li><li>确定临近度的度量，并计算临近度;</li><li>按照临近度递增次序排序;</li><li>选取与当前点距离最小的k个点;</li><li>确定前k个点所在类别的出现频率;</li><li>返回前k个点出现频率最高的类别作为当前点的预测分类。</li></ul></li><li><figure><img src="image-93.webp" srcset="/img/loading/loading3.gif" lazyload alt="KNN"><figcaption aria-hidden="true">KNN</figcaption></figure></li></ul></li><li><strong>支持向量机（SVM）</strong><ul><li>定义：<ul><li>SVM支持向量机（英文全称：support vectormachine）是一个分类算法，通过找到一个分类平面，将数据分隔在平面两侧，从而达到分类的目的。</li></ul></li><li><strong>分类基本思路</strong><ul><li><strong>找到最合适的分类平面</strong>，最直接的评估标准S是被分隔的两边数据距离平面间隔最大</li><li>换句话，SVM就是获取最大间隔的超平面。<span class="math inline"><em>w</em> * <em>x</em> + <em>b</em> = 0</span>确定的情况下，<span class="math inline">|<em>w</em><em>x</em> + <em>b</em>|</span>表示点距离超平面的距离，而超平面作为二分类器，如果<span class="math inline"><em>w</em><em>x</em> + <em>b</em> &gt; 0</span>，判断类别y为1,否则判定为-1。</li></ul></li><li><figure><img src="image-94.webp" srcset="/img/loading/loading3.gif" lazyload alt="SVN"><figcaption aria-hidden="true">SVN</figcaption></figure></li></ul></li></ol><h2 id="舆情系统功能及内容分析">舆情系统功能及内容分析</h2><ol type="1"><li><strong>网络舆情系统概述</strong><ul><li><strong>定义</strong>：舆情指在一定的社会空间内，围绕中介性社会事项的发生、发展和变化，作为主体的民众对作为客体的国家管理者产生和持有的社会政治态度。如果把中间的一些定语省略掉，<strong>舆情就是民众的社会政治态度</strong>。</li><li><strong>网络舆情系统</strong>：<ul><li>对海量非结构化信息挖掘与分析；</li><li>实现对网络舆情的热点、焦点、演变等信息的掌握；</li><li>为网络舆情监测与引导部门的决策提供科学依据。</li></ul></li><li><strong>网络舆情特点</strong>：<ul><li>直接性：通过网络直接发表意见，传播迅速</li><li>随意性和多元化：网民可匿名发表观点，健康观点和灰色言论并存</li><li>突发性：网络快速传播的特性使关注焦点迅速成长为舆论热点</li><li>隐蔽性：虚拟网络空间中网民可以隐身发言</li><li>偏差性：网络舆情不等同于全民立场</li></ul></li></ul></li><li><strong>网络舆情分析系统框架</strong><ul><li><figure><img src="image-104.webp" srcset="/img/loading/loading3.gif" lazyload alt="框架"><figcaption aria-hidden="true">框架</figcaption></figure></li><li><figure><img src="image-105.webp" srcset="/img/loading/loading3.gif" lazyload alt="框架"><figcaption aria-hidden="true">框架</figcaption></figure></li></ul></li><li><strong>网络舆情监测技术的发展趋势</strong><ul><li><strong>针对信息源的深入信息采集</strong>：<ul><li>传统搜索引擎一般采用<strong>广度优先</strong>的策略遍历Web并下载文档。</li><li>不能完全满足实际需求，其主要不足体现在——<strong>互联网定点信息源信息的提取率过低</strong>。</li></ul></li><li><strong>异构信息融合分析</strong>：<ul><li>互联网信息在<strong>编码、数据格式以及结构组成</strong>方面存在巨大差异。</li><li>信息分析与提取的重要前提是对信息在<strong>同一表达或标准</strong>的前提下进行有机的结合</li></ul></li><li><strong>非结构信息的结构化表达</strong>：<ul><li>非结构化信息对于阅读者而言比较容易理解，但对于计算机信息处理系统却相当困难。</li><li>目前已有优秀的技术与方法可以对结构化数据进行分析。</li><li>说明：<ul><li>结构化数据是指按照预定义的模型结构化或以预定义的方式组织的数据，结构化数据通常存储在关系数据库管理系统(RDBMS)中。</li><li>非结构化数据指那些无法用固定结构来逻辑表达实现的数据，简单来说就是用户散落在论坛、微博、微信或其他渠道发表的关于产品的各种评价或吐槽。</li><li>非结构化数据主要包含三大块：第一是文本文字；第二是图像、图片等；第三是视频流、电视流，还有网页、元数据等。</li></ul></li></ul></li></ul></li><li><strong>网络舆情分析关键技术</strong><ul><li>信息采集技术</li><li>热点发现</li><li>热点评估</li><li>主题跟踪</li><li>分析处理</li></ul></li><li><strong>网络舆情系统的常用方法</strong><ul><li><strong>高仿真网络信息深度提取技术</strong>：<ul><li>是舆情监控系统信息获取模块的核心，重点研究<strong>原创网络互动式动态信息提取</strong>，形成高性能动态信息提取系统，组成舆情监控系统的信息获取模块。</li><li><figure><img src="image-96.webp" srcset="/img/loading/loading3.gif" lazyload alt="高仿真网络信息深度提取"><figcaption aria-hidden="true">高仿真网络信息深度提取</figcaption></figure></li></ul></li><li><strong>基于语义的海量媒体内容特征快速提取与分类技术</strong>：<ul><li>实现信息特征提取和结构化转变功能，组成舆情监控系统信息分析模块。</li><li>为实现舆情的分析、监测与预警完成信息转化。</li><li><figure><img src="image-97.webp" srcset="/img/loading/loading3.gif" lazyload alt="基于语义的海量文本特征快速提取与分类"><figcaption aria-hidden="true">基于语义的海量文本特征快速提取与分类</figcaption></figure></li></ul></li><li><strong>非结构信息自组织聚合表达技术</strong>：<ul><li>满足网络舆情监测预警基础设施与典型应用的实际需求，组成数据分类、仓储和挖掘引擎模块。</li><li><figure><img src="image-98.webp" srcset="/img/loading/loading3.gif" lazyload alt="非结构信息自组织聚合表达"><figcaption aria-hidden="true">非结构信息自组织聚合表达</figcaption></figure></li></ul></li></ul></li><li><strong>典型运用——互联网舆情内容分析</strong><ul><li><strong>深度挖掘技术</strong>：利用定向搜索手段完成针对指定信息源的深入、全面的<strong>内容提取</strong>操作，以面向结构迥异、风格多样的数据发布源实施互联网媒体信息监控工作。</li><li>关键技术<ul><li>异构信息归一化</li><li>网络热点自动发现</li><li>协商与人际对话模拟</li><li>热点数据报告定制</li></ul></li></ul></li></ol><h2 id="内容中心网络及安全">内容中心网络及安全</h2><ol type="1"><li><strong>内容中心网络概述</strong><ul><li><strong>定义</strong>：<ul><li>内容中心网络(Content CentricNetwork,CCN)是2009年提出的新型下一代网络体系结构，是一个基于内容的网络。</li></ul></li><li><strong>核心思想</strong>：<ul><li><strong>对网络中的每个内容命名, 而不是使用主机和节点的 IP地址</strong>。当需要获取一个内容/服务时,网络节点将发送一个包含所需内容/服务名字的请求。该请求按照内容名字进行路由,而不是 IP 地址。</li></ul></li><li><strong>目标</strong>：<ul><li>替代现有的以 IP为核心的网络体系架构，“以数据为中心”将通信范式的重点从关注于<code>where</code>(地址、服务器、主机)转变到<code>what</code>（通信的内容）。以对数据命名的方式代替位置（IP地址），将数据转变成网络的第一要素。</li></ul></li></ul></li><li><strong>内容中心网络架构</strong><ul><li><strong>基本原理</strong>：摒弃IP地址为中心的传输架构，采用<strong>以内容名称为中心</strong>的架构，通过<strong>以内容为中心的订阅机制和语义主导的命名、路由和缓存策略</strong>，在解决当前基于IP地址进行联网的模式上体现出了巨大的潜力</li><li><strong>架构组成部分</strong><ul><li><strong>内容信息对象</strong>：存储在计算机中并可访问的各类对象，如网页、文档、电影、照片、音乐等。</li><li><strong>命名</strong>：是信息对象的标识，具有<strong>全局性和唯一性</strong>。其地位与TCP/IP架构的IP地址类似。<ul><li>分层命名方案</li><li>扁平命名方案</li></ul></li><li><strong>路由</strong>：<ul><li><figure><img src="image-99.webp" srcset="/img/loading/loading3.gif" lazyload alt="路由"><figcaption aria-hidden="true">路由</figcaption></figure></li></ul></li><li><strong>缓存</strong>：每个CCN节点维护<strong>缓存表</strong>，用于缓存CCN路由器接收的内容消息对象，以便<strong>响应后继接收到的相同请求</strong>。</li><li><strong>应用程序编程接口</strong>：CCN应用程序编程接口根据<strong>请求和交付</strong>内容信息对象定义，用于内容信息对象的<strong>发布和获取</strong>操作。</li></ul></li></ul></li><li><strong>面向内容中心网络的攻击分类</strong><ul><li><strong>命名相关攻击</strong>：<ul><li>监视列表攻击</li><li>嗅探攻击</li></ul></li><li><strong>路由相关攻击</strong>：<ul><li>DDOS攻击</li><li>欺骗攻击</li></ul></li><li><strong>缓存相关攻击</strong>：<ul><li>驱逐流行内容攻击</li></ul></li><li><strong>其他攻击</strong>：<ul><li>假冒攻击</li><li>重放攻击</li></ul></li></ul></li><li><strong>基于雾计算的内容信息中心网络安全防护架构</strong><ul><li>基于雾计算的智能防火墙模型：<ul><li>利用<strong>雾计算范式</strong>在<strong>网络边缘</strong>实现了<strong>隔离防御</strong>系统；</li><li>基于已有的安全策略，该防火墙能够实现对<strong>兴趣包洪泛攻击</strong>的智能感知和动态防御。</li><li><figure><img src="image-100.webp" srcset="/img/loading/loading3.gif" lazyload alt="雾计算"><figcaption aria-hidden="true">雾计算</figcaption></figure></li></ul></li></ul></li></ol><h1 id="第六章-应用安全基础">第六章 应用安全基础</h1><h2 id="应用安全概述">应用安全概述</h2><ol type="1"><li><strong>研究背景</strong><ul><li>信息技术、移动通信技术等的紧密结合与快速发展，以及智能终端软硬件的不断升级与换代，促进了移动互联网、云计算、大数据、物联网等应用的不断普及。</li><li>海量用户个人信息跨系统、跨生态圈乃至跨国境流转常态化<ul><li>住宿出行</li><li>移动社交媒体平台</li><li>移动支付</li></ul></li></ul></li><li><strong>研究范围</strong><ul><li><strong>定义</strong>：应用安全是指为保障各种应用系统在信息的获取，存储，传输和处理各个环节的安全所涉及的相关技术的总称。</li><li><figure><img src="image-106.webp" srcset="/img/loading/loading3.gif" lazyload alt="研究范围"><figcaption aria-hidden="true">研究范围</figcaption></figure></li><li>e.g.<ol type="1"><li>云计算：<ul><li>云计算已成为当前普及的一种信息服务提供方式，为政府和企业提供了新信息系统构建方式和计算方式。</li><li>由于云计算造成了数据所有权和管理权的分离</li><li>在以下两方面开展持续研究：<ul><li>云计算基础设施的可信性</li><li>云数据安全保障</li></ul></li></ul></li><li>工业互联网：<ul><li>数据汇集到云端，要保证系统的可靠运行，需要保证数据的机密性、完整性、访问和流转的可控性以及系统软硬件的安全性</li></ul></li><li>大数据：<ul><li>大数据是一种规模大到在获取、存储、管理、分析方面大大超出了传统数据库软件工具能力范围的数据集合</li><li>大数据本质上是一种方法论，是组合分析多源异构的数据来进行更好的决策，获得的数据越多越能发现数据中蕴含的知识、价值和规律</li><li>实现大数据安全应用的关键：<ul><li>保证数据来源的真实</li><li>促进多源数据的共享</li><li>有效挖掘数据的价值</li><li>保障数据所有者的权益</li></ul></li></ul></li><li>人工智能：<ul><li>人工智能在图像识别、自然语言理解、知识发现与数据挖掘、博弈等方面取得了显著的成就</li><li>人工智能技术越来越多的应用在网络安全防护、密码设计与分析领域</li></ul></li><li>区块链：<ul><li>区块链是数字加密货币-比特币的基础支撑技术</li><li>区块链本身安全问题、隐私保护问题亟待解决，同时对于互联网信息服务、金融安全也带来相应的风险</li></ul></li></ol></li></ul></li></ol><h2 id="身份认证的主要方法">身份认证的主要方法</h2><ol type="1"><li><strong>身份认证定义</strong><ul><li><strong>认证(Authentication)是证实客户的真实身份与其所声称的身份是否相符的过程</strong>，是保证系统安全的重要措施之一。当服务器提供服务时，需要确认请求者的身份，请求者有时也需要确认服务提供者的身份。</li><li>实现身份认证的基本途径：<ul><li>所知：个人掌握的知识，如口令，秘密</li><li>所有：个人所具有的东西，如身份证、令牌、密钥等</li><li>个人特征：指纹、笔迹等</li></ul></li></ul></li><li><strong>身份认证的主要方法</strong><ul><li>用户名/口令认证(所知)<ul><li>优点：简单易用，不需要任何硬件设备</li><li>缺点：<ul><li>口令易泄露；</li><li>弱口令容易被猜测，</li><li>易受字典攻击和暴力攻击；</li><li>复杂的强安全口令难于记忆</li></ul></li></ul></li><li>动态口令/一次性口令OTP(所有)<ul><li>一次性口令是变化的密码，它来源于<strong>产生密码的运算因子是变化的</strong></li><li>一次性口令产生因子一般都采用ISO/IEC 9798-2-2008标准的双运算因子(TwoFactor)，其一是有效期较长的共享密钥，其二是<strong>随机因子</strong><ul><li>1)基于时间同步</li><li>2)基于事件同步</li><li>3)短信验证码</li></ul></li></ul></li><li>挑战应答认证(所有)<ul><li>通过一轮应答实现服务器对用户的认证，利用一次性随机数实现防重放攻击</li><li><figure><img src="image-107.webp" srcset="/img/loading/loading3.gif" lazyload alt="基于单向密码函数和基于数字签名算法"><figcaption aria-hidden="true">基于单向密码函数和基于数字签名算法</figcaption></figure></li><li>基于单向密码函数</li><li>基于数字签名算法</li></ul></li><li>基于生物特征的认证(个人特征)<ul><li><strong>生物统计学</strong>(Biometrics)方法正在成为实现个人身份认证最简单而安全的方法</li><li>签名、指纹、人脸、虹膜、语音等</li><li>优点<ul><li>可信度高</li><li>个人特征因人而异，难以伪造</li><li>随时携带，不易丢失</li></ul></li><li>缺点<ul><li>不够稳定(辨别失败率高)</li><li>不能挂失</li></ul></li></ul></li><li>图灵测试<ul><li>验证登录信息系统的是人还是自动化执行的程序</li><li>采用的方式利用人能快速回答，而机器回答困难的问题</li><li>目的是防范利用计算机程序对系统进行暴力破解</li></ul></li><li>多因子认证<ul><li><strong>实际应用当中，多采取多种认证方式结合，构成多因子认证方式。</strong></li></ul></li></ul></li><li><strong>公钥基础设施PKI</strong><ul><li><strong>定义</strong>：<ul><li>PKI：公钥基础设施(<strong>P</strong>ublic <strong>K</strong>ey<strong>I</strong>nfrastructure)是一种遵循标准的利用公钥理论和技术建立的提供安全服务的<strong>基础设施</strong>。</li></ul></li><li>目的：<ul><li>解决网上<strong>身份认证、电子信息的完整性和不可抵赖性</strong>等安全问题，为网络应用提供可靠的安全服务。</li></ul></li><li>任务：<ul><li>确立可信任的数字身份。</li></ul></li><li><strong>数字证书</strong>：<ul><li>一个用户的<strong>身份</strong>与其所持有的<strong>公钥</strong>绑定，由一个可信任的权威机构CA对该用户身份及对应公钥相绑定的证书进行数字签名，以证明证书的有效性，从而证明用户的身份。</li></ul></li><li>信任体系：<ul><li>X.509标准采用树型的信任体系。根CA自签发证书，是整个信任体系的锚点</li><li>上级CA为下级CA或者用户颁发证书</li><li>Alice和Bob的证书沿着信任路径可以到达相同的证书节点，就可以建立信任关系</li><li><figure><img src="image-108.webp" srcset="/img/loading/loading3.gif" lazyload alt="信任体系"><figcaption aria-hidden="true">信任体系</figcaption></figure></li></ul></li></ul></li><li>身份认证的主流标准<ol type="1"><li><strong>RADIUS</strong>：<ul><li><strong>远程认证拨入业务协议RADIUS</strong> (Remote AuthenticationDial-In User Serviceprotocol)是由Livingston公司发明的，用于接入认证和计费服务。RADIUS规范文本可以参看RFC2865和RFC2856。RAIUS在许多企业信息系统接入过程中得到应用。</li><li><figure><img src="image-109.webp" srcset="/img/loading/loading3.gif" lazyload alt="RADIUS"><figcaption aria-hidden="true">RADIUS</figcaption></figure></li></ul></li><li><strong>FIDO</strong>：<ul><li><strong>在线快速身份认证</strong>(Fast IdentityOnline)使用<strong>生物特征识别技术代替口令</strong>对在线用户进行身份认证</li><li><strong>主要思想</strong><ul><li><strong>基于生物特征识别解锁设备上的加密密钥，使用公钥密码或者对称密码方案与服务器进行身份认证</strong>，从而可完全<strong>通过本地身份认证实现无口令的登录。</strong></li></ul></li><li>FIDO 联盟于 2012 年创立，主旨是制定无口令身份认证协议。</li><li>分类：<ul><li><strong>通用身份认证框架UAF</strong>(Universal AuthenticationFramework)</li><li><strong>通用第二因子认证协议U2F</strong>( Universal 2nd Factor)</li><li><figure><img src="image-110.webp" srcset="/img/loading/loading3.gif" lazyload alt="UAF &amp; U2F"><figcaption aria-hidden="true">UAF &amp; U2F</figcaption></figure></li></ul></li><li>FIDO注册流程<ul><li><figure><img src="image-111.webp" srcset="/img/loading/loading3.gif" lazyload alt="注册"><figcaption aria-hidden="true">注册</figcaption></figure></li></ul></li><li>FIDO认证流程<ul><li><figure><img src="image-112.webp" srcset="/img/loading/loading3.gif" lazyload alt="认证"><figcaption aria-hidden="true">认证</figcaption></figure></li></ul></li></ul></li><li><strong>FIM</strong>：<ul><li><strong>联盟身份管理FIM</strong>(Federated IdentityManagement)可以使<strong>用户使用同一个身份在组成联盟的所有企业中访问相应的资源</strong>，支持用户身份跨安全域链接，用户可以在一个域中认证之后，不需要再进行独立的登录过程就可以访问另一个域的资源。</li><li><strong>Oauth</strong>(OpenAuthorization)是典型的FIM系统，定义了<strong>资源所有者、资源服务器、客户、授权服务器</strong>四个角色。任何服务提供商都可以实现自身的OAUTH认证服务，很多大的公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务。</li><li><strong>SSO单点登录</strong>是身份联盟的一个重要组件。SSO单点登陆是一种集中式访问控制技术，允许主体在系统上进行一次身份认证，并且不需要再次身份认证，就可以访问多个资源。公司的文件传输系统ipan就使用的单点登陆，学校的邮箱和网站，一套密码应用于所有身份认证系统</li><li>工作流程<ul><li><figure><img src="image-113.webp" srcset="/img/loading/loading3.gif" lazyload alt="流程图"><figcaption aria-hidden="true">流程图</figcaption></figure></li><li>客户端(Client)向资源所有者(Resource Owner)请求授权。</li><li>客户端(Client)收到用户授权，这是代表资源所有者(ResourceOwner)授权的凭证(Authorization)。</li><li>客户端(Client)通过与授权服务器(AuthorizationServer)进行身份验证并提供授权许可来请求访问令牌(Access Token)。</li><li>授权服务器(AuthorizationServer)对客户端进行身份验证并验证授权许可，如果有效，则颁发访问令牌(AccessToken)。</li><li>客户端(Client)从资源服务器(ResourceServer)请求受保护的资源并通过提供访问令牌(AccessToken)进行身份验证。</li><li>资源服务器(Resource Server)验证访问令牌(AccessToken)，如果有效，则为请求提供服务。</li></ul></li></ul></li></ol></li></ol><h2 id="访问控制模型">访问控制模型</h2><ol type="1"><li><strong>访问控制的概念和目标</strong><ul><li><strong>概念</strong>：<ul><li>访问控制是通过某种途径<strong>显式地准许或限制访问能力及范围</strong>的一种方法，是针对越权使用资源的防御措施，通过限制对关键资源的访问，防止非法用户侵入或因为合法用户的不慎操作而造成的破坏，保证网络资源受控地，合法地使用。</li></ul></li><li><strong>基本目标</strong>：<ul><li>防止对任何资源(如计算资源、通信资源或信息资源)进行<strong>未授权的访问</strong>；</li><li>允许被授权的主体对某些客体的访问、拒绝向非授权的主体提供服务</li><li>未授权的访问包括：<ul><li><strong>非法用户进入系统</strong></li><li><strong>合法用户对系统资源的非法使用</strong></li></ul></li></ul></li></ul></li><li><strong>访问控制模型</strong><ul><li><strong>自主访问控制模型DAC</strong><ul><li>资源拥有者按照自己的意愿来决定是否将自己所拥有资源的访问权限授予其他用户，策略灵活但安全性较差</li></ul></li><li><strong>强制访问控制模型MAC</strong><ul><li>为用户和数据划分安全等级，实现了信息的单向流动，但权限管理效率偏低、缺少灵活性</li></ul></li><li><strong>基于角色的访问控制模型RBAC</strong><ul><li>通过角色对访问控制策略进行描述，系统中的用户和权限均对应于某些特定的角色。角色的引入实现了用户与权限之间的分离，简化了授权管理。</li><li><strong>核心思想</strong>：将访问权限与角色相联系<ul><li>给用户分配合适的角色</li><li>让用户与访问权限相关联</li><li>用户可以在角色间进行转换</li><li>系统可以添加、删除角色</li></ul></li><li><strong>特点</strong>：<ul><li>以角色作为访问控制的主体</li><li>角色继承</li><li>用户可以在角色间进行转换</li><li>最小特权</li></ul></li></ul></li></ul></li></ol><h2 id="零信任模型">零信任模型</h2><ol type="1"><li><strong>零信任模型(Zero Trust Model)</strong><ul><li>核心思想<ul><li><strong>网络边界内外的任何实体，在未验证之前都不予以信任</strong>，典型系统是谷BeyondCorp体系</li></ul></li><li>特点：<ul><li>内网应用程序和服务不再对公网可见</li><li>企业内网的边界消失</li><li>基于身份、设备、环境认证的精准访问控制</li><li>提供网络通信的端到端加密</li></ul></li></ul></li></ol><h2 id="典型应用及其安全">典型应用及其安全</h2><ol type="1"><li><strong>隐私保护</strong><ul><li>定义：<ul><li><strong>隐私保护是指在发布或者共享数据中不能识别出具体个人的数据</strong></li><li><strong>个人信息</strong>是指自然人的相关数据</li><li><strong>隐私</strong>是指<strong>个人敏感信息</strong><ul><li>包括身份证号码、电话号码、住址、住房类型、居住时间、过敏信息、疾病和药品使用状况、财务状况、信用记录、车辆识别码、品牌爱好、交通工具、出行地、出行时间、购买记录、指纹、掌纹、虹膜、社交账号、犯罪信息等</li></ul></li></ul></li><li>隐私保护方法：<ul><li><strong>基于数据扰乱方法</strong>：扰乱是指在数据发布前通过加入噪声、引入随机因子及对私有向量进行线型变换等手段对敏感数据进行扰乱(数据泛化、数据扭曲、数据清洗、数据屏蔽等)，以实现对原始数据改头换面的目标。这种处理方法可以快速地完成，但其安全性较差，且以降低数据的精确性为代价，从而影响数据分析结果，一般这种处理手段仅能得到近似的计算结果。</li><li><strong>基于密码的方法</strong>：主要是研究构造适用于隐私保护、与传统数据加解密不同的密钥管理机制、同态密码方案以及混淆方法、多方计算等。</li></ul></li></ul></li><li><strong>K-匿名性</strong><ul><li>仅在数据集中去掉名字不能起到匿名效果。数据集中存在一些准标识符，当与其他数据集中的信息组合在一起的时候可以重新标识身份。</li><li>1998年Sweeney 提出K-匿名。</li></ul></li><li><strong>L-多样性</strong><ul><li>同质性攻击(Homogeneity attack)</li><li>背景知识攻击(background knowledge attack)</li></ul></li><li><strong>t-邻近(t-closeness)</strong><ul><li>隐私是观测到的信息增益;看到发布的数据表之前，得到的敏感属性的先验信息；看到发布数据之后，得到后验信息；</li><li><strong>隐私是先验信息和后验信息的差额</strong></li></ul></li><li><strong>差分隐私(Differential Privacy)</strong><ul><li>定义：<ul><li>一个数据集进行统计查询计算时，<strong>不能通过多次不同的查询方式推断出数据集中是否包含一个特定个体的数据</strong>。</li><li>称一个算法A满足ϵ-差分隐私<span class="math inline">(<em>ϵ</em> − <em>D</em><em>P</em>)</span>，其中<span class="math inline"><em>ϵ</em> &gt; 0</span>，当且仅当对于任意的两个只相差一个元素的数据集D和D’，有以下条件满足：$∀𝑇 ⊆ Range(𝐴): Pr[𝐴(𝐷)∈𝑇] ≤ 𝑒^𝜀 Pr[𝐴(𝐷^′)∈𝑇] $</li></ul></li><li>实现方式：<ul><li>$ 𝑀(𝑓(𝐷)) = 𝑓(𝐷) + 𝑥 $，<ul><li>𝑓:查询函数</li><li>x:随机噪声</li></ul></li><li>拉普拉斯机制 $ Lap(𝑥│𝜇，𝑏) = e^{(−)} $</li></ul></li><li><figure><img src="image-114.webp" srcset="/img/loading/loading3.gif" lazyload alt="DP"><figcaption aria-hidden="true">DP</figcaption></figure></li></ul></li><li><strong>隐私计算</strong><ul><li>定义：<ul><li><strong>隐私计算是面向隐私信息全生命周期保护的计算理论和方法</strong>，是隐私信息的所有权、管理权和使用权分离时隐私度量、隐私泄漏代价、隐私保护与隐私分析复杂性的可计算模型与公理化系统</li></ul></li><li>地位：<ul><li><strong>隐私计算是泛在网络空间隐私信息保护的重要理论基础</strong></li></ul></li><li>在处理视频、音频、图像、图形、文字、数值、泛在网络行为性信息流等信息时，对所涉及的隐私信息进行<strong>描述、度量、评价和融合</strong>等操作，形成一套符号化、公式化且具有量化评价标准的隐私计算理论、算法及应用技术，支持多系统融合的隐私信息保护</li></ul></li><li><strong>隐私保护的法律法规</strong><ul><li>HIPAA</li><li>Regulation P(Privacy of Consumer Financial Information)</li><li>FACT(Fair and Accurate Credit Transaction Act 2003)</li><li>GDPR(General Data Protection Reform)</li><li>网络安全法</li><li>个人信息保护法</li></ul></li><li><strong>云计算</strong><ul><li>定义：<ul><li>云计算是一种基于网络访问、以按需分配、共享使用的方式对物理计算资源进行供应和管理的模式</li></ul></li><li>云部署方式<ul><li><figure><img src="image-115.webp" srcset="/img/loading/loading3.gif" lazyload alt="云部署方式"><figcaption aria-hidden="true">云部署方式</figcaption></figure></li></ul></li><li>云计算服务模型<ul><li>SaaS</li><li>PaaS</li><li>IaaS</li></ul></li><li><strong>云计算基础：虚拟化技术</strong><ul><li>裸金属架构<ul><li>VMware vSphere， Xen， Hyper-V， KVM</li></ul></li><li>寄居架构<ul><li>VMware Workstation， VirtualBox</li></ul></li><li>容器<ul><li>Docker</li></ul></li><li><figure><img src="image-116.webp" srcset="/img/loading/loading3.gif" lazyload alt="虚拟化技术"><figcaption aria-hidden="true">虚拟化技术</figcaption></figure></li></ul></li></ul></li><li><strong>云计算安全</strong><ul><li>云基础设施安全<ol type="1"><li>虚拟机逃逸<ul><li>利用虚拟机管理软件或者虚拟机中<strong>运行软件的漏洞</strong>，控制虚拟机管理系统或者在<strong>宿主机上运行恶意软件</strong>，进而获得<strong>其他虚拟机的完全控制权限</strong></li></ul></li><li>边信道攻击<ul><li>攻击者<strong>控制的虚拟机与目标虚拟机使用相同的物理层硬件</strong>，二者交替执行。攻击者首先借助恶意虚拟机访问共享硬件和缓存，然后在交替执行的过程中通过边信道信息来推断出目标虚拟机的行为，识别相应的信息，最终导致目标虚拟机内的用户数据泄露。</li></ul></li><li>网络隔离<ul><li>云计算平台中，数据包在虚拟网络中移动，不用通过物理网络传输，在物理网络上的监控和过滤工具永远看不到这些流量，在多租户的公有云网络中引发的安全问题尤为显著</li></ul></li><li>镜像和快照的安全<ul><li>云计算平台往往通过特定的镜像来创建虚拟机或者服务实例；</li><li>攻击者通过入侵虚拟机管理系统并感染镜像，可以大幅提升攻击的效率和影响范围。若攻击者非法恢复了快照，历史数据将被清除，攻击行为将被彻底隐藏</li></ul></li></ol></li><li>云数据安全<ol type="1"><li>云存储数据安全<ul><li><strong>云加密数据库</strong><ul><li><figure><img src="image-120.webp" srcset="/img/loading/loading3.gif" lazyload alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure></li></ul></li><li><strong>密文搜索</strong><ul><li>可搜索加密技术是搜索技术和加密技术的结合。可搜索加密能够实现将用户的数据进行特殊的加密后上传到云服务器上，并且可以实现根据关键字进行检索的功能，在方便用户使用的过程中，也保护了文件的隐私安全。</li><li><figure><img src="image-118.webp" srcset="/img/loading/loading3.gif" lazyload alt="密文搜索"><figcaption aria-hidden="true">密文搜索</figcaption></figure></li><li>当前可搜索加密机制分为：<ol type="1"><li>对称可搜索加密(Symmetric Searchable Encryption SSE)<ul><li>对称可搜索加密的构造通常基于伪随机函数，具有计算开销小、算法简单、速度快的特点。</li><li>除了加解密过程采用相同的密钥外，其陷门生成也需密钥的参与。</li><li>单用户模型的单用户特点使得对称可搜索加密非常适用于该类问题的解决：用户使用密钥加密个人文件并上传至服务器，检索时，用户通过密钥生成待检索关键词陷门，服务器根据陷门执行检索过程后返回目标密文。</li></ul></li><li>非对称可搜索加密(Asymmetric Searchable Encryption ASE)<ul><li>非对称可搜索加密使用两种密钥：公钥用于明文信息的加密和目标密文的检索，私钥用于解密密文信息和生成关键词陷门。</li><li>非对称可搜索加密算法通常较为复杂，加解密速度较慢，然而，其公私钥相互分离的特点，非常适用于多用户体制下可搜索加密问题的解决：发送者使用接收者的公钥加密文件和相关关键词，检索时，接收者使用私钥生成待检索关键词陷门，服务器根据陷门执行检索算法后返回目标密文。</li><li>该处理过程避免了在发送者与接收者之间建立安全通道，具有较高的实用性。</li></ul></li></ol><ul><li><figure><img src="image-117.webp" srcset="/img/loading/loading3.gif" lazyload alt="SSE &amp; ASE"><figcaption aria-hidden="true">SSE &amp; ASE</figcaption></figure></li></ul></li></ul></li></ul></li><li>云计算数据安全<ul><li>保密计算旨在保护使用中的数据。<ul><li>通过加密数据，让云服务器在密文数据上进行计算。</li><li>相关技术：同态加密、特定计算安全外包、可验证外包计算</li><li><figure><img src="image-119.webp" srcset="/img/loading/loading3.gif" lazyload alt="保密计算"><figcaption aria-hidden="true">保密计算</figcaption></figure></li></ul></li><li><strong>基于SGX的保密计算</strong><ul><li>SGX(Software Guard Extensions)，是 Intel CPU提供的可信执行环境，可以为云上数据代码的完整性和保密性提供芯片级的安全保障。<ol type="1"><li>在计算平台上提供一个可信的空间，保障用户关键代码和数据的机密性和完整性。</li><li>把应用程序分为两部分：安全应用程序和非安全应用程序；</li><li>将合法软件的安全操作封装在一个<code>飞地</code>(enclave)中；</li><li>当调用 enclave 函数时，只有 enclave内部的代码才能查看其数据，并始终拒绝外部访问；当调用结束时，enclave的数据会留在受保护的内存中。</li><li>注：一个 CPU中可以存在多个<code>飞地</code>，大家互不干扰，同时进行自己秘密的操作。</li></ol></li></ul></li></ul></li><li>云共享数据安全<ul><li>数据拥有者通常会将数据加密后上传到云端，给数据共享带来困难。<ul><li>大规模用户的数据共享需要大量密钥，生成、分发和保管这些密钥困难</li><li>如何制定灵活可控的访问策略，实施细粒度的访问控制，会成倍增加密钥数量</li><li>用户访问权限更新或撤销时，需要重新生成信的密钥，计算量大</li><li>相关技术：基于属性的加密技术(Attributed Based EncryptionABE)、访问策略表达技术、访问权限撤销技术、访问控制效率增强技术</li></ul></li><li><strong>CP—ABE(密文策略属性加密)</strong><ul><li>在ABE系统中，用户的密钥和密文被标记为描述性属性集，而特定密钥只有在密文的属性与用户密钥之间匹配的情况下才能解密特定的密文。<ul><li>以属性作为公钥对用户数据进行加密</li><li>用户的私钥也和属性相关，只有当用户私钥具备解密数据的基本属性时，用户才能够解密出数据明文，当密文和私钥之间至少K个属性重叠时，密码系统允许解密。</li></ul></li><li>CP-ABE：将访问控制策略嵌入到密文当中，只有当用户拥有满足访问控制策略的属性集合及其对应的私钥情况下才能解密密文。</li><li><figure><img src="image-121.webp" srcset="/img/loading/loading3.gif" lazyload alt="CP-ABE"><figcaption aria-hidden="true">CP-ABE</figcaption></figure></li></ul></li></ul></li></ol></li></ul></li><li><strong>比特币与区块链</strong><ul><li>区块链<ul><li>2008年11月，中本聪(Satoshi Nakamoto)发表Bitcoin: A Peer-to-PeerElectronic Cash System，提出了无中心电子现金系统</li><li>区块链是比特币的底层技术</li><li>区块链是一个公开、透明的分布式账本</li><li>区块链是一条<strong>哈希链</strong>，<strong>用哈希串联信息</strong>，实现完整性，防止篡改，公开验证</li><li>区块链具有不可篡改性。<ul><li>区块链中存储的交易信息每一条都有相对应的 Hash 值，由每一条记录的Hash 值作为叶子节点生成二叉 Merkle 树。</li><li>Merkle 树的根节点（Hash值）保存在本区块的块头部分，区块头部除了当前区块的 Merkle树的根节点，还保存时间戳以及前一个区块的 Hash 形成一条链式结构。</li><li>因此，要想篡改区块链中的一条记录，不仅要修改本区块的Hash值，还要修改后续所有区块的Hash值，或者生成一条新的区块链结构，使得新的链比原来的链更长。</li><li>实际上，这是很难实现的。一般一个区块后面有6个新的区块生成时，即可认为该区块不可篡改，可以将该区块加入到区块链的结构中。</li></ul></li></ul></li><li>区块<ul><li>比特币网络中，<strong>数据以文件的形式被永久记录，称这些记录为区块</strong></li><li>新区块一旦被记录在区块链上，就不能被改变或者删除<ul><li><strong>时间戳</strong>记录特定的数据生成时间</li><li>默克尔树用来存储当前区块的所有交易信息</li><li>难度系数用于控制区块的生成速度，<strong>比特币每10分钟产生一个区块</strong></li></ul></li><li><figure><img src="image-122.webp" srcset="/img/loading/loading3.gif" lazyload alt="比特币"><figcaption aria-hidden="true">比特币</figcaption></figure></li></ul></li><li>共识机制<ul><li>网络中各个参与节点需要<strong>确认交易的机制</strong>，使得在网络中存在故障或不可信节点的情况下，区块链网络中的交易能按照预期的正确方式执行，<strong>确保各个节点最终结果的一致性</strong>。</li><li>e.g.<ul><li>PoW(Proof of Work) 算力证明机制</li><li>PoS(Proof of Stake) 权益证明机制</li><li>DPoS(Delegated Proof of Stake) 股份授权证明机制</li><li>PBFT(Practical Byzantine Fault Tolerance)拜占庭容错算法</li></ul></li></ul></li><li>智能合约<ul><li>智能合约是<strong>运行在链上并可针对区块链数据库进行读写操作的代码</strong>，可以自动执行参与方指定的数字契约</li><li>特点:<ul><li>无须中介，满足合约条件即可自动执行与验证计算机协议</li><li>最小化意外或恶意情况的发生</li><li>最小化信任中介职能</li><li>降低仲裁以及强制执行的成本</li><li>降低违约带来的损失</li></ul></li><li><figure><img src="image-123.webp" srcset="/img/loading/loading3.gif" lazyload alt="智能合约模型"><figcaption aria-hidden="true">智能合约模型</figcaption></figure></li></ul></li><li>区块链主要类型<ul><li><strong>公有链</strong><ul><li>自由加入和退出(比特币、以太坊等)</li></ul></li><li><strong>联盟链</strong><ul><li>通过授权加入和退出(Hyperledger、R3)</li></ul></li><li><strong>私有链</strong><ul><li>私有机构单中心网络</li></ul></li></ul></li><li>区块链的安全<ul><li><strong>51%算力攻击</strong>：当攻击者掌握了超过全网50%的算力，就很容易阻止其他节点确认交易，也可以逆转当前区块已经完成的交易，并在网络中双花电子货币。2018年，Zencash、Verge、EthereumClassic就受到了51%攻击</li><li><strong>攻击交易所</strong>：加密货币交易所拥有大量的加密货币，若安全防范措施不到位，成为黑客们关注的目标。当前对交易所的攻击频发，数字货币被窃时有发生</li><li><strong>软件漏洞</strong>：2018年钱包和去中心化APP的软件bug导致了超过2400万美元的损失。需要完备的代码审计、渗透测试和智能合约监控</li><li><strong>隐私泄露</strong>：公有链数据可以公开获取，通过大数据关联分析，可能对特定用户去标识化，从而泄露用户隐私信息。</li></ul></li><li>区块链的安全事件<!-- - 零时科技 联合多家媒体共同发布《2019年度区块链十大安全事件》：51%算力攻击  - 2019年3月29日，韩国知名数字货币交易所Bithumb疑似遭到黑客攻击，黑客窃取了价值1000万多美元的EOS和价值600万多美元的XRP；  - 2019年3月24日，新加坡DragonEx交易所遭到黑客入侵，被盗价值600余万元的数字货币，黑客使用含有0day的软件进行钓鱼攻击。  - 2019年5月7日，知名数字货币交易所发出公告称，黑客从币安热钱包中盗取了7000枚比特币，价值数千万美元。 --></li></ul></li><li><strong>人工智能</strong><ul><li>主要技术领域<ul><li>自然语言处理<ul><li>通过计算机对自然语言的分析，对词法、句法、语法和语义进行理解分析，实现人机信息交流</li></ul></li><li>计算机视觉<ul><li>让计算机具备理解图像表示内容、图像中物体存在的关系等能力。如文字识别、图像处理、图像识别</li></ul></li><li>数据挖掘<ul><li>从数据中提取出具有潜在价值的信息和知识。如用户精准画像，智能推荐等</li></ul></li><li>深度学习<ul><li>通过建立模拟人脑分析学习的神经网络对数据进行解释。常见的深度学习模型：卷积神经网络(CNN)、循环神经网络(RNN)、对抗生成网络(GAN)和强化学习(RL)等</li></ul></li></ul></li><li>安全问题<ul><li>对抗样本<ul><li>对待预测样本添加特定很小的扰动或者进行细微的修改，使模型对于该样本判断出错，“熊猫”图像添加少量噪声后就会被识别为长臂猿，且可信度为99.3%</li></ul></li><li>模型萃取<ul><li>通过构造请求向目标服务发起查询，取得目标模型参数或者构造出与目标模型功能相似可替代的模型</li></ul></li><li>投毒攻击<ul><li>在模型训练过程中修改训练数据集或者投放精心构造的恶意样例，来使训练数据中毒或者被污染，从而干扰机器学习模型的训练过程，降低最终得到模型的判断准确性</li></ul></li><li>训练数据窃取<ul><li>攻击模型训练集，获得训练数据集的具体样本及统计分布，或者判断某条数据是否在该训练数据集中</li></ul></li></ul></li><li>人工智能与网络空间安全的影响<ul><li>复杂性挑战：<ul><li>复杂的技术构成和应用场景势必会产生新的安全漏洞</li></ul></li><li>网络犯罪<ul><li>伪造语音、图片、视频，生成虚假内容，识别验证码</li></ul></li><li>隐私保护侵犯<ul><li>收集、识别个人隐私，精准画像</li></ul></li><li>不确定性风险<ul><li>人工智能不可控，产生意外损害</li></ul></li><li>智能网络攻防<ul><li>自动化的网络攻防</li></ul></li><li>人工智能伦理<ul><li>人工智能与人类的关系，是否会取代人类</li></ul></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 信安 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 网安法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蜀地行吟</title>
      <link href="/_posts/%E8%9C%80%E5%9C%B0%E8%A1%8C%E5%90%9F/"/>
      <url>/_posts/%E8%9C%80%E5%9C%B0%E8%A1%8C%E5%90%9F/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_01.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_02.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_03.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_04.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_05.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_06.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_07.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_08.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_09.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_10.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_11.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_12.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_13.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_14.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_15.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_16.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_17.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_18.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./蜀地行吟_19.webp&quot;);" viewBox="0 0 1000 1647"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Notes</title>
      <link href="/_posts/Git-Notes/"/>
      <url>/_posts/Git-Notes/</url>
      
        <content type="html"><![CDATA[<h1 id="git-notes">Git Notes</h1><p>为什么我会写这篇博客，自然是因为偶尔会想不起来某些Git命令，又不想每次都上网查。对于一个在进入大学前完全没接触过代码、直到大一结束才第一次接触Git和Linux的人，这看起来似乎情有可原。但是！为了以防今后某些不正确的操作将自己的仓库甚至整个项目搞得一团糟，还是把我容易搞混的Git命令记录下来吧！</p><h1 id="修改-添加到暂存区-提交-推送的状态转换">修改-添加到暂存区-提交-推送的状态转换</h1><h2 id="状态表示">状态表示</h2><ul><li>设状态0为初始状态</li><li>工作区文件修改后为状态1</li><li>执行add将工作区修改添加到暂存区后为状态2</li><li>执行commit将暂存区的修改提交到本地仓库后为状态3</li><li>执行push将本地仓库的修改推送到远程仓库后为状态4</li></ul><h2 id="状态转换">状态转换</h2><p>状态转换图如下： <img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="状态转换图"></p><h2 id="各状态转换指令">各状态转换指令</h2><ol type="1"><li><p><strong><code>1-&gt;0</code>（修改后回到初始状态，不保留修改）</strong></p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">checkout</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.</span></span></code></pre></div></div></figure>此命令会用最近一次提交的版本覆盖工作区的所有文件，从而丢弃工作区的修改，回到初始状态。<p></p></li><li><p><strong><code>2-&gt;0</code>（已 <code>add</code>后回到初始状态，不保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--hard</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD</span></span></code></pre></div></div></figure><code>git reset --hard</code> 会将暂存区和工作区都重置为<code>HEAD</code>指向的提交版本，即丢弃暂存区和工作区的修改，回到初始状态。<p></p></li><li><p><strong><code>3-&gt;0</code>（已 <code>commit</code>后回到初始状态，不保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--hard</span><span style="color: #ABB2BF"> [初始提交的哈希值]</span></span></code></pre></div></div></figure> 你需要先使用<code>git log</code> 命令找到初始提交的哈希值，然后使用<code>git reset --hard</code>命令将当前分支重置到该提交，丢弃所有后续的提交和修改。<p></p></li><li><p><strong><code>4-&gt;0</code>（已 <code>push</code>后回到初始状态，不保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 本地操作</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--hard</span><span style="color: #ABB2BF"> [初始提交的哈希值]</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 强制推送到远程仓库</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [分支名]</span></span></code></pre></div></div></figure> 先在本地使用<code>git reset --hard</code> 回到初始提交，然后使用<code>git push -f</code>强制将本地的修改推送到远程仓库，覆盖远程仓库的历史记录。<p></p></li><li><p><strong><code>2-&gt;1</code>（已 <code>add</code>后回到修改后状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.</span></span></code></pre></div></div></figure>该命令会将暂存区的所有文件撤回到工作区，保留工作区的修改。<p></p></li><li><p><strong><code>3-&gt;1</code>（已 <code>commit</code>后回到修改后状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--mixed</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span></code></pre></div></div></figure><code>git reset --mixed HEAD~1</code>会撤销上一次提交，将提交的内容放回暂存区，同时保留工作区的修改。<p></p></li><li><p><strong><code>4-&gt;1</code>（已 <code>push</code>后回到修改后状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 本地操作</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--mixed</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 撤销远程仓库的推送</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [分支名]</span></span></code></pre></div></div></figure> 先在本地使用<code>git reset --mixed HEAD~1</code>撤销上一次提交并将内容放回暂存区，然后使用 <code>git push -f</code>强制推送到远程仓库，撤销远程仓库的推送。<p></p></li><li><p><strong><code>3-&gt;2</code>（已 <code>commit</code> 后回到已<code>add</code> 状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--soft</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span></code></pre></div></div></figure> 同样使用<code>git reset --soft HEAD~1</code>撤销上一次提交，将提交的内容放回暂存区。<p></p></li><li><p><strong><code>4-&gt;2</code>（已 <code>push</code> 后回到已<code>add</code> 状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 本地操作</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--soft</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 撤销远程仓库的推送</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [分支名]</span></span></code></pre></div></div></figure> 与<code>4-&gt;1</code>类似，先在本地撤销提交并将内容放回暂存区，然后强制推送到远程仓库撤销推送。<p></p></li><li><p><strong><code>4-&gt;3</code>（已 <code>push</code> 后回到已<code>commit</code> 状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 本地回退到上一个提交</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--hard</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 强制推送到远程仓库</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [分支名]</span></span></code></pre></div></div></figure> 先在本地使用<code>git reset --hard HEAD~1</code> 回退到上一个提交，然后使用<code>git push -f</code>强制推送到远程仓库，使远程仓库也回到上一个提交状态。<p></p></li></ol><h2 id="总结">总结</h2><table><thead><tr><th>状态转换</th><th>指令</th></tr></thead><tbody><tr><td>1-&gt;0</td><td><code>git checkout -- .</code></td></tr><tr><td>2-&gt;0</td><td><code>git reset --hard HEAD</code></td></tr><tr><td>3-&gt;0</td><td><code>git reset --hard [初始提交的哈希值]</code></td></tr><tr><td>4-&gt;0</td><td><code>git reset --hard [初始提交的哈希值]</code> &amp;&amp;<code>git push -f origin [分支名]</code></td></tr><tr><td>2-&gt;1</td><td><code>git reset HEAD .</code></td></tr><tr><td>3-&gt;1</td><td><code>git reset --mixed HEAD~1</code></td></tr><tr><td>4-&gt;1</td><td><code>git reset --mixed HEAD~1</code> AND<code>git push -f origin [分支名]</code></td></tr><tr><td>3-&gt;2</td><td><code>git reset --soft HEAD~1</code></td></tr><tr><td>4-&gt;2</td><td><code>git reset --soft HEAD~1</code> AND<code>git push -f origin [分支名]</code></td></tr><tr><td>4-&gt;3</td><td><code>git reset --hard HEAD~1</code> AND<code>git push -f origin [分支名]</code></td></tr></tbody></table><h1 id="取消跟踪">取消跟踪</h1><p>要停止跟踪已推送到远程仓库的文件，同时保留本地文件并从远程仓库删除它们，可以按照以下步骤操作：</p><ol type="1"><li><strong>确认 <code>.gitignore</code> 文件配置</strong><br>确保 <code>.gitignore</code>文件中已正确添加要忽略的文件或目录路径。例如： <figure class="shiki text"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf"># .gitignore</span></span><span class="line"><span style="color: #abb2bf">ignore_file.txt</span></span><span class="line"><span style="color: #abb2bf">ignore_dir/</span></span></code></pre></div></div></figure></li><li><strong>停止本地仓库跟踪这些文件</strong><br>使用 <code>git rm --cached</code>命令删除文件的跟踪状态（保留本地文件）： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">rm</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--cached</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">ignore_file.txt</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">rm</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--cached</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-r</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">ignore_dir/</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 递归删除目录</span></span></code></pre></div></div></figure></li><li><strong>提交更改</strong> 将修改后的 <code>.gitignore</code>和文件删除操作提交到本地仓库： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.gitignore</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">commit</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-m</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Stop tracking ignored files"</span></span></code></pre></div></div></figure></li><li><strong>推送到远程仓库</strong><br>将提交推送到远程仓库，同步删除操作： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [branch-name]</span></span></code></pre></div></div></figure></li></ol><h1 id="子模块">子模块</h1><p>子模块是 Git 中的一种机制，用于在一个 Git 仓库中嵌套另一个 Git仓库。它允许你将一个独立的 Git 仓库作为另一个仓库的子目录来管理。 1.子仓库的创建（正常创建） </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">cd</span><span style="color: #ABB2BF"> [path_to_submodule]</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">init</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">remote</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [submodule-repository-url]</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-u</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">master</span></span></code></pre></div></div></figure> 2. 在主仓库中添加子模块<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">submodule</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> [repository-url] [path-to-submodule]</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.gitmodules</span><span style="color: #ABB2BF"> [path-to-submodule]</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">commit</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-m</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Add submodule"</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span></span></code></pre></div></div></figure><p></p><h1 id="修改commit信息">修改commit信息</h1><ol type="1"><li>要修改最近一次提交的 commit 信息，可以使用以下命令：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">commit</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--amend</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-m</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"New commit message"</span></span></code></pre></div></div></figure></li><li>如果需要修改更早的提交，可以使用 <code>rebase</code> 命令：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">rebase</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-i</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~n</span></span></code></pre></div></div></figure> 在编辑器中，将需要修改的提交前的 <code>pick</code> 改为<code>reword</code>，然后保存并退出编辑器。接下来，Git会提示修改提交信息，修改后保存并退出编辑器即可。</li><li>如果需要修改远程仓库中的提交信息，可以使用 <code>push</code>命令强制推送： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [branch-name]</span></span></code></pre></div></div></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日月代序</title>
      <link href="/_posts/%E6%97%A5%E6%9C%88%E4%BB%A3%E5%BA%8F/"/>
      <url>/_posts/%E6%97%A5%E6%9C%88%E4%BB%A3%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./日月代序_01.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./日月代序_02.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./日月代序_03.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./日月代序_04.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./日月代序_05.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./日月代序_06.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./日月代序_07.webp&quot;);" viewBox="0 0 1000 2000"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./日月代序_08.webp&quot;);" viewBox="0 0 1000 1992"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>习近平新时代中国特色社会主义思想概论</title>
      <link href="/_posts/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3%E6%A6%82%E8%AE%BA/"/>
      <url>/_posts/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>魏旭老师</em> 2023-2024学年春季学期教学内容进行整理</p></blockquote><h1 id="导论-马克思主义中国化时代化新的飞跃">导论马克思主义中国化时代化新的飞跃</h1><h2 id="习近平新时代中国特色社会主义思想是如何创立的">※习近平新时代中国特色社会主义思想是如何创立的</h2><ol type="1"><li><strong>时代背景</strong>：“两个大局”同步交织、相互激荡<ul><li>“两个大局”：世界百年未有之大变局、实现中华民族伟大复兴战略全局</li><li>习近平新时代中国特色社会主义思想正是在中华民族伟大复兴进入关键时期创立并不断丰富发展的，正是在把握世界发展大势、应对全球共同挑战、维护人类共同利益的过程中创立并不断丰富发展的，正是在不断回答中国之问、世界之问、人民之问、时代之问的过程中创立并不断丰富发展的。</li></ul></li><li><strong>历史方位</strong>：中国特色社会主义进入新时代<ul><li>基本依据：社会主要矛盾变化——我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</li><li>中国特色社会主义进入新时代，这是一个需要理论而且一定能够产生理论的时代，是一个需要思想而且一定能够产生思想的时代。习近平新时代中国特色社会主义思想正是在这样的伟大时代中应运而生、顺势而成的。</li></ul></li><li>实践基础:历史性成就、历史性变革<ul><li>习近平新时代中国特色社会主义思想是在新时代的伟大实践中应运而生、顺势而成的。</li></ul></li><li>必由之路：“两个结合”<ul><li>坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合</li><li>习近平新时代中国特色社会主义思想正是在不断推进马克思主义中国化时代化，在坚持马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合中创立并不断丰富发展的。</li></ul></li></ol><h2 id="习近平新时代中国特色社会主义思想主要包含哪些内容">※习近平新时代中国特色社会主义思想主要包含哪些内容</h2><ol type="1"><li>重大时代课题<ul><li>讲的是方向性质问题：新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义</li><li>讲的是目标路径问题：建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国</li><li>讲的是力量保证问题：建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党</li></ul></li><li>基本内容（科学体系：世界观和方法论）<ul><li>“十个明确”</li><li>“十四个坚持”</li><li>“十三个方面成就”</li><li>“六个必须坚持”</li></ul></li></ol><h2 id="如何理解习近平新时代中国特色社会主义思想的历史地位">※如何理解习近平新时代中国特色社会主义思想的历史地位</h2><ol type="1"><li>是当代中国马克思主义、二十一世纪马克思主义<ul><li>这一思想把坚持马克思主义和发展马克思主义统一起来，对马克思主义作出了许多原创性贡献，开辟了马克思主义中国化时代化新境界。</li></ul></li><li>是中华文化和中国精神的时代精华<ul><li>这一思想汲取中华优秀传统文化所蕴含的丰富哲学思想、人文精神、道德理念和政治智慧，有效激活了中华优秀传统文化的生命力，实现了中华优秀传统文化的创造性转化、创新性发展。</li></ul></li><li>是马克思主义中国化时代化新的飞跃<ul><li>这一思想深刻总结并充分运用党成立以来的历史经验，从新的实际出发，提出了一系列原创性的治国理政新理念新思想新战略，以全新的视野深化了对共产党执政规律、社会主义建设规律、人类社会发展规律的认识，实现了马克思主义中国化时代化新的飞跃。</li></ul></li></ol><h2 id="两个确立">两个确立</h2><ol type="1"><li>确立习近平同志党中央的核心、全党的核心地位</li><li>确立习近平新时代中国特色社会主义思想的指导地位</li></ol><p>“两个确立”是推动新时代党和国家事业取得历史性成就、发生历史性变革的根本原因，是实现新时代新征程各项目标任务的根本保证。</p><h2 id="如何学好用好习近平新时代中国特色社会主义思想">※如何学好用好习近平新时代中国特色社会主义思想</h2><ol type="1"><li>坚定理想信念<ul><li>学习习近平新时代中国特色社会主义思想，就是要深刻领会这一思想的真理力量和实践伟力，坚定对马克思主义的信仰、对中国特色社会主义的信念、对实现中华民族伟大复兴中国梦的信心。</li></ul></li><li>提高理论水平<ul><li>要把学习本课程与坚持读原著、学原文、悟原理结合起来，同学习马克思主义基本原理贯通起来，同学习党史、新中国史、改革开放史、社会主义发展史、中华民族发展史结合起来。</li></ul></li><li>增强实践能力<ul><li>要密切联系思想实际和学习实际，做到学以致用、学用结合、有的放矢。</li></ul></li></ol><h1 id="第一章-新时代坚持和发展中国特色社会主义">第一章新时代坚持和发展中国特色社会主义</h1><h2 id="中国特色社会主义如何一路走来">中国特色社会主义如何一路走来</h2><ol type="1"><li>道路决定命运<ul><li>走自己的路，是党的全部理论和实践立足点，更是党百年奋斗得出的历史结论。</li></ul></li><li>近代以来中国社会发展的必然选择<ul><li>中国共产党在革命、建设、改革各个历史时期，都探索并形成了符合中国实际的道路。</li></ul></li></ol><h2 id="如何理解中国特色社会主义是社会主义而不是其他什么主义">如何理解中国特色社会主义是社会主义而不是其他什么主义</h2><ol type="1"><li>坚持了科学社会主义基本原则<ul><li>科学社会主义基本原则为中国特色社会主义奠定了思想前提和理论基础</li></ul></li><li>赋予科学社会主义鲜明中国特色<ul><li>中国特色社会主义写出了科学社会主义的“中国特色”</li></ul></li></ol><h2 id="为什么说中国特色社会主义进入了新时代">※为什么说中国特色社会主义进入了新时代</h2><ol type="1"><li><strong>基本依据</strong>：社会主要矛盾的转化<ul><li>人类社会是在矛盾运动中不断向前发展的。社会主要矛盾是各种社会矛盾的主要根源和集中反映，在社会矛盾运动中居于主导地位。</li></ul></li><li>社会主要矛盾变化是关系全局的历史性变化<ul><li>主要矛盾的变化，反映了社会发展的客观实际——需求侧和供给侧的问题</li></ul></li><li>社会主要矛盾变化没有改变我国社会主义初级阶段的基本国情<ul><li>我国社会主要矛盾的变化，是在社会主义初级阶段中发生的变化，没有改变我们对我国社会主义所处历史阶段的判断。</li><li>“一个变”和“两个没有变”：社会主要矛盾变化，我国仍处于并将长期处于社会主义初级阶段的基本国情没有变，我国是世界上最大发展中国家的地位没有变。</li></ul></li></ol><h2 id="新时代坚持和发展中国特色社会主义如何一以贯之">新时代坚持和发展中国特色社会主义如何一以贯之</h2><ol type="1"><li>更加自觉地坚定“四个自信”<ul><li>改革开放以来，我们取得一切成绩和进步的根本原因，归结起来就是：开辟了中国特色社会主义道路，形成了中国特色社会主义理论，确立了中国特色社会主义制度，发展了中国特色社会主义文化。</li></ul></li><li>全面贯彻党的基本理论、基本路线、基本方略</li><li>统筹推进“五位一体”总体布局和协调推进“四个全面”战略布局<ul><li>经济建设是中心；政治建设是保障；文化建设是灵魂；社会建设是条件；生态文明建设是基础</li><li>党的十八届三中、四中、五中、六中全会相继提出全面深化改革、全面依法治国、全面建成小康社会、全面从严治党。决胜全面建成小康社会后，提出全面建设社会主义现代化国家。</li></ul></li></ol><h1 id="第二章-以中国式现代化全面推进中华民族伟大复兴">第二章以中国式现代化全面推进中华民族伟大复兴</h1><h2 id="为什么说实现中华民族伟大复兴进入了不可逆转的历史进程">为什么说实现中华民族伟大复兴进入了不可逆转的历史进程</h2><ol type="1"><li>实现中华民族伟大复兴是中华民族近代以来最伟大的梦想<ul><li>中国梦的本质是<strong>国家富强、民族振兴、人民幸福</strong>。</li></ul></li><li>实现中华民族伟大复兴是党百年奋斗的主题</li><li>中华民族伟大复兴展现出前所未有的光明前景<ul><li>1921-1949实现了中国从几千年封建专制政治向人民民主的伟大飞跃，中国人民从此站起来了</li><li>1949-1978实现了一穷二白、人口众多的东方大国大步迈进社会主义社会的伟大飞跃</li><li>1978-2012推进了中华民族从站起来到富起来的伟大飞跃，中国大踏步赶上了时代</li><li>2012— 中华民族迎来了从站起来、富起来到强起来的伟大飞跃</li></ul></li><li>实现中华民族伟大复兴的艰巨性、复杂性和长期性<ul><li>形势环境变化之快；改革发展稳定任务之重；矛盾风险挑战之多；治国理政考验之大</li></ul></li></ol><h2 id="如何擘画全面建成社会主义现代化强国的宏伟蓝图">如何擘画全面建成社会主义现代化强国的宏伟蓝图</h2><ol type="1"><li>全面建成小康社会<ul><li>全面建成小康社会是实现中华民族伟大复兴中国梦的关键一步。</li><li>为了实现中国梦，我们确立了“两个一百年”奋斗目标，就是到2020年实现国内生产总值和城乡居民人均收入比2010年翻一番，全面建成小康社会；到本世纪中叶建成富强民主文明和谐美丽的社会主义现代化国家，实现中华民族伟大复兴。</li></ul></li><li>全面建成社会主义现代化强国<ul><li>建成社会主义现代化强国的战略安排（党的二十大）：<ul><li>第一步 从2020年到2035年基本实现社会主义现代化；</li><li>第二步从2035年到本世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化国家。</li></ul></li></ul></li><li>中国式现代化是强国建设、民族复兴的康庄大道</li></ol><h2 id="中国式现代化是一种什么样的现代化">※中国式现代化是一种什么样的现代化</h2><ol type="1"><li>中国式现代化的中国特色<ul><li>中国式现代化，是中国共产党领导的社会主义现代化，既有各国现代化的共同特征，更有基于自己国情的中国特色。</li><li><strong>人口规模巨大的现代化</strong>：是中国式现代化的显著特征。</li><li><strong>全体人民共同富裕的现代化</strong>：是中国式现代化的本质特征，也是区别于西方现代化的显著标志。</li><li><strong>物质文明和精神文明相协调的现代化</strong>：</li><li><strong>人与自然和谐共生的现代化</strong>：是中国式现代化的鲜明特点</li><li><strong>走和平发展道路的现代化</strong>：是中国式现代化的突出特征。</li></ul></li><li><strong>中国式现代化的本质要求</strong><ul><li>坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</li><li>中国式现代化是中国共产党领导的社会主义现代化。这是对中国式现代化定性的话，是管总、管根本的。</li></ul></li><li>中国式现代化创造了人类文明新形态<ul><li>中国式现代化，打破了“现代化=西方化”的迷思，展现了不同于西方现代化的新图景。中国式现代化，提供了一种全新的现代化模式，为广大发展中国家提供了全新选择。</li></ul></li><li>推进中国式现代化需要把握的重大原则<ul><li>坚持和加强党的全面领导</li><li>坚持中国特色社会主义道路</li><li>坚持以人民为中心的发展思想</li><li>坚持深化改革开放</li><li>坚持发扬斗争精神</li></ul></li></ol><h1 id="第三章-坚持党的领导">第三章 坚持党的领导</h1><h2 id="为什么要坚持党的领导">※为什么要坚持党的领导</h2><ol type="1"><li>中国共产党是最高政治领导力量<ul><li>这是由我国国家性质和政治制度体系决定的，是由国家宪法所确立的，是经过中国革命、建设、改革伟大实践所检验的。</li><li>党是最高政治领导力量，主要体现在引领政治方向、统领政治体系、决断重大事项、领导社会治理等方面。</li></ul></li><li>中国共产党领导是中国特色社会主义最本质的特征<ul><li><strong>中国特色社会主义最本质的特征是中国共产党领导</strong></li></ul></li><li><strong>中国共产党领导是中国特色社会主义制度的最大优势</strong><ul><li>中国共产党领导是充分发挥中国特色社会主义制度优势的根本保障</li><li>中国共产党的自身优势是中国特色社会主义制度优势的主要来源</li><li>中国共产党能够集中全党全国力量、凝聚全民族共同意志，在各项事业中发挥总总揽全局、协调各方的作用，确保中国特色社会主义制度的显著优势充分彰显。</li></ul></li></ol><h2 id="怎样理解党的领导是全面的系统的整体的">怎样理解党的领导是全面的、系统的、整体的</h2><ol type="1"><li>党的领导是全面的<ul><li>领导对象要全面覆盖；领导内容要全面；领导过程要全面；领导方法要全面</li></ul></li><li>党的领导是系统的<ul><li>党的领导制度是我国的根本领导制度，居于统领地位。</li></ul></li><li>党的领导是整体的<ul><li>从党的中央组织到地方组织再到基层组织，都要按照党章的规定发挥应有作用，党的领导作用要体现到治国理政的全过程，领导功能的发挥要完整。</li></ul></li></ol><h2 id="怎样实现党的全面领导">怎样实现党的全面领导</h2><ol type="1"><li>自觉在思想上政治上行动上同党中央保持高度一致<ul><li>从思想上正本清源、固本培元，不断提高政治判断力、政治领悟力、政治执行力，增强“四个意识”、坚定“四个自信”、做到“两个维护”，始终在思想上政治上行动上同党中央保持高度一致征。</li><li>“<strong>四个意识</strong>”：政治意识、大局意识、核心意识、看齐意识</li><li>“<strong>两个维护</strong>”：<ul><li>坚决维护习近平总书记党中央的核心、全党的核心地位；</li><li>坚决维护党中央权威和集中统一领导（这是党的领导的最高原则）。</li></ul></li></ul></li><li>健全和完善党的领导制度体系<ul><li>健全党中央对重大工作的领导体制</li><li>健全党的全面领导制度</li></ul></li></ol><h1 id="第四章-坚持以人民为中心">第四章 坚持以人民为中心</h1><h2 id="为什么必须坚持以人民为中心">为什么必须坚持以人民为中心</h2><ol type="1"><li>人民是创造历史的动力<ul><li>人民是历史的创造者，是真正的影响</li><li>党的历史伟业是人民创造的</li></ul></li><li>江山就是人民、人民就是江山<ul><li>我国的政权是人民的政权</li></ul></li><li>党依靠人民创造历史伟业<ul><li>党依靠人民夺取新民主主义革命伟大胜利</li><li>党依靠人民完成社会主义革命和推进社会主义建设</li><li>党依靠人民进行改革开放和社会主义现代化建设</li><li>党依靠人民开创中国特色社会主义新时代</li></ul></li><li>人民是党的工作的最高裁决者和最终评判者</li></ol><h2 id="如何理解不断实现人民对美好生活的向往">如何理解不断实现人民对美好生活的向往</h2><ol type="1"><li>人民立场是中国共产党的根本政治立场<ul><li>人民立场是马克思主义政党区别于资产阶级政党的显著标志</li><li>全心全意为人民服务是党的根本宗旨</li><li>党性和人民性是高度一致的</li></ul></li><li>为中国人民谋幸福是中国共产党的初心<ul><li>为中华民族谋复兴（使命）、为中国人民谋幸福（初心），是中国共产党的初心使命</li></ul></li><li>人民对美好生活的向往就是党的奋斗目标<ul><li>人民对美好生活的新期待：进入新时代，人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长。</li></ul></li></ol><h2 id="怎样实现人的全面发展全体人民共同富裕">※怎样实现人的全面发展、全体人民共同富裕</h2><ol type="1"><li>坚持和贯彻党的群众路线<ul><li>党的群众路线：坚持一切为了群众，一切依靠群众，从群众中来，到群众中去</li><li>群众路线始终是党的生命线和根本工作路线</li><li>调查研究是贯彻群众路线的有效途径</li></ul></li><li>把为人民造福的事情真正办好办实<ul><li>为人民造福，要落实到新时代中国特色社会主义的各项事业、全部工作之中</li><li>为人民造福，要着力解决好人民群众最关心最直接最现实的利益问题</li><li>为人民造福，要一件事情接着一件事办，一年接着一年干。</li></ul></li><li>推动全体人民共同富裕取得更为明显的实质性进展<ul><li>共同富裕是社会主义的本质要求，是中国式现代化的重要特征。我们说的共同富裕是全体人民共同富裕，是人民群众物质生活和精神生活都富裕，不是少数人的富裕，也不是整齐划一的平均主义。要处理好先富和共富的关系，允许一部分人先富起来，同时积极推动先富带后富。</li><li>扎实推动共同富裕的总体思路:坚持以人民为中心的发展思想，在高质量发展中促进共同富裕，正确处理效率和公平的关系，构建初次分配、再分配、三次分配协调配套的基础性制度安排，加大税收、社保、转移支付等调节力度并提高精准性，扩大中等收入群体比重，增加低收入群体收入，合理调节高收入，取缔非法收入，形成中间大、两头小的橄榄型分配结构，促进社会公平正义，促进人的全面发展，使全体人民朝着共同富裕目标扎实迈进。</li><li>扎实推进共同富裕的基本原则：鼓励勤劳创新致富；坚持基本经济制度；尽力而为量力而行；坚持循序渐进</li></ul></li></ol><h1 id="第五章-全面深化改革开放">第五章 全面深化改革开放</h1><h2 id="为什么要全面深化改革开放">为什么要全面深化改革开放</h2><ol type="1"><li>改革开放是我们前进的重要法宝<ul><li>中国共产党作出实行改革开放的历史性决策，是基于对党和国家前途命运的深刻把握、基于对社会主义革命和建设实践的深刻总结、基于对时代潮流的深刻洞察、基于对人民群众期盼和需要的深刻体悟。</li></ul></li><li>改革进入攻坚期和深水区<ul><li>必须勇于破除一切不合时宜的思维定势和固有观念</li><li>必须勇于打破部门利益、行业利益、本位思想</li><li>必须勇于跳出条条框框限制，破除深层次体制机制障碍和顽瘴痼疾</li><li>必须勇于破解我国开放型经济体制建设中的突出问题，积极适应经济全球化新趋势、世界格局新变化和我国发展新要求</li></ul></li></ol><h2 id="怎样推进全面深化改革开放">※怎样推进全面深化改革开放</h2><ol type="1"><li>坚持全面深化改革总目标<ul><li><strong>完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化</strong><ul><li>前者规定了改革的方向，后者明确了改革的鲜明指向和时代要求</li></ul></li><li>全面深化改革分目标：“六个紧紧围绕着”，规定了各领域各方面改革的主要任务</li></ul></li><li>推进国家治理体系和治理能力现代化<ul><li>新时代全面深化改革开放，就是要使中国特色社会主义制度更加成熟更加定型，推进国家治理体系和治理能力现代化。</li><li>国家治理体系和治理能力是一个国家制度和制度执行能力的集中体现；</li><li>推进国家治理体系和治理能力现代化，必须坚定中国特色社会主义制度自信；</li><li>推进国家治理体系和治理能力现代化，必须把中国特色社会主义制度优势转化为治理效能</li></ul></li><li>全面深化改革开放要坚持正确方法论<ul><li>增强全面深化改革的系统性、整体性、协同性</li><li>加强顶层设计和摸着石头过河相结合</li><li>统筹改革发展稳定。改革是经济社会发展的强大动力；发展是解决一切经济社会问题的关键；稳定是改革发展的前提</li><li>胆子要大，步子要稳。</li><li>坚持重大改革于法有据。（改革和法治如鸟之两翼、车之两轮、相辅相成）</li></ul></li></ol><h2 id="如何将改革开放进行到底">如何将改革开放进行到底</h2><ol type="1"><li>改革开放永无止境<ul><li>生产力发展是永无止境的，调整生产关系、完善上层建筑的改革开放的改革也是永无止境的</li><li>改革开放永无止境是总结世界社会主义实践经验得出的重要结论</li><li>改革开放永无止境是推进党和人民事业发展的必然要求</li></ul></li><li>坚定不移把全面深化改革引向深入<ul><li>围绕中心任务；把准改革方向；围绕目标</li><li>要聚焦全面建设社会主义现代化国家中的重大问题，抓好重大改革任务攻坚克难</li></ul></li><li>坚定不移扩大高水平对外开放<ul><li>开放合作仍然是历史潮流</li><li>继续扩大对外开放，构建更高水平开放型经济新体制</li></ul></li></ol><h1 id="第六章-推动高质量发展">第六章 推动高质量发展</h1><h2 id="如何完整准确全面贯彻新发展理念">※如何完整、准确、全面贯彻新发展理念</h2><ol type="1"><li>进入新发展阶段是中华民族伟大复兴历史进程的大跨越<ul><li><strong>新发展阶段就是全面建设社会主义现代化国家、向第二个百年奋斗目标进军的阶段。</strong></li><li>我国进入新发展阶段的基本依据：<ul><li>理论依据：马克思主义是远大理想和现实目标相结合、历史必然性和发展阶段性相统一的统一论者，我们坚信人类社会必然走向共产主义，但实现这一崇高目标必然经历若干历史阶段。</li><li>历史依据：新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段。</li><li>现实依据：我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础。</li></ul></li><li><strong>新发展阶段，是社会主义初级阶段中的一个阶段，是全面建设社会主义现代化国家的阶段</strong></li></ul></li><li>贯彻新发展理念是关系我国发展全局的一场深刻变革<ul><li>新发展理念是新时代我国经济发展的指导原则，回答了关于发展的目的、动力、方式、路径等一系列理论和实践问题，阐明了我们党关于发展的政治立场、价值导向、发展模式、发展道路等重大政治问题。</li><li>创新注重解决发展动力问题；协调注重解决发展不平衡问题；绿色注重解决人与自然和谐共生问题；开放注重解决发展内外联动问题；共享注重解决社会公平正义问题</li><li>为人民谋幸福、为民族谋复兴，这既是我们党领导现代化建设的出发点和落脚点，也是新发展理念的“根”和“魂”。</li></ul></li><li>以新发展理念引领高质量发展<ul><li>高质量发展：是从“有没有”转向“好不好”；是能够很好满足人民日益增长的美好生活需要的发展；是体现新发展理念的发展。</li><li>高质量发展是全面建设社会主义现代化国家的首要任务</li><li>推动高质量发展的必要性：推动高质量发展是保持经济持续健康发展的必然要求；推动高质量发展是适应我国社会主要矛盾变化的必然要求；推动高质量发展是遵循经济发展规律的必然要求</li></ul></li></ol><h2 id="如何坚持和完善社会主义基本经济制度">如何坚持和完善社会主义基本经济制度</h2><ol type="1"><li>坚持和完善社会主义基本经济制度是实现高质量发展的保障</li><li>坚持“两个毫不动摇”<ul><li>毫不动摇巩固和发展公有制经济；毫不动摇鼓励、支持、引导非公有制经济发展</li></ul></li><li>坚持按劳分配为主体、多种分配方式并存<ul><li>按劳分配为主体、多种分配方式并存，构建初次分配、再分配、第三次分配协调配套的制度体系</li></ul></li><li>构建高水平社会主义市场经济体制<ul><li>关键是要处理好政府和市场的关系</li><li>正确认识和把握资本的特性和行为规律</li></ul></li></ol><h2 id="如何加快构建新发展格局">※如何加快构建新发展格局</h2><ol type="1"><li>把握未来发展主动权的战略性布局<ul><li>加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局</li><li>构建新发展格局的本质特征：实现高水平的自立自强</li></ul></li><li>以国内大循环为主体、国内国际双循环相互促进<ul><li>构建新发展格局涉及我国经济发展的各个方面、各个领域，要准确把握基本要求，加强整体协调和系统布局，推动国内循环和国际循环相互促进、良性互动。</li><li>加快构建新发展格局，要从两个维度来研究和布局：一是更有针对性地加快补上我国产业链供应链短板弱项，确保国民经济循环畅通；二是提升国内大循环内生动力和可靠性，提高国际竞争力，增强对国际循环的吸引力、推动力。</li></ul></li><li>大力推动构建新发展格局<ul><li>增强供给侧结构对需求变化的适应性、灵活性（供给侧重在解决结构性问题；需求侧重在解决总量性问题）</li><li>把握扩大内需战略基点：加快培育完整内需体系</li></ul></li></ol><h1 id="第七章-社会主义现代化建设的教育科技人才战略">第七章社会主义现代化建设的教育、科技、人才战略</h1><h2 id="为什么要坚持教育科技人才一体推进">为什么要坚持教育、科技、人才一体推进</h2><ol type="1"><li>高度重视教育、科技、人才是历史的经验</li><li>实施科教兴国战略、人才强国战略、创新驱动发展战略是时代的需要</li><li>坚持教育优先发展、科技自立自强、人才引领驱动是中国式现代化的必然选择<ul><li>教育是全面建设社会主义现代化国家的坚实基础；科技是全面建设社会主义现代化国家的强大动力；人才是全面建设社会主义现代化国家的有力支撑</li></ul></li></ol><h2 id="怎样加快建设教育强国">怎样加快建设教育强国</h2><ol type="1"><li>推进教育现代化</li><li>落实立德树人根本任务</li><li>办好人民满意的教育<ul><li>大力促进教育公平</li><li>必须建设高质量教育体系</li><li>提升教育服务经济社会发展能力</li><li>坚持深化教育改革创新</li><li>坚持把教师队伍建设作为基础工作</li></ul></li></ol><h2 id="怎样加快建设科技强国">※怎样加快建设科技强国</h2><ol type="1"><li>科技强则国家强<ul><li>要大力发展科学技术，加快实现高水平科技自立自强，努力成为世界主要科学中心和创新高地。<br></li></ul></li><li>打赢关键核心技术攻坚战<ul><li>原因：只有把关键核心技术掌握在自己手中，才能从根本上保障国家经济安全、国防安全和其他安全，才能真正掌握竞争和发展的主动权。</li><li>打赢关键核心技术攻坚战，<strong>首要任务是加快实现“卡脖子”关键核心技术突破</strong></li></ul></li><li>增强自主创新能力<ul><li>增强自主创新能力，着力推进基础研究、应用研究、前沿研究</li></ul></li></ol><h2 id="如何深入实施新时代人才强国战略">如何深入实施新时代人才强国战略</h2><ol type="1"><li>人才是国家和民族长远发展大计<ul><li>人才是创新的根基是创新的核心要素</li></ul></li><li>坚持党管人才<ul><li>坚持党对人才工作的全面领导；深化人才发展体制机制改革；全方位培养用好人才</li></ul></li><li>加快建设世界人才中心和创新高地<ul><li>做好顶层设计和战略谋划；走好人才自主培养之路；抓好国家战略人才力量</li></ul></li></ol><h1 id="第八章-发展全过程人民民主">第八章 发展全过程人民民主</h1><h2 id="什么是全过程人民民主">※什么是全过程人民民主</h2><ol type="1"><li><strong>全过程人民民主是社会主义民主政治的本质属性</strong><ul><li>人民当家作主是社会主义民主政治的本质和核心，是发展全过程人民民主的根本出发点和归宿。</li><li>全过程人民民主展现出的过程民主和成果民主、程序民主和实质民主、直接民主和间接民主、人民民主和国家意志相统一的鲜明特征，充分体现了社会主义民主政治的本质属性。</li></ul></li><li>全过程人民民主是全链条、全方位、全覆盖的民主<ul><li>全过程人民民主是民主选举、民主协商、民主决策、民主管理、民主监督各个环节紧密联系、相互贯通、相辅相成的全链条民主；</li><li>全过程人民民主是贯通国家政治生活和社会生活各层面各维度的全方位民主；</li><li>全过程人民民主是涵盖国家各项事业各项工作的全覆盖民主。</li></ul></li></ol><h2 id="全过程人民民主好在哪里">※全过程人民民主好在哪里</h2><ol type="1"><li>全过程人民民主是最广泛的民主<ul><li>全过程人民民主是全体人民共同持续参与，各个民族共同平等享有，不同地域、不同领域、不同层级、不同群体均实现全面覆盖的民主体系，是最广泛的民主。</li></ul></li><li>全过程人民民主是最真实的民主<ul><li>全过程人民民主是真真切切落实到国家政治生活和社会生活各方面、为全体人民真真切切感知和认同的民主体系，是最真实的民主。</li></ul></li><li>全过程人民民主是最管用的民主<ul><li>全过程人民民主体现了社会主义民主的优势，具有显著的实践优越性，是最管用的民主。</li></ul></li></ol><h2 id="如何践行全过程人民民主">如何践行全过程人民民主</h2><ol type="1"><li>坚定不移走中国特色社会主义政治发展道路<ul><li>必须坚持党的领导、人民当家作主、依法治国有机统一；必须积极稳妥推进政治体制改革；必须始终保持政治定力</li></ul></li><li>加强人民当家作主制度保障</li><li>全面发展协商民主</li><li>积极发展基层民主</li><li>巩固和发展新时代爱国统一战线</li></ol><h1 id="第九章-全面依法治国">第九章 全面依法治国</h1><h2 id="为什么要全面推进依法治国">※为什么要全面推进依法治国</h2><ol type="1"><li>法治是社会文明进步的重要标志</li><li>全面依法治国是国家治理现代化的必然要求　<ul><li>全面依法治国是坚持和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化的重要方面。</li><li>全面依法治国是社会主义法治建设的“全面升级版”，是国家治理的一场深刻革命。</li><li>全面依法治国是解决党和国家事业发展面临的重大问题、促进社会公平正义、确保党和国家长治久安的根本要求。</li><li>全面依法治国，既是立足于解决事关我国发展大局的现实考量，也是着眼于长远的战略谋划。</li></ul></li><li>在法治轨道上全面建设社会主义现代化国家<ul><li>要深入贯彻习近平法治思想，坚持党的领导、人民当家作主、依法治国有机统一，更好发挥法治固根本、稳预期、利长远的保障作用，为全面建设社会主义现代化国家保驾护航。</li></ul></li></ol><h2 id="为什么要走中国特色社会主义法治道路">※为什么要走中国特色社会主义法治道路</h2><ol type="1"><li>全面依法治国必须走对路<ul><li>中国特色社会主义法治道路，从根本上保证了我国社会主义法治建设的正确方向，是全面依法治国的唯一正确道路</li></ul></li><li>中国特色社会主义法治道路的核心要义<ul><li>坚持党的领导，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论</li></ul></li><li>走中国特色社会主义法治道路必须坚持的基本原则<ul><li>坚持党的领导是中国特色社会主义法治之魂；坚持人民主体地位；坚持法律面前人人平等；坚持依法治国和以德治国相结合；坚持从中国实际出发</li></ul></li><li>统筹处理全面依法治国的重大关系<ul><li>正确处理政治和法治的关系；正确处理改革和法治的关系；正确处理依法治国和以德治国的关系；正确处理依法治国和依规治党的关系。</li></ul></li></ol><h2 id="如何理解全面依法治国的总目标">如何理解全面依法治国的总目标</h2><ol type="1"><li>全面依法治国的总抓手<ul><li>全面推进依法治国涉及很多方面，在实际工作中必须有一个总揽全局、牵引各方的总抓手，这个总抓手就是建设中国特色社会主义法治体系。依法治国各项工作都要围绕这个总抓手来谋划、来推进。</li></ul></li><li>中国特色社会主义法治体系的基本框架<ul><li>加快形成完备的法律规范体系；加快形成高效的法治实施体系；加快形成严密的法治监督体系；加快形成有力的法治保障体系；加快形成完善的党内法规体系</li></ul></li><li>全面依法治国的总体目标<ul><li>实现法律规范完备统一，执法司法公正高效权威，权力运行收到有效制约监督，人民合法权益得到充分尊重保障，法治信仰普遍确立，法治国家、法治政府、法治社会全面建成。</li></ul></li></ol><h2 id="如何加快建设法治中国1">如何加快建设法治中国1</h2><ol type="1"><li>完善以宪法为核心的中国特色社会主义法律体系</li><li>扎实推进依法行政</li><li>严格公正司法</li><li>加快建设法治社会</li><li>加强法治工作队伍建设</li></ol><h1 id="第十章-建设社会主义文化强国">第十章 建设社会主义文化强国</h1><h2 id="为什么建设中国特色社会主义文化1">为什么建设中国特色社会主义文化1</h2><ol type="1"><li>文化是一个国家、一个民族的灵魂</li><li>没有文化繁荣兴盛就没有中华民族伟大复兴<ul><li>文化繁荣兴盛是实现中华民族伟大复兴的精神支柱；是建设社会主义现代化国家的应有之义；是满足人民日益增长的美好生活需要的内在要求；是在世界文化激荡中站稳脚跟的前提基础。</li></ul></li><li>文化自信是一个国家、一个民族发展中最基本、最深沉、最持久的力量<ul><li>中华优秀传统文化是坚定文化自信的深厚基础；党带领人民在伟大斗争中孕育的革命文化和社会主义先进文化是坚定文化自信的坚强基石；中国特色社会主义伟大实践是坚定文化自信的现实基础。</li></ul></li></ol><h2 id="为什么要坚持马克思主义在意识形态领域指导地位的根本制度">为什么要坚持马克思主义在意识形态领域指导地位的根本制度</h2><ol type="1"><li>意识形态工作是党的一项极端重要的工作</li><li>巩固马克思主义在意识形态领域的指导地位</li><li>不断增强意识形态领域主导权和话语权</li><li>互联网是意识形态斗争的主阵地、主战场、最前沿</li></ol><h2 id="为什么要用社会主义核心价值观凝心聚力">※为什么要用社会主义核心价值观凝心聚力</h2><ol type="1"><li>文化的影响力首先是价值观念的影响力<ul><li>一个国家的文化软实力，从根本上说，取决于其核心价值观的生命力、凝聚力、感召力。世界上各种文化之争，本质上是价值观念之争，也是人心之争、意识形态之争。</li><li>核心价值观，承载着一个民族、一个国家的精神追求，体现着一个社会评判是非曲直的价值标准。</li></ul></li><li>广泛践行社会主义核心价值观<ul><li>社会主义核心价值观集中体现着全体人民共同的价值追求，是凝聚人心、汇聚敏力的强大力量。内容：富强、民主、文明、和谐（国家层面）；自由、平等、公正、法治（社会层面）；爱国、敬业、诚信、友善（个人层面）</li><li>社会主义核心价值观只有成为广泛的社会共识，内化为人们的精神追求，外化为人们的自觉行动，才能真正在社会生活中发挥作用。</li><li>社会主义核心价值观建设，要注重区分层次、突出重点，抓好重点人群。</li></ul></li></ol><h2 id="如何铸就社会主义文化新辉煌">如何铸就社会主义文化新辉煌</h2><ol type="1"><li>推动中华优秀传统文化创造性转化、创新性发展</li><li>用中国特色社会主义文化培根铸魂</li><li>繁荣发展文化事业和文化产业</li><li>不断提升国家文化软实力和中华文化影响力</li></ol><h1 id="第十一章-以保障和改善民生为重点加强社会建设">第十一章以保障和改善民生为重点加强社会建设</h1><h2 id="为什么说悠悠万事民生为大">为什么说“悠悠万事，民生为大”</h2><ol type="1"><li>民生是最大的政治<ul><li>民生事关人民幸福生活；民生事关社会和谐稳定。</li><li>增进民生福祉是马克思主义政党的本质要求；增进民生福祉是社会主义生产的根本目的；增进民生福祉是全面建设社会主义现代化国家的应有之义</li></ul></li><li>人民获得感幸福感安全感更加充实、更有保障、更可持续</li><li>坚持在发展中增进民生福祉<ul><li>正确把握民生和发展的关系：既要发展经济为持续改善民生奠定坚实物质基础，又要持续不断改善民生，为经济发展创造更多有效需求</li><li>坚守底线、突出重点、完善制度、引导预期</li><li>解决人民群众最关心最直接最现实的利益问题</li><li>尽力而为、量力而行</li><li>劳动创造幸福</li></ul></li></ol><h2 id="提高人民生活品质着重从哪些方面入手">提高人民生活品质着重从哪些方面入手</h2><ol type="1"><li>完善分配制度</li><li>实施就业优先战略</li><li>健全社会保障体系</li><li>推进健康中国建设</li></ol><h2 id="怎样推进社会治理现代化">※怎样推进社会治理现代化</h2><ol type="1"><li>加强和创新社会治理<ul><li>社会治理是国家治理的重要领域，推进社会治理现代化是推进国家治理体系和治理能力现代化的重要内容。</li><li>新时代加强社会治理，要坚持<strong>系统治理、综合治理、依法治理、源头治理</strong>。</li></ul></li><li>完善社会治理体系<ul><li>社会治理体系是进行社会治理的基础。</li><li>理念是完善社会治理体系的先导，必须坚持共建共治共享的社会治理理念。<ul><li>共建是共同参与社会建设，突出制度和体系建设在社会治理格局中的基础性、战略性地位，是社会治理的基础；</li><li>共治是共同参与社会治理，要求树立大社会观、大治理观，打造全民参与的开放治理体系，是社会治理的关键；</li><li>共享是共同享有社会治理成果，要求社会治理的成效更多更公平惠及全体人民，是社会治理的目标。</li></ul></li><li>制度是完善社会治理体系的保障</li><li>方式方法是完善社会治理体系的重要内容</li></ul></li><li>加强城乡社区治理<ul><li>健全党组织领导的城乡基层治理体系，实现政府治理和社会调节、居民自洽良性互动</li><li>坚持和发展新时代“枫桥经验”“浦江经验”</li><li>加快推进市域社会治理现代化，提高市域社会治理能力</li></ul></li></ol><h1 id="第十二章-建设社会主义生态文明">第十二章建设社会主义生态文明</h1><h2 id="新时代为什么突出强调生态文明建设">新时代为什么突出强调生态文明建设</h2><ol type="1"><li>顺应人类文明进程<ul><li>人类经历了原始文明、农业文明、工业文明，生态文明是工业文明发展到一定阶段的产物，是实现人与自然和谐发展的新要求。</li></ul></li><li>破解我国经济社会发展短板问题<ul><li>我国资源保障能力较弱制约经济社会可持续发展；环境污染制约人民生活质量和幸福感；我国生态系统依然脆弱制约其服务经济社会发展能力</li></ul></li><li>满足人民日益增长的优美生态环境需要<ul><li>进入新时代，生态环境在群众生活幸福指数中的地位不断凸显，人民对优美生态环境的需要愈益普遍、愈发强烈</li></ul></li><li>应对全球生态环境领域挑战<ul><li>生态环境恶化是当代人类面临的严重全球性问题，需要国际社会共同担当和应对。积极参与气候变化等全球环境治理，不仅能推动国际社会共同构建人与自然命运共同体，展现我国作为负责任发展中大国的担当和影响力，而且可化解全球生态环境问题给中华民族永续发展带来的风险。</li></ul></li></ol><h2 id="建设什么样的生态文明">※建设什么样的生态文明</h2><ol type="1"><li>人与自然和谐共生的现代化<ul><li>人与自然是生命共同体；实现人与自然和谐共生的现代化</li></ul></li><li>绿水青山就是金山银山<ul><li>绿水青山就是金山银山理念，阐明了经济发展与生态环境保护之间的关系。经济发展不能对资源和生态环境竭泽而渔，生态环境保护也不是舍弃经济发展而缘木求鱼，而是在高质量发展中保护、在高水平保护中发展，实现发展和保护的协同共生。</li><li>习近平“两山论”的突出贡献：马克思主义生产力观的新成果</li></ul></li><li>新时代生态文明建设的辉煌成就<ul><li>四个重大转变：方式方法由重点整治到系统治理；观念和责任由被动应对到主动作为；思想和理论由实践探索到科学理论指导；胸怀与格局由全球环境治理参与者到引领者。</li><li>生态文明建设战略地位更加凸显</li><li>生态文明制度体系更加健全</li><li>污染防治和生态保护更加有力</li></ul></li></ol><h2 id="怎样建设美丽中国">※怎样建设美丽中国</h2><ol type="1"><li>加快发展方式绿色转型<ul><li>推动经济社会发展绿色化、低碳化是实现高质量发展的关键环节。</li><li>推动形成绿色低碳的生产方式和生活方式；积极稳妥推进碳达峰碳中和；注重处理好五对关系、落实六项举措；把建设美丽中国转化为全体人民的自觉行动</li></ul></li><li>坚持山水林田湖草沙一体化保护和系统治理<ul><li>深入实施山水林田湖草一体化生态保护和修复，开展大规模国土绿化行动，加快水土流失和荒漠化石漠化综合治理。</li></ul></li><li>用最严格制度最严密法治保护生态环境<ul><li>保护生态环境必须依靠最严格制度最严密法治；生态环境治理的体系化、法治化和效能化；健全落地见效的生态环境监管考核体制</li></ul></li></ol><h2 id="怎样共谋全球生态文明建设之路">怎样共谋全球生态文明建设之路</h2><ol type="1"><li>保护人类共同家园</li><li>共建清洁美丽的世界</li><li>积极推动全球可持续发展</li></ol><h1 id="第十三十五章-实现中华民族伟大复兴的重要保障">第十三~十五章实现中华民族伟大复兴的重要保障</h1><h2 id="构建统筹各领域安全的新安全格局">※构建统筹各领域安全的新安全格局</h2><ol type="1"><li>统筹发展和安全<ul><li>统筹发展和安全，是党和国家的一项基础性工作，是我们党治国理政的一个重大原则。加快构建新安全格局，是以习近平同志为核心的党中央统筹发展和安全、把握国家安全主动权的重大战略部署。</li><li>发展和安全，是一个国家、一个民族生存与进步必须处理好的首要问题。发展解决的是动力问题，是推动国家和民族赓续绵延的根本支撑。安全解决的是保障问题，是确保国家和民族行稳致远的坚强柱石。</li><li>以新安全格局保障新发展格局</li></ul></li><li>把维护政治安全放在首要位置<ul><li>政治安全是国家安全的根本。政治安全涉及国家主权、政权、制度和意识形态的稳固，是一个国家最根本的需求，是一切国家生存和发展的基础条件。维护政治安全，要毫不动摇坚持和巩固党的领导和长期执政地位；毫不动摇坚持和完善中国特色社会主义制度；毫不动摇坚持和巩固马克思主义在意识形态领域的指导地位，不断巩固全党全国人民团结奋斗的共同思想基础。</li></ul></li><li>统筹推进各重点领域国家安全工作<ul><li>维护国土安全——国土安全是立国之基</li><li>维护经济安全——国家安全的基础</li><li>维护社会安全——社会安全与人民群众切身利益关系最密切，是社会安定的风向标。</li><li>维护网络、人工智能、数据安全——成为我国面临的最复杂、最现实、最严峻的非传统安全问题之一</li><li>维护生物安全和公共卫生安全——事关国家安全和发展、事关社会大局稳定的重大风险挑战。</li><li>维护外部安全——任何一个国家的安全问题积累到一定程度，都可能外溢成为区域性甚至全球性安全问题。</li></ul></li></ol><h2 id="实现党在新时代的强军目标">※实现党在新时代的强军目标</h2><ol type="1"><li>建设强大军队是接续奋斗的伟大事业<ul><li>“两个差距很大”和“两个能力不够”</li></ul></li><li>强军目标 的科学内涵<ul><li><strong>党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队</strong>。</li><li><strong>听党指挥是灵魂，能打胜战是核心，作风优良是保证</strong>，三者统一于建设强大人民军队的实践。体现了我们党一以贯之的建军治军指导思想和方针原则，体现了革命化现代化正规化建设相统一的全面建设思想，明确了加强军队建设的聚焦点和着力点。</li></ul></li><li>全面推进国防和军队现代化的战略安排<ul><li>2027年：实现建军一百年奋斗目标</li><li>2035年：基本实现国防和军队现代化</li><li>本世纪中叶：把人民军队全面建成世界一流军队</li></ul></li></ol><h2 id="推进祖国完全统一">※推进祖国完全统一</h2><ol type="1"><li>实现祖国完全统一是中华民族伟大复兴的必然要求<ul><li>实现祖国完全统一是由中华民族伟大复兴的时和势决定的，是不可阻挡的历史潮流。台湾的前途在于国家统一，台湾同胞福祉系于民族复兴。两岸关系和平发展是维护两岸和平、促进两岸共同发展、造福两岸同胞的正确道路。</li></ul></li><li>坚决贯彻新时代党解决台湾问题的总体方略</li><li>坚定不移推进祖国统一大业<ul><li>“和平统一、一国两制”方针是实现两岸统一的最佳方式</li><li>促进两岸经济文化交流合作，深化两岸各领域融合发展</li><li>坚持以最大诚意、尽最大努力争取和平统一的前景</li></ul></li></ol><h1 id="第十六章-中国特色大国外交和推动构建人类命运共同体">第十六章中国特色大国外交和推动构建人类命运共同体</h1><h2 id="世界怎么了">世界怎么了</h2><ol type="1"><li>世界进入新的动荡变革期</li><li>国际力量对比发生深刻变化</li><li>经济全球化遭遇逆流</li><li>国际体系和国际秩序深度调整</li></ol><h2 id="人类向何处去">※人类向何处去</h2><ol type="1"><li>构建人类命运共同体是世界各国人民前途所在<ul><li>人类是一个整体，地球是一个家园构建人类命运共同体是中国共产党审视当今世界发展趋势、针对当今世界发展的重大问题提出的重要理念。</li></ul></li><li>人类命运共同体的提出与内涵<ul><li>内涵：每个民族、每个国家的前途命运都紧紧联系在一起，应该风雨同舟，荣辱与共，努力把我们生于斯、长于斯的这个星球建成一个和睦的大家庭，把世界各国人民对美好生活的向往变成现实。<ul><li>坚持对话协商，建设持久和平的世界；</li><li>坚持共建共享，建设普遍安全的世界；</li><li>坚持合作共赢，建设共同繁荣的世界；</li><li>坚持交流互鉴，建设开放包容的世界；</li><li>坚持绿色低碳，建设清洁美丽的世界</li></ul></li></ul></li><li>弘扬全人类共同价值——人类命运共同体的价值基础<ul><li>和平、发展、公平、正义、民主、自由的全人类共同价值</li></ul></li><li>高质量共建“一带一路” ——人类命运共同体的生动实践</li></ol><h2 id="中国怎么办">中国怎么办</h2><ol type="1"><li>坚持走和平发展道路</li><li>推动建设新型国际关系</li><li>坚决维护国家主权、安全、发展利益</li><li>积极参与全球治理体系改革和建设</li></ol><h1 id="第十七章-中国特色大国外交和推动构建人类命运共同体">第十七章中国特色大国外交和推动构建人类命运共同体</h1><h2 id="为什么要全面从严治党">为什么要全面从严治党</h2><ol type="1"><li>从严治党是马克思主义政党的政治优势</li><li>全面从严治党是实现民族复兴的根本保证</li><li>全面从严治党是决定党兴衰成败的关键因素</li><li>坚定不移全面从严治党</li></ol><h2 id="为什么十八大以来管党治党宽松软状况得到根本扭转">为什么十八大以来管党治党宽松软状况得到根本扭转</h2><ol type="1"><li>把党的政治建设摆在首位</li><li>思想建设是党的基础性建设</li><li>贯彻新时代党的组织路线</li><li>始终绷紧作风建设这根弦</li><li>把纪律的螺丝拧得紧而又紧</li><li>把制度建设贯穿到党的各项建设之中</li><li>坚定不移推进反腐败斗争</li></ol><h2 id="如何理解全面从严治党这场伟大自我革命">※如何理解全面从严治党这场伟大自我革命</h2><ol type="1"><li><strong>党的自我革命是跳出历史周期率的第二个答案</strong></li><li>时刻保持解决大党独有难题的清醒和坚定<ul><li>如何始终不忘初心、牢记使命；如何始终统一思想、统一意志、统一行动；如何始终具备强大的执政能力和领导水平；如何始终保持干事创业精神状态；如何始终能够及时发现和解决自身存在的问题；如何始终保持风清气正的政治生态</li></ul></li><li>以伟大自我革命引领伟大社会革命<ul><li>党的自我革命是伟大社会革命的基础和先导；<strong>伟大社会革命是党的自我革命的根本目的</strong>；党的自我革命和伟大社会革命统一于新时代中国特色社会主义的伟大实践中</li><li><strong>以中央八项规定为切入口的作风建设成为新时代党的自我革命伟大实践的重要标志</strong>，推动管党治党发生格局性变化。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 红课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 习概 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>孟魁老师</em> 2023-2024学年春季学期教学内容进行整理。</p></blockquote><h1 id="引言">引言</h1><h2 id="算法与数据结构">算法与数据结构</h2><ul><li>数据的逻辑结构<ul><li>集合结构</li><li>线性结构</li><li>树形结构</li><li>图形结构</li></ul></li><li>数据结构的运算<ul><li>创建运算（create）</li><li>清除运算（clear）</li><li>插入运算（insert）</li><li>删除运算（delete）</li><li>搜索运算（search）</li><li>更新运算（update）</li><li>访问运算（visit）</li><li>遍历运算（traverse）</li></ul></li></ul><h2 id="存储实现">存储实现</h2><ul><li>物理结构<ul><li>存储结点</li><li>元素关系的存储</li><li>附加信息</li></ul></li><li>存储结点实现方式<ul><li>顺序实现</li><li>链接实现</li><li>散列存储方式/哈希存储</li><li>索引存储方式</li></ul></li></ul><h2 id="算法分析">算法分析</h2><ul><li>时间复杂度<ul><li>最好情况</li><li>最坏情况</li><li>平均情况</li></ul></li><li>渐进表示法：渐进时间复杂度<ul><li>大O表示法</li><li>小o表示法</li><li>Θ表示法</li></ul></li><li>空间复杂度</li></ul><h2 id="面向对象方法">面向对象方法</h2><ol type="1"><li>定义数据结构的需求，即对应的逻辑结构及运算。</li><li>定义数据结构的用户接口，即工具的外形。</li><li>数据结构的实现。</li></ol><h1 id="线性表">线性表</h1><h2 id="线性表的定义">线性表的定义</h2><ul><li>线性结构是 <span class="math inline"><em>n</em>(<em>n</em> ≥ 0)</span> 个数据元素 <span class="math inline">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, …, <em>a</em><sub><em>n</em></sub>)</span>的有限序列，满足以下性质：<ul><li>起始结点：<span class="math inline"><em>a</em><sub>1</sub></span></li><li>结束结点：<span class="math inline"><em>a</em><sub><em>n</em></sub></span></li><li>线性关系：对于任意的 <span class="math inline"><em>i</em>(1 ≤ <em>i</em> &lt; <em>n</em>)</span>，都有<span class="math inline"><em>a</em><sub><em>i</em></sub></span> 和<span class="math inline"><em>a</em><sub><em>i</em> + 1</sub></span>之间的线性关系:<ul><li>直接前驱：<span class="math inline"><em>a</em><sub><em>i</em> − 1</sub></span></li><li>直接后继：<span class="math inline"><em>a</em><sub><em>i</em> + 1</sub></span></li></ul></li></ul></li><li>线性表的抽象类</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#ifndef</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">LIST_H</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">2</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">LIST_H</span><span style="color: #ABB2BF">-2-1</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;iostream&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">list</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">~list</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">length</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">cosnt</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">search</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">visit</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">traverse</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"><span style="color: #C678DD">#endif</span></span></code></pre></div></div></figure><h2 id="线性表的顺序实现">线性表的顺序实现</h2><figure><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="线性表的顺序实现结构"><figcaption aria-hidden="true">线性表的顺序实现结构</figcaption></figure><ul><li>时间复杂度<ul><li>create、clear、update、visit：<span class="math inline"><em>O</em>(1)</span></li><li>insert、delete、search、traverse：<span class="math inline"><em>O</em>(<em>N</em>)</span></li></ul></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"2-1-list.h"</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqList</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">list</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        elemType </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">data;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> currentLength;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> maxSize;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">doubleSpace</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">seqList</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">initSize</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~seqList</span><span style="color: #ABB2BF">() {</span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> data;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">() {currentLength </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">length</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> currentLength;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">search</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">visit</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i];};</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">traverse</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        /*</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        bool isEmpty() const {return currentLength == 0;}</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        bool isFull() const {return currentLength == maxSize;}</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        */</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">seqList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">seqList</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> initSize)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">[initSize];</span></span><span class="line"><span style="color: #ABB2BF">    maxSize </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> initSize;</span></span><span class="line"><span style="color: #ABB2BF">    currentLength </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">traverse</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> currentLength; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">search</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> currentLength; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> x) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">doubleSpace</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    elemType </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> data;</span></span><span class="line"><span style="color: #ABB2BF">    maxSize </span><span style="color: #C678DD">*=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">[maxSize];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> currentLength; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (currentLength </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> maxSize) </span><span style="color: #61AFEF">doubleSpace</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> currentLength; j </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> i; </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">j)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">currentLength;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> currentLength </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">j)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">currentLength;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="线性表的链接实现">线性表的链接实现</h2><h3 id="单链表">单链表</h3><p><img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="线性表的单链表实现结构"> <img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload alt="双链表的插入与删除"></p><ul><li>时间复杂度<ul><li>visit: <span class="math inline"><em>O</em>(<em>N</em>)</span></li><li>insert: <span class="math inline"><em>O</em>(1)</span></li></ul></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"2-1-list.h"</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sLinkList</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">list</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">node</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            elemType data;</span></span><span class="line"><span style="color: #ABB2BF">            node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">next;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">n</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">                next </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> n;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">():</span><span style="color: #61AFEF">next</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {}</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">~node</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"><span style="color: #ABB2BF">        node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">head;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> currentLength;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">sLinkList</span><span style="color: #ABB2BF">() {};</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~sLinkList</span><span style="color: #ABB2BF">() {</span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">(); </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> head;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">length</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> currentLength;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">search</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">visit</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">traverse</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        /*bool isEmpty() const;*/</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">typename</span><span style="color: #ABB2BF"> sLinkList&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #E5C07B">sLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (i</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">sLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">sLinkList</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    head </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> node;</span></span><span class="line"><span style="color: #ABB2BF">    currentLength </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">q;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        q </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    currentLength </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">pos;</span></span><span class="line"><span style="color: #ABB2BF">    pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">currentLength;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">pos, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">delp;</span></span><span class="line"><span style="color: #ABB2BF">    pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    delp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">delp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> delp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">currentLength;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">search</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> x)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">visit</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(i)-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">sLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">traverse</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="双链表">双链表</h3><figure><img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload alt="线性表的双链表实现结构"><figcaption aria-hidden="true">线性表的双链表实现结构</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"2-1-list.h"</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dLinkList</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">list</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">node</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            elemType data;</span></span><span class="line"><span style="color: #ABB2BF">            node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">prev, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">next;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">p</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">n</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">                prev </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">                next </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> n;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">():</span><span style="color: #61AFEF">prev</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">), </span><span style="color: #61AFEF">next</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {}</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">~node</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"><span style="color: #ABB2BF">        node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">head, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tail;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> currentLength;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">dLinkList</span><span style="color: #ABB2BF">() {};</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~dLinkList</span><span style="color: #ABB2BF">() {</span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">(); </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> head; </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> tail;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">length</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> currentLength;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">search</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">visit</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">traverse</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        /*bool isEmpty() const;*/</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">dLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">dLinkList</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    head </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> node;</span></span><span class="line"><span style="color: #ABB2BF">    tail </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> node;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tail;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">tail</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">prev</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">    currentLength </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">typename</span><span style="color: #ABB2BF"> dLinkList&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #E5C07B">dLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (i</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">pos, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">newNode;</span></span><span class="line"><span style="color: #ABB2BF">    pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    newNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(x, pos, </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">next</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">prev</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> newNode;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> newNode;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">currentLength;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">pos;</span></span><span class="line"><span style="color: #ABB2BF">    pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(i);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">prev</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">next</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">prev</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">pos</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">prev</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> pos;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">currentLength;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">q;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tail;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">tail</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">prev</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> head;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> tail)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        q </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    currentLength </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">search</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> tail </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> x)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> tail) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">visit</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">move</span><span style="color: #ABB2BF">(i)-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dLinkList</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">traverse</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> tail)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="循环链表">循环链表</h3><h4 id="循环单链表">循环单链表</h4><figure><img src="image-4.webp" srcset="/img/loading/loading3.gif" lazyload alt="线性表循环单链表实现结构"><figcaption aria-hidden="true">线性表循环单链表实现结构</figcaption></figure><h4 id="循环双链表">循环双链表</h4><figure><img src="image-5.webp" srcset="/img/loading/loading3.gif" lazyload alt="线性表循环双链表结构"><figcaption aria-hidden="true">线性表循环双链表结构</figcaption></figure><h2 id="线性表的应用">线性表的应用</h2><ul><li>大整数处理</li><li>多项式求和</li><li>约瑟夫环</li><li>动态内存管理</li></ul><h1 id="栈">栈</h1><h2 id="栈的定义">栈的定义</h2><figure><img src="image-6.webp" srcset="/img/loading/loading3.gif" lazyload alt="栈的结构"><figcaption aria-hidden="true">栈的结构</figcaption></figure><ul><li>特点：<strong>先进后出</strong>结构，最先到达栈的结点将最晚被删除</li><li>相关概念：<ul><li>栈底(bottom)：结构的首部（先进栈结点的位置）</li><li>栈顶(top)：结构的尾部（后进栈结点的位置）</li><li>出栈(pop)：结点从栈顶删除</li><li>进栈(push)：结点在栈顶位置插入</li><li>空栈：栈中结点个数为零</li></ul></li><li>栈的抽象类</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#ifndef</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">STACK_H</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">STACK_H</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;iostream&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">stack</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">~stack</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">#endif</span></span></code></pre></div></div></figure><h2 id="栈的顺序实现">栈的顺序实现</h2><figure><img src="image-7.webp" srcset="/img/loading/loading3.gif" lazyload alt="栈的顺序实现结构"><figcaption aria-hidden="true">栈的顺序实现结构</figcaption></figure><ul><li>时间复杂度: <span class="math inline"><em>O</em>(1)</span></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"3-1-stack.h"</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqStack</span><span style="color: #ABB2BF"> : </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">stack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">    elemType </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">elem;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> top_p;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> maxSize;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">doubleSpace</span><span style="color: #ABB2BF">();</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">seqStack</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">initSize</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">~seqStack</span><span style="color: #ABB2BF">() { </span><span style="color: #C678DD">delete[]</span><span style="color: #ABB2BF"> elem; }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> { </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> top_p </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">seqStack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">seqStack</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> initSize)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    elem </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">[initSize];</span></span><span class="line"><span style="color: #ABB2BF">    maxSize </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> initSize;</span></span><span class="line"><span style="color: #ABB2BF">    top_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqStack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">doubleSpace</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    elemType </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> elem;</span></span><span class="line"><span style="color: #ABB2BF">    elem </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> maxSize];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> maxSize; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    maxSize </span><span style="color: #C678DD">*=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete[]</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqStack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (top_p </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> maxSize </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">doubleSpace</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">top_p] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqStack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[top_p</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqStack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[top_p];</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="栈的链接实现">栈的链接实现</h2><figure><img src="image-8.webp" srcset="/img/loading/loading3.gif" lazyload alt="栈的链接实现结构"><figcaption aria-hidden="true">栈的链接实现结构</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"3-1-stack.h"</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">linkStack</span><span style="color: #ABB2BF"> : </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">stack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">node</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        elemType data;</span></span><span class="line"><span style="color: #ABB2BF">        node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">next;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">N</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">            next </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> N;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">() : </span><span style="color: #61AFEF">next</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~node</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">    };</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">top_p;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">linkStack</span><span style="color: #ABB2BF">() { top_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">~linkStack</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> { </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> top_p </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">linkStack&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #56B6C2">~</span><span style="color: #61AFEF">linkStack</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (top_p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> top_p;</span></span><span class="line"><span style="color: #ABB2BF">        top_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">top_p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">linkStack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    top_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(x, top_p);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">linkStack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> top_p;</span></span><span class="line"><span style="color: #ABB2BF">    elemType value </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">top_p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    top_p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">top_p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> value;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">linkStack</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">top_p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="栈的应用">栈的应用</h2><ul><li>递归消除</li><li>括号配对</li><li>表达式的计算（后缀表达式）<ul><li>对于一个表达式 <span class="math inline"><em>a</em> + <em>b</em></span><ul><li><strong>前缀式</strong>：<span class="math inline">+<em>a</em><em>b</em></span></li><li><strong>中缀式</strong>：<span class="math inline"><em>a</em> + <em>b</em></span></li><li><strong>后缀式</strong>：<span class="math inline"><em>a</em><em>b</em>+</span></li></ul></li></ul></li></ul><h1 id="队列">队列</h1><h2 id="队列的定义">队列的定义</h2><figure><img src="image-9.webp" srcset="/img/loading/loading3.gif" lazyload alt="队列结构"><figcaption aria-hidden="true">队列结构</figcaption></figure><ul><li>特点：<strong>先进先出</strong>结构，最先到达队列的结点将最早被删除</li><li>相关概念：<ul><li>队列头(front)：结构的首部（先进队列结点的位置）</li><li>队列尾(rear)：结构的尾部（后进队列结点的位置）</li><li>出队列(dequeue)：结点从队列头删除</li><li>入队列(enqueue)：结点在队列尾位置插入</li><li>空队列：队列中结点个数为零</li></ul></li><li>队列的抽象类</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#ifndef</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">QUEUE_H</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">QUEUE_H</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;iostream&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">queue</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">~queue</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">enQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">deQueue</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getHead</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">#endif</span></span></code></pre></div></div></figure><h2 id="队列的顺序实现">队列的顺序实现</h2><ul><li><strong>队列头位置固定的顺序实现</strong> <img src="image-10.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>队列头位置不固定的顺序实现</strong> <img src="image-11.webp" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>循环队列</strong> <img src="image-12.webp" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="循环队列的顺序实现">循环队列的顺序实现</h3><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"4-1-queue.h"</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqQueue</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">queue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        elemType </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">elem;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> maxSize;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> front, rear;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">doubleSpace</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">seqQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~seqQueue</span><span style="color: #ABB2BF">() {</span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> elem;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> front </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> rear;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">enQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">deQueue</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getHead</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[(front</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF">maxSize];}</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">seqQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">seqQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> size)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    elem </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">[size];</span></span><span class="line"><span style="color: #ABB2BF">    maxSize </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    front </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> rear </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">doubleSpace</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    elemType </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> elem;</span></span><span class="line"><span style="color: #ABB2BF">    elem </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">2</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">maxSize];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> maxSize; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[(front</span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF">i)</span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF">maxSize];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    front </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    rear </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> maxSize;</span></span><span class="line"><span style="color: #ABB2BF">    maxSize </span><span style="color: #C678DD">*=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">enQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> ((rear</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF">maxSize </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> front) </span><span style="color: #61AFEF">doubleSpace</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    rear </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (rear</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF">maxSize;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[rear] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">seqQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">deQueue</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    front </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (front</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF">maxSize;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[front];</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="队列的链接实现">队列的链接实现</h2><figure><img src="image-13.webp" srcset="/img/loading/loading3.gif" lazyload alt="队列的链接实现结构"><figcaption aria-hidden="true">队列的链接实现结构</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"4-1-queue.h"</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">linkQueue</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">queue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">node</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            elemType data;</span></span><span class="line"><span style="color: #ABB2BF">            node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">next;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">N</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">                next </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> N;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">():</span><span style="color: #61AFEF">next</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {}</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">~node</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"><span style="color: #ABB2BF">        node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">front, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">rear;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">linkQueue</span><span style="color: #ABB2BF">() {front </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> rear </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~linkQueue</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> front </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">enQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">deQueue</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getHead</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">front</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;}</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">linkQueue&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #56B6C2">~</span><span style="color: #61AFEF">linkQueue</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (front </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> front;</span></span><span class="line"><span style="color: #ABB2BF">        front </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">front</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">linkQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">enQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (rear </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        front </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> rear </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(x);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">rear</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(x);</span></span><span class="line"><span style="color: #ABB2BF">        rear </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">rear</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">linkQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">deQueue</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> front;</span></span><span class="line"><span style="color: #ABB2BF">    elemType value </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">front</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    front </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">front</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (front </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) rear </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> value;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="队列的应用">队列的应用</h2><ul><li>火车车厢重排问题</li><li>排队系统的模拟</li></ul><h1 id="树">树</h1><h2 id="树的定义">树的定义</h2><ul><li>相关概念<ul><li><strong>结点</strong><ul><li>根结点：起始结点，没有父结点</li><li>叶结点：没有子结点（度为0）</li><li>子结点：结点的下一层结点</li><li>父结点：结点的上一层结点</li><li>兄弟结点：同一父结点的结点</li><li>祖先结点：从根到该结点路径上的所有结点</li><li>子孙结点：某个结点的所有下层结点</li></ul></li><li><strong>度</strong>：直接子结点的数量<ul><li>树的度：由度最大的结点决定</li></ul></li><li><strong>层次/深度</strong>：结点在树的层数<ul><li>根结点在第1层</li><li><strong>高度</strong>：树的结点中的最大层次</li></ul></li><li><strong>有序树与无序树</strong><ul><li>有序树：子树从左到右有顺序，即区分左右子树</li><li>无序树：不区分左右子树</li></ul></li><li><strong>森林</strong>：若干互不相交的树的集合</li></ul></li><li>树的抽象类</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#ifndef</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">TREE_H</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">TREE_H</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tree</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">~tree</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Root</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">parent</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">child</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">i</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">traverse</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">#endif</span></span></code></pre></div></div></figure><h2 id="二叉树">二叉树</h2><h3 id="二叉树的定义">二叉树的定义</h3><p><img src="image-14.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>有序树，必须严格区分左右子树</li><li>任意结点的子结点数不超2</li><li><strong>满二叉树/完美树</strong>：任意一层的结点个数都达到最大值<ul><li>高度为 <span class="math inline"><em>k</em></span> 并具有 <span class="math inline">2<em>k</em> − 1</span> 个结点的二叉树</li></ul></li><li><strong>完全二叉树</strong>：满二叉树最底层从右向左依次移除若干结点<ul><li>满二叉树一定是完全二叉树</li><li>完全二叉树不一定是满二叉树</li></ul></li></ul><figure><img src="image-15.webp" srcset="/img/loading/loading3.gif" lazyload alt="完全二叉树与满二叉树"><figcaption aria-hidden="true">完全二叉树与满二叉树</figcaption></figure><h3 id="二叉树的常用性质">二叉树的常用性质</h3><ol type="1"><li>非空二叉树的第 <span class="math inline"><em>i</em></span>层上最多有 <span class="math inline">2<em>i</em> − 1</span>个结点（<span class="math inline"><em>i</em> ≥ 1</span>）</li><li>高度为 <span class="math inline"><em>k</em></span>的二叉树，最多具有 <span class="math inline">2<sup><em>k</em></sup> − 1</span>个结点（对满二叉树进行 <span class="math inline">2</span>的等比数列求和）</li><li>如果叶子结点数为 <span class="math inline"><em>n</em><sub>0</sub></span>，度数为 <span class="math inline">2</span> 的结点数为 <span class="math inline"><em>n</em><sub>2</sub></span>，则有：<span class="math inline"><em>n</em><sub>0</sub> = <em>n</em><sub>2</sub> + 1</span></li><li>具有 <span class="math inline"><em>n</em></span>个结点的完全二叉树的高度 <span class="math inline"><em>k</em> = ⌊log<sub>2</sub><em>n</em>⌋ + 1</span></li><li>对一棵有 <span class="math inline"><em>n</em></span>个结点的完全二叉树按层自上而下编号，每一层自左至右依次编号，若树的根结点编号为<span class="math inline">1</span>，则对一个编号为 <span class="math inline"><em>i</em></span> 的结点<ol type="1"><li>若 <span class="math inline"><em>i</em> = 1</span>，则该结点是根结点，否则父结点编号为<span class="math inline">⌊<em>i</em>/2⌋</span></li><li>若 <span class="math inline">2<em>i</em> &gt; <em>n</em></span>，则该结点是叶结点，否则左儿子编号为<span class="math inline">2<em>i</em></span></li><li>若 <span class="math inline">2<em>i</em> + 1 &gt; <em>n</em></span>，则该结点是叶结点，否则右儿子编号为<span class="math inline">2<em>i</em> + 1</span></li></ol></li></ol><h3 id="二叉树的基本运算">二叉树的基本运算</h3><ul><li>遍历<ul><li>前序遍历/先根遍历<ul><li>顺序：根-左-右</li></ul></li><li>中序遍历/中根遍历<ul><li>顺序：左-根-右</li></ul></li><li>后序遍历/后根遍历<ul><li>顺序：左-右-根</li></ul></li><li>层次遍历<ul><li>顺序：从根到叶，从左到右</li></ul></li></ul></li><li>由二叉树的前序遍历和中序遍历/后序遍历和中序遍历可以唯一确定一棵二叉树<ul><li>前序遍历和中序遍历<ul><li>前序遍历的第一个结点为根结点</li><li>在中序遍历中找到根结点，将中序遍历分为左子树和右子树</li><li>对左子树和右子树递归进行前序遍历和中序遍历</li></ul></li><li>后序遍历和中序遍历<ul><li>后序遍历的最后一个结点为根结点</li><li>在中序遍历中找到根结点，将中序遍历分为左子树和右子树</li><li>对左子树和右子树递归进行后序遍历和中序遍历</li></ul></li></ul></li><li>二叉树的抽象类</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#ifndef</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">BTREE_H</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">BTREE_H</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">bTree</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">~bTree</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Root</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">parent</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">lchild</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">rchild</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">delLeft</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">delRight</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">elemType</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">preOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">midOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">postOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">levelOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">#endif</span></span></code></pre></div></div></figure><h3 id="二叉树的顺序实现">二叉树的顺序实现</h3><figure><img src="image-16.webp" srcset="/img/loading/loading3.gif" lazyload alt="二叉树的顺序实现结构"><figcaption aria-hidden="true">二叉树的顺序实现结构</figcaption></figure><ul><li>使用数组存储<ul><li>根结点下标为 <span class="math inline">1</span></li><li>若某个结点下标为 <span class="math inline"><em>i</em></span><ul><li>左子树下标为 <span class="math inline">2<em>i</em></span></li><li>右子树下标为 <span class="math inline">2<em>i</em> + 1</span></li></ul></li></ul></li></ul><h3 id="二叉树的链接实现">二叉树的链接实现</h3><p><img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload alt="标准存储结构"> <img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload alt="广义标准存储结构"></p><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"6-2-bTree.h"</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF"> : </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">bTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">friend</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">printTree</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Node</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            T data;</span></span><span class="line"><span style="color: #ABB2BF">            Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">left, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">right;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">Node</span><span style="color: #ABB2BF">():</span><span style="color: #61AFEF">left</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">), </span><span style="color: #61AFEF">right</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {}</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">Node</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">item</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">L</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">R</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">):</span><span style="color: #61AFEF">data</span><span style="color: #ABB2BF">(item), </span><span style="color: #61AFEF">left</span><span style="color: #ABB2BF">(L), </span><span style="color: #61AFEF">right</span><span style="color: #ABB2BF">(R) {}</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">~Node</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"><span style="color: #ABB2BF">        Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">root;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">binaryTree</span><span style="color: #ABB2BF">():</span><span style="color: #61AFEF">root</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">binaryTree</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">value</span><span style="color: #ABB2BF">) {root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Node</span><span style="color: #ABB2BF">(value);}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~binaryTree</span><span style="color: #ABB2BF">() {</span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">();}</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> root </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Root</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">lchild</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">rchild</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">delLeft</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">delRight</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">preOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">midOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">postOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">levelOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">createTree</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">parent</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> flag;}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(root);}</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">(root);}</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">Node</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*&amp;</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">preOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">midOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">postOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (root </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">    root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*&amp;</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> t;</span></span><span class="line"><span style="color: #ABB2BF">    t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">Root</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (root </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> flag;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">root</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">binaryTree&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #E5C07B">Node</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, binaryTree&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> x) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> t;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> ((tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">)) </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">lchild</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x, root);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (tmp </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> flag;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">left</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">rchild</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x, root);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (tmp </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> flag;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">right</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">delLeft</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x, root);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (tmp </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">delRight</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x, root);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (tmp </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">clear</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">createTree</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    queue</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">Node</span><span style="color: #56B6C2">*</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">    Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp;</span></span><span class="line"><span style="color: #ABB2BF">    T x, ldata, rdata;</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"</span><span style="color: #56B6C2">\n</span><span style="color: #98C379"> Input root node: "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    cin </span><span style="color: #C678DD">&gt;&gt;</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">    root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Node</span><span style="color: #ABB2BF">(x);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">front</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Input "</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"'s two children("</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> flag </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" as NULL): "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        cin </span><span style="color: #C678DD">&gt;&gt;</span><span style="color: #ABB2BF"> ldata </span><span style="color: #C678DD">&gt;&gt;</span><span style="color: #ABB2BF"> rdata;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (ldata </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> flag) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Node</span><span style="color: #ABB2BF">(ldata));</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (rdata </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> flag) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">Node</span><span style="color: #ABB2BF">(rdata));</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Create completed!"</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">printTree</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">flag</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    queue </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">T</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">Root</span><span style="color: #ABB2BF">(flag));    </span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        T tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">front</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (tmp </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> flag) </span><span style="color: #C678DD">continue</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> tmp </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">lchild</span><span style="color: #ABB2BF">(tmp, flag) </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">rchild</span><span style="color: #ABB2BF">(tmp, flag) </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">lchild</span><span style="color: #ABB2BF">(tmp, flag) </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> flag) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">lchild</span><span style="color: #ABB2BF">(tmp, flag));</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">rchild</span><span style="color: #ABB2BF">(tmp, flag) </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> flag) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">rchild</span><span style="color: #ABB2BF">(tmp, flag));</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> lt </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">), rt </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> ((lt </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> rt) </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> lt </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> rt);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">preOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (root </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #61AFEF">preOrder</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #7F848E; font-style: italic">// 递归实现</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">preOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">preOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">preOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #7F848E; font-style: italic">// 非递归实现</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">BinaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">preOrder</span><span style="color: #ABB2BF"> () </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    Stack</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">Node</span><span style="color: #56B6C2">*</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> s;</span></span><span class="line"><span style="color: #ABB2BF">    Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">current;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        current </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">midOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (root </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #61AFEF">midOrder</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #7F848E; font-style: italic">// 递归实现</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">midOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">midOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">midOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #7F848E; font-style: italic">// 非递归实现</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">BinaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">midOrder</span><span style="color: #ABB2BF"> () </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">StNode</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">node;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> TimesPop;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">StNode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">N</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">):</span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(N), </span><span style="color: #61AFEF">TimesPop</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {}</span></span><span class="line"><span style="color: #ABB2BF">    };</span></span><span class="line"><span style="color: #ABB2BF">    Stack</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">StNode</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> s;</span></span><span class="line"><span style="color: #ABB2BF">    StNode </span><span style="color: #61AFEF">current</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(current);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        current </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">++</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">TimesPop</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">StNode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(current);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">StNode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">postOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (root </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #61AFEF">postOrder</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #7F848E; font-style: italic">// 递归实现</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">postOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">postOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">postOrder</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #7F848E; font-style: italic">// 非递归实现</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">BinaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">postOrder</span><span style="color: #ABB2BF"> () </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">StNode</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">node;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> TimesPop;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">StNode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">N</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">):</span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(N), </span><span style="color: #61AFEF">TimesPop</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) {}</span></span><span class="line"><span style="color: #ABB2BF">    };</span></span><span class="line"><span style="color: #ABB2BF">    Stack</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">StNode</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> s;</span></span><span class="line"><span style="color: #ABB2BF">    StNode </span><span style="color: #61AFEF">current</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(current);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        current </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">++</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">TimesPop</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">continue</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(current);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">TimesPop</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">StNode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">StNode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">current</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binaryTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">levelOrder</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    queue</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">Node</span><span style="color: #56B6C2">*</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">    Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (root </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">front</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="二叉树的应用">二叉树的应用</h3><ul><li>计算表达式</li></ul><p><img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload></p><h2 id="哈夫曼树和哈夫曼编码">哈夫曼树和哈夫曼编码</h2><h3 id="前缀编码">前缀编码</h3><ul><li>无二义性</li><li>每个字符的编码与其它字符编码的前缀不同</li></ul><h3 id="哈夫曼编码">哈夫曼编码</h3><ul><li>目的：根据数据的出现频率进行不同长度的编码，从而节省空间。</li><li>哈夫曼树：哈夫曼树是一棵最小代价的二叉树，在这棵树上，所有的字符都包含在叶结点上。要使得整棵树的代价最小，显然权值大的叶子应当尽量靠近树根，权值小的叶子可以适当离树根远一些。</li><li>构建方法：从当前集合中选取并去除权值最小、次最小的两个结点，以这两个结点作为内部结点<span class="math inline"><em>b</em><sub><em>i</em></sub></span>的左右儿子，<span class="math inline"><em>b</em><sub><em>i</em></sub></span>的权值为其左右儿子权值之和并加入其中。这样，在集合A中，结点个数便减少了一个。这样，在经过了<span class="math inline"><em>n</em> − 1</span>次循环之后，集合A中只剩下了一个结点，这个结点就是根结点。</li></ul><p><img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload alt="哈夫曼树的构建过程"> <img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload alt="哈夫曼树的内存表示"></p><h3 id="哈夫曼树类的实现">哈夫曼树类的实现</h3><ul><li>二叉树的广义标准存储<ul><li>每个结点包含以下字段<ul><li>数据<ul><li>数据</li><li>权值</li></ul></li><li><strong>父结点指针</strong></li><li>左、右子结点指针</li></ul></li></ul></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">hfTree</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Node</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            T data;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> weight;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> parent, left, right;</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"><span style="color: #ABB2BF">        Node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">elem;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> length;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">hfCode</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            T data;</span></span><span class="line"><span style="color: #ABB2BF">            string code;</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">hfTree</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">v</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">w</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getCode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">hfCode</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">result</span><span style="color: #ABB2BF">[]);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~hfTree</span><span style="color: #ABB2BF">() {</span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> elem; }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">hfTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">hfTree</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> T </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">v, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">w, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> size)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> MAX_INT </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">32767</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> min1, min2;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> x, y;</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    length </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    elem </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Node</span><span style="color: #ABB2BF">[length];</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> length; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">w</span><span style="color: #ABB2BF">[i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> size];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">v</span><span style="color: #ABB2BF">[i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> size];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">parent</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        min1 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> min2 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> MAX_INT;</span></span><span class="line"><span style="color: #ABB2BF">        x </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> y </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> length; j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[j].</span><span style="color: #E06C75">parent</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[j].</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> min1)</span></span><span class="line"><span style="color: #ABB2BF">                {</span></span><span class="line"><span style="color: #ABB2BF">                    min2 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> min1;</span></span><span class="line"><span style="color: #ABB2BF">                    min1 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[j].</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                    y </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">                    x </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> j;</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[j].</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> min2)</span></span><span class="line"><span style="color: #ABB2BF">                {</span></span><span class="line"><span style="color: #ABB2BF">                    min2 </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[j].</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                    y </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> j;</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> min1 </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> min2;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> y;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">parent</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[x].</span><span style="color: #E06C75">parent</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[y].</span><span style="color: #E06C75">parent</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">hfTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">getCode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">hfCode</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">result</span><span style="color: #ABB2BF">[])</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> size </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> length </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> p, s;</span></span><span class="line"><span style="color: #ABB2BF">    string str </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">""</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> length; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">result</span><span style="color: #ABB2BF">[i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> size].</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">result</span><span style="color: #ABB2BF">[i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> size].</span><span style="color: #E06C75">code</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">""</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">parent</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        s </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[p].</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> s) str </span><span style="color: #C678DD">+=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'0'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> str </span><span style="color: #C678DD">+=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'1'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            s </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">elem</span><span style="color: #ABB2BF">[p].</span><span style="color: #E06C75">parent</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">str</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; j</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">)  </span><span style="color: #E5C07B">result</span><span style="color: #ABB2BF">[i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> size].</span><span style="color: #E06C75">code</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">+=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">str</span><span style="color: #ABB2BF">[j];</span></span><span class="line"><span style="color: #ABB2BF">        str </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">""</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">main</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">char</span><span style="color: #ABB2BF"> ch[] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> {</span><span style="color: #98C379">"aeistdn"</span><span style="color: #ABB2BF">};</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> w[] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> {</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">15</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">12</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">13</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">};</span></span><span class="line"><span style="color: #ABB2BF">    hfTree</span><span style="color: #C678DD">&lt;char&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">tree</span><span style="color: #ABB2BF">(ch, w, </span><span style="color: #D19A66">7</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    hfTree&lt;</span><span style="color: #C678DD">char</span><span style="color: #ABB2BF">&gt;::hfCode </span><span style="color: #E5C07B">result</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">7</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">tree</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getCode</span><span style="color: #ABB2BF">(result);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">7</span><span style="color: #ABB2BF">; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">result</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">' '</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">result</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">code</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="树和森林">树和森林</h2><h3 id="树的存储实现">树的存储实现</h3><p><img src="image-25.webp" srcset="/img/loading/loading3.gif" lazyload></p><ul><li><p><strong>孩子链表示法</strong> <img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload alt="孩子链表示法"></p></li><li><p><strong>孩子兄弟链表示法</strong></p><ul><li>把树表示成一棵二叉树<ul><li>左指针：第一个子结点</li><li>右指针：兄弟结点</li></ul></li><li>前序遍历与二叉树相同</li><li>后序遍历与二叉树的中序遍历相同</li></ul><figure><img src="image-23.webp" srcset="/img/loading/loading3.gif" lazyload alt="孩子兄弟链表示法"><figcaption aria-hidden="true">孩子兄弟链表示法</figcaption></figure></li><li><p><strong>双亲表示法</strong> <img src="image-24.webp" srcset="/img/loading/loading3.gif" lazyload alt="双亲表示法"></p></li></ul><h3 id="树的遍历">树的遍历</h3><ul><li>前序遍历</li><li>后序遍历</li><li>层次遍历</li></ul><h3 id="树森林与二叉树的转换">树、森林与二叉树的转换</h3><ul><li><strong>森林</strong>：树的集合<ul><li>存储方式：把森林存储为一棵二叉树</li></ul></li><li><strong>把森林转换为二叉树的步骤</strong>：<ol type="1"><li>把森林 <span class="math inline"><em>F</em> = <em>T</em><sub>1</sub>, <em>T</em><sub>2</sub>, …, <em>T</em><sub><em>k</em></sub></span>中的树 <span class="math inline"><em>T</em><sub><em>i</em></sub></span>用孩子兄弟链法表示为一棵二叉树 <span class="math inline"><em>B</em><sub><em>i</em></sub></span></li><li>把二叉树 <span class="math inline"><em>B</em><sub><em>i</em></sub></span> 作为二叉树<span class="math inline"><em>B</em><sub><em>i</em> − 1</sub></span>的根结点的右子树</li></ol></li></ul><figure><img src="image-26.webp" srcset="/img/loading/loading3.gif" lazyload alt="森林转换为二叉树"><figcaption aria-hidden="true">森林转换为二叉树</figcaption></figure><h1 id="优先级队列">优先级队列</h1><p>优先级队列是一种特殊的队列，其中每个元素都有一个优先级。优先级最高的元素是队头元素，优先级最低的元素是队尾元素。</p><h2 id="基于线性表的优先级的队列">基于线性表的优先级的队列</h2><ul><li>时间复杂度 <span class="math inline"><em>O</em>(<em>N</em>)</span></li></ul><h2 id="基于树的优先级队列">基于树的优先级队列</h2><figure><img src="image-27.webp" srcset="/img/loading/loading3.gif" lazyload alt="二叉堆"><figcaption aria-hidden="true">二叉堆</figcaption></figure><ul><li>又称<strong>二叉堆</strong></li><li>时间复杂度：<span class="math inline"><em>O</em>(log <em>N</em>)</span></li><li>分为：<ul><li>最大堆：根结点是最大元素</li><li>最小堆：根结点是最小元素</li></ul></li><li>实现：<ul><li>插入：新结点会先插入到完全二叉树最后一个结点，然后<strong>向上过滤</strong>（percolateup）</li><li>出队：移出根结点后，最后一个结点会填补根结点的位置，然后<strong>向下过滤</strong>（percolatedown）</li></ul><figure><img src="image-28.webp" srcset="/img/loading/loading3.gif" lazyload alt="插入与出队"><figcaption aria-hidden="true">插入与出队</figcaption></figure></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">PriorityQueue</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">PriorityQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">capacity</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">PriorityQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">pq</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">PriorityQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">capacity</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">T</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">~PriorityQueue</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isFull</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">print</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">enQueue</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">item</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">deQueue</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getHead</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> currentSize;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> capacity;</span></span><span class="line"><span style="color: #ABB2BF">    T</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> items;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">doubleCapacity</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">percolateDown</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">hole</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">buildHeap</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">PriorityQueue</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    capacity </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">100</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    items </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">[capacity</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    currentSize </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">PriorityQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> capacity) {</span></span><span class="line"><span style="color: #ABB2BF">    capacity </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> capacity;</span></span><span class="line"><span style="color: #ABB2BF">    items </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">[capacity</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    currentSize </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">PriorityQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> PriorityQueue</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">T</span><span style="color: #C678DD">&gt;</span><span style="color: #56B6C2">&amp;</span><span style="color: #ABB2BF"> pq) {</span></span><span class="line"><span style="color: #ABB2BF">    capacity </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">pq</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">capacity</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    items </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">[capacity</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    currentSize </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">pq</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">currentSize</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> currentSize; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">pq</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">items</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">PriorityQueue</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> capacity, T</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> x, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> size) {</span></span><span class="line"><span style="color: #ABB2BF">    capacity </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> capacity;</span></span><span class="line"><span style="color: #ABB2BF">    items </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">[capacity</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    currentSize </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> currentSize; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[i</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">buildHeap</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">PriorityQueue&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #56B6C2">~</span><span style="color: #61AFEF">PriorityQueue</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete[]</span><span style="color: #ABB2BF"> items;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> currentSize </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">isFull</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> currentSize </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> capacity;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">print</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x; i </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> currentSize; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">enQueue</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">item</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">isFull</span><span style="color: #ABB2BF">()) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">doubleCapacity</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> hole </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">currentSize;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (; hole </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> item </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[hole </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">]; hole </span><span style="color: #C678DD">/=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[hole] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[hole </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[hole] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> item;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">deQueue</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    T minItem </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[currentSize</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">percolateDown</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> minItem;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">T</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">getHead</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">doubleCapacity</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    T</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> oldItems </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> items;</span></span><span class="line"><span style="color: #ABB2BF">    capacity </span><span style="color: #C678DD">*=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    items </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">[capacity</span><span style="color: #56B6C2">+</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> currentSize; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">oldItems</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete[]</span><span style="color: #ABB2BF"> oldItems;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">percolateDown</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">hole</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> child;</span></span><span class="line"><span style="color: #ABB2BF">    T tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[hole];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (; hole </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> currentSize; hole </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> child) {</span></span><span class="line"><span style="color: #ABB2BF">        child </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> hole </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (child </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> currentSize </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[child </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[child]) {</span></span><span class="line"><span style="color: #ABB2BF">            child</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[child] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> tmp) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[hole] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[child];</span></span><span class="line"><span style="color: #ABB2BF">        } </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">break</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">items</span><span style="color: #ABB2BF">[hole] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">PriorityQueue</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">T</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">buildHeap</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> currentSize </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">percolateDown</span><span style="color: #ABB2BF">(i);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="优先级队列的应用">优先级队列的应用</h2><ul><li>排队系统的模拟</li></ul><h1 id="集合和静态查找表">集合和静态查找表</h1><h2 id="集合的定义">集合的定义</h2><ul><li>集合中的数据元素除了属于同一集合之外，没有任何逻辑关系。</li><li>在集合中，每个数据元素有一个区别于其他元素的<strong>唯一标识</strong>，通常称为<strong>键值或关键字值</strong>。</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#ifndef</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">SET_H</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">SET_H</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    KEY key;</span></span><span class="line"><span style="color: #ABB2BF">    OTHER other;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">SET</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">k</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">o</span><span style="color: #ABB2BF">) : </span><span style="color: #61AFEF">key</span><span style="color: #ABB2BF">(k), </span><span style="color: #61AFEF">other</span><span style="color: #ABB2BF">(o) {}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">SET</span><span style="color: #ABB2BF">() {}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">operator</span><span style="color: #ABB2BF"> != (</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> key </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">operator</span><span style="color: #ABB2BF"> == (</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> key </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">ostream</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;operator</span><span style="color: #ABB2BF"> &lt;&lt; (</span><span style="color: #E5C07B">ostream</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">os</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        os </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> key;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> os;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">#endif</span></span></code></pre></div></div></figure><h2 id="查找的基本概念">查找的基本概念</h2><ul><li>用于查找的集合称之为查找表</li><li>查找表分类：<ul><li>静态查找表：数据元素固定</li><li>动态查找表</li></ul></li><li>根据查找的数据元素存放位置：<ul><li>内部查找</li><li>外部查找：记录</li></ul></li></ul><h2 id="静态查找表">静态查找表</h2><h3 id="无序表的查找">无序表的查找</h3><ul><li>查找表中的元素无序</li><li>顺序查找<ul><li>时间复杂度：<span class="math inline"><em>O</em>(<em>N</em>)</span></li></ul></li></ul><h3 id="有序表的查找">有序表的查找</h3><ul><li><strong>顺序查找</strong>：<span class="math inline"><em>O</em>(<em>N</em>)</span></li><li><strong>二分查找</strong>：<span class="math inline"><em>O</em>(log <em>N</em>)</span></li><li><strong>插值查找</strong>：<ul><li>根据下面的公式估算位置 <span class="math display">$$ next = low +[\frac{(x - A[low])}{A[high] - A[low]} \times (high - low - 1)]$$</span></li></ul></li><li><strong>分块查找/顺序索引查找</strong><ul><li>分块：块间必须是有序的</li><li>索引表：对查找表分块后建立，每个索引项包含一个块内的最大元素值和该索引块的起始地址</li><li>先查找索引表，确定在哪一块，再在块中查找元素</li></ul></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"8-1-set.h"</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">seqSearch</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size; </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> x; i</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">binSearch</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> left </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, right </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size, mid;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (left </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> right) {</span></span><span class="line"><span style="color: #ABB2BF">        mid </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (left </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> right) </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[mid].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> x) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> mid;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[mid].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> x) {</span></span><span class="line"><span style="color: #ABB2BF">            left </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> mid </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            right </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> mid </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h1 id="动态查找表">动态查找表</h1><h2 id="动态查找表的定义">动态查找表的定义</h2><ul><li>支持增、删、查、改等操作</li><li>存储结构：<ul><li>查找树</li><li>散列表</li></ul></li><li>动态查找表的抽象类</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#ifndef</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">DYNAMICSEARCHTABLE_H</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">DYNAMICSEARCHTABLE_H</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"8-1-set.h"</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dynamicSearchTable</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">~dynamicSearchTable</span><span style="color: #ABB2BF">() {};</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">#endif</span></span></code></pre></div></div></figure><h2 id="二叉查找树">二叉查找树</h2><h3 id="二叉查找树的定义">二叉查找树的定义</h3><ul><li><strong>定义</strong>：二叉查找树又称二叉排序树，非空情况下满足下列条件<ul><li>若左子树非空，则左子树上的所有非空结点的关键字值均小于根结点的关键字值</li><li>若右子树非空，则右子树上的所有非空结点的关键字值均大于根结点的关键字值</li><li>左右子树也是二叉查找树</li></ul></li><li><strong>性质</strong>：<ul><li>中序遍历一棵二叉查找树的道德访问序列<strong>按键值递增</strong></li></ul></li></ul><figure><img src="image-29.webp" srcset="/img/loading/loading3.gif" lazyload alt="二叉查找树的构造"><figcaption aria-hidden="true">二叉查找树的构造</figcaption></figure><h3 id="二叉查找树的实现">二叉查找树的实现</h3><ul><li>通常采用二叉树的标准存储法<ul><li>每个结点包含以下字段<ul><li>数据：键值-数据对</li><li>左、右子结点指针</li></ul></li></ul></li><li><strong>运算实现</strong>：<ul><li>查找：<ol type="1"><li>若根结点不存在，则不存在</li><li>若根结点关键字值等于查找值，则找到</li><li>若根结点关键字值大于查找值，则递归查找左子树</li><li>若根结点关键字值小于查找值，则递归查找右子树</li></ol></li><li>插入：<ol type="1"><li>若根结点不存在，则插入为根结点</li><li>若根结点关键字值大于插入值，则在左子树上递归插入</li><li>若根结点关键字值小于插入值，则在右子树上递归插入</li></ol></li><li>删除：<ol type="1"><li>若根结点关键字值大于待删值，则在左子树上递归删除</li><li>若根结点关键字值小于待删值，则在右子树上递归删除</li><li>若根结点关键字值等于待删值，则：<ol type="1"><li>根结点无子结点：直接删</li><li>根结点有一个子结点：作为新的根结点</li><li>根结点有两个子结点：找到左子树的最大结点或右子树最小结点替代</li></ol></li></ol></li></ul></li><li>时间复杂度：<span class="math inline"><em>O</em>(log <em>N</em>)</span></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"9-1-dynamicSearchTable.h"</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binarySearchTree</span><span style="color: #ABB2BF"> : </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dynamicSearchTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">binarySearchTree</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">~binarySearchTree</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">BinaryNode</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> data;</span></span><span class="line"><span style="color: #ABB2BF">        BinaryNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> left;</span></span><span class="line"><span style="color: #ABB2BF">        BinaryNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> right;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">BinaryNode</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">thedata</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l</span><span style="color: #C678DD">=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">r</span><span style="color: #C678DD">=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            : </span><span style="color: #61AFEF">data</span><span style="color: #ABB2BF">(thedata), </span><span style="color: #61AFEF">left</span><span style="color: #ABB2BF">(l), </span><span style="color: #61AFEF">right</span><span style="color: #ABB2BF">(r) {}</span></span><span class="line"><span style="color: #ABB2BF">    };</span></span><span class="line"><span style="color: #ABB2BF">    BinaryNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">binarySearchTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">binarySearchTree</span><span style="color: #ABB2BF">() </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">binarySearchTree&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #56B6C2">~</span><span style="color: #61AFEF">binarySearchTree</span><span style="color: #ABB2BF">() </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binarySearchTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x, root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binarySearchTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> x) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> t;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (x </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binarySearchTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(x, root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binarySearchTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">BinaryNode</span><span style="color: #ABB2BF">(x);</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binarySearchTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(x, root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binarySearchTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (x </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    } </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (x </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {</span><span style="color: #7F848E; font-style: italic">// Two children</span></span><span class="line"><span style="color: #ABB2BF">        BinaryNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span><span style="color: #7F848E; font-style: italic">// Find the smallest node in the right subtree</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span><span style="color: #7F848E; font-style: italic">// Remove the smallest node in the right subtree</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span><span style="color: #7F848E; font-style: italic">// One or zero children</span></span><span class="line"><span style="color: #ABB2BF">        BinaryNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> oldNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> t;</span></span><span class="line"><span style="color: #ABB2BF">        t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> oldNode;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">binarySearchTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">BinaryNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> t;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">main</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;int</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">char</span><span style="color: #56B6C2">*</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> a[] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> { {</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"aaa"</span><span style="color: #ABB2BF">},{</span><span style="color: #D19A66">8</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"bbb"</span><span style="color: #ABB2BF">},{</span><span style="color: #D19A66">21</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"ccc"</span><span style="color: #ABB2BF">},{</span><span style="color: #D19A66">87</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"ddd"</span><span style="color: #ABB2BF">},{</span><span style="color: #D19A66">56</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"eee"</span><span style="color: #ABB2BF">},{</span><span style="color: #D19A66">4</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"fff"</span><span style="color: #ABB2BF">},{</span><span style="color: #D19A66">11</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"ggg"</span><span style="color: #ABB2BF">},{</span><span style="color: #D19A66">3</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"hhh"</span><span style="color: #ABB2BF">},{</span><span style="color: #D19A66">22</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"iii"</span><span style="color: #ABB2BF">},{</span><span style="color: #D19A66">7</span><span style="color: #ABB2BF">,</span><span style="color: #98C379">"jjj"</span><span style="color: #ABB2BF">} };</span></span><span class="line"><span style="color: #ABB2BF">    binarySearchTree</span><span style="color: #C678DD">&lt;int</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">char</span><span style="color: #56B6C2">*</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> tree;</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;int</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">char</span><span style="color: #56B6C2">*</span><span style="color: #C678DD">&gt;</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> p; </span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;int</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">char</span><span style="color: #56B6C2">*</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tree</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">a</span><span style="color: #ABB2BF">[i]);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tree</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">21</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (p) {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Find 21: "</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">other</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"21 not found"</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">tree</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">21</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tree</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">21</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (p) {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Find 21: "</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">other</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"21 not found"</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="avl-树">AVL 树</h2><h3 id="avl-树二叉平衡树的定义">AVL 树（二叉平衡树）的定义</h3><ul><li>二叉平衡树是满足某个平衡条件的二叉查找树，其保证树的高度是 <span class="math inline"><em>O</em>(log <em>N</em>)</span>，从而操作都是<span class="math inline"><em>O</em>(log <em>N</em>)</span></li><li>最理想是每个节点的左右子树都有同样的高度，不过条件可以放宽一些，因此有了二叉平衡查找树</li><li><strong>平衡因子（平衡度）</strong>：结点的平衡度是结点的左子树的高度减去右子树的高度<ul><li>要求每个结点的平衡因子都为 <span class="math inline">+1, −1, 0</span>，即每个结点的左右子树的高度最多差<span class="math inline">1</span></li><li>一棵由 <span class="math inline"><em>N</em></span> 个结点组成的 AVL树的高度 <span class="math inline"><em>H</em> ≤ 1.44log (<em>N</em> + 1) − 0.328</span></li></ul></li></ul><h3 id="avl-树的实现">AVL 树的实现</h3><ul><li>采用二叉链表存储<ul><li>每个结点包含以下字段<ul><li>数据<ul><li>键值-数据对</li><li>节点高度</li></ul></li><li>左、右子结点指针</li></ul></li></ul></li><li><strong>运算实现</strong><ul><li><p>查找：与二叉查找树相同</p></li><li><p><strong>插入</strong>：插入结点后检查到根结点路径上的平衡性，如果没破坏平衡性，可以直接插入，然后自下而上修改结点平衡度（若有结点平衡度没变，上面的就都不用修改）；如果破坏了平衡性，则需要调整树的结构（单旋转or双旋转），再修改平衡度</p><ul><li>插入方法：LL和RR、LR和RL是对称的</li><li>LL/RR：插入在危机结点的左子结点的左子树/右子结点的右子树，进行单旋转</li></ul><figure><img src="image-30.webp" srcset="/img/loading/loading3.gif" lazyload alt="LL!"><figcaption aria-hidden="true">LL!</figcaption></figure><ul><li>LR/RL：插入在危机结点的左子结点的右子树/右子结点的左子树，进行双旋转<ul><li>LR：先对危机结点的左子树执行RR，再对危机结点自身执行LL</li><li>RL：先对危机结点的右子树执行LL，再对危机结点自身执行RR</li></ul></li></ul><figure><img src="image-31.webp" srcset="/img/loading/loading3.gif" lazyload alt="LR"><figcaption aria-hidden="true">LR</figcaption></figure></li><li><p><strong>删除</strong>：删除结点后检查到根结点路径上的平衡性，共分五种情况：</p><figure><img src="image-32.webp" srcset="/img/loading/loading3.gif" lazyload alt="删除的五种情况"><figcaption aria-hidden="true">删除的五种情况</figcaption></figure></li></ul></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"9-1-dynamicSearchTable.h"</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF"> : </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dynamicSearchTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">AvlTree</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">~AvlTree</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlNode</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> data;</span></span><span class="line"><span style="color: #ABB2BF">        AvlNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> left;</span></span><span class="line"><span style="color: #ABB2BF">        AvlNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> right;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> height;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">AvlNode</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">thedata</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">l</span><span style="color: #C678DD">=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">r</span><span style="color: #C678DD">=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">h</span><span style="color: #C678DD">=</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            : </span><span style="color: #61AFEF">data</span><span style="color: #ABB2BF">(thedata), </span><span style="color: #61AFEF">left</span><span style="color: #ABB2BF">(l), </span><span style="color: #61AFEF">right</span><span style="color: #ABB2BF">(r), </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(h) {}</span></span><span class="line"><span style="color: #ABB2BF">    };</span></span><span class="line"><span style="color: #ABB2BF">    AvlNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> root;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">LL</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">LR</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">RL</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">RR</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> { </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">max</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">a</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">b</span><span style="color: #ABB2BF">) { </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> a </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> b </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> a </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> b; }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">subTree</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">AvlTree</span><span style="color: #ABB2BF">() </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    root </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">AvlTree&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #56B6C2">~</span><span style="color: #61AFEF">AvlTree</span><span style="color: #ABB2BF">() </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    AvlNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> root;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> x) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (x </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> (SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">)t;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(x, root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">AvlNode</span><span style="color: #ABB2BF">(x, </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(t, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">left</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #61AFEF">LL</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">                } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #61AFEF">LR</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(t, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">right</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #61AFEF">RR</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">                } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #61AFEF">RL</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">max</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">), </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">)) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(x, root);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (x </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            AvlNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> oldNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> t;</span></span><span class="line"><span style="color: #ABB2BF">            t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> oldNode;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        } </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            AvlNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">)) </span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(t, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (x </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">)) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(t, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">)) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(t, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">adjust</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">subTree</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (subTree) </span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">           </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">)) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">--</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">left</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">left</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">)) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">LR</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">LL</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">)) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">)) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">--</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">right</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">right</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">)) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">RL</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">RR</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">)) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }       </span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (t </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">makeEmpty</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> t;</span></span><span class="line"><span style="color: #ABB2BF">    t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">LL</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    AvlNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> l </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">l</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">l</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> t;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">max</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">), </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">)) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">l</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">max</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">l</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">), </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> l;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">LR</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">RR</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">LL</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">RL</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">LL</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">RR</span><span style="color: #ABB2BF">(t);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">AvlTree</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">RR</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">AvlNode</span><span style="color: #C678DD">*&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">t</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    AvlNode</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> r </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">r</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">r</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> t;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">max</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">left</span><span style="color: #ABB2BF">), </span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">)) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">r</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">max</span><span style="color: #ABB2BF">(</span><span style="color: #61AFEF">height</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">r</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">right</span><span style="color: #ABB2BF">), </span><span style="color: #E5C07B">t</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    t </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> r;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="散列表">散列表</h2><h3 id="散列表的定义">散列表的定义</h3><ul><li>散列表的思想是用一个比集合规模略大的数组来存储这个集合，将数据元素关键字映射到这个数组的下标<ul><li>这个映射成为<strong>散列函数</strong></li><li>散列函数的定义域范围大于值域，可能发生冲突/碰撞</li></ul></li></ul><h3 id="散列函数">散列函数</h3><ul><li><strong>直接定址法</strong>：去关键字值或其线性函数值作为散列地址</li><li><strong>除留余数法</strong>：如果 <span class="math inline"><em>M</em></span> 是散列表的大小，关键字为 <span class="math inline"><em>x</em></span>，则散列地址为 <span class="math inline"><em>H</em>(<em>x</em>) = <em>x</em> mod &nbsp;<em>M</em></span>，常选<span class="math inline"><em>M</em></span> 为素数，使其分布更均匀</li><li><strong>数字分析法</strong>：对关键字集合中的所有关键字，分析每一位上数字分布，取关键字的某一部分（数字分布均匀的位）进行映射</li><li><strong>平方取中法</strong>：如果关键字中各位的分布都比较均匀，但关键字的值域比数组规模大，则可以将关键字平方后，取其结果的中间各位作为散列函数值</li><li><strong>折叠法</strong>：关键字相当长，以至于和散列表的单元总数相比大得多时，可选取一个长度后，将关键字按此长度分组相加</li></ul><h3 id="闭散列表">闭散列表</h3><p>将溢出数据元素存放到没有使用过的单元中</p><ul><li><strong>线性探测法</strong>：<ul><li>插入：当散列发生冲突时，探测下一个单元，直到发现一个空单元，即 <span class="math inline"><em>H</em>, <em>H</em> + 1, <em>H</em> + 2, <em>H</em> + 3, ⋯</span></li><li>查找：算出来位置之后，找不到的话就向后查找，直到找到或者遇到空单元</li><li>删除：采用迟删除，标记该单元活动/被删除</li><li>缺点：可能产生<strong>初始聚集</strong></li></ul></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"9-1-dynamicSearchTable.h"</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">closeHashTable</span><span style="color: #ABB2BF"> : </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dynamicSearchTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> data;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> state;</span><span style="color: #7F848E; font-style: italic"> // 0: empty, 1: active, 2: deleted</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">() { state </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"><span style="color: #ABB2BF">        node</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> array;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> (*</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">)(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">static</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">defaultKey</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">k</span><span style="color: #ABB2BF">) { </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> k; }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">closeHashTable</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">length</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">101</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> (*</span><span style="color: #E06C75; font-style: italic">f</span><span style="color: #ABB2BF">)(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> defaultKey);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~closeHashTable</span><span style="color: #ABB2BF">() { </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">[]</span><span style="color: #ABB2BF"> array; }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">closeHashTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">closeHashTable</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> length, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">f)(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> KEY</span><span style="color: #56B6C2">&amp;</span><span style="color: #ABB2BF"> x)) </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    size </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> length;</span></span><span class="line"><span style="color: #ABB2BF">    array </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">[size];</span></span><span class="line"><span style="color: #ABB2BF">    key </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> f;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">closeHashTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> initPos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">key</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> initPos;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">do</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E06C75">state</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E06C75">state</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E06C75">data</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        } </span></span><span class="line"><span style="color: #ABB2BF">        pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (pos </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (pos </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> initPos);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">closeHashTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> initPos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">key</span><span style="color: #ABB2BF">(x) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> initPos;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">do</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E06C75">state</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E06C75">state</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> x) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E06C75">state</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (pos </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (pos </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> initPos);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span><span style="color: #C678DD">*</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">closeHashTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #C678DD">&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> initPos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">key</span><span style="color: #ABB2BF">(x) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> initPos;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">do</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E06C75">state</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E06C75">state</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos].</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> x) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> (SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">)</span><span style="color: #56B6C2">&amp;</span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos];</span></span><span class="line"><span style="color: #ABB2BF">        pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (pos </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (pos </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> initPos);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><ul><li><strong>二次探测法</strong>：<ul><li>当散列发生冲突时，检查远离初始探测点的某一单元，即 <span class="math inline"><em>H</em>, <em>H</em> + 1<sup>2</sup>, <em>H</em> + 2<sup>2</sup>, <em>H</em> + 3<sup>2</sup>, ⋯</span></li><li>定理：使用二次探测法且表的大小是一个素数，则如果表至少有一半空单元，新的元素总能被插入，且插入过程中没有一个单元被探测两次</li><li>动态扩展：当负载因子超过 <span class="math inline">0.5</span>时，需要把数组扩大一倍，并且进行<strong>重新散列</strong>（新的数组隐含新的散列函数）</li></ul></li><li><strong>再散列法</strong>：<ul><li>两个散列函数 <span class="math inline"><em>H</em><sub>1</sub>, <em>H</em><sub>2</sub></span>，分别用于计算探测序列的起始地址和下一个探测的步长，即<span class="math inline"><em>H</em><sub>1</sub>(<em>x</em>), <em>H</em><sub>1</sub>(<em>x</em>) + <em>H</em><sub>2</sub>(<em>x</em>), <em>H</em><sub>1</sub>(<em>x</em>) + 2<em>H</em><sub>2</sub>(<em>x</em>), <em>H</em><sub>1</sub>(<em>x</em>) + 3<em>H</em><sub>2</sub>(<em>x</em>), ⋯</span></li></ul></li></ul><h3 id="开散列表拉链表">开散列表/拉链表</h3><figure><img src="image-33.webp" srcset="/img/loading/loading3.gif" lazyload alt="开散列表"><figcaption aria-hidden="true">开散列表</figcaption></figure><p>将具有相同散列地址的碰撞结点存储在一个单链表中，散列表中的 <span class="math inline"><em>k</em></span> 号单元保存的是指向散列地址同为<span class="math inline"><em>k</em></span>的链表的第一个结点的地址。</p><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"9-1-dynamicSearchTable.h"</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">openHashTable</span><span style="color: #ABB2BF"> : </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">dynamicSearchTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">node</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> data;</span></span><span class="line"><span style="color: #ABB2BF">            node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">next;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">d</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">n</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> d;</span></span><span class="line"><span style="color: #ABB2BF">                next </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> n;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                next </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        node </span><span style="color: #56B6C2">**</span><span style="color: #ABB2BF">array;</span><span style="color: #7F848E; font-style: italic">//指针数组</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> (*</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">)(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span><span style="color: #7F848E; font-style: italic">//函数指针</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">static</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">defaultKey</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">openHashTable</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">length</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">101</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> (*</span><span style="color: #E06C75; font-style: italic">f</span><span style="color: #ABB2BF">)(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> defaultKey);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~openHashTable</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">openHashTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">openHashTable</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> length, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">f)(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> KEY </span><span style="color: #56B6C2">&amp;</span><span style="color: #ABB2BF">x))</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    size </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> length;</span></span><span class="line"><span style="color: #ABB2BF">    array </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> node</span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">[size];</span></span><span class="line"><span style="color: #ABB2BF">    key </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> f;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> size; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">openHashTable&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #56B6C2">~</span><span style="color: #61AFEF">openHashTable</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">q;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> size; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            q </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> []array;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E5C07B">openHashTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> pos;</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"><span style="color: #ABB2BF">    pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">key</span><span style="color: #ABB2BF">(x) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> x) p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> (SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">)p;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">openHashTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> pos;</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"><span style="color: #ABB2BF">    pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">key</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">x</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(x, </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos]);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">openHashTable</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> pos;</span></span><span class="line"><span style="color: #ABB2BF">    node </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">q;</span></span><span class="line"><span style="color: #ABB2BF">    pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">key</span><span style="color: #ABB2BF">(x) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> size;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos]-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> x)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">array</span><span style="color: #ABB2BF">[pos] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">next</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> x) p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        q </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h1 id="排序">排序</h1><h2 id="排序的基本概念">排序的基本概念</h2><ul><li><strong>排序</strong>：把集合中的数据元素按照它们的<strong>关键字</strong>的非递减或非递增序排成一个序列</li><li><strong>稳定排序与非稳定排序</strong>：多个关键字值相同的数据元素经过排序后，这些数据元素的相对次序保持不变，则稳定，反之则不稳定</li><li><strong>内排序与外排序</strong>：<ul><li>内排序是指被排序的数据元素全部存放在计算机的内存之中，并且在内存中调整数据元素的相对位置。</li><li>外排序是指在排序的过程中，数据元素主要存放在外存储器中，借助于内存储器逐步调整数据元素之间的相对位置。</li></ul></li></ul><h2 id="插入排序">插入排序</h2><p>首先将由第一个数据元素组成的序列看成是有序的，然后将剩余的 <span class="math inline"><em>n</em> − 1</span>个元素依次<strong>插入</strong>到前面的已排好序的子序列中去，使得每次插入后的子序列也是有序的。</p><figure><img src="image-34.webp" srcset="/img/loading/loading3.gif" lazyload alt="插入排序"><figcaption aria-hidden="true">插入排序</figcaption></figure><h3 id="直接插入排序">直接插入排序</h3><ul><li>时间复杂度：<ul><li>最好情况：<span class="math inline"><em>O</em>(<em>N</em>)</span></li><li>最坏情况、平均情况：<span class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span></li></ul></li><li>空间复杂度：<span class="math inline"><em>O</em>(1)</span></li><li>稳定</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//直接插入排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">simpleInsertSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> k;</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> size; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (k </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; k </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> tmp </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k]; k</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k];</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="二分排序">二分排序</h3><ul><li>二分插入排序是直接插入排序的改进版，利用二分查找来确定插入位置</li><li>时间复杂度（平均）：<ul><li>比较次数：<span class="math inline"><em>O</em>(<em>N</em>log <em>N</em>)</span></li><li>移动次数：<span class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span></li><li>总体时间复杂度：<span class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span></li></ul></li><li>空间复杂度：<span class="math inline"><em>O</em>(1)</span></li><li>稳定</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//二分插入排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">binaryInsertSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> left, right, mid;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> size; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">        left </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        right </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        //二分查找插入位置</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (left </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> right) {</span></span><span class="line"><span style="color: #ABB2BF">            mid </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (left </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> right) </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[mid].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                left </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> mid </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">                right </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> mid </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">        //将元素向后移动</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> k </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; k </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> left; k</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k];</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[left] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="希尔排序">希尔排序</h3><ul><li>希尔排序是直接插入排序的改进版，先将待排序序列分成若干个子序列分别进行直接插入排序，然后再对全体记录进行一次直接插入排序</li><li>时间复杂度：取决于步长序列的选取，一般情况下为<span class="math inline"><em>O</em>(<em>N</em><sup>1.3</sup>)</span>到<span class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span>之间</li><li>不稳定</li></ul><figure><img src="image-35.webp" srcset="/img/loading/loading3.gif" lazyload alt="希尔排序"><figcaption aria-hidden="true">希尔排序</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//希尔排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">shellSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> step </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">; step </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; step </span><span style="color: #C678DD">/=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">) {</span><span style="color: #7F848E; font-style: italic">//步长</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> step; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> size; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> k </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> step; k </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">; k </span><span style="color: #C678DD">-=</span><span style="color: #ABB2BF"> step) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> step] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k];</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[k </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> step] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="选择排序">选择排序</h2><p>从 <span class="math inline"><em>n</em></span>个元素开始，每次从剩下的元素序列中<strong>选择</strong>关键字最小/最大的元素，依此类推，直至序列中最后只剩下一个元素为止。这样，把每次得到的元素排成一个序列，就得到了按非递减序排列的排序序列。</p><h3 id="直接选择排序">直接选择排序</h3><ul><li>时间复杂度：<span class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span></li><li>空间复杂度：<span class="math inline"><em>O</em>(1)</span></li><li>不稳定</li></ul><figure><img src="image-36.webp" srcset="/img/loading/loading3.gif" lazyload alt="直接选择排序"><figcaption aria-hidden="true">直接选择排序</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//直接选择排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">simpleSelectSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> min;</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> size </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        min </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> i </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> size; j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[min]) {</span></span><span class="line"><span style="color: #ABB2BF">                min </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> j;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (min </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> i) {</span></span><span class="line"><span style="color: #ABB2BF">            tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[min];</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[min] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="堆排序">堆排序</h3><ul><li>时间复杂度：<span class="math inline"><em>O</em>(<em>N</em>log <em>N</em>)</span></li><li>空间复杂度：<span class="math inline"><em>O</em>(1)</span></li><li>不稳定</li></ul><figure><img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload alt="堆排序"><figcaption aria-hidden="true">堆排序</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//堆排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">heapSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">perccolateDown</span><span style="color: #ABB2BF">(SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">data, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> hole, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> size);</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    //建立最大堆</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">perccolateDown</span><span style="color: #ABB2BF">(data, i, size);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    //删除最大堆顶</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">perccolateDown</span><span style="color: #ABB2BF">(data, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, i);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">perccolateDown</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">hole</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> child;</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[hole];</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (; hole </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> size; hole </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> child) {</span></span><span class="line"><span style="color: #ABB2BF">        child </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> hole </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (child </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> size </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[child].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[child </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            child</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[child].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[hole] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[child];</span></span><span class="line"><span style="color: #ABB2BF">        } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">break</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[hole] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="交换排序">交换排序</h2><p>根据序列中两个数据元素的比较结果来确定是否要<strong>交换</strong>这两个数据元素在序列中的位置。通过交换，将关键字值较大的数据元素向序列的尾部移动，关键字值较小的数据元素向序列的头部移动。</p><h3 id="冒泡排序">冒泡排序</h3><ul><li>时间复杂度：<ul><li>最好情况：<span class="math inline"><em>O</em>(<em>N</em>)</span></li><li>最坏、平均情况：<span class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span></li></ul></li><li>空间复杂度：<span class="math inline"><em>O</em>(1)</span></li><li>稳定</li></ul><figure><img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload alt="冒泡排序"><figcaption aria-hidden="true">冒泡排序</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//冒泡排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">bubbleSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> flag </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span><span style="color: #7F848E; font-style: italic">//标记是否有交换</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> size </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> flag; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        flag </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> i; j</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">].</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j];</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">                flag </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="快速排序">快速排序</h3><ul><li>快速排序是交换排序的一种，采用分治法的思想，将待排序序列分成两个子序列，使得左子序列的所有元素都小于或等于右子序列的所有元素，然后对这两个子序列递归进行快速排序</li><li>时间复杂度：<ul><li>最好情况：<span class="math inline"><em>O</em>(<em>N</em>log <em>N</em>)</span></li><li>最坏情况：<span class="math inline"><em>O</em>(<em>N</em><sup>2</sup>)</span></li><li>平均情况：<span class="math inline"><em>O</em>(<em>N</em>log <em>N</em>)</span></li></ul></li><li>不稳定</li></ul><figure><img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload alt="快速排序"><figcaption aria-hidden="true">快速排序</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//快速排序的划分函数</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">divide</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">low</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">high</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> k </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[low];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">do</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (low </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> high </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[high] </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> k) </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">high;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (low </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> high) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[low] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[high];</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">low;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (low </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> high </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[low] </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> k) </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">low;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (low </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> high) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[high] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[low];</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">high;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (low </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> high);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[low] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> k;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> low;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">//快速排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">quickSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">low</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">high</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> mid;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (low </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> high) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span><span style="color: #7F848E; font-style: italic">//递归结束</span></span><span class="line"><span style="color: #ABB2BF">    mid </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">divide</span><span style="color: #ABB2BF">(data, low, high);</span><span style="color: #7F848E; font-style: italic">//一分为二</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">quickSort</span><span style="color: #ABB2BF">(data, low, mid </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span><span style="color: #7F848E; font-style: italic">//对低子表递归排序</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">quickSort</span><span style="color: #ABB2BF">(data, mid </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, high);</span><span style="color: #7F848E; font-style: italic">//对高子表递归排序</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">//快速排序的封装函数</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">quickSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">quickSort</span><span style="color: #ABB2BF">(data, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, size </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">//快速排序非递归实现</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">quickSort2</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    stack</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> s;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> low </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, high </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> size </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> mid;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (low </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> high) {</span></span><span class="line"><span style="color: #ABB2BF">        mid </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">divide</span><span style="color: #ABB2BF">(data, low, high);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (low </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> mid </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(low);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(mid </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (mid </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> high) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(mid </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(high);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">()) {</span></span><span class="line"><span style="color: #ABB2BF">            high </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            low </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            mid </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">divide</span><span style="color: #ABB2BF">(data, low, high);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (low </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> mid </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(low);</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(mid </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (mid </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> high) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(mid </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(high);</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="归并排序">归并排序</h2><p>归并排序的思想来源于合并两个已排序的有序表时，只需要从两个表的表头开始比较，将较小的元素放入结果表中，直到一个表为空，然后将另一个表中剩余的元素全部放入结果表中。</p><ul><li>时间复杂度：<span class="math inline"><em>O</em>(<em>N</em>log <em>N</em>)</span></li><li>空间复杂度：<span class="math inline"><em>O</em>(<em>N</em>)</span></li><li>稳定</li></ul><figure><img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload alt="归并排序"><figcaption aria-hidden="true">归并排序</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//归并排序的合并函数</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">merge</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">left</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">mid</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">right</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF">[right </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> left </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> pos </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> left, j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> mid;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> mid </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> right)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j])</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[pos</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">else</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[pos</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> mid)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[pos</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (j </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> right)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[pos</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> pos; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">[left </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete[]</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">//归并排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">left</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">right</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (left </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> right)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> mid </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (left </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> right) </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">mergeSort</span><span style="color: #ABB2BF">(data, left, mid);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">mergeSort</span><span style="color: #ABB2BF">(data, mid </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, right);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">merge</span><span style="color: #ABB2BF">(data, left, mid </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, right);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">//归并排序的封装函数</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">mergeSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">size</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">mergeSort</span><span style="color: #ABB2BF">(data, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, size </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="基数排序">基数排序</h2><p>又称为口袋排序法，通过分配的方法对整数进行排序。基数排序的基本思想是将整数按位切割成不同的数字，然后按每个位数分别比较。- 时间复杂度：<span class="math inline"><em>O</em>(<em>l</em><em>e</em><em>n</em> ⋅ (<em>N</em> + <em>k</em>))</span>，其中<span class="math inline"><em>l</em><em>e</em><em>n</em></span>是关键字的位数，<span class="math inline"><em>k</em></span>是基数（即每一位的取值范围/进制数） - 空间复杂度：<span class="math inline"><em>O</em>(1)</span></p><figure><img src="image-41.webp" srcset="/img/loading/loading3.gif" lazyload alt="基数排序"><figcaption aria-hidden="true">基数排序</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//基数排序的辅助结点</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">node</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    SET</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> data;</span></span><span class="line"><span style="color: #ABB2BF">    node</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">next;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">() {next </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;}</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">node</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">&amp;</span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">node</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">N</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> x;</span></span><span class="line"><span style="color: #ABB2BF">        next </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> N;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">//基数排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">bukketSort</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">SET</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">KEY</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">OTHER</span><span style="color: #ABB2BF">&gt; </span><span style="color: #C678DD">*&amp;</span><span style="color: #E06C75; font-style: italic">data</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    node</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">KEY, OTHER</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #E5C07B">bukket</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">], </span><span style="color: #56B6C2">*</span><span style="color: #E5C07B">last</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">], </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tail;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i, j, k;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> base </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, max </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, len </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (tail </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> data; tail </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; tail </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tail</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">tail</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> max)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            max </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">tail</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span><span style="color: #7F848E; font-style: italic">//找到最大值</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (max </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        len </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (max </span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            max </span><span style="color: #C678DD">/=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            len</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span><span style="color: #7F848E; font-style: italic">//找到最大值的位数</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, base </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;=</span><span style="color: #ABB2BF"> len; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">, base </span><span style="color: #C678DD">*=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">; j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">bukket</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">last</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (data </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            k </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">key</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> base) </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">bukket</span><span style="color: #ABB2BF">[k] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">bukket</span><span style="color: #ABB2BF">[k] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">last</span><span style="color: #ABB2BF">[k] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> data;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">else</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">last</span><span style="color: #ABB2BF">[k]-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> data;</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">last</span><span style="color: #ABB2BF">[k] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> data;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">data</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #ABB2BF">; j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">bukket</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (data </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                {</span></span><span class="line"><span style="color: #ABB2BF">                    data </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">bukket</span><span style="color: #ABB2BF">[j];</span></span><span class="line"><span style="color: #ABB2BF">                    tail </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">last</span><span style="color: #ABB2BF">[j];</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">else</span></span><span class="line"><span style="color: #ABB2BF">                {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">tail</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">bukket</span><span style="color: #ABB2BF">[j];</span></span><span class="line"><span style="color: #ABB2BF">                    tail </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">last</span><span style="color: #ABB2BF">[j];</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tail</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h1 id="外部查找与排序">外部查找与排序</h1><h2 id="主存储器与外存储器">主存储器与外存储器</h2><ul><li><strong>主存储器</strong>：也被称为内存，是存储正在运行的程序代码及处理数据。</li><li><strong>外存储器</strong>：用于存储长期保存的信息。常用的外存储器有磁盘、磁带、光盘、U盘等，访问速度慢，故需考虑减少访问次数。<ul><li>外存储器中的信息以文件为单位。每个文件在内存有一个缓冲区存放正在处理的文件中的数据</li><li>外存储器以数据块为单位与内存交换信息。当程序需要处理外存储器中的某个数据，则将包含该数据的数据块读入缓冲区进行处理</li></ul></li></ul><h2 id="b-树">B 树</h2><h3 id="b-树的定义">B 树的定义</h3><p>一棵 <span class="math inline"><em>m</em></span> 阶 B树或者为空，或者满足以下条件。</p><ol type="1"><li><p>根结点要么是叶子，要么至少有两个儿子，至多有 <span class="math inline"><em>m</em></span> 个儿子。</p></li><li><p>除根结点和叶子结点之外，每个结点的儿子个数 <span class="math inline"><em>s</em></span> 满足<span class="math inline">⌈<em>m</em>/2⌉ ≤ <em>s</em> ≤ <em>m</em></span>。</p></li><li><p>有 <span class="math inline"><em>s</em></span>个儿子的非叶结点具有<span class="math inline"><em>n</em> = <em>s</em> − 1</span>个关键字，故<span class="math inline"><em>s</em> = <em>n</em> + 1</span>。这些结点的数据信息为<br><span class="math display">(<em>n</em>, <em>A</em><sub>0</sub>, (<em>K</em><sub>1</sub>, <em>R</em><sub>1</sub>), <em>A</em><sub>1</sub>, (<em>K</em><sub>2</sub>, <em>R</em><sub>2</sub>), <em>A</em><sub>2</sub>, ⋯, (<em>K</em><sub><em>n</em></sub>, <em>R</em><sub><em>n</em></sub>), <em>A</em><sub><em>n</em></sub>)</span></p><p>其中：</p><ul><li><span class="math inline"><em>n</em></span>: 关键字的个数</li><li><span class="math inline"><em>K</em><sub>1</sub>, <em>K</em><sub>2</sub>, ⋯, <em>K</em><sub><em>n</em></sub></span>:结点的关键字，且<span class="math inline"><em>K</em><sub>1</sub> &lt; <em>K</em><sub>2</sub>⋯ &lt; <em>K</em><sub><em>n</em></sub></span></li><li><span class="math inline"><em>A</em><sub>0</sub></span>: B树中小于<span class="math inline"><em>K</em><sub>1</sub></span>的结点的地址<br></li><li><span class="math inline"><em>R</em><sub><em>j</em></sub></span>:关键字值等于<span class="math inline"><em>K</em><sub><em>j</em></sub>(1 ≤ <em>j</em> ≤ <em>n</em>)</span>的数据记录在硬盘中的地址</li><li><span class="math inline"><em>A</em><sub><em>j</em></sub></span>: B树中大于<span class="math inline"><em>K</em><sub><em>j</em></sub></span>且小于<span class="math inline"><em>K</em><sub><em>j</em> + 1</sub>(1 ≤ <em>j</em> ≤ <em>n</em> − 1)</span>的结点的地址</li><li><span class="math inline"><em>A</em><sub><em>n</em></sub></span>: B树中大于<span class="math inline"><em>K</em><sub><em>n</em></sub></span>的结点的地址</li></ul></li><li><p>所有的叶子结点都出现在同一层上，即它们的深度相同，并且不带信息(可以认为是外部结点或查找失败的结点，这些结点并不存在，指向这些结点的指针为空)。</p></li></ol><figure><img src="image-42.webp" srcset="/img/loading/loading3.gif" lazyload alt="一棵五阶 B 树"><figcaption aria-hidden="true">一棵五阶 B 树</figcaption></figure><h3 id="b-树的查找">B 树的查找</h3><p>B 树的查找过程与二叉查找树类似，但由于 B树的每个结点可以有多个关键字，因此查找过程需要在结点内部进行线性查找。</p><ol type="1"><li>从根结点开始，比较要查找的关键字与根结点的关键字。</li><li>如果找到相等的关键字，则查找成功。</li><li>如果要查找的关键字在根结点关键字之间，则继续在根结点的某个子树中查找。</li><li>重复以上步骤，直到找到关键字或到达叶子结点。</li></ol><h3 id="b-树的插入">B 树的插入</h3><p>首先在 <span class="math inline"><em>m</em></span> 阶 B树上进行查找操作，确定新插入的关键字 key在最底层的非叶结点的插入位置，将 key和其他信息按序插入最底层上的某个结点。</p><ul><li>若被插入结点的关键字个数小于 <span class="math inline"><em>m</em> − 1</span> ，则插入操作结束</li><li>若该结点原有的关键字个数已经等于 <span class="math inline"><em>m</em> − 1</span> ，必须分裂成两个结点</li></ul><figure><img src="image-43.webp" srcset="/img/loading/loading3.gif" lazyload alt="插入39"><figcaption aria-hidden="true">插入39</figcaption></figure><h3 id="b-树的删除">B 树的删除</h3><p>类似二叉查找树的删除操作，从根结点开始查找与给定关键字值 key相等的关键字 <span class="math inline"><em>K</em><sub><em>i</em></sub></span>。关键字 <span class="math inline"><em>K</em><sub><em>i</em></sub></span>可能出现在第一层到最底层之间的任何一个结点上，计有以下几种情况:</p><ol type="1"><li>如果关键字 <span class="math inline"><em>K</em><sub><em>i</em></sub></span>在最底层，可直接删除，转 (3) 。</li><li>否则，先找到“替身”。用它的右子树中的最左面的结点的关键字值，即处于最底层上的最小关键字值取代。然后，删除最底层上的该关键字。</li><li>从最底层开始进行删除相应关键字的操作，计有以下几种情况：<ul><li>若删除关键字之后，结点的关键字的个数仍处于 <span class="math inline">[⌈<em>m</em>/2⌉ − 1, <em>m</em> − 1]</span>之间，仍满足 B 树的结点的定义，删除结束。</li><li>若结点的关键字的个数原为 <span class="math inline">[⌈<em>m</em>/2⌉ − 1]</span>，若再删除一个关键字，将不符合B 树定义。如果该结点的左或右兄弟结点的关键字的个数大于 <span class="math inline">[⌈<em>m</em>/2⌉ − 1]</span>，则借一个关键字过来。必须注意的是，并不是直接将左或右兄弟结点的关键字取过来，因为这样将无法保证结点的关键字有序。如果是借左兄弟结点的最大关键字，则必须将该关键字上移到父结点的相应位置，而将父结点中大于该关键字且最接近该关键字的那个关键字（连同左兄弟结点的最右方的指针<span class="math inline"><em>A</em><sub><em>n</em></sub></span>）下移到被删关键字所在结点的最左面，删除操作结束。若借右兄弟结点的最小关键字，操作类似。</li><li>若该结点的左或右兄弟结点的关键字的个数都为 <span class="math inline">[⌈<em>m</em>/2⌉ − 1]</span>，那么将无结点可借。这时只能执行合并结点的操作。将该结点同左兄弟（无左兄弟时，与右兄弟）合并。由于两个结点合并后，父结点中相应的关键字将不再保留，因为它原来的左右儿子已经不存在，因此，把父结点中该关键字也并入合并后的结点。这样，父结点的关键字个数便减少了一个。如果父结点的关键字个数不满足定义，则必须继续调整。在最坏情况下，调整可能会一直波及到根结点，导致B 树的高度减少 1，即减少一层。</li></ul></li></ol><figure><img src="image-44.webp" srcset="/img/loading/loading3.gif" lazyload alt="删除31"><figcaption aria-hidden="true">删除31</figcaption></figure><h3 id="b-树占用空间的情况">B 树占用空间的情况</h3><p>将一个磁盘块作为一个B树的结点。假设一个块的容量 <span class="math inline"><em>m</em><em>a</em><em>x</em></span>字节，如果每个键要占用 <span class="math inline"><em>k</em><em>e</em><em>y</em></span> 个字节。在一棵<span class="math inline"><em>M</em></span> 阶 B 树中，可以有 <span class="math inline"><em>M</em> − 1</span> 个键，总的数据量是：</p><p><span class="math display">(<em>M</em> − 1) * <em>k</em><em>e</em><em>y</em> + <em>M</em><em>个</em><em>分</em><em>支</em><em>的</em><em>地</em><em>址</em> + <em>M</em> − 1<em>个</em><em>关</em><em>键</em><em>字</em><em>对</em><em>应</em><em>记</em><em>录</em><em>的</em><em>存</em><em>储</em><em>地</em><em>址</em></span></p><h2 id="b-树-1">B+ 树</h2><h3 id="b-树的定义-1">B+ 树的定义</h3><ul><li>B 树不适合顺序访问</li><li>B+ 树既能提供随机查找，也能提供顺序访问的存储结构。<ul><li>B+ 树的所有关键字都在叶子结点中，并且叶子结点之间通过指针相连</li></ul></li><li>一棵 <span class="math inline"><em>M</em></span> 阶的 B+树被定义为具有以下性质的 <span class="math inline"><em>M</em></span>叉树：<ol type="1"><li>根或者是叶子，或者有 <span class="math inline">2</span> 到 <span class="math inline"><em>M</em></span> 个孩子。</li><li>除根之外所有结点都有不少于 <span class="math inline">⌈<em>M</em>/2⌉</span> 且不多于 <span class="math inline"><em>M</em></span> 个孩子。</li><li>有 <span class="math inline"><em>K</em></span> 个孩子的结点保存了<span class="math inline"><em>K</em> − 1</span> 个键来引导查找，键 <span class="math inline">1</span> 代表了子树 <span class="math inline"><em>i</em> + 1</span> 中键的最小值。</li><li>叶结点中的孩子指针指向存储记录的数据块的地址。换句话说，对于索引 B+树，它们是叶结点。但对于数据块来说，它们又是数据块的父结点。数据块才是真正的叶结点。而在B 树中，叶结点的孩子指针都是空指针。</li><li>每个数据块至少有 <span class="math inline">⌈<em>L</em>/2⌉</span>个记录，至多有 <span class="math inline"><em>L</em></span> 个记录。</li><li>所有的叶结点按序连成一个单链表。</li></ol></li><li>B+ 树存储两个指针<ul><li>指向树根的指针，提供了索引查找</li><li>指向关键字最小的叶结点，提供顺序访问</li></ul></li></ul><figure><img src="image-45.webp" srcset="/img/loading/loading3.gif" lazyload alt="一棵五阶 B+ 树"><figcaption aria-hidden="true">一棵五阶 B+ 树</figcaption></figure><h3 id="b-树的查找-1">B+ 树的查找</h3><p>与二叉查找树类似，在 B+树上查找某一条记录也是从根结点开始，根据结点中的键值决定查找哪一棵子树。一层一层往下找，直到找到该记录应该存放的数据块。在数据块中查找被查找的记录，找到了则表示查找成功，没有找到则表示该记录不存在。</p><h3 id="b-树的插入-1">B+ 树的插入</h3><p>从根结点开始查找插入的位置，把它插入相应的数据块中：</p><ul><li>若存放被插入记录的数据块还没有放满：直接插入</li><li>若已满：分裂叶结点<ul><li>若父结点也已满，则继续向上分裂，直至父亲直到不需要再分裂或者到达了根结点。若到达根结点，则重新建立一个根，让这两个分裂出来的根做它的两个子结点</li></ul></li></ul><figure><img src="image-46.webp" srcset="/img/loading/loading3.gif" lazyload alt="依次插入7、22、41"><figcaption aria-hidden="true">依次插入7、22、41</figcaption></figure><h3 id="b-树的删除-1">B+ 树的删除</h3><p>删除操作首先查找到要删除的项，然后删除它。</p><ul><li>如果此时它所在的叶子的元素数量正好满足要求的最小值，删除该项就会使它低于最小值<ul><li>如果邻居不是最少的情况，就借一个过来领养；<ul><li>如果邻居也处于最少的情况，就把两个结点合并成一个满的结点。</li><li>在这种情况下父亲就失去了一个儿子。如果它引起父亲的儿子数少于了最小值，则需要一直向上进行过滤到根。</li><li>如果根只剩下了一个儿子，就把根删除，让它的儿子作为新的树根，这也是唯一能使B树变矮的情况。</li></ul></li></ul></li></ul><figure><img src="image-47.webp" srcset="/img/loading/loading3.gif" lazyload alt="依次删除32、16、22"><figcaption aria-hidden="true">依次删除32、16、22</figcaption></figure><h2 id="外排序">外排序</h2><p>在外存上进行排序的最常用的方法是利用归并排序，因为归并排序只需要访问被归并序列中的第一个元素，这非常适合于顺序文件。</p><h3 id="预处理阶段">预处理阶段</h3><ul><li>预处理阶段：根据内存的大小将一个有 n个记录的文件分批读入内存，用各种内排序算法排序，形成一个个有序片段。</li><li><strong>置换选择</strong><ul><li>在外排序中，已排序片段越多，归并的次数也越多。如果能够让每个初始的已排序片段包含更多的记录，就能减少已排序片段数，就能减少排序时间。</li><li>置换选择可以在只能容纳 <span class="math inline"><em>p</em></span>个记录的内存中生成平均长度为 <span class="math inline">2<em>p</em></span> 的初始的已排序片段。</li><li>基于每个小片段采用选择排序。每次选出的最小记录直接被写到输出文件上，它所用的内存空间就可以给别的元素使用，此时可以从输入文件读入一个新记录。如果它比刚才写出去的元素大，则把它加入到优先级队列；否则，它不可能进入当前的已排序片段，该元素就被放于优先级队列的空余位置，用于下个片段的排序。</li></ul></li><li>文件上的数据为 <span class="math inline">1、4、10、2、0、5、7、6、9、12</span>，内存中能够容纳 3 个记录，这 3 个记录存放在数组 a中。构造初始的已排序片段的过程如下图。由于采用了置换选择法，使得对 11个记录只生成了两个初始的已排序片段，这样只需要一次归并就能排好序。</li></ul><figure><img src="image-48.webp" srcset="/img/loading/loading3.gif" lazyload alt="置换选择"><figcaption aria-hidden="true">置换选择</figcaption></figure><h3 id="归并阶段">归并阶段</h3><ul><li>归并阶段：将预处理得到的已排序片段逐步归并成一个有序文件。</li><li><strong>多阶段归并</strong><ul><li><span class="math inline"><em>k</em></span><strong>路归并</strong>：如果生成的已排序片段数为 <span class="math inline"><em>m</em></span> ，则 <span class="math inline"><em>k</em></span> 路归并需要归并 <span class="math inline">⌈log<sub><em>k</em></sub><em>m</em>⌉</span> 次。<ul><li><span class="math inline"><em>k</em></span>越大，归并次数越少。</li><li><span class="math inline"><em>k</em></span> 路归并需要 <span class="math inline">2<em>k</em></span> 个缓冲区</li></ul></li><li>使用多阶段归并，可以在只有 <span class="math inline"><em>k</em> + 1</span> 个缓冲区的情况下完成 <span class="math inline"><em>k</em></span> 路归并。</li></ul></li></ul><figure><img src="image-49.webp" srcset="/img/loading/loading3.gif" lazyload alt="多阶段归并"><figcaption aria-hidden="true">多阶段归并</figcaption></figure><h1 id="图">图</h1><h2 id="图的定义">图的定义</h2><ul><li><strong>图</strong>：由顶点集 <span class="math inline"><em>V</em></span> 和边集 <span class="math inline"><em>E</em></span> 组成的有序对 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span><ul><li><strong>顶点</strong>：图中的基本元素，通常用 <span class="math inline"><em>V</em> = {<em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ⋯, <em>v</em><sub><em>n</em></sub>}</span>表示</li><li><strong>边</strong>：连接两个顶点的线段，通常用 <span class="math inline"><em>E</em> = {<em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>, ⋯, <em>e</em><sub><em>m</em></sub>}</span>表示</li></ul></li></ul><p><img src="image-50.webp" srcset="/img/loading/loading3.gif" lazyload> <img src="image-51.webp" srcset="/img/loading/loading3.gif" lazyload alt="图的示例"></p><ul><li><strong>有向图</strong>：边有方向的图，边从一个顶点指向另一个顶点，用有序对表示边，如<span class="math inline"><em>e</em> =  &lt; <em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>&gt;</span>，表示从顶点<span class="math inline"><em>v</em><sub><em>i</em></sub></span> 到顶点<span class="math inline"><em>v</em><sub><em>j</em></sub></span>的边</li><li><strong>无向图</strong>：边没有方向的图，边连接两个顶点，用无序对表示边，如<span class="math inline"><em>e</em> = (<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)</span>，表示顶点<span class="math inline"><em>v</em><sub><em>i</em></sub></span> 和顶点<span class="math inline"><em>v</em><sub><em>j</em></sub></span>之间的边</li><li><strong>加权图</strong>：边带有权值的图，通常用 <span class="math inline"><em>w</em>(<em>e</em>)</span> 表示边 <span class="math inline"><em>e</em></span> 的权值<ul><li>加权有向图：<span class="math inline"><em>e</em> =  &lt; <em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>, <em>w</em>&gt;</span>，表示从顶点<span class="math inline"><em>v</em><sub><em>i</em></sub></span> 到顶点<span class="math inline"><em>v</em><sub><em>j</em></sub></span>的边，权值为 <span class="math inline"><em>w</em></span></li><li>加权无向图：<span class="math inline"><em>e</em> = (<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>, <em>w</em>)</span>，表示顶点<span class="math inline"><em>v</em><sub><em>i</em></sub></span> 和顶点<span class="math inline"><em>v</em><sub><em>j</em></sub></span>之间的边，权值为 <span class="math inline"><em>w</em></span></li></ul></li></ul><h3 id="图的基本术语">图的基本术语</h3><ol type="1"><li><strong>邻接</strong>：如果边 <span class="math inline"><em>e</em> = (<em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>)</span>存在，则称顶点 <span class="math inline"><em>v</em><sub><em>i</em></sub></span> 和顶点 <span class="math inline"><em>v</em><sub><em>j</em></sub></span>是邻接的。</li><li><strong>度</strong><ul><li>无向图：与该结点关联的边数</li><li>有向图：分为入度和出度<ul><li><strong>入度</strong>：有向图中进入某一结点的边数，称为该结点的入度</li><li><strong>出度</strong>：有向图中离开某一结点的边数，称为该结点的出度</li></ul></li></ul></li><li><strong>子图</strong>：如果图 <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>的一个子集 <span class="math inline"><em>V</em><sup>′</sup> ⊆ <em>V</em></span> 和 <span class="math inline"><em>E</em><sup>′</sup> ⊆ <em>E</em></span> 使得<span class="math inline"><em>G</em><sup>′</sup> = (<em>V</em><sup>′</sup>, <em>E</em><sup>′</sup>)</span>也是一个图，则称 <span class="math inline"><em>G</em><sup>′</sup></span>是 <span class="math inline"><em>G</em></span> 的子图</li><li>路径和路径长度<ul><li><strong>路径</strong>：从一个顶点到另一个顶点的边的序列<ul><li>若两个顶点之间存在路径，则称这两个顶点是<strong>连通</strong>的</li><li><strong>简单路径</strong>：路径上除了起始结点和终止结点外，其余的结点都不相同</li></ul></li><li><strong>路径长度</strong>：<ul><li>非加权路径长度：路径中边的数量</li><li>加权路径长度：路径中所有边的权值之和</li></ul></li></ul></li><li>连通图和连通分量<ul><li><strong>连通图</strong>：无向图中任意两个顶点之间都有路径相连，则称该图是连通的</li><li><strong>连通分量</strong>：无向图中一个连通子图，且该子图不是任何其他连通子图的子集</li></ul></li><li>强连通图和强连通分量<ul><li><strong>强连通图</strong>：有向图中任意两个顶点之间都有路径相连，则称该图是强连通的</li><li><strong>强连通分量</strong>：有向图中一个强连通子图，且该子图不是任何其他强连通子图的子集</li><li>若一个有向图不是强连通的，但把它看作无向图时是连通的，则称该有向图是<strong>弱连通的</strong></li></ul></li><li><strong>完全图</strong><ul><li>无向图：每一对顶点都有一条边相连，共有 <span class="math inline">$\frac{n(n-1)}{2}$</span> 条边</li><li>有向图：每一对顶点 <span class="math inline"><em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub></span>都有两条边 <span class="math inline"> &lt; <em>v</em><sub><em>i</em></sub>, <em>v</em><sub><em>j</em></sub>&gt;</span>和 <span class="math inline"> &lt; <em>v</em><sub><em>j</em></sub>, <em>v</em><sub><em>i</em></sub>&gt;</span>相连，共有 <span class="math inline"><em>n</em>(<em>n</em> − 1)</span>条边</li></ul></li><li><strong>生成树</strong>：无向连通图的极小连通子图，有 <span class="math inline"><em>n</em></span> 个顶点和 <span class="math inline"><em>n</em> − 1</span> 条边</li></ol><h3 id="图的基本运算">图的基本运算</h3><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#ifndef</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">GRAPH_H</span></span><span class="line"><span style="color: #C678DD">#define</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">GRAPH_H</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Graph</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">w</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">virtual</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">exist</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">numOfVer</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> { </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> Vers; }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">numOfEdge</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> { </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> Edges; }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">protected:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> Vers, Edges;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">#endif</span></span></code></pre></div></div></figure><h2 id="图的存储">图的存储</h2><h3 id="加权邻接矩阵表示法">（加权）邻接矩阵表示法</h3><p><span class="math display">$$A[i][j] = \begin{cases}1\ \text{or}\ w &amp; \text{if } &lt;i,j&gt;\ \in E \text{ or } (i,j)\in E \\0\ \text{or}\ \infty &amp; \text{otherwise}\end{cases}$$</span></p><figure><img src="image-52.webp" srcset="/img/loading/loading3.gif" lazyload alt="邻接矩阵表示法"><figcaption aria-hidden="true">邻接矩阵表示法</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"13-1-graph.h"</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjMatrixGraph</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Graph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt; {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">adjMatrixGraph</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">vSize</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">d</span><span style="color: #ABB2BF">[], </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">noEdgeFlag</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~adjMatrixGraph</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">w</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">exist</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">printGraph</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        TypeOfEdge </span><span style="color: #56B6C2">**</span><span style="color: #ABB2BF">edge;</span></span><span class="line"><span style="color: #ABB2BF">        TypeOfVer </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">ver;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">v</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">ver</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> v)</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        TypeOfEdge noEdge;</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">adjMatrixGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">adjMatrixGraph</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> vSize, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> TypeOfVer d[], </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> TypeOfEdge noEdgeFlag)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    Vers </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> vSize;</span></span><span class="line"><span style="color: #ABB2BF">    Edges </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    noEdge </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> noEdgeFlag;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i, j;</span></span><span class="line"><span style="color: #ABB2BF">    ver </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">[vSize];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> vSize; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">ver</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">d</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    edge </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> TypeOfEdge </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">[vSize];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> vSize; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">[vSize];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> vSize; j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[i][j] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> noEdge;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[i][i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">adjMatrixGraph&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #56B6C2">~</span><span style="color: #61AFEF">adjMatrixGraph</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete[]</span><span style="color: #ABB2BF"> ver;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">delete[]</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete[]</span><span style="color: #ABB2BF"> edge;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjMatrixGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">w</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> u </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x), v </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(y);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (u </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> v </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[u][v] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> noEdge)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[u][v] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> w;</span></span><span class="line"><span style="color: #ABB2BF">        Edges</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjMatrixGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> u </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x), v </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(y);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (u </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> v </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[u][v] </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> noEdge)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[u][v] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> noEdge;</span></span><span class="line"><span style="color: #ABB2BF">        Edges</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjMatrixGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">exist</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> u </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x), v </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(y);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (u </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> v </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[u][v] </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> noEdge;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjMatrixGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">printGraph</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ver</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">": "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> j </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; j </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; j</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[i][j] </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> noEdge)</span></span><span class="line"><span style="color: #ABB2BF">                cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ver</span><span style="color: #ABB2BF">[j] </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">edge</span><span style="color: #ABB2BF">[i][j] </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="邻接表表示法">邻接表表示法</h3><ul><li><strong>邻接表是图的标准存储方式</strong>。</li><li>邻接表将每一个结点的邻接结点组成一个链表，链表的每个结点表示一条边。</li><li>分为两部分：保存顶点和保存边<ul><li>顶点集用一个数组表示，数组的每个元素由两部分组成：<ul><li>顶点值</li><li>指向该顶点对应的链表的首地址</li></ul></li><li>边集用一组单链表表示。<ul><li>非加权图，单链表的结点由两部分组成：<ul><li>这条边终止结点的编号</li><li>后继指针</li></ul></li><li>加权图，单链表的结点由三部分组成：<ul><li>这条边终止结点的编号</li><li>边的权值</li><li>后继指针</li></ul></li></ul></li></ul></li><li>空间复杂度：<span class="math inline"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span>，其中<span class="math inline">|<em>V</em>|</span> 是顶点数，<span class="math inline">|<em>E</em>|</span> 是边数</li></ul><figure><img src="image-53.webp" srcset="/img/loading/loading3.gif" lazyload alt="邻接表表示法"><figcaption aria-hidden="true">邻接表表示法</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"13-1-graph.h"</span></span><span class="line"><span style="color: #C678DD">#include</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">&lt;bits/stdc++.h&gt;</span></span><span class="line"><span style="color: #C678DD">using</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">namespace</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">std</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">: </span><span style="color: #C678DD">public</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Graph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt; {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">public:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">adjListGraph</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">vSize</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">d</span><span style="color: #ABB2BF">[]);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">~adjListGraph</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">w</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">exist</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">printGraph</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">dfs</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">bfs</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">topSort</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">EulerCircuit</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">start</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">private:</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">edgeNode</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> end;</span></span><span class="line"><span style="color: #ABB2BF">            TypeOfEdge weight;</span></span><span class="line"><span style="color: #ABB2BF">            edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">next;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">edgeNode</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">e</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">w</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">edgeNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">n</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">): </span><span style="color: #61AFEF">end</span><span style="color: #ABB2BF">(e), </span><span style="color: #61AFEF">weight</span><span style="color: #ABB2BF">(w), </span><span style="color: #61AFEF">next</span><span style="color: #ABB2BF">(n) {}</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verNode</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            TypeOfVer ver;</span></span><span class="line"><span style="color: #ABB2BF">            edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">head;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">verNode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">edgeNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E06C75; font-style: italic">h</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">): </span><span style="color: #61AFEF">head</span><span style="color: #ABB2BF">(h) {}</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        verNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">verList;</span></span><span class="line"><span style="color: #ABB2BF">        TypeOfEdge noEdge;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">v</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> v) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">dfs</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">start</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">visited</span><span style="color: #ABB2BF">[]) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">struct</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">EulerNode</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> NodeNum;</span></span><span class="line"><span style="color: #ABB2BF">            EulerNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">next;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">EulerNode</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">ver</span><span style="color: #ABB2BF">): </span><span style="color: #61AFEF">NodeNum</span><span style="color: #ABB2BF">(ver), </span><span style="color: #61AFEF">next</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) {}</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">EulerCircuit</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">start</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">EulerNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*&amp;</span><span style="color: #E06C75; font-style: italic">beg</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">EulerNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*&amp;</span><span style="color: #E06C75; font-style: italic">end</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        adjListGraph&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #E5C07B">verNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #61AFEF">clone</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {};</span></span><span class="line"><span style="color: #ABB2BF">};</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">adjListGraph</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> vSize, </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> TypeOfVer d[])</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    Vers </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> vSize;</span></span><span class="line"><span style="color: #ABB2BF">    Edges </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    verList </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verNode</span><span style="color: #ABB2BF">[vSize];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> vSize; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">d</span><span style="color: #ABB2BF">[i];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">adjListGraph&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #56B6C2">~</span><span style="color: #61AFEF">adjListGraph</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> ((p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete[]</span><span style="color: #ABB2BF"> verList;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">w</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> u </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x), v </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(y);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (u </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> v </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[u].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">edgeNode</span><span style="color: #ABB2BF">(v, w, </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[u].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    Edges</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> u </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x), v </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(y);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (u </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> v </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[u].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">q;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> v)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[u].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">        Edges</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">next</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> v) p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        q </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">        Edges</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">exist</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">y</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> u </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(x), v </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(y);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (u </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> v </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[u].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> v) p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">//打印图</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">printGraph</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">": "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"; "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="图的遍历">图的遍历</h2><h3 id="深度优先遍历dfs">深度优先遍历（DFS）</h3><ul><li>图的深度优先遍历类似于树的前序遍历：<ol type="1"><li>选中第一个被访问的顶点</li><li>对顶点作已访问过的标志</li><li>依次从顶点的未被访问过的第一个、第二个、第三个……邻接顶点出发进行深度优先搜索</li><li>如果还有顶点未被访问，则选中一个起始顶点，转向 (2)</li><li>所有的顶点都被访问到，则结束</li></ol></li><li>深度优先生成树：每个深度优先搜索的过程都对应着一棵树。</li><li>深度优先生成森林：如果图不是连通图或强连通图，在进行深度优先搜索时，有时并不一定能够保证从某一个结点出发能访问到所有的顶点在这种情况下，必须再选中一个未访问过的顶点，继续进行深度优先搜索。直至所有的顶点都被访问到为止。这时，将得到的是一组树而不是一棵树，这一组树被称为深度优先生成森林。</li></ul><figure><img src="image-54.webp" srcset="/img/loading/loading3.gif" lazyload alt="深度优先生成树、森林"><figcaption aria-hidden="true">深度优先生成树、森林</figcaption></figure><ul><li>时间复杂度：<ul><li>邻接矩阵表示：<span class="math inline"><em>O</em>(|<em>V</em>|<sup>2</sup>)</span></li><li>邻接表表示：<span class="math inline"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span></li></ul></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//递归DFS</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">dfs</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">visited </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF">[Vers];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"dfs: "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[i]) </span><span style="color: #61AFEF">dfs</span><span style="color: #ABB2BF">(i, visited);</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;    </span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">dfs</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">start</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">visited</span><span style="color: #ABB2BF">[]) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[start].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[start] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[start].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">]) </span><span style="color: #61AFEF">dfs</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">, visited);</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">//非递归DFS</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">dfs</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">visited </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF">[Vers];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    stack</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> s;</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> currentNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"dfs: "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[i]) </span><span style="color: #C678DD">continue</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(i);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            currentNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[currentNode]) </span><span style="color: #C678DD">continue</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[currentNode].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[currentNode] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[currentNode].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">])</span></span><span class="line"><span style="color: #ABB2BF">                {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">                p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="广度优先遍历bfs">广度优先遍历（BFS）</h3><ul><li>图的广度优先搜索类似于树的层次遍历：<ol type="1"><li>选中第一个被访问的顶点</li><li>对顶点作已访问过的标志</li><li>依次访问已访问顶点的未被访问过的第一个、第二个、第三个……邻接顶点，并进行标记，转向(3)</li><li>如果还有顶点未被访问，则选中一个起始顶点，转向 (2)</li><li>所有的顶点都被访问到，则结束</li></ol></li><li>广度优先生成树/森林：与 DFS 同理</li><li>BFS 没有递归实现！</li></ul><figure><img src="image-55.webp" srcset="/img/loading/loading3.gif" lazyload alt="广度优先生成树、森林"><figcaption aria-hidden="true">广度优先生成树、森林</figcaption></figure><ul><li>时间复杂度：<ul><li>邻接矩阵表示：<span class="math inline"><em>O</em>(|<em>V</em>|<sup>2</sup>)</span></li><li>邻接表表示：<span class="math inline"><em>O</em>(|<em>V</em>|+|<em>E</em>|)</span></li></ul></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//非递归BFS</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">bfs</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF">   </span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">visited </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF">[Vers];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    queue</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> currentNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"bfs: "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[i]) </span><span style="color: #C678DD">continue</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(i);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            currentNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">front</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[currentNode]) </span><span style="color: #C678DD">continue</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[currentNode].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[currentNode] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[currentNode].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">])</span></span><span class="line"><span style="color: #ABB2BF">                {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">                p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h2 id="图的遍历的应用">图的遍历的应用</h2><h3 id="无向图的连通性">无向图的连通性</h3><ul><li>深度优先搜索和广度优先搜索都可以用来测试无向图的连通性。<ul><li>如果无向图是连通的，则从无向图中的任意结点出发进行深度优先搜索或广度优先搜索都可以访问到每一个结点。访问的次序是一棵深度／广度优先生成树。</li><li>如果图是非连通的，深度／广度优先搜索可以找到一片深度／广度优先生成森林。</li></ul></li></ul><h3 id="欧拉回路">欧拉回路</h3><ul><li>欧拉路径：如果能够在一个图中找到一条路径，使得该路径对图的每一条边正好经过一次，这条路径被称为欧拉路径。</li><li>欧拉回路：如果起点和终点是相同的，这条路径被称为欧拉回路。</li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//欧拉回路</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">EulerCircuit</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">start</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    EulerNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">beg, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">end, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">q, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tb, </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">te;</span><span style="color: #7F848E; font-style: italic">//beg, end分别指向欧拉回路的头和尾</span></span><span class="line"><span style="color: #7F848E; font-style: italic">    //tb, te分别指向beg和end的尾部</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> numOfDegree;</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">r;</span></span><span class="line"><span style="color: #ABB2BF">    verNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">u;</span></span><span class="line"><span style="color: #ABB2BF">    beg </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> end </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tb </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> te </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (Edges </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"None"</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        numOfDegree </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (r </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">; r </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; r </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">r</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">) numOfDegree</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (numOfDegree </span><span style="color: #56B6C2">%</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"None"</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span><span style="color: #7F848E; font-style: italic">//出度为基数，不存在欧拉回路</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    //寻找起点</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> startNum </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">find</span><span style="color: #ABB2BF">(start);</span></span><span class="line"><span style="color: #ABB2BF">    tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">clone</span><span style="color: #ABB2BF">();</span><span style="color: #7F848E; font-style: italic">//复制一个图</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    //寻找从startNum开始的欧拉回路，路径的起点和终点分别为beg和end</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">EulerCircuit</span><span style="color: #ABB2BF">(startNum, beg, end);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> beg;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> NUll)</span><span style="color: #7F848E; font-style: italic">//检查p的后继节点是否有边未被访问</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E5C07B">next</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">NodeNum</span><span style="color: #ABB2BF">].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">break</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">break</span><span style="color: #ABB2BF">;</span><span style="color: #7F848E; font-style: italic">//p的后继节点都被访问过</span></span><span class="line"><span style="color: #ABB2BF">            q </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #61AFEF">EulerCircuit</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">NodeNum</span><span style="color: #ABB2BF">, tb, te);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">te</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tb;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #7F848E; font-style: italic">    //恢复原图</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> []verList;</span></span><span class="line"><span style="color: #ABB2BF">    verList </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    //输出欧拉回路</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"EulerCircuit: "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (beg</span><span style="color: #C678DD">!=</span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">beg</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">NodeNum</span><span style="color: #ABB2BF">].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> beg;</span></span><span class="line"><span style="color: #ABB2BF">        beg </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">beg</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">delete</span><span style="color: #ABB2BF"> p;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">//寻找从start开始的欧拉回路，路径的起点和终点分别为beg和end</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">EulerCircuit</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">start</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">EulerNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*&amp;</span><span style="color: #E06C75; font-style: italic">beg</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">EulerNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*&amp;</span><span style="color: #E06C75; font-style: italic">end</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> nextNode;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    beg </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> end </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">EulerNode</span><span style="color: #ABB2BF">(start);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[start].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        nextNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[start].</span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(start, nextNode);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">remove</span><span style="color: #ABB2BF">(nextNode, start);</span></span><span class="line"><span style="color: #ABB2BF">        start </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> nextNode;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">end</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">EulerNode</span><span style="color: #ABB2BF">(start);</span></span><span class="line"><span style="color: #ABB2BF">        end </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">end</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">adjListGraph&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #E5C07B">verNode</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">*</span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">clone</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    verNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">tmp </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verNode</span><span style="color: #ABB2BF">[Vers];</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">edgeNode</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">tmp</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> tmp;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="有向图的连通性">有向图的连通性</h3><ul><li>对于有向图，通过两次深度优先搜索可以测试该有向图是否为强连通。如果不是强连通，则可以找出所有强连通分量。</li><li>找出有向图 <span class="math inline"><em>G</em></span> 的强连通分量:<ul><li>从任意结点开始执行深度优先搜索<ul><li>如果 <span class="math inline"><em>G</em></span>不是强连通的，则该深度优先搜索会得到一个深度优先生成森林/一棵深度优先生成树。</li><li>对森林中的每棵树按它们的生成次序依次进行后序遍历，并按遍历的顺序给每个结点编号。</li></ul></li><li>将图 <span class="math inline"><em>G</em></span> 的每条边逆向，形成<span class="math inline"><em>G</em><sub><em>r</em></sub></span>。从编号最大的结点开始深度优先搜索<span class="math inline"><em>G</em><sub><em>r</em></sub></span>，得到的深度优先遍历森林的每棵树就是<span class="math inline"><em>G</em></span> 的强连通分量。</li></ul></li></ul><figure><img src="image-56.webp" srcset="/img/loading/loading3.gif" lazyload alt="有向图的强连通分量"><figcaption aria-hidden="true">有向图的强连通分量</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//有向图的强连通分量</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">dfs</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">visited </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">bool</span><span style="color: #ABB2BF">[Vers];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    stack</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> s;</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> currentNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    vector</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> order;</span><span style="color: #7F848E; font-style: italic"> //存储访问顺序</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"dfs: "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[i]) </span><span style="color: #C678DD">continue</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(i);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            currentNode </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">top</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[currentNode]) </span><span style="color: #C678DD">continue</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[currentNode].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[currentNode] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">order</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push_back</span><span style="color: #ABB2BF">(currentNode);</span><span style="color: #7F848E; font-style: italic"> //记录访问顺序</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[currentNode].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">])</span></span><span class="line"><span style="color: #ABB2BF">                {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">s</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">                p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 对图进行转置</span></span><span class="line"><span style="color: #ABB2BF">    adjListGraph</span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF">TypeOfVer, TypeOfEdge</span><span style="color: #C678DD">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">transposedGraph</span><span style="color: #ABB2BF">(Vers, verList);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">transposedGraph</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">insert</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 对转置图进行深度优先搜索</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Strongly Connected Components: "</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">fill</span><span style="color: #ABB2BF">(visited, visited </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> Vers, </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">order</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">size</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">visited</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">order</span><span style="color: #ABB2BF">[i]])</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">transposedGraph</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">dfs</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">order</span><span style="color: #ABB2BF">[i], visited);</span></span><span class="line"><span style="color: #ABB2BF">            cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="拓扑排序">拓扑排序</h3><ul><li>AOV网：如果用图中的顶点表示活动，边表示活动间的先后关系，这样的有向图称为顶点活动网(Activity On Vertex Network)，简称 AOV 网。<ul><li>将 AOV网中的活动表示为有向边，活动间的先后关系表示为有向边的方向。</li></ul></li><li><strong>拓扑排序</strong>：将 AOV网中的活动按活动发生的先后次序排成拓扑序列。<ul><li>排序：如果有一条从 <span class="math inline"><em>u</em></span> 到<span class="math inline"><em>v</em></span> 的路径，那么结点 <span class="math inline"><em>v</em></span> 在拓扑排序中必须出现在结点 <span class="math inline"><em>u</em></span> 之后。</li><li>存在拓扑序列的图一定是一个有向无环图。</li><li>步骤：<ol type="1"><li>计算每个顶点的入度</li><li>将所有入度为 0 的顶点入队</li><li>当队列不为空时，出队一个顶点，将其加入拓扑序列，并将该顶点的所有出边的终点的入度减1</li><li>如果某个出边的终点的入度变为 0，则将该顶点入队</li><li>重复步骤 3 和 4，直到队列为空</li></ol></li></ul></li></ul><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">//拓扑排序</span></span><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF"> &lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">topSort</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span></span><span class="line"><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">    queue</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> current;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">inDegree </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">[Vers];</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span><span style="color: #7F848E; font-style: italic"> //计算每个顶点的入度</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">inDegree</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">) </span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">inDegree</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">]</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; i</span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">)</span><span style="color: #7F848E; font-style: italic"> //将入度为0的顶点入队</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">inDegree</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(i);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"topSort: "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">empty</span><span style="color: #ABB2BF">())</span></span><span class="line"><span style="color: #ABB2BF">    {</span></span><span class="line"><span style="color: #ABB2BF">        current </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">front</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[current].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[current].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">inDegree</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">]</span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">inDegree</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> endl;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><h3 id="关键路径">关键路径</h3><ul><li>AOE网：顶点表示事件，有向边的权值表示某个活动的待续时间，有向边的方向表示事件发生的先后次序，这样的有向图称为顶点事件网(Activity On Edge Network)，简称 AOE 网。<ul><li>源点/起点：入度为 0 的顶点。</li><li>汇点/收点：出度为 0 的顶点。</li></ul></li><li><strong>关键路径</strong>：AOE 网中从起点到收点的最长路径。<ul><li><strong>关键活动</strong>：关键路径上的活动称为关键活动。</li><li>关键活动的延误会导致整个项目的延误。</li><li>找出关键路径先要找出拓扑序列，从头到尾遍历拓扑序列可以找出最早发生时间，然后再从尾到头遍历拓扑序列可以找到最迟发生时间，最后再从头到尾遍历拓扑序列，找出最早发生时间和最迟发生时间的顶点，组成了关键路径。</li><li>步骤：<ol type="1"><li>设结点 <span class="math inline"><em>x</em></span>的最早发生时间记为 <span class="math inline">ee(<em>x</em>)</span>，边<span class="math inline"> &lt; <em>u</em>, <em>v</em>&gt;</span>的长度记为 <span class="math inline"><em>L</em><sub>uv</sub></span>。<ul><li>首先设所有结点的最早发生时间是 <span class="math inline">0</span>。</li><li>对每个被遍历的结点 <span class="math inline"><em>u</em></span>检查它的后继 <span class="math inline"><em>v</em></span>。如果 <span class="math inline">ee(<em>u</em>) + <em>L</em><sub>uv</sub> &gt; ee(<em>v</em>)</span>，则更新<span class="math inline">ee(<em>v</em>)</span> 为 <span class="math inline">ee(<em>u</em>) + <em>L</em><sub>uv</sub></span>。</li><li>最后得到汇点的最早发生时间，即关键路径的长度。</li></ul></li><li>设结点 <span class="math inline"><em>x</em></span>的最迟发生时间记为 <span class="math inline">le(<em>x</em>)</span>。<ul><li>首先设所有结点的最迟发生时间是关键路径的长度。</li><li>对每个被遍历的结点 <span class="math inline"><em>u</em></span>检查它的后继 <span class="math inline"><em>v</em></span>。如果 <span class="math inline">le(<em>v</em>) − <em>L</em><sub>uv</sub> &lt; le(<em>u</em>)</span>，则更新<span class="math inline">le(<em>u</em>)</span> 为 <span class="math inline">le(<em>v</em>) − <em>L</em><sub>uv</sub></span>。</li></ul></li></ol></li></ul></li></ul><figure><img src="image-57.webp" srcset="/img/loading/loading3.gif" lazyload alt="关键路径"><figcaption aria-hidden="true">关键路径</figcaption></figure><figure class="shiki cpp"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">template</span><span style="color: #ABB2BF">&lt;</span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">class</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #C678DD">void</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">adjListGraph</span><span style="color: #ABB2BF">&lt;</span><span style="color: #E5C07B">TypeOfVer</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">&gt;::</span><span style="color: #61AFEF">criticalPath</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    TypeOfEdge </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">ee </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">[Vers], </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">le </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">TypeOfEdge</span><span style="color: #ABB2BF">[Vers];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">top </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">[Vers], </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">inDegree </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF">[Vers];</span><span style="color: #7F848E; font-style: italic">  // top 保存拓扑序列</span></span><span class="line"><span style="color: #ABB2BF">    linkQueue</span><span style="color: #C678DD">&lt;int&gt;</span><span style="color: #ABB2BF"> q;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">int</span><span style="color: #ABB2BF"> i;</span></span><span class="line"><span style="color: #ABB2BF">    edgeNode </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF">p;</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 找出拓扑序列，放入数组 top</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span><span style="color: #7F848E; font-style: italic">  // 计算每个结点的入度</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">inDegree</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[i].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">++</span><span style="color: #E5C07B">inDegree</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i)</span><span style="color: #7F848E; font-style: italic">  // 将入度为 0 的结点入队</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">inDegree</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">enQueue</span><span style="color: #ABB2BF">(i);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">while</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">isEmpty</span><span style="color: #ABB2BF">()) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">deQueue</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">--</span><span style="color: #E5C07B">inDegree</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">enQueue</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 找最早发生时间</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) </span><span style="color: #E5C07B">ee</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span><span style="color: #7F848E; font-style: italic">  // 找出最早发生时间存于数组 ee</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">ee</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ee</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]] </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">ee</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ee</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]] </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 找最晚发生时间</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) </span><span style="color: #E5C07B">le</span><span style="color: #ABB2BF">[i] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ee</span><span style="color: #ABB2BF">[Vers </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> Vers </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; </span><span style="color: #C678DD">--</span><span style="color: #ABB2BF">i) {</span><span style="color: #7F848E; font-style: italic">  // 找出最晚发生时间存于数组 le</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]].</span><span style="color: #E06C75">head</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">!=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">NULL</span><span style="color: #ABB2BF">; p </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">next</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">le</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">] </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">le</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]])</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">le</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]] </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">le</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">end</span><span style="color: #ABB2BF">] </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">-&gt;</span><span style="color: #E06C75">weight</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">    // 找出关键路径</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (i </span><span style="color: #C678DD">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; i </span><span style="color: #C678DD">&lt;</span><span style="color: #ABB2BF"> Vers; </span><span style="color: #C678DD">++</span><span style="color: #ABB2BF">i) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">le</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]] </span><span style="color: #C678DD">==</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ee</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]]) {</span></span><span class="line"><span style="color: #ABB2BF">            cout </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"("</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">verList</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]].</span><span style="color: #E06C75">ver</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">", "</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">ee</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">top</span><span style="color: #ABB2BF">[i]] </span><span style="color: #C678DD">&lt;&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">")"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 计科 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春日映像</title>
      <link href="/_posts/%E6%98%A5%E6%97%A5%E6%98%A0%E5%83%8F/"/>
      <url>/_posts/%E6%98%A5%E6%97%A5%E6%98%A0%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./春日映像psd_01.webp&quot;);" viewBox="0 0 1000 2018"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./春日映像psd_02.webp&quot;);" viewBox="0 0 1000 2019"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./春日映像psd_03.webp&quot;);" viewBox="0 0 1000 2018"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./春日映像psd_04.webp&quot;);" viewBox="0 0 1000 2018"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./春日映像psd_05.webp&quot;);" viewBox="0 0 1000 2019"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./春日映像psd_06.webp&quot;);" viewBox="0 0 1000 2018"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./春日映像psd_07.webp&quot;);" viewBox="0 0 1000 2018"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./春日映像psd_08.webp&quot;);" viewBox="0 0 1000 2019"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./春日映像psd_09.webp&quot;);" viewBox="0 0 1000 2018"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>何处闻灯不看来</title>
      <link href="/_posts/%E4%BD%95%E5%A4%84%E9%97%BB%E7%81%AF%E4%B8%8D%E7%9C%8B%E6%9D%A5/"/>
      <url>/_posts/%E4%BD%95%E5%A4%84%E9%97%BB%E7%81%AF%E4%B8%8D%E7%9C%8B%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./何处闻灯不看来_01.webp&quot;);" viewBox="0 0 1000 2080"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./何处闻灯不看来_02.webp&quot;);" viewBox="0 0 1000 2079"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./何处闻灯不看来_03.webp&quot;);" viewBox="0 0 1000 2080"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./何处闻灯不看来_04.webp&quot;);" viewBox="0 0 1000 2080"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./何处闻灯不看来_05.webp&quot;);" viewBox="0 0 1000 2079"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./何处闻灯不看来_06.webp&quot;);" viewBox="0 0 1000 2080"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./何处闻灯不看来_07.webp&quot;);" viewBox="0 0 1000 2079"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./何处闻灯不看来_08.webp&quot;);" viewBox="0 0 1000 2080"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>烟花未冷</title>
      <link href="/_posts/%E7%83%9F%E8%8A%B1%E6%9C%AA%E5%86%B7/"/>
      <url>/_posts/%E7%83%9F%E8%8A%B1%E6%9C%AA%E5%86%B7/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./烟花未冷_01.webp&quot;);" viewBox="0 0 1000 1936"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./烟花未冷_02.webp&quot;);" viewBox="0 0 1000 1936"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./烟花未冷_03.webp&quot;);" viewBox="0 0 1000 1936"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./烟花未冷_04.webp&quot;);" viewBox="0 0 1000 1936"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./烟花未冷_05.webp&quot;);" viewBox="0 0 1000 1935"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./烟花未冷_06.webp&quot;);" viewBox="0 0 1000 1936"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./烟花未冷_07.webp&quot;);" viewBox="0 0 1000 1936"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./烟花未冷_08.webp&quot;);" viewBox="0 0 1000 1936"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构光影</title>
      <link href="/_posts/%E9%87%8D%E6%9E%84%E5%85%89%E5%BD%B1/"/>
      <url>/_posts/%E9%87%8D%E6%9E%84%E5%85%89%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_01.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_02.webp&quot;);" viewBox="0 0 1000 2775"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_03.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_04.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_05.webp&quot;);" viewBox="0 0 1000 2778"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_06.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_07.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_08.webp&quot;);" viewBox="0 0 1000 2778"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_09.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_10.webp&quot;);" viewBox="0 0 1000 2778"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_11.webp&quot;);" viewBox="0 0 1000 2778"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_12.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_13.webp&quot;);" viewBox="0 0 1000 2778"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_14.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_15.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_16.webp&quot;);" viewBox="0 0 1000 2778"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_17.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_18.webp&quot;);" viewBox="0 0 1000 2779"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_19.webp&quot;);" viewBox="0 0 1000 2778"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./重构光影_20.webp&quot;);" viewBox="0 0 1000 2779"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二三回忆录</title>
      <link href="/_posts/%E4%BA%8C%E4%B8%89%E5%9B%9E%E5%BF%86%E5%BD%95/"/>
      <url>/_posts/%E4%BA%8C%E4%B8%89%E5%9B%9E%E5%BF%86%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_01.webp&quot;);" viewBox="0 0 1000 1931"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_02.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_03.webp&quot;);" viewBox="0 0 1000 1931"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_04.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_05.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_06.webp&quot;);" viewBox="0 0 1000 1931"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_07.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_08.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_09.webp&quot;);" viewBox="0 0 1000 1931"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_10.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_11.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_12.webp&quot;);" viewBox="0 0 1000 1931"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_13.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_14.webp&quot;);" viewBox="0 0 1000 1931"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_15.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_16.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_17.webp&quot;);" viewBox="0 0 1000 1931"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_18.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_19.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_20.webp&quot;);" viewBox="0 0 1000 1931"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_21.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_22.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_23.webp&quot;);" viewBox="0 0 1000 1931"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_24.webp&quot;);" viewBox="0 0 1000 1930"></svg><svg class="custom-gallery-svg" style="background-image: url(&quot;./二三回憶錄（压缩）_25.webp&quot;);" viewBox="0 0 1000 1930"></svg>]]></content>
      
      
      <categories>
          
          <category> DayDream Gallery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Photography </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国近现代史纲要</title>
      <link href="/_posts/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/"/>
      <url>/_posts/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>马楠老师</em> 2023-2024学年秋季学期教学内容进行整理</p></blockquote><h1 id="导言">导言</h1><h2 id="近代史现代史的定义">近代史、现代史的定义</h2><ul><li><strong>中国近现代史</strong>：1840年以来的中国历史</li><li><strong>中国近代史</strong>：从1840年<strong>鸦片战争爆发</strong>到1949年<strong>中华人民共和国成立前夕</strong>的历史<ul><li><strong>中国近代史</strong>以鸦片战争为起点</li><li>1842 年8 月29日，清政府与英国签订中国近代史上第一个不平等条约——南京条约。鸦片战争后，由于西方列强入侵和封建统治腐败，中国逐步成为半殖民地半封建社会，从那时起，中国社会发生两个根本变化：<ul><li>一是独立的中国逐步变成半殖民地的中国</li><li>二是封建的中国逐步变成半封建的中国</li></ul></li></ul></li><li><strong>中国现代史</strong>：1949年中华人民共和国成立以来的历史</li></ul><h2 id="中国人民必须完成的两大历史任务">中国人民必须完成的两大历史任务</h2><p>争得民族独立、人民解放，实现国家富强、人民幸福。</p><h2 id="近代中国社会的主要矛盾">近代中国社会的主要矛盾</h2><p>主要矛盾是帝国主义和中华民族的矛盾、封建主义和人民大众的矛盾。</p><h1 id="第一章-进入近代后中华民族的磨难与抗争">第一章进入近代后中华民族的磨难与抗争</h1><h2 id="鸦片战争后签订的一系列不平等条约">鸦片战争后签订的一系列不平等条约</h2><ul><li>1842.8.29 中英《南京条约》——中国近代史上第一个不平等条约</li><li>1843.10 中英《虎门条约》</li><li>1844.7 中美《望厦条约》</li><li>1844.10 中法《黄埔条约》</li></ul><p>随着外国资本主义的入侵，中国的封建社会逐渐变成了半殖民地半封建社会。中国人民逐渐开始了反帝反封建的资产阶级民主革命。鸦片战争成为中国近代史起点。</p><h2 id="中国封建社会的性质">中国封建社会的性质</h2><ul><li><strong>近代中国社会的性质（1840-1949）</strong>：半殖民地半封建性质</li><li><strong>关键词</strong>：<ul><li>独立——半殖民地：主权受破坏，一定程度上被殖民地化，丧失完整主权但仍维持独立国家和政府的名义</li><li>封建——半封建：卷入世界资本主义经济体系和世界市场，自给自足的自然经济的基础受破坏，中国资本主义的产生有了某些客观条件</li></ul></li><li><strong>基本特征</strong>：<ol type="1"><li>资本—帝国主义侵略势力逐步操纵中国财政、经济、政治，日益成为支配中国的决定性力量</li><li>自然经济受破坏但仍存在严重阻碍</li><li>封建势力勾结帝国主义</li><li>新兴民族资本主义产生但力量软弱</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-4a63de2c" role="button" aria-expanded="false" aria-controls="collapse-4a63de2c">        <div class="fold-arrow">▶</div>半殖民地半封建性质辨析      </div>      <div class="fold-collapse collapse" id="collapse-4a63de2c">        <div class="fold-content">          <p>鸦片战争以后，资本–帝国主义列强通过发动侵略战争，强迫中国签订一系列不平等条约，破坏中国的领土主权、领海主权、关税主权、司法主权等，并一步一步地控制中国的政治、经济、外交和军事。中国已经丧失了完全独立的地位，在相当程度上被殖民地化了。近代中国尽管在实际上已经丧失拥有完整主权的独立国的地位，但是仍然维持着独立国家和政府的名义，还有一定的主权。由于它与连名义上的独立也没有而由殖民主义宗主国直接统治的殖民地尚有区别，因此被称作半殖民地。</p><p>外国资本–帝国主义列强用武力打开中国的门户，把中国卷入世界资本主义经济体系和世界市场之中。随着外国资本主义的入侵，洋纱、洋布等商品在中国大量倾销，逐渐使中国的农业与家庭手工业分离，一方面，破坏了中国自给自足的自然经济的基础，破坏了城市的手工业和农民的家庭手工业；另一方面，则促进了中国城乡商品经济的发展，给中国资本主义的产生造成了某些客观条件。破产的农民和手工业者成了产业工人的后备军。一批官僚、买办、地主、商人投资兴办新式工业。中国出现了资本主义生产关系。中国已经不是完全的封建社会了，因此被称作半封建社会。</p>        </div>      </div>    </div><h2 id="近代中国的社会主要矛盾">近代中国的社会主要矛盾</h2><p>近代中国半殖民地半封建社会的矛盾，呈现出错综复杂的状况</p><ul><li><strong>主要矛盾</strong>：这两对主要矛盾及其斗争贯穿整个中国半殖民地半封建社会的始终，并对中国近代社会的发展变化起着<strong>决定性的作用</strong><ol type="1"><li>帝国主义和中华民族的矛盾<ul><li><strong>最主要的矛盾</strong></li></ul></li><li>封建主义和人民大众的矛盾</li></ol></li></ul><h2 id="近代中国的两大历史任务">近代中国的两大历史任务</h2><ol type="1"><li>争得民族独立和人民解放</li><li>实现国家富强和人民幸福</li></ol><h2 id="帝国主义对中国的侵略">帝国主义对中国的侵略</h2><h3 id="军事侵略">军事侵略</h3><p>资本–帝国主义列强对中国的侵略，<strong>首先和主要</strong>的是进行<strong>军事侵略</strong></p><ol type="1"><li>发动侵略战争，屠杀中国人民</li><li>侵占中国领土，划分势力范围</li><li>勒索赔款，抢掠财富</li></ol><h3 id="政治控制">政治控制</h3><ol type="1"><li>控制中国的内政、外交</li><li>镇压中国人民的反抗</li><li>扶植、收买代理人</li></ol><h3 id="经济掠夺">经济掠夺</h3><ol type="1"><li>强迫中国支付巨额的战争赔款</li><li>控制中国的通商口岸</li><li>剥夺中国的关税门主权</li><li>实行商品倾销和资本输出</li><li>操纵中国的经济命脉</li></ol><h3 id="文化渗透">文化渗透</h3><ol type="1"><li>披着宗教外衣，进行侵略活动</li><li>为侵略中国制造舆论</li></ol><h2 id="抵御外来侵略的斗争历程">抵御外来侵略的斗争历程</h2><ul><li><strong>人民群众的反侵略斗争</strong>：三元里人民抗英；太平天国；台湾人民高山族；香港造船工人罢工；台北人民反对割台；义和团</li><li>三元里人民的抗英斗争，是中国近代史上中国人民<strong>第一次大规模的反侵略武装斗争</strong></li></ul><h2 id="帝国主义侵略中国的最终目的">帝国主义侵略中国的最终目的</h2><p><strong>瓜分中国</strong>、<strong>灭亡中国</strong></p><h2 id="列强瓜分中国图谋的破产原因何在">列强瓜分中国图谋的破产原因何在</h2><p><strong>关键词</strong>：</p><ol type="1"><li>帝国主义列强之间的<strong>矛盾</strong>与相互<strong>制约</strong>，在争吵与协商后认定暂缓瓜分中国，实行“以华治华”</li><li><strong>根本原因</strong>：中华民族不屈不挠的反侵略斗争：如义和团；中国人民不畏强暴、敢与敌人血战到底的英雄气概，中华民族为反抗侵略所进行的前赴后继视死如归的战斗</li></ol><h2 id="反侵略战争的失败及其原因">反侵略战争的失败及其原因</h2><ol type="1"><li>社会制度的腐败<ul><li>最<strong>根本原因</strong></li><li>社会制度的腐败，使得经济技术落后的状况长期得不到改变</li></ul></li><li>经济技术的落后</li></ol><ul><li>中法战争后期，1885.3，爱国将领冯子材指挥清军在中越边境前线大败法军，清政府主权者力主避战求和签订《中法新约》——“中国不败而败，法国不胜而胜”</li></ul><h2 id="早期维新思想">早期维新思想</h2><ul><li><p><strong>林则徐</strong>是近代中国<strong>睁眼看世界的第一人</strong></p></li><li><p><strong>魏源</strong>在1843年1月编成《<strong>海国图志</strong>》</p><ul><li>提出“<strong>师夷长技以制夷</strong>”：主张学习外国先进的军事和科学技术，以期富国强兵，抵御外国侵略</li></ul></li><li><p><strong>郑观应</strong>《<strong>盛世危言</strong>》：具有重要的<strong>思想启蒙</strong>的意义</p><ul><li>出大力<strong>发展民族工商业</strong></li><li>同西方国家进行“商战”</li><li>设立议院，实行“君民共主”制度</li></ul></li><li><p><strong>严复</strong>翻译《<strong>天演论</strong>》</p><ul><li>“<strong>物竞天择</strong>”“<strong>适者生存</strong>”的社会进化论思想</li><li>为这种危机意识和民族意识提供了<strong>理论根据</strong></li></ul></li></ul><h1 id="第二章-不同社会力量对国家出路的早期探索">第二章不同社会力量对国家出路的早期探索</h1><h2 id="太平天国">太平天国</h2><ul><li>历史沿革<ul><li>1843年，<strong>洪秀全</strong>从<strong>农民斗争</strong>的需要出发，加以改造，创立<strong>拜上帝教</strong>，并利用它发动和组织群众</li><li><strong>金田起义</strong>：1851年1月，洪秀全率拜上帝教教众在广西省桂平县金田村发动起义，建号<strong>太平天国</strong></li></ul></li><li>性质<ul><li><strong>反对清政府腐朽统治</strong>和<strong>地主阶级压迫、剥削</strong></li><li><strong>正义战争</strong></li></ul></li></ul><h3 id="天朝田亩制度和资政新篇">《天朝田亩制度》和《资政新篇》</h3><ul><li>《天朝田亩制度》：<ul><li>最能体现太平天国社会理想和这次农民起义特色的纲领性文件</li><li>内容与局限性：农民要求平分土地的强烈愿望，不切实际的空想性质</li><li>先进性：否定了封建社会的基础即封建土地所有制</li></ul></li><li>《资政新篇》：<ul><li>太平天国后期发布的社会发展方案</li><li>作者：洪仁轩（资本主义色彩，受限于历史条件未能实施）</li><li>特点：具有<strong>资本主义色彩</strong>的方案，中国近代历史上第一个<strong>比较系统的发展资本主义</strong>的方案</li><li>反映通过向外国学习来寻求出路的一种努力，在中国近代“向西方学习”、追求近代化的进程中有比较重要的意义</li></ul></li></ul><h3 id="太平天国农民起义失败的原因">太平天国农民起义失败的原因</h3><ol type="1"><li>无法克服小生产者所固有的阶级局限性，缺乏科学思想理论的指导，没有先进阶级的领导无法从根本上提出完整、正确的政治纲领和社会改革方案；</li><li>后期无法制止和克服领导集团自身腐败现象的产生，领导集团部分人追求享乐争权夺利，削弱向心力和战斗力；</li><li>军事战略失误：未能与捻军结成同盟；天京被围时拒绝“让城别走”；</li><li>以宗教发动组织群众，拜上帝教教义无法正确指导斗争反而带来危害；</li><li>未能正确对待儒学；</li><li>无法将西方国家侵略者和人民群众区别开来，缺乏对西方资本主义侵略者的理性认识；</li></ol><h3 id="太平天国的历史意义">太平天国的历史意义</h3><ol type="1"><li><strong>沉重打击了封建统治阶级</strong>，强烈撼动了清政府的统治根基</li><li>是中国<strong>旧式农民战争</strong>的最高峰</li><li>在一定程度上削弱了封建统治的精神支柱</li><li>有力地<strong>打击</strong>了<strong>外国侵略势力</strong>，冲击了西方殖民主义者在亚洲的统治</li></ol><h3 id="太平天国失败的历史意义">太平天国失败的历史意义</h3><ol type="1"><li>农民具有伟大的<strong>革命潜力</strong></li><li>但它<strong>自身不能担负</strong>起领导反帝反封建斗争取得胜利的重任</li><li><strong>单纯的农民战争</strong>不可能完成争取民族独立和人民解放的历史任务</li></ol><h2 id="洋务运动">洋务运动</h2><h3 id="洋务运动指导思想中学为体西学为用">洋务运动指导思想：“中学为体，西学为用”</h3><ul><li>以中国封建伦理纲常所维护的<strong>统治秩序为主体</strong></li><li>用西方的近代工业和技术为<strong>辅助</strong></li><li>并以前者来支配后者</li></ul><h3 id="洋务运动的事业内容">洋务运动的事业内容</h3><ol type="1"><li>兴办近代企业<ul><li>官办<strong>军用工业</strong><ul><li><strong>最早</strong>：1861<strong>安庆军械所</strong></li><li>最大兵工厂：<strong>上海江南制造总局</strong></li></ul></li><li>民用企业<ul><li>采取<strong>官督商办</strong></li></ul></li></ul></li><li>建立新式海陆军</li><li>创办<strong>新式学堂</strong>，派遣留学生</li></ol><h3 id="洋务运动的失败及其原因">洋务运动的失败及其原因</h3><ol type="1"><li>洋务运动具有封建性：企图吸收西方近代生产技术以维护巩固中国封建统治，然而新的生产力是同封建主义的生产关系及其上层建筑不相容的；</li><li>洋务运动对列强具有依赖性：企图依赖外国来达到自强求富的目的；</li><li>洋务企业的管理具有腐朽性：本质是封建衙门式的，内部腐败</li></ol><h2 id="维新运动">维新运动</h2><ul><li>背景与原因：甲午战败与马关条约的签订</li><li>资产阶级维新派：康有为、梁启超、谭嗣同、严复等</li></ul><h3 id="维新派与守旧派的论战">维新派与守旧派的论战</h3><ul><li><strong>※重要：戊戌维新运动</strong>：维新派与守旧派的这场论战，实质上是资产阶级思想和封建主义思想在中国的第一次正面交锋</li></ul><h3 id="戊戌维新运动的意义">戊戌维新运动的意义：</h3><ol type="1"><li>是一次爱国救亡运动：高举救亡图存旗帜要求通过变法发展资本主义走上富强道路，推动中华民族的觉醒；</li><li>是一场资产阶级性质的政治改良运动：在政治、经济等领域一定程度上冲击了封建制度；</li><li>是一场思想启蒙运动：利于民主思想在中国传播，有利于人们思想解放，推动近代教育发展</li></ol><h3 id="维新运动失败的原因">维新运动失败的原因</h3><ol type="1"><li>维新派自身的局限<ol type="1"><li>不敢否定封建主义<ol type="1"><li>政治上：不敢根本否定封建君主制度</li><li>经济上：虽然要求发展民族资本主义，却<strong>未触及封建主义的经济基础</strong>——封建土地所有制</li><li>思想上：仍要打着孔子的旗号，借古代圣贤之名“托古改制”</li></ol></li><li>对帝国主义抱有幻想，虽然大声疾呼救亡图存，却又幻想西方列强能帮助自己变法维新</li><li>惧怕人民群众，活动基本上局限于官僚士大夫和知识分子的小圈子</li></ol></li><li>以慈禧太后为首的强大的守旧势力的反对</li></ol><h3 id="维新运动失败的意义">维新运动失败的意义</h3><p>使人们认识到：在半殖民地半封建的旧中国</p><ul><li><strong>自上而下的改良道路行不通</strong></li><li>必须用革命的手段，推翻帝国主义、封建主义联合统治的半殖民地半封建的社会制度</li></ul><h1 id="第三章-辛亥革命与君主专制制度的终结">第三章辛亥革命与君主专制制度的终结</h1><h2 id="孙中山与资产阶级民主革命的开始">孙中山与资产阶级民主革命的开始</h2><ul><li><strong>1894年</strong>，<strong>孙中山</strong>组建了第一个革命团体<strong>兴中会</strong><ul><li>目标：驱除勒虏，恢复中国，创立合众政府</li><li>性质：革命组织，并非政党</li></ul></li><li><strong>1905年8月20日</strong>，<strong>孙中山和黄兴、宋教仁</strong>等人在日本东京成立<strong>中国同盟会</strong><ul><li>性质及意义：近代中国<strong>第一个</strong>领导<strong>资产阶级革命</strong>的全国性<strong>政党</strong></li></ul></li></ul><h2 id="民主革命思想广泛传播">民主革命思想广泛传播</h2><ul><li>资产阶级革命派的宣传与组织工作：<ul><li>章炳麟《驳康有为论革命书》</li><li>邹容《革命军》——“革命军中马前卒”</li><li>陈天华《警世钟》《猛回头》</li></ul></li></ul><h2 id="三民主义">三民主义</h2><ul><li>1905年11月<strong>孙中山</strong>在《<strong>民报</strong>》中将同盟会的纲领概括为<strong>三民主义</strong><ol type="1"><li>民族主义（<em>推翻清政府，建立独立国家</em>）<ul><li>驱除勒虏，恢复中华</li></ul></li><li>民权主义（<em>政治革命</em>）<ul><li>“<strong>创立民国</strong>”</li><li>即<strong>推翻封建君主专制制度</strong>，建立<strong>资产阶级民主共和国</strong></li></ul></li><li>民生主义（<em>社会革命</em>）<ul><li>当时为<strong>平均地权</strong></li></ul></li></ol></li><li><strong>同盟会政治纲领</strong>：“驱除鞑虏，回复中华，创立民国，平均地权”</li><li><strong>孙中山的三民主义学说意义</strong>：初步描绘出中国还不曾有过的资产阶级共和国方案，是一个比较完整和明确的资产阶级民主革命纲领，它的提出对推动革命的发展产生了重大而积极的影响。</li></ul><h2 id="辛亥革命与中华民国的建立">辛亥革命与中华民国的建立</h2><ul><li>1911.10.10晚，驻武昌的新军工程第八营的革命党人打响起义第一枪，大肆镇压革命的军官，冲向楚望台军械所夺取弹药，一举占领楚望台，随即向湖广总督衙门发起攻击。</li><li>1912.2.12，清帝退位，延续了两千多年的封建君主专制制度终于覆灭。</li><li>1912.1.1，孙中山在南京宣誓就职，改国号为中华民国，定1912年为民国元年，并成立中华民国临时政府</li><li><strong>《中华民国临时约法</strong>》：1912.3，临时参议院颁布《中华民国临时约法》，这是中国历史上第一部有资产阶级共和国宪法性质的法典</li><li>1912.3，袁世凯派人刺杀宋教仁，孙中山领导国民党发动<strong>二次革命</strong></li><li>1912.8，宋教仁在征得孙中山、黄兴的同意后，以同盟会为基础联合其他几个政党，组成国民党</li><li>1919.10，孙中山将中华革命党改组为中国国民党</li></ul><h3 id="辛亥革命的历史意义">辛亥革命的历史意义</h3><p>辛亥革命是<strong>资产阶级领导</strong>的以<strong>反对封建君主专制制度</strong>、<strong>建立资产阶级共和国</strong>为目的的革命，是一次比较完全意义上的<strong>资产阶级民主革命</strong>，它使中国发生了历史性的巨变，具有伟大的历史意义。</p><ol type="1"><li>辛亥革命推翻了<strong>封建势力</strong>的政治代表、<strong>帝国主义</strong>在中国的代理人<strong>清王朝</strong>的统治，沉重打击了<strong>中外反动势力</strong></li><li>辛亥革命<strong>结束</strong>了中国延续两千多年的<strong>封建君主专制制度</strong>，建立了中国历史上<strong>第一个资产阶级共和政府</strong>，使<strong>民主共和</strong>的观念开始<strong>深入人心</strong></li><li>辛亥革命推动了中国人民的<strong>思想解放</strong></li><li>辛亥革命推动了中国的<strong>社会变革</strong>，促使中国的社会经济、思想习惯和社会风俗等方面发生了新的积极变化</li><li>辛亥革命不仅在一定程度上<strong>打击</strong>了<strong>帝国主义</strong>的侵略势力，而且<strong>推动</strong>了亚洲各国<strong>民族解放运动</strong>的高涨</li></ol><h3 id="辛亥革命失败的原因">辛亥革命失败的原因</h3><ul><li>客观方面<ol type="1"><li><strong>根本</strong>：在<strong>帝国主义时代</strong>，在<strong>半殖民地半封建的中国</strong>，<strong>资本主义</strong>的建国方案是<strong>行不通</strong>的</li><li>帝国主义决不容许中国建立一个独立、富强的资产阶级共和国</li><li>帝国主义与以<strong>袁世凯</strong>为代表的<strong>大地主大买办</strong>势力以及旧官僚、立宪派一起勾结起来，从外部和内部绞杀了这场革命</li></ol></li><li>主观方面：领导者资产阶级革命派本身存在着许多弱点和错误<ol type="1"><li>没有提出<strong>彻底的反帝反封建</strong>的革命<strong>纲领</strong></li><li>不能充分发动和依靠<strong>人民群众</strong></li><li>不能建立坚强的革命政党</li><li><strong>根源</strong>：中国民族资产阶级的<strong>软弱性</strong>和<strong>妥协性</strong></li></ol></li></ul><h1 id="第四章-中国共产党成立和中国革命新局面">第四章中国共产党成立和中国革命新局面</h1><h2 id="新文化运动">新文化运动</h2><ul><li><strong>科学狭义指自然科学，广义指社会科学</strong></li><li><strong>新文化运动基本口号</strong>：拥护“德先生”和“赛先生”，即提倡民主和科学<ul><li><strong>民主，既是指资产阶级民主主义制度，也是指资产阶级民主主义思想。科学狭义指自然科学，广义指社会科学</strong></li></ul></li><li><strong>十月革命对中国先进分子的影响</strong>：1917年俄国十月社会主义革命是一个具有划时代意义的世界性历史事件</li><li><strong>李大钊率先在中国举起马克思主义旗帜</strong></li></ul><h2 id="五四运动">五四运动</h2><ul><li><strong>五四运动的历史特点和意义</strong>：五四运动是一场以先进青年知识分子为先锋、广大人民群众参加的彻底反帝反封建的伟大爱国革命运动，是一场中国人民为拯救民族危亡、捍卫民族尊严、凝聚民族力量而掀起的伟大社会革命运动，是一场传播新思想新文化新知识的伟大思想启蒙运动和新文化运动</li><li><strong>意义</strong>：<ol type="1"><li>旧民主向新民主主义革命转变的转折点，里程碑意义，彻底的反帝反封建革命性</li><li>促进马克思主义在中国的传播，为中国共产党成立做了思想上干部上的准备，新民主主义革命的开端</li><li>激发追求真理和进步的伟大觉醒</li><li>以全民族的搏击培育了永久奋斗的伟大传统（五四运动以全民族的力量高举起爱国主义的伟大旗帜，孕育了以爱国主义为核心的、以爱国、进步、民主、科学为主要内容的伟大五四精神）</li></ol></li></ul><h2 id="早期信仰马克思主义的三类人物">早期信仰马克思主义的三类人物</h2><ol type="1"><li>新文化运动精神领袖：李大钊、陈独秀</li><li>五四运动左翼骨干：毛泽东</li><li>原中国同盟会会员、辛亥革命时期的活动家：董必武</li></ol><h2 id="中国共产党成立的历史条件">中国共产党成立的历史条件</h2><p><strong>中国先进分子选择了马克思主义，这是具有伟大历史意义的事件</strong></p><p><strong>中国共产党早期组织的活动</strong>：</p><ol type="1"><li>研究宣传马克思主义、研究中国实际问题</li><li>到工人中去进行宣传和组织工作</li><li>进行关于建党问题的讨论和实际组织工作</li></ol><h2 id="中国共产党成立">中国共产党成立</h2><ul><li><strong>中国共产党第一次全国代表大会</strong>：1921.7.23，上海法租界望志路106号</li><li>成果：<ul><li>确定党的名称为“<strong>中国共产党</strong>”</li><li>设立<strong>中央局</strong>作为中央的临时领导机构，选举产生了以<strong>陈独秀</strong>为书记的中央局</li><li>宣告<strong>中国共产党正式成立</strong></li></ul></li><li><strong>中国共产党的成立，深刻改变了</strong><ul><li>近代以后中华民族发展的方向和进程</li><li>中国人民和中华民族的前途和命运</li><li>世界发展的趋势和格局</li></ul></li></ul><h2 id="民主革命纲领的制定">民主革命纲领的制定</h2><ul><li><strong>中共二大</strong>：1922年7月，上海，中国共产党第二次全国代表大会</li><li><strong>中共二大</strong>提出了<strong>反帝反封建的民主革命纲领</strong></li><li>意义<ul><li>为中国人民指出了明确的<strong>斗争目标</strong></li></ul></li><li>内容<ul><li>党的最高纲领：实现社会主义、共产主义</li><li>党在现阶段的纲领，即<strong>最低纲领</strong>是<ul><li><strong>打倒军阀</strong></li><li>推翻<strong>国际帝国主义</strong>的压迫</li><li>统一中国为真正<strong>民主共和国</strong></li></ul></li></ul></li></ul><h2 id="国共合作的形成">国共合作的形成</h2><ul><li>中共三大后，国共合作步伐大大加快。</li><li>1924.1，中国国民党第一次全国代表大会由孙中山主持在广州举行。大会审议通过的《中国国民党第一次全国代表大会宣言》，对三民主义作出新的解释，即”新三民主义”。<ul><li>民族主义突出</li><li>反对帝国主义；民权主义强调民主权利应“为一般平民所共有”</li><li>民生主义概括为“平均地权、节制资本”和补充“耕者有其田”</li></ul></li><li>国共合作的政治基础：新三民主义纲领同中国共产党在民主革命阶段的纲领基本一致</li></ul><h2 id="中国人民为什么选择了马克思主义">※中国人民为什么选择了马克思主义</h2><p>中国人民选择了马克思主义，是因为马克思主义理论符合中国社会需要。近代中国向西方寻找救国真理屡遭失败，俄国十月革命给探寻国家出路的中国人民指明了前进方向，提供了全新选择。早期马克思主义者推动了马克思主义在中国的传播。中国人民选择马克思主义有力推动了中国人民争取民族独立、人民解放的反帝反封建的革命运动。中国人在精神上就由被动转为主动。马克思主义在中国的早期传播，就开始与中国工人运动相结合，从而产生了中国共产党，使得中国人民反帝反封建斗争有了坚强的领导核心。</p><h1 id="第五章-中国革命的新道路">第五章 中国革命的新道路</h1><h2 id="武装反抗国民党反动统治的斗争">武装反抗国民党反动统治的斗争</h2><ul><li><strong>八七会议</strong>：1927.8，中共中央在汉口秘密召开紧急会议，会议确定了土地革命和武装起义的方针，给正在处于思想混乱和组织涣散中的中国共产党指明了新的出路，这是<strong>由大革命失败到土地革命战争兴起的历史性转变</strong>。</li></ul><h2 id="武装起义">武装起义</h2><ul><li><strong>1927.8.1</strong>八一<strong>南昌起义</strong>，武装反抗国民党反动派的第一枪</li><li><strong>1927.9.9</strong>九九<strong>秋收起义</strong>，毛泽东等领导的湘赣边界秋收起义爆发</li><li><strong>1927.10.7</strong><strong>井冈山</strong>农村革命<strong>根据地创立</strong></li><li>1927.12.11 广州起义</li></ul><h2 id="对中国革命新道路的探索">对中国革命新道路的探索</h2><p>毛泽东率领起义军到井冈山后全力进行湘赣边界党、军队和政权的建设。</p><ul><li>1927.11 成立边界第一个红色政权——茶陵县工农兵政府</li><li>1928.10-11 毛泽东——《中国的红色政权为很么能够存在》《井冈山的斗争》<ul><li>提出了工农武装割据的思想</li></ul></li><li>1920.1 毛泽东——《星星之火可以燎原》</li><li>1920.5 毛泽东——《反对本本主义》<ul><li>“没有调查没有发言权”</li><li>“中国革命斗争的胜利要靠中国同志了解中国情况”</li><li>表现毛泽东开辟新道路、创造新理论的革命首创精神</li></ul></li></ul><h2 id="农村革命根据地的建设">农村革命根据地的建设</h2><p>1931.11,中华苏维埃第一期全国代表大会在江西瑞金召开</p><ul><li>成果<ul><li>通过《中华苏维埃共和国宪法大纲》及土地法令、劳动法</li><li>选举产生了中华苏维埃共和国中央执行委员会，</li><li>成立了<strong>中华苏维埃共和国临时中央政府</strong></li><li>毛泽东当选为<strong>主席</strong></li></ul></li><li>意义<ul><li>中华苏维埃共和国是中国历史上<strong>第一个全国性的工农民主政权</strong></li></ul></li></ul><h2 id="遵义会议与长征">遵义会议与长征</h2><ul><li><strong>1934年10月</strong>，红军开始<strong>长征</strong><ul><li>意义<ul><li>是中国共产党和红军在极端困难的条件下进行的一次伟大的战略转移</li><li>是中国革命史上具有伟大历史意义的事件</li><li>使红军保存了有生力量，保存了革命火种，为中国革命的胜利创造了条件</li><li>是一次理想信念的伟大远征，是一次检验真理的伟大远征，是一次唤醒群众的伟大远征，是一次开创新局的伟大远征</li></ul></li></ul></li><li><strong>1935年1月15-17日，遵义会议</strong><ul><li>背景<ul><li>第五次反围剿失败中的“左”倾错误领导</li><li><strong>强渡湘江</strong>，中央红军从长征出发时的8.6万人锐减到3万多人</li></ul></li><li>成果<ul><li>由张闻天代替博古负总的责任，毛泽东为周恩来在军事指挥上的帮助者</li><li>成立由<strong>毛泽东、周恩来、王稼祥</strong>组成的三人小组，<strong>负责全军的军事行动</strong></li></ul></li><li>意义<ul><li>党的历史上一个生死攸关的<strong>转折点</strong></li><li>确立了<strong>毛泽东</strong>在<strong>党中央和红军的领导地位</strong></li><li>开始确立以毛泽东为主要代表的<strong>马克思主义正确路线</strong>在<strong>党中央</strong>的领导地位</li><li>开始形成以毛泽东同志为核心的<strong>第一代中央领导集体</strong></li><li>在最危急关头<strong>挽救</strong>了党、挽救了红军、挽救了中国革命</li></ul></li></ul></li></ul><h1 id="第六章-中华民族的抗日战争">第六章 中华民族的抗日战争</h1><h2 id="九一八事变与七七事变">九一八事变与七七事变</h2><ul><li><strong>1931年9月18日 九一八事变</strong><ul><li>日本变中国为其<strong>独占殖民地</strong>的<strong>侵略战争</strong>由此<strong>开始</strong></li></ul></li><li><strong>1937年7月7日 卢沟桥事变（七七事变）</strong><ul><li>日本<strong>全面侵华战争</strong>由此开始</li></ul></li></ul><h2 id="西安事变及其和平解决">西安事变及其和平解决</h2><p>1936.12，西安事变的和平解决成为时局转换的枢纽，十年内战局面基本结束，<strong>国内和平初步实现</strong></p><h2 id="国共第二次合作">国共第二次合作</h2><ul><li>国民党中央通讯社发表中共中央的宣言《<strong>中共中央为公布国共合作宣言</strong>》</li><li>蒋介石承认共产党合法地位</li><li>意义<ul><li>以<strong>国共两党第二次合作</strong>为基础的<strong>抗日民族统一战线</strong>正式形成</li></ul></li></ul><h2 id="抗日战争各阶段">抗日战争各阶段</h2><ul><li>战略防御 1937.7.7 - 1938.10</li><li>战略相持 1938.10 - 1943.7</li><li>战略反攻 1943.7 - 1945.9</li></ul><h2 id="论持久战">论持久战</h2><p>1938.5-6，毛泽东发表《论持久战》，批驳了“亡国论”、“速胜论”等错误观点，系统阐明持久战方针。</p><h2 id="统一战线中的独立自主原则">统一战线中的独立自主原则</h2><p>由于国共两党代表不同阶级利益，参战目的不尽相同，实行抗战路线不同，统一战线内部存在矛盾和斗争。全民族抗战伊始，中共中央就提出必须在统一战线中坚持独立自主原则。</p><p>1944.9，中共参政员林伯渠在国民参政会上正式提出立即结束国民党一党统治，建立各抗日党派民主联合政府的主张</p><h2 id="新民主主义理论的系统阐明">新民主主义理论的系统阐明</h2><p>1939、1940年之交，毛泽东撰写《《共产党人》发刊词》、《中国革命和中国共产党》、《新民主主义论》等一批重要理论著作</p><h2 id="中共七大前的准备工作">中共七大前的准备工作</h2><ul><li>《关于若干历史问题的决议》：1944.5-1945.4，中共扩大的六届七中全会在延安召开，通过《决议》，为中共七大胜利召开创造充分条件</li><li><strong>中共七大和毛泽东思想指导地位的确立</strong>：1945.4-6，延安</li></ul><h2 id="抗日战争的胜利">抗日战争的胜利</h2><p>中国人民抗日战争的胜利，是近代以来中国人民反抗外敌入侵第一次取得完全胜利的民族解放斗争。</p><ul><li>抗日战争胜利的原因：<ol type="1"><li>爱国主义为核心的民族精神——决定性因素</li><li>中国共产党的中流砥柱作用——关键</li><li>全民族抗战——重要法宝</li><li>世界所有爱好和平和正义的国家、人民、国际组织以及各种反法西斯力量的同情和支持</li></ol></li><li>抗日战争胜利的意义：中华民族从近代以来陷入深重危机<strong>走向伟大复兴的历史转折点</strong><ol type="1"><li>彻底粉碎了日本军国主义殖民奴役中国的图谋，有力<strong>捍卫了国家主权和领土完整</strong>，彻底<strong>洗刷</strong>了近代以来抗击外来侵略屡战屡败的<strong>民族耻辱</strong></li><li>促进了中华民族的大团结，形成了<strong>伟大的抗战精神</strong></li><li>对世界各国夺取反法西斯战争的胜利，维护世界和平产生了巨大影响中国人民赢得了世界爱好和平人民的尊敬，中华民族赢得了崇高的民族声誉</li><li>坚定了中国人民追求民族独立、自由、解放的意志，开启了古老中国凤凰涅槃、浴火重生的历史新征程</li></ol></li></ul><h1 id="第七章-为建立新中国而奋斗">第七章 为建立新中国而奋斗</h1><h2 id="重庆谈判和政治协商会议">重庆谈判和政治协商会议</h2><ul><li>1945年8月28日<strong>重庆谈判</strong>，毛泽东、周恩来、王若飞赴重庆与国民党当局进行谈判</li><li>成果<ul><li>双方签署 <strong>双十协定</strong>：《政府与中共代表会谈纪要》</li><li>确认<strong>和平建国的基本方针</strong></li><li>同意“长期合作，坚决避免内战”</li></ul></li></ul><h2 id="国共全面内战">国共全面内战</h2><p>1946年6月，国民党挑起全面内战</p><h2 id="解放战争">解放战争</h2><ul><li>解放战争的阶段<ul><li>1947.6前 <strong>战略防御</strong></li><li>1947.6后 <strong>战略反攻</strong><ul><li>刘伯承、邓小平 千里跃进<strong>大别山</strong></li><li>陈毅、粟裕 挺进<strong>苏鲁豫皖</strong>地区</li><li>陈赓、谢富治 挺进<strong>豫西</strong></li></ul></li><li>1948秋 <strong>战略决战</strong><ul><li>1948.9-12 <strong>辽沈战役</strong></li><li>1948.11-1949.1 <strong>淮海战役</strong></li><li>1949.1-4 <strong>平津战役</strong></li><li>1949.4-6 <strong>渡江战役</strong></li></ul></li></ul></li><li>1947.10.10，中国人民解放军总部发表宣言：口号：“打倒蒋介石，解救全中国”极大鼓舞了解放军全体指战员和全国人民的斗志</li><li>配合人民解放战争的第二条战线：以学生运动为先导的人民民主运动（在国民党统治区）</li></ul><h2 id="土地改革运动">土地改革运动</h2><ul><li>1946年5月4日，中共中央发布《<strong>关于土地问题的指示</strong>》（<strong>五四指示</strong>）</li><li>1947年7月至9月，<strong>西柏坡</strong>，中国共产党召开<strong>全国土地会议</strong><ul><li>成果<ul><li>制定和通过了《<strong>中国土地法大纲</strong>》</li><li><strong>废除封建性</strong>及半封建性剥削的<strong>土地制度</strong></li><li>实行<strong>耕者有其田的土地制度</strong></li></ul></li><li>意义<ul><li>彻底反封建的土地革命纲领</li></ul></li></ul></li></ul><h1 id="第八章-中华人民共和国的成立与中国社会主义建设道路的探索">第八章中华人民共和国的成立与中国社会主义建设道路的探索</h1><h2 id="探索">探索</h2><ul><li>医疗卫生方面：党和政府提出卫生工作要“面向工农兵”、“预防为主”、“团结中西医”方针</li><li>三反运动：1951-1952，反贪污、反浪费、反官僚主义（新中国成立后党高度重视执政条件下党组织的自身建设）</li></ul><h2 id="党在过渡时期的总路线">党在过渡时期的总路线</h2><p>1953年正式提出<strong>党在过渡时期的总路线</strong>：<strong>一化三改</strong></p><ul><li>逐步实现国家的<strong>社会主义工业化</strong></li><li>逐步实现国家对<strong>农业</strong>、对<strong>手工业</strong>和对<strong>资本主义工商业</strong>的<strong>社会主义改造</strong></li></ul><p>又称“一体两翼”：“一化”是主体，“三改”是两翼</p><h2 id="社会主义改造的基本完成">社会主义改造的基本完成</h2><ul><li>1954.9，全国一大讨论通过《中华人民共和国宪法》（五四宪法）<ul><li>社会主义类型的宪法，提现人民民主原则、社会主义原则</li></ul></li><li>1956年社会主义改造的基本完成，标志着社会主义基本制度的确立。</li><li>中国走社会主义道路具有历史必然性：<ul><li>因为社会主义是马克思主义的社会理想。</li><li>社会主义是中国共产党自创立时就确定的奋斗目标。</li><li>新民主主义的前途必然是社会主义。</li><li>实现社会主义工业化，必须走社会主义道路。</li><li>当时的国际环境也促使中国选择社会主义。</li></ul></li></ul><h2 id="社会主义基本制度确立的伟大意义">社会主义基本制度确立的伟大意义</h2><ol type="1"><li>极大提高工人阶级和广大劳动人民的积极性、创造性，为社会生产力大力发展开辟广阔道路</li><li>为当代中国一切发展进步提供根本政治保障</li></ol><h1 id="第九章-改革开放与中国特色社会主义的开创和发展">第九章改革开放与中国特色社会主义的开创和发展</h1><ul><li>1981.6，党的十一届六中全会通过《关于建国以来的党的若干历史问题的决议》</li><li>1982.9，中国共产党第十二次全国代表大会在北京举行。邓小平在开幕词中响亮提出“把马克思主义的普遍真理同我国的具体实际结合起来，走自己的道路，建设有中国特色的社会主义”。</li><li>1992，下半年中共十四大召开之前，邓小平南方谈话提出“社会主义市场经济体制”</li><li>1992.10.12-18，中共十四大：确定我国经济体制改革的目标是建立社会主义市场经济体制</li><li>2017.10，中共十九大北京召开，通过《中国共产党章程（修正案）》，把习近平新时代中国特色社会主义思想同马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观一道确立为党的行动指南，充分体现了党的十八大以后党的理论创新、实践创新、制度创新成果，充分体现了党的十九大报告确立的重大理论观点和重大战略思想。</li></ul><h1 id="第十章-中国特色社会主义进入新时代">第十章中国特色社会主义进入新时代</h1><p>党的二十大强调，新时代新征程中国共产党的中心任务就是</p><ul><li>团结带领全国各族人民<strong>全面建成社会主义现代化强国</strong></li><li><strong>实现第二个百年奋斗目标</strong></li><li><strong>以中国式现代化全面推进中华民族伟大复兴</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 红课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 近纲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>军事理论</title>
      <link href="/_posts/%E5%86%9B%E4%BA%8B%E7%90%86%E8%AE%BA/"/>
      <url>/_posts/%E5%86%9B%E4%BA%8B%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>闫成老师</em> 2023-2024学年秋季学期教学内容进行整理</p></blockquote><h1 id="第一章-中国国防">第一章 中国国防</h1><h2 id="国防概述">国防概述</h2><ul><li>国防的含义：国家为抵御外来侵略与颠覆，捍卫国家主权、领土完整，维护国家安全、统一和发展，而进行的军事及与军事有关的政治、经济、科技、文化、教育、外交等方面的活动。</li><li>国防的目的：<ul><li><strong>捍卫国家主权</strong>（首要）</li><li>保卫国家的统一、领土完整</li><li>维护国家安全与稳定</li></ul></li><li>现代国防的基本类型<ul><li>扩张型（美国）</li><li>自卫型（中国）</li><li>联盟型（美日、北约）</li><li>中立型（瑞士）。</li></ul></li><li>中国国防历史<ul><li>兵役制度的发展（奴隶制民军制度–封建社会相适应的兵役制度）。</li><li>新时代<strong>防御型</strong>国防政策：国防和军队建设战略目标（三步走，2020年基本实现机械化、2035年基本实现现代化、本世纪中叶全面建成世界一流军队）、服务构建人类命运共同体（一支强大的中国军队，是维护世界和平稳定、服务构建人类命运共同体的坚定力量）。</li></ul></li></ul><h2 id="国防建设">国防建设</h2><ul><li>国防建设的领导体制（五级领导体制）<ul><li>中共中央</li><li>全国人民代表大会及其常务委员会</li><li>国家主席</li><li>国务院</li><li>中央军事委员会在国防方面的职权</li></ul></li><li>国防建设发展<ul><li>1964年10月16日，我国第一颗原子弹爆炸成功。</li><li>第六阶段新要求：<ul><li>坚持以国家核心安全需求为导向，统筹经济建设和国防建设，实现富国和强军的统一。</li><li>确立新时代强军目标。</li><li>重新调整军队规模结构和力量编成。</li><li>确立军民深度融合发展战略。</li></ul></li></ul></li><li>国防建设取得的新成就<ul><li>有效履行新的历史使命（圆满完成非战争军事行动任务属于国防成就）。</li><li>军队信息化建设迈上新台阶。</li><li>形成<strong>军委——军种——部队</strong>的领导管理体系。</li><li>构建军队院校教育、部队训练实践、军事职业教育“三位一体”的新型军事人才培养体系。</li><li>国防科技和武器装备跨越发展。</li><li>国防科技工业军民融合蓬勃发展。</li></ul></li></ul><h2 id="武装力量">武装力量</h2><ul><li>组成：<ul><li>中国人民解放军现役部队和预备役部队</li><li>中国人民武装警察部队</li><li>民兵</li></ul></li><li>组织：<ul><li><strong>领导管</strong>理上实行军委——军种——部队体系</li><li><strong>联合作战指挥</strong>上实行军委——战区——部队体系</li></ul></li><li>军种：<ul><li>陆军</li><li>海军</li><li>空军</li><li>火箭军</li><li>战略支援部队</li><li>联勤保障部队</li></ul></li><li>战区：是本战略方向的唯一最高联合作战指挥机构<ul><li>东部战区</li><li>南部战区</li><li>西部战区</li><li>北部战区</li><li>中部战区</li></ul></li><li>陆军以原18个集团军为基础，调整组建<strong>13</strong>个集团军。</li><li>2012年9月，辽宁号航空母舰列装海军服役（第一艘国产航母为山东号，电磁弹射航母为福建号）。</li><li>火箭军、海军潜地战略导弹部队和空军战略轰炸机部队构成我国三位一体的<strong>战略核力量</strong>。</li><li>战略支援部队是维护国家安全的新型作战力量，是我军新质作战能力的<strong>重要增长点</strong>；是由战略性基础性支撑性都很强的各类保障力量进行功能整合后组建而成的，其主要目的是优化军事力量、提高综合保障能力，为联合作战提供有效支撑。</li><li>武装警察部队由党中央、中央军委集中统一领导，实行中央军委——武警部队——部队领导指挥体制。</li></ul><h2 id="国防动员">国防动员</h2><ul><li>国防动员的含义：国家或政治集团由平时状态转入战时状态，统一调动人力、物力、财力为战争服务的措施。</li><li>国民<strong>经济</strong>动员是战争动员的<strong>基础</strong>。</li></ul><h2 id="国防法规">国防法规</h2><ul><li>《兵役法》规定：我国实行<strong>以志愿兵役为主体</strong>的<strong>志愿兵役与义务兵役相结合</strong>的兵役制度。</li><li>《国防教育法》规定：每年9月第三个星期六为全民国防教育日。</li></ul><h1 id="第二章-国家安全">第二章 国家安全</h1><h2 id="国家安全概述">国家安全概述</h2><ul><li>总体国家安全观<ul><li><strong>以人民安全为宗旨，以政治安全为根本，以经济安全为基础，以军事、文化、社会安全为保障，以促进国际安全为依托</strong>（2014年，习近平提出）。<ul><li>政治安全在国家安全体系中居<strong>核心地位</strong>和<strong>最高层次</strong>，具有根本性战略意义。<br></li><li>生态安全指生态系统完整性和健康的整体水平，尤其是生存与发展的不良风险最小及不受威胁的状态。<br></li><li>生物安全一般指现代生物技术开发和应用对生态环境和人体健康造成的潜在威胁及预防控制措施（与生态安全区分）。</li></ul></li></ul></li></ul><h2 id="国家安全形势">国家安全形势</h2><ul><li>地缘环境基本概况：东部有960万平方公里陆地疆土（世界第三），-2万多公里陆地边界线，与14个国家接壤；300多万平方公里大陆架及专属经济区海洋面积，海岸疆线总长-2万公里（大陆海岸线约-8万公里+岛屿海岸线约-4万公里）。<br></li><li>边界领土争端仍存在，解决难度大，我国与<strong>印度</strong>和<strong>不丹</strong>的陆地边界尚未正式划定。<br></li><li>南海问题涉及“六国七方”权益争端，我国主张“<strong>主权归我，搁置争议</strong>”。<br></li><li>新兴领域国家安全：太空安全、深海安全、极地安全、<strong>网络安全</strong>。</li></ul><h2 id="国际战略局势">国际战略局势</h2><ul><li>美国武装力量特点：文官控制军队，行政领导与作战指挥分离。<br></li><li>美国现行军事战略：新版《印太战略》，以遏制中国崛起为目的。</li></ul><h2 id="中国倡导的新安全观">中国倡导的新安全观</h2><ul><li>共同安全、综合安全、合作安全、可持续安全。</li></ul><h1 id="第三章-军事思想">第三章 军事思想</h1><h2 id="军事思想概述">军事思想概述</h2><ul><li>军事思想含义<ul><li>军事思想是关于战争、军队和国防基本问题的理性认识，属社会意识形态范畴。<br></li></ul></li><li>军事思想基本特征<ul><li>鲜明的阶级性</li><li>强烈的时代性</li><li>明显的继承性</li><li>显著的实践性</li></ul></li></ul><h2 id="外国军事思想">外国军事思想</h2><ul><li>资产阶级军事思想的著名代表人物及其主要观点<br></li><li>拿破仑：重视武力和思想双重作用，重视军队改革和建设。<br></li><li>克劳塞维茨：战争为政治服务，进攻和防御是战争的两种基本作战形式。<br></li><li>若米尼：战略是进行战争的科学，战术是进行战斗的科学。<br></li><li>毛奇：重视铁路、电报等新技术在军事上的运用。<br></li><li>马汉：“海军制胜论”。<br></li><li>杜黑：制空权理论，空中战争论。<br></li><li>富勒：机械化战争。</li></ul><h2 id="中国古代军事思想">中国古代军事思想</h2><ul><li>《尉缭子》：“故兵者，所以诛暴乱，禁不义也”，认为战争作用是镇压暴乱、制止不义行为。<br></li><li>《孙子兵法》：<ul><li>“凡战者，以正合，以奇胜。故善出奇者，无穷如天地，不竭如江河”——奇正互变。<br></li><li>“兵之情主速，乘人之不及”“久暴师则国用不足”“久则钝兵挫锐”“故兵贵胜，不贵久”——速战速决。<br></li><li>“夫用兵之法，全国为上，破国次之；全军为上，破军次之……不战而屈人之兵，善之善者也”——以全征胜，不战而屈人之兵的战略思想。<br></li><li>“善战者，致人而不致于人”——争取战争主动权。</li></ul></li></ul><h2 id="中国当代军事思想">中国当代军事思想</h2><ul><li>毛泽东军事思想：<ul><li><strong>三湾改编</strong>为毛泽东建设人民军队的思想开始形成奠定基础。<br></li><li>十大军事原则、“<strong>两弹一星</strong>”（核弹、导弹和人造卫星）。<br></li><li>人民军队三大任务：战斗队、工作队、生产队。<br></li><li>人民军队三大民主：政治民主、经济民主、军事民主。<br></li><li>政治工作三大原则：官兵一致、军民一致、瓦解敌军。<br></li><li>三大纪律：一切行动听指挥、不拿群众一针一线、一切缴获要归公。</li><li>人民战争属性：群众性、正义性、组织性。</li><li>人是战争胜负的<strong>决定因素</strong>，武器是战争的<strong>重要因素</strong>。</li><li><strong>歼灭战</strong>是基本作战方针。</li><li>三种作战形式（运动战、阵地战、游击战）密切配合并实时转换。</li></ul></li><li>邓小平新时期军队建设思想：建设一支革命化、现代化、正规化的革命军队（三化建设）。</li><li>江泽民国防和军队建设思想：<ul><li>党对军队的绝对领导是我军永远不变的<strong>军魂</strong>。</li><li>围绕“打得赢、不变质”两个历史性课题推进军队建设。</li></ul></li><li>习近平强军思想：<ul><li>强军目标：建设听党指挥、能打胜仗、作风优良的人民军队（<strong>听党指挥是灵魂，能打胜仗是核心，作风优良是保证</strong>）。</li><li>强调依法治军是党建军治军的基本方式。</li></ul></li></ul><h1 id="第四章-现代战争">第四章 现代战争</h1><h2 id="现代战争概述">现代战争概述</h2><ul><li>战争的本质<ul><li>战争是政治的继续，战争形态演变但本质不变。</li></ul></li></ul><h2 id="新军事革命">新军事革命</h2><ul><li>信息化军事革命<ul><li>催生信息化战争（信息时代基本战争形态）。</li></ul></li><li>新军事革命<ul><li>酝酿准备时期为20世纪80年代末，1991年海湾战争有昭示作用。<br></li></ul></li><li>作战样式新类型<ul><li>非对称作战和非接触作战。</li></ul></li></ul><h2 id="机械化战争">机械化战争</h2><ul><li>如苏德战争中的莫斯科战役、斯大林格勒战役胜利。</li></ul><h2 id="信息化战争">信息化战争</h2><ul><li>信息时代<ul><li>信息成为部队战斗力核心要素，<strong>制信息权</strong>是未来战场之“魂”。</li></ul></li><li>数字化部队特点<ul><li>指挥控制灵活、消息传递实时、部队行动快速、武器反应迅速。</li></ul></li><li>信息化战争基本特征<ul><li>战场空间多维化、作战要素一体化。</li></ul></li></ul><h1 id="第五章-信息化装备">第五章 信息化装备</h1><h2 id="信息化装备概述">信息化装备概述</h2><ul><li>信息化装备对现代战争的影响<ul><li>侦察立体化、反应快速化、打击精确化、防护综合化、控制智能化。<br></li></ul></li><li>信息化作战平台发展趋势<ul><li>隐形化、多功能化、无人化。</li></ul></li><li>信息化弹药发展趋势<ul><li>灵巧型、智能性。</li></ul></li></ul><h2 id="信息化作战平台">信息化作战平台</h2><ul><li>坦克<ul><li>具有强大直射火力、高度越野机动性和装甲防护力的履带式装甲战斗车辆（如美国M-1“阿布拉姆斯”、俄罗斯T-90、中国99式）。</li></ul></li><li>海上作战平台<ul><li>在海洋范围活动的舰艇，如航空母舰、潜艇。</li></ul></li><li>信息化空中作战平台<ul><li>战斗机、轰炸机、预警机、空中加油机、直升机、军用运输机。</li></ul></li></ul><h2 id="综合电子信息系统">综合电子信息系统</h2><ul><li>情报侦察系统<ul><li>组成：<ul><li>战略、战役、战术情报侦察系统</li><li>谍报人员和人民群众情报侦察系统</li><li>电子战情报侦察系统</li></ul></li><li>分类：航天、航空、海上及水下、地面侦察系统。</li></ul></li><li>卫星导航系统<ul><li>美国GPS、俄罗斯GLONASS、欧洲伽利略、中国北斗。</li></ul></li></ul><h2 id="信息化杀伤武器">信息化杀伤武器</h2><ul><li>精准制导武器<ul><li>采用精确制导技术，直接命中率50%以上的武器</li></ul></li><li><strong>精准制导方式</strong>：<ul><li>自主制导（惯性、地形匹配、数字景象匹配、卫星定位）</li><li>寻的制导（主动、半主动、被动）、遥控制导（指令、波束）</li><li>复合制导</li></ul></li><li>精确制导弹药：<ul><li>末制导弹药</li><li>末敏弹药</li></ul></li><li>精确制导特点：<ul><li>命中精度高、作战效能高、远程突防能力强、作战效费比高。</li></ul></li><li>核武器<ul><li>原子弹（裂变）、氢弹（聚变）、中子弹（利用聚变效应）。</li></ul></li><li>新概念武器<ul><li>激光武器：烧蚀效应、激波效应、辐射效应。</li><li>粒子束武器、微波武器、动能武器、气象武器、非致命武器、基因武器、纳米武器。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SJTU Notes </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SJTU </tag>
            
            <tag> 军事理论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
