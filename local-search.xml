<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git对文件名大小写不敏感的解决方法</title>
    <link href="/posts/Git%E5%AF%B9%E6%96%87%E4%BB%B6%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/posts/Git%E5%AF%B9%E6%96%87%E4%BB%B6%E5%90%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="问题的发现">问题的发现</h1><p>半小时前，我修改完博客上的《Fluid主题美化》的文章，熟练地执行了Hexo三连后，期待满满地打开浏览器准备查看效果，结果却发现页面的某些组件没有正确显示，然而执行<code>Hexo s</code>命令打开的本地预览页面却一切正常。这是怎么一回事？</p><p><a href="https://youyeyejie.github.io/posts/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/" name="/img/avatar/avatar.jpg" class="LinkCard">Fluid主题美化</a></p><h1 id="问题的排查">问题的排查</h1><p>我首先注意到的是文章中的链接卡片没有被正常渲染，于是首先使用浏览器的开发者工具检查了页面，发现链接卡片成功读取了css样式，但却没有加载js脚本，于是我怀疑是我在修改上一篇文章时，由于调整了<code>linkcard.js</code> ，将其拆分为 <code>LinkCard.js</code> 和<code>LinkCard.css</code>两个文件，同时为了规范化文件名，调整了大小写的格式，这才导致了问题。</p><p>接着我检查本地执行 <code>Hexo cl &amp;&amp; Hexo g</code> 后生成的<code>public/js</code> 目录，发现确实存在 <code>LinkCard.js</code>文件，这也同样印证了此前在本地预览页面时一切正常的结论</p><p>于是我打开博客的Github仓库，却惊讶地发现 <code>js</code>目录下的文件名仍然是 <code>linkcard.js</code>，这就解释了为什么在GithubPages上预览时无法加载js脚本。</p><p>再看看其他被我修改过文件名的文件，无一例外，Github仓库上的文件名都没有被正确更新！原来这就是造成这一切的罪魁祸首！经过搜索，我确定了问题的根源：Git对文件名的大小写变更不敏感，在只修改文件名大小写时，Git不会将其视为一次变更，因此不会提交到仓库中。</p><h1 id="解决方法">解决方法</h1><p>为了解决这个问题，我需要强制Git识别文件名的大小写变更。笨办法是将出现问题的文件修改为其他名称，添加一次后再修改回原来的名称，并再次添加到暂存区，但这样的方法还是太不优雅了，也无法保证下次不会再遇到这个问题。</p><p>因此我们可以设置Git的配置选项来强制它对文件名的大小写变更敏感。具体步骤如下：</p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">config</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--global</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">core.ignorecase</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">false</span></span></code></pre></div></div></figure><p>接着还需要将暂存区中原本的文件移除，然后再重新添加以及提交修改：</p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">rm</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--cached</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-r</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.</span></span></code></pre></div></div></figure><p></p><p>如果不这样做，你就会发现远程仓库将会同时出现大小写不同的两个甚至多个文件，进一步造成混乱。</p><p>至此，问题就解决了！现在你可以放心地修改文件名的大小写，而不必担心Git会忽略这些变更。</p>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题美化</title>
    <link href="/posts/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/"/>
    <url>/posts/Fluid%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="fluid主题美化">Fluid主题美化</h1><p>上一篇博客提到过，我在Fluid、Solitude、Matery、ShokaX等一众主题中选择了Fluid主题，但对于其他主体内置的一些功能，我还是十分眼馋的。那怎么办呢，当然是自己进行美化了。当然，作为一个新手，大部分美化都是参考其他博客的经验进行的，部分自己摸索的美化方式也比较粗糙，不够优雅，参考需谨慎。</p><p>在开始配置主题以及美化前，建议将<code>themes/fluid/_config.yml</code> 文件复制到根目录下，并改名为<code>_config.fluid.yml</code>，后续修改均在<code>_config.fluid.yml</code> 文件中进行，此处的配置会覆盖主题内置的<code>_config.yml</code>文件中的配置，这样可以避免在主题更新时丢失配置。</p><h1 id="黑暗模式下修改加粗字体和斜体样式">黑暗模式下修改加粗字体和斜体样式</h1><p>由于个人习惯在黑暗模式下阅读，且发现Fluid主题在黑暗模式下加粗字体和并不明显，相比之下Matery主题修改了加粗字体的颜色，深得我心，于是决定对Fluid主题进行类似的修改。</p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5565586c" role="button" aria-expanded="false" aria-controls="collapse-5565586c">        <div class="fold-arrow">▶</div>此方式已被弃用，改用无侵入的方法实现      </div>      <div class="fold-collapse collapse" id="collapse-5565586c">        <div class="fold-content">          <p>首先在博客根目录下的 <code>_config.fluid.yml</code> 文件对<code>color</code> 进行修改，增加以下内容 </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #98C379">color：</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 原有内容，下面是新加的</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 文章正文加粗/斜体字体色</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># Color of post text</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">my-post_text_color</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">"#2c3e50"</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">my-post_text_color_dark</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">"#feeed6"</span></span></code></pre></div></div></figure><p></p><p>接着需要修改<code>themes/fluid/source/css/_pages/_base/base.styl</code> 文件，在<code>body</code> 选择器下添加以下内容 </p><figure class="shiki stylus"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">body</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic">// 原有内容，下面是新加的</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">strong</span></span><span class="line"><span style="color: #ABB2BF">    color </span><span style="color: #61AFEF">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--my-post-text-color</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">em</span></span><span class="line"><span style="color: #ABB2BF">    color </span><span style="color: #61AFEF">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--my-post-text-color</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><p></p><p>修改<code>themes/fluid/source/css/_pages/_base/color-schema.styl</code>文件，分别在 <code>:root</code> 和 <code>dark-colors</code>下增加以下内容 </p><figure class="shiki stylus"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">:root</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--my-post-text-color</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">$my-post-text-color</span></span><span class="line"></span><span class="line"><span style="color: #61AFEF">dark-colors</span><span style="color: #ABB2BF">()</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--my-post-text-color</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">$my-post-text-color-dark</span></span></code></pre></div></div></figure><p></p><p>然后修改 <code>themes/fluid/source/css/_variables/base.styl</code>文件，在 <code>post</code> 注释处增加以下内容 </p><figure class="shiki stylus"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">// post</span></span><span class="line"><span style="color: #E06C75">$my-post-text-color</span><span style="color: #ABB2BF"> = </span><span style="color: #61AFEF">theme-config</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"color.my_post_text_color"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"#2c3a46"</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #E06C75">$my-post-text-color-dark</span><span style="color: #ABB2BF"> = </span><span style="color: #61AFEF">theme-config</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"color.my_post_text_color_dark"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"#feeed6"</span><span style="color: #ABB2BF">)</span></span></code></pre></div></div></figure><p></p>        </div>      </div>    </div><p>首先在 <code>source/css/</code> 目录下新建一个<code>StrongInDark.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">:root</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--my-post-text-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#2c3e50</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #C678DD">[</span><span style="color: #D19A66">data-user-color-scheme</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"dark"</span><span style="color: #C678DD">]</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--my-post-text-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#feeed6</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #D19A66">.page-content</span><span style="color: #C678DD"> </span><span style="color: #E06C75">strong</span><span style="color: #ABB2BF">,</span><span style="color: #C678DD"> </span><span style="color: #D19A66">.post-content</span><span style="color: #C678DD"> </span><span style="color: #E06C75">strong</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--my-post-text-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.page-content</span><span style="color: #C678DD"> </span><span style="color: #E06C75">em</span><span style="color: #ABB2BF">,</span><span style="color: #C678DD"> </span><span style="color: #D19A66">.post-content</span><span style="color: #C678DD"> </span><span style="color: #E06C75">em</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--my-post-text-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure> 并在<code>_config.fluid.yml</code> 文件的 <code>custom_css</code>部分添加以下内容： <figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/StrongInDark.css</span></span></code></pre></div></div></figure><p></p><p>至此，黑暗模式下加粗字体和斜体样式的修改就完成了。</p><h1 id="博客标题霓虹灯效样式">博客标题霓虹灯效样式</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-269cf29a" role="button" aria-expanded="false" aria-controls="collapse-269cf29a">        <div class="fold-arrow">▶</div>此方式已被弃用，改用无侵入的方法实现      </div>      <div class="fold-collapse collapse" id="collapse-269cf29a">        <div class="fold-content">          <p>由于我对Fluid的各种设置不太了解，导致我在上一步修改加粗字体和斜体样式后，博客的标题也被修改了颜色，因此我又单独调整了博客标题的颜色。</p><p>首先在<code>themes/fluid/source/css/_pages/_base/_widget/header.styl</code>文件中进行修改，追加以下内容 </p><figure class="shiki stylus"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #D19A66">.navbar-title</span></span><span class="line"><span style="color: #ABB2BF">  outline </span><span style="color: #D19A66">none</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF"> lightseagreen</span></span><span class="line"><span style="color: #ABB2BF">  text-shadow </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">),</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">20</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">),</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">40</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">),</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">80</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">),</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">160</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">  animation animate </span><span style="color: #D19A66">5</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">linear</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">infinite</span></span><span class="line"><span style="color: #ABB2BF">  color </span><span style="color: #61AFEF">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--navbar_text_color</span><span style="color: #ABB2BF">)</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">@keyframes</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">animate</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #D19A66">to</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">      filter: </span><span style="color: #56B6C2">hue-rotate</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">360</span><span style="color: #E06C75">deg</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">  }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure> 其中<code>color var(--navbar_text_color)</code>是为了将博客标题的颜色恢复为我们在 <code>_config.fluid.yml</code>文件中设置的颜色。<p></p>        </div>      </div>    </div><p>标题的霓虹灯效果是参考KEVIN’S BLOG的实现并进行修改。</p><p><a href="https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/" name="https://static.kevinchu.top/blog/assets/img/avatar_03.jpg" class="LinkCard">Hexo博客Fluid主题魔改记录</a></p><p>首先在 <code>source/css/</code> 目录下新建一个<code>TitleNeon.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #D19A66">.navbar-title</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  outline: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">: lightseagreen;</span></span><span class="line"><span style="color: #ABB2BF">  text-shadow: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">), </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">20</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">), </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">40</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">), </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">80</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">), </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">160</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--c</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">  animation: animate </span><span style="color: #D19A66">5</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">linear</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">infinite</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #C678DD">@keyframes</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">animate</span><span style="color: #ABB2BF">{</span></span><span class="line"><span style="color: #ABB2BF">  to{</span></span><span class="line"><span style="color: #ABB2BF">      filter: </span><span style="color: #56B6C2">hue-rotate</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">360</span><span style="color: #E06C75">deg</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">  }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>然后在 <code>_config.fluid.yml</code> 文件的 <code>custom_css</code>部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/TitleNeon.css</span></span></code></pre></div></div></figure><p></p><p>当然，为了使博客标题的霓虹灯效果生效，还是不可避免的需要对主题文件进行修改。</p><p>需要修改的是<code>themes/fluid/layout/_partials/header/navigation.ejs</code>文件，在最前面几行找到对应导航栏标题的标签内容进行修改即可：</p><figure class="shiki diff"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">-&lt;strong&gt;&lt;%= theme.navbar.blog_title || config.title %&gt;&lt;/strong&gt;</span></span><span class="line"><span style="color: #98C379">+&lt;strong class="navbar-title"&gt;&lt;%= theme.navbar.blog_title || config.title %&gt;&lt;/strong&gt;</span></span></code></pre></div></div></figure><p></p><p>至此，博客标题的霓虹灯效果就完成了。</p><h1 id="标题颜色渐变样式">标题颜色渐变样式</h1><p>实现标题颜色渐变效果的代码同样参考了的是EmoryHuang’sBlog的实现并进行修改。</p><p><a href="https://emoryhuang.cn/blog/1729600336.html" name="https://emoryhuang.cn/img/friend_404.gif" class="LinkCard">EmoryHuang’sBlog</a></p><p>在 <code>source/css/</code> 目录下新建一个<code>TitleGradient.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">#subtitle</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    background: </span><span style="color: #56B6C2">linear-gradient</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">-45</span><span style="color: #E06C75">deg</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">#0f76c1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">#3a8dc0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">#80d2ef</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">#ffffff</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-background-clip</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">text</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    background-clip: </span><span style="color: #D19A66">text</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-text-fill-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">transparent</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>并在 <code>_config.fluid.yml</code> 文件的 <code>custom_css</code>部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/TitleGradient.css</span></span></code></pre></div></div></figure><p></p><h1 id="修改滚动条样式">修改滚动条样式</h1><p>原本页面右侧的滚动条和默认代码块、行间公式的滚动条样式都比较朴素，因此我参考了EmoryHuang’sBlog的代码并进行了一些修改，为滚动条添加了样式。</p><p>在 <code>source/css/</code> 目录下新建一个 <code>ScrollBar.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">::-webkit-scrollbar</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    width: </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    height: </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #56B6C2">::-webkit-scrollbar-thumb</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    background-color: </span><span style="color: #D19A66">#679ed9</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    background-image: </span><span style="color: #56B6C2">-webkit-linear-gradient</span><span style="color: #ABB2BF">( </span><span style="color: #D19A66">45</span><span style="color: #E06C75">deg</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0.4</span><span style="color: #ABB2BF">) </span><span style="color: #D19A66">25</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">transparent</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">25</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">transparent</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">50</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0.4</span><span style="color: #ABB2BF">) </span><span style="color: #D19A66">50</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0.4</span><span style="color: #ABB2BF">) </span><span style="color: #D19A66">75</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">transparent</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">75</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">transparent</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">2</span><span style="color: #E06C75">em</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #56B6C2">::-webkit-scrollbar-corner</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    background-color: </span><span style="color: #D19A66">transparent</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #56B6C2">::-moz-selection</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #D19A66">#fff</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    background-color: </span><span style="color: #D19A66">#7095da</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>并在 <code>_config.fluid.yml</code> 文件的 <code>custom_css</code>部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/ScrollBar.css</span></span></code></pre></div></div></figure><p></p><h1 id="使用mac风格代码块样式">使用Mac风格代码块样式</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-82a7ba27" role="button" aria-expanded="false" aria-controls="collapse-82a7ba27">        <div class="fold-arrow">▶</div>此方式已被弃用，博主采用另一种方式实现      </div>      <div class="fold-collapse collapse" id="collapse-82a7ba27">        <div class="fold-content">          <p>原本的代码块风格比较朴素，因此我参考KEVIN’SBLOG的代码块样式，修改为MAC风格。</p><p><a href="https://blog.kevinchu.top/2023/07/17/hexo-theme-fluid-modify/" name="https://static.kevinchu.top/blog/assets/img/avatar_03.jpg" class="LinkCard">Hexo博客Fluid主题魔改记录</a></p><p>在 <code>source/css/</code> 目录下新建一个 <code>MacPanel.styl</code>文件，内容如下： </p><figure class="shiki stylus"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #D19A66">.highlight</span></span><span class="line"><span style="color: #ABB2BF">    background: </span><span style="color: #D19A66">#21252b</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">5</span><span style="color: #E06C75">px</span></span><span class="line"><span style="color: #ABB2BF">    box-shadow: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">30</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">.4</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    padding-top: </span><span style="color: #D19A66">30</span><span style="color: #E06C75">px</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">    &amp;</span><span style="color: #56B6C2">::before</span></span><span class="line"><span style="color: #ABB2BF">      background: </span><span style="color: #D19A66">#fc625d</span></span><span class="line"><span style="color: #ABB2BF">      border-radius: </span><span style="color: #D19A66">50</span><span style="color: #E06C75">%</span></span><span class="line"><span style="color: #ABB2BF">      box-shadow: </span><span style="color: #D19A66">20</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">#fdbc40</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">40</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">#35cd4b</span></span><span class="line"><span style="color: #ABB2BF">      content: </span><span style="color: #98C379">' '</span></span><span class="line"><span style="color: #ABB2BF">      height: </span><span style="color: #D19A66">12</span><span style="color: #E06C75">px</span></span><span class="line"><span style="color: #ABB2BF">      left: </span><span style="color: #D19A66">12</span><span style="color: #E06C75">px</span></span><span class="line"><span style="color: #ABB2BF">      margin-top: </span><span style="color: #D19A66">-20</span><span style="color: #E06C75">px</span></span><span class="line"><span style="color: #ABB2BF">      position: </span><span style="color: #D19A66">absolute</span></span><span class="line"><span style="color: #ABB2BF">      width: </span><span style="color: #D19A66">12</span><span style="color: #E06C75">px</span></span></code></pre></div></div></figure><p></p><p>并在 <code>_config.fluid.yml</code> 文件的 <code>custom_css</code>部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/MacPanel</span></span></code></pre></div></div></figure><p></p>        </div>      </div>    </div><p>起初我使用的是上面被折叠的方式，但是在写这篇文章时发现存在一个问题：代码块不具备折叠功能！这导致了一旦插入长代码，就会占用大量页面空间，既不美观也不方便阅读。因此，我参考了4rozeN的实现方法，将渲染器更换为Hexo Shiki Plugin。此处感谢4rozeN的答疑解惑。</p><p><a href="https://4rozen.github.io/archives/Hexo/41513.html" name="https://4rozen.github.io/img/avatar/avatar.jpg" class="LinkCard">Hexo博客 Fluid 主题实现代码折叠和文字遮盖效果</a></p><p>Hexo Shiki Plugin是一个Hexo插件，仓库地址见下方。</p><p><a href="https://github.com/nova1751/hexo-shiki-plugin/" name="https://avatars.githubusercontent.com/u/97817985?v=4" class="LinkCard">HexoShiki Plugin</a></p><p>具体安装额和使用方法如下：</p><ol type="1"><li>在博客根目录下执行以下命令安装插件： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">npm</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">install</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">hexo-shiki-plugin</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--save</span></span></code></pre></div></div></figure></li><li>修改博客根目录下的 <code>_config.yml</code> 文件：<figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">syntax_highlighter</span><span style="color: #ABB2BF">: </span><span style="color: #7F848E; font-style: italic"># 留空</span></span><span class="line"><span style="color: #E06C75">highlight</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">enable</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">false</span></span><span class="line"><span style="color: #E06C75">prismjs</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">enable</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">false</span></span><span class="line"><span style="color: #E06C75">shiki</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">theme</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">one-dark-pro</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># highlight-theme：one-dark-pro / github-light / github-dark / material-theme-palenight</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">line_number</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># whether to show the line_number</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">beautify</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># whether to add highlight tool true or false</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">highlight_copy</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># copy button</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">highlight_lang</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># show the code language</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">highlight_height_limit</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">360</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># code-block max height,unit: px</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">is_highlight_shrink</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># true: shrink the code blocks / false: expand the code blocks | none: expand code blocks and hide the button</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">copy</span><span style="color: #ABB2BF">: </span><span style="color: #7F848E; font-style: italic"># copy message</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">success</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'Copy Success'</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">error</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'Copy Error'</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">no_support</span><span style="color: #ABB2BF">: </span><span style="color: #98C379">'Browser Not Support'</span></span></code></pre></div></div></figure></li><li>修改 <code>_config.fluid.yml</code> 文件，修改 <code>code</code>中的 <code>highlight</code> 部分： <figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">code</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">copy_btn</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">false</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">language</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #E06C75">enable</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">false</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">highlight</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #E06C75">enable</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">false</span></span></code></pre></div></div></figure></li><li>在 <code>_config.fluid.yml</code> 文件的 <code>custom_css</code>部分添加以下内容以引入font-awesome图标库： <figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">https://lib.baomitu.com/font-awesome/6.1.2/css/all.min.css</span></span></code></pre></div></div></figure></li><li>此时我发现折叠代码下方的折叠按钮很不明显，因此在<code>source/css/</code> 目录下新建一个 <code>CodeBlock.css</code>文件（如果不存在该目录则需要先创建），代码如下： <figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #D19A66">.markdown-body</span><span style="color: #C678DD"> </span><span style="color: #E06C75">code</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #D19A66">.markdown-body</span><span style="color: #C678DD"> </span><span style="color: #E06C75">pre</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  font-family: </span><span style="color: #98C379">"JetBrains Mono"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"Fira Code"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"Noto Sans SC"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"Source Code Pro"</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">monospace</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  line-height: </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">/* 以下样式给 shiki 代码块使用 */</span></span><span class="line"><span style="color: #D19A66">.code-expand-btn</span><span style="color: #C678DD"> </span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  color: </span><span style="color: #D19A66">#ffffff</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">/* 展开或隐藏代码块的按钮颜色 */</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #56B6C2">:root</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--hlnumber-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#a5a5a5</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">/* 行号颜色 */</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--hl-bg</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#1f1f1f</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">/* 代码块背景颜色 */</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--hlnumber-bg</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#1f1f1f</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">/* 行号背景颜色 */</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--hlexpand-bg</span><span style="color: #ABB2BF">: </span><span style="color: #56B6C2">linear-gradient</span><span style="color: #ABB2BF">(</span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #D19A66">180</span><span style="color: #E06C75">deg</span><span style="color: #ABB2BF">, </span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">255</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0.1</span><span style="color: #ABB2BF">), </span></span><span class="line"><span style="color: #ABB2BF"></span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">40</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">44</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">52</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0.9</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #E06C75">pre</span><span style="color: #C678DD"> </span><span style="color: #E06C75">code</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  color: </span><span style="color: #D19A66">#b9b9b9</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">/* 没有颜色方案的代码语言的表现色 */</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure> 并在<code>_config.fluid.yml</code> 文件的 <code>custom_css</code>部分添加以下内容： <figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/CodeBlock.css</span></span></code></pre></div></div></figure></li></ol><h1 id="修改行内代码样式">修改行内代码样式</h1><p>这个功能实现起来非常简单，只需要在 <code>source/css/</code>目录下新建一个 <code>CodeInLine.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #D19A66">.markdown-body</span><span style="color: #C678DD"> </span><span style="color: #E06C75">code</span><span style="color: #ABB2BF">,</span><span style="color: #C678DD"> </span><span style="color: #D19A66">.markdown-body</span><span style="color: #C678DD"> </span><span style="color: #E06C75">pre</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  font-family: </span><span style="color: #98C379">"JetBrains Mono"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"Fira Code"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"Noto Sans SC"</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"Source Code Pro"</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">monospace</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  line-height: </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  color: </span><span style="color: #D19A66">#E05B35</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>并在 <code>_config.fluid.yml</code> 文件的 <code>custom_css</code>部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/CodeInLine.css</span></span></code></pre></div></div></figure><p></p><h1 id="文章界面背景毛玻璃样式">文章界面背景毛玻璃样式</h1><p>谁知道我到底有多喜欢毛玻璃！因此我又为文章界面添加了毛玻璃样式，这部分参考的是4rozeN的博客，并进行了部分修改。</p><p><a href="https://4rozen.github.io/archives/Hexo/60191.html" name="https://4rozen.github.io/img/avatar/avatar.jpg" class="LinkCard">Hexofluid 全屏背景图随日夜模式切换以及正文底页毛玻璃效果</a></p><p>首先在 <code>source/css/</code> 目录下新建一个<code>FrostedGlassBg.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">#board</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #56B6C2">-webkit-backdrop-filter</span><span style="color: #ABB2BF">: </span><span style="color: #56B6C2">blur</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">15</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">  backdrop-filter: </span><span style="color: #56B6C2">blur</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">15</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #61AFEF">#toc</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  padding: </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  top: </span><span style="color: #D19A66">4</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  background-color: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--board-bg-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">  border-radius: </span><span style="color: #D19A66">10</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #56B6C2">-webkit-backdrop-filter</span><span style="color: #ABB2BF">: </span><span style="color: #56B6C2">blur</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">15</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">  backdrop-filter: </span><span style="color: #56B6C2">blur</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">15</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>然后修改 <code>_config.fluid.yml</code> 文件的中的主面板背景色</p><figure class="shiki diff"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">-board_color: "#ffffff"</span></span><span class="line"><span style="color: #E06C75">-board_color_dark: "#151722"</span></span><span class="line"><span style="color: #98C379">+board_color:  "#ffffff80"</span></span><span class="line"><span style="color: #98C379">+board_color_dark: "#15172280"</span></span></code></pre></div></div></figure><p></p><p>当然，也需要在 <code>_config.fluid.yml</code> 文件的<code>custom_css</code> 部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/FrostedGlassBg.css</span></span></code></pre></div></div></figure><p></p><p>这样我们就实现了文章界面的毛玻璃样式。4rozeN在博客中还实现了背景图全屏显示以及随日夜模式切换的效果，但由于我个人认为这样或许会使得显示比较杂乱，因此暂时未加入此功能。</p><h1 id="链接卡片样式">链接卡片样式</h1><p>在Fluid主题中，没有内置的链接卡片样式，因此参照丁丁の店的处理方式，并进行了一些修改和优化，为链接添加了卡片样式。</p><p><a href="https://blog.butanediol.me/2020/06/03/Hexo%20改良版知乎外链卡片/" name="https://blog.butanediol.me/media/avatar.png" class="LinkCard">Hexo改良版知乎“外链卡片”</a></p>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-40cfb162" role="button" aria-expanded="false" aria-controls="collapse-40cfb162">        <div class="fold-arrow">▶</div>此方式已被弃用，改用样式与功能分离的方法实现      </div>      <div class="fold-collapse collapse" id="collapse-40cfb162">        <div class="fold-content">          <p>在 <code>source/js/</code> 目录下新建一个 <code>LinkCard.js</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">onload</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> () {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isDarkMode</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">htmlElement</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">documentElement</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">userScheme</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">htmlElement</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'data-user-color-scheme'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">defaultScheme</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">htmlElement</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'data-default-color-scheme'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 如果用户手动设置了主题，优先使用用户设置</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">userScheme</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">userScheme</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'dark'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 否则使用默认主题设置</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">defaultScheme</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">defaultScheme</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'dark'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 如果都没有设置，检查系统偏好</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">matchMedia</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'(prefers-color-scheme: dark)'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">matches</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 监听主题切换，动态更新卡片背景色</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">updateLinkCardStyle</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(() </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'LinkCardStyle'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">style</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">color</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isDarkMode</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'#242a38'</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'#eeefef'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">innerHTML</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">replace</span><span style="color: #ABB2BF">(</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">/(</span><span style="color: #56B6C2">\.</span><span style="color: #E06C75">LinkCard-content\s</span><span style="color: #D19A66">*</span><span style="color: #56B6C2">\{</span><span style="color: #D19A66">[</span><span style="color: #ABB2BF">^</span><span style="color: #D19A66">}]*</span><span style="color: #E06C75">background-color:\s</span><span style="color: #D19A66">*</span><span style="color: #E06C75">)(#</span><span style="color: #D19A66">[0-9a-fA-F]{6}</span><span style="color: #ABB2BF">|</span><span style="color: #E06C75">#</span><span style="color: #D19A66">[0-9a-fA-F]{3}</span><span style="color: #ABB2BF">|</span><span style="color: #E06C75">rgba</span><span style="color: #D19A66">?</span><span style="color: #56B6C2">\(</span><span style="color: #D19A66">[</span><span style="color: #ABB2BF">^</span><span style="color: #D19A66">)]+</span><span style="color: #56B6C2">\)</span><span style="color: #E06C75">);/</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #98C379">`$1</span><span style="color: #C678DD">${</span><span style="color: #E06C75">color</span><span style="color: #C678DD">}</span><span style="color: #98C379">;`</span></span><span class="line"><span style="color: #ABB2BF">                );</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }, </span><span style="color: #D19A66">60</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 监听自定义事件和系统主题变化</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">observer</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">MutationObserver</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">updateLinkCardStyle</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">observer</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">observe</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">documentElement</span><span style="color: #ABB2BF">, { </span><span style="color: #E06C75">attributes</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">attributeFilter</span><span style="color: #ABB2BF">: [</span><span style="color: #98C379">'data-user-color-scheme'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'data-default-color-scheme'</span><span style="color: #ABB2BF">] });</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">matchMedia</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'(prefers-color-scheme: dark)'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">addEventListener</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'change'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">updateLinkCardStyle</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">LinkCards</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementsByClassName</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'LinkCard'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; </span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">LinkCards</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">; </span><span style="color: #E06C75">i</span><span style="color: #56B6C2">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementById</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'LinkCardStyle'</span><span style="color: #ABB2BF">)) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">style</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createElement</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'style'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">id</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'LinkCardStyle'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">color</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isDarkMode</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'#242a38'</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'#eeefef'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">`</span></span><span class="line"><span style="color: #98C379">            .LinkCard, .LinkCard:hover {</span></span><span class="line"><span style="color: #98C379">                text-decoration: none;</span></span><span class="line"><span style="color: #98C379">                border: none !important;</span></span><span class="line"><span style="color: #98C379">                color: inherit !important;</span></span><span class="line"><span style="color: #98C379">            }</span></span><span class="line"><span style="color: #98C379">            .LinkCard {</span></span><span class="line"><span style="color: #98C379">                position: relative;</span></span><span class="line"><span style="color: #98C379">                display: block;</span></span><span class="line"><span style="color: #98C379">                margin: 1em auto;</span></span><span class="line"><span style="color: #98C379">                width: 60%;</span></span><span class="line"><span style="color: #98C379">                box-sizing: border-box;</span></span><span class="line"><span style="color: #98C379">                border-radius: 12px;</span></span><span class="line"><span style="color: #98C379">                max-width: 100%;</span></span><span class="line"><span style="color: #98C379">                overflow: hidden;</span></span><span class="line"><span style="color: #98C379">                color: inherit;</span></span><span class="line"><span style="color: #98C379">                text-decoration: none;</span></span><span class="line"><span style="color: #98C379">            }</span></span><span class="line"><span style="color: #98C379">            .ztext { word-break: break-word; line-height: 1.6; }</span></span><span class="line"><span style="color: #98C379">            .LinkCard-backdrop {</span></span><span class="line"><span style="color: #98C379">                position: absolute;</span></span><span class="line"><span style="color: #98C379">                top: 0; left: 0; right: 0; bottom: 0;</span></span><span class="line"><span style="color: #98C379">                background-repeat: no-repeat;</span></span><span class="line"><span style="color: #98C379">                -webkit-filter: blur(20px);</span></span><span class="line"><span style="color: #98C379">                filter: blur(20px);</span></span><span class="line"><span style="color: #98C379">                background-size: cover;</span></span><span class="line"><span style="color: #98C379">                background-position: center;</span></span><span class="line"><span style="color: #98C379">            }</span></span><span class="line"><span style="color: #98C379">            .LinkCard-content {</span></span><span class="line"><span style="color: #98C379">                position: relative;</span></span><span class="line"><span style="color: #98C379">                display: flex;</span></span><span class="line"><span style="color: #98C379">                align-items: center;</span></span><span class="line"><span style="color: #98C379">                justify-content: space-between;</span></span><span class="line"><span style="color: #98C379">                padding: 12px;</span></span><span class="line"><span style="color: #98C379">                border-radius: inherit;</span></span><span class="line"><span style="color: #98C379">                background-color: </span><span style="color: #C678DD">${</span><span style="color: #E06C75">color</span><span style="color: #C678DD">}</span><span style="color: #98C379">;</span></span><span class="line"><span style="color: #98C379">            }</span></span><span class="line"><span style="color: #98C379">            .LinkCard-text { overflow: hidden; }</span></span><span class="line"><span style="color: #98C379">            .LinkCard-title {</span></span><span class="line"><span style="color: #98C379">                display: -webkit-box;</span></span><span class="line"><span style="color: #98C379">                -webkit-line-clamp: 2;</span></span><span class="line"><span style="color: #98C379">                overflow: hidden;</span></span><span class="line"><span style="color: #98C379">                text-overflow: ellipsis;</span></span><span class="line"><span style="color: #98C379">                max-height: calc(16px * 1.25 * 2);</span></span><span class="line"><span style="color: #98C379">                font-size: 16px;</span></span><span class="line"><span style="color: #98C379">                font-weight: 500;</span></span><span class="line"><span style="color: #98C379">                line-height: 1.25;</span></span><span class="line"><span style="color: #98C379">                color: inherit;</span></span><span class="line"><span style="color: #98C379">            }</span></span><span class="line"><span style="color: #98C379">            .LinkCard-meta {</span></span><span class="line"><span style="color: #98C379">                display: flex;</span></span><span class="line"><span style="color: #98C379">                margin-top: 4px;</span></span><span class="line"><span style="color: #98C379">                font-size: 14px;</span></span><span class="line"><span style="color: #98C379">                line-height: 20px;</span></span><span class="line"><span style="color: #98C379">                color: #999;</span></span><span class="line"><span style="color: #98C379">                white-space: nowrap;</span></span><span class="line"><span style="color: #98C379">            }</span></span><span class="line"><span style="color: #98C379">            .LinkCard-imageCell {</span></span><span class="line"><span style="color: #98C379">                margin-left: 8px;</span></span><span class="line"><span style="color: #98C379">                border-radius: 6px;</span></span><span class="line"><span style="color: #98C379">            }</span></span><span class="line"><span style="color: #98C379">            .LinkCard-image {</span></span><span class="line"><span style="color: #98C379">                display: block;</span></span><span class="line"><span style="color: #98C379">                width: 60px;</span></span><span class="line"><span style="color: #98C379">                height: auto;</span></span><span class="line"><span style="color: #98C379">                border-radius: inherit;</span></span><span class="line"><span style="color: #98C379">                margin-bottom: 0 !important;</span></span><span class="line"><span style="color: #98C379">            }</span></span><span class="line"><span style="color: #98C379">            `</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">appendChild</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">style</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 截断链接</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">truncateLink</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">url</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">maxLength</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">url</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">maxLength</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">url</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">url</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">slice</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">maxLength</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'...'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">LinkCard</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">LinkCards</span><span style="color: #ABB2BF">[</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">link</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">LinkCard</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">href</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">title</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">LinkCard</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">logourl</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">LinkCard</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">name</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">displayLink</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">truncateLink</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">link</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">32</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">LinkCard</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #98C379">`&lt;span class="LinkCard-backdrop" style="background-image:url(/images/logo.svg)"&gt;&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;span class="LinkCard-content"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span class="LinkCard-text"&gt;</span></span><span class="line"><span style="color: #98C379">                    &lt;span class="LinkCard-title"&gt;</span><span style="color: #C678DD">${</span><span style="color: #E06C75">title</span><span style="color: #C678DD">}</span><span style="color: #98C379">&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                    &lt;span class="LinkCard-meta"&gt;</span></span><span class="line"><span style="color: #98C379">                        &lt;span style="display:inline-flex;align-items:center"&gt;</span></span><span class="line"><span style="color: #98C379">                            &lt;svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"&gt;</span></span><span class="line"><span style="color: #98C379">                                &lt;path d="M6.77 17.23c-.905-.904-.94-2.333-.08-3.193l3.059-3.06-1.192-1.19-3.059 3.058c-1.489 1.489-1.427 3.954.138 5.519s4.03 1.627 5.519.138l3.059-3.059-1.192-1.192-3.059 3.06c-.86.86-2.289.824-3.193-.08zm3.016-8.673l1.192 1.192 3.059-3.06c.86-.86 2.289-.824 3.193.08.905.905.94 2.334.08 3.194l-3.059 3.06 1.192 1.19 3.059-3.058c1.489-1.489 1.427-3.954-.138-5.519s-4.03-1.627-5.519-.138L9.786 8.557zm-1.023 6.68c.33.33.863.343 1.177.029l5.34-5.34c.314-.314.3-.846-.03-1.176-.33-.33-.862-.344-1.176-.03l-5.34 5.34c-.314.314-.3.846.03 1.177z" fill-rule="evenodd"&gt;&lt;/path&gt;</span></span><span class="line"><span style="color: #98C379">                            &lt;/svg&gt;</span></span><span class="line"><span style="color: #98C379">                        &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                        &lt;a href="</span><span style="color: #C678DD">${</span><span style="color: #E06C75">link</span><span style="color: #C678DD">}</span><span style="color: #98C379">" title="</span><span style="color: #C678DD">${</span><span style="color: #E06C75">link</span><span style="color: #C678DD">}</span><span style="color: #98C379">" style="color:inherit;text-decoration:none;"&gt;</span><span style="color: #C678DD">${</span><span style="color: #E06C75">displayLink</span><span style="color: #C678DD">}</span><span style="color: #98C379">&lt;/a&gt;</span></span><span class="line"><span style="color: #98C379">                    &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span class="LinkCard-imageCell"&gt;</span></span><span class="line"><span style="color: #98C379">                    &lt;img class="LinkCard-image" alt="logo" src="</span><span style="color: #C678DD">${</span><span style="color: #E06C75">logourl</span><span style="color: #C678DD">}</span><span style="color: #98C379">"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;/span&gt;`</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>然后在 <code>_config.fluid.yml</code> 文件的 <code>custom_js</code>部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_js</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/LinkCard.js</span></span></code></pre></div></div></figure><p></p>        </div>      </div>    </div><p>为了实现样式与功能分离，我将该博主的代码进行了修改：</p><p>在 <code>source/css/</code> 目录下新建一个 <code>LinkCard.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">:root</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--linkcard-bg-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#eeefef</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #C678DD">[</span><span style="color: #D19A66">data-user-color-scheme</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"dark"</span><span style="color: #C678DD">]</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E06C75">--linkcard-bg-color</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">#242a38</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #D19A66">.LinkCard</span><span style="color: #ABB2BF">,</span><span style="color: #C678DD"> </span><span style="color: #D19A66">.LinkCard</span><span style="color: #56B6C2">:hover</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    text-decoration: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    border: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #D19A66">inherit</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.LinkCard</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    position: </span><span style="color: #D19A66">relative</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">block</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    margin: </span><span style="color: #D19A66">1</span><span style="color: #E06C75">em</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">auto</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    width: </span><span style="color: #D19A66">60</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    box-sizing: </span><span style="color: #D19A66">border-box</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">12</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    max-width: </span><span style="color: #D19A66">100</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    overflow: </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #D19A66">inherit</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    text-decoration: </span><span style="color: #D19A66">none</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    background: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--linkcard-bg-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.ztext</span><span style="color: #ABB2BF"> { word-break: </span><span style="color: #D19A66">break-word</span><span style="color: #ABB2BF">; line-height: </span><span style="color: #D19A66">1.6</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #D19A66">.LinkCard-backdrop</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    position: </span><span style="color: #D19A66">absolute</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    top: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; left: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; right: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; bottom: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    background-repeat: </span><span style="color: #D19A66">no-repeat</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-filter</span><span style="color: #ABB2BF">: </span><span style="color: #56B6C2">blur</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">20</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    filter: </span><span style="color: #56B6C2">blur</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">20</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    background-size: </span><span style="color: #D19A66">cover</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    background-position: </span><span style="color: #D19A66">center</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.LinkCard-content</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    position: </span><span style="color: #D19A66">relative</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">flex</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    align-items: </span><span style="color: #D19A66">center</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    justify-content: </span><span style="color: #D19A66">space-between</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    padding: </span><span style="color: #D19A66">12</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">inherit</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    background-color: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--linkcard-bg-color</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.LinkCard-text</span><span style="color: #ABB2BF"> { overflow: </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #D19A66">.LinkCard-title</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    display: -webkit-box;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #56B6C2">-webkit-line-clamp</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    line-clamp: </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    overflow: </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    text-overflow: </span><span style="color: #D19A66">ellipsis</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    max-height: </span><span style="color: #56B6C2">calc</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">16</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1.25</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    font-size: </span><span style="color: #D19A66">16</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    font-weight: </span><span style="color: #D19A66">500</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    line-height: </span><span style="color: #D19A66">1.25</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #D19A66">inherit</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.LinkCard-meta</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">flex</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    margin-top: </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    font-size: </span><span style="color: #D19A66">14</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    line-height: </span><span style="color: #D19A66">20</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    color: </span><span style="color: #D19A66">#999</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    white-space: </span><span style="color: #D19A66">nowrap</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.LinkCard-imageCell</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    margin-left: </span><span style="color: #D19A66">8</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">6</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.LinkCard-image</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    display: </span><span style="color: #D19A66">block</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    width: </span><span style="color: #D19A66">60</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    height: </span><span style="color: #D19A66">auto</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    border-radius: </span><span style="color: #D19A66">inherit</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    margin-bottom: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">!important</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>然后还需要在 <code>source/js/</code> 目录下新建一个<code>LinkCard.js</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">onload</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> () {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">LinkCards</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementsByClassName</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'LinkCard'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; </span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">LinkCards</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">; </span><span style="color: #E06C75">i</span><span style="color: #56B6C2">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 截断链接</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">truncateLink</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">url</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">maxLength</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">url</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">maxLength</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">url</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">url</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">slice</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">maxLength</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'...'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">LinkCard</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">LinkCards</span><span style="color: #ABB2BF">[</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">link</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">LinkCard</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">href</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">title</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">LinkCard</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerText</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">logourl</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">LinkCard</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">name</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">displayLink</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">truncateLink</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">link</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">32</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">LinkCard</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerHTML</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #98C379">`&lt;span class="LinkCard-backdrop" style="background-image:url(/images/logo.svg)"&gt;&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;span class="LinkCard-content"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span class="LinkCard-text"&gt;</span></span><span class="line"><span style="color: #98C379">                    &lt;span class="LinkCard-title"&gt;</span><span style="color: #C678DD">${</span><span style="color: #E06C75">title</span><span style="color: #C678DD">}</span><span style="color: #98C379">&lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                    &lt;span class="LinkCard-meta"&gt;</span></span><span class="line"><span style="color: #98C379">                        &lt;span style="display:inline-flex;align-items:center"&gt;</span></span><span class="line"><span style="color: #98C379">                            &lt;svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"&gt;</span></span><span class="line"><span style="color: #98C379">                                &lt;path d="M6.77 17.23c-.905-.904-.94-2.333-.08-3.193l3.059-3.06-1.192-1.19-3.059 3.058c-1.489 1.489-1.427 3.954.138 5.519s4.03 1.627 5.519.138l3.059-3.059-1.192-1.192-3.059 3.06c-.86.86-2.289.824-3.193-.08zm3.016-8.673l1.192 1.192 3.059-3.06c.86-.86 2.289-.824 3.193.08.905.905.94 2.334.08 3.194l-3.059 3.06 1.192 1.19 3.059-3.058c1.489-1.489 1.427-3.954-.138-5.519s-4.03-1.627-5.519-.138L9.786 8.557zm-1.023 6.68c.33.33.863.343 1.177.029l5.34-5.34c.314-.314.3-.846-.03-1.176-.33-.33-.862-.344-1.176-.03l-5.34 5.34c-.314.314-.3.846.03 1.177z" fill-rule="evenodd"&gt;&lt;/path&gt;</span></span><span class="line"><span style="color: #98C379">                            &lt;/svg&gt;</span></span><span class="line"><span style="color: #98C379">                        &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                        &lt;a href="</span><span style="color: #C678DD">${</span><span style="color: #E06C75">link</span><span style="color: #C678DD">}</span><span style="color: #98C379">" title="</span><span style="color: #C678DD">${</span><span style="color: #E06C75">link</span><span style="color: #C678DD">}</span><span style="color: #98C379">" style="color:inherit;text-decoration:none;"&gt;</span><span style="color: #C678DD">${</span><span style="color: #E06C75">displayLink</span><span style="color: #C678DD">}</span><span style="color: #98C379">&lt;/a&gt;</span></span><span class="line"><span style="color: #98C379">                    &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;span class="LinkCard-imageCell"&gt;</span></span><span class="line"><span style="color: #98C379">                    &lt;img class="LinkCard-image" alt="logo" src="</span><span style="color: #C678DD">${</span><span style="color: #E06C75">logourl</span><span style="color: #C678DD">}</span><span style="color: #98C379">"&gt;</span></span><span class="line"><span style="color: #98C379">                &lt;/span&gt;</span></span><span class="line"><span style="color: #98C379">            &lt;/span&gt;`</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>并在 <code>_config.fluid.yml</code> 文件的 <code>custom_css</code> 和<code>custom_js</code> 部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/LinkCard.css</span></span><span class="line"><span style="color: #E06C75">custom_js</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/LinkCard.js</span></span></code></pre></div></div></figure><p></p><p>使用时只需在文章中添加以下内容即可： </p><figure class="shiki markdown"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;a href="" name="" class="LinkCard"&gt;标题&lt;/a&gt;</span></span></code></pre></div></div></figure><p></p><p>其中 <code>href</code> 是链接地址，<code>name</code>是链接的logo地址，<code>标题</code> 处为连接卡片显示的标题。</p><h1 id="首页文章滑入动效">首页文章滑入动效</h1><p>在Fluid主题中，首页文章列表的文章卡片是静态显示的，没有任何动效。为了让首页看起来更有活力，我参考QingShang的博客为文章卡片添加了滑入动效。</p><p><a href="https://qingshaner.com/Hexo%20fluid主题首页添加文章滑入动画/" name="https://qingshaner.oss-cn-hangzhou.aliyuncs.com/images/202205021359396.jpg" class="LinkCard">Hexofluid主题首页添加文章滑入动画</a></p><p>在 <code>source/js/</code> 目录下新建一个<code>ScrollAnimation.js</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">cards</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelectorAll</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'.index-card'</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">cards</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">querySelector</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'.row'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">setAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'style'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'overflow: hidden;'</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">coefficient</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">documentElement</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientWidth</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">768</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">.5</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">.3</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">origin</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">documentElement</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientHeight</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">cards</span><span style="color: #ABB2BF">[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">].</span><span style="color: #61AFEF">getBoundingClientRect</span><span style="color: #ABB2BF">().</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">coefficient</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">throttle</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">fn</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">wait</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">let</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">timer</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> () {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">context</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">this</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">args</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">arguments</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #56B6C2">!</span><span style="color: #E06C75">timer</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E06C75">timer</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> () {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E5C07B">fn</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">apply</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">context</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">args</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #E06C75">timer</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                }, </span><span style="color: #E06C75">wait</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">handle</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">cards</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">forEach</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">card</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">=&gt;</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">card</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">setAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'style'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">`--state: </span><span style="color: #C678DD">${</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">card</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getBoundingClientRect</span><span style="color: #ABB2BF">().</span><span style="color: #E06C75">top</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">origin</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #C678DD">}</span><span style="color: #98C379">;`</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        })</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">log</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">addEventListener</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"scroll"</span><span style="color: #ABB2BF">, </span><span style="color: #61AFEF">throttle</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">handle</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">100</span><span style="color: #ABB2BF">));</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>接着在 <code>source/css/</code>目录下新建一个<code>ScrollAnimation.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #D19A66">.index-card</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  transition: </span><span style="color: #D19A66">all</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.5</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">  transform: </span><span style="color: #56B6C2">scale</span><span style="color: #ABB2BF">(</span><span style="color: #56B6C2">calc</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1.5</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.5</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--state</span><span style="color: #ABB2BF">)));</span></span><span class="line"><span style="color: #ABB2BF">  opacity: </span><span style="color: #56B6C2">var</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">--state</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">  margin-bottom: </span><span style="color: #D19A66">2</span><span style="color: #E06C75">rem</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #D19A66">.index-img</span><span style="color: #C678DD"> </span><span style="color: #E06C75">img</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  margin: </span><span style="color: #D19A66">20</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>并在 <code>_config.fluid.yml</code> 中载入，在 <code>custom_js</code>和 <code>custom_css</code> 部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_js</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/ScrollAnimation.js</span></span><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/ScrollAnimation.css</span></span></code></pre></div></div></figure><p></p><h1 id="首页文章图片悬浮动效">首页文章图片悬浮动效</h1><p>在实现首页文章滑入动效后，我又参照Hugo@kkl’s的博客为首页文章图片添加了悬浮动效</p><p><a href="https://zhangkeliang0627.github.io/2024/07/31/关于Fluid主题拓展的N种配置/README/" name="https://hugokkl.oss-cn-shenzhen.aliyuncs.com/blog/sys/avatar.png" class="LinkCard">关于Fluid主题拓展的N种配置</a></p><p>在 <code>source/css/</code> 目录下新建一个<code>IndexImgHover.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #D19A66">.index-img</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic">/* 动画时间 */</span></span><span class="line"><span style="color: #ABB2BF">  transition: </span><span style="color: #D19A66">.4</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.index-card</span><span style="color: #56B6C2">:hover</span><span style="color: #C678DD"> </span><span style="color: #D19A66">.index-img</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic">/* 放大倍数 */</span></span><span class="line"><span style="color: #ABB2BF">  transform: </span><span style="color: #56B6C2">scale</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1.05</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>并在 <code>_config.fluid.yml</code> 中载入，在<code>custom_css</code> 部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/IndexImgHover.css</span></span></code></pre></div></div></figure><p></p><p>至此，首页文章图片的动效就完成了。</p><p>当然，你也可以借助浏览器开发者工具选取其他样式，并仿照这个方法进行修改。如修改“关于”页的头像与“标签页”的标签：</p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #D19A66">.about-avatar</span><span style="color: #C678DD"> </span><span style="color: #E06C75">img</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  transition: </span><span style="color: #D19A66">.4</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.about-avatar</span><span style="color: #56B6C2">:hover</span><span style="color: #C678DD"> </span><span style="color: #E06C75">img</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  transform: </span><span style="color: #56B6C2">scale</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1.05</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #D19A66">.tagcloud</span><span style="color: #C678DD"> </span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  transition: </span><span style="color: #D19A66">.6</span><span style="color: #E06C75">s</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.tagcloud</span><span style="color: #C678DD"> </span><span style="color: #E06C75">a</span><span style="color: #56B6C2">:hover</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">  transform: </span><span style="color: #56B6C2">scale</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">1.05</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><h1 id="彩虹加载动效">彩虹加载动效</h1><p>由于我的博客使用GithubPages托管，因此在加载时偶尔会花费较长时间，这时页面各种效果加载的速度往往并不一致，大大影响了观感。因此，我参考Emberffの小破站，为博客添加了彩虹加载动效。</p><p><a href="https://blog.emb42.com/2024/10/04/Hexo-Fluid%E8%83%8C%E6%99%AF%E5%9B%BA%E5%AE%9A%E4%BB%A5%E5%8F%8A%E6%B7%BB%E5%8A%A0%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/" name="https://blog.emb42.com/img/avatar.png" class="LinkCard">HexoFluid背景固定以及添加加载动画</a></p><p>在 <code>source/js/</code> 目录下新建一个<code>RainbowLoading.js</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">loadScript</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">url</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">callback</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">script</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createElement</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'script'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">script</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">type</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'text/javascript'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">script</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">src</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">url</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">script</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">onload</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">callback</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    };</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">head</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">appendChild</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">script</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic">// 加载 jQuery</span></span><span class="line"><span style="color: #61AFEF">loadScript</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'https://code.jquery.com/jquery-3.6.0.min.js'</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">$</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(){</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">$</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"#loader-container"</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">fadeOut</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">560</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    });</span></span><span class="line"><span style="color: #ABB2BF">});</span></span></code></pre></div></div></figure><p></p><p>然后在 <code>source/css/</code> 目录下新建一个<code>RainbowLoading.css</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki css"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">#loader-container</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   position: </span><span style="color: #D19A66">fixed</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">/* 或 absolute，根据需求 */</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   left: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   right: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   bottom: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   z-index: </span><span style="color: #D19A66">99999</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">/* 确保在最上层 */</span></span><span class="line"><span style="color: #ABB2BF">   display: </span><span style="color: #D19A66">flex</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   justify-content: </span><span style="color: #D19A66">center</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   align-items: </span><span style="color: #D19A66">center</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   background: </span><span style="color: #56B6C2">rgba</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0.7</span><span style="color: #ABB2BF">); </span><span style="color: #7F848E; font-style: italic">/* 可选：添加背景以增加可见性 */</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #D19A66">.loader</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #D19A66">.loader-inner</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #D19A66">.loader-line</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">    position: </span><span style="color: #D19A66">absolute</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">/* 或 fixed，根据需要选择 */</span></span><span class="line"><span style="color: #ABB2BF">    z-index: </span><span style="color: #D19A66">99999</span><span style="color: #ABB2BF">; </span><span style="color: #7F848E; font-style: italic">/* 确保在最上层 */</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #D19A66">.loader</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   background: </span><span style="color: #D19A66">#000</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   background: </span><span style="color: #56B6C2">radial-gradient</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">#222</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">#000</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">   bottom: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   left: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   overflow: </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   position: </span><span style="color: #D19A66">fixed</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   right: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   z-index: </span><span style="color: #D19A66">99999</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #D19A66">.loader-inner</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   bottom: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   height: </span><span style="color: #D19A66">60</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   left: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   margin: </span><span style="color: #D19A66">auto</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   position: </span><span style="color: #D19A66">absolute</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   right: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   width: </span><span style="color: #D19A66">100</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   animation: </span></span><span class="line"><span style="color: #ABB2BF">     spin </span><span style="color: #D19A66">2000</span><span style="color: #E06C75">ms</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">cubic-bezier</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">.175</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">.885</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">.32</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">1.275</span><span style="color: #ABB2BF">) </span><span style="color: #D19A66">infinite</span></span><span class="line"><span style="color: #ABB2BF">  ;</span></span><span class="line"><span style="color: #ABB2BF">   box-sizing: </span><span style="color: #D19A66">border-box</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   height: </span><span style="color: #D19A66">50</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   left: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   overflow: </span><span style="color: #D19A66">hidden</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   position: </span><span style="color: #D19A66">absolute</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   transform-origin: </span><span style="color: #D19A66">50</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">100</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   width: </span><span style="color: #D19A66">100</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.loader-line</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   border: </span><span style="color: #D19A66">4</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">solid</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">transparent</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   border-radius: </span><span style="color: #D19A66">100</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   box-sizing: </span><span style="color: #D19A66">border-box</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   height: </span><span style="color: #D19A66">100</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   left: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   margin: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">auto</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   position: </span><span style="color: #D19A66">absolute</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   right: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   width: </span><span style="color: #D19A66">100</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">1</span><span style="color: #C678DD">)</span><span style="color: #ABB2BF"> { animation-delay: </span><span style="color: #D19A66">-50</span><span style="color: #E06C75">ms</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">2</span><span style="color: #C678DD">)</span><span style="color: #ABB2BF"> { animation-delay: </span><span style="color: #D19A66">-100</span><span style="color: #E06C75">ms</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">3</span><span style="color: #C678DD">)</span><span style="color: #ABB2BF"> { animation-delay: </span><span style="color: #D19A66">-150</span><span style="color: #E06C75">ms</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">4</span><span style="color: #C678DD">)</span><span style="color: #ABB2BF"> { animation-delay: </span><span style="color: #D19A66">-200</span><span style="color: #E06C75">ms</span><span style="color: #ABB2BF">; }</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">5</span><span style="color: #C678DD">)</span><span style="color: #ABB2BF"> { animation-delay: </span><span style="color: #D19A66">-250</span><span style="color: #E06C75">ms</span><span style="color: #ABB2BF">; }</span></span><span class="line"></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">1</span><span style="color: #C678DD">) </span><span style="color: #D19A66">.loader-line</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   border-color: </span><span style="color: #56B6C2">hsl</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">80</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">60</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">   height: </span><span style="color: #D19A66">90</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   width: </span><span style="color: #D19A66">90</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">7</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">2</span><span style="color: #C678DD">) </span><span style="color: #D19A66">.loader-line</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   border-color: </span><span style="color: #56B6C2">hsl</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">60</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">80</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">60</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">   height: </span><span style="color: #D19A66">76</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   width: </span><span style="color: #D19A66">76</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">14</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">3</span><span style="color: #C678DD">) </span><span style="color: #D19A66">.loader-line</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   border-color: </span><span style="color: #56B6C2">hsl</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">120</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">80</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">60</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">   height: </span><span style="color: #D19A66">62</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   width: </span><span style="color: #D19A66">62</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">21</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">4</span><span style="color: #C678DD">) </span><span style="color: #D19A66">.loader-line</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   border-color: </span><span style="color: #56B6C2">hsl</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">180</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">80</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">60</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">   height: </span><span style="color: #D19A66">48</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   width: </span><span style="color: #D19A66">48</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">28</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"><span style="color: #D19A66">.loader-line-wrap</span><span style="color: #56B6C2">:nth-child</span><span style="color: #C678DD">(</span><span style="color: #D19A66">5</span><span style="color: #C678DD">) </span><span style="color: #D19A66">.loader-line</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   border-color: </span><span style="color: #56B6C2">hsl</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">240</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">80</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">60</span><span style="color: #E06C75">%</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">   height: </span><span style="color: #D19A66">34</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   width: </span><span style="color: #D19A66">34</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">   top: </span><span style="color: #D19A66">35</span><span style="color: #E06C75">px</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">}</span></span><span class="line"></span><span class="line"><span style="color: #C678DD">@keyframes</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75; font-style: italic">spin</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">   0%, 15% {</span></span><span class="line"><span style="color: #ABB2BF">     transform: </span><span style="color: #56B6C2">rotate</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">  }</span></span><span class="line"><span style="color: #ABB2BF">  100% {</span></span><span class="line"><span style="color: #ABB2BF">     transform: </span><span style="color: #56B6C2">rotate</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">360</span><span style="color: #E06C75">deg</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">  }</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure><p></p><p>然后还需要在 <code>source/html/</code> 目录下新建一个<code>RainbowLoading.html</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki html"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">&lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-container"</span><span style="color: #ABB2BF">&gt; </span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">id</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader"</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-inner"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line-wrap"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line-wrap"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line-wrap"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line-wrap"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line-wrap"</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">            &lt;</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">class</span><span style="color: #ABB2BF">=</span><span style="color: #98C379">"loader-line"</span><span style="color: #ABB2BF">&gt;&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">        &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">    &lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span><span class="line"><span style="color: #ABB2BF">&lt;/</span><span style="color: #E06C75">div</span><span style="color: #ABB2BF">&gt;</span></span></code></pre></div></div></figure><p></p><p>然后在 <code>_config.fluid.yml</code> 文件的 <code>custom_js</code>和 <code>custom_css</code> 部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_js</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/RainbowLoading.js</span></span><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/RainbowLoading.css</span></span></code></pre></div></div></figure><p></p><p>在这之后，还需要使用Hexo的注入功能来将加载动画的HTML代码注入到页面中。我们需要在博客根目录下新建<code>scripts/</code> 目录，然后在该目录下新建一个<code>injector.js</code> 文件，代码如下： </p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic">// 注入彩虹加载动画</span></span><span class="line"><span style="color: #E5C07B">hexo</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">extend</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">filter</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">register</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'theme_inject'</span><span style="color: #ABB2BF">, </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">injects</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">  </span><span style="color: #E5C07B">injects</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">bodyBegin</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">file</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'loader'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'source/html/RainbowLoading.html'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">});</span></span></code></pre></div></div></figure><p></p><p>Hexo注入器的使用可以参考Fluid主题的用户手册。</p><p><a href="https://hexo.fluid-dev.com/docs/advance/#hexo-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81" name="https://hexo.fluid-dev.com/docs/fluid_hexo.png" class="LinkCard">Hexo注入代码</a></p><h1 id="背景动态线条动效">背景动态线条动效</h1><p>但是，现在我又觉得纯色的界面有些单调了，于是我为背景加上了动态线条的效果。参考EmoryHuang’sBlog的代码并进行一定修改。</p><p>在 <code>source/js/</code> 目录下新建一个 <code>DynamicLine.js</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #ABB2BF">(</span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 检测深色模式的辅助函数 - 直接检查data-user-color-scheme属性</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isDarkMode</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">htmlElement</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">documentElement</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">userScheme</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">htmlElement</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'data-user-color-scheme'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">defaultScheme</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">htmlElement</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'data-default-color-scheme'</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 如果用户手动设置了主题，优先使用用户设置</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">userScheme</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">userScheme</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'dark'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 否则使用默认主题设置</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">defaultScheme</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">defaultScheme</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">'dark'</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 如果都没有设置，检查系统偏好</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">matchMedia</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'(prefers-color-scheme: dark)'</span><span style="color: #ABB2BF">).</span><span style="color: #E06C75">matches</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 获取元素属性的辅助函数</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getAttr</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">el</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">attr</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75; font-style: italic">defaultValue</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">el</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getAttribute</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">attr</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">defaultValue</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 获取标签元素的辅助函数</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getTags</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">tag</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getElementsByTagName</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">tag</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 获取配置信息，根据深色模式设置不同的线条颜色</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getConfig</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">scripts</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getTags</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"script"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">lastScript</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">scripts</span><span style="color: #ABB2BF">[</span><span style="color: #E5C07B">scripts</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">];</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #7F848E; font-style: italic">// 根据深色模式状态设置线条颜色</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">lineColor</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isDarkMode</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"255,255,255"</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"0,0,0"</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">return</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">l</span><span style="color: #ABB2BF">: </span><span style="color: #E5C07B">scripts</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">z</span><span style="color: #ABB2BF">: </span><span style="color: #61AFEF">getAttr</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">lastScript</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"zIndex"</span><span style="color: #ABB2BF">, </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">),</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">o</span><span style="color: #ABB2BF">: </span><span style="color: #61AFEF">getAttr</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">lastScript</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"opacity"</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0.5</span><span style="color: #ABB2BF">),</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">c</span><span style="color: #ABB2BF">: </span><span style="color: #61AFEF">getAttr</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">lastScript</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"color"</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">lineColor</span><span style="color: #ABB2BF">),</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">n</span><span style="color: #ABB2BF">: </span><span style="color: #61AFEF">getAttr</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">lastScript</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">"count"</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">99</span><span style="color: #ABB2BF">)</span></span><span class="line"><span style="color: #ABB2BF">        };</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 设置Canvas尺寸</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">setCanvasSize</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">width</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">canvas</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">width</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerWidth</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">documentElement</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientWidth</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">body</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientWidth</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">canvas</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">innerHeight</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">documentElement</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientHeight</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">body</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientHeight</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 绘制函数</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">draw</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">ctx</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">clearRect</span><span style="color: #ABB2BF">(</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">width</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">height</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">allPoints</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [</span><span style="color: #E06C75">mouse</span><span style="color: #ABB2BF">].</span><span style="color: #61AFEF">concat</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">points</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">points</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">forEach</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">p</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">xa</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">ya</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">xa</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*=</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">width</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">ya</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*=</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&gt;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">height</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">) </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">ctx</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">fillRect</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.5</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.5</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">v</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; </span><span style="color: #E06C75">v</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">allPoints</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">length</span><span style="color: #ABB2BF">; </span><span style="color: #E06C75">v</span><span style="color: #56B6C2">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">q</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">allPoints</span><span style="color: #ABB2BF">[</span><span style="color: #E06C75">v</span><span style="color: #ABB2BF">];</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">p</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">q</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dx</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dy</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dist</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dx</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dx</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dy</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dy</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">dist</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">max</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">q</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">mouse</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dist</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&gt;=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">max</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                            </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.03</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dx</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                            </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.03</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dy</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                        }</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">ratio</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">max</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">dist</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">max</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #E5C07B">ctx</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">beginPath</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #E5C07B">ctx</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">lineWidth</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">ratio</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #E5C07B">ctx</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">strokeStyle</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"rgba("</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">config</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">c</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">","</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">ratio</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0.2</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">")"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #E5C07B">ctx</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">moveTo</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">p</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #E5C07B">ctx</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">lineTo</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">q</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                        </span><span style="color: #E5C07B">ctx</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">stroke</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">                    }</span></span><span class="line"><span style="color: #ABB2BF">                }</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">allPoints</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">splice</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">allPoints</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">indexOf</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">p</span><span style="color: #ABB2BF">), </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        });</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">animation</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">draw</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 主题变化时更新Canvas配置</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">updateCanvasTheme</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">const</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">newColor</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">isDarkMode</span><span style="color: #ABB2BF">() </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"255,255,255"</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"0,0,0"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">config</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">c</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">newColor</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">config</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">c</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">newColor</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">console</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">log</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"主题已切换，线条颜色更新为:"</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">newColor</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">===</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"255,255,255"</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">?</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"白色"</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">:</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"黑色"</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">canvas</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">createElement</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"canvas"</span><span style="color: #ABB2BF">),</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">config</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">getConfig</span><span style="color: #ABB2BF">(),</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">canvasId</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"c_n"</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">config</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">l</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">ctx</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">canvas</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">getContext</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"2d"</span><span style="color: #ABB2BF">),</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">width</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">height</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">animation</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">requestAnimationFrame</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">webkitRequestAnimationFrame</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">mozRequestAnimationFrame</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">oRequestAnimationFrame</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">msRequestAnimationFrame</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">fn</span><span style="color: #ABB2BF">) { </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">fn</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">1000</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">/</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">45</span><span style="color: #ABB2BF">); },</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">random</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">Math</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">random</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">mouse</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> { </span><span style="color: #E06C75">x</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">y</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">max</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">20000</span><span style="color: #ABB2BF"> };</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">canvas</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">id</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">canvasId</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">canvas</span><span style="color: #ABB2BF">.</span><span style="color: #E5C07B">style</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">cssText</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #98C379">"position:fixed;top:0;left:0;z-index:"</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">config</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">z</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">";opacity:"</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">+</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">config</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">o</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">getTags</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">"body"</span><span style="color: #ABB2BF">)[</span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">].</span><span style="color: #61AFEF">appendChild</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">canvas</span><span style="color: #ABB2BF">);</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">setCanvasSize</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">onresize</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">setCanvasSize</span><span style="color: #ABB2BF">;</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">onmousemove</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75; font-style: italic">e</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">e</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">e</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">event</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">mouse</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientX</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">mouse</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">e</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">clientY</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    };</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">onmouseout</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">mouse</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">mouse</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    };</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">points</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> [];</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">0</span><span style="color: #ABB2BF">; </span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">&lt;</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">config</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">n</span><span style="color: #ABB2BF">; </span><span style="color: #E06C75">i</span><span style="color: #56B6C2">++</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">x</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">random</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">width</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">y</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">random</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">height</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">xa</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">random</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">ya</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">*</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">random</span><span style="color: #ABB2BF">() </span><span style="color: #56B6C2">-</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">points</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">({ </span><span style="color: #E06C75">x</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">x</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">y</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">y</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">xa</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">xa</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">ya</span><span style="color: #ABB2BF">: </span><span style="color: #E06C75">ya</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">max</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">6000</span><span style="color: #ABB2BF"> });</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 初始设置线条颜色</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">updateCanvasTheme</span><span style="color: #ABB2BF">();</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 监听data-user-color-scheme和data-default-color-scheme属性变化</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">MutationObserver</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">new</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">MutationObserver</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">updateCanvasTheme</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">observe</span><span style="color: #ABB2BF">(</span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">documentElement</span><span style="color: #ABB2BF">, {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">attributes</span><span style="color: #ABB2BF">: </span><span style="color: #D19A66">true</span><span style="color: #ABB2BF">,</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">attributeFilter</span><span style="color: #ABB2BF">: [</span><span style="color: #98C379">'data-user-color-scheme'</span><span style="color: #ABB2BF">, </span><span style="color: #98C379">'data-default-color-scheme'</span><span style="color: #ABB2BF">]</span></span><span class="line"><span style="color: #ABB2BF">        });</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #7F848E; font-style: italic">// 监听系统主题变化</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">matchMedia</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">window</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">matchMedia</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'(prefers-color-scheme: dark)'</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">addEventListener</span><span style="color: #ABB2BF">(</span><span style="color: #98C379">'change'</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">updateCanvasTheme</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #61AFEF">draw</span><span style="color: #ABB2BF">();</span></span><span class="line"><span style="color: #ABB2BF">    }, </span><span style="color: #D19A66">100</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">})();</span></span></code></pre></div></div></figure><p></p><p>并在 <code>_config.fluid.yml</code> 文件的 <code>custom_js</code>部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_js</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/DynamicLine.js</span></span></code></pre></div></div></figure><p></p><p>这样，在博客加载时就会自动添加动态线条效果。</p><h1 id="标签页根据焦点切换显示">标签页根据焦点切换显示</h1><p>在浏览其他人的博客时，我发现有些博客在我切换出标签页时，顶栏会呈现出挽留的效果，然而我实在不知道应该用什么关键词检索相关代码，因此只能自行查阅资料来实现。最终我了解到这样的效果是通过页面可见性事件<code>visibilitychange</code> 监听来实现的。</p><p>在 <code>source/js/</code> 目录下新建一个 <code>TabDisplay.js</code>文件（如果不存在该目录则需要先创建），代码如下： </p><figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">jQuery</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">document</span><span style="color: #ABB2BF">).</span><span style="color: #61AFEF">ready</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">b</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">c</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">a</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">title</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">var</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">welcomeTimer</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">function</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">d</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">document</span><span style="color: #ABB2BF">[</span><span style="color: #E06C75">b</span><span style="color: #ABB2BF">]) {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">title</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" 你去哪啦(๑•́ ₃ •̀๑) "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">welcomeTimer</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #61AFEF">clearTimeout</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">welcomeTimer</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E06C75">welcomeTimer</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">null</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }</span></span><span class="line"><span style="color: #ABB2BF">        } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> {</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">title</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">" 你回来啦(*^▽^*) "</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">welcomeTimer</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #61AFEF">setTimeout</span><span style="color: #ABB2BF">(</span><span style="color: #C678DD">function</span><span style="color: #ABB2BF">() {</span></span><span class="line"><span style="color: #ABB2BF">                </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">title</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">a</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">            }, </span><span style="color: #D19A66">2000</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">        }</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">typeof</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">hidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"undefined"</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">b</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"hidden"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">c</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"visibilitychange"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">typeof</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">mozHidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"undefined"</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">b</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"mozHidden"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">c</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"mozvisibilitychange"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    } </span><span style="color: #C678DD">else</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> (</span><span style="color: #C678DD">typeof</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">webkitHidden</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"undefined"</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">b</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"webkitHidden"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">c</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">=</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"webkitvisibilitychange"</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">if</span><span style="color: #ABB2BF"> ((</span><span style="color: #C678DD">typeof</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #E06C75">addEventListener</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"undefined"</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">||</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">typeof</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">document</span><span style="color: #ABB2BF">[</span><span style="color: #E06C75">b</span><span style="color: #ABB2BF">] </span><span style="color: #56B6C2">!==</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"undefined"</span><span style="color: #ABB2BF">) </span><span style="color: #56B6C2">&amp;&amp;</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">c</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E5C07B">document</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">addEventListener</span><span style="color: #ABB2BF">(</span><span style="color: #E06C75">c</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">d</span><span style="color: #ABB2BF">, </span><span style="color: #D19A66">false</span><span style="color: #ABB2BF">);</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">});</span></span></code></pre></div></div></figure><p></p><p>并在 <code>_config.fluid.yml</code> 文件的 <code>custom_js</code>部分添加以下内容： </p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">custom_js</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/TabDisplay.js</span></span></code></pre></div></div></figure><p></p><p>至此，我的博客就完成了当前所有的美化效果！最终，<code>_config.fluid.yml</code>文件的 <code>custom_js</code> 和 <code>custom_css</code> 部分如下所示：</p><figure class="shiki yaml"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 指定自定义 .js 文件路径，支持列表；路径是相对 source 目录，如 /js/custom.js 对应存放目录 source/js/custom.js</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># Specify the path of your custom js file, support list. The path is relative to the source directory, such as `/js/custom.js` corresponding to the directory `source/js/custom.js`</span></span><span class="line"><span style="color: #E06C75">custom_js</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/DynamicLine.js</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 动态线条</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/LinkCard.js</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 链接卡片效果</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/RainbowLoading.js</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 彩虹加载动画</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/ScrollAnimation.js</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 首页文章滑入动画</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/js/TabDisplay.js</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 标签页根据焦点切换显示</span></span><span class="line"></span><span class="line"><span style="color: #7F848E; font-style: italic"># 指定自定义 .css 文件路径，用法和 custom_js 相同</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># The usage is the same as custom_js</span></span><span class="line"><span style="color: #E06C75">custom_css</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/CodeBlock.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 代码折叠</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/CodeInLine.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 行内代码样式</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/FrostedGlassBg.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 文章界面毛玻璃</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/IndexImgHover.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 首页文章封面图片悬浮效果</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/LinkCard.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 链接卡片效果</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/RainbowLoading.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 彩虹加载动画</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/ScrollAnimation.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 首页文章滑入动画</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/ScrollBar.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 滚动条颜色</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/StrongInDark.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 强化暗色模式加粗字体</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/TitleGradient.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 文章标题颜色渐变效果</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">/css/TitleNeon.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># 博客标题霓虹灯效</span></span><span class="line"><span style="color: #ABB2BF">  - </span><span style="color: #98C379">https://lib.baomitu.com/font-awesome/6.1.2/css/all.min.css</span><span style="color: #ABB2BF"> </span><span style="color: #7F848E; font-style: italic"># Font Awesome 图标库</span></span></code></pre></div></div></figure><p></p><p>具体的代码可以参考我的博客仓库中的 <code>js</code> 和<code>css</code> 目录。</p><p><a href="https://github.com/youyeyejie/youyeyejie.github.io" name="/img/avatar/avatar.jpg" class="LinkCard">GitHub仓库</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo Blog Building</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>📍Start Point of my Blog</title>
    <link href="/posts/Start-Point-of-my-Blog/"/>
    <url>/posts/Start-Point-of-my-Blog/</url>
    
    <content type="html"><![CDATA[<h1 id="本站的由来">本站的由来</h1><p>每个人建立自己博客的原因都不尽相同，有的是为了与他人分享知识和情绪，有的是为了记录自己的学习、工作与生活，有的是为了展现自己的能力。相比之下，我的理由就显得有些出人意料了——我只是觉得有个属于自己的博客挺酷的。</p><p>最初打动我的其实是Boar酱的图库，毕竟作为同样一个喜欢摄影的人，我也希望有一个属于自己的网站来展示我的摄影作品。但是苦于技术力有限，我始终只敢远观。于是，我将眼光放在了无需自己从零开始手搓，而是可以站在前人的肩膀上，使用现成的框架和主题来搭建的博客上。</p><p><a href="https://gallery.boar.osaka/" name="/img/avatar.png" class="LinkCard">Boar’sGallery</a></p><p>除此之外，Teruteru的博客也给了我很大的帮助和启发。事实上，过去的我并不十分热衷于记录和分享，但一次又一次在期末周借助Teruteru的学习笔记进行复习迎接考试的过程中，我逐渐意识到记录和分享的重要性。于是，我决定建立一个属于自己的博客，记录我的学习和生活点滴。</p><p><a href="https://teruteru.space/" name="https://teruteru.space/img/teruteru.jpg" class="LinkCard">Teruteru的学习笔记</a></p><h1 id="本站的搭建">本站的搭建</h1><p>在了解了主流的博客搭建方式后，我选择了Hexo作为我的博客框架。Hexo是一个基于Node.js的静态博客框架，具有快速和简洁的特点，且其社区活跃度高、文档完善，也易于学习和使用。相比于动态博客系统，Hexo的静态页面生成方式使得博客加载速度更快，也不必自行注册域名和购买服务器，极大降低了我的学习成本与维护成本。除此之外，Hexo还拥有丰富的主题和插件生态系统，可以满足我对博客外观和功能的各种需求。</p><p>在选择主流的Hexo作为博客框架之后，面临的第一个问题就是选择一个合适的主题。在一番比较后，Fluid、Solitude、Matery、ShokaX等主题“入围”了我的初步选择。Fluid主题兼顾简洁和美观、文档最为完善，对于在网站开发方面经验为零的我来说最为友好，且我的“博客启蒙”——Teruteru的博客就是基于Fluid主题搭建的，因此我最终选择了Fluid主题。</p><h1 id="本站的内容">本站的内容</h1><p>在短期内，我将陆续整理过去两年的部分笔记，并将其发布到本站上。而在此之后，也即接下来的很长一段时间内，本站主要发布的都将是我在学习过程中留下的笔记，未来或许会进一步分享更多的内容。此外，本站也会记录我对这个博客进行搭建和美化的过程，为其他想要搭建Hexo博客的朋友提供一些参考和帮助。</p><p>正如标题所示，本站是我博客的起点。人生缓缓，自有答案，且以群词，注解我这座荒山。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo Blog Building</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象代数</title>
    <link href="/posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"/>
    <url>/posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文章基于<a href="https://teruteru.space/2024/02/21/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0/">Teruteru的学习笔记</a>进行整理，针对2024-2025 学年春季学期教学内容进行修改。</p></blockquote><h1 id="解题范式">解题范式</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-93269758" role="button" aria-expanded="false" aria-controls="collapse-93269758">        <div class="fold-arrow">▶</div>解题范式      </div>      <div class="fold-collapse collapse" id="collapse-93269758">        <div class="fold-content">          <h2 id="证明相等">证明相等</h2><p>两个集合 <span class="math inline"><em>A</em>, <em>B</em></span>相等：</p><ol type="1"><li>证明 <span class="math inline"><em>A</em> ⊆ <em>B</em></span></li><li>证明 <span class="math inline"><em>B</em> ⊆ <em>A</em></span></li></ol><p>两个数 <span class="math inline"><em>a</em>, <em>b</em></span>相等：</p><ol type="1"><li>证明 <span class="math inline"><em>a</em> ∣ <em>b</em></span></li><li>证明 <span class="math inline"><em>b</em> ∣ <em>a</em></span></li></ol><h2 id="等价关系">等价关系</h2><p>若要证明 <span class="math inline">∼</span> 是一个等价关系：</p><ol type="1"><li>证明 <strong>反身性</strong></li><li>证明 <strong>对称性</strong></li><li>证明 <strong>传递性</strong></li></ol><h2 id="代数运算">代数运算</h2><p>若要证明集合 <span class="math inline"><em>A</em></span> 中的运算<span class="math inline">⋅</span> 是一个代数运算：</p><ol type="1"><li>证明 <strong>封闭性</strong></li><li>证明 <strong>唯一性</strong> （通常显然）</li></ol><h2 id="群">群</h2><p>若要证明集合 <span class="math inline"><em>A</em></span> 关于运算<span class="math inline">⋅</span> 构成一个群：</p><ol type="1"><li>证明 <span class="math inline">⋅</span> 是<strong>代数运算</strong></li><li>证明 <strong>结合律</strong> （左右结合律）</li><li>证明 <strong>单位元</strong> <span class="math inline"><em>e</em></span> 存在（左右单位元）</li><li>证明 <strong>逆元</strong> 存在（左右逆元）</li></ol><h2 id="子群">子群</h2><p>若要证明群 <span class="math inline"><em>G</em></span> 的子集 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，即 <span class="math inline"><em>H</em> &lt; <em>G</em></span>：</p><ul><li>定义：<ol type="1"><li><span class="math inline"><em>H</em></span> 在群的运算下封闭</li><li><span class="math inline"><em>H</em></span> 有单位元</li><li><span class="math inline"><em>H</em></span> 中每个元素都有逆元</li></ol></li><li>定理1：<ol type="1"><li>证明 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的 <strong>非空</strong> 子集</li><li>对任意 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>H</em></span>，证明<span class="math inline"><em>a</em><em>b</em> ∈ <em>H</em></span></li><li>对任意 <span class="math inline"><em>a</em> ∈ <em>H</em></span>，证明 <span class="math inline"><em>a</em><sup>−1</sup> ∈ <em>H</em></span></li></ol></li><li>定理2：<ol type="1"><li>证明 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的 <strong>非空</strong> 子集</li><li>对任意 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>H</em></span>，证明<span class="math inline"><em>a</em><em>b</em><sup>−1</sup> ∈ <em>H</em></span></li></ol></li></ul><h2 id="正规子群">正规子群</h2><p>若要证明群 <span class="math inline"><em>G</em></span> 的子群 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，即 <span class="math inline"><em>H</em> ⊲ <em>G</em></span>，则下面几个条件等价</p><ol type="1"><li><span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群</li><li><span class="math inline">∀<em>g</em> ∈ <em>G</em></span>，<span class="math inline"><em>g</em><em>H</em> = <em>H</em><em>g</em></span></li><li><span class="math inline">∀<em>g</em> ∈ <em>G</em></span>，<span class="math inline"><em>g</em><em>H</em><em>g</em><sup>−1</sup> = <em>H</em></span></li><li><span class="math inline">∀<em>g</em> ∈ <em>G</em></span>，<span class="math inline"><em>g</em><em>H</em><em>g</em><sup>−1</sup> ⊆ <em>H</em></span></li><li><span class="math inline">∀<em>g</em> ∈ <em>G</em></span>，<span class="math inline"><em>h</em> ∈ <em>H</em></span>，则 <span class="math inline"><em>g</em><em>h</em><em>g</em><sup>−1</sup> ∈ <em>H</em></span></li></ol><h2 id="群同态">群同态</h2><p>若要证明两个群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 同态：</p><ol type="1"><li>建立群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>映射</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明由<span class="math inline"><em>x</em> = <em>y</em></span> 可推出 <span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>ϕ</em>(<em>y</em>)</span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明<span class="math inline"><em>ϕ</em>(<em>x</em><em>y</em>) = <em>ϕ</em>(<em>x</em>)<em>ϕ</em>(<em>y</em>)</span></li></ul></li><li>若还能证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满射</strong>，则 <span class="math inline"><em>ϕ</em></span> 是<span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满同态映射</strong></li><li>若还能证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>单射</strong>，则 <span class="math inline"><em>ϕ</em></span> 是<span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>单同态映射</strong></li></ol><h2 id="群同构">群同构</h2><p>若要证明两个群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 同构：</p><ol type="1"><li>构造群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>映射</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明由<span class="math inline"><em>x</em> = <em>y</em></span> 可推出 <span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>ϕ</em>(<em>y</em>)</span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>单射</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明由<span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>ϕ</em>(<em>y</em>)</span>可推出 <span class="math inline"><em>x</em> = <em>y</em></span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满射</strong><ul><li>即对 <span class="math inline">∀<em>x</em><sup>′</sup> ∈ <em>G</em><sup>′</sup></span>，证明存在（构造）<span class="math inline"><em>x</em> ∈ <em>G</em></span>，使 <span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>x</em><sup>′</sup></span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong><ul><li>即对 <span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明<span class="math inline"><em>ϕ</em>(<em>x</em><em>y</em>) = <em>ϕ</em>(<em>x</em>)<em>ϕ</em>(<em>y</em>)</span></li></ul></li></ol><p>若要证明 <span class="math inline"><em>G</em>/<em>K</em> ≅ <em>G</em><sup>′</sup></span>，即<span class="math inline"><em>G</em>/<em>K</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 同构：</p><ol type="1"><li>建立群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素之间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>映射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong> <span class="math display"><em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span></li><li>综上 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满同态映射</strong></li><li>计算同态的 <strong>核</strong> <span class="math inline">Ker <em>ϕ</em></span>，使得 <span class="math inline"><em>K</em> = Ker <em>ϕ</em></span></li><li>应用 <strong>群同态基本定理</strong> 得 <span class="math inline"><em>G</em>/Ker <em>ϕ</em> ≅ <em>G</em><sup>′</sup></span></li></ol><h2 id="环">环</h2><p>若要证明 <span class="math inline"><em>R</em></span> 是一个环：</p><ol type="1"><li>证明 <strong>加法封闭</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> + <em>y</em> ∈ <em>R</em></span></li></ul></li><li>证明加法满足 <strong>加法结合律</strong> 和<strong>加法交换律</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em>, <em>z</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> + <em>y</em> = <em>y</em> + <em>x</em></span>，<span class="math inline"><em>x</em> + (<em>y</em> + <em>z</em>) = (<em>x</em> + <em>y</em>) + <em>z</em></span></li></ul></li><li>找到加法 <strong>零元</strong><ul><li><span class="math inline">∃0 ∈ <em>R</em>, ∀<em>x</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> + 0 = <em>x</em></span></li></ul></li><li>找到加法 <strong>负元</strong><ul><li><span class="math inline">∀<em>x</em> ∈ <em>R</em>, ∃−<em>x</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> + (−<em>x</em>) = 0</span></li></ul></li><li>证明 <strong>乘法封闭</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em> ∈ <em>R</em></span>：<span class="math inline"><em>x</em> ⋅ <em>y</em> ∈ <em>R</em></span></li></ul></li><li>证明乘法满足 <strong>结合律</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em>, <em>z</em> ∈ <em>R</em></span>：<span class="math inline">(<em>x</em> ⋅ <em>y</em>) ⋅ <em>z</em> = <em>x</em> ⋅ (<em>y</em> ⋅ <em>z</em>)</span></li></ul></li><li>证明乘法对加法满足 <strong>两个分配律</strong><ul><li><span class="math inline">∀<em>x</em>, <em>y</em>, <em>z</em> ∈ <em>R</em></span><span class="math display">$$ \begin{array}{c} x\cdot (y + z) = x\cdot y +x\cdot z\\\ (y+z)\cdot x = y\cdot x + z\cdot x \end{array}$$</span></li></ul></li><li>综上可得 <span class="math inline"><em>R</em></span> 是一个环</li><li>如果 <span class="math inline"><em>R</em></span>的乘法满足交换律，则 <span class="math inline"><em>R</em></span> 是一个<strong>交换环</strong></li><li>如果 <span class="math inline"><em>R</em></span> 的乘法有单位元，则<span class="math inline"><em>R</em></span> 是一个有<strong>单位元</strong> 的环</li></ol><p>其中，1 - 4 即证明 <span class="math inline">(<em>R</em>, +)</span>是一个 <strong>加法交换群</strong>，5 - 7 即证明 <span class="math inline"><em>R</em></span> 还具有乘法代数运算。</p><h2 id="整环">整环</h2><p>若要证明 <span class="math inline"><em>R</em></span> 是一个整环：</p><ol type="1"><li>证明 <span class="math inline"><em>R</em></span> 是一个<strong>交换环</strong></li><li>证明 <span class="math inline"><em>R</em></span> 中有<strong>单位元</strong> 且单位元不为零元</li><li>证明 <span class="math inline"><em>R</em></span> 中没有<strong>零因子</strong><ul><li>即对 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>R</em></span>，如果<span class="math inline"><em>a</em> ⋅ <em>b</em> = 0</span>，则 <span class="math inline"><em>a</em> = 0</span> 或 <span class="math inline"><em>b</em> = 0</span></li></ul></li></ol><h2 id="域">域</h2><p>若要证明 <span class="math inline"><em>F</em></span> 是一个域：</p><ol type="1"><li>证明 <span class="math inline"><em>F</em></span> 是一个<strong>交换环</strong></li><li>证明 <span class="math inline"><em>F</em></span> 中有<strong>单位元</strong> 且单位元不为零元</li><li>证明 <span class="math inline"><em>F</em></span> 中每个<strong>非零元都可逆</strong><ul><li>即对 <span class="math inline">∀<em>a</em> ∈ <em>F</em></span> 且<span class="math inline"><em>a</em> ≠ 0</span>，存在 <span class="math inline"><em>b</em> ∈ <em>F</em></span> 使得 <span class="math inline"><em>a</em> ⋅ <em>b</em> = 1</span></li></ul></li></ol><h2 id="子环">子环</h2><p>若要证明环 <span class="math inline"><em>R</em></span> 的子集 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的子环：</p><ul><li>定理1：<ol type="1"><li>证明 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>非空子集</strong>（通常显然）</li><li>证明 <span class="math inline">(<em>S</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的<strong>加法子群</strong></li><li><span class="math inline"><em>S</em></span> 关于 <span class="math inline"><em>R</em></span> 的 <strong>乘法封闭</strong>，即对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>S</em></span>，有 <span class="math inline"><em>a</em><em>b</em> ∈ <em>S</em></span></li></ol></li><li>定理2：<ol type="1"><li>证明 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>非空子集</strong>（通常显然）</li><li>证明 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>S</em></span>，有<span class="math inline"><em>a</em> − <em>b</em> ∈ <em>S</em></span>（<strong>减法封闭</strong>）</li><li>证明 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>S</em></span>，有<span class="math inline"><em>a</em><em>b</em> ∈ <em>S</em></span>（<strong>乘法封闭</strong>）</li></ol></li></ul><h2 id="理想">理想</h2><p>若要证明环 <span class="math inline"><em>R</em></span> 的子集 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的理想：</p><ol type="1"><li>证明 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>非空子集</strong>（通常显然）</li><li>证明 <span class="math inline">∀<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub> ∈ <em>I</em></span>，<span class="math inline"><em>r</em><sub>1</sub> − <em>r</em><sub>2</sub> ∈ <em>I</em></span>（<strong>减法封闭</strong>）</li><li>证明 <span class="math inline">∀<em>r</em> ∈ <em>I</em></span>，<span class="math inline"><em>s</em> ∈ <em>R</em></span>，<span class="math inline"><em>r</em><em>s</em>, <em>s</em><em>r</em> ∈ <em>I</em></span>（<strong>乘法吸收</strong>）</li></ol><h2 id="环同态">环同态</h2><p>若要证明 <span class="math inline"><em>ϕ</em> : <em>R</em> → <em>R</em><sup>′</sup></span>是一个同态映射：</p><ol type="1"><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>映射</strong><ul><li>即对 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>R</em></span>，证明由<span class="math inline"><em>a</em> = <em>b</em></span> 可推出 <span class="math inline"><em>ϕ</em>(<em>a</em>) = <em>ϕ</em>(<em>b</em>)</span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong><ul><li>即对 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>R</em></span>，证明<ol type="1"><li><span class="math inline"><em>ϕ</em>(<em>a</em> + <em>b</em>) = <em>ϕ</em>(<em>a</em>) + <em>ϕ</em>(<em>b</em>)</span>（<strong>加法保持</strong>）</li><li><span class="math inline"><em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span>（<strong>乘法保持</strong>）</li></ol></li></ul></li><li>若还能证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满射</strong>，则 <span class="math inline"><em>ϕ</em></span> 是<span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满同态映射</strong></li><li>若还能证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>单射</strong>，则 <span class="math inline"><em>ϕ</em></span> 是<span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>单同态映射</strong></li></ol><h2 id="环同构">环同构</h2><p>若要证明环 <span class="math inline"><em>R</em></span> 与环 <span class="math inline"><em>R</em><sup>′</sup></span> 同构：</p><ol type="1"><li>构造环 <span class="math inline"><em>R</em></span> 与环 <span class="math inline"><em>R</em><sup>′</sup></span> 的元素间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>映射</strong><ul><li>即对 <span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>R</em></span>，证明由<span class="math inline"><em>a</em> = <em>b</em></span> 可推出 <span class="math inline"><em>ϕ</em>(<em>a</em>) = <em>ϕ</em>(<em>b</em>)</span></li></ul></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>单射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong></li></ol><p>若要证明 <span class="math inline"><em>R</em>/<em>I</em> ≅ <em>R</em><sup>′</sup></span>，即<span class="math inline"><em>R</em>/<em>I</em></span> 与 <span class="math inline"><em>R</em><sup>′</sup></span> 同构：</p><ol type="1"><li>建立环 <span class="math inline"><em>R</em></span> 与环 <span class="math inline"><em>R</em><sup>′</sup></span> 的元素之间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>映射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong> <span class="math display"><em>ϕ</em>(<em>a</em> + <em>b</em>) = <em>ϕ</em>(<em>a</em>) + <em>ϕ</em>(<em>b</em>),  <em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span></li><li>综上 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的<strong>满同态映射</strong></li><li>计算同态的 <strong>核</strong> <span class="math inline">Ker <em>ϕ</em></span>，使得 <span class="math inline"><em>I</em> = Ker <em>ϕ</em></span></li><li>应用 <strong>环同态基本定理</strong> 得 <span class="math inline"><em>R</em>/Ker <em>ϕ</em> ≅ <em>R</em><sup>′</sup></span></li></ol><h2 id="素理想">素理想</h2><p>若要证明交换环 <span class="math inline"><em>R</em></span> 的理想<span class="math inline"><em>P</em></span> 是素理想：</p><ol type="1"><li>证明 <span class="math inline"><em>P</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>真理想</strong></li><li>证明对任意 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，如果<span class="math inline"><em>a</em><em>b</em> ∈ <em>P</em></span>，则<span class="math inline"><em>a</em> ∈ <em>P</em></span> 或 <span class="math inline"><em>b</em> ∈ <em>P</em></span></li></ol><h2 id="极大理想">极大理想</h2><p>若要证明交换环 <span class="math inline"><em>R</em></span> 的理想<span class="math inline"><em>I</em></span> 是极大理想：</p><ol type="1"><li>证明 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>真理想</strong></li><li>设 <span class="math inline"><em>J</em></span> 是 <span class="math inline"><em>R</em></span> 的任意理想，且 <span class="math inline"><em>I</em> ⊊ <em>J</em> ⊆ <em>R</em></span>（左右夹击）</li><li>任取 <span class="math inline"><em>x</em> ∈ <em>J</em></span> 且<span class="math inline"><em>x</em> ∉ <em>I</em></span></li><li>根据 <span class="math inline"><em>x</em> ∉ <em>I</em></span>，获取约束条件，如不整除、互素等</li><li>构造 <span class="math inline">1 = ⋯ ∈ <em>J</em></span></li><li>因此 <span class="math inline"><em>J</em> = <em>R</em></span></li><li>故 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的极大理想</li></ol><p>若要证明交换环 <span class="math inline"><em>R</em></span> 的理想<span class="math inline"><em>I</em></span> 是唯一极大理想：</p><ol type="1"><li>证明 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的 <strong>真理想</strong></li><li>设 <span class="math inline"><em>J</em></span> 是 <span class="math inline"><em>R</em></span> 的任意 <strong>不包含于</strong><span class="math inline"><em>I</em></span> 的理想</li><li>任取 <span class="math inline"><em>x</em> ∈ <em>J</em></span> 且<span class="math inline"><em>x</em> ∉ <em>I</em></span></li><li>根据 <span class="math inline"><em>x</em> ∉ <em>I</em></span>，获取约束条件，如不整除、互素等</li><li>构造 <span class="math inline">1 = ⋯ ∈ <em>J</em></span></li><li>因此 <span class="math inline"><em>J</em> = <em>R</em></span></li><li>故 <span class="math inline"><em>R</em></span> 的所有真理想都包含于<span class="math inline"><em>I</em></span>，即 <span class="math inline"><em>I</em></span> 是唯一极大理想</li></ol><h2 id="特征">特征</h2><p>若要证明 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline"><em>n</em></span>，<span class="math inline"><em>n</em> ≠ 0</span>：<br>- 方法一： 1. 给出正整数 <span class="math inline"><em>n</em></span>，使得 <span class="math inline">∀<em>a</em> ∈ <em>R</em>, <em>n</em><em>a</em> = 0</span>（存在<span class="math inline"><em>n</em></span>） 2. 证明 <span class="math inline">∀<em>k</em>, 1 ≤ <em>k</em> &lt; <em>n</em>, ∃<em>b</em> ∈ <em>R</em>, <em>k</em><em>b</em> ≠ 0</span>（没有比<span class="math inline"><em>n</em></span> 更小的）</p><ul><li>方法二：（若 <span class="math inline"><em>R</em></span> 有单位元）<ol type="1"><li>找出 <span class="math inline"><em>R</em></span> 的单位元 <span class="math inline"><em>e</em></span></li><li>计算 <span class="math inline"><em>e</em></span> 关于加法的阶 <span class="math inline"><em>n</em></span></li><li>特征 <span class="math inline">Char <em>R</em> = <em>n</em></span></li></ol></li></ul><p>若要证明 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline"><em>n</em> = 0</span>： - 证明 <span class="math inline"><em>R</em></span> 的单位元 <span class="math inline"><em>e</em></span> 关于加法的阶为无穷大</p>        </div>      </div>    </div><h1 id="第一章-群">第一章 群</h1><h2 id="等价关系与集合的分类">等价关系与集合的分类</h2><h3 id="二元关系">二元关系</h3><p>设 <span class="math inline"><em>S</em></span> 是一个<strong>非空集合</strong> ，<span class="math inline">ℛ</span> 是关于<span class="math inline"><em>S</em></span> 的元素的一个条件。如果对<span class="math inline"><em>S</em></span> 中 <strong>任意</strong>一个 <strong>有序</strong> 元素对<span class="math inline">(<em>a</em>, <em>b</em>)</span>，我们总能<strong>确定</strong><span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 是否满足条件 <span class="math inline">ℛ</span>，就称 <span class="math inline">ℛ</span> 是<span class="math inline"><em>S</em></span>的一个<strong>关系</strong>。如果 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 满足条件 <span class="math inline">ℛ</span>，则称 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 有关系 <span class="math inline">ℛ</span>，记作 <span class="math inline"><em>a</em>ℛ<em>b</em></span>；否则称 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 无关系 <span class="math inline">ℛ</span>。</p><ul><li>关系 <span class="math inline">ℛ</span>也称为<strong>二元关系</strong>。</li><li>注意 <span class="math inline">ℛ</span>的确定性，“总能”表示忽略验证所需的时间和复杂度</li></ul><h3 id="等价关系">等价关系</h3><p>设 <span class="math inline">ℛ</span> 是非空集合 <span class="math inline"><em>S</em></span> 的一个关系，如果 <span class="math inline">ℛ</span> 满足</p><ul><li>反身性，即对任意的 <span class="math inline"><em>a</em> ∈ <em>S</em></span>，有 <span class="math inline"><em>a</em>ℛ<em>a</em></span></li><li>对称性，即若 <span class="math inline"><em>a</em>ℛ<em>b</em></span>，则 <span class="math inline"><em>b</em>ℛ<em>a</em></span></li><li>传递性，即若 <span class="math inline"><em>a</em>ℛ<em>b</em></span>，且 <span class="math inline"><em>b</em>ℛ<em>c</em></span>，则 <span class="math inline"><em>a</em>ℛ<em>c</em></span></li></ul><p>则称 <span class="math inline">ℛ</span> 是 <span class="math inline"><em>S</em></span> 的一个<strong>等价关系</strong>，并且如果 <span class="math inline"><em>a</em>ℛ<em>b</em></span>，则称<span class="math inline"><em>a</em></span> 等价于 <span class="math inline"><em>b</em></span>，记作 <span class="math inline"><em>a</em> ∼ <em>b</em></span></p><ul><li>注意可能存在孤立元素，即存在 <span class="math inline"><em>a</em></span>，对于任意 <span class="math inline"><em>b</em></span>，<span class="math inline"><em>a</em> ≁ <em>b</em></span>。</li><li>不能根据传递性和对称性推出自反性。（反例：<span class="math inline"><em>a</em></span> 可以是孤立元素且没有自反性）</li></ul><h3 id="等价类">等价类</h3><p>如果是集合 <span class="math inline"><em>S</em></span>的一个等价关系，对 <span class="math inline"><em>a</em> ∈ <em>S</em></span>，令 <span class="math display">[<em>a</em>] = {<em>x</em> ∈ <em>S</em> ∣ <em>x</em> ∼ <em>a</em>}</span></p><p>称子集 <span class="math inline">[<em>a</em>]</span> 为 <span class="math inline"><em>S</em></span> 的一个<strong>等价类</strong>。<span class="math inline"><em>S</em></span> 的全体等价类的集合称为集合<span class="math inline"><em>S</em></span>在等价关系下的<strong>商集</strong> ，记 <span class="math inline"><em>S</em>/∼</span></p><h3 id="同余关系与剩余类">同余关系与剩余类</h3><p>设 <span class="math inline"><em>m</em></span> 是正整数，在整数集<span class="math inline"><strong>Z</strong></span> 中，规定</p><p><span class="math display"><em>a</em>ℛ<em>b</em> ⇔ <em>m</em> ∣ <em>a</em> − <em>b</em>,  ∀<em>a</em>, <em>b</em> ∈ <strong>Z</strong></span></p><p>则</p><ul><li>对任意整数 <span class="math inline"><em>a</em></span>，有 <span class="math inline"><em>m</em> ∣ <em>a</em> − <em>a</em></span></li><li>若 <span class="math inline"><em>m</em> ∣ <em>a</em> − <em>b</em></span>，则<span class="math inline"><em>m</em> ∣ <em>b</em> − <em>a</em></span></li><li>若 <span class="math inline"><em>m</em> ∣ <em>a</em> − <em>b</em></span>，<span class="math inline"><em>m</em> ∣ <em>b</em> − <em>c</em></span>，则<span class="math inline"><em>m</em> ∣ <em>a</em> − <em>c</em></span></li></ul><p>所以 <span class="math inline">ℛ</span> 是 <span class="math inline">ℤ</span> 的一个等价关系。显然 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 等价当且仅当 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>b</em></span> 被 <span class="math inline"><em>m</em></span>除有相同的余数，因此称这个关系为<strong>同余关系</strong> ，并记作 <span class="math inline"><em>a</em> ≡ <em>b</em>(&nbsp;mod &nbsp;<em>m</em>)</span></p><p>设 <span class="math inline"><em>a</em> ∈ ℤ</span>，则</p><p><span class="math display">$$\begin{aligned}{[a]} &amp; =\{x \in \mathbb{Z} \mid x \equiv a \quad(\bmod m)\} \\&amp; =\{x \in \mathbb{Z} \mid m| x-a\} \\&amp; =\{a+m z \mid z \in \mathbb{Z}\}\end{aligned}$$</span></p><p><span class="math inline">[<em>a</em>]</span> 称为整数集 <span class="math inline">ℤ</span> 的一个（与 <span class="math inline"><em>a</em></span> 同余的）<strong>模 m剩余类</strong> ，在数论中，<span class="math inline">[<em>a</em>]</span> 常记作 <span class="math inline"><em>ā</em></span>，而相应的商集称为 <span class="math inline">ℤ</span> 的模 m 剩余类集，记作 <span class="math inline">ℤ<sub><em>m</em></sub></span><br>由 <span class="math display"><em>ā</em> = <em>b̄</em> ⇔ <em>m</em> ∣ <em>a</em> − <em>b</em></span></p><p>易得 <span class="math display">$$\begin{array}{l}\overline{0}=\{\cdots,-2 m,-m,0,m,2 m,\cdots\},\\\overline{1}=\{\cdots,-2 m+1,-m+1,1,m+1,2 m+1,\cdots\},\\\cdots \cdots \\\overline{m-1}=\{\cdots,-2 m-1,-m-1,-1,m-1,2 m-1,\cdots\}\end{array}$$</span></p><p>是模 <span class="math inline"><em>m</em></span>的全体不同的剩余类，所以 <span class="math display">$$\mathbb{Z}_{m}=\{\overline{0},\overline{1},\overline{2},\cdots,\overline{m-1}\}$$</span></p><h3 id="分类">分类</h3><p>如果非空集合 <span class="math inline"><em>S</em></span>是它的某些两两不相交的非空子集的并，则称这些子集为集合 <span class="math inline"><em>S</em></span> 的一种<strong>分类</strong>，其中每个子集称为 <span class="math inline"><em>S</em></span>一个<strong>类</strong> 。如果 <span class="math inline"><em>S</em></span> 的子集族 <span class="math inline">{<em>S</em><sub><em>i</em></sub> ∣ <em>i</em> ∈ <em>I</em>}</span>构成 <span class="math inline"><em>S</em></span> 的一种分类，则记作<span class="math inline">𝒫 = {<em>S</em><sub><em>i</em></sub> ∣ <em>i</em> ∈ <em>I</em>}</span>由此定义可知，集合 <span class="math inline"><em>S</em></span> 的子集族<span class="math inline">{<em>S</em><sub><em>i</em></sub> ∣ <em>i</em> ∈ <em>I</em>}</span>构成 <span class="math inline"><em>S</em></span> 的一种分类当且仅当</p><ul><li><span class="math inline"><em>S</em> = ⋃<sub><em>i</em> ∈ <em>I</em></sub><em>S</em><sub><em>i</em></sub></span></li><li><span class="math inline"><em>S</em><sub><em>i</em></sub> ∩ <em>S</em><sub><em>j</em></sub> = ⌀</span>，<span class="math inline"><em>i</em> ≠ <em>j</em></span></li></ul><p>第一个条件说明 <span class="math inline">{<em>S</em><sub><em>i</em></sub>}</span> 这些子集<strong>无遗漏地包含</strong> 了 <span class="math inline"><em>S</em></span>的全部元素，第二个条件说明两个不同的子集无公共元素，从而 <span class="math inline"><em>S</em></span> 的元素属于且仅属于一个子集</p><ul><li>这表明，<span class="math inline"><em>S</em></span>的一个分类必须满足 <strong>不漏不重</strong> 的原则</li></ul><h3 id="分类与等价关系的关系">分类与等价关系的关系</h3><ul><li>集合 <span class="math inline"><em>S</em></span>的任何一个等价关系都确定了 <span class="math inline"><em>S</em></span>的一种分类，且其中每一个类都是集合 <span class="math inline"><em>S</em></span> 的一个等价类。</li><li>反之，集合 <span class="math inline"><em>S</em></span>的任何一种分类也都给出了集合 <span class="math inline"><em>S</em></span>的一个等价关系，且相应的等价类就是原分类中的那些类。</li><li>也就是说，一个集合的分类可以通过等价关系来描述；另一方面，等价关系也可以用集合的分类来表示</li></ul><h3 id="等价关系数目">等价关系数目</h3><p>如果用 <span class="math inline"><em>B</em>(<em>n</em>)</span>表示一个具有 <span class="math inline"><em>n</em></span>个元素的集合上的不同等价关系的个数，则有下列的递推公式：</p><p><span class="math display">$$ B(n+1)=\sum_{k=0}^{n}\mathrm{C}_{n}^{k} B(k),\quad n \geqslant 1$$</span></p><p>其中 <span class="math inline">C<sub><em>n</em></sub><sup><em>k</em></sup></span>为二项式系数，并规定 <span class="math inline"><em>B</em>(0) = 1, <em>B</em>(1) = 1</span></p><p>怎么理解：这个递推公式的含义是，划分具有 <span class="math inline"><em>n</em> + 1</span> 个元素的集合时，考虑第 <span class="math inline"><em>n</em> + 1</span> 个元素，若其自成一类，则剩余<span class="math inline"><em>n</em></span> 个元素的划分方式就是 <span class="math inline"><em>B</em>(<em>n</em>)</span>；若其从剩余 <span class="math inline"><em>n</em></span> 个元素中选出 <span class="math inline">1</span> 个元素与之同类，则有 <span class="math inline">C<sub><em>n</em></sub><sup>1</sup></span>种选择方式，剩余 <span class="math inline"><em>n</em> − 1</span>个元素的划分方式就是 <span class="math inline"><em>B</em>(<em>n</em> − 1)</span>，共有 <span class="math inline">C<sub><em>n</em></sub><sup>1</sup><em>B</em>(<em>n</em> − 1)</span>种划分方式；以此类推，若其从剩余 <span class="math inline"><em>n</em></span> 个元素中选出 <span class="math inline"><em>k</em></span> 个元素与之同类，则有 <span class="math inline">C<sub><em>n</em></sub><sup><em>k</em></sup><em>B</em>(<em>k</em>)</span>种划分方式。所有这些情况加起来就是 <span class="math inline"><em>B</em>(<em>n</em> + 1)</span></p><h2 id="群的概念">群的概念</h2><h3 id="代数运算">代数运算</h3><p>设 <span class="math inline"><em>A</em></span> 是一个非空集合，若对<span class="math inline"><em>A</em></span> 中任意两个元素 <span class="math inline"><em>a</em>, <em>b</em></span>，通过某个法则“<span class="math inline">⋅</span>”，有 <span class="math inline"><em>A</em></span> 中唯一确定的元素 <span class="math inline"><em>c</em></span> 与之对应，则称法则“<span class="math inline">⋅</span>”为集合 <span class="math inline"><em>A</em></span> 上的一个<strong>代数运算</strong>。元素 <span class="math inline"><em>c</em></span> 是 <span class="math inline"><em>a</em>, <em>b</em></span> 通过运算“<span class="math inline">⋅</span>” 作用的结果，将此结果记为 <span class="math inline"><em>a</em> ⋅ <em>b</em> = <em>c</em></span></p><p>换句话说代数运算满足封闭性和唯一性：</p><ul><li><span class="math inline">∀<em>a</em>, <em>b</em> ∈ <em>A</em></span>，<span class="math inline"><em>a</em> ⋅ <em>b</em> ∈ <em>A</em></span></li><li>若 <span class="math inline"><em>a</em><sub>1</sub> ⋅ <em>b</em><sub>1</sub> = <em>c</em><sub>1</sub></span>，<span class="math inline"><em>a</em><sub>2</sub> ⋅ <em>b</em><sub>2</sub> = <em>c</em><sub>2</sub></span>，<span class="math inline"><em>a</em><sub>1</sub> = <em>a</em><sub>2</sub></span>，<span class="math inline"><em>b</em><sub>1</sub> = <em>b</em><sub>2</sub></span>，则必有<span class="math inline"><em>c</em><sub>1</sub> = <em>c</em><sub>2</sub></span></li></ul><h3 id="群的定义">群的定义</h3><p>设 <span class="math inline"><em>G</em></span> 是一个非空集合，“<span class="math inline">⋅</span>”是 <span class="math inline"><em>G</em></span> 上的一个代数运算，即</p><ul><li>(G0) 对所有的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em> ⋅ <em>b</em> ∈ <em>G</em></span>。</li></ul><p>如果 <span class="math inline"><em>G</em></span> 的运算还满足</p><ul><li>(G1) 结合律，即对所有的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>G</em></span>，有<span class="math inline">(<em>a</em> ⋅ <em>b</em>) ⋅ <em>c</em> = <em>a</em> ⋅ (<em>b</em> ⋅ <em>c</em>)</span></li><li>(G2) <span class="math inline"><em>G</em></span> 中有元素 <span class="math inline"><em>e</em></span>，使对每个 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>e</em> ⋅ <em>a</em> = <em>a</em> ⋅ <em>e</em> = <em>a</em></span></li><li>(G3) 对 <span class="math inline"><em>G</em></span> 中每个元素 <span class="math inline"><em>a</em></span>，存在元素 <span class="math inline"><em>b</em> ∈ <em>G</em></span>，使 <span class="math inline"><em>a</em> ⋅ <em>b</em> = <em>b</em> ⋅ <em>a</em> = <em>e</em></span></li></ul><p>则称 <span class="math inline"><em>G</em></span> 关于运算“<span class="math inline">⋅</span>”构成一个<strong>群</strong> ，记作 <span class="math inline">(<em>G</em>, ⋅)</span>。在不致引起混淆的情况下，也称<span class="math inline"><em>G</em></span> 为群。</p><ul><li><p>(G2) 中的元素 <span class="math inline"><em>e</em></span> 称为群<span class="math inline"><em>G</em></span> 的<strong>单位元</strong>或恒等元；</p></li><li><p>(G3) 中的元素 <span class="math inline"><em>b</em></span> 称为<span class="math inline"><em>a</em></span>的<strong>逆元</strong></p></li><li><p>群 <span class="math inline"><em>G</em></span> 的单位元 <span class="math inline"><em>e</em></span>和每个元素的逆元都是唯一的</p></li><li><p><span class="math inline"><em>G</em></span> 中元素 <span class="math inline"><em>a</em></span> 的唯一的逆元通常记作 <span class="math inline"><em>a</em><sup>−1</sup></span></p></li><li><p>如果群 <span class="math inline"><em>G</em></span>的运算还满足交换律，即对任意的 <span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em> ⋅ <em>b</em> = <em>b</em> ⋅ <em>a</em></span>，则称<span class="math inline"><em>G</em></span> 是一个<strong>交换群</strong> 或 <strong>阿贝尔群</strong></p></li><li><p>群 <span class="math inline"><em>G</em></span> 中元素的个数称为群<span class="math inline"><em>G</em></span> 的 <strong>阶</strong>，记为 <span class="math inline">|<em>G</em>|</span>。如果 <span class="math inline">|<em>G</em>|</span> 是有限数，则称 <span class="math inline"><em>G</em></span> 为 <strong>有限群</strong>，否则称 <span class="math inline"><em>G</em></span> 为<strong>无限群</strong></p></li><li><p>当群 <span class="math inline"><em>G</em></span>的运算用加号“+”表示时，通常将 <span class="math inline"><em>G</em></span> 的单位元记作 <span class="math inline">0</span>，并称 <span class="math inline">0</span> 为<span class="math inline"><em>G</em></span> 的 <strong>零元</strong>；将 <span class="math inline"><em>a</em> ∈ <em>G</em></span> 的逆元记作<span class="math inline">−<em>a</em></span>，并称 <span class="math inline">−<em>a</em></span> 为 <span class="math inline"><em>a</em></span> 的 <strong>负元</strong></p></li><li><p>习惯上，只有当群为交换群时，才用“+”来表示群的运算，并称这个运算为加法，把运算的结果叫做和，同时称这样的群为<strong>加群</strong></p></li><li><p>相应地，将不是加群的群称为 <strong>乘群</strong>，并把乘群的运算叫做乘法，运算的结果叫做积。在运算过程中，乘群的运算符号通常省略不写</p></li><li><p>今后，如不作特别声明，<strong>总假定群的运算是乘法</strong></p></li></ul><h3 id="群表">群表</h3><p>形如下表的表通常称为群的 <strong>乘法表</strong> ，也称<strong>群表</strong> 或<strong>凯莱表</strong>。人们常用群表来表示有限群的运算</p><table><thead><tr><th><span class="math inline">∘</span></th><th><span class="math inline"><em>e</em></span></th><th><span class="math inline">⋯</span></th><th><span class="math inline"><em>b</em></span></th><th><span class="math inline">⋯</span></th></tr></thead><tbody><tr><td><span class="math inline"><em>e</em></span></td><td><span class="math inline"><em>e</em></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><em>b</em></span></td><td><span class="math inline">⋯</span></td></tr><tr><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋱</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋱</span></td></tr><tr><td><span class="math inline"><em>a</em></span></td><td><span class="math inline"><em>a</em></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><em>a</em> ∘ <em>b</em></span></td><td><span class="math inline">⋯</span></td></tr></tbody></table><p>在一个群表中，</p><ul><li>表的左上角列出了群的运算符号（有时省略）</li><li>表的最上面一行则依次列出群的所有元素（通常单位元列在最前面）</li><li>表的最左列按同样的次序列出群的所有元素</li><li>表中的其余部分则是最左列的元素和最上面一行的元素的乘积</li><li>注意，在乘积 <span class="math inline"><em>a</em> ∘ <em>b</em></span> 中，左边的因子 <span class="math inline"><em>a</em></span> 是左列上的元素，右边的因子 <span class="math inline"><em>b</em></span> 是最上面一行的元素</li><li>由群表很容易确定一个元素的逆元素</li><li>如果一个群的群表是对称的，则可以肯定，这个群一定是交换群</li></ul><h3 id="群的性质">群的性质</h3><p>设 <span class="math inline"><em>G</em></span> 为群，则有</p><ul><li>群 <span class="math inline"><em>G</em></span> 的单位元是唯一的</li><li>群 <span class="math inline"><em>G</em></span>的每个元素的逆元是唯一的</li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline">(<em>a</em><sup>−1</sup>)<sup>−1</sup> = <em>a</em></span></li><li>对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，有 <span class="math inline">(<em>a</em><em>b</em>)<sup>−1</sup> = <em>b</em><sup>−1</sup><em>a</em><sup>−1</sup></span></li><li>在群中消去律成立，即设 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>G</em></span>，如果<span class="math inline"><em>a</em><em>b</em> = <em>a</em><em>c</em></span>，或<span class="math inline"><em>b</em><em>a</em> = <em>c</em><em>a</em></span>，则<span class="math inline"><em>b</em> = <em>c</em></span></li></ul><p>设 <span class="math inline"><em>G</em></span> 是群，那么对任意的<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，方程</p><p><span class="math display"><em>a</em><em>x</em> = <em>b</em>  及  <em>y</em><em>a</em> = <em>b</em></span></p><p>在 <span class="math inline"><em>G</em></span> 中都有唯一解</p><h3 id="方幂">方幂</h3><p>群的定义中的结合律表明，群中三个元素 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em></span>的乘积与运算的顺序无关，因此可以简单地写成：<span class="math inline"><em>a</em><em>b</em><em>c</em></span>。进一步可知，在群<span class="math inline"><em>G</em></span> 中，任意 <span class="math inline"><em>k</em></span> 个元素 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>k</em></sub></span>的乘积与运算的顺序无关，因此可以写成 <span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>2</sub>⋯<em>a</em><sub><em>k</em></sub></span>。据此，可以定义群的元素的<strong>方幂</strong>：</p><h4 id="乘群">乘群</h4><p>对任意的正整数 <span class="math inline"><em>n</em></span>，定义<span class="math display">$$a^{n}=\underbrace{a \cdot a \cdots a}_{n \text{个} a}$$</span></p><p>再约定 <span class="math display">$$\begin{aligned}a^{0} &amp; =e,\\a^{-n} &amp; =\left(a^{-1}\right)^{n} \quad(n \text{为正整数}),\end{aligned}$$</span></p><p>则 <span class="math inline"><em>a</em><sup><em>n</em></sup></span>对任意整数 <span class="math inline"><em>n</em></span>都有意义，并且不难证明，对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，<span class="math inline"><em>m</em>, <em>n</em> ∈ <strong>Z</strong></span>，有下列的指数法则：</p><ul><li><span class="math inline"><em>a</em><sup><em>n</em></sup> ⋅ <em>a</em><sup><em>m</em></sup> = <em>a</em><sup><em>n</em> + <em>m</em></sup></span></li><li><span class="math inline">(<em>a</em><sup><em>n</em></sup>)<sup><em>m</em></sup> = <em>a</em><sup><em>n</em><em>m</em></sup></span></li><li>如果 <span class="math inline"><em>G</em></span> 是交换群，则 <span class="math inline">(<em>a</em><em>b</em>)<sup><em>n</em></sup> = <em>a</em><sup><em>n</em></sup><em>b</em><sup><em>n</em></sup></span></li></ul><h4 id="加群">加群</h4><p>当 <span class="math inline"><em>G</em></span>是加群时，元素的方幂则应改写为倍数</p><p><span class="math display">$$\begin{aligned}n a=\underbrace{a+a+\cdots+a}_{n \text{个} a}\\0 a=0,\\(-n) a=n(-a)\end{aligned}$$</span></p><p>相应地，指数法则变为倍数法则，</p><ul><li><span class="math inline"><em>n</em><em>a</em> + <em>m</em><em>a</em> = (<em>n</em> + <em>m</em>)<em>a</em></span></li><li><span class="math inline"><em>m</em>(<em>n</em><em>a</em>) = (<em>m</em><em>n</em>)<em>a</em></span></li><li><span class="math inline"><em>n</em>(<em>a</em> + <em>b</em>) = <em>n</em><em>a</em> + <em>n</em><em>b</em></span></li></ul><p>因为加群是交换群，所以第三条总是成立的</p><h3 id="群的判定">群的判定</h3><ul><li><p>设 <span class="math inline"><em>G</em></span>是一个具有代数运算的非空集合，则 <span class="math inline"><em>G</em></span>关于所给的运算构成群的<strong>充分必要条件</strong> 是</p><ul><li><span class="math inline"><em>G</em></span> 的运算满足结合律</li><li><span class="math inline"><em>G</em></span> 中有一个元素 <span class="math inline"><em>e</em></span>（称为 <span class="math inline"><em>G</em></span> 的左单位元），使对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>e</em><em>a</em> = <em>a</em></span></li><li>对 <span class="math inline"><em>G</em></span> 的每一个元素 <span class="math inline"><em>a</em></span>，存在 <span class="math inline"><em>a</em><sup>′</sup> ∈ <em>G</em></span>（称为<span class="math inline"><em>a</em></span> 的左逆元），使 <span class="math inline"><em>a</em><sup>′</sup><em>a</em> = <em>e</em></span>。这里<span class="math inline"><em>e</em></span> 是 <span class="math inline"><em>G</em></span> 的左单位元</li></ul><p>换句话说，一个具有乘法运算的非空集合 <span class="math inline"><em>G</em></span>，只要满足结合律，有左单位元，每个元素有左逆元，就构成一个群。同理可证，一个具有乘法运算的非空集合 <span class="math inline"><em>G</em></span>，如果满足结合律，有右单位元，且<span class="math inline"><em>G</em></span> 中每个元素有右逆元，则 <span class="math inline"><em>G</em></span> 也构成群</p></li><li><p>设 <span class="math inline"><em>G</em></span>是一个具有乘法运算且满足结合律的非空集合，则 <span class="math inline"><em>G</em></span> 构成群的<strong>充分必要条件</strong> 是对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，方程<span class="math display"><em>a</em><em>x</em> = <em>b</em>  与  <em>y</em><em>a</em> = <em>b</em></span></p><p>在 <span class="math inline"><em>G</em></span> 中都有解</p></li><li><p>设 <span class="math inline"><em>G</em></span>是一个具有乘法运算的非空 <strong>有限</strong> 集合，如果 <span class="math inline"><em>G</em></span> 满足结合律，且两个消去律成立，则<span class="math inline"><em>G</em></span> 构成群</p><ul><li>要注意的是，如果没有有限的条件，一个具有代数运算的集合，仅仅满足结合律和两个消去律，并不一定构成群</li></ul></li></ul><h3 id="常用例子">常用例子</h3><ul><li>整数集 <span class="math inline"><strong>Z</strong></span>关于数的加法构成群，这个群称为整数加群</li><li>全体非零有理数的集合 <span class="math inline"><strong>Q</strong><sup>*</sup></span>关于数的乘法构成交换群</li><li>全体非零实数的集合 <span class="math inline"><strong>R</strong><sup>*</sup></span>关于数的乘法也构成交换群</li><li>全体非零复数的集合 <span class="math inline"><strong>C</strong><sup>*</sup></span>关于数的乘法也构成交换群</li><li>全体 <span class="math inline"><em>n</em></span> 次单位根组成的集合<span class="math display">$$  \begin{aligned} U_{n}  &amp; =\left\{x \in \mathbf{C} \mid x^{n}=1\right\} \\  &amp; =\left\{\left.\cos \frac{2 k \pi}{n}+i \sin \frac{2 k \pi}{n}\right\rvert\,k=0,1,2,\cdots,n-1\right\}  \end{aligned}  $$</span> 关于数的乘法构成一个 <span class="math inline"><em>n</em></span> 阶交换群，通常称这个群为 <strong>n次单位根群</strong></li><li>设 <span class="math inline"><em>m</em></span> 是大于 <span class="math inline">1</span> 的正整数，记 <span class="math display">$$  \mathbf{Z}_{m}=\{\overline{0},\overline{1},\overline{2},\cdots,\overline{m-1}\}  $$</span> 则 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>关于剩余类的加法构成加群，这个群称为 <span class="math inline"><strong>Z</strong></span> 的模 <span class="math inline"><em>m</em></span> 剩余类加群</li><li>设 <span class="math inline"><em>m</em></span> 是大于 <span class="math inline">1</span> 的正整数，记 <span class="math display"><em>U</em>(<em>m</em>) = {<em>ā</em> ∈ <strong>Z</strong><sub><em>m</em></sub> ∣ (<em>a</em>, <em>m</em>) = 1}</span>则 <span class="math inline"><em>U</em>(<em>m</em>)</span>关于剩余类的乘法构成群，群 <span class="math inline">(<em>U</em>(<em>m</em>), ⋅)</span> 称为 <span class="math inline"><strong>Z</strong></span> 的模 <span class="math inline"><em>m</em></span>单位群，显然这是一个交换群，不一定是循环群。当 <span class="math inline"><em>p</em></span> 为素数时，<span class="math inline"><em>U</em>(<em>p</em>)</span> 常记作 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>，易知<span class="math display">$$  \mathbf{Z}_{p}^{*}=\{\overline{1},\overline{2},\cdots,\overline{p-1}\}  $$</span> 这是一个循环群，<span class="math inline"><em>U</em>(<em>m</em>)</span> 的阶等于欧拉函数 <span class="math inline"><em>ϕ</em>(<em>m</em>)</span></li></ul><h2 id="子群">子群</h2><h3 id="子群的定义">子群的定义</h3><p>设 <span class="math inline"><em>G</em></span> 是一个群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的一个非空子集。如果 <span class="math inline"><em>H</em></span> 关于 <span class="math inline"><em>G</em></span> 的运算也构成群，则称 <span class="math inline"><em>H</em></span> 为 <span class="math inline"><em>G</em></span> 的一个<strong>子群</strong> ，记作<span class="math inline"><em>H</em> &lt; <em>G</em></span></p><ul><li><p>对任意群 <span class="math inline"><em>G</em></span>，<span class="math inline"><em>G</em></span> 本身以及只含单位元 <span class="math inline"><em>e</em></span> 的子集 <span class="math inline"><em>H</em> = {<em>e</em>}</span> 是 <span class="math inline"><em>G</em></span> 的子群，这两个子群称为 <span class="math inline"><em>G</em></span> 的 <strong>平凡子群</strong> 。群<span class="math inline"><em>G</em></span> 的其他子群称为 <span class="math inline"><em>G</em></span> 的<strong>非平凡子群</strong></p></li><li><p>群 <span class="math inline"><em>G</em></span>的不等于它自身的子群称为 <span class="math inline"><em>G</em></span> 的<strong>真子群</strong></p></li><li><p>设 <span class="math inline"><em>m</em></span> 是一个整数，令<span class="math display"><em>H</em> = {<em>m</em><em>z</em> ∣ <em>z</em> ∈ <strong>Z</strong>}</span></p><p>则 <span class="math inline"><em>H</em></span> 为整数加群 <span class="math inline"><strong>Z</strong></span> 的子群。这个群称为由 <span class="math inline"><em>m</em></span> 所 <strong>生成的子群</strong>，常记作 <span class="math inline"><em>m</em><strong>Z</strong></span>或 <span class="math inline">⟨<em>m</em>⟩</span></p></li></ul><h3 id="子群的判定">子群的判定</h3><ul><li>由于群 <span class="math inline"><em>G</em></span>的运算满足结合律，所以结合律在 <span class="math inline"><em>G</em></span> 的任何关于 <span class="math inline"><em>G</em></span> 的运算封闭的非空子集 <span class="math inline"><em>H</em></span>上都成立。于是，由群的定义知，如果群 <span class="math inline"><em>G</em></span> 的非空子集 <span class="math inline"><em>H</em></span> 满足下列条件，则 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的子群：<ul><li><span class="math inline"><em>H</em></span> 在群的运算下封闭</li><li><span class="math inline"><em>H</em></span> 有单位元</li><li><span class="math inline"><em>H</em></span>包含它的每个元素的逆元</li></ul></li><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的 <strong>非空子集</strong> ，则<span class="math inline"><em>H</em></span> 成为群 <span class="math inline"><em>G</em></span> 的子群的<strong>充分必要条件</strong> 是<ul><li>对任意 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>H</em></span>，有 <span class="math inline"><em>a</em><em>b</em> ∈ <em>H</em></span></li><li>对任意 <span class="math inline"><em>a</em> ∈ <em>H</em></span>，有<span class="math inline"><em>a</em><sup>−1</sup> ∈ <em>H</em></span></li></ul></li><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的 <strong>非空子集</strong> ，则<span class="math inline"><em>H</em></span> 成为 <span class="math inline"><em>G</em></span> 的子群的<strong>充分必要条件</strong> 是<ul><li>对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>H</em></span>，有 <span class="math inline"><em>a</em><em>b</em><sup>−1</sup> ∈ <em>H</em></span></li></ul></li></ul><h3 id="子群的性质">子群的性质</h3><ul><li><p>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，则</p><ul><li>群 <span class="math inline"><em>G</em></span> 的单位元 <span class="math inline"><em>e</em></span> 是 <span class="math inline"><em>H</em></span> 的单位元；</li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>H</em></span>，<span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>G</em></span> 中的逆元 <span class="math inline"><em>a</em><sup>−1</sup></span> 就是 <span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>H</em></span> 中的逆元</li></ul></li><li><p>设 <span class="math inline"><em>G</em></span> 为群，记 <span class="math display"><em>C</em>(<em>G</em>) = {<em>g</em> ∈ <em>G</em> ∣ <em>g</em><em>x</em> = <em>x</em><em>g</em>, ∀<em>x</em> ∈ <em>G</em>}</span></p><p>则 <span class="math inline"><em>C</em>(<em>G</em>)</span> 是 <span class="math inline"><em>G</em></span> 的子群。称 <span class="math inline"><em>C</em>(<em>G</em>)</span> 为 <span class="math inline"><em>G</em></span> 的<strong>中心</strong>。</p></li><li><p>设 <span class="math inline"><em>a</em></span> 是群 <span class="math inline"><em>G</em></span> 的元素，定义 <span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>G</em></span> 中的 <strong>中心化子</strong> 为<span class="math display"><em>C</em>(<em>a</em>) = {<em>g</em> ∈ <em>G</em> ∣ <em>g</em><em>a</em> = <em>a</em><em>g</em>}</span></p><p>则 <span class="math inline"><em>C</em>(<em>a</em>)</span> 是 <span class="math inline"><em>G</em></span> 的子群，且满足 <span class="math display"><em>C</em>(<em>G</em>) = ⋂<sub><em>a</em> ∈ <em>G</em></sub><em>C</em>(<em>a</em>)</span></p></li><li><p>群 <span class="math inline"><em>G</em></span> 的任意两个子群的<strong>交</strong> 集 <strong>一定</strong> 是 <span class="math inline"><em>G</em></span> 的子群</p></li><li><p>群 <span class="math inline"><em>G</em></span> 的任意两个子群的<strong>并</strong> 集 <strong>不一定</strong> 是 <span class="math inline"><em>G</em></span> 的子群</p></li></ul><h3 id="生成子群">生成子群</h3><h4 id="生成子群的定义">生成子群的定义</h4><p>设 <span class="math inline"><em>S</em></span> 是群 <span class="math inline"><em>G</em></span> 的一个非空子集，令 <span class="math inline"><em>M</em></span> 表示 <span class="math inline"><em>G</em></span> 中所有包含 <span class="math inline"><em>S</em></span> 的子群所组成的集合，即 <span class="math display"><em>M</em> = {<em>H</em> &lt; <em>G</em> ∣ <em>S</em> ⊆ <em>H</em>}</span></p><p>本身显然包含 <span class="math inline"><em>S</em></span>，所以 <span class="math inline"><em>G</em> ∈ <em>M</em></span>，从而 <span class="math inline"><em>M</em></span> 非空。令 <span class="math display"><em>K</em> = ⋂<sub><em>H</em> ∈ <em>M</em></sub><em>H</em></span></p><p>则 <span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，称 <span class="math inline"><em>K</em></span> 为群 <span class="math inline"><em>G</em></span> 的由子集 <span class="math inline"><em>S</em></span>所生成的子群，简称<strong>生成子群</strong> ，记作 <span class="math inline">⟨<em>S</em>⟩</span>，即 <span class="math display">⟨<em>S</em>⟩ = ⋂<sub><em>S</em> ⊆ <em>H</em> &lt; <em>G</em></sub><em>H</em></span></p><p>子集 <span class="math inline"><em>S</em></span> 称为 <span class="math inline">⟨<em>S</em>⟩</span>的<strong>生成元组</strong></p><p>如果 <span class="math inline"><em>S</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>r</em></sub>}</span>为有限集，则记</p><p><span class="math display">⟨<em>S</em>⟩ = ⟨<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>r</em></sub>⟩</span></p><h4 id="生成子群的性质">生成子群的性质</h4><p>设 <span class="math inline"><em>S</em></span> 是群 <span class="math inline"><em>G</em></span> 的非空子集，则</p><ul><li><span class="math inline">⟨<em>S</em>⟩</span> 是 <span class="math inline"><em>G</em></span> 的包含 <span class="math inline"><em>S</em></span> 的最小子群</li><li><span class="math inline">⟨<em>S</em>⟩ = {<em>a</em><sub>1</sub><sup><em>l</em><sub>1</sub></sup><em>a</em><sub>2</sub><sup><em>l</em><sub>2</sub></sup>⋯<em>a</em><sub><em>k</em></sub><sup><em>l</em><sub><em>k</em></sub></sup> ∣ <em>a</em><sub><em>i</em></sub> ∈ <em>S</em>, <em>l</em><sub><em>i</em></sub> = ±1, <em>k</em> ∈ <strong>N</strong>}</span></li></ul><p><strong>特别注意</strong> ：上式中的 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>k</em></sub></span>可以取重复的值。若我们用不重复的 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>k</em></sub></span>来表示，那么这个乘法式子可能是无限长（因为不一定有交换律），不太好表示了。</p><h4 id="特例">特例</h4><ul><li><p>当 <span class="math inline"><em>S</em></span> 只包含群 <span class="math inline"><em>G</em></span> 的一个元素 <span class="math inline"><em>a</em></span> 时，由于 <span class="math display">$$  a^{l_{1}} a^{l_{2}} \cdots a^{l_{k}}=a^{\sum_{i=1}^{k} l_{i}}  $$</span> 所以 <span class="math display">⟨<em>a</em>⟩ = {<em>a</em><sup><em>r</em></sup> ∣ <em>r</em> ∈ <strong>Z</strong>}</span></p><p>这种由一个元素 <span class="math inline"><em>a</em></span>生成的子群称为由 <span class="math inline"><em>a</em></span> 生成的<strong>循环群</strong></p></li><li><p>当 <span class="math inline"><em>S</em></span> 只包含群 <span class="math inline"><em>G</em></span> 的两个元素 <span class="math inline"><em>a</em>, <em>b</em></span>，且 <span class="math inline"><em>a</em><em>b</em> = <em>b</em><em>a</em></span>，则<span class="math display">⟨<em>a</em>, <em>b</em>⟩ = {<em>a</em><sup><em>m</em></sup><em>b</em><sup><em>n</em></sup> ∣ <em>m</em>, <em>n</em> ∈ <strong>Z</strong>}</span></p></li></ul><h2 id="群的同构">群的同构</h2><h3 id="同构的定义">同构的定义</h3><p>设 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 是两个群，<span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的一一对应，使 <span class="math display"><em>ϕ</em>(<em>a</em> ⋅ <em>b</em>) = <em>ϕ</em>(<em>a</em>) ⋅ <em>ϕ</em>(<em>b</em>),  ∀<em>a</em>, <em>b</em> ∈ <em>G</em>,</span></p><p>则称 <span class="math inline"><em>ϕ</em></span> 为群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的一个<strong>同构映射</strong> ，简称<strong>同构</strong> ，并称群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> <strong>同构</strong>，记作 <span class="math display"><em>ϕ</em>: <em>G</em> ≅ <em>G</em><sup>′</sup></span></p><ul><li>群 <span class="math inline"><em>G</em></span>到它自身的同构映射称为群 <span class="math inline"><em>G</em></span>的<strong>自同构</strong> ，恒等同构是自同构</li><li>同构映射一定是可逆变换（双射），且其逆映射也是同构映射</li><li>同构的群之间可以有不止一个同构映射</li><li>在群同构的定义中，虽然使用了同一个符号“ <span class="math inline">⋅</span> ”表示群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span>的运算，但事实上，<span class="math inline"><em>a</em> ⋅ <em>b</em></span> 与 <span class="math inline"><em>ϕ</em>(<em>a</em>) ⋅ <em>ϕ</em>(<em>b</em>)</span>分别是在群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span>中进行的运算，一般来说它们是不相同的</li></ul><h3 id="证明两个群同构的步骤">证明两个群同构的步骤</h3><ol type="1"><li>构造群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的映射</li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>单映射</strong> 。即对任意的 <span class="math inline"><em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明由<span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>ϕ</em>(<em>y</em>)</span>可推出 <span class="math inline"><em>x</em> = <em>y</em></span></li><li>证明 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>满映射</strong> 。即对任意的 <span class="math inline"><em>x</em><sup>′</sup> ∈ <em>G</em><sup>′</sup></span>，证明存在<span class="math inline"><em>x</em> ∈ <em>G</em></span>，使 <span class="math inline"><em>ϕ</em>(<em>x</em>) = <em>x</em><sup>′</sup></span></li><li>证明 <span class="math inline"><em>ϕ</em></span><strong>保持运算</strong> 。即对任意的 <span class="math inline"><em>x</em>, <em>y</em> ∈ <em>G</em></span>，证明<span class="math inline"><em>ϕ</em>(<em>x</em><em>y</em>) = <em>ϕ</em>(<em>x</em>)<em>ϕ</em>(<em>y</em>)</span></li></ol><h3 id="同构的性质">同构的性质</h3><ul><li>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的同构映射，<span class="math inline"><em>e</em></span> 与 <span class="math inline"><em>e</em><sup>′</sup></span> 分别是 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 的单位元，<span class="math inline"><em>a</em></span> 是 <span class="math inline"><em>G</em></span> 的任一元素，则<ul><li><span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span></li><li><span class="math inline"><em>ϕ</em>(<em>a</em><sup>−1</sup>) = (<em>ϕ</em>(<em>a</em>))<sup>−1</sup></span></li><li><span class="math inline"><em>ϕ</em></span> 是可逆映射，且 <span class="math inline"><em>ϕ</em></span> 的逆映射 <span class="math inline"><em>ϕ</em><sup>−1</sup></span> 是群 <span class="math inline"><em>G</em><sup>′</sup></span> 到群 <span class="math inline"><em>G</em></span> 的同构映射</li></ul></li><li>设群 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 同构<ul><li>如果 <span class="math inline"><em>G</em></span> 是交换群（Abel群），则 <span class="math inline"><em>G</em><sup>′</sup></span>也是交换群</li><li>如果 <span class="math inline"><em>G</em></span> 是有限群，则 <span class="math inline"><em>G</em><sup>′</sup></span> 也是有限群，且 <span class="math inline">|<em>G</em>| = |<em>G</em><sup>′</sup>|</span></li></ul></li><li>群的同构是一个等价关系，即对群 <span class="math inline"><em>G</em>, <em>G</em><sup>′</sup>, <em>G</em><sup>′′</sup></span><ul><li>反身性：<span class="math inline"><em>G</em> ≅ <em>G</em></span></li><li>对称性：若 <span class="math inline"><em>G</em> ≅ <em>G</em><sup>′</sup></span>，则 <span class="math inline"><em>G</em><sup>′</sup> ≅ <em>G</em></span></li><li>传递性：若 <span class="math inline"><em>G</em> ≅ <em>G</em><sup>′</sup></span>，<span class="math inline"><em>G</em><sup>′</sup> ≅ <em>G</em><sup>′′</sup></span>，则<span class="math inline"><em>G</em> ≅ <em>G</em><sup>′′</sup></span></li><li><strong>注意</strong>：同构关系是等价关系，映射不是等价关系！</li></ul></li></ul><h3 id="变换群">变换群</h3><h4 id="变换群的定义">变换群的定义</h4><p>非空集合 <span class="math inline"><em>X</em></span>的全体可逆变换关于变换的合成所构成的群 <span class="math inline"><em>S</em><sub><em>x</em></sub></span> 称为集合<span class="math inline"><em>X</em></span> 的<strong>对称群</strong>，<span class="math inline"><em>S</em><sub><em>x</em></sub></span>的任一子群称为 <span class="math inline"><em>X</em></span>的一个<strong>变换群</strong>。</p><h4 id="凯莱定理">凯莱定理</h4><p><strong>每一个群都同构于一个变换群。</strong></p><p>证明凯莱定理，需要先构造一个变换群，如对于群 <span class="math inline"><em>G</em></span>，<span class="math inline"><em>a</em> ∈ <em>G</em></span>，定义变换 <span class="math inline"><em>ϕ</em><sub><em>a</em></sub></span> 为 <span class="math display"><em>ϕ</em><sub><em>a</em></sub>(<em>x</em>) = <em>a</em><em>x</em>  (<em>x</em> ∈ <em>G</em>)</span></p><p>则 <span class="math inline"><em>ϕ</em><sub><em>a</em></sub></span>是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em></span> 的一个变换。令 <span class="math display"><em>G</em><sub><em>l</em></sub> = {<em>ϕ</em><sub><em>a</em></sub> ∣ <em>a</em> ∈ <em>G</em>}</span></p><p>则可以证明 <span class="math inline"><em>G</em><sub><em>l</em></sub></span> 是对称群<span class="math inline"><em>S</em><sub><em>G</em></sub></span>的一个子群，即 <span class="math inline"><em>G</em><sub><em>l</em></sub></span> 是群 <span class="math inline"><em>G</em></span> 的一个变换群。又可以证明 <span class="math inline"><em>G</em><sub><em>l</em></sub> ≅ <em>G</em></span>，即群<span class="math inline"><em>G</em></span> 同构于它的变换群 <span class="math inline"><em>G</em><sub><em>l</em></sub></span></p><p>变换群 <span class="math inline"><em>G</em><sub><em>l</em></sub></span> 称为 群 <span class="math inline"><em>G</em></span> 的<strong>左正则表示</strong>，变换 <span class="math inline"><em>ϕ</em><sub><em>a</em></sub></span> 称为群 <span class="math inline"><em>G</em></span> 由元素 <span class="math inline"><em>a</em></span> 所定义的<strong>左平移</strong>。</p><h2 id="循环群">循环群</h2><h3 id="群的阶">群的阶</h3><h4 id="阶的定义">阶的定义</h4><p>设 <span class="math inline"><em>G</em></span> 是一个群，<span class="math inline"><em>e</em></span> 是 <span class="math inline"><em>G</em></span> 的单位元，<span class="math inline"><em>a</em> ∈ <em>G</em></span>。如果存在正整数 <span class="math inline"><em>r</em></span>，使 <span class="math inline"><em>a</em><sup><em>r</em></sup> = <em>e</em></span>，则称<span class="math inline"><em>a</em></span> 是 <strong>有限阶</strong>的，否则称 <span class="math inline"><em>a</em></span>是<strong>无限阶</strong> 的。使 <span class="math inline"><em>a</em><sup><em>r</em></sup> = <em>e</em></span><strong>的最小正整数</strong> <span class="math inline"><em>r</em></span> 称为元素 <span class="math inline"><em>a</em></span> 的<strong>阶</strong> ，记作 <span class="math inline">ord <em>a</em> = <em>r</em></span>。如果 <span class="math inline"><em>a</em></span> 是无限阶的，则记作 <span class="math inline">ord <em>a</em> = ∞</span>。</p><ul><li>在任何一个群中，单位元的阶总是 <span class="math inline">1</span></li><li>在整数加群 <span class="math inline"><strong>Z</strong></span>中，除零元 <span class="math inline">0</span>外，每个元素都是无限阶的</li></ul><h4 id="阶的性质">阶的性质</h4><ul><li><p>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>e</em></span> 为 <span class="math inline"><em>G</em></span> 的单位元</p><ul><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline">ord <em>a</em> = ord <em>a</em><sup>−1</sup></span></li><li>设 <span class="math inline">ord <em>a</em> = <em>n</em></span>，如果有 <span class="math inline"><em>m</em> ∈ <strong>Z</strong></span>，使 <span class="math inline"><em>a</em><sup><em>m</em></sup> = <em>e</em></span>，则<span class="math inline"><em>n</em> ∣ <em>m</em></span></li><li>设 <span class="math inline">ord <em>a</em> = <em>n</em></span>，则对任意的 <span class="math inline"><em>m</em> ∈ <strong>Z</strong></span>，<span class="math inline">$\operatorname{ord}a^{m}=\frac{n}{(n,m)}$</span></li><li>设 <span class="math inline">ord <em>a</em> = <em>n</em></span>，<span class="math inline">ord <em>b</em> = <em>m</em></span>，如果 <span class="math inline"><em>a</em><em>b</em> = <em>b</em><em>a</em></span>，且<span class="math inline">gcd (<em>n</em>, <em>m</em>) = 1</span>，则<span class="math inline">ord (<em>a</em><em>b</em>) = <em>m</em><em>n</em></span></li></ul><p>其中 <span class="math inline">(<em>n</em>, <em>m</em>)</span> 与<span class="math inline">gcd (<em>n</em>, <em>m</em>)</span> 表示 <span class="math inline"><em>n</em></span> 与 <span class="math inline"><em>m</em></span> 的最大公约数</p></li><li><p>设 <span class="math inline"><em>G</em></span>是一个有限群，<span class="math inline">|<em>G</em>| = <em>n</em></span>，则对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，<span class="math inline"><em>a</em></span> 是有限阶的，且 <span class="math inline">ord <em>a</em> ∣ |<em>G</em>|</span>，即有限群的任何一个元素的阶都是群阶数的因子。</p></li></ul><h3 id="循环群-1">循环群</h3><h4 id="循环群的定义">循环群的定义</h4><p>设 <span class="math inline"><em>G</em></span> 是群，如果存在 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，使得 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span>（a的生成子群），则称 <span class="math inline"><em>G</em></span> 为一个<strong>循环群</strong> ，并称 <span class="math inline"><em>a</em></span> 为 <span class="math inline"><em>G</em></span> 的一个 <strong>生成元</strong>。当 <span class="math inline"><em>G</em></span> 的元素个数无限时，称<span class="math inline"><em>G</em></span> 为<strong>无限循环群</strong> ；当 <span class="math inline"><em>G</em></span> 的元素个数为 <span class="math inline"><em>n</em></span> 时，称 <span class="math inline"><em>G</em></span> 为 <strong>n阶循环群</strong>。</p><ul><li>整数加群 <span class="math inline"><strong>Z</strong></span>是无限循环群</li><li>设 <span class="math inline"><em>m</em></span> 为正整数，则模 <span class="math inline"><em>m</em></span> 剩余类加群 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span> 是<span class="math inline"><em>m</em></span> 阶循环群</li><li><span class="math inline"><em>n</em></span> 次单位根群 <span class="math inline"><em>U</em><sub><em>n</em></sub></span> 是一个 <span class="math inline"><em>n</em></span> 阶循环群</li></ul><p>由循环群的定义可知：</p><ul><li><span class="math inline">⟨<em>a</em>⟩ = ⟨<em>a</em><sup>−1</sup>⟩</span></li><li>如果 <span class="math inline"><em>G</em></span> 是循环群，则 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩ ⇔ |<em>G</em>| = ord <em>a</em></span>，即<span class="math inline"><em>G</em></span> 的阶等于 <span class="math inline"><em>a</em></span> 的阶</li><li>如果 <span class="math inline"><em>G</em></span> 是无限循环群，则<span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>−1</sup>, <em>a</em><sup>2</sup>, <em>a</em><sup>−2</sup>, ⋯}</span>，且对<span class="math inline"><em>k</em>, <em>l</em> ∈ <strong>Z</strong></span>，有$a^{k} = a^{l} k = l $</li><li>如果 <span class="math inline"><em>G</em></span> 是 <span class="math inline"><em>n</em></span> 阶循环群，则 <span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>, ⋯, <em>a</em><sup><em>n</em> − 1</sup>}</span>，且对<span class="math inline"><em>k</em>, <em>l</em> ∈ <strong>Z</strong></span>，有<span class="math inline"><em>a</em><sup><em>k</em></sup> = <em>a</em><sup><em>l</em></sup> ⇔ <em>k</em> ≡ <em>l</em>(&nbsp;mod &nbsp;<em>n</em>)</span></li></ul><h4 id="循环群的性质">循环群的性质</h4><ul><li><p>设 <span class="math inline"><em>p</em></span> 为素数，则 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>是 <span class="math inline"><em>p</em> − 1</span> 阶循环群。对于循环群<span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>，如果<span class="math inline"><em>ā</em></span> 是 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>的生成元，则称数 <span class="math inline"><em>a</em></span> 是 <span class="math inline"><strong>Z</strong></span> 的一个<strong>模 p原根</strong></p></li><li><p>设 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span>为循环群，则</p><ul><li>如果 <span class="math inline">|<em>G</em>| = ∞</span>，则 <span class="math inline"><em>a</em></span> 与 <span class="math inline"><em>a</em><sup>−1</sup></span> 是 <span class="math inline"><em>G</em></span> 的两个仅有的生成元</li><li>如果 <span class="math inline">|<em>G</em>| = <em>n</em></span>，则<span class="math inline"><em>G</em></span> 恰有 <span class="math inline"><em>ϕ</em>(<em>n</em>)</span> 个生成元，且 <span class="math inline"><em>a</em><sup><em>r</em></sup></span> 是 <span class="math inline"><em>G</em></span> 的生成元的充分必要条件是 <span class="math inline">(<em>n</em>, <em>r</em>) = 1</span>，其中，<span class="math inline"><em>ϕ</em>(<em>n</em>)</span> 是欧拉函数</li></ul></li><li><p>原根判定定理：设 <span class="math inline"><em>m</em> ≥ 3</span>，<span class="math inline">(<em>g</em>, <em>m</em>) = 1</span>，则 <span class="math inline"><em>g</em></span> 是模 <span class="math inline"><em>m</em></span> 的原根的充要条件是，对于 <span class="math inline"><em>φ</em>(<em>m</em>)</span> 的每个素因数 <span class="math inline"><em>p</em></span>，都有 <span class="math inline">$g^{\frac{\varphi(m)}{p}} \not \equiv 1(\bmodm)$</span></p></li><li><p>循环群的任一子群也是循环群</p></li><li><p>设 <span class="math inline">ord <em>a</em> = <em>n</em></span>，<span class="math inline"><em>r</em></span> 是任一整数。如果 <span class="math inline">(<em>n</em>, <em>r</em>) = <em>d</em></span>，则<span class="math display">⟨<em>a</em><sup><em>r</em></sup>⟩ = ⟨<em>a</em><sup><em>d</em></sup>⟩</span></p></li><li><p>设 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span>为循环群，</p><ul><li>如果 <span class="math inline">|<em>G</em>| = ∞</span>，则 <span class="math inline"><em>G</em></span> 的全部子群为<span class="math display">{⟨<em>a</em><sup><em>d</em></sup>⟩ ∣ <em>d</em> = 0, 1, 2, ⋯}</span></li><li>如果 <span class="math inline">|<em>G</em>| = <em>n</em></span>，则<span class="math inline"><em>G</em></span> 的全部子群为<span class="math display">{⟨<em>a</em><sup><em>d</em></sup>⟩ ∣ <em>d</em>为<em>n</em>的正因子}</span></li></ul></li></ul><h4 id="循环群的结构定理">循环群的结构定理</h4><p>设 <span class="math inline"><em>G</em></span> 为循环群</p><ul><li>如果 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span>是无限循环群，则 <span class="math inline"><em>G</em> ≅ (<strong>Z</strong>, +)</span></li><li>如果 <span class="math inline"><em>G</em> = ⟨<em>a</em>⟩</span> 是<span class="math inline"><em>n</em></span> 阶循环群，则 <span class="math inline"><em>G</em> ≅ (<strong>Z</strong><sub><em>n</em></sub>, +)</span></li></ul><h2 id="置换群与对称群">置换群与对称群</h2><p>前面提到非空集合的全体可逆变换关于映射的合成构成集合 <span class="math inline"><em>X</em></span> 的对称群 <span class="math inline"><em>S</em><sub><em>X</em></sub></span>，并且把 <span class="math inline"><em>S</em><sub><em>X</em></sub></span>的任一子群叫做 <span class="math inline"><em>X</em></span>的一个变换群。如果 <span class="math inline"><em>X</em></span> 是由<span class="math inline"><em>n</em></span>个元素组成的有限集合，则通常把的一个可逆变换叫做一个 <span class="math inline"><em>n</em></span> 阶置换，称 <span class="math inline"><em>S</em><sub><em>X</em></sub></span> 为 <strong>n次对称群</strong> ，并把 <span class="math inline"><em>S</em><sub><em>X</em></sub></span> 记作 <span class="math inline"><em>S</em><sub><em>n</em></sub></span>（因为集合<span class="math inline"><em>X</em></span>有哪些元素与群的特性无关），同时称 <span class="math inline"><em>S</em><sub><em>n</em></sub></span>的子群为<strong>置换群</strong> 。</p><ul><li>定理：<strong>每一个有限群都同构于一个置换群</strong></li></ul><h3 id="置换">置换</h3><p>由于集合 <span class="math inline"><em>X</em></span>的元素本身与我们所讨论的问题无关，所以可不妨记 <span class="math display"><em>X</em> = {1, 2, 3, ⋯, <em>n</em>}</span></p><p>设 <span class="math inline"><em>σ</em></span> 为 <span class="math inline"><em>X</em></span> 的任一置换，如果 <span class="math inline"><em>σ</em></span> 把 <span class="math inline">1</span> 映成 <span class="math inline"><em>k</em><sub>1</sub></span>，<span class="math inline">2</span> 映成 <span class="math inline"><em>k</em><sub>2</sub></span>，……，<span class="math inline"><em>n</em></span> 映成 <span class="math inline"><em>k</em><sub><em>n</em></sub></span>，则可以把这个置换记作<span class="math display">$$\sigma=\left(\begin{array}{ccccc}1 &amp; 2 &amp; 3 &amp; \cdots &amp; n \\k_{1} &amp; k_{2} &amp; k_{3} &amp; \cdots &amp; k_{n}\end{array}\right)$$</span></p><p>如果固定第一行元素的次序，则第二行就是 <span class="math inline">1, 2, ⋯, <em>n</em></span> 的一个排列，且<strong>每一个置换都唯一对应了一个这样的排列</strong> 。反之，每一个<span class="math inline"><em>n</em></span>阶排列也可按上式得到唯一的一个 <span class="math inline"><em>n</em></span> 阶置换 。由于 <span class="math inline"><em>n</em></span> 个数共有 <span class="math inline"><em>n</em>!</span> 个 <span class="math inline"><em>n</em></span> 阶排列，所以 <span class="math inline"><em>n</em></span> 个元素的集合共有 <span class="math inline"><em>n</em>!</span> 个 <span class="math inline"><em>n</em></span> 阶置换。换句话说，<span class="math inline"><em>n</em></span> 次对称群 <span class="math inline"><em>S</em><sub><em>n</em></sub></span> 的阶是 <span class="math inline"><em>n</em>!</span>，即 <span class="math inline">|<em>S</em><sub><em>n</em></sub>| = <em>n</em>!</span>。</p><h4 id="置换的合成">置换的合成</h4><p>置换的乘法习惯上总是按<strong>从右到左</strong>的顺序进行的。在本教材中，总是按从右到左的顺序计算置换的乘法。</p><p>两个置换 <span class="math inline"><em>σ</em>, <em>τ</em></span>的乘积 <span class="math inline"><em>σ</em> ⋅ <em>τ</em></span>是按通常映射合成的法则进行的，即 <span class="math display">(<em>σ</em> ⋅ <em>τ</em>)(<em>i</em>) = <em>σ</em>(<em>τ</em>(<em>i</em>)),  <em>i</em> = 1, 2, ⋯, <em>n</em></span></p><p>它是先用 <span class="math inline"><em>τ</em></span> 作用于 <span class="math inline"><em>i</em></span>，再用 <span class="math inline"><em>σ</em></span> 作用于 <span class="math inline"><em>τ</em>(<em>i</em>)</span></p><ul><li>当 <span class="math inline"><em>n</em> ≥ 3</span> 时，<span class="math inline"><em>S</em><sub><em>n</em></sub></span>都不是交换群</li></ul><h4 id="置换的性质">置换的性质</h4><p>设置换 <span class="math display">$$\tau=\left(\begin{array}{cccc}1 &amp; 2 &amp; \cdots &amp; n \\k_{1} &amp; k_{2} &amp; \cdots &amp; k_{n}\end{array}\right)$$</span></p><p>则对任一 <span class="math inline"><em>n</em></span> 阶置换 <span class="math inline"><em>σ</em></span>， <span class="math display">$$\sigma \tau \sigma^{-1}=\left(\begin{array}{cccc}\sigma(1) &amp; \sigma(2) &amp; \cdots &amp; \sigma(n) \\\sigma\left(k_{1}\right) &amp; \sigma\left(k_{2}\right) &amp; \cdots&amp; \sigma\left(k_{n}\right)\end{array}\right)$$</span></p><h3 id="轮换">轮换</h3><p>设 <span class="math inline"><em>σ</em></span> 是一个 <span class="math inline"><em>n</em></span> 阶置换，如果存在 <span class="math inline">1</span> 到 <span class="math inline"><em>n</em></span> 中的 <span class="math inline"><em>r</em></span> 个不同的数 <span class="math inline"><em>i</em><sub>1</sub>, <em>i</em><sub>2</sub>, ⋯, <em>i</em><sub><em>r</em></sub></span>，使<span class="math display"><em>σ</em>(<em>i</em><sub>1</sub>) = <em>i</em><sub>2</sub>, <em>σ</em>(<em>i</em><sub>2</sub>) = <em>i</em><sub>3</sub>, ⋯, <em>σ</em>(<em>i</em><sub><em>r</em> − 1</sub>) = <em>i</em><sub><em>r</em></sub>, <em>σ</em>(<em>i</em><sub><em>r</em></sub>) = <em>i</em><sub>1</sub></span></p><p>并且 <span class="math inline"><em>σ</em></span>保持其余的元素不变，则称 <span class="math inline"><em>σ</em></span>是一个长度为 <span class="math inline"><em>r</em></span> 的<strong>轮换</strong> ，简称 <span class="math inline"><em>r</em></span>轮换，记作 <span class="math display"><em>σ</em> = (<em>i</em><sub>1</sub><em>i</em><sub>2</sub>⋯<em>i</em><sub><em>r</em></sub>)</span></p><ul><li>2 轮换称为 <strong>对换</strong></li><li>1 轮换就是 <strong>恒等置换</strong>，并且显然有 <span class="math inline">(1) = (2) = ⋯ = (<em>n</em>)</span></li><li>轮换的表示一般不是唯一的 <span class="math inline">.</span>例如，置换 <span class="math display">$$  \sigma=\left(\begin{array}{ccccccc}  1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 \\\  2 &amp; 4 &amp; 3 &amp; 6 &amp; 5 &amp; 1 &amp; 7  \end{array}\right)  $$</span> 可分别表示为 <span class="math display">$$  \begin{aligned}  \sigma &amp; =\left(\begin{array}{llll} 1 &amp; 2 &amp; 4 &amp; 6\end{array}\right) \\  &amp; =\left(\begin{array}{llll} 2 &amp; 4 &amp; 6 &amp; 1\end{array}\right) \\  &amp; =\left(\begin{array}{llll} 4 &amp; 6 &amp; 1 &amp; 2\end{array}\right) \\  &amp; =\left(\begin{array}{llll} 6 &amp; 1 &amp; 2 &amp; 4\end{array}\right) \\  \end{aligned}  $$</span></li></ul><h4 id="轮换的性质">轮换的性质</h4><ul><li><p>设 <span class="math inline"><em>σ</em> = (<em>i</em><sub>1</sub><em>i</em><sub>2</sub>⋯<em>i</em><sub><em>r</em></sub>)</span>与 <span class="math inline"><em>τ</em> = (<em>j</em><sub>1</sub><em>j</em><sub>2</sub>⋯<em>j</em><sub><em>s</em></sub>)</span>是两个轮换，如果 <span class="math display"><em>i</em><sub><em>k</em></sub> ≠ <em>j</em><sub><em>l</em></sub>,  <em>k</em> = 1, 2, ⋯, <em>r</em>; <em>l</em> = 1, 2, ⋯, <em>s</em></span></p><p>则称 <span class="math inline"><em>σ</em></span> 与 <span class="math inline"><em>τ</em></span> 为两个 <strong>不相交</strong>的轮换</p><ul><li>任何两个不相交轮换的乘积是可以交换的</li><li>一个置换不一定就是轮换，但是每一个置换可表为一些不相交轮换的乘积</li><li>将一个置换分解为不相交轮换的乘积，如果不考虑因子的次序和乘积中 <span class="math inline">1</span> 轮换的个数，则这个分解式是唯一的</li></ul></li><li><p>对于轮换的乘积，容易证明下面一些有用的等式： <span class="math display">$$  \begin{array}{l}  (k\ l)(k\ a \cdots b)(l\ c \cdots d)=(k\ a \cdots b\ l\ c \cdots d) \\  (k\ l)(k\ a \cdots b\ l\ c \cdots d)=(k\ a \cdots b)(l\ c \cdots d)\\  (k\ c \cdots d)(k\ a \cdots b)=(k\ a \cdots b\ c \cdots d)\\  (k\ l\ c \cdots d)(k\ l\ a \cdots b)=(k\ c \cdots d)(l\ a \cdots b) \\  (l\ k\ c \cdots d)(k\ l\ a \cdots b)=(k)(l\ a \cdots b\ c \cdots d) \\  \end{array}  $$</span></p><ul><li>其中 <span class="math inline"><em>a</em>, ⋯, <em>b</em>, <em>c</em>, ⋯, <em>d</em>, <em>k</em>, <em>l</em></span>为互不相同的正整数</li><li>注意置换是从右到左</li></ul></li><li><p>如果 <span class="math inline"><em>σ</em></span> 是一个 <span class="math inline"><em>r</em></span> 轮换，则 <span class="math inline">ord <em>σ</em> = <em>r</em></span></p></li><li><p>如果 <span class="math inline"><em>σ</em></span>是一些不相交轮换的乘积 <span class="math display"><em>σ</em> = <em>σ</em><sub>1</sub><em>σ</em><sub>2</sub>⋯<em>σ</em><sub><em>s</em></sub></span></p><p>其中 <span class="math inline"><em>σ</em><sub><em>i</em></sub></span>是 <span class="math inline"><em>r</em><sub><em>i</em></sub></span>轮换，则 <span class="math inline">ord <em>σ</em> = [<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, ⋯, <em>r</em><sub><em>s</em></sub>]</span></p></li><li><p>每个置换都可表为对换的乘积</p></li><li><p>将一个置换表为对换的乘积，表法一般不唯一</p></li><li><p>将一个置换表为对换的乘积，所用对换个数的奇偶性是唯一的。可表成偶数个对换的乘积的置换叫<strong>偶置换</strong>，可表成奇数个对换的乘积的置换叫<strong>奇置换</strong></p><ul><li>任何两个偶（奇）置换之积是偶置换</li><li>一个偶置换与一个奇置换之积是奇置换</li><li>一个偶（奇）置换的逆置换仍是一个偶（奇）置换</li><li>当 <span class="math inline"><em>n</em> &gt; 1</span> 时，在全体<span class="math inline"><em>n</em></span> 阶置换中，奇置换与偶置换各有<span class="math inline">$\frac{n!}{2}$</span> 个</li><li>在 <span class="math inline"><em>S</em><sub><em>n</em></sub></span>中，全体偶置换构成 <span class="math inline"><em>S</em><sub><em>n</em></sub></span> 的子群，称为<strong>n 次交代群</strong> ，记作 <span class="math inline"><em>A</em><sub><em>n</em></sub></span></li></ul></li></ul><h2 id="子群的陪集">子群的陪集</h2><h3 id="子集的运算">子集的运算</h3><h4 id="乘积">乘积</h4><p>设 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 是群 <span class="math inline"><em>G</em></span> 的两个非空子集，称集合 <span class="math display"><em>A</em><em>B</em> = {<em>a</em><em>b</em> ∣ <em>a</em> ∈ <em>A</em>, <em>b</em> ∈ <em>B</em>}</span></p><p>为群的子集 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 的 <strong>乘积</strong> 。 如果<span class="math inline"><em>g</em></span> 为群 <span class="math inline"><em>G</em></span> 的一个元素，<span class="math inline"><em>A</em> = {<em>g</em>}</span>，则 <span class="math inline"><em>A</em><em>B</em></span> 与 <span class="math inline"><em>B</em><em>A</em></span> 分别简记为 <span class="math display"><em>g</em><em>B</em> = {<em>g</em><em>b</em> ∣ <em>b</em> ∈ <em>B</em>}  和  <em>B</em><em>g</em> = {<em>b</em><em>g</em> ∣ <em>b</em> ∈ <em>B</em>}</span></p><h4 id="和">和</h4><p>当 <span class="math inline"><em>G</em></span>为加群时，上述记号应相应地改为 <span class="math display">$$\begin{aligned}A+B &amp; =\{a+b \mid a \in A,b \in B\},\\g+A &amp; =\{g+a \mid a \in A\},\\A+g &amp; =\{a+g \mid a \in A\}\end{aligned}$$</span></p><p>并称 <span class="math inline"><em>A</em> + <em>B</em></span> 为<span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 的<strong>和</strong></p><h4 id="简单性质">简单性质</h4><ul><li>“和”有交换律 <span class="math display"><em>A</em> + <em>B</em> = <em>B</em> + <em>A</em>,  <em>g</em> + <em>A</em> = <em>A</em> + <em>g</em></span></li><li>当群 <span class="math inline"><em>G</em></span> 不是交换群时，<span class="math inline"><em>A</em><em>B</em></span> 与 <span class="math inline"><em>B</em><em>A</em></span> 一般是不相同的；即使<span class="math inline"><em>A</em><em>B</em> = <em>B</em><em>A</em></span>，也并不意味着对任意的<span class="math inline"><em>a</em> ∈ <em>A</em></span>，<span class="math inline"><em>b</em> ∈ <em>B</em></span>，一定有 <span class="math inline"><em>a</em><em>b</em> = <em>b</em><em>a</em></span>，<span class="math inline"><em>A</em><em>B</em> = <em>B</em><em>A</em></span>的意思是，对任意的 <span class="math inline"><em>a</em> ∈ <em>A</em>, <em>b</em> ∈ <em>B</em></span>，存在<span class="math inline"><em>a</em><sup>′</sup> ∈ <em>A</em>, <em>b</em><sup>′</sup> ∈ <em>B</em></span>，使<span class="math inline"><em>a</em><em>b</em> = <em>b</em><sup>′</sup><em>a</em><sup>′</sup></span></li><li>由 <span class="math inline"><em>A</em><em>B</em> = <em>A</em><em>C</em></span>，一般不能推出<span class="math inline"><em>B</em> = <em>C</em></span></li><li>设 <span class="math inline"><em>A</em>, <em>B</em>, <em>C</em></span> 是群 <span class="math inline"><em>G</em></span> 的非空子集，<span class="math inline"><em>g</em></span> 是群 <span class="math inline"><em>G</em></span> 的一个元素，则<ul><li><span class="math inline"><em>A</em>(<em>B</em><em>C</em>) = (<em>A</em><em>B</em>)<em>C</em></span></li><li>如果 <span class="math inline"><em>g</em><em>A</em> = <em>g</em><em>B</em></span>或 <span class="math inline"><em>A</em><em>g</em> = <em>B</em><em>g</em></span>，则<span class="math inline"><em>A</em> = <em>B</em></span></li><li>如果 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的子群，则 <span class="math inline"><em>H</em> ⋅ <em>H</em> = <em>H</em></span></li><li>如果 <span class="math inline"><em>A</em>, <em>B</em></span> 是群<span class="math inline"><em>G</em></span> 的两个子群，则 <span class="math inline"><em>A</em><em>B</em></span> 也是群 <span class="math inline"><em>G</em></span> 的子群的充分必要条件是 <span class="math inline"><em>A</em><em>B</em> = <em>B</em><em>A</em></span></li></ul></li></ul><h3 id="陪集">陪集</h3><h4 id="陪集的定义">陪集的定义</h4><p>设 <span class="math inline"><em>G</em></span> 是群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群。对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，群 <span class="math inline"><em>G</em></span> 的子集 <span class="math display"><em>a</em><em>H</em> = {<em>a</em><em>h</em> ∣ <em>h</em> ∈ <em>H</em>}  与<em>H</em><em>a</em> = {<em>h</em><em>a</em> ∣ <em>h</em> ∈ <em>H</em>}</span></p><p>分别称为 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的 <strong>左陪集</strong> 和<strong>右陪集</strong></p><ul><li><span class="math inline"><em>H</em></span> 的一个陪集<strong>一般</strong> 不是 <span class="math inline"><em>G</em></span>的子群</li><li><span class="math inline"><em>G</em></span> 的两个不同的元素<strong>可能</strong> 生成 <span class="math inline"><em>H</em></span>的同一个左陪集</li><li><span class="math inline"><em>H</em></span> 的一个左陪集 <span class="math inline"><em>a</em><em>H</em></span> <strong>一般</strong>不等于相应的右陪集 <span class="math inline"><em>H</em><em>a</em></span></li></ul><h4 id="陪集的性质">陪集的性质</h4><p>设 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的子群，<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span>，则</p><ul><li><span class="math inline"><em>a</em> ∈ <em>a</em><em>H</em></span></li><li><span class="math inline"><em>a</em><em>H</em> = <em>H</em></span>的充分必要条件是 <span class="math inline"><em>a</em> ∈ <em>H</em></span></li><li><span class="math inline"><em>a</em><em>H</em></span>为子群的充分必要条件是 <span class="math inline"><em>a</em> ∈ <em>H</em></span></li><li><span class="math inline"><em>a</em><em>H</em> = <em>b</em><em>H</em></span>的充分必要条件是 <span class="math inline"><em>a</em><sup>−1</sup><em>b</em> ∈ <em>H</em></span></li><li><span class="math inline"><em>a</em><em>H</em></span> 与 <span class="math inline"><em>b</em><em>H</em></span>或者完全相同，或者无公共元素</li><li><span class="math inline">|<em>a</em><em>H</em>| = |<em>b</em><em>H</em>|</span></li></ul><p>由此定理可以知道，群 <span class="math inline"><em>G</em></span>可表示成子群 <span class="math inline"><em>H</em></span>的一些互不相交的左陪集之并。因此，群 <span class="math inline"><em>G</em></span> 的子群 <span class="math inline"><em>H</em></span> 的全体左陪集的集合组成群 <span class="math inline"><em>G</em></span> 的一个分类，即 <span class="math display"><em>G</em> = ⋃<sub><em>g</em><sub><em>i</em></sub> ∈ <em>G</em></sub><em>g</em><sub><em>i</em></sub><em>H</em></span></p><p>其中 <span class="math inline"><em>g</em><sub><em>i</em></sub></span>取遍 <span class="math inline"><em>H</em></span>的不同陪集的代表元素。特别地，如果 <span class="math inline"><em>G</em></span> 为有限群，则 <span class="math display">$$|G|=\sum_{i=1}^{t}\left|g_{i} H\right|=\sum_{i=1}^{t}|H|=t|H|$$</span></p><p>其中 <span class="math inline"><em>t</em></span> 为 <span class="math inline"><em>H</em></span> 的不同左陪集的个数</p><h4 id="左陪集与右陪集">左陪集与右陪集</h4><p>相应的结论对右陪集也成立，特别地： <span class="math display"><em>H</em><em>a</em> = <em>H</em><em>b</em> ⇔ <em>b</em><em>a</em><sup>−1</sup> ∈ <em>H</em></span></p><p>用 <span class="math inline"><em>G</em>/<em>H</em></span> 与 <span class="math inline"><em>H</em> ∖ <em>G</em></span> 分别表示 <span class="math inline"><em>H</em></span>的全体左陪集和全体右陪集组成的集合，即 <span class="math display">$$\begin{aligned}G / H=\{g H \mid g \in G\} \\H \backslash G=\{H g \mid g \in G\}\end{aligned}$$</span></p><p>则两者间有下述关系 <span class="math display">$$\begin{aligned}\phi: \quad G / H &amp; \longrightarrow H \backslash G,\\a H &amp; \longmapsto H a^{-1}\end{aligned}$$</span></p><p>是 <span class="math inline"><em>G</em>/<em>H</em></span> 到 <span class="math inline"><em>H</em> ∖ <em>G</em></span>的<strong>一一对应</strong></p><h3 id="拉格朗日定理">拉格朗日定理</h3><ul><li><p>设 <span class="math inline"><em>G</em></span> 是群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群。称子群 <span class="math inline"><em>H</em></span> 在群 <span class="math inline"><em>G</em></span>中的左陪集或右陪集的个数（有限或无限）为 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的 <strong>指数</strong>，记作<span class="math inline">[<em>G</em> : <em>H</em>]</span></p></li><li><p><strong>拉格朗日定理</strong>：设 <span class="math inline"><em>G</em></span> 是一个有限群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，则 <span class="math display">|<em>G</em>| = |<em>H</em>|[<em>G</em> : <em>H</em>]</span></p><ul><li>拉格朗日定理说明，有限群 <span class="math inline"><em>G</em></span>的子群 <span class="math inline"><em>H</em></span> 的阶数与它在 <span class="math inline"><em>G</em></span> 中的指数，都是群 <span class="math inline"><em>G</em></span> 的阶数的因子<br></li><li>设 <span class="math inline"><em>G</em></span> 是有限群，则 <span class="math inline"><em>G</em></span> 中每一个元素的阶都是 <span class="math inline">|<em>G</em>|</span> 的因子</li><li>设 <span class="math inline"><em>G</em></span> 为有限群，<span class="math inline">|<em>G</em>| = <em>n</em></span>，则对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em><sup><em>n</em></sup> = <em>e</em></span><ul><li>应用到模 <span class="math inline"><em>p</em></span> 单位群 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub><sup>*</sup></span>（<span class="math inline"><em>p</em></span> 是素数），可以得到<strong>费马小定理</strong>：设 <span class="math inline"><em>p</em></span> 为素数，则对任意一个与 <span class="math inline"><em>p</em></span> 互素的整数 <span class="math inline"><em>a</em></span>，有 <span class="math display"><em>a</em><sup><em>p</em> − 1</sup> ≡ 1  (&nbsp;mod &nbsp;<em>p</em>)</span></li></ul></li><li>应用拉格朗日定理，可以推测在一个有限群中，可能有怎样阶数的子群与元素，只是一种可能性，不能仅仅依据这种可能性，就断定这样的子群或元素一定存在</li></ul></li></ul><h3 id="各阶群的结构">各阶群的结构</h3><ul><li>一阶群是循环群：<span class="math inline"><em>G</em> = {<em>e</em>}</span></li><li>二阶群是循环群：<span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>} = ⟨<em>a</em>⟩</span></li><li>三阶群是循环群：<span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>} = ⟨<em>a</em>⟩</span></li><li>四阶群是循环群或克莱因四元群：<ul><li><span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>, <em>a</em><sup>3</sup>} = ⟨<em>a</em>⟩</span></li><li><span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>b</em>, <em>a</em><em>b</em>}</span>，<span class="math inline"><em>a</em><em>b</em> = <em>b</em><em>a</em></span>，<span class="math inline"><em>a</em><sup>2</sup> = <em>b</em><sup>2</sup> = <em>e</em></span></li></ul></li><li>五阶群是循环群：<span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>, <em>a</em><sup>3</sup>, <em>a</em><sup>4</sup>} = ⟨<em>a</em>⟩</span></li><li>六阶群是循环群或三次对称群<ul><li><span class="math inline"><em>G</em> = {<em>e</em>, <em>a</em>, <em>a</em><sup>2</sup>, <em>a</em><sup>3</sup>, <em>a</em><sup>4</sup>, <em>a</em><sup>5</sup>} = ⟨<em>a</em>⟩</span></li><li><span class="math inline"><em>G</em> ≅ <em>S</em><sub>3</sub> = {(1), (1&nbsp;2), (1&nbsp;3), (2&nbsp;3), (1&nbsp;2&nbsp;3), (1&nbsp;3&nbsp;2)}</span></li></ul></li></ul><h2 id="正规子群与商群">正规子群与商群</h2><h3 id="正规子群">正规子群</h3><h4 id="正规子群的定义">正规子群的定义</h4><p>设 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的子群，如果对每个 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，都有 <span class="math inline"><em>a</em><em>H</em> = <em>H</em><em>a</em></span>，则称<span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的一个 <strong>正规子群</strong>或 <strong>不变子群</strong> ，记作 <span class="math inline"><em>H</em> ⊲ <em>G</em></span></p><ul><li>条件 <span class="math inline"><em>a</em><em>H</em> = <em>H</em><em>a</em></span>仅仅表示两个集合 <span class="math inline"><em>a</em><em>H</em></span>与 <span class="math inline"><em>H</em><em>a</em></span>相等，即对任意的 <span class="math inline"><em>h</em> ∈ <em>H</em></span>，存在 <span class="math inline"><em>h</em><sup>′</sup> ∈ <em>H</em></span>，使 <span class="math inline"><em>a</em><em>h</em> = <em>h</em><sup>′</sup><em>a</em></span>；不可推出<span class="math inline"><em>a</em><em>h</em> = <em>h</em><em>a</em></span>对 <span class="math inline"><em>H</em></span> 中所有的元素 <span class="math inline"><em>h</em></span> 都成立</li><li>群 <span class="math inline"><em>G</em></span> 的单位元群 <span class="math inline">{<em>e</em>}</span> 和群 <span class="math inline"><em>G</em></span> 本身都是 <span class="math inline"><em>G</em></span> 的正规子群，这两个正规子群称为<span class="math inline"><em>G</em></span> 的<strong>平凡正规子群</strong></li><li>如果群 <span class="math inline"><em>G</em></span>只有平凡的正规子群，且 <span class="math inline"><em>G</em> ≠ <em>e</em></span>，则称 <span class="math inline"><em>G</em></span> 为 <strong>单群</strong></li></ul><h4 id="正规子群的性质">正规子群的性质</h4><ul><li>如果 <span class="math inline"><em>G</em></span> 是<strong>交换群</strong> ，则 <span class="math inline"><em>G</em></span>的一切子群都是 <span class="math inline"><em>G</em></span>的正规子群</li><li>设 <span class="math inline"><em>H</em>, <em>K</em></span> 都是<span class="math inline"><em>G</em></span> 的子群，如果 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群且 <span class="math inline"><em>H</em> ⊆ <em>K</em></span>，则 <span class="math inline"><em>H</em></span> 也是 <span class="math inline"><em>K</em></span> 的正规子群</li><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，如果 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的指数 <span class="math inline">[<em>G</em> : <em>H</em>] = 2</span>，则 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群</li><li>若 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>K</em></span> 的正规子群，<span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，<span class="math inline"><em>H</em></span> 不一定是 <span class="math inline"><em>G</em></span>的正规子群（正规子群没有传递性）</li></ul><h4 id="正规子群的判定">正规子群的判定</h4><ul><li>设 <span class="math inline"><em>G</em></span> 是群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，则下列四个条件等价：<ul><li><span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群</li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em><em>H</em><em>a</em><sup>−1</sup> = <em>H</em></span></li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，有 <span class="math inline"><em>a</em><em>H</em><em>a</em><sup>−1</sup> ⊆ <em>H</em></span></li><li>对任意的 <span class="math inline"><em>a</em> ∈ <em>G</em></span>，<span class="math inline"><em>h</em> ∈ <em>H</em></span>，有 <span class="math inline"><em>a</em><em>h</em><em>a</em><sup>−1</sup> ∈ <em>H</em></span></li></ul></li><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em><sub>1</sub></span>，<span class="math inline"><em>H</em><sub>2</sub></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，则 <span class="math display"><em>H</em><sub>1</sub> ∩ <em>H</em><sub>2</sub>与<em>H</em><sub>1</sub><em>H</em><sub>2</sub></span>都是 <span class="math inline"><em>G</em></span> 的正规子群<ul><li>事实上，前面提到，两个子群的交一定是子群，而两个子群的合成要是子群的充分必要条件是可交换。而只要其中一个子群是正规子群，那么就是可交换的</li></ul></li></ul><h3 id="商群">商群</h3><h4 id="陪集的乘法">陪集的乘法</h4><p>正规子群的基本特点是：它的每一个左陪集与相应的右陪集完全一致。因此，对于群<span class="math inline"><em>G</em></span> 的正规子群 <span class="math inline"><em>H</em></span>，可不必区分它的左陪集 <span class="math inline"><em>a</em><em>H</em></span> 与右陪集 <span class="math inline"><em>H</em><em>a</em></span>，而直接称 <span class="math inline"><em>a</em><em>H</em></span> 或 <span class="math inline"><em>H</em><em>a</em></span>为它的一个<strong>陪集</strong> 。用 <span class="math inline"><em>G</em>/<em>H</em></span>表示它的所有陪集组成的集合，即 <span class="math display"><em>G</em>/<em>H</em> = {<em>a</em><em>H</em> ∣ <em>a</em> ∈ <em>G</em>}</span></p><p>下面规定 <span class="math inline"><em>G</em>/<em>H</em></span>的运算，以使 <span class="math inline"><em>G</em>/<em>H</em></span>关于给定的运算构成群。</p><p>对任意的 <span class="math inline"><em>a</em><em>H</em>, <em>b</em><em>H</em> ∈ <em>G</em>/<em>H</em></span>，规定：<span class="math display">(<em>a</em><em>H</em>) ⋅ (<em>b</em><em>H</em>) = (<em>a</em><em>b</em>)<em>H</em></span></p><p>设 <span class="math inline"><em>a</em><sup>′</sup><em>H</em> = <em>a</em><em>H</em></span>，<span class="math inline"><em>b</em><sup>′</sup><em>H</em> = <em>b</em><em>H</em></span>，则<span class="math display">$$\begin{aligned}a^{\prime} H \cdot b^{\prime} H &amp; =\left(a^{\prime}b^{\prime}\right) H=a^{\prime}\left(b^{\prime} H\right)=a^{\prime}(bH)=a^{\prime}(H b) \\&amp; =\left(a^{\prime} H\right) b=(a H) b=a(H b)=(a b) H\\\&amp; =a H \cdot b H\end{aligned}$$</span></p><p>所以 <span class="math inline"><em>H</em></span> 的任意两个陪集 <span class="math inline"><em>a</em><em>H</em></span> 与 <span class="math inline"><em>b</em><em>H</em></span>的乘积是唯一确定的，并且与 <span class="math inline"><em>a</em></span>与 <span class="math inline"><em>b</em></span>的选择无关，所以上述乘法是 <span class="math inline"><em>G</em>/<em>H</em></span> 的一个代数运算。</p><h4 id="商群的定义">商群的定义</h4><p>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群。<span class="math inline"><em>H</em></span> 的所有陪集 <span class="math inline"><em>G</em>/<em>H</em></span> 关于陪集的乘法 <span class="math inline"><em>a</em><em>H</em> ⋅ <em>b</em><em>H</em> = (<em>a</em><em>b</em>)<em>H</em></span>构成的群称为群 <span class="math inline"><em>G</em></span> 关于子群<span class="math inline"><em>H</em></span>的<strong>商群</strong>，仍记作 <span class="math inline"><em>G</em>/<em>H</em></span>，即 <span class="math display"><em>G</em>/<em>H</em> = {<em>a</em><em>H</em> ∣ <em>a</em> ∈ <em>G</em>}</span></p><ul><li>商群 <span class="math inline"><em>G</em>/<em>H</em></span>的单位元是 <span class="math inline"><em>e</em><em>H</em>( = <em>H</em>)</span></li><li><span class="math inline"><em>a</em><em>H</em></span> 在 <span class="math inline"><em>G</em>/<em>H</em></span> 中的逆元是 <span class="math inline"><em>a</em><sup>−1</sup><em>H</em></span></li></ul><h4 id="商群的性质">商群的性质</h4><ul><li>设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的任一子群。如果 <span class="math inline"><em>G</em></span> 是交换群，则商群 <span class="math inline"><em>G</em>/<em>H</em></span> 也是交换群。由于 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的指数<span class="math inline">[<em>G</em> : <em>H</em>]</span> 就是 <span class="math inline"><em>H</em></span> 在 <span class="math inline"><em>G</em></span> 中的陪集的个数，所以 <span class="math inline">|<em>G</em>/<em>H</em>| = [<em>G</em> : <em>H</em>]</span>。特别地，当<span class="math inline"><em>G</em></span> 是有限群时 <span class="math display">$$  |G / H|=[G:H]=\frac{|G|}{|H|}  $$</span><ul><li>有限群 <span class="math inline"><em>G</em></span> 的商群的阶是群<span class="math inline"><em>G</em></span> 的阶数的因子。</li></ul></li><li><span class="math inline"><strong>Z</strong></span> 关于 <span class="math inline">⟨<em>m</em>⟩</span> 的商群 <span class="math inline"><strong>Z</strong>/⟨<em>m</em>⟩</span> 就是 <span class="math inline"><strong>Z</strong></span> 关于模 <span class="math inline"><em>m</em></span> 的剩余类加群 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>，因此有<span class="math display"><strong>Z</strong>/⟨<em>m</em>⟩ = <strong>Z</strong><sub><em>m</em></sub></span></li></ul><h2 id="群的同态与同态基本定理">群的同态与同态基本定理</h2><h3 id="群同态">群同态</h3><h4 id="群同态定义">群同态定义</h4><p>设 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 是两个群，<span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的映射。如果对任意的<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>G</em></span> 有<span class="math display"><em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span></p><p>则称 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的一个<strong>同态映射</strong> ，简称<strong>同态</strong></p><ul><li><p>当同态映射 <span class="math inline"><em>ϕ</em></span>是满射时，称 <span class="math inline"><em>ϕ</em></span> 为群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>满同态</strong></p></li><li><p>当同态映射 <span class="math inline"><em>ϕ</em></span>是单射时，称 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>单同态</strong></p></li><li><p>群的同构映射一定是既单且满的同态映射；反之，当群 <span class="math inline"><em>G</em></span> 到群 <span class="math inline"><em>G</em><sup>′</sup></span> 的同态映射 <span class="math inline"><em>ϕ</em></span> 既是单同态又是满同态时，<span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的同构映射</p></li><li><p>在上式中，虽然用同一个记号“<span class="math inline">⋅</span>”来表示群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span>的运算，但这不表示等式两边的运算 <span class="math inline"><em>a</em><em>b</em></span> 与 <span class="math inline"><em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span>是一样的，而是分别表示群 <span class="math inline"><em>G</em></span>与群 <span class="math inline"><em>G</em><sup>′</sup></span>的运算。</p></li><li><p><strong>自然同态</strong>：设 <span class="math inline"><em>G</em></span> 为群，<span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，对商群 <span class="math inline"><em>G</em>/<em>H</em></span>，令 <span class="math display">$$  \begin{aligned}  \eta:G &amp; \longrightarrow G / H,\\  a &amp; \longrightarrow a H,  \end{aligned}  $$</span></p><p>则 <span class="math inline"><em>η</em></span> 是满映射，且对任意<span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em> ∈ <em>G</em></span>，有 <span class="math display"><em>η</em>(<em>a</em><em>b</em>) = (<em>a</em><em>b</em>)<em>H</em> = <em>a</em><em>H</em> ⋅ <em>b</em><em>H</em> = <em>η</em>(<em>a</em>)<em>η</em>(<em>b</em>)</span></p><p>所以 <span class="math inline"><em>η</em></span> 是 <span class="math inline"><em>G</em></span> 到它的商群 <span class="math inline"><em>G</em>/<em>H</em></span>的同态映射。通常称这样的同态映射为自然同态。</p></li></ul><h4 id="群同态的性质">群同态的性质</h4><p>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到群 <span class="math inline"><em>G</em><sup>′</sup></span> 的同态映射，<span class="math inline"><em>e</em></span> 与 <span class="math inline"><em>e</em><sup>′</sup></span> 分别是 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 的单位元，<span class="math inline"><em>a</em> ∈ <em>G</em></span>，则</p><ul><li><span class="math inline"><em>ϕ</em></span> 将 <span class="math inline"><em>G</em></span> 的单位元映到 <span class="math inline"><em>G</em><sup>′</sup></span> 的单位元，即 <span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span></li><li><span class="math inline"><em>ϕ</em></span> 将 <span class="math inline"><em>a</em></span> 的逆元映到 <span class="math inline"><em>ϕ</em>(<em>a</em>)</span> 的逆元，即 <span class="math inline"><em>ϕ</em>(<em>a</em><sup>−1</sup>) = (<em>ϕ</em>(<em>a</em>))<sup>−1</sup></span></li><li>设 <span class="math inline"><em>n</em></span> 是任一整数，则 <span class="math inline"><em>ϕ</em>(<em>a</em><sup><em>n</em></sup>) = (<em>ϕ</em>(<em>a</em>))<sup><em>n</em></sup></span></li><li>如果 <span class="math inline">ord <em>a</em></span> 有限，则 <span class="math inline">ord <em>ϕ</em>(<em>a</em>) ∣ ord <em>a</em></span></li></ul><h4 id="象和原象">象和原象</h4><ul><li><p>设 <span class="math inline"><em>ϕ</em></span> 为群 <span class="math inline"><em>G</em></span> 到群 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>映射</strong> ，<span class="math inline"><em>A</em>, <em>B</em></span> 分别为 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 的非空子集，记 <span class="math display">$$  \begin{aligned}  \phi(A) &amp; =\{\phi(x) \mid x \in A\},\\  \phi^{-1}(B) &amp; =\{x \in G \mid \phi(x) \in B\}  \end{aligned}  $$</span></p><p>则 <span class="math inline"><em>ϕ</em>(<em>A</em>)</span> 与 <span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>B</em>)</span> 分别是<span class="math inline"><em>G</em><sup>′</sup></span> 与 <span class="math inline"><em>G</em></span> 的非空子集。<span class="math inline"><em>ϕ</em>(<em>A</em>)</span> 与 <span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>B</em>)</span>分别称为子集 <span class="math inline"><em>A</em></span> 与 <span class="math inline"><em>B</em></span> 在 <span class="math inline"><em>ϕ</em></span> 下的<strong>象</strong>与<strong>原象</strong></p><ul><li>注意，<span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>B</em>)</span>仅仅是一个集合的记号，并不表示映射 <span class="math inline"><em>ϕ</em></span> 是可逆的</li></ul></li><li><p>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span>的<strong>同态映射</strong> ，<span class="math inline"><em>H</em></span> 与 <span class="math inline"><em>K</em></span> 分别是 <span class="math inline"><em>G</em></span> 与 <span class="math inline"><em>G</em><sup>′</sup></span> 的子群，则</p><ul><li><span class="math inline"><em>ϕ</em>(<em>H</em>)</span> 是 <span class="math inline"><em>G</em><sup>′</sup></span> 的子群</li><li><span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>K</em>)</span>是 <span class="math inline"><em>G</em></span> 的子群</li><li>如果 <span class="math inline"><em>H</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，则 <span class="math inline"><em>ϕ</em>(<em>H</em>)</span> 是 <span class="math inline"><em>ϕ</em>(<em>G</em>)</span> 的正规子群</li><li>如果 <span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em><sup>′</sup></span> 的正规子群，则 <span class="math inline"><em>ϕ</em><sup>−1</sup>(<em>K</em>)</span> 是 <span class="math inline"><em>G</em></span> 的正规子群</li></ul></li></ul><h4 id="核">核</h4><p>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的同态映射，<span class="math inline"><em>e</em><sup>′</sup></span> 是 <span class="math inline"><em>G</em><sup>′</sup></span> 的单位元，则称 <span class="math inline"><em>e</em><sup>′</sup></span> 在 <span class="math inline"><em>G</em></span> 中的原象 <span class="math display"><em>ϕ</em><sup>−1</sup>({<em>e</em><sup>′</sup>}) = {<em>a</em> ∈ <em>G</em> ∣ <em>ϕ</em>(<em>a</em>) = <em>e</em><sup>′</sup>}</span></p><p>为同态映射 <span class="math inline"><em>ϕ</em></span>的<strong>核</strong> ，记作 <span class="math inline">Ker <em>ϕ</em></span></p><h3 id="群同态基本定理">群同态基本定理</h3><p>设 <span class="math inline"><em>ϕ</em></span> 是群 <span class="math inline"><em>G</em></span> 到群 <span class="math inline"><em>G</em><sup>′</sup></span> 的满同态，<span class="math inline"><em>K</em> = Ker <em>ϕ</em></span>，则 <span class="math display"><em>G</em>/<em>K</em> ≅ <em>G</em><sup>′</sup></span></p><p>应用群同态基本定理证明群的同构，一般有以下五个步骤：</p><ol type="1"><li>建立群 <span class="math inline"><em>G</em></span> 与群 <span class="math inline"><em>G</em><sup>′</sup></span> 的元素之间的对应关系<span class="math inline"><em>ϕ</em></span>，并证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>映射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>满映射</strong></li><li>证明 <span class="math inline"><em>ϕ</em></span> 为 <span class="math inline"><em>G</em></span> 到 <span class="math inline"><em>G</em><sup>′</sup></span> 的<strong>同态映射</strong>，即证明保持运算</li><li>计算同态的 <strong>核</strong> <span class="math inline">Ker <em>ϕ</em></span></li><li>应用群同态基本定理得 <span class="math inline"><em>G</em>/Ker <em>ϕ</em> ≅ <em>G</em><sup>′</sup></span></li></ol><h3 id="第二同构定理">第二同构定理</h3><p>设 <span class="math inline"><em>H</em></span> 为 <span class="math inline"><em>G</em></span> 的子群，<span class="math inline"><em>K</em></span> 为 <span class="math inline"><em>G</em></span> 的正规子群，则 <span class="math inline"><em>H</em> ∩ <em>K</em></span> 是 <span class="math inline"><em>H</em></span> 的正规子群且 <span class="math display"><em>H</em>/(<em>H</em> ∩ <em>K</em>) ≅ <em>H</em><em>K</em>/<em>K</em></span></p><h3 id="第三同构定理">第三同构定理</h3><p>设 <span class="math inline"><em>H</em></span> 是群 <span class="math inline"><em>G</em></span> 的正规子群，<span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em></span> 的正规子群，且 <span class="math inline"><em>K</em> ⊆ <em>H</em></span>，则 <span class="math display">(<em>G</em>/<em>K</em>)/(<em>H</em>/<em>K</em>) ≅ <em>G</em>/<em>H</em></span></p><h2 id="群的直积">群的直积</h2><h3 id="外直积">外直积</h3><h4 id="外直积的定义">外直积的定义</h4><p>设 <span class="math inline"><em>G</em><sub>1</sub>, <em>G</em><sub>2</sub></span>是两个群，构造集合 <span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 的卡氏积 <span class="math display"><em>G</em> = {(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>) ∣ <em>a</em><sub>1</sub> ∈ <em>G</em><sub>1</sub>, <em>a</em><sub>2</sub> ∈ <em>G</em><sub>2</sub>}</span></p><p>并在 <span class="math inline"><em>G</em></span> 中定义乘法运算 <span class="math display">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>) ⋅ (<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>) = (<em>a</em><sub>1</sub><em>b</em><sub>1</sub>, <em>a</em><sub>2</sub><em>b</em><sub>2</sub>),  (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>), (<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>) ∈ <em>G</em></span></p><p>则 <span class="math inline"><em>G</em></span>关于上述定义的乘法构成群，称为群 <span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span>的<strong>外直积</strong> ，记作 <span class="math inline"><em>G</em> = <em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span></p><ul><li>如果 <span class="math inline"><em>e</em><sub>1</sub>, <em>e</em><sub>2</sub></span>分别是群 <span class="math inline"><em>G</em><sub>1</sub></span> 和<span class="math inline"><em>G</em><sub>2</sub></span> 的单位元，则<span class="math inline">(<em>e</em><sub>1</sub>, <em>e</em><sub>2</sub>)</span>是 <span class="math inline"><em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>的单位元</li><li>设 <span class="math inline">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>) ∈ <em>G</em></span>，则<span class="math inline">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>)<sup>−1</sup> = (<em>a</em><sub>1</sub><sup>−1</sup>, <em>a</em><sub>2</sub><sup>−1</sup>)</span></li><li>当 <span class="math inline"><em>G</em><sub>1</sub></span> 和 <span class="math inline"><em>G</em><sub>2</sub></span> 都是加群时，<span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 的外直积也可记作 <span class="math inline"><em>G</em><sub>1</sub> ⊕ <em>G</em><sub>2</sub></span></li></ul><h4 id="外直积的性质">外直积的性质</h4><ul><li><p>设 <span class="math inline"><em>G</em> = <em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>是群 <span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 的外直积，则</p><ul><li><span class="math inline"><em>G</em></span> 是有限群的充分必要条件是<span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 都是有限群。</li><li>当 <span class="math inline"><em>G</em></span> 是有限群时，有 <span class="math display">|<em>G</em>| = |<em>G</em><sub>1</sub>| ⋅ |<em>G</em><sub>2</sub>|</span></li><li><span class="math inline"><em>G</em></span> 是交换群的充分必要条件是<span class="math inline"><em>G</em><sub>1</sub></span> 与 <span class="math inline"><em>G</em><sub>2</sub></span> 都是交换群</li><li><span class="math inline"><em>G</em><sub>1</sub> × <em>G</em><sub>2</sub> ≅ <em>G</em><sub>2</sub> × <em>G</em><sub>1</sub></span></li></ul></li><li><p>设 <span class="math inline"><em>G</em><sub>1</sub></span>，<span class="math inline"><em>G</em><sub>2</sub></span> 是两个群，<span class="math inline"><em>a</em></span> 和 <span class="math inline"><em>b</em></span> 分别是 <span class="math inline"><em>G</em><sub>1</sub></span> 和 <span class="math inline"><em>G</em><sub>2</sub></span> 中的有限阶元素，则对于<span class="math inline">(<em>a</em>, <em>b</em>) ∈ <em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>，有<span class="math display">ord (<em>a</em>, <em>b</em>) = [ord <em>a</em>, ord <em>b</em>]</span></p></li><li><p>设 <span class="math inline"><em>G</em><sub>1</sub></span> 和<span class="math inline"><em>G</em><sub>2</sub></span> 分别是 <span class="math inline"><em>m</em></span> 阶及 <span class="math inline"><em>n</em></span> 阶的循环群，则 <span class="math inline"><em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>是循环群的充要条件是 <span class="math inline">(<em>m</em>, <em>n</em>) = 1</span></p></li></ul><h3 id="内直积">内直积</h3><h4 id="内直积的定义">内直积的定义</h4><p>设 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 是群 <span class="math inline"><em>G</em></span> 的正规子群。如果群 <span class="math inline"><em>G</em></span> 满足条件 <span class="math display"><em>G</em> = <em>H</em><em>K</em>,  <em>H</em> ∩ <em>K</em> = {<em>e</em>}</span></p><p>则称 <span class="math inline"><em>G</em></span> 是 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 的<strong>内直积</strong></p><h4 id="内直积的判定">内直积的判定</h4><p>设 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 是 <span class="math inline"><em>G</em></span> 的子群，则 <span class="math inline"><em>G</em></span> 是 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 的内直积的充分必要条件是 <span class="math inline"><em>G</em></span> 满足如下两个条件：</p><ul><li><span class="math inline"><em>G</em></span> 中每个元素可唯一地表为<span class="math inline"><em>h</em><em>k</em></span> 的形式，其中 <span class="math inline"><em>h</em> ∈ <em>H</em></span>，<span class="math inline"><em>k</em> ∈ <em>K</em></span></li><li><span class="math inline"><em>H</em></span> 中每个元素与 <span class="math inline"><em>K</em></span> 中任意元素可交换，即：对任意 <span class="math inline"><em>h</em> ∈ <em>H</em></span>，<span class="math inline"><em>k</em> ∈ <em>K</em></span>，有 <span class="math inline"><em>h</em><em>k</em> = <em>k</em><em>h</em></span></li></ul><h3 id="内外直积的关系">内外直积的关系</h3><p>如果群 <span class="math inline"><em>G</em></span> 是正规子群 <span class="math inline"><em>H</em></span> 和 <span class="math inline"><em>K</em></span> 的内直积，则 <span class="math inline"><em>H</em> × <em>K</em> ≅ <em>G</em></span></p><p>反之，如果群 <span class="math inline"><em>G</em> = <em>G</em><sub>1</sub> × <em>G</em><sub>2</sub></span>，则存在<span class="math inline"><em>G</em></span> 的正规子群 <span class="math inline"><em>G</em><sub>1</sub><sup>′</sup></span> 和 <span class="math inline"><em>G</em><sub>2</sub><sup>′</sup></span>，且 <span class="math inline"><em>G</em><sub><em>i</em></sub><sup>′</sup></span>与 <span class="math inline"><em>G</em><sub><em>i</em></sub></span> 同构<span class="math inline">(<em>i</em> = 1, 2)</span>，使得 <span class="math inline"><em>G</em></span> 是 <span class="math inline"><em>G</em><sub>1</sub><sup>′</sup></span> 与 <span class="math inline"><em>G</em><sub>2</sub><sup>′</sup></span>的内直积</p><ul><li>从本定理中可看到，内外直积的概念本质上是一致的，所以有时可不对内外直积加以区分，而统称为群的直积</li></ul><h3 id="多个群的直积">多个群的直积</h3><ul><li><p>设 <span class="math inline"><em>G</em><sub>1</sub>, <em>G</em><sub>2</sub>, ⋯, <em>G</em><sub><em>n</em></sub></span>是有限多个群。构造集合 <span class="math display"><em>G</em> = {(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>) ∣ <em>a</em><sub><em>i</em></sub> ∈ <em>G</em><sub><em>i</em></sub>, <em>i</em> = 1, 2, ⋯, <em>n</em>}</span></p><p>并在 <span class="math inline"><em>G</em></span> 中定义运算 <span class="math display">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>) ⋅ (<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>n</em></sub>) = (<em>a</em><sub>1</sub><em>b</em><sub>1</sub>, <em>a</em><sub>2</sub><em>b</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub><em>b</em><sub><em>n</em></sub>)</span></p><p>则 <span class="math inline"><em>G</em></span>关于上述运算构成群，称为群 <span class="math inline"><em>G</em><sub>1</sub>, <em>G</em><sub>2</sub>, ⋯, <em>G</em><sub><em>n</em></sub></span>的外直积</p></li><li><p>设 <span class="math inline"><em>H</em><sub>1</sub>, <em>H</em><sub>2</sub>, ⋯, <em>H</em><sub><em>n</em></sub></span>是群 <span class="math inline"><em>G</em></span>的有限多个正规子群。如果 <span class="math inline"><em>G</em></span>满足以下两个条件，就称 <span class="math inline"><em>G</em></span> 是<span class="math inline"><em>H</em><sub>1</sub>, <em>H</em><sub>2</sub>, ⋯, <em>H</em><sub><em>n</em></sub></span>的内直积：</p><ul><li><span class="math inline"><em>G</em> = <em>H</em><sub>1</sub><em>H</em><sub>2</sub>⋯<em>H</em><sub><em>n</em></sub> = {<em>h</em><sub>1</sub><em>h</em><sub>2</sub>⋯<em>h</em><sub><em>n</em></sub> ∣ <em>h</em><sub><em>i</em></sub> ∈ <em>H</em><sub><em>i</em></sub>}</span></li><li><span class="math inline">(<em>H</em><sub>1</sub><em>H</em><sub>2</sub>⋯<em>H</em><sub><em>i</em></sub>) ∩ <em>H</em><sub><em>i</em> + 1</sub> = {<em>e</em>}, <em>i</em> = 1, 2, ⋯, <em>n</em> − 1</span>（任意两个交起来都是单位群）</li></ul></li><li><p>对于多个群的直积，如果群 <span class="math inline"><em>G</em></span> 是有限多个子群 <span class="math inline"><em>H</em><sub>1</sub>, <em>H</em><sub>2</sub>, ⋯, <em>H</em><sub><em>n</em></sub></span>的内直积，则 <span class="math inline"><em>G</em></span> 同构于 <span class="math inline"><em>H</em><sub>1</sub>, <em>H</em><sub>2</sub>, ⋯, <em>H</em><sub><em>n</em></sub></span>的外直积</p></li></ul><h1 id="第二章-环">第二章 环</h1><h2 id="环的定义和基本性质">环的定义和基本性质</h2><h3 id="环的定义">环的定义</h3><p>设 <span class="math inline"><em>R</em></span> 是一个非空集合，如果在<span class="math inline"><em>R</em></span> 上定义了两数运算“<span class="math inline">+</span>”（称为加法）和“<span class="math inline">⋅</span>”（称为乘法），并且满足</p><ul><li>(R1) <span class="math inline"><em>R</em></span>关于加法构成一个<strong>交换群</strong></li><li>(R2) 乘法结合律成立，即对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，有<span class="math display">(<em>a</em> ⋅ <em>b</em>) ⋅ <em>c</em> = <em>a</em> ⋅ (<em>b</em> ⋅ <em>c</em>)</span></li><li>(R3) 乘法对加法的两个分配律成立，即对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，有<span class="math display">$$  \begin{aligned}  a\cdot (b + c) = a\cdot b + a\cdot c\\  (b+c)\cdot a = b\cdot a + c\cdot a  \end{aligned}  $$</span></li></ul><p>则称 <span class="math inline">(<em>R</em>, +, ⋅)</span>为一个<strong>环</strong> ，或简称 <span class="math inline"><em>R</em></span> 为环</p><ul><li>由环的定义知 <span class="math inline">(<em>R</em>, +)</span>是一个交换群，称为环的加法群。与前两章中关于加群的记号一样，<span class="math inline"><em>R</em></span> 的加法单位元常用 0 表示，称为环<span class="math inline"><em>R</em></span> 的 <strong>零元</strong>，环<span class="math inline"><em>R</em></span> 的元素 <span class="math inline"><em>a</em></span> 的加法逆元称为 <span class="math inline"><em>a</em></span> 的 <strong>负元</strong> ，记作<span class="math inline">−<em>a</em></span>，由群的性质可知，<span class="math inline"><em>R</em></span>的零元及每个元素的负元都是唯一的</li><li>如果环 <span class="math inline"><em>R</em></span>的乘法还满足交换律，则称为<strong>交换环</strong></li><li>如果环中存在元素 <span class="math inline"><em>e</em></span>，使对任意的 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，有 <span class="math display"><em>a</em><em>e</em> = <em>e</em><em>a</em> = <em>a</em></span>则称 <span class="math inline"><em>R</em></span>是一个有单位元的环，并称 <span class="math inline"><em>e</em></span> 为<span class="math inline"><em>R</em></span> 的<strong>单位元</strong>（注意：环的单位元是乘法单位元）</li><li>一个环<strong>不一定有单位元</strong>，如果环有单位元，则单位元是唯一的</li><li>设环 <span class="math inline"><em>R</em></span>是有单位元的环，<span class="math inline"><em>a</em> ∈ <em>R</em></span>，如果存在 <span class="math inline"><em>b</em> ∈ <em>R</em></span>，使 <span class="math display"><em>a</em><em>b</em> = <em>b</em><em>a</em> = <em>e</em></span>则称 <span class="math inline"><em>a</em></span> 是 <span class="math inline"><em>R</em></span> 的一个 <strong>可逆元</strong>或<strong>单位</strong> ，并称 <span class="math inline"><em>b</em></span> 为 <span class="math inline"><em>a</em></span> 的 <strong>逆元</strong> ，记作<span class="math inline"><em>a</em><sup>−1</sup></span></li><li>环的一个元素不一定是可逆的，如果 <span class="math inline"><em>a</em></span> 可逆则 <span class="math inline"><em>a</em></span> 的逆元是唯一的</li><li>对于一个有单位元的环 <span class="math inline"><em>R</em></span>，其所有可逆元组成的集合关于环<span class="math inline"><em>R</em></span> 的乘法构成群。这个群称为环<span class="math inline"><em>R</em></span> 的 <strong>单位群</strong>，记作 <span class="math inline"><em>U</em>(<em>R</em>)</span></li><li>设 <span class="math inline"><em>R</em> = {0}</span>，规定 <span class="math inline">0 + 0 = 0 ⋅ 0 = 0</span>，则 <span class="math inline"><em>R</em></span>构成环称为<strong>零环</strong>，零环是唯一的一个有单位元且单位元等于零元，并且零元也可逆的环</li><li>今后，如无特别声明，凡提到有单位元的环时我们总假定这个环不是零环，因此环的单位元也就不等于零元</li></ul><h3 id="常见的环">常见的环</h3><ul><li><p>整数集 <span class="math inline">ℤ</span>、有理数集 <span class="math inline">ℚ</span>、实数集 <span class="math inline">ℝ</span>、复数集 <span class="math inline">ℂ</span>对于通常数的加法与乘法构成有单位元 <span class="math inline">1</span>的交换环，分别称为<strong>整数环、有理数域、实数域、复数域</strong>、它们的单位群分别是 <span class="math inline">{1, −1}</span>、<span class="math inline">ℚ<sup>*</sup></span>、<span class="math inline">ℝ<sup>*</sup></span> 和 <span class="math inline">ℂ<sup>*</sup></span></p></li><li><p>数域 <span class="math inline"><em>F</em></span> 上全体 <span class="math inline"><em>n</em>(<em>n</em> &gt; 1)</span> 阶方阵 <span class="math inline"><em>M</em><sub><em>n</em></sub>(<em>F</em>)</span>的集合关于矩阵的加法与乘法构成一个有单位元 <span class="math inline"><em>E</em></span>（单位矩阵）的非交换环，称为数域<span class="math inline"><em>F</em></span> 上的 <span class="math inline"><em>n</em></span> 阶全矩阵环，这个环的单位群是 <span class="math inline"><em>G</em><em>L</em><sub><em>n</em></sub>(<em>F</em>)</span></p></li><li><p>设 <span class="math inline"><em>m</em></span> 为大于 <span class="math inline">1</span> 的正整数，则 <span class="math inline">ℤ</span> 的模 <span class="math inline"><em>m</em></span> 剩余类集 <span class="math display">$$  Z_m=\{\overline{0},\overline{1},\overline{2},\cdots,\overline{m-1}\}  $$</span> 关于剩余类的加法和乘法构成有单位元的交换环，称为<strong>模 m剩余类环</strong> ，这个环的单位群是 <span class="math inline">$U(m) =\{\overline{x} \mid 1 \leq x &lt; m, (x,m)=1\}$</span></p></li><li><p>设 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, ⋯, <em>R</em><sub><em>n</em></sub></span>为 <span class="math inline"><em>n</em></span> 个环。令 <span class="math display"><em>R</em> = <em>R</em><sub>1</sub> ⊕ <em>R</em><sub>2</sub> ⊕ ⋯ ⊕ <em>R</em><sub><em>n</em></sub> = {(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>) ∣ <em>a</em><sub><em>i</em></sub> ∈ <em>R</em><sub><em>i</em></sub>, <em>i</em> = 1, 2, ⋯；<em>n</em>}</span></p><p>对任意的 <span class="math inline">(<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>), (<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>n</em></sub>) ∈ <em>R</em></span>，规定<span class="math display">$$  \begin{aligned}  \left(a_{1},a_{2},\cdots,a_{n}\right)+\left(b_{1},b_{2},\cdots,b_{n}\right)&amp; =\left(a_{1}+b_{1},a_{2}+b_{2},\cdots,a_{n}+b_{n}\right),\\  \left(a_{1},a_{2},\cdots,a_{n}\right)\cdot\left(b_{1},b_{2},\cdots,b_{n}\right) &amp; =\left(a_{1}b_{1},a_{2} b_{2},\cdots,a_{n} b_{n}\right)  \end{aligned}  $$</span></p><p>则 <span class="math inline"><em>R</em></span>关于上面所定义的加法与乘法构成一个环。这个环称为环 <span class="math inline"><em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, ⋯, <em>R</em><sub><em>n</em></sub></span>的<strong>直和</strong></p><ul><li><span class="math inline"><em>R</em></span>有单位元的充分必要条件是每个 <span class="math inline"><em>R</em><sub><em>i</em></sub></span>都有单位元</li><li><span class="math inline"><em>R</em></span>是交换环的充分必要条件是每个 <span class="math inline"><em>R</em><sub><em>i</em></sub></span>都是交换环</li></ul></li></ul><h3 id="环的性质">环的性质</h3><ul><li><p>设 <span class="math inline"><em>R</em></span> 是一个环，<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，则</p><ul><li><span class="math inline"><em>a</em> ⋅ 0 = 0 ⋅ <em>a</em> = 0</span></li><li><span class="math inline">−(−<em>a</em>) = <em>a</em></span></li><li><span class="math inline"><em>a</em> ⋅ (−<em>b</em>) = (−<em>a</em>) ⋅ <em>b</em> = −<em>a</em><em>b</em></span></li><li><span class="math inline">(−<em>a</em>) ⋅ (−<em>b</em>) = <em>a</em><em>b</em></span></li></ul></li><li><p>利用负元的概念，可以定义环 <span class="math inline"><em>R</em></span> 的减法“<span class="math inline">−</span>”，即对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，令 <span class="math display"><em>a</em> − <em>b</em> = <em>a</em> + (−<em>b</em>)</span></p></li><li><p><strong>移项法则</strong>：对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，有以下移项法则：<span class="math display"><em>a</em> + <em>b</em> = <em>c</em> ⇔ <em>a</em> = <em>c</em> − <em>b</em></span></p><p>乘法对于减法还满足分配律，即对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，有<span class="math display">$$  \begin{aligned}  a(b-c)=a b-a c \\  (b-c) a=b a-c a  \end{aligned}  $$</span></p></li><li><p><strong>倍数法则</strong>：对任意的 <span class="math inline"><em>m</em>, <em>n</em> ∈ <strong>Z</strong></span>，<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，</p><ul><li><span class="math inline"><em>m</em><em>a</em> + <em>n</em><em>a</em> = (<em>m</em> + <em>n</em>)<em>a</em></span></li><li><span class="math inline"><em>m</em>(<em>a</em> + <em>b</em>) = <em>m</em><em>a</em> + <em>m</em><em>b</em></span></li><li><span class="math inline"><em>m</em>(<em>n</em><em>a</em>) = (<em>m</em><em>n</em>)<em>a</em> = <em>n</em>(<em>m</em><em>a</em>)</span></li><li><span class="math inline"><em>m</em>(<em>a</em><em>b</em>) = (<em>m</em><em>a</em>)<em>b</em> = <em>a</em>(<em>m</em><em>b</em>)</span></li></ul></li><li><p><strong>指数法则</strong>：对任意的 <span class="math inline"><em>m</em>, <em>n</em> ∈ <strong>N</strong></span>，<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，</p><ul><li><span class="math inline">(<em>a</em><sup><em>m</em></sup>)<sup><em>n</em></sup> = <em>a</em><sup><em>m</em><em>n</em></sup></span></li><li><span class="math inline"><em>a</em><sup><em>m</em></sup> ⋅ <em>a</em><sup><em>n</em></sup> = <em>a</em><sup><em>m</em> + <em>n</em></sup></span></li><li>如果 <span class="math inline"><em>R</em></span> 的元素 <span class="math inline"><em>a</em></span> 是不可逆的，则 <span class="math inline"><em>a</em><sup>0</sup></span> 与 <span class="math inline"><em>a</em><sup>−<em>n</em></sup>(<em>n</em> &gt; 0)</span>通常是没有意义的</li><li>当 <span class="math inline"><em>a</em><em>b</em> ≠ <em>b</em><em>a</em></span>时，等式 <span class="math inline">(<em>a</em> ⋅ <em>b</em>)<sup><em>n</em></sup> = <em>a</em><sup><em>n</em></sup> ⋅ <em>b</em><sup><em>n</em></sup></span>一般也不成立</li></ul></li><li><p><strong>广义分配律</strong>： 设 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，则对 <span class="math inline"><em>b</em><sub><em>i</em></sub> ∈ <em>R</em>(<em>i</em> = 1, 2, ⋯, <em>n</em>)</span>，有<span class="math display">$$  a\left(\sum_{i=1}^{n} b_{i}\right)=\sum_{i=1}^{n} a  b_{i},\quad\left(\sum_{i=1}^{n} b_{i}\right) a=\sum_{i=1}^{n} b_{i} a  $$</span></p><p>设 <span class="math inline"><em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub> ∈ <em>R</em>(<em>i</em> = 1, 2, ⋯, <em>n</em></span>；<span class="math inline"><em>j</em> = 1, 2, ⋯, <em>m</em>)</span>，则 <span class="math display">$$  \left(\sum_{i=1}^{n} a_{i}\right)\left(\sum_{j=1}^{m}b_{j}\right)=\sum_{i=1}^{n} \sum_{j=1}^{m} a_{i} b_{j}  $$</span></p></li></ul><h3 id="子环的定义">子环的定义</h3><p>设 <span class="math inline">(<em>R</em>, +, ⋅)</span>是一个环，<span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的一个非空子集。如果 <span class="math inline"><em>S</em></span> 关于 <span class="math inline"><em>R</em></span> 的运算构成环，则称 <span class="math inline"><em>S</em></span> 为 <span class="math inline"><em>R</em></span> 的一个<strong>子环</strong> ，记作<span class="math inline"><em>S</em> &lt; <em>R</em></span></p><ul><li>如果 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的子环，则 <span class="math inline">(<em>S</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的子加群</li><li><span class="math inline"><em>R</em></span> 的零元 <span class="math inline">0</span> 就是 <span class="math inline"><em>S</em></span> 的零元</li><li><span class="math inline"><em>S</em></span> 中元素 <span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>R</em></span> 中的负元 <span class="math inline">−<em>a</em></span> 就是 <span class="math inline"><em>a</em></span> 在 <span class="math inline"><em>S</em></span> 中的负元</li><li>环 <span class="math inline"><em>R</em></span>本身以及由单独一个零元 <span class="math inline">{0}</span>所构成的集合关于 <span class="math inline"><em>R</em></span>的运算显然都构成 <span class="math inline"><em>R</em></span>的子环，这两个子环称为环 <span class="math inline"><em>R</em></span>的<strong>平凡子环</strong></li><li>即使一个环有单位元，其子环也可能没有单位元</li><li>即使一个环没有单位元，其子环也可能有单位元</li></ul><h3 id="子环的判定">子环的判定</h3><ul><li>设 <span class="math inline"><em>R</em></span> 是一个环，<span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的一个非空子集，则 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的子环的充分必要条件是<ul><li><span class="math inline">(<em>S</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的加法子群</li><li><span class="math inline"><em>S</em></span> 关于 <span class="math inline"><em>R</em></span> 的乘法封闭，即对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>S</em></span>，有 <span class="math inline"><em>a</em><em>b</em> ∈ <em>S</em></span></li></ul></li><li>设 <span class="math inline"><em>R</em></span> 是一个环，<span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的一个非空子集，则 <span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span> 的子环的充分必要条件是<ul><li>对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>S</em></span>，<span class="math inline"><em>a</em> − <em>b</em> ∈ <em>S</em></span></li><li>对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>S</em></span>，<span class="math inline"><em>a</em><em>b</em> ∈ <em>S</em></span></li></ul></li><li>这就是说，环 <span class="math inline"><em>R</em></span> 的子环<span class="math inline"><em>S</em></span> 是 <span class="math inline"><em>R</em></span>的关于减法与乘法封闭的非空子集</li></ul><h3 id="中心">中心</h3><p>设 <span class="math inline"><em>R</em></span> 为环，则 <span class="math display"><em>C</em>(<em>R</em>) = {<em>r</em> ∈ <em>R</em> ∣ <em>r</em><em>s</em> = <em>s</em><em>r</em>, ∀<em>s</em> ∈ <em>R</em>}</span></p><p>为 <span class="math inline"><em>R</em></span>的一个子环，这个子环称为 <span class="math inline"><em>R</em></span> 的<strong>中心</strong></p><h2 id="整环和域">整环和域</h2><h3 id="零因子">零因子</h3><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em></span> 为 <span class="math inline"><em>R</em></span> 的两个<strong>非零元素</strong>，如果 <span class="math display"><em>a</em> ⋅ <em>b</em> = 0</span></p><p>则称 <span class="math inline"><em>a</em></span> 为 <span class="math inline"><em>R</em></span> 的一个<strong>左零因子</strong>，<span class="math inline"><em>b</em></span> 为 <span class="math inline"><em>R</em></span>的一个<strong>右零因子</strong></p><ul><li>左零因子与右零因子统称为<strong>零因子</strong></li><li>在一个有零因子的环中，右零因子不一定是左零因子，左零因子也不一定是右零因子</li><li>如果一个环有左零因子，也就一定有右零因子，反之亦然</li><li>如果一个环没有左零因子，当然也就没有右零因子，从而也就没有零因子</li><li>一个没有零因子的环称为<strong>无零因子环</strong></li><li>在一个无零因子的环中，两个消去律成立，即对任意的 <span class="math inline"><em>a</em>, <em>b</em>, <em>c</em> ∈ <em>R</em></span>，<span class="math inline"><em>c</em> ≠ 0</span>，如果 <span class="math inline"><em>a</em><em>c</em> = <em>b</em><em>c</em></span>或 <span class="math inline"><em>c</em><em>a</em> = <em>c</em><em>b</em></span>，则<span class="math inline"><em>a</em> = <em>b</em></span></li><li>如果环 <span class="math inline"><em>R</em></span>中两个消去律有一个成立，则 <span class="math inline"><em>R</em></span>必是无零因子环，从而另一个消去律也成立</li></ul><h3 id="整环">整环</h3><p>一个 <strong>无零因子</strong> 的，有 <strong>单位元</strong> <span class="math inline"><em>e</em> ≠ 0</span> 的 <strong>交换环</strong><span class="math inline"><em>R</em></span> 称为<strong>整环</strong></p><ul><li><p>整数环 <span class="math inline"><strong>Z</strong></span>，高斯整环 <span class="math inline"><strong>Z</strong>[i]</span>，模 <span class="math inline"><em>m</em></span> 剩余类环 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>，数域<span class="math inline"><strong>F</strong></span> 上的一元多项式环<span class="math inline"><strong>F</strong>[<em>x</em>]</span>都是整环。</p></li><li><p>全体形如 <span class="math display"><strong>Z</strong>[i] = {<em>a</em> + <em>b</em>i ∣ <em>a</em>, <em>b</em> ∈ <strong>Z</strong>}</span></p><p>的复数关于通常数的运算构成一个整环，环 <span class="math inline"><strong>Z</strong>[i]</span> 称为<strong>高斯整环</strong>，单位群为 <span class="math inline"><strong>Z</strong>[i]<sup>×</sup> = {1, −1, i, −i}</span></p></li><li><p>类似地可以证明，对任一无平方因子的整数 <span class="math inline"><em>d</em>(<em>d</em> ≠ 1)</span>，数集 <span class="math display">$$  \mathbf{Z}[\sqrt{d}]=\{a+b \sqrt{d} \mid a,b \in \mathbf{Z}\}  $$</span></p><p>也是整环</p></li></ul><h3 id="域">域</h3><p>设 <span class="math inline"><em>F</em></span> 是一个有<strong>单位元</strong> <span class="math inline">1<sub><em>F</em></sub> ≠ 0</span> 的<strong>交换环</strong>。如果 <span class="math inline"><em>F</em></span> 中<strong>每个非零元都可逆</strong>，则称 <span class="math inline"><em>F</em></span> 是一个<strong>域</strong></p><ul><li>由于可逆元一定不是零因子，所以 <strong>每个域都是整环</strong></li><li>整环却不一定是域，如整数环 <span class="math inline"><strong>Z</strong></span>，高斯整环 <span class="math inline"><strong>Z</strong>[i]</span> 都不是域</li><li><span class="math inline">Q</span>，<span class="math inline">R</span>，<span class="math inline">C</span>都是域，分别称为有理数域、实数域和复数域</li><li>设 <span class="math inline"><em>p</em></span> 是一个素数，则模<span class="math inline"><em>p</em></span> 剩余类环 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub></span>是一个含 有 <span class="math inline"><em>p</em></span>个元素的域，称为<strong>素数域</strong></li></ul><h2 id="理想和商环">理想和商环</h2><h3 id="理想的定义">理想的定义</h3><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的非空子集，如果 <span class="math inline"><em>I</em></span> 满足</p><ul><li>对任意的 <span class="math inline"><em>r</em><sub>1</sub></span>，<span class="math inline"><em>r</em><sub>2</sub> ∈ <em>I</em></span>，<span class="math inline"><em>r</em><sub>1</sub> − <em>r</em><sub>2</sub> ∈ <em>I</em></span></li><li>对任意的 <span class="math inline"><em>r</em> ∈ <em>I</em></span>，<span class="math inline"><em>s</em> ∈ <em>R</em></span>，<span class="math inline"><em>r</em><em>s</em>, <em>s</em><em>r</em> ∈ <em>I</em></span></li></ul><p>则称 <span class="math inline"><em>I</em></span> 为环 <span class="math inline"><em>R</em></span> 的一个<strong>理想</strong> ，记作<span class="math inline"><em>I</em> ⊲ <em>R</em></span>。又如果 <span class="math inline"><em>I</em> ⊊ <em>R</em></span>，则称 <span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的 <strong>真理想</strong></p><ul><li>如果 <span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>I</em></span> 必为 <span class="math inline"><em>R</em></span> 的子环</li><li><span class="math inline">{0}</span> 与 <span class="math inline"><em>R</em></span> 本身显然都是 <span class="math inline"><em>R</em></span> 的理想，这两个理想称为 <span class="math inline"><em>R</em></span> 的 <strong>平凡理想</strong></li><li><span class="math inline">ℤ</span> 的所有理想是 <span class="math inline">{<em>d</em>Z ∣ <em>d</em> ∈ ℤ, <em>d</em> ≥ 0}</span></li><li><span class="math inline">ℤ<sub><em>m</em></sub></span> 的所有理想是<span class="math inline">{<em>d</em>Z<sub><em>m</em></sub> ∣ <em>d</em> = 0或 <em>d</em> ∣ <em>m</em>}</span></li></ul><h3 id="理想的运算">理想的运算</h3><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>I</em></span>，<span class="math inline"><em>J</em></span> 都是 <span class="math inline"><em>R</em></span> 的理想，集合 <span class="math display"><em>I</em> + <em>J</em> = {<em>a</em> + <em>b</em> ∣ <em>a</em> ∈ <em>I</em>, <em>b</em> ∈ <em>J</em>}  与  <em>I</em> ∩ <em>J</em></span></p><p>分别称为理想 <span class="math inline"><em>I</em></span> 与 <span class="math inline"><em>J</em></span> 的<strong>和</strong>与<strong>交</strong></p><ul><li>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>I</em></span>，<span class="math inline"><em>J</em></span> 都是 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>I</em></span> 与 <span class="math inline"><em>J</em></span> 的和与交都是 <span class="math inline"><em>R</em></span> 的理想</li><li>环 <span class="math inline"><em>R</em></span> 的任意<strong>有限</strong> 多个理想的和还是 <span class="math inline"><em>R</em></span> 的理想</li><li>环 <span class="math inline"><em>R</em></span>的任意（<strong>有限或无限</strong> ）多个理想的交还是 <span class="math inline"><em>R</em></span> 的理想</li></ul><h3 id="主理想">主理想</h3><p>设 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，考察<span class="math inline"><em>R</em></span> 中含有元素 <span class="math inline"><em>a</em></span> 的全部理想的集合 <span class="math display"><em>Σ</em> = {<em>I</em> ⊲ <em>R</em> ∣ <em>a</em> ∈ <em>I</em>}</span></p><p>因为 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，且<span class="math inline"><em>R</em> ⊲ <em>R</em></span>，所以 <span class="math inline"><em>R</em> ∈ <em>Σ</em></span>，从而 <span class="math inline"><em>Σ</em></span> 非空。令 <span class="math display">⟨<em>a</em>⟩ = ⋂<sub><em>I</em> ∈ <em>Σ</em></sub><em>I</em></span></p><p>则 <span class="math inline">⟨<em>a</em>⟩</span> 为 <span class="math inline"><em>R</em></span> 的一个理想，这个理想称为 <span class="math inline"><em>R</em></span> 的由 <span class="math inline"><em>a</em></span> 生成的 <strong>主理想</strong></p><ul><li>因为 <span class="math inline"><em>a</em> ∈ <em>I</em>(<em>I</em> ∈ <em>Σ</em>)</span>，所以<span class="math inline"><em>a</em> ∈ ⟨<em>a</em>⟩</span>，从而 <span class="math inline">⟨<em>a</em>⟩ ∈ <em>Σ</em></span></li><li>我们看到：一方面，<span class="math inline">⟨<em>a</em>⟩</span>是包含 <span class="math inline"><em>a</em></span>的理想；另一方面，<span class="math inline">⟨<em>a</em>⟩</span>是所有包含 <span class="math inline"><em>a</em></span> 的理想的交，所以<span class="math inline">⟨<em>a</em>⟩</span> 是 <span class="math inline"><em>R</em></span> 的包含 <span class="math inline"><em>a</em></span> 的最小理想</li></ul><h4 id="主理想的构成">主理想的构成</h4><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>a</em> ∈ <em>R</em></span>，则</p><ul><li>一般地 <span class="math display">$$\langlea\rangle=\left\{\sum_{i=1}^{n} x_{i} a y_{i}+x a+a y+m a \midx_{i},y_{i},x,y \in R,\,n \in \mathbf{N},\,m \in\mathbf{Z}\right\}$$</span></li><li>如果 <span class="math inline"><em>R</em></span> 是有单位元的环，则<span class="math display">$$ \langle a\rangle=\left\{\sum_{i=1}^{n}x_{i} a y_{i} \mid x_{i},y_{i} \in R,\,n \in\mathbf{N}\right\}$$</span></li><li>如果 <span class="math inline"><em>R</em></span> 是交换环，则 <span class="math display">⟨<em>a</em>⟩ = {<em>x</em><em>a</em> + <em>m</em><em>a</em> ∣ <em>x</em> ∈ <em>R</em>, <em>m</em> ∈ <strong>Z</strong>}；</span></li><li>如果 <span class="math inline"><em>R</em></span>是有单位元的交换环，则 <span class="math display">⟨<em>a</em>⟩ = <em>a</em><em>R</em> = {<em>a</em><em>r</em> ∣ <em>r</em> ∈ <em>R</em>}</span></li></ul><p>则有</p><ul><li>整数环 <span class="math inline"><strong>Z</strong></span>的每个理想都是主理想</li><li>模 <span class="math inline"><em>m</em></span> 剩余类环 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>的每个理想都是主理想</li></ul><h3 id="多元理想">多元理想</h3><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub> ∈ <em>R</em></span>，则<span class="math inline">⟨<em>a</em><sub>1</sub>⟩, ⟨<em>a</em><sub>2</sub>⟩, ⋯, ⟨<em>a</em><sub><em>s</em></sub>⟩</span>都是 <span class="math inline"><em>R</em></span> 的理想。令</p><p><span class="math display">⟨<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub>⟩ = ⟨<em>a</em><sub>1</sub>⟩ + ⟨<em>a</em><sub>2</sub>⟩ + ⋯ + ⟨<em>a</em><sub><em>s</em></sub>⟩</span></p><p>则 <span class="math inline">⟨<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub>⟩</span>为 <span class="math inline"><em>R</em></span> 的理想，称为 <span class="math inline"><em>R</em></span> 的由 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub></span>生成的理想。易知，<span class="math inline">⟨<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub>⟩</span>是 <span class="math inline"><em>R</em></span> 的含 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>s</em></sub></span>的最小理想</p><h3 id="商环">商环</h3><p>设 <span class="math inline"><em>R</em></span> 是一个环，<span class="math inline"><em>I</em></span> 是环 <span class="math inline"><em>R</em></span> 的一个理想，则 <span class="math inline">(<em>I</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的子加群，从而 <span class="math inline">(<em>I</em>, +)</span> 是 <span class="math inline">(<em>R</em>, +)</span> 的正规子群，于是有商群：<span class="math display">$$R / I=\{\overline{x}=x+I \mid x \in R\}$$</span></p><p>其加法运算定义为 <span class="math display">$$\overline{x}+\overline{y}=\overline{x+y},\quad x,y \in R$$</span></p><p>定义 <span class="math inline"><em>R</em>/<em>I</em></span> 的乘法：<span class="math display">$$\overline{x} \cdot \overline{y}=\overline{x y},\quad x,y \in R$$</span></p><p>称环 <span class="math inline"><em>R</em>/<em>I</em></span> 为环<span class="math inline"><em>R</em></span> 关于它的理想 <span class="math inline"><em>I</em></span> 的<strong>商环</strong></p><p>设 <span class="math inline"><em>R</em></span> 为环，<span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的理想，则</p><ul><li><span class="math inline">$\overline{0}=I$</span> 为 <span class="math inline"><em>R</em>/<em>I</em></span> 的零元</li><li>如果 <span class="math inline"><em>R</em></span> 有单位元 <span class="math inline"><em>e</em></span>，且 <span class="math inline"><em>e</em> ∉ <em>I</em></span>，则 <span class="math inline"><em>ē</em> = <em>e</em> + <em>I</em></span> 为 <span class="math inline"><em>R</em>/<em>I</em></span> 的单位元</li><li>如果 <span class="math inline"><em>R</em></span> 是交换环，则 <span class="math inline"><em>R</em>/<em>I</em></span> 也是交换环</li></ul><h2 id="环的同态">环的同态</h2><h3 id="环同态的定义">环同态的定义</h3><p>设 <span class="math inline"><em>R</em></span> 和 <span class="math inline"><em>R</em><sup>′</sup></span> 为两个环，<span class="math inline"><em>ϕ</em></span> 是集合 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的映射。如果对任意的<span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，有</p><ul><li><span class="math inline"><em>ϕ</em>(<em>a</em> + <em>b</em>) = <em>ϕ</em>(<em>a</em>) + <em>ϕ</em>(<em>b</em>)</span></li><li><span class="math inline"><em>ϕ</em>(<em>a</em><em>b</em>) = <em>ϕ</em>(<em>a</em>)<em>ϕ</em>(<em>b</em>)</span></li></ul><p>则称 <span class="math inline"><em>ϕ</em></span> 为环 <span class="math inline"><em>R</em></span> 到环 <span class="math inline"><em>R</em><sup>′</sup></span>的一个<strong>同态映射</strong> ，简称<strong>同态</strong></p><ul><li>环同态就是环之间保持运算的映射</li><li>如果 <span class="math inline"><em>ϕ</em></span> 是单映射，则称<span class="math inline"><em>ϕ</em></span> 为单同态</li><li>如果 <span class="math inline"><em>ϕ</em></span> 是满映射，则称<span class="math inline"><em>ϕ</em></span> 为满同态</li><li>如果 <span class="math inline"><em>ϕ</em></span>既是单同态，又是满同态，则称 <span class="math inline"><em>ϕ</em></span>为<strong>同构</strong> ，此时，称环 <span class="math inline"><em>R</em></span> 与 <span class="math inline"><em>R</em><sup>′</sup></span> <strong>同构</strong>，记作 <span class="math inline"><em>ϕ</em> : <em>R</em> ≅ <em>R</em><sup>′</sup></span></li><li>与群的相应概念类似，环的同构是环之间的一个等价关系，并且从环的观点来看，同构的环有完全相同的代数性质</li></ul><h4 id="零同态">零同态</h4><p>设 <span class="math inline"><em>R</em></span> 与 <span class="math inline"><em>R</em><sup>′</sup></span> 是两个环，对任意的<span class="math inline"><em>a</em> ∈ <em>R</em></span>，令 <span class="math display">$$\begin{aligned}\phi: R &amp;\longrightarrow R^{\prime},\\\ a &amp;\longmapsto 0\end{aligned}$$</span></p><p>则对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>， <span class="math display">$$\begin{aligned}\phi(a+b) &amp; =0=\phi(a)+\phi(b),\\\phi(a b) &amp; =0=\phi(a) \phi(b)\end{aligned}$$</span></p><p>所以 <span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span>的一个同态，这个同态称为 <strong>零同态</strong></p><h4 id="自然同态">自然同态</h4><p>设 <span class="math inline"><em>R</em></span> 是环，<span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的理想。对任意的 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，令</p><p><span class="math display">$$\begin{aligned}\eta:R &amp; \longrightarrow R / I,\\a &amp; \longmapsto \bar{a}\end{aligned}$$</span></p><p>则 <span class="math inline"><em>η</em></span> 为 <span class="math inline"><em>R</em></span> 到它的商环 <span class="math inline"><em>R</em>/<em>I</em></span> 的满映射。又对任意的<span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em> ∈ <em>R</em></span>，</p><p><span class="math display">$$\begin{aligned}\eta(a+b) &amp;=\overline{a+b}=\bar{a}+\bar{b}=\eta(a)+\eta(b),\\\eta(a b) &amp; =\overline{a b}=\bar{a} \bar{b}=\eta(a) \eta(b)\end{aligned}$$</span></p><p>所以 <span class="math inline"><em>η</em></span> 为 <span class="math inline"><em>R</em></span> 到它的商环 <span class="math inline"><em>R</em>/<em>I</em></span>的一个<strong>满同态</strong>，这个同态称为<strong>自然同态</strong></p><h3 id="环同态的性质">环同态的性质</h3><ul><li><p>设 <span class="math inline"><em>ϕ</em></span> 是环 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的同态，则对任意的<span class="math inline"><em>a</em> ∈ <em>R</em></span></p><ul><li><span class="math inline"><em>ϕ</em>(0<sub><em>R</em></sub>) = 0<sub><em>R</em><sup>′</sup></sub></span></li><li><span class="math inline"><em>ϕ</em>(<em>n</em><em>a</em>) = <em>n</em><em>ϕ</em>(<em>a</em>),  ∀<em>n</em> ∈ <strong>Z</strong></span></li><li><span class="math inline"><em>ϕ</em>(<em>a</em><sup><em>n</em></sup>) = (<em>ϕ</em>(<em>a</em>))<sup><em>n</em></sup>,  ∀<em>n</em> ∈ <strong>N</strong></span></li></ul></li><li><p>设 <span class="math inline"><em>R</em></span> 与 <span class="math inline"><em>R</em><sup>′</sup></span>都是有单位元的环，<span class="math inline"><em>e</em></span> 与 <span class="math inline"><em>e</em><sup>′</sup></span>分别是它们的单位元，<span class="math inline"><em>ϕ</em></span> 是 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的环同态</p><ul><li>如果 <span class="math inline"><em>ϕ</em></span> 是满同态，则 <span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span></li><li>如果 <span class="math inline"><em>R</em><sup>′</sup></span>为无零因子环，且 <span class="math inline"><em>ϕ</em>(<em>e</em>) ≠ 0</span>，则 <span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span></li><li>如果 <span class="math inline"><em>ϕ</em>(<em>e</em>) = <em>e</em><sup>′</sup></span>，则对<span class="math inline"><em>R</em></span> 的任一单位 <span class="math inline"><em>u</em></span>，<span class="math inline"><em>ϕ</em>(<em>u</em>)</span> 是 <span class="math inline"><em>R</em><sup>′</sup></span> 的单位，且 <span class="math inline">(<em>ϕ</em>(<em>u</em>))<sup>−1</sup> = <em>ϕ</em>(<em>u</em><sup>−1</sup>)</span></li></ul></li></ul><h3 id="核-1">核</h3><p>设 <span class="math inline"><em>ϕ</em></span> 为环 <span class="math inline"><em>R</em></span> 到环 <span class="math inline"><em>R</em><sup>′</sup></span> 的同态映射，称集合<span class="math display"><em>K</em> = {<em>a</em> ∈ <em>R</em> ∣ <em>ϕ</em>(<em>a</em>) = 0}</span></p><p>为环同态 <span class="math inline"><em>ϕ</em></span>的<strong>核</strong> ，记作 <span class="math inline">Ker <em>ϕ</em></span>，且 <span class="math inline">Ker <em>ϕ</em></span> 为 <span class="math inline"><em>R</em></span> 的理想。</p><h3 id="环同态基本定理">环同态基本定理</h3><p>设 <span class="math inline"><em>ϕ</em></span> 是环 <span class="math inline"><em>R</em></span> 到 <span class="math inline"><em>R</em><sup>′</sup></span> 的满同态，则有环同构<span class="math display"><em>ϕ̃</em> : <em>R</em>/Ker <em>ϕ</em> ≅ <em>R</em><sup>′</sup></span></p><h3 id="环的第二同构定理">环的第二同构定理</h3><p>设 <span class="math inline"><em>S</em></span> 为 <span class="math inline"><em>R</em></span> 的子环，<span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>S</em> ∩ <em>I</em></span> 是 <span class="math inline"><em>S</em></span> 的理想且 <span class="math display"><em>S</em>/(<em>S</em> ∩ <em>I</em>) ≅ (<em>S</em> + <em>I</em>)/<em>I</em></span></p><h3 id="环的第三同构定理">环的第三同构定理</h3><p>设 <span class="math inline"><em>R</em></span> 是环，<span class="math inline"><em>I</em></span> 和 <span class="math inline"><em>J</em></span> 都是 <span class="math inline"><em>R</em></span> 的理想，且 <span class="math inline"><em>I</em> ⊆ <em>J</em></span>。则有环同构 <span class="math display">(<em>R</em>/<em>I</em>)/(<em>J</em>/<em>I</em>) ≅ <em>R</em>/<em>J</em></span></p><h2 id="素理想和极大理想">素理想和极大理想</h2><h3 id="素理想">素理想</h3><p>设 <span class="math inline"><em>R</em></span> 是一个交换环，<span class="math inline"><em>P</em></span> 是 <span class="math inline"><em>R</em></span> 的真理想。如果对任意的 <span class="math inline"><em>a</em>, <em>b</em> ∈ <em>R</em></span>，由 <span class="math inline"><em>a</em><em>b</em> ∈ <em>P</em></span>，可推出<span class="math inline"><em>a</em> ∈ <em>P</em></span> 或 <span class="math inline"><em>b</em> ∈ <em>P</em></span>，则称 <span class="math inline"><em>P</em></span> 为 <span class="math inline"><em>R</em></span> 的一个<strong>素理想</strong></p><ul><li><span class="math inline"><strong>Z</strong></span> 的全部素理想为<span class="math display">⟨<em>p</em>⟩  以及  {0}</span></li><li>设 <span class="math inline"><em>R</em></span> 是有单位元 <span class="math inline"><em>e</em> ≠ 0</span> 的交换环，<span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的素理想的充分必要条件是 <span class="math inline"><em>R</em>/<em>I</em></span> 是整环</li></ul><h3 id="极大理想">极大理想</h3><p>设 <span class="math inline"><em>R</em></span> 是一个交换环，<span class="math inline"><em>M</em></span> 是 <span class="math inline"><em>R</em></span> 的真理想。如果对 <span class="math inline"><em>R</em></span> 的任一包含 <span class="math inline"><em>M</em></span> 的理想 <span class="math inline"><em>N</em></span>，必有 <span class="math inline"><em>N</em> = <em>M</em></span> 或 <span class="math inline"><em>N</em> = <em>R</em></span>，则称 <span class="math inline"><em>M</em></span> 为 <span class="math inline"><em>R</em></span>的一个<strong>极大理想</strong></p><ul><li><p>设 <span class="math inline"><em>R</em></span> 是有单位元 <span class="math inline"><em>e</em></span> 的交换环，<span class="math inline"><em>I</em></span> 为 <span class="math inline"><em>R</em></span> 的理想，则 <span class="math inline"><em>I</em></span> 是 <span class="math inline"><em>R</em></span> 的极大理想的充分必要条件是 <span class="math inline"><em>R</em>/<em>I</em></span> 是域</p></li><li><p>设 <span class="math inline"><em>R</em></span>是一个有单位元的交换环，则 <span class="math inline"><em>R</em></span>的每个极大理想都是素理想</p><ul><li>若没有单位元，则不一定成立</li><li>素理想不一定是极大理想</li></ul></li></ul><h3 id="中国剩余定理">中国剩余定理</h3><p>如果 <span class="math inline"><em>I</em></span> 和 <span class="math inline"><em>J</em></span> 是包含单位元 <span class="math inline">1</span> 的交换环 <span class="math inline"><em>R</em></span> 的两个理想，满足 <span class="math inline"><em>I</em> + <em>J</em> = <em>R</em></span>，则有</p><ol type="1"><li><span class="math inline"><em>I</em> ∩ <em>J</em> = <em>I</em><em>J</em></span></li><li><span class="math inline"><em>R</em>/<em>I</em><em>J</em> ≅ <em>R</em>/<em>I</em> × <em>R</em>/<em>J</em></span></li></ol><h2 id="环的特征与素域">环的特征与素域</h2><h3 id="特征">特征</h3><h4 id="特征的定义">特征的定义</h4><p>设 <span class="math inline"><em>R</em></span>为环，如果存在最小的正整数 <span class="math inline"><em>n</em></span>，使得对所有的 <span class="math inline"><em>a</em> ∈ <em>R</em></span>，有 <span class="math inline"><em>n</em><em>a</em> = 0</span>，则称 <span class="math inline"><em>n</em></span> 为环 <span class="math inline"><em>R</em></span> 的 <strong>特征</strong>。如果这样的正整数不存在，则称环 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline">0</span>。环 <span class="math inline"><em>R</em></span> 的特征记作 <span class="math inline">Char <em>R</em></span>。</p><ul><li><span class="math inline"><strong>Z</strong>, <strong>Q</strong>, <strong>R</strong>, <strong>C</strong></span>的特征都等于 <span class="math inline">0</span></li><li>一般地，如果 <span class="math inline"><em>R</em></span>是一个数环，则 <span class="math inline">Char <em>R</em> = 0</span></li><li>设 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span> 是模<span class="math inline"><em>m</em></span> 剩余类环，则对每个 <span class="math inline"><em>n̄</em> ∈ <strong>Z</strong><sub><em>m</em></sub></span>，有<span class="math display">$$  m \bar{n}=\overline{m n}=\overline{0}  $$</span> 而对于任何正整数 <span class="math inline"><em>k</em> &lt; <em>m</em></span>，有 <span class="math display">$$  k \overline{1}=\bar{k} \neq \overline{0}  $$</span> 所以 <span class="math inline">Char <strong>Z</strong><sub><em>m</em></sub> = <em>m</em></span></li><li>对于 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub></span>上的一元多项式环 <span class="math inline"><strong>Z</strong><sub><em>m</em></sub>[<em>x</em>]</span>，也有<span class="math inline">Char <strong>Z</strong><sub><em>m</em></sub>[<em>x</em>] = <em>m</em></span></li><li>一个有限环的特征是一个正整数</li></ul><h4 id="特征的性质">特征的性质</h4><ul><li><p>设 <span class="math inline"><em>R</em></span> 是有单位元 <span class="math inline"><em>e</em></span> 的环，如果 <span class="math inline"><em>e</em></span> 关于加法的阶为无穷大，那么 <span class="math inline"><em>R</em></span> 的特征等于 <span class="math inline">0</span>。如果 <span class="math inline"><em>e</em></span> 关于加法的阶等于 <span class="math inline"><em>n</em></span>，那么 <span class="math inline">Char <em>R</em> = <em>n</em></span>。</p></li><li><p>整环的特征是 <span class="math inline">0</span>或者是一个素数，域同理。</p></li><li><p>设 <span class="math inline"><em>R</em></span> 是有单位元 <span class="math inline"><em>e</em></span> 的环，则映射 <span class="math display">$$  \begin{aligned}  \phi:\mathbf{Z} &amp; \longrightarrow R,\\  n &amp; \longmapsto n e  \end{aligned}  $$</span></p><p>是环 <span class="math inline"><strong>Z</strong></span> 到 <span class="math inline"><em>R</em></span> 的同态</p></li><li><p>设 <span class="math inline"><em>R</em></span> 是有单位元的环</p><ul><li>如果 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline"><em>n</em> &gt; 0</span>，则 <span class="math inline"><em>R</em></span> 包含一个与 <span class="math inline"><strong>Z</strong><sub><em>n</em></sub></span>同构的子环 <span class="math inline"><em>R</em><sup>′</sup> = {<em>m</em><em>e</em> ∣ <em>m</em> ∈ <strong>Z</strong>}</span></li><li>如果 <span class="math inline"><em>R</em></span> 的特征为 <span class="math inline">0</span>，则 <span class="math inline"><em>R</em></span> 包含一个与 <span class="math inline"><strong>Z</strong></span> 同构的子环 <span class="math inline"><em>R</em><sup>′</sup> = {<em>m</em><em>e</em> ∣ <em>m</em> ∈ <strong>Z</strong>}</span></li></ul></li><li><p>设 <span class="math inline"><em>F</em></span> 是域</p><ul><li>如果 <span class="math inline"><em>F</em></span> 的特征是 <span class="math inline">0</span>，则 <span class="math inline"><em>F</em></span> 包含一个与有理数域 <span class="math inline"><strong>Q</strong></span> 同构的子域</li><li>如果 <span class="math inline"><em>F</em></span> 的特征是素数 <span class="math inline"><em>p</em></span>，则 <span class="math inline"><em>F</em></span> 包含一个与模 <span class="math inline"><em>p</em></span> 剩余类环 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub></span>同构的子域</li></ul></li></ul><h3 id="素域">素域</h3><ul><li><p>一个域 <span class="math inline"><em>F</em></span>如果不含任何真子域，则称 <span class="math inline"><em>F</em></span>是一个<strong>素域</strong></p></li><li><p>设 <span class="math inline"><em>F</em></span> 是个域</p><ul><li>如果 <span class="math inline">Char <em>F</em> = 0</span>，那么<span class="math inline"><em>F</em></span> 包含一个与 <span class="math inline"><strong>Q</strong></span> 同构的素域</li><li>如果 <span class="math inline">Char <em>F</em> = <em>p</em> &gt; 0</span>，那么<span class="math inline"><em>F</em></span> 包含一个与 <span class="math inline"><strong>Z</strong><sub><em>p</em></sub></span>同构的素域</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>抽象代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马克思主义基本原理</title>
    <link href="/posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="导论">导论</h1><h2 id="一什么是马克思主义">一、什么是马克思主义</h2><ul><li>马克思主义是由马克思和恩格斯创立并为后继者所不断发展的科学理论体系，是关于自然、社会和人类思维发展一般规律的学说，是关于社会主义必然代替资本主义、最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，是无产阶级政党和社会主义国家的指导思想，是指引人们创造美好生活的行动指南。</li><li>马克思主义理论体系基本组成部分：<strong>马克思主义哲学、马克思主义政治经济学、科学社会主义</strong>。</li></ul><h2 id="二马克思主义的创立与发展">二、马克思主义的创立与发展</h2><ul><li>马克思主义产生于19世纪40年代，创始人是<strong>马克思和恩格斯</strong>。</li><li><strong>德国古典哲学、英国古典政治经济学、英法空想社会主义</strong>为马克思主义的创立提供了直接的理论来源。</li><li>《<strong>德意志意识形态</strong>》首次系统阐述了历史唯物主义的基本观点，实现了历史观上的伟大变革。</li><li>1848年3月《<strong>共产党宣言</strong>》发表，标志着马克思主义的公开问世。</li><li>《<strong>资本论</strong>》系统阐述了剩余价值学说，揭示了资本主义生产关系的秘密。</li><li><strong>唯物史观</strong>和<strong>剩余价值学说</strong>是马克思一生的两个伟大发现。</li><li>列宁深刻分析了19世纪末20世纪初世界历史条件的变化，认为资本主义发达国家已经发展到帝国主义阶段，经济政治发展的不平衡已成为资本主义发展的绝对规律。</li><li>1917年，列宁和布尔什维克党领导俄国工人阶级和革命人民夺取了十月社会主义革命的胜利，使社会主义从理想开始变为现实，从而开创了世界历史的新纪元。</li><li>列宁把马克思主义基本原理与俄国实际相结合，创立了列宁主义，把马克思主义发展到一个新的历史阶段。</li></ul><h2 id="三马克思主义的基本特征">三、马克思主义的基本特征</h2><ul><li>科学性、人民性、实践性、发展性</li><li>马克思主义的世界观和方法论基础：辩证唯物主义和历史唯物主义</li><li>马克思主义的政治立场：人民至上</li><li>马克思主义的基本特征：科学性与革命性的统一。革命性是马克思主义的内在品质，是人民性、实践性、发展性的应有之义和必然要求</li></ul><h2 id="四马克思主义的当代价值不考">四、马克思主义的当代价值（不考）</h2><h2 id="五自觉学习和运用马克思主义不考">五、自觉学习和运用马克思主义（不考）</h2><h1 id="第一章-世界的物质性及其发展规律">第一章世界的物质性及其发展规律</h1><h2 id="第一节-世界的多样性与物质统一性">第一节世界的多样性与物质统一性</h2><ol type="1"><li>哲学基本问题<ul><li>一是存在和思维、物质和意识谁为本原的问题，即何者为第一性的问题。<strong>划分唯物主义和唯心主义</strong></li><li>二是存在和思维、物质和意识是否具有同一性的问题，即思维能否正确地反映存在、人能否认识或彻底认识世界的问题。<strong>划分可知论和不可知论</strong></li></ul></li><li>唯物主义<ul><li>古代朴素唯物主义：合理性和进步性</li><li>近代形而上学唯物主义：直观性和朴素性</li></ul></li><li>马克思主义的物质范畴具有丰富而深刻的理论意义<ul><li>第一，坚持了<strong>唯物主义一元论</strong>，同唯心主义一元论和二元论划清了界限。</li><li>第二，坚持了<strong>能动的反映论和可知论</strong>，批判了不可知论。</li><li>第三，体现了<strong>唯物论和辩证法的统一</strong>，克服了形而上学唯物主义的缺陷。</li><li>第四，体现了<strong>唯物主义自然观与历史观的统一</strong>，为彻底的唯物主义奠定了理论基础。</li></ul></li><li>马克思主义的物质观<ol type="1"><li>物质的存在方式<ul><li>物质是指不依赖于人的意识又能为人的意识所反映的客观实在。</li><li><strong>客观实在性</strong>是物质的唯一特性。</li><li>物质的<strong>根本属性是运动</strong>。运动是标志一切事物和现象的变化及其过程的哲学范畴。</li><li>物质世界的运动是绝对的，而物质在运动过程中有暂时的静止。</li><li>相对静止是物质运动在一定条件下的稳定状态。</li><li>时间和空间是运动着的物质的基本存在形式：<ul><li>时间是物质运动的持续性、顺序性，特点是一维性。</li><li>空间是物质运动的广延性、伸张性，特点是三维性。</li></ul></li></ul></li><li>物质世界的<strong>二重化</strong>：人的实践活动是自然界与人类社会、客观世界与主观世界相分化的关键，也是他们相统一的关键。<ul><li>自然界和人类社会<ul><li>区别：自然界中一切自发产生；人类社会是人有目的的实践的结果。</li><li>联系：自然界中有“人化自然”；社会中有自然物质和自然力的运用，物质生产本身也是人与自然的物质能量的交换。</li></ul></li><li>客观世界与主观世界<ul><li>区别：客观世界不依赖于思想意识而存在，包括自然界和人类社会。主观世界是人的头脑反映和把握物质世界的精神活动的总和。</li><li>联系：主观世界是对客观世界的反映，并反作用于客观世界。</li></ul></li></ul></li></ol></li><li>物质与意识的辩证关系<ol type="1"><li><strong>物质决定意识</strong>：<ul><li>起源：意识是自然界长期发展的产物。意识是社会历史的产物，劳动在意识的产生和发展中起着决定性作用。</li><li>本质：意识是人脑的机能和属性，是物质世界的主观映象。意识在内容上是客观的，在形式上是主观的，是客观内容和主观形式的统一。</li></ul></li><li>意识对物质具有反作用：意识的能动作用：<ul><li>意识具有目的性和计划性。</li><li>意识具有创造性。</li><li>意识具有指导实践改造客观世界的作用。</li><li>意识具有调控人的行为和生理活动的作用。</li></ul></li><li><strong>主观能动性和客观规律性的辩证统一</strong><ul><li>主观能动性与客观规律性的辩证关系：<ul><li>尊重客观规律是正确发挥主观能动性的前提。</li><li>只有充分发挥主观能动性，才能正确认识和利用客观规律。</li></ul></li><li>正确发挥人的主观能动性的前提和条件：<ul><li>第一，从实际出发是正确发挥人的主观能动性的前提。</li><li>第二，实践是正确发挥人的主观能动性的根本途径。</li><li>第三，正确发挥人的主观能动性，还要依赖于一定的物质条件和物质手段。</li></ul></li><li>坚持遵循客观规律与发挥主观能动性相统一，要求充分发扬历史主动精神。</li></ul></li><li>意识与人工智能<ul><li>人工智能不可能取代或超越人类<ul><li>人类意识是<strong>知情意的统一</strong>，而人工智能只能是人类的理性智能的模拟和扩展，不具备情感、信念、意志等人类意识形式。</li><li><strong>社会性</strong>是人的意识所固有的本质属性，而人工智能不可能真正具备人类的社会属性。</li><li>人类的<strong>自然语言</strong>是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义上的能力。</li><li>人工智能能够获得人类意识中可以化约为数字信号的内容，但是人脑中总有许多东西无法被化约。</li></ul></li></ul></li></ol></li><li>世界的物质统一性：世界的统一性在于他的物质性，世界统一于物质。<ul><li>第一，自然界是物质的。</li><li>第二，人类社会本质上是生产实践基础上形成的物质体系。</li><li>第三，人的意识统一于物质。</li></ul></li></ol><h2 id="第二节-事物的普遍联系和变化发展">第二节事物的普遍联系和变化发展</h2><ol type="1"><li><strong>联系和发展的观点是唯物辩证法的总观点</strong>，集中体现了唯物辩证法的总特征。</li><li>联系是指事物内部各要素之间和事物之间相互影响、相互制约和相互作用的关系。</li><li>联系的特点：<ul><li>首先，联系具有<strong>客观性</strong>。</li><li>其次，联系具有<strong>普遍性</strong>。<ul><li>其一，任何事物内部的不同部分和要素之间都是相互联系的。</li><li>其二，任何事物都不能孤立存在，都同其他事物处于一定的联系之中。</li><li>其三，整个世界是相互联系的统一整体。</li></ul></li><li>再次，联系具有<strong>多样性</strong>。<ul><li>直接联系与间接联系</li><li>内部联系与外部联系</li><li>本质联系与非本质联系</li><li>必然联系与偶然联系</li></ul></li><li>最后，联系具有<strong>条件性</strong>。</li></ul></li><li><strong>发展的实质</strong>：物质世界的发展，特别是人类社会的发展，其实质是新事物的产生和旧事物的灭亡。新事物是指合乎历史前进方向、具有远大前途的东西；旧事物是指丧失历史必然性、日趋灭亡的东西。在新陈代谢的发展过程中，新事物是不可战胜的。新事物在本质上优越于旧事物，具有强大生命力。</li><li>唯物辩证法揭示了事物变化发展的一般规律，即<strong>对立统一规律、量变质变规律和否定之否定规律</strong>，其中对立统一规律是根本规律，是唯物辩证法的实质和核心。</li><li>对立统一规律<ol type="1"><li>矛盾的同一性和斗争性<ul><li>矛盾的含义：矛盾是反映事物内部和事物之间<strong>对立统一</strong>关系的哲学范畴。对立和统一分别体现了矛盾的两种基本属性。</li><li>矛盾的<strong>同一性</strong>是指矛盾着的对立面相互依存、相互贯通的性质和趋势。</li><li>矛盾的同一性的含义：<ul><li>一是矛盾着的对立面相互依存、互为存在的前提，并共处于一个统一体中。</li><li>二是矛盾着的对立面相互贯通，在一定条件下可以相互转化。</li></ul></li><li>矛盾的<strong>斗争性</strong>是矛盾着的对立面之间相互排斥、相互分离的性质和趋势。</li><li>矛盾可以分为<strong>对抗性矛盾和非对抗性矛盾</strong>两种基本形式。</li><li>矛盾的同一性和斗争性相互联结、相辅相成。</li><li>矛盾的同一性在事物发展中的作用：<ul><li>第一，同一性是事物存在和发展的前提。</li><li>第二，同一性使矛盾双方相互吸取有利于自身的因素，在相互作用中各自得到发展。</li><li>第三，同一性规定着事物转化的可能和发展的趋势。</li></ul></li><li>矛盾的斗争性在事物发展中的作用：<ul><li>第一，矛盾双方的斗争促进矛盾双方力量的变化，造成双方力量发展的不平衡，为对立面的转化、事物的质变创造条件。</li><li>第二，矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过渡的决定性力量。</li></ul></li><li>矛盾的同一性和斗争性辩证关系原理要求我们在观察和处理问题时，必须善于把二者结合起来，在斗争性中把握同一性，在同一性中把握斗争性。运用矛盾的同一性和斗争性辩证关系原理指导实践，要正确把握和谐对事物发展的作用，还要大力发扬斗争精神。</li></ul></li><li>矛盾的普遍性和特殊性<ul><li>矛盾的<strong>普遍性</strong>：矛盾存在于一切事物中，存在于一切事物发展过程的始终</li><li>矛盾的<strong>特殊性</strong>：各个具体事物的矛盾、每一个矛盾的各个方面在发展的不同阶段上各有其特点。<ul><li>一是<strong>不同事物的矛盾</strong>各有其特点。</li><li>二是同一事物的矛盾在<strong>不同发展过程和发展阶段</strong>各有不同特点。</li><li>三是构成事物的诸多矛盾以及每一矛盾的<strong>不同方面</strong>各有不同的性质、地位和作用。</li></ul></li><li>把主要矛盾和次要矛盾、矛盾的主要方面和次要方面的辩证关系运用到实际工作中，就是要坚持“两点论”和“重点论”的统一。<ul><li>“<strong>两点论</strong>”是指在分析事物的矛盾时，不仅要看到矛盾双方的<strong>对立</strong>，而且要看到矛盾双方的<strong>统一</strong>；不仅要看到矛盾体系中存在<strong>主要矛盾</strong>、<strong>矛盾的主要方面</strong>，而且要看到<strong>次要矛盾</strong>、<strong>矛盾的次要方面</strong>。</li><li>“<strong>重点论</strong>”是指要着重把握主要矛盾、矛盾的主要方面，并以此作为解决问题的出发点。</li></ul></li><li>矛盾普遍性与矛盾特殊性是辩证统一的关系。矛盾的普遍性即矛盾的共性，矛盾的特殊性即矛盾的个性。</li><li>矛盾的共性和个性、绝对和相对的道理，是关于事物矛盾问题的精髓。</li><li>矛盾的普遍性和特殊性辩证关系原理是马克思主义基本原理同各国实际相结合的哲学基础，也是建设中国特色社会主义的哲学基础。</li></ul></li></ol></li><li>量变质变规律<ul><li>量变质变规律体现了事物发展的渐进性和飞跃性的统一。</li><li>质：一事物区别于其他事物的内在规定性。</li><li>量：事物的规模、程度、速度等可以用数量关系表示的规定性。</li><li>度：保持事物质的稳定性的数量界限。</li><li>量变：事物数量的增减和组成要素排列次序的变动，是保持事物的质的相对稳定性的不显著变化，体现了事物发展渐进过程的连续性。</li><li>质变：事物性质的根本变化，是事物由一种质态向另一种质态的飞跃，体现了事物发展渐进过程和连续性的中断。</li><li>量变和质变的辩证关系：<ul><li>第一，量变是质变的<strong>必要准备</strong>。</li><li>第二，质变是量变的<strong>必然结果</strong>。</li><li>第三，量变和质变是<strong>相互渗透</strong>的。</li></ul></li><li>量变质变规律的方法论意义：<ul><li>一方面，当事物的发展处在量变阶段时，要踏踏实实做好日常工作，为未来重大改变做准备；</li><li>另一方面，当质变来临的时候，要果断地、不失时机地抓住机遇，促成质变，使工作迈上新台阶。</li></ul></li></ul></li><li>否定之否定规律<ul><li>否定之否定规律揭示了事物发展的前进性和曲折性的统一。</li><li>肯定因素是维持现存事物存在的因素，否定因素是促使现存事物灭亡的因素。</li><li>辩证否定观（否定的深刻内涵）：<ul><li>第一，否定是<strong>事物的自我否定、自我发展</strong>，是事物内部矛盾运动的结果。</li><li>第二，否定是<strong>事物发展的环节</strong>，是旧事物向新事物的转变，是从旧质到新质的飞跃。</li><li>第三，否定是<strong>新旧事物联系的环节</strong>，新事物孕育产生于旧事物。</li><li>第四，辩证否定的实质是“<strong>扬弃</strong>”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素。</li></ul></li><li>否定之否定：肯定→否定→否定之否定<ul><li>第一次否定使矛盾得到初步解决，而处于否定阶段的事物仍然具有片面性。</li><li>第二次否定实现了对立面的统一，使矛盾得到根本解决。</li></ul></li><li>事物的发展呈现出周期性，不同周期的交替使事物的发展呈现出波浪式前进或螺旋式上升的总趋势。</li></ul></li><li>内容与形式<ul><li>内容指构成事物的一切要素的总和，形式指把诸要素统一起来的结构或表现内容的方式。</li><li>任何事物都是内容与形式的统一。<ul><li>一方面，内容是事物存在的基础，对形式具有决定作用。</li><li>另一方面，形式对内容具有反作用。</li></ul></li></ul></li><li>本质与现象<ul><li>本质是事物的根本性质，是构成事物的诸要素之间的内在联系。</li><li>现象是事物的外部联系和表面特征，是事物本质的外在表现。现象可以区分为真象和假象。</li></ul></li><li>原因与结果<ul><li>在事物的普遍联系中，引起某种现象的现象就是原因，被某种现象引起的现象就是结果。</li></ul></li><li>必然与偶然<ul><li>必然是指事物联系与发展中确定不移的趋势，在一定条件下具有不可避免性。</li><li>偶然是指事物联系与发展中不确定的趋势。</li></ul></li><li>现实与可能<ul><li>现实是指相互联系着的实际存在的事物的综合。</li><li>可能是指包含在事物中、预示事物发展前途的种种趋势。</li></ul></li></ol><h2 id="第三节-唯物辩证法是认识世界和改造世界的根本方法不考">第三节唯物辩证法是认识世界和改造世界的根本方法（不考）</h2><h1 id="第二章-实践与认识及其发展规律">第二章实践与认识及其发展规律</h1><h2 id="第一节-实践与认识">第一节 实践与认识</h2><ol type="1"><li>科学实践观及其意义<ul><li>第一，克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础。</li><li>第二，揭示了实践对认识的决定作用，为能动的、革命的反映论的创立奠定了科学的理论基础。</li><li>第三，在人类思想史上第一次揭示了社会生活的实践本质，为唯物史观的创立奠定了科学的理论基础。</li><li>第四，为人们能动地认识世界和改造世界提供了基本的思想方法和工作方法。</li></ul></li><li>实践的本质：<strong>实践是人类能动地改造世界的社会性的物质活动</strong>。</li><li>实践的基本特征：<strong>客观实在性、自觉能动性、社会历史性</strong>。</li><li>实践的基本结构：<ul><li>第一，<strong>实践主体</strong>，指具有一定的主体能力、从事现实社会实践活动的人。<ul><li>能力：自然能力、精神能力（知识性因素、非知识性因素）。</li><li>基本形态：个体主体、群体主体、人类主体。</li></ul></li><li>第二，<strong>实践客体</strong>，指实践活动所指向的对象。<ul><li>是否为实践所创造：天然客体和人工客体；</li><li>自然界与人类社会两个领域相区分：自然客体与社会客体；</li><li>物质性和精神性相区分：物质性客体和精神性客体。</li></ul></li><li>第三，<strong>实践中介</strong>。<ul><li>子系统：物质性工具系统、语言符号工具系统。</li></ul></li></ul></li><li>实践的主体和客体相互作用的关系：<strong>实践关系</strong>（最根本的关系）、认识关系、价值关系。</li><li>主体和客体相互作用：双向运动<ul><li><strong>主体客体化</strong>：人通过实践使自己的本质力量作用于客体，使其按照主体的需要发生结构和功能上的变化，形成了世界上本来不存在的对象物。</li><li><strong>客体主体化</strong>：客体从客观对象的存在形式转化为主体生命结构的因素或主体本质力量的因素，客体失去客体性的形式，变成主体的一部分。</li></ul></li><li>实践的形式：<ul><li>一是<strong>物质生产实践</strong>。（最基本的实践活动）（制约其他两种实践并受其产生能动的反作用）</li><li>二是社会政治实践。</li><li>三是科学文化实践。</li><li>四是虚拟实践。</li></ul></li><li>实践对认识的决定作用：<ul><li>第一，实践是认识的<strong>来源</strong>。</li><li>第二，实践是认识<strong>发展的动力</strong>。</li><li>第三，实践是认识的<strong>目的</strong>。</li><li>第四，实践是<strong>检验</strong>认识真理性的唯一标准。</li></ul></li><li>认识是主体在实践基础上对客体的能动反映，这是辩证唯物主义认识论对认识本质的科学回答。</li><li>不同的认识路线：<ul><li>唯物主义反映论：<strong>从物到感觉和思想</strong><ul><li>旧唯物主义：离开实践考察认识问题，因而不了解实践对认识的决定作用；离开辩证法来考察认识问题，因而把复杂的认识过程简单化，把认识运动凝固化，把多方面的认识要素片面化。</li><li><strong>辩证唯物主义认识论是建立在实践基础上的能动的反映论</strong>。</li></ul></li><li>唯心主义先验论：<strong>从思想和感觉到物</strong></li></ul></li><li>辩证唯物主义认识论特点：<ul><li>一是把实践的观点引入认识论。</li><li>二是把辩证法应用于反映论考察认识的发展过程。</li></ul></li><li>反映和创造不是人类认识的两种不同的本质，而是同一本质的两个不同的方面。<ul><li>其一，创造离不开反映，创造存在于反映之中，创造过程是在相互联系的多个方面的反映基础上实现的。</li><li>其二，反映也离不开创造，反映是在创造过程中实现的。</li></ul></li><li>人们认识事物的过程，是一个<strong>从实践到认识，再从认识到实践</strong>的过程。<ul><li>认识运动的第一次飞跃：从实践到认识，从生动的直观到抽象的思维，由感性认识能动地飞跃到理性认识<ul><li>感性认识包括感觉、知觉、表象。</li><li>理性认识包括概念、判断、推理。</li><li>感性认识和理性认识的关系是辩证统一的：<ul><li>第一，理性认识依赖于感性认识。</li><li>第二，感性认识有待于发展和深化为理性认识。</li><li>第三，感性认识和理性认识相互渗透、相互包含。</li></ul></li></ul></li><li>认识运动的第二次飞跃：从认识到实践<ul><li>必要性和重要性：<ul><li>第一，认识世界的目的是改造世界。</li><li>第二，认识的真理性只有在实践中才能得到检验和发展。</li></ul></li></ul></li></ul></li></ol><h2 id="第二节-真理与价值">第二节 真理与价值</h2><ol type="1"><li>真理<ol type="1"><li><strong>客观性（本质属性）</strong>：对客观事物及其规律的正确反映，包含着不依赖于人和人的意识的客观内容。<ul><li>真理的客观性决定了真理的一元性，即在同一条件下对于特定的认识客体的真理性认识只有一个。</li><li>真理是<strong>内容上的一元性与形式上的多样性</strong>的统一。</li></ul></li><li>真理的<strong>绝对性和相对性</strong><ul><li>真理的绝对性：真理主客观统一的确定性和发展的无限性。</li><li>真理的相对性：人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的、不完善的。</li><li>真理的绝对性和相对性辩证统一。真理的绝对性与相对性根源于人类认识世界能力的无限性与有限性、绝对性与相对性的矛盾。</li></ul></li><li>真理与谬误<ul><li>谬误指同客观事物及其发展规律相违背的认识，是对客观事物及其发展规律的歪曲反映。</li><li>真理与谬误既对立又统一：<ul><li>第一，真理与谬误相互对立。真理和谬误有着原则界线。</li><li>第二，真理与谬误的对立又是相对的，它们在一定条件下能够相互转化。首先，真理在一定条件下会转化为谬误。其次，谬误在一定条件下能够向真理转化。</li></ul></li><li>真理和谬误的对立统一关系表明，真理总是同谬误相比较而存在、相斗争而发展的。</li></ul></li></ol></li><li><strong>实践是检验真理的唯一标准</strong>，是由真理的本性和实践的特点所决定的。<ul><li>第一，从真理的本性看，真理是人们对客观事物及其发展规律的正确反映，它的本性在于主观和客观相符合。</li><li>第二，从实践的特点来看，<strong>实践具有直接现实性</strong>。</li></ul></li><li>实践标准是确定性与不确定性的统一。<ul><li>实践标准的确定性即绝对性，是指实践作为检验真理标准的唯一性、归根到底性、最终性，由实践标准的客观性和唯一性所决定。</li><li>实践标准的不确定性即相对性，是指实践作为检验真理标准的条件性。</li></ul></li><li>价值是<strong>反映主客体之间意义关系</strong>的哲学范畴，是客体对个人群体乃至整个社会的生活和活动所具有的意义。价值离不开主体的需要和客体的特性，既有主体性特征又有客观基础。</li><li>价值的基本特征：<ul><li>第一，价值的<strong>主体性</strong>：指价值直接与主体相联系，始终以主体为中心。</li><li>第二，价值的<strong>客观性</strong>：指在一定条件下客体对于主体的意义不依赖于主体的主观意识而存在。</li><li>第三，价值的<strong>多维性</strong>：指每个主体的价值关系具有多样性，同一客体相对于主体的不同需要会产生不同的价值。</li><li>第四，价值的<strong>社会历史性</strong>：指价值关系随着社会历史的发展、主客体的不断变化而变化，具有历史性和阶段性。</li></ul></li><li>价值评价：<ul><li>第一，评价以主客体之间的价值关系为认识对象。</li><li>第二，评价结果与评价主体直接相关。</li><li>第三，评价结果的正确与否依赖于对客体状况和主体需要的认识。</li><li>第四，价值评价有科学和非科学之别。</li></ul></li><li><strong>价值观是人们关于价值本质的认识以及对人和事物评价标准、评价原则和评价方法的观点的体系。</strong></li><li>任何成功的实践都是真理尺度和价值尺度的统一，是合规律性和合目的性的统一。</li></ol><h2 id="第三节-认识世界和改造世界">第三节 认识世界和改造世界</h2><ol type="1"><li>认识世界和改造世界史相互依赖、相互制约的辩证统一关系<ul><li>一方面，认识世界有助于改造世界。正确认识世界是有效改造世界的必要前提；</li><li>另一方面，人们只有在改造世界的实践中才能不断地深化、拓展对世界的正确认识。</li></ul></li><li>改造客观世界和改造主观世界是辩证统一的。</li><li>自由是表示人的活动状态的范畴，是指人在活动中通过认识和利用必然所表现出的自然自觉的状态。</li><li>自由的条件：<ul><li><strong>认识条件</strong>：即要有对客观事物的正确认识，最主要的是对客观事物运动发展规律性、必然性的正确认识。</li><li><strong>实践条件</strong>：即能够将获得的规律性认识运用于指导实践，实现改造世界的目的，才是真正的自由。</li></ul></li><li>认识必然和争取自由，是人类认识世界和改造世界的根本目标，是一个历史性的过程。</li><li><strong>一切从实际出发</strong>，就是要把客观存在的事物作为观察和处理问题的根本出发点，这是<strong>马克思主义认识论的根本要求和具体体现</strong>。</li><li><strong>思想路线</strong>的基本内涵：一切从实际出发，理论联系实际，实事求是，在实践中检验和发展真理。<strong>核心是实事求是</strong>。</li></ol><h1 id="第三章-人类社会及其发展规律">第三章 人类社会及其发展规律</h1><h2 id="第一节-人类社会的存在与发展">第一节 人类社会的存在与发展</h2><ol type="1"><li><strong>社会存在与社会意识的关系问题，是社会历史观的基本问题。</strong></li><li>两种根本对立的历史观：唯心史观和唯物史观</li><li>社会存在是指社会物质生活条件，是社会生活的<strong>物质方面</strong>，主要包括自然地理环境、人口因素和物质生产方式。<ul><li><strong>物质生产方式是社会存在和发展的基础及决定力量，生产方式是社会历史发展的决定力量</strong>。</li><li>自然地理环境是指与人类社会所处的地理位置相联系的自然条件的总和，是人类社会生存和发展的永恒的、必要的条件。</li><li>人口是由人类社会的一切有生命的个人构成的总和。</li><li>物质生产方式是指人们为获取物质生活资料而进行的生产活动的方式，是生产力和生产关系的统一体。</li></ul></li><li>社会意识是社会存在的反映，是社会生活的<strong>精神方面</strong>。<ul><li>根据不同的主体，分为个体意识（个体社会实践的产物）和群体意识（群体实践的产物）。</li><li>根据不同的层次，分为社会心理（以感性认识为主）和社会意识形式（以理性认识为主）。</li><li>社会意识形式以社会心理为基础，并对社会心理起指导和影响作用。</li><li>社会意识形式：<ol type="1"><li>意识形态<ul><li><strong>政治法律思想</strong>：在意识形态中居核心地位，发挥主导作用。</li><li>道德：历史性、继承性</li><li>艺术</li><li>宗教：自然压迫和社会压迫的产物。</li><li>哲学：世界观和方法论的统一。</li></ul></li><li>非意识形态：自然科学、语言学、形式逻辑</li></ol></li></ul></li><li><strong>社会存在和社会意识是辩证统一的</strong>：<ul><li>社会存在<strong>决定</strong>社会意识，社会意识是社会存在的<strong>反映</strong>，并<strong>反作用</strong>于社会存在。</li><li>社会存在是社会意识内容的<strong>客观来源</strong>，社会意识是社会物质生活过程及其条件的<strong>主观反映</strong>。</li><li>社会意识既依赖于社会存在，又有其相对独立性：<ul><li>一是社会意识与社会存在发展具有不完全同步性和不平衡性。</li><li>二是社会意识内部各种形式之间存在相互影响且各自具有历史继承性。</li><li>三是社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现。</li></ul></li></ul></li><li>社会存在和社会意识辩证关系原理的重要意义：<ul><li>社会存在和社会意识辩证关系原理对于我们树立科学的历史观、正确认识社会历史具有重要意义。</li><li>社会存在和社会意识辩证关系原理对于推进社会发展包括社会文化建设具有重要指导意义。</li></ul></li><li><strong>生产力与生产关系、经济基础与上层建筑之间的矛盾，是人类社会基本矛盾</strong>。<ul><li>生产力与生产关系矛盾运动的规律、经济基础与上层建筑矛盾运动的规律，是<strong>人类社会发展的基本规律</strong>。</li></ul></li><li>生产力与生产关系的矛盾运动及其规律<ol type="1"><li><strong>生产力</strong>：<strong>是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量</strong>。<ul><li>生产力是人类社会生活和全部历史的物质基础。</li><li>生产力具有<strong>客观现实性和社会历史性</strong>。</li><li>生产力基本要素：<ul><li><strong>劳动资料</strong>：也称为劳动手段，是人们在劳动过程中所运用的物质资料或物质条件，其中最重要的是<strong>生产工具</strong>。“各种经济时代的区别，不在于生产什么，而在于怎样生产，用什么劳动资料生产。”</li><li><strong>劳动对象</strong>：是现实生产的必要前提，它从一个侧面反映和体现了生产力的发展水平。</li><li><strong>劳动者</strong>：是具有一定生产经验、劳动技能和知识，能够运用一定生产资料作用于劳动对象，从事生产实践活动的人。劳动者是生产力中最活跃的因素，在生产力中起<strong>主导作用</strong>。劳动者一般包括体力劳动者和脑力劳动者。</li></ul></li><li><strong>科学技术是先进生产力的集中体现和主要标志，是第一生产力。</strong></li></ul></li><li><strong>生产关系</strong>：<strong>是人们在物质生产过程中形成的不以人的意志为转移的经济关系</strong>。<ul><li><strong>生产关系是社会关系中最基本的关系</strong>，政治关系、家庭关系、宗教关条等其他社会关系，都受生产关系的支配和制约。</li><li>生产关系包括<strong>生产资料所有制关系（最基本）、生产中人与人的关系、产品分配关系</strong>。</li><li>生产关系基本类型：<ul><li>以生产资料公有制为基础的生产关系</li><li>以生产资料私有制为基础的生产关系</li></ul></li></ul></li><li>生产力与生产关系的相互关系：<ul><li>第一，<strong>生产力决定生产关系</strong>。</li><li>第二，<strong>生产关系对生产力具有能动的反作用</strong>。<ul><li>当生产关系适合生产力发展的客观要求时，对生产力的发展起推动作用；</li><li>当生产关系不适合生产力发展的客观要求时就会阻碍生产力的发展。</li></ul></li><li>生产关系一定要适合生产力状况的规律是社会形态发展的普遍规律：生产关系对于生产力总是从基本相适合到基本不相适合，再到基本相适合；与此相适应，生产关系也总是从相对稳定到新旧更替，再到相对稳定。</li></ul></li><li>生产力与生产关系矛盾运动规律具有极为重要的理论意义和现实意义：<ul><li>第一，这一原理在人类思想史上彻底否定了单纯以道德作为评判历史功过是非标准的思想体系，第一次科学地确立了<strong>生产力发展是“社会进步的最高标准”</strong>，并且把生产领域生产关系矛盾运动的规律作为判断时代变革的客观依据。</li><li>第二，生产力与生产关系矛盾运动规律是马克思主义政党制定路线、方针和政策的重要依据。</li></ul></li></ol></li><li>经济基础与上层建筑的矛盾运动及其规律<ol type="1"><li><strong>经济基础</strong>：是指<strong>由社会一定发展阶段的生产力所决定的生产关系的总和</strong>。<ul><li>其一，社会发展中往往有多种生产关系，但决定社会性质的是其中占支配地位的生产关系。</li><li>其二，经济基础与经济体制具有内在联系：经济体制是社会基本经济制度所采取的组织形式和管理形式。</li></ul></li><li><strong>上层建筑</strong>：是<strong>建立在一定经济基础之上的意识形态以及相应的制度、组织和设施</strong>。<ul><li>上层建筑的构成：<ul><li><strong>意识形态</strong>（观念上层建筑）：政治法律思想、道德、艺术、宗教、哲学</li><li><strong>政治法律制度及设施和政治组织</strong>（政治上层建筑）：国家制度、立法司法制度、行政制度；国家政权机构、政党、军队、法庭、监狱等等。</li></ul></li><li>观念上层建筑和政治上层建筑的关系：政治上层建筑是在一定意识形态指导下建立起来的，是统治阶级意志的体现；政治上层建筑一旦形成，就成为一种现实的力量，影响并制约着人们的思想理论观点。</li><li>在整个上层建筑中，<strong>政治居主导地位，国家政权是核心地位</strong>。<ul><li>国家不是从来就有的，它是社会发展到一定历史阶段的产物</li><li>国家是阶级矛盾不可调和的产物</li><li>国家的实质是一个阶级统治另一个阶级的工具</li></ul></li><li><strong>国体</strong>是指社会各阶级在国家中的地位，它表明国家政权掌握在哪个阶级手里，哪个阶级是统治阶级，哪个阶级是被统治阶级，这是决定国家阶级性质的方面。（我国的国体是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家）</li><li><strong>政体</strong>是指统治阶级实现其阶级统治的具体组织形式，也就是政权构成形式。它表明统治阶级采取什么样的形式去组织自己的政权，实现自己的统治。（我国的政体是人民代表大会制度）</li><li>国体和政体的关系：一般来说。<strong>国体决定政体，政体服从于国体</strong>；政体为国体服务，并对保证国家的性质起重要作用。</li></ul></li><li>经济基础与上层建筑是辩证统一的：<ul><li>首先，<strong>经济基础决定上层建筑</strong>。</li><li>其次，<strong>上层建筑对经济基础具有反作用</strong>。</li></ul></li><li>经济基础与上层建筑相互作用构成二者的矛盾运动。</li><li>经济基础和上层建筑之间的内在联系构成了上层建筑一定要适合经济基础状况的规律。</li></ol></li><li>交往：指在一定历史条件下的现实的个人、群体、阶级、民族、国家之间在物质和精神上的相互往来、相互作用、彼此联系的活动。<ol type="1"><li>交往分为：<ul><li>物质交往：是指人们在物质生产实践中发生的交往，物质产品是其交往内容。</li><li>精神交往：是指一定的历史条件下，人们在涉及思想、意识、观念、情感和情绪等精神性的领域中进行的交往。</li></ul></li><li>交往对社会生活有着重要的影响：<ul><li>第一，促进生产力的发展。</li><li>第二，促进社会关系的进步。</li><li>第三，促进文化的发展与传播。</li><li>第四，促进人的全面发展。</li></ul></li></ol></li><li>世界历史的形成与发展<ul><li>生产方式的发展变革是世界历史形成和发展的基础。</li><li>普遍交往是世界历史的基本特征。</li></ul></li><li>社会进步与人发展<ol type="1"><li>社会进步表现：<ul><li>一是社会形态从低级到高级的发展。</li><li>二是同一社会形态内部的发展。</li></ul></li><li>社会进步作用：<ul><li>社会进步促进<strong>人的发展</strong>。<ul><li>人的发展：人的依赖关系占统治地位的阶段、以物的依赖关系为基础的人的独立性的阶段、自由个性的阶段。</li></ul></li><li>社会进步推动<strong>人类解放</strong>。</li></ul></li><li>社会形态是关于社会运动的具体形式、发展阶段和不同质态的范畴，是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体。<ul><li>社会形态包括社会的经济形态、政治形态和意识形态，是三者的历史的、具体的统一。经济形态是社会形态的基础。</li></ul></li></ol></li><li>社会形态更替的<strong>统一性</strong>和<strong>多样性</strong>：<ul><li>原始社会、奴隶社会、封建社会、资本主义社会、共产主义社会五种社会形态的依次更替，是社会历史运动的一般过程和一般规律，表现了社会形态更替的统一性。</li><li>就某一国家或民族的社会发展的历程而言，社会形态的更替具有种种复杂情况和特点，体现了社会形态更替形式的多样性。</li></ul></li><li>社会形态更替的<strong>必然性</strong>与<strong>选择性</strong>：<ul><li>社会形态发展的统一性与多样性，根源于社会发展的客观必然性与人们的历史选择性相统一的过程。</li><li>人们的历史选择性：<ul><li>第一，社会发展的必然性造成了一定历史阶段社会发展的基本趋势，为人们的历史选择提供了基础、范围和可能性空间。</li><li>第二，社会形态更替的过程也是一个主观能动性和客观规律性相统一的过程。</li><li>第三，人们的历史选择性归根结底是人民群众的选择性。</li></ul></li></ul></li><li>文明：是人类创造的所有物质成果、精神成果和制度成果的总和，是标志社会进步程度的范畴，反映了人类社会实践的积极成果。</li></ol><h2 id="第二节-社会历史发展的动力">第二节 社会历史发展的动力</h2><ol type="1"><li><strong>社会基本矛盾是社会发展的根本动力</strong><ul><li>生产力和生产关系、经济基础和上层建筑的矛盾是社会基本矛盾。</li><li>社会基本矛盾在历史发展中的作用：<ul><li>首先，生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量。</li><li>其次，社会基本矛盾特别是生产力和生产关系的矛盾，决定着社会中其他矛盾的存在和发展。</li><li>最后，社会基本矛盾具有不同的表现形式和解决方式，并从根本上影响和促进社会形态的变化和发展。</li></ul></li></ul></li><li>社会基本结构<ol type="1"><li>经济结构<ul><li>广义：生产方式，包含生产力和生产关系。</li><li>狭义：经济关系或经济制度。</li></ul></li><li>政治结构：政治上层建筑</li><li>观念结构：观念上层建筑</li></ol></li><li>社会基本矛盾是其他一切社会矛盾的根源，规定和制约着社会主要矛盾的存在和发展，<strong>社会主要矛盾是社会基本矛盾的具体体现</strong>。<ul><li>社会主要矛盾不是一成不变的，它在一定条件下会发生转变化：<ul><li>一是社会主要矛盾双方的内容发生变化；</li><li>二是矛盾地位发生变化。</li></ul></li></ul></li><li><strong>阶级斗争是阶级社会发展的直接动力</strong>。<ul><li>阶级斗争是阶级利益根本冲突的对抗阶级之间的对立和斗争。</li><li>阶级斗争根源于阶级之间物质利益的根本对立，根源于社会经济关系的冲突。</li><li>阶级斗争的推动作用突出表现在社会形态的更替中（推翻反动阶级）。也表现在统一社会形态的量变过程中（反动统治阶级做出某些让步）。</li></ul></li><li>革命或狭义的社会革命，是阶级斗争的最高形式，其实质是革命阶级推翻反动阶级的统治，用新的社会制度代替旧的社会制度。根源于社会基本矛盾的尖锐化。<ul><li>革命对社会发展的作用：<ul><li>革命是实现社会形态更替的重要手段和决定性环节。</li><li>革命能充分发挥人民群众创造历史的积极性和伟大作用。</li><li>革命斗争能够极大地教育和锻炼包括革命阶级在内的广大人民群众。</li></ul></li></ul></li><li><strong>马克思主义的阶级分析方法</strong>是认识阶级社会的科学方法。<ul><li>在认识和处理矛盾时，要严格区分阶级矛盾和非阶级矛盾、对抗阶级之间的矛盾和非对抗阶级之间的矛盾，以及敌我矛盾和人民内部矛盾。</li></ul></li><li>革命和改革区别：<ul><li>社会革命：适用于解决现存的<strong>社会基本制度</strong>问题，把生产力从已经不能容纳它的旧的生产关系解放出来。</li><li>改革：改革适用于解决现存的<strong>社会体制</strong>存在的问题，在不改变社会基本制度的前提下，对生产关系和上层建筑的某些方面和环节进行变革，从而促进生产力发展和社会进步。</li></ul></li><li><strong>科技革命是推动经济和社会发展的强大杠杆</strong>。<ul><li>每次科技革命，都不同程度地引起了生产方式、生活方式和思维方式的深刻变化和社会的巨大变化：<ul><li>首先，对生产方式产生了深刻影响。<ul><li>其一，改变了社会生产力的构成要素。</li><li>其二，改变了人们的劳动形式。</li><li>其三，改变了社会经济结构，特别是导致产业结构发生变革。</li></ul></li><li>其次，对生活方式产生了巨大影响。</li><li>最后，促进了思维方式的变革。</li></ul></li></ul></li><li>文化在社会发展中的作用：<ul><li>第一，文化为社会发展提供思想指引。</li><li>第二，文化为社会发展提供精神动力。</li><li>第三，文化为社会发展提供凝聚力量。</li></ul></li></ol><h2 id="第三节-人民群众在历史发展中的作用">第三节人民群众在历史发展中的作用</h2><ol type="1"><li>唯物史观和唯心史观在历史创造者问题上根本对立：<ul><li>唯心史观：<strong>英雄史观</strong></li><li>唯物史观：<strong>群众史观</strong></li></ul></li><li>英雄史观产生的原因：<ul><li>认识根源上：人们停留在历史的表象上，把活跃在历史前台的少数英雄人物的作用尤其是他们意识的作用加以夸大人并绝对化。</li><li>社会历史根源上：英雄史观的产生同社会生产力水平较低，大多数人从事物质资料的生产活动，少数人从事政治统治、垄断精神生活有关。</li><li>阶级根源上：剥削阶级的思想家为了维护本阶级的利益，需要宣扬唯心史观。</li></ul></li><li>唯物史观在考察历史创造者问题时坚持了几点原则：<ul><li>首先，唯物史观立足于<strong>现实的人及其本质</strong>来把握历史的创造者</li><li>其次，唯物史观立足于<strong>整体的社会历史过程</strong>来探究历史创造者问题</li><li>再次，唯物史观从<strong>社会历史发展的必然性</strong>入手来考察和说明历史创造者及其活动</li><li>最后，唯物史观从<strong>人与历史关系的不同层次</strong>上考察人们历史活动的作用及其性质</li></ul></li><li><strong>人民群众是历史的创造者</strong>。<ul><li>人民群众在创造历史过程中的决定作用：<ul><li>人民群众是社会<strong>物质</strong>财富的创造者。</li><li>人民群众是社会<strong>精神</strong>财富的创造者。</li><li>人民群众是社会<strong>变革</strong>的决定力量。</li></ul></li><li>人民群众创造历史的作用同社会基本矛盾运动推动社会前进的过程相一致。</li><li>人民群众创造历史的活动要受到一定社会历史条件的制约：<ul><li>经济条件对于人民群众的创造活动有着首要的、决定性的影响。</li><li>政治条件对人民群众的创造活动也具有直接的影响。</li><li>精神文化条件也是制约人民群众创造活动的重要因素。</li></ul></li></ul></li><li>无产阶级政党的群众路线<ul><li><strong>马克思主义群众观点</strong>：<ul><li>坚信人民群众自己解放自己的观点</li><li>全心全意为人民服务的观点</li><li>一切向人民群众负责的观点</li><li>虚心向人民群众学习的观点</li></ul></li><li><strong>群众路线是我们党的生命线和根本工作路线</strong>，也是我们党的优良传统。</li><li>群众路线是群众观点的具体应用，即<strong>一切为了群众，一切依靠群众，从群众中来，到群众中去</strong>。</li><li>群众路线的实质，就在于充分相信群众，坚决依靠群众，密切联系群众，全心全意为人民群众服务。</li><li>群众路线重要方面：<ul><li>一是领导和群众相结合，</li><li>二是一般号召和个别指导相结合。</li></ul></li></ul></li><li>群众、阶级、政党、领袖的关系：<ul><li>首先，群众是划分为阶级的。</li><li>其次，阶级通常是由政党领导的。</li><li>最后，政党是由领袖来主持的。</li></ul></li></ol><h1 id="第四章-资本主义的本质及其规律">第四章资本主义的本质及其规律</h1><h2 id="第一节-商品经济和价值规律">第一节 商品经济和价值规律</h2><ol type="1"><li>商品经济发展：<ul><li>简单商品经济：以生产资料私有制和个体劳动为基础</li><li>发达商品经济/资本主义商品经济：以生产资料私有制和雇佣劳动为基础。</li><li>商品经济是以交换为目的而进行生产的经济形式，是一定社会历史条件的产物。</li><li>商品经济产生的社会历史条件：<ul><li>一是存在社会分工。</li><li>二是生产资料和劳动产品属于不同的所有者。</li></ul></li></ul></li><li>商品是用来交换的能够满足人们某种需要的劳动产品，具有使用价值和价值两个因素，是使用价值和价值的矛盾统一体，<ul><li><strong>使用价值</strong>：是指商品能满足人们某种需要的有用性，反映的是人与自然之间的物质关系，是商品的<strong>自然属性</strong>，是<strong>一切劳动产品所共有的属性</strong>。<ul><li><strong>使用价值构成社会财富的物质内容</strong>。</li><li><strong>使用价值是交换价值的物质承担者</strong>。</li><li><strong>使用价值是价值的物质承担者</strong>。</li></ul></li><li><strong>交换价值</strong>：首先表现为一种使用价值同另一种使用价值相交换的量的关系或比例。决定商品交换的比例的，不是商品的使用价值，而是价值。</li><li><strong>价值</strong>：是凝结在商品中的无差别的一般人类劳动，即人类脑力和体力的耗费。<strong>价值是商品所特有的社会属性</strong>。<ul><li>价值是交换价值的基础，交换价值是价值的表现形式。</li></ul></li><li>商品的价值和使用价值是对立统一的关系：<ul><li>对立性：商品的使用价值和价值是相互排斥的，二者不可兼得。</li><li>统一性：商品必须同时具有使用价值和价值两个因素。使用价值是价值的物质承担者；价值寓于使用价值之中。</li></ul></li></ul></li><li>劳动的二重性：生产商品的劳动可区分为<strong>具体劳动和抽象劳动</strong>。<ul><li>具体劳动是指生产一定使用价值的具体形式的劳动，马克思也称之为有用劳动。</li><li>抽象劳动是指撇开一切具体形式的、无差别的一般人类劳动，即人的体力和脑力消耗。</li><li>生产商品的具体劳动形成商品的使用价值，抽象劳动形成商品的价值。</li><li><strong>劳动的二重性决定了商品的二因素</strong>。</li><li>具体劳动和抽象劳动也是对立统一的关系：<ul><li>一方面，具体劳动和抽象劳动不是各自独立存在的两种劳动或两次劳动，它们在时间上和空间上是统一的，是商品生产者的同一劳动过程的不可分割的两个方面</li><li>另一方面，具体劳动所反映的是人与自然的关系，它是<strong>劳动的自然属性</strong>，而抽象劳动所反映的是商品生产者的社会关系，它是<strong>劳动的社会属性</strong>。</li></ul></li></ul></li><li>商品价值量的决定<ul><li>商品的价值包括质的规定与量的规定两个方面：<ul><li>价值的<strong>质</strong>的规定回答的是价值的实体是什么。</li><li>价值的<strong>量</strong>的规定则回答价值的大小由什么决定和怎样决定。</li></ul></li><li>商品的价值是凝结在商品中的劳动，价值量是由生产商品所耗费的劳动量决定的，而劳动量则按照劳动时间来计量。</li><li><strong>决定商品价值量的是社会必要劳动时间</strong>。</li><li>社会必要劳动时间是在现有的社会正常的生产条件下，在社会平均的劳动熟练程度和劳动强度下制造某种使用价值所需要的劳动时间。</li></ul></li><li>货币是在长期交换过程中形成的固定充当一般等价物的商品。<ul><li><strong>货币职能</strong>：价值尺度、流通手段、贮藏手段、支付手段、世界货币</li><li><strong>价值尺度和流通手段是最基本的职能</strong>。</li><li>商品转换为货币为“商品的惊险的跳跃”。</li></ul></li><li><strong>价值规律</strong>：商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行。<ul><li>价值规律是商品生产和商品交换的基本规律。</li><li>在商品经济中，价值规律的表现形式是，商品的价格围绕商品的价值自发波动。</li><li>价值规律在市场配置资源过程中的作用表现在：<ul><li>第一，自发地调节生产资料和劳动力在社会各生产部门之间的分配比例。</li><li>第二，自发地刺激社会生产力的发展。</li><li>第三，自发地调节社会收入的分配。</li></ul></li><li>价值规律在对经济活动进行自发调节时，会产生一些消极的后果：<ul><li>其一，导致社会资源浪费。</li><li>其二，阻碍技术进步。</li><li>其三，导致收入两极分化。</li></ul></li></ul></li><li><strong>商品经济的基本矛盾，即私有制经济基础之上私人劳动和社会劳动的矛盾</strong>。<ul><li>私人劳动和社会劳动的矛盾构成私有制商品经济的基本矛盾，这一矛盾贯穿商品经济发展过程的始终，决定着商品经济的各种内在矛盾及其发展趋势：<ul><li>首先，私人劳动和社会劳动的矛盾决定着商品经济的本质及其发展过程。</li><li>其次，私人劳动和社会劳动的矛盾，是商品经济的其他一切矛盾的基础。</li><li>最后，私人劳动和社会劳动的矛盾决定着商品生产者的命运。</li></ul></li><li>私有制商品经济条件下商品世界的拜物教性质的产生的必然性：<ul><li>其一，劳动产品只有采取商品的形式才能进行交换，人类劳动的等同性只有采取同质的价值形式才能在交换中体现出来。</li><li>其二，劳动量只有采取价值量这一物的形式才能进行计算和比较。</li><li>其三，生产者的劳动关系的社会性质只有采取商品之间即物与物之间相交换的形式才能间接地表现出来，这就使人与人之间一定的社会关系被物与物的关系所掩盖，具有了拜物教性质。</li></ul></li></ul></li><li><strong>马克思劳动价值论</strong>的理论和实践意义：<ul><li>第一，马克思劳动价值论扬弃了英国古典政治经济学的观点，为剩余价值论的创立奠定了基础。</li><li>第二，马克思劳动价值论揭示了私有制条件下商品经济的基本矛盾，为从物与物的关系背后揭示人与人的关系提供了理论依据。</li><li>第三，马克思劳动价值论揭示了商品经济的一般规律，对理解社会主义市场经济具有指导意义。</li></ul></li><li>深化对马克思劳动价值论的认识<ul><li>第一，深化对创造价值的劳动的认识，对生产性劳动作出新的界定。</li><li>第二，深化对科技人员、经营管理人员在社会生产和价值创造中所起到的作用的认识。</li><li>第三，深化对价值创造和价值分配关系的认识。</li></ul></li></ol><h2 id="第二节-资本主义经济制度">第二节 资本主义经济制度</h2><ol type="1"><li>简单商品公式和资本总公式<ul><li>简单商品公式：W-G-W，W 代表商品，G代表流通中的货币，表明商品流通的目的是获得使用价值。</li><li><strong>资本总公式</strong>：G-W-G’，G代表作为资本的货币，G’代表价值增殖后的货币，表明资本运动的一般目的是价值增值。</li></ul></li><li>劳动力的使用即劳动。<ul><li>劳动力成为商品，要具备两个基本条件：<ul><li>第一，劳动者是自由人，能够把自己的劳动力当作自己的商品来支配；</li><li>第二，劳动者没有任何生产资料，没有生活资料来源，因而不得不依靠出卖劳动力为生。</li></ul></li><li><strong>劳动力成为商品，标志着简单商品生产发展到资本主义商品生产的新阶段</strong>。</li><li><strong>劳动力商品的价值</strong> =劳动者自己及其家属所需要的生活资料的价值（历史和道德的因素）<ul><li>维持劳动者本人生存所必需的生活资料的价值</li><li>维持劳动者家属的生存所必需的生活资料的价值</li><li>劳动者接受教育和训练所支出的费用</li></ul></li><li><strong>劳动力商品的使用价值是价值的源泉</strong>，在消费过程中能够创造新的价值，并且这个新的价值比劳动力本身的价值更大。</li></ul></li><li>资本是可以带来剩余价值的价值。剩余价值是由雇佣工人的剩余劳动创造的。<ul><li>资本主义生产过程具有二重性：<ul><li>一方面是生产物质资料的<strong>劳动过程</strong>；</li><li>另一方面是生产剩余价值的过程，即<strong>价值增殖过程</strong>。</li><li>资本主义生产过程是劳动过程和价值增殖过程的统一。</li></ul></li><li>生产物质资料的劳动过程的基本要素：劳动者的劳动、劳动对象、劳动资料。</li><li>资本主义劳动过程特点：<ul><li>其一，工人在资本家的监督下劳动，他们的劳动隶属于资本家；</li><li>其二，劳动的成果或者产品全部归资本家所有。</li></ul></li><li>剩余价值就是雇佣工人在剩余劳动时间内创造的、被资本家无偿占有的超过劳动力价值的那部分新价值。</li></ul></li><li>资本主义生产的直接目的和决定性动机，就是无休止地采取各种方法获取尽可能多的剩余价值。这样一种不以人的意志为转移的客观必然性，就是<strong>剩余价值规律</strong>。<ul><li>根据资本在剩余价值生产中所起的不同作用，资本划分为：<ul><li>不变资本（C）：以生产资料形态存在的资本。原有价值转移，不发生增值。</li><li>可变资本（V）：用来购买劳动力的那部分资本。原有价值增值，产生剩余价值。</li></ul></li><li><strong>商品价值构成公式</strong>：W = C + V + M<ul><li>其中，C为不变资本，V为可变资本，M为剩余价值。</li></ul></li><li><strong>剩余价值率</strong>：M’ = M / V = 剩余价值 / 可变资本 =剩余劳动 / 必要劳动 = 剩余劳动时间 / 必要劳动时间</li></ul></li><li>生产剩余价值的两种基本方法：绝对剩余价值生产和相对剩余价值生产。<ul><li><strong>绝对剩余价值</strong>：<strong>指在必要劳动时间不变的条件下，由于延长劳动日的长度和提高劳动强度而生产的剩余价值。</strong></li><li><strong>相对剩余价值</strong>：<strong>指在工作日长度不变的条件下，通过缩短必要劳动时间而相对延长剩余劳动时间生产的剩余价值。</strong><ul><li><strong>相对剩余价值的生产是整个社会劳动生产率普遍提高的结果</strong>。全社会劳动生产率的提高是资本家追逐超额剩余价值的结果。</li><li>超额剩余价值是指企业由于提高劳动生产率而使商品的个别价值低于社会价值的差额。</li></ul></li></ul></li><li>把剩余价值转化为资本，或者说，<strong>剩余价值的资本化，就是资本积累</strong>。<ul><li><strong>资本主义简单再生产</strong>：资本家瓜分到剩余价值后，如果将其完全用于个人消费，则生产就在原有规模的基础上重复进行。<ul><li>资本主义简单再生产，不仅生产商品，不仅生产剩余价值，而且还生产和再生产资本关系本身：一方面是资本家，另一方面是雇佣工人。</li><li>资本主义简单再生产，就其实质而言，是物质资料再生产和资本主义生产关系再生产的统一。</li></ul></li><li><strong>资本主义的扩大再生产</strong>：资本家获得无偿占有的剩余价值后，并不是将其完全用于个人消费，而是将一部分转化为资本，用以购买追加的生产资料和劳动力，使生产在扩大的规模上重复进行。<ul><li><strong>资本积累是资本主义扩大再生产的源泉</strong>。资本积累的本质，就是<strong>资本家不断地利用无偿占有的工人创造的剩余价值来扩大自已的资本规模</strong>，从而进一步扩大和加强对工人的剥削和统治。</li></ul></li></ul></li><li>资本的构成：<ul><li>资本的<strong>技术构成</strong>：由生产的技术水平决定的生产资料和劳动力之间的比例叫做资本的技术构成。</li><li>资本的<strong>价值构成</strong>：从价值上看，资本可以分为不变资本和可变资本，这两部分资本价值之间的比例，叫做资本的价值构成。</li><li>资本的<strong>有机构成</strong>：一般来说，资本的技术构成决定资本的价值构成，技术构成的变化往往会引起价值构成的变化，而价值构成的变化通常反映着技术构成的变化。这种由资本的技术构成决定并反映技术构成变化的资本价值构成，叫做资本的有机构成。</li></ul></li><li>资本积聚是指个别资本通过剩余价值的资本化来增大资本的总量。<ul><li>资本积累是资本积聚的基础，资本积聚是资本积累的直接结果。</li><li>资本集中是指个别资本通过结合而形成的资本。</li><li>相对过剩人口形式：流动的过剩人口、潜在的过剩人口、停滞的过剩人口。</li></ul></li><li>资本循环周转<ul><li>产业资本的循环过程：<ul><li>第一个阶段：<strong>购买阶段</strong>，即生产资料和劳动力的购买阶段，产业资本执行<strong>货币资本</strong>的职能。</li><li>第二个阶段：<strong>生产阶段</strong>，即生产资料与劳动力按比例结合在一起从事资本主义生产的阶段，产业资本执行<strong>生产资本</strong>的职能。</li><li>第三个阶段：<strong>售卖阶段</strong>，即商品资本向货币资本的转化阶段，产业资本执行<strong>商品资本</strong>的职能。</li></ul></li><li>产业资本的运动基本前提条件：<ul><li>一是产业资本的三种职能形式必须在空间上并存。</li><li>二是产业资本的三种职能必须在时间上继起。</li></ul></li><li>产业资本的连续循环是流通过程和生产过程的统一，也是它的三种职能形式循环，即货币资本循环、生产资本循环和商品资本循环的统一。</li></ul></li><li>社会资本再生产的核心问题：社会总产品的实现问题，即社会总产品的价值补偿和实物补偿问题。<ul><li>社会生产两大部类：<ul><li>第一部类（I）由生产生产资料的部门所构成，其产品进入生产消费领域；</li><li>第二部类（II）由生产消费资料的部门所构成，其产品进入生活消费领域。</li></ul></li><li>社会总产品在实物上得到替换，在价值上实现补偿，客观上就要求两大部类内部各个产业部门之间和两大部类之间保持一定的比例关系。</li></ul></li><li><strong>马克思剩余价值论</strong>的意义：<ul><li>马克思通过分析剩余价值的生产、积累、流通以及分配，揭示了剩余价值的运动规律及其作用，创立了剩余价值理论。</li><li>剩余价值论深刻揭露了资本主义生产关系的剥削本质，阐明了资产阶级与无产阶级之间阶级斗争的经济根源，指出了无产阶级革命的历史必然性。</li><li>剩余价值论是马克思主义经济学说的核心内容和基石，是无产阶级反对资产阶级、揭示资本主义制度剥削本质的锐利武器。</li><li>由于唯物史观和剩余价值理论的发现，社会主义由空想变为科学。</li></ul></li><li><strong>资本主义基本矛盾：生产社会化和生产资料的私人占有之间的矛盾</strong>。<ul><li>生产过剩是资本主义经济危机的本质特征。</li><li>资本主义经济危机具有周期性，这是由资本主义基本矛盾运动的阶段性决定的。</li><li>社会资本再生产周期：危机（基本阶段）、萧条、复苏、高涨。</li></ul></li></ol><h2 id="第三节-资本主义上层建筑不考">第三节资本主义上层建筑（不考）</h2><h1 id="第五章-资本主义的发展及其趋势">第五章资本主义的发展及其趋势</h1><h2 id="第一节-垄断资本主义的形成与发展">第一节垄断资本主义的形成与发展</h2><ol type="1"><li>自由竞争引起生产集中和资本集中，生产集中和资本集中发展到一定阶段必然引起垄断，这是资本主义发展的客观规律。<ul><li>垄断是指少数资本主义大企业为了获得高额利润，通过相互协议或联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制。</li><li>垄断组织是指在一个或几个经济部门中占据垄断地位的大企业联合。</li></ul></li><li>垄断产生的原因：<ul><li>第一，当生产集中发展到相当高的程度，极少数企业就会联合起来，操纵和控制本部门的生产和销售，实行垄断，以获得高额利润。</li><li>第二，企业规模巨大，形成对竞争的限制，也会产生垄断。</li><li>第三，激烈的竞争、给竞争各方带来的损失越来越严重，为了避免两败俱伤，企业之间会达成妥协，联合起来，实行垄断。</li></ul></li><li>垄断是在自由竞争中形成的，是作为自由竞争的对立面产生的。但是，垄断并不能消除竞争，反而使竞争变得更加复杂和激烈。垄断条件下竞争的特点：<ul><li>第一，垄断没有消除产生竞争的经济条件。</li><li>第二，垄断必须通过竞争来维持。</li><li>第三，社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产全部包下来。</li></ul></li><li><strong>金融资本</strong>是由工业垄断资本和银行垄断资本融合在一起而形成的一种垄断资本。<ul><li><strong>金融寡头</strong>是指操纵国民经济命脉，并在实际上控制国家政权的少数垄断资本家或垄断资本家集团。</li><li>金融寡头在经济领域中的统治主要是通过“<strong>参与制</strong>”实现的。</li><li>金融寡头对国家机器的控制，主要是通过同政府的“<strong>个人联合</strong>”来实现的。</li></ul></li><li>垄断资本的实质在于获取垄断利润。<ul><li>垄断利润是垄断资本家凭借其在社会生产和流通中的垄断地位而获得的超过平均利润的高额利润。</li><li>垄断资本所获得的高额利润，归根到底来自无产阶级和其他劳动人民所创造的剩余价值。</li></ul></li><li>国家垄断资本主义的形成和发展不是偶然的，它是科技进步和生产社会化程度进一步提高的产物，是资本主义基本矛盾进一步尖锐化的必然结果。<ul><li>首先，社会生产力的发展，要求资本主义生产资料在更大范围内被支配，从而促进了国家垄断资本主义的产生。</li><li>其次，经济波动和经济危机的深化，要求国家垄断资本主义的产生。</li><li>最后，缓和社会矛盾，协调利益关系，要求国家垄断资本主义的产生。</li><li>国家垄断资本主义的主要形式：<ul><li>第一种是国家所有并直接经营的企业；</li><li>第二种是国家与私人共有、合营企业；</li><li>第三种是国家通过多种形式参与私人垄断资本的再生产过程；</li><li>第四种是宏观调节：宏观调节主要是国家运用财政政策、货币政策等经济手段，对社会总供给和总需求进行调节，以实现经济快速增长、充分就业、物价稳定和国际收支平衡的基本目标。</li><li>第五种是微观规制：微观规制则主要是国家运用法律手段规范市场秩序，限制垄断，保护竞争，维护社会公众的合法权益。</li></ul></li><li>国家垄断资本主义对资本主义经济发展产生的积极作用：<ul><li>首先，国家垄断资本主义的出现在一定程度上有利于社会生产力的发展。</li><li>其次，资本主义国家凌驾于私人垄断资本之上，代表整个垄断资产阶级的利益，调节经济过程和经济活动，这在一定范围内突破了私人垄断资本的狭隘界限。</li><li>再次，通过国家的收入再分配手段，劳动人民生活水平有所改善和提高。</li><li>最后，在国家垄断资本主义的参与和干预下，各主要资本主义国家的农业、工业、商业、通信业及交通运输业的现代化水平迅速提高，社会生产和社会生活的面貌改观，加快了国民经济的现代化进程。</li></ul></li><li>国家垄断资本主义并没有根本改变垄断资本主义的性质。<strong>国家垄断资本主义在本质上是资产阶级国家力量同垄断组织力量结合在一起的垄断资本主义</strong>。它在一定程度上促进生产力发展的同时，却加大了对劳动人民的剥削和掠夺，更好地保证了垄断资产阶级获得高额垄断利润，更有利于维护资本主义制度。</li></ul></li><li>金融自由化和金融创新是金融垄断资本形成的重要条件。</li><li>垄断资本向世界范围扩展<ol type="1"><li>垄断资本向世界范围扩展的原因：<ul><li>首先，将国内过剩的资本输出，以便在国外谋求高额利润</li><li>其次，部分技术转移，获取垄断优势，进而谋取高额利润</li><li>再次，争夺商品销售市场</li><li>最后，确保原材料和能源的可靠来源</li><li>垄断资本向世界范围扩展的形式：<ul><li>从输出的形式来看；<ul><li><strong>借贷资本输出</strong>：由资本主义国家的政府、银行、企业把资本贷给其他国家的政府、银行或企业。</li><li><strong>生产资本输出</strong>：在国外直接投资，独立创办企业，与国外资本合营，或者收购国外已有的企业。</li><li><strong>商品资本输出</strong>：把商品卖到世界各地，不断扩大市场，获取高额利润。</li></ul></li><li>从输出的主体来看：私人资本输出、国家资本输出。</li></ul></li></ul></li><li>垄断资本向世界范围扩展带来的影响：<ul><li>对资本输出国的影响：<ul><li>积极作用：<ul><li>资本输出为其带来了巨额利润，加速了资本积累，增强了垄断资本的实力</li><li>带动和扩大了商品输出，巩固和扩大了垄断资本的销售市场和投资场所</li><li>大大改善了国际收支状况</li><li>对发展中国家的经济命脉形成控制，进一步巩固和扩大了垄断优势地位</li></ul></li><li>消极作用：<ul><li>资本输出国可能出现产业空心化</li><li>资本输出国与发展中国家及其他发达国家之间的矛盾会加深</li></ul></li></ul></li><li>对资本输入国(主要是发展中国家)的影响：<ul><li>积极作用：<ul><li>吸收了经济发展所需要的资金，为经济发展创造了条件。</li><li>引进了比较先进的机器设备和工艺技术，同时培训了一批适应现代化生产需要的技术人员、熟练工人和经营管理人员。</li><li>利用外资技术，建立一批现代工业，改造老企业和旧设备，优化了产业结构</li><li>利用外资扩大生产，增加产品产量，提高产品质量，扩大出口，促进了对外贸易发展</li><li>推动了经济发展，增加就业机会，提高了收入水平。</li></ul></li><li>消极作用：<ul><li>付出了较大的经济代价以及环境污染、能源资源消耗的代价</li><li>产业调整与布局有可能受制于外资的投资战略</li><li>外来资本和跨国公司投资增加，冲击本国的民族工业，并影响到国民经济的控制器</li><li>债务负担加重，影响经济的持续稳定发展</li><li>对国际资本的依赖性增强，容易受到国际经济波动的影响。</li></ul></li></ul></li></ul></li></ol></li><li>列宁根据他所处时代的实践曾指出，<strong>资本主义发展到垄断资本主义，进而发展到帝国主义</strong>，便具有五个基本特征：<ul><li>垄断组织在经济生活中起决定作用；</li><li>在金融资本的基础上形成金融寡头的统治；</li><li>资本输出有了特别重要的意义；</li><li>瓜分世界的资本家国际垄断同盟已经形成；</li><li>最大资本主义列强已把世界上的领土分割完毕。<ul><li>这些特征集中体现了帝国主义的实质，即垄断资本凭借垄断地位，获取高额垄断利润。</li></ul></li></ul></li><li><strong>经济全球化</strong>是指国际经济发展中的这样一种趋势，即在生产不断发展、科技加速进步、社会分工和国际分工不断深化、生产的社会化和国际化程度不断提高的情况下，世界各国、各地区的经济活动越来越超出一国和地区的范围而相互紧密地联系在一起。<ul><li>经济全球化的表现：<strong>生产全球化</strong>、<strong>贸易全球化</strong>、<strong>金融全球化</strong></li><li>经济全球化的动因：<ul><li>首先，科学技术的进步和生产力的发展为经济全球化提供了坚实的物质推动力基础和根本的推动力。</li><li>其次，跨国公司的发展为经济全球化提供了适宜的企业组织形式。</li><li>最后，各国经济体制的变革和国际经济组织的发展是经济全球化的体制与组织保障。</li></ul></li><li>经济全球化的影响：<ul><li>发达资本主义国家是经济全球化的主要受益者。</li><li>经济全球化对发展中国家也具有积极的影响。<ul><li>第一，经济全球化为发展中国家提供了先进技术和管理经验。</li><li>第二，经济全球化为发展中国家提供更多的就业机会。</li><li>第三，经济全球化推动发展中国家国际贸易发展。</li></ul></li><li><strong>经济全球化是一把双刃剑</strong>。<ul><li>第一，发达国家与发展中国家在经济全球化过程中的地位和收益不平等、不平衡。</li><li>第二，加剧了发展中国家资源短缺和环境污染恶化。</li><li>第三，一定程度上增加了经济风险。</li></ul></li></ul></li></ul></li></ol><h2 id="第二节-正确认识当代资本主义的新变化">第二节正确认识当代资本主义的新变化</h2><ol type="1"><li>当代资本主义的新变化：<ul><li>生产资料所有制的变化：<ul><li>国家资本所有制形成并发挥重要作用；</li><li>法人资本所有制崛起并成为居主导地位的资本所有制形式。</li></ul></li><li>劳资关系和分配关系的变化：资本家及其代理人采取的缓和劳资关系的激励制度主要有：<ul><li>其一，职工参与决策；</li><li>其二，终身雇佣；</li><li>其三，职工持股。</li></ul></li><li>社会阶级、阶层结构的变化：<ul><li>一是传统的资本家的地位和作用已经发生很大变化。</li><li>二是高级职业经理成为大公司经营活动的实际控制者。</li><li>三是知识型和服务型劳动者的数重不断增加，劳动方式发生了新变化。</li></ul></li><li>经济调节机制和经济危机形态的变化</li><li>政治制度的变化：<ul><li>首先，政治制度出现多元化的趋势，公民权利有所扩大。</li><li>其次，重视并加强法制建设。</li><li>最后，改良主义政党在政治舞台上的影响日益扩大，成为战后西方资本主义国家政治生活中非常引人注目的现象。</li></ul></li></ul></li><li>当代资本主义发生新变化的原因是多方面的，最主要的有：<ul><li>首先，<strong>科学技术</strong>革命和生产力的发展，是资本主义变化的根本推动力量。</li><li>其次，<strong>工人阶级</strong>争取自身权力和利益斗争的作用，是推动资本主义变化的重要力量。</li><li>再次，<strong>社会主义制度初步显示的优越性</strong>对资本主义产生了一定影响。</li><li>最后，主张<strong>改良主义的政党</strong>对资本主义制度的改革，也对资本主义的变化发挥了重要作用。</li></ul></li><li>当代资本主义变化的新特征：<ul><li>第一，科技创新加速了资本主义生产方式的变化：<ul><li>产业结构的调整：形成了以去工业化、经济虚拟化、金融化为主要特征的产业结构模式，一般制造业占比逐渐下降：</li><li>生产组织和劳动形式的变化：以数据的生产、管理、服务等在线化和智能化为主的数字劳动在生产中的地位愈加突出。</li><li>新经济形态的出现：数字经济、智能经济、共享经济。</li></ul></li><li>第二，国际金融垄断资本主义影响日益显现。<ul><li>金融垄断寡头化。</li><li>金融垄断国际化。</li><li>经济虚拟化、产业空心化。</li></ul></li><li>第三，社会阶级层级结构呈现复杂性、多样化。<ul><li>资产阶级内部结构日趋复杂<ul><li>最高层是极少数国际垄断寡头阶层。</li><li>第二层是与前者相联合，以能源、军工、高科技利益集团为主体的国际金融–产业垄断寡头阶层</li><li>占据各产业垄断地位的产业垄断资本家阶层</li><li>由经理资本家、食利者阶层、中小企业资本家构成的一般资本家阶层</li></ul></li><li>工人人阶级内部也逐渐分化<ul><li>“知识工人”数量和增长速度超过“非知识工人”，</li><li>工人阶级内部因技能、收入等方面的差异逐渐分化。</li></ul></li></ul></li><li>第四，发达资本主义国家凭借经济、科技、文化传播等超级优势，在世界范围推行霸权主义和强权政治。</li></ul></li></ol><h2 id="第三节-资本主义的历史地位和发展趋势">第三节资本主义的历史地位和发展趋势</h2><ol type="1"><li>资本主义的历史地位：<ul><li>与封建社会相比，资本主义显示了巨大的历史进步性：<ul><li>资本主义将科学技术转变为强大的生产力。</li><li>资本追求剩余价值的内在动力和竞争的外在压力推动了社会生产力的迅速发展。</li><li>资本主义的意识形态和政治制度作为上层建筑在战胜封建社会自给自足的小生产的生产方式，保护、促进和完善资本主义生产方式方面起着重要作用，从而推动了社会生产力的迅速展，促进了社会进步。</li></ul></li><li>然而，资本主义的历史进步性并不能掩盖其自身的局限性，其表现是：<ul><li>资本主义的基本矛盾阻碍社会生产力的发展。</li><li>资本主义制度下财富占有两极分化，引发经济危机。</li><li>资产阶级支配和控制资本主义经济和政治的发展和运行，不断激化社会矛盾和冲突。</li></ul></li></ul></li><li><strong>资本主义的内在矛盾决定了资本主义必然被社会主义所代替</strong>：<ul><li>资本主义基本矛盾“包含着现代的一切冲突的萌芽”</li><li>资本积累推动资本主义基本矛盾不断激化并最终否定资本主义自身。</li><li>国家垄断资本主义是资本社会化的更高形式，将成为社会主义的前奏。</li><li>资本主义社会存在着资产阶级和无产阶级两大阶级之间的矛盾和斗争。</li></ul></li></ol><h1 id="第六章-社会主义的发展及其规律">第六章社会主义的发展及其规律</h1><h2 id="第一节-社会主义五百年的历史进程">第一节社会主义五百年的历史进程</h2><ol type="1"><li>社会主义从空想到科学<ul><li>空想社会主义发展阶段：<ul><li>16-17世纪的<strong>早期空想社会主义</strong></li><li>18世纪的<strong>空想平均共产主义</strong></li><li>19世纪初期<strong>批判的空想社会主义</strong></li></ul></li><li>开山之作：1516年托马斯·莫尔所的《乌托邦》</li><li>空想社会主义理论的<strong>意义</strong>：<ul><li>空想社会主义对资本主义旧制度的辛辣批判，包含着许多集中要害的见解；对社会主义新制度的描绘，闪烁着天才的火花。</li><li>作为一种批判、否定资本主义的思潮，空想社会主义是早期无产阶级意识和利益的先声，反映了早期无产阶级迫切要求改造现存社会、建立理想的新社会的愿望。</li><li>空想社会主义“提供了启发工人觉悟的极为宝责的饲料”，但是不具备科学的和实践的品格。</li></ul></li><li>空想社会主义的<strong>局限性</strong>：<ul><li>没有指出社会发展的真正出路。</li><li>没有阐明资本主义雇佣制的本质。</li><li>没有发现资本主义发展规律。</li><li>没有找到成为新社会的创造者的社会力量。</li></ul></li><li>科学社会主义：<strong>唯物史观和剩余价值学说</strong></li></ul></li><li>马克思、恩格斯在<strong>揭示人类社会发展一般规律和资本主义发展特殊规律</strong>的基础上，科学论证了<strong>社会主义代替资本主义的历史必然性</strong>，阐明了<strong>无产阶级的历史使命</strong>，提出了<strong>无产阶级革命斗争的战略策略</strong>，科学预见了未来社会的<strong>基本特征</strong>，提出了<strong>从资本主义社会向共产主义社会过渡时期的理论</strong>，创立了<strong>科学社会主义学说</strong>，从根本上超越了空想社会主义，实现了社会主义从空想到科学的伟大飞跃。</li><li>社会主义在中国焕发出蓬勃生机<ul><li>中国共产党领导的社会主义事业经过了从夺取新民主主义革命伟大胜利到完成社会主义革命和推进社会主义建设、进行改革开放和社会主义现代化建设、开创中国特色社会主义新时代的发展过程，在百年奋斗中不断发展壮大，在21世纪焕发出蓬勃生机。</li><li>邓小平：“把马克思主义的普遍真理同我国的具体实际结合起来，走自己的道路，建设有中国特色的社会主义，这就是我们总结长期历史经验得出的基本结论。”</li><li>科学社会主义在中国的成功实践和理论发展，使世界范围内社会主义和资本主义两种社会制度、两种意识形态的历史演进及其较量，发生了有利于社会主义的重大转变。中国特色社会主义高高举起科学社会主义旗帜，向世界表明科学社会主义在21世纪的中国焕发出新的蓬勃生机，突出展现了社会主义的优越性。</li></ul></li></ol><h2 id="第二节-科学社会主义的基本原则不考">第二节科学社会主义的基本原则（不考）</h2><h2 id="第三节-在实践中探索社会主义的发展规律">第三节在实践中探索社会主义的发展规律</h2><ol type="1"><li>社会主义建设过程的长期性<ul><li>第一，<strong>生产力发展状况</strong>的制约。</li><li>第二，<strong>经济基础和上层建筑发展状况</strong>的制约。</li><li>第三，<strong>国际环境</strong>的严峻挑战。</li><li>第四，马克思主义执政党<strong>对社会主义发展道路的探索和对社会主义建设规律的认识</strong>，需要一个长期的过程。</li></ul></li></ol><h1 id="第七章-共产主义崇高理想及其最终实现">第七章共产主义崇高理想及其最终实现</h1><h2 id="第一节-展望未来共产主义新社会">第一节展望未来共产主义新社会</h2><ol type="1"><li>预见未来社会的方法论原则<ul><li>在揭示人类社会发展一般规律的基础上指明社会发展的方向</li><li>在剖析资本主义社会旧世界中阐发未来新世界的特点</li><li>在社会主义社会发展中不断深化对未来共产主义社会的认识</li><li>立足于揭示未来社会的一般特征，而不作详尽的细节描绘</li></ul></li><li>共产主义社会的基本特征<ul><li>物质财富极大丰富，消费资料按需分配</li><li>社会关系高度和谐，人们精神境界极大提高<ul><li><strong>阶级</strong>将会消亡。</li><li><strong>国家</strong>将会消亡。</li><li><strong>战争</strong>将不复存在。</li><li><strong>三大差别</strong>消失：由于社会生产力的巨大发展，工业与农业、城市与乡村、脑力劳动与体力劳动的差别将归于消失。</li><li>不仅社会是和谐的，而且<strong>社会与自然</strong>之间也将达成和谐。</li><li>人们的<strong>精神境界</strong>将得到极大提高。</li></ul></li><li>实现每个人自由而全面的发展，人类从必然王国向自由王国的飞跃。<ul><li><strong>实现人的自由而全面的发展，是马克思主义追求的根本价值目标，也是共产主义社会的根本特征。</strong><ul><li>旧式分工的消除为人的自由而全面的发展创造条件。</li><li>自由时间的延长为人的自由而全面的发展提供了广阔的前景。</li><li>劳动不再是单纯的谋生手段，而成为“生活的第一需要”。</li></ul></li></ul></li></ul></li></ol><h2 id="第二节-实现共产主义是历史发展的必然趋势不考">第二节实现共产主义是历史发展的必然趋势（不考）</h2><h2 id="第三节-共产主义远大理想和中国特色社会主义共同理想不考">第三节共产主义远大理想和中国特色社会主义共同理想（不考）</h2>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>马克思主义基本原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <url>/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>胡易坤老师</em> 2024-2025学年春季学期教学内容进行整理，部分图片来自胡教授的PPT，若有侵权请联系删除。</p></blockquote><h1 id="quick-links">Quick Links</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5b4e0fea" role="button" aria-expanded="false" aria-controls="collapse-5b4e0fea">        <div class="fold-arrow">▶</div>考点跳转链接      </div>      <div class="fold-collapse collapse" id="collapse-5b4e0fea">        <div class="fold-content">          <ul><li><a href="#conversion-regex----nfa">Regex to NFA</a></li><li><a href="#conversion-nfa----dfa">NFA to DFA</a></li><li><a href="#dfa-simplification">DFA Simplification</a></li></ul><hr><ul><li><a href="#top-down-parsing">Top-Down Parsing</a><ul><li><a href="#recursive-descent-parsing">Recursive-DescentParsing</a></li><li><a href="#predictive-parsing">Predictive Parsing</a><ul><li><a href="#ll1-parsing">LL(1) Parsing</a></li></ul></li></ul></li><li><a href="#bottom-up-parsing">Bottom-Up Parsing</a><ul><li><a href="#shift-reduce-parsing-移位归约解析">Shift-ReduceParsing</a></li><li><a href="#operator-precedence-parsing-运算符优先解析">OPP</a></li><li><a href="#lr-parsing">LR Parsing</a><ul><li><a href="#lr0-parsing">LR(0) Parsing</a></li><li><a href="#slr1-parsing">SLR(1) Parsing</a></li><li><a href="#lr1-parsing">LR(1) Parsing</a></li><li><a href="#lalr1-parsing">LALR(1) Parsing</a></li></ul></li></ul></li></ul><hr><ul><li><a href="#first-and-follow">FIRST and FOLLOW</a></li><li><a href="#leading-and-trailing">LEADING and TRAILING</a></li><li><a href="#closure-and-goto">CLOSURE and GOTO</a></li><li><a href="#lr1s-closure-and-goto">LR(1)’s CLOSURE and GOTO</a></li></ul>        </div>      </div>    </div><h1 id="quick-check">Quick Check</h1>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-fea42ee7" role="button" aria-expanded="false" aria-controls="collapse-fea42ee7">        <div class="fold-arrow">▶</div>各类文法与解析方法      </div>      <div class="fold-collapse collapse" id="collapse-fea42ee7">        <div class="fold-content">          <ul><li><strong>LL(1) Grammar</strong><ul><li>L: 从左到右扫描输入；L：最左派生；1：提前看一个输入符号</li><li>无左递归和左因子</li><li><span class="math inline"><strong>A</strong> → <strong>α</strong>&nbsp;|&nbsp;<strong>β</strong></span>表示两个不同的产生式，则<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>和 <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>是互不相交的集合<ul><li>二者不会同时派生以<span class="math inline"><strong>a</strong></span>开头的字符串</li><li>至多一个<span class="math inline"><strong>α</strong></span>和<span class="math inline"><strong>β</strong></span>可以派生空字符串</li></ul></li><li>如果<span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>，则<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>和<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>是互不相交的集合</li></ul></li><li><strong>LL(1) Parsing</strong><ul><li>提取左因子</li><li>消除直接左递归</li><li>计算<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong></span>和<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong></span></li><li>构造预测分析表（列为终结符，行为非终结符）</li><li>从Start Symbol开始预测/或使用栈和输入缓冲区进行预测分析<ul><li>查表（最左侧非终结符，最左侧未匹配输入符号）作为派生的产生式进行派生</li><li>若使用栈和输入缓冲区，则<ul><li>若栈顶符号为终结符且与输入符号匹配，则出栈并将输入指针后移</li><li>若栈顶符号为非终结符，则查表（栈顶符号，输入指针对应符号）得到派生的产生式，将栈顶符号出栈并将产生式右侧符号逆序入栈</li><li>直到栈为空，输入指针指向<span class="math inline">$</span>，则接受输入</li></ul></li></ul></li></ul></li><li><strong>OG Grammar（算符文法）</strong><ul><li>任意生成式不含两个相邻的非终结符</li><li>不含空生成式</li></ul></li><li><strong>OPP Grammar（算符优先文法）</strong><ul><li>首先满足OG Grammar的要求</li><li>任意两个终结符号对（有序）之间一定满足唯一的优先级关系</li></ul></li><li><strong>OPP Parsing</strong><ul><li>计算<span class="math inline"><strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong></span>和<span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong></span></li><li>构造优先级关系表</li><li>使用栈和输入缓冲区进行运算符优先解析/或使用优先级爬升法<ul><li>若栈顶终结符号优先级 &lt;· / =· 输入符号优先级，则移进</li><li>若栈顶终结符号优先级 &gt;· 输入符号优先级，则归约</li></ul></li></ul></li><li><strong>LR(0) Grammar</strong><ul><li>L:从左到右扫描输入；R：最右派生，最左归约；0：提前看一个输入符号</li><li>任一项集的状态转移不含归约-归约或移进-归约冲突</li></ul></li><li><strong>LR(0) Parsing</strong><ul><li>扩展文法</li><li>通过<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>和<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong></span>构造LR(0)项集族</li><li>构造LR(0)分析表（列为输入符号，行为状态）</li><li>使用栈和输入缓冲区进行LR(0)解析<ul><li>查表，（栈顶，输入符号）为s n，则移进并push状态n到栈顶，</li><li>若为rm，则用第m条产生式进行归约，pop栈顶的符号数目等于产生式右侧符号数目，查（栈顶符号，产生式左侧符号）为n，则push状态n到栈顶</li><li>若为ACCEPT，则接受输入</li></ul></li></ul></li><li><strong>SLR(1) Grammar</strong><ul><li>任一项集的状态转移不含归约-归约或移进-归约冲突<ul><li>LR(0)项目集中存在归约-归约冲突时，两个<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong></span>集的交集为空</li><li>LR(0)项目集中存在移进-归约冲突时，移进的终结符号不在归约的<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong></span>集中</li></ul></li></ul></li><li><strong>SLR(1) Parsing</strong><ul><li>扩展文法、构造集族同LR(0)</li><li>构造SLR(1)分析表时：<ul><li>对<span class="math inline"><strong>A</strong> → <strong>β</strong>⋅</span>归约时, 只对<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>中的终结符进行归约</li><li>对<span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong><sup><strong>′</strong></sup></span>赋值ACCEPT时, 只对<span class="math inline">$</span>接受</li></ul></li><li>使用栈和输入缓冲区进行SLR(1)解析</li></ul></li><li><strong>LR(1) Grammar</strong><ul><li>L:从左到右扫描输入；R：最右派生，最左归约；1：提前看一个输入符号</li><li>LR(1)的项由两部分组成：LR(0)的项和一个lookahead符号</li><li>任一项集的状态转移不含归约-归约或移进-归约冲突<ul><li>无归约-归约冲突：同一状态下如果有多个归约，则前瞻符号不相交</li><li>无移进-归约冲突：同一状态下如果同时有移进和归约，则移进的终结符号不在归约的前瞻符号中</li></ul></li></ul></li><li><strong>LR(1) Parsing</strong><ul><li>扩展文法</li><li>通过<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>和<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong></span>构造LR(1)项集族</li><li>构造LR(1)分析表时：<ul><li>对<span class="math inline">[<strong>A</strong> → <strong>β</strong>⋅, <em>a</em>]</span>归约时, 只对<span class="math inline"><strong>a</strong></span>进行归约</li><li>对<span class="math inline">[<strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅, $]</span>赋值ACCEPT时, 只对<span class="math inline">$</span>接受</li></ul></li><li>使用栈和输入缓冲区进行LR(1)解析</li></ul></li><li><strong>LALR(1) Grammar</strong><ul><li>LA: LookAhead；L:从左到右扫描输入；R：最右派生，最左归约；1：提前看一个输入符号</li><li>LALR(1)的项集族是LR(1)的项集族的同心集合并</li><li>任一项集的状态转移不含归约-归约或移进-归约冲突</li></ul></li><li><strong>LALR(1) Parsing</strong><ul><li>扩展文法、构造集族同LR(0)作为心</li><li>对每个状态的初始项的心，用占位符#作为前瞻符号，通过闭包计算自发生成的前瞻符号和传递关系</li><li>对于传递关系，保留每个状态的内核项，构造传播表</li><li>根据传播表和自发生成的前瞻符号，通过若干轮传播得到每个心最终对应的前瞻符号，得到归约内核项的[心，前瞻符号(若干个)]对</li><li>构造LALR(1)分析表，与LR(1)相同</li><li>使用栈和输入缓冲区进行LALR(1)解析</li></ul></li></ul>        </div>      </div>    </div><h1 id="ch1-intro">Ch1 Intro</h1><h2 id="编译流程">编译流程</h2><p><img src="image-1.png" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>解释器 vs.&nbsp;编译器 (Interpreter vs.&nbsp;Compiler)<ul><li>解释器方便错误诊断 (Error Diagnosis)</li><li>编译器得到的代码更加高效 <img src="image-2.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h3 id="编译器">编译器</h3><p><img src="image.png" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>前端：词法分析(Lexical Analysis)、语法分析(SyntaxAnalysis)、语义分析(Semantic Analysis)、中间代码生成(Intermediate CodeGeneration)</li><li>后端：代码优化(Optimization)、目标代码生成(Code Generation)</li></ul><h2 id="词法分析lexical-analysis">词法分析：Lexical Analysis</h2><ul><li>Lexical Analysis: Scanning （词法分析：扫描）<ul><li>Lexical Analyzer: Scanner （词法分析器：扫描器）</li><li>Recognize Words (Lexemes) -&gt; Tokens &amp; Symbol Table（识别单词（词素）-&gt; 生成标记和符号表）</li><li>Token: &lt;token-name, attribute-value (opt.)&gt;<ul><li>token-name: id, number, keywords, operators, etc.（标记名：标识符、数字、关键字、运算符等）</li><li>attribute-value: a pointer to the symbol table（属性值：指向符号表的指针）</li></ul></li></ul></li></ul><h2 id="语法分析syntax-analysis">语法分析：Syntax Analysis</h2><ul><li>Syntax Analysis: Parsing （语法分析：解析）<ul><li>Syntax Analyzer: Parser （语法分析器：解析器）</li><li>Produce the Grammatical Structure （生成语法结构）<ul><li>The Relationships among Tokens （标记之间的关系）</li><li>Tree-like Intermediate Representation （树状中间表示）</li></ul></li><li>Parse Tree （解析树）<ul><li>Parser generates the Parse Tree, from which produces the Syntax Tree（解析器生成解析树，从中生成语法树）</li></ul></li><li>Syntax Tree: Simplified Parse Tree （语法树：简化的解析树）<ul><li>Interior Node: Operation （内部节点：操作）</li><li>Children: Arguments of the Operation （子节点：操作的参数）</li></ul></li></ul></li></ul><h2 id="词法分析-vs.-语法分析">词法分析 vs.&nbsp;语法分析</h2><ul><li>做着相似的事情：处理字符串</li><li>词法分析 (Scanning)：拆分字符串成Lexemes，并抽象成Tokens</li><li>语法分析 (Parsing)：整理Tokens的逻辑关系</li></ul><h2 id="语义分析semantic-analysis">语义分析：Semantic Analysis</h2><ul><li>Semantic Analysis （语义分析）<ul><li>computing additional info needed for compilation（计算编译所需的附加信息）<ul><li>which is not regarded as syntax （这些信息不被视为语法）</li></ul></li><li>checking source code semantic consistency with the languagedefinition （检查源代码与语言定义的语义一致性）<ul><li>Type Checking （类型检查）</li></ul></li></ul></li></ul><h2 id="中间代码生成intermediate-code-generation">中间代码生成：IntermediateCode Generation</h2><ul><li>Intermediate Code Generation （中间代码生成）<ul><li>Intermediate Representations (IR), e.g., Syntax Tree, etc.（中间表示，例如语法树等）</li><li>Low-level or Machine-like IR （低级或类似机器的中间表示）<ul><li>LLVM-IR (LLVM, Clang), Gimple (GCC), etc.（LLVM-IR（LLVM，Clang），Gimple（GCC）等）</li><li>Three-address Code, with at Most Three Operands per Instruction（三地址码，每条指令最多三个操作数）</li><li>Static Single Assignment (SSA) （静态单赋值）<ul><li>Every variable is only assigned (defined) once and defined beforeused. （每个变量只能被赋值（定义）一次，并且在使用前必须定义。）</li></ul></li></ul></li></ul></li></ul><h2 id="优化optimization">优化：Optimization</h2><ul><li>Optimization （优化）<ul><li>Improve the IR for Better Target Code（改进中间表示以生成更好的目标代码）</li><li>Better: Faster, Smaller, Greener （更好：更快、更小、更环保）</li></ul></li></ul><h2 id="目标代码生成target-code-generation">目标代码生成：Target CodeGeneration</h2><ul><li>Target Code Generation （目标代码生成）<ul><li>Instruction Selection （指令选择）<ul><li>RISC vs.&nbsp;CISC<ul><li>RISC: Reduced Instruction Set Computer （精简指令集计算机）</li><li>CISC: Complex Instruction Set Computer （复杂指令集计算机）</li></ul></li><li>Intel Manual: &gt; 6000 Pages （英特尔手册：超过6000页）</li></ul></li><li>Register Allocation （寄存器分配）<ul><li>Graph Coloring Problem （图着色问题）</li></ul></li><li>Evaluation Order （计算顺序）<ul><li>Arrange the Computation Order for Less Register Occupation（安排计算顺序以减少寄存器占用）</li><li>NPC (Non-Polynomial Complete) Problem （非多项式完全问题）</li></ul></li></ul></li></ul><h1 id="ch2-syntax-definition">Ch2 Syntax Definition</h1><h2 id="文法的定义definition-of-grammars">文法的定义：Definition ofGrammars</h2><h3 id="定义">定义</h3><ul><li>Grammar: a Set of Rules to Describe a Language.</li><li>Language: a Sorted Set of Strings over some fixed Alphabet.</li><li>关系：Grammar Abstracts the Language to Cover All Its Strings.（文法是对语言的抽象，覆盖了语言的所有字符串）</li><li>∅: Empty Language (Set of Strings)</li><li>𝜺: Empty String (Set of Symbols)</li></ul><h3 id="组成">组成</h3><ul><li>Grammar G[S] = (VN, VT, P, S)<ul><li>VT: A set of Terminal Symbols (终结符)<ul><li>Atomic: 基本符号，不可再分</li></ul></li><li>VN : A set of Non-terminals (非终结符)<ul><li>A Non-terminal: a set of strings of Terminals</li></ul></li><li>P: A set of Productions (生成式、规则)<ul><li>A Non-terminal, an Arrow, a sequence of Terminals and/orNon-terminals</li></ul></li><li>S: A Start Symbol (开始符)<ul><li>A Non-terminal</li></ul></li></ul></li></ul><h2 id="推导derivations">推导：Derivations</h2><h3 id="定义-1">定义</h3><ul><li>A Grammar derives strings by beginning with the <strong>StartSymbol</strong> and repeatedly replacing a <strong>Non-terminal</strong>with <strong>Terminals</strong> via its <strong>Productions</strong>.（文法通过从开始符开始，反复用生成式将非终结符替换为终结符来派生字符串）<ul><li>推导（Derivation）：反复根据生成规则用终结符替换非终结符</li><li>归约（Reduction）：推导的反过程</li></ul></li></ul><h3 id="语法分析syntax-analysis-parsing">语法分析（Syntax Analysis,Parsing）</h3><ul><li>given a sequence of Terminals, figure out Whether it can be Derivedfrom the Grammar and How if possible.（给定一个终结符序列，判断它是否可以由文法推导而来，如果可以，推导过程是什么）</li><li>一个语言可能有多个文法描述，而一个文法只会派生一个唯一语言</li></ul><h2 id="文法的二义性ambiguity">文法的二义性：Ambiguity</h2><h3 id="定义-2">定义</h3><ul><li>语法树（Parse Tree）: A Graphical Representation of a Derivationwithout the Order of Applying Productions.（语法树是一个图形表示，表示了一个推导过程，但不考虑生成式应用的顺序）</li><li>二义性（Ambiguity）: When Parsing, given a sequence of Terminals, aGrammar is Ambiguous if there are more than one Parse Tree for theDerivation.（二义性是指一个文法可以产生多棵语法树） ### Fix theGrammar</li><li>Example:<ul><li>stmt -&gt; if expr then stmt | if expr then stmt else stmt |other</li><li>if E1 then if E2 then S1 else S2</li></ul></li><li>Match each else with the <strong>closest unmatched then</strong><ul><li>the statement appearing between a then and an else must be“matched”</li><li>the interior statement must not end with an unmatched (open)then</li></ul></li><li>Listing All Cases then Tidying Them Up<ul><li>if expr then matched_stmt</li><li>if expr then open_stmt</li><li>if expr then matched_stmt else matched_stmt</li><li>if expr then matched_stmt else open_stmt</li><li>so that:<ul><li>matched_stmt -&gt; if expr then matched_stmt else matched_stmt |other</li><li>open_stmt -&gt; if expr then matched_stmt | if expr then open_stmt |if expr then matched_stmt else open_stm</li></ul></li><li>finally:<ul><li>stmt -&gt; matched_stmt | open_stmt</li><li>matched_stmt -&gt; if expr then matched_stmt else matched_stmt |other</li><li>open_stmt -&gt; if expr then stmt | if expr then matched_stmt elseopen_stmt</li></ul></li></ul></li></ul><h2 id="文法和语言的分类classes-of-languages">文法和语言的分类：Classesof Languages</h2><p><img src="image-3.png" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>范围由 Type 0 到 Type 3 逐渐缩小</li></ul><h1 id="ch3-scanning">Ch3 Scanning</h1><h2 id="词法分析lexical-analysis-1">词法分析：Lexical Analysis</h2><h3 id="token-pattern-and-lexemes">Token, Pattern, and Lexemes</h3><ul><li>The Analysis Partitions Input String into Substrings.（分析将输入字符串划分为子字符串。） <img src="image-4.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>Token</strong>: &lt;token-name, attribute-value(opt.)&gt;<ul><li>token-name: the role of lexical unit （词法单元的角色）<ul><li>often refer to Token by its token-name</li></ul></li><li>attribute-value: any info associated to the Token（与Token相关的任何信息）<ul><li>Generally, it has only ONE value: a pointer to the Symbol Table（通常只有一个值：指向符号表的指针）<ul><li>In practice, the value of a constant can be stored as the attribute.（在实践中，常量的值可以作为属性存储。）<ul><li>constant: strings, numbers （常量：字符串、数字）</li></ul></li></ul></li></ul></li></ul></li><li><strong>Pattern</strong>: description of the form lexemes of a tokenmay （描述词法单元的形式）<ul><li>regular expression: , ?, *, +, …</li></ul></li><li><strong>Lexeme</strong>: a sequence of characters matches a token’spattern （与模式匹配的字符序列）<ul><li>Token vs.&nbsp;Lexeme: Class vs.&nbsp;Instance in C++</li></ul></li></ul><p><img src="image-7.png" srcset="/img/loading/loading3.gif" lazyload></p><h2 id="specification-of-tokens">Specification of Tokens</h2><h3 id="strings-and-languages">Strings and Languages</h3><ul><li>String: a finite sequence of Symbols from an Alphabet（字符串：来自字母表的有限符号序列）</li><li>Language: any countable set of Strings（语言：任何可数的字符串集合）</li><li>Terms for Parts of a String s （字符串s的部分术语）:<ul><li>prefix：前缀<ul><li>any string obtained by removing zero or more symbols from the end ofs</li></ul></li><li>suffix：后缀<ul><li>any string obtained by removing zero or more symbols from thebeginning of s</li></ul></li><li>substring：子串<ul><li>any string obtained by removing any prefix or any suffix from s（去掉前缀或后缀）</li></ul></li><li>subsequence：子序列<ul><li>any string obtained by removing zero or more not necessarilyconsecutive position of s （不一定连续的位置）</li></ul></li></ul></li></ul><h3 id="operations-on-languages">Operations on Languages</h3><ul><li><strong>Union</strong>: （并集）<ul><li><span class="math inline"><em>L</em><sub>1</sub> ∪ <em>L</em><sub>2</sub> = {<em>x</em>|<em>x</em> ∈ <em>L</em><sub>1</sub>  <em>o</em><em>r</em>  <em>x</em> ∈ <em>L</em><sub>2</sub>}</span></li></ul></li><li><strong>Concatenation</strong>: （连接）<ul><li><span class="math inline"><em>L</em><sub>1</sub><em>L</em><sub>2</sub> = {<em>x</em><em>y</em>|<em>x</em> ∈ <em>L</em><sub>1</sub>  <em>a</em><em>n</em><em>d</em>  <em>y</em> ∈ <em>L</em><sub>2</sub>}</span></li></ul></li><li><strong>Kleene closure</strong>: （星闭包）<ul><li><span class="math inline">$L^* = \bigcup_{1=0}^\infty L^i \\= {𝜖} ∪L ∪ L^2 ∪ L^3 ∪ ... \\= \{x | x = x_1x_2...x_n, n ≥ 0, xi ∈L\}$</span></li><li>𝜖 is the empty string</li></ul></li><li><strong>Positive closure</strong>: （正闭包）<ul><li><span class="math inline">$L^+ = \bigcup_{1=1}^\infty L^i \\= LL^*\\= \{x | x = x_1x_2...x_n, n ≥ 1, xi ∈ L\}$</span></li></ul></li></ul><h3 id="regular-expressions">Regular Expressions</h3><h4 id="定义-3">定义</h4><ul><li><strong>Regular Expression (Regex)</strong>: a way to describePatterns of Tokens of a programming language.（正则表达式：描述编程语言的词法单元模式的一种方式）<ul><li>Each Regular Expression r denotes a Language L<span class="math inline">(<em>r</em>)</span>.（每个正则表达式r表示一个语言L<span class="math inline">(<em>r</em>)</span>）<ul><li>Regular Language, Type-3 Language</li></ul></li><li>The Regular Expressions are built recursively out of smaller ones,using the rules. （正则表达式是用规则递归构建的）</li></ul></li></ul><h4 id="语法">语法</h4><ul><li><strong>BASIS</strong> （基础）<ul><li>𝜀 is a regular expression, and L(𝜀) = {𝜀}, the empty set.（空字符）</li><li>a is a symbol in a set Σ, then a is a regular expression, and L(a) ={a}. （集合中的字符）</li></ul></li><li><strong>INDUCTION</strong> （归纳）：Suppose <span class="math inline"><em>r</em></span> and <span class="math inline"><em>s</em></span> are expressions denoting <span class="math inline"><em>L</em>(<em>r</em>)</span> and <span class="math inline"><em>L</em>(<em>s</em>)</span><ul><li><span class="math inline"><em>r</em>|<em>s</em></span> : a regularexpression denoting <span class="math inline"><em>L</em>(<em>r</em>) ∪ <em>L</em>(<em>s</em>)</span></li><li><span class="math inline"><em>r</em><em>s</em></span> : a regularexpression denoting <span class="math inline"><em>L</em>(<em>r</em>)<em>L</em>(<em>s</em>)</span></li><li><span class="math inline"><em>r</em><sup>*</sup></span> : a regularexpression denoting <span class="math inline">(<em>L</em>(<em>r</em>))<sup>*</sup></span></li><li><span class="math inline">(<em>r</em>)</span> : a regular expressiondenoting <span class="math inline"><em>L</em>(<em>r</em>)</span><ul><li>We can add additional brackets around expressions.（我们可以在表达式周围添加额外的括号。）</li></ul></li></ul></li><li><strong>定律</strong>： <img src="image-6.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="regular-definitions">Regular Definitions</h3><ul><li><strong>Regular Definition</strong>: a set of productions withnon-terminals derived by regular expressions.（正则定义：一组通过正则表达式派生的非终结符的产生式）</li></ul><h3 id="extensions-of-regex">Extensions of Regex</h3><ul><li><span class="math inline">+</span> : one or more instances<ul><li><span class="math inline"><em>r</em><sup>*</sup></span> = <span class="math inline"><em>r</em><sup>+</sup></span> | 𝜖</li><li><span class="math inline"><em>r</em><sup>+</sup></span> = <span class="math inline"><em>r</em><em>r</em><sup>*</sup></span> = <span class="math inline"><em>r</em><sup>*</sup><em>r</em></span></li></ul></li><li><span class="math inline">?</span> : zero or one instance<ul><li><span class="math inline"><em>r</em>?</span> = <span class="math inline"><em>r</em></span> | 𝜖</li></ul></li><li><span class="math inline">[  ]</span> : character classes<ul><li><span class="math inline">[<em>a</em><em>b</em><em>c</em>]</span> =<span class="math inline"><em>a</em></span> | <span class="math inline"><em>b</em></span> | <span class="math inline"><em>c</em></span></li><li><span class="math inline">[<em>a</em> − <em>z</em>]</span> = <span class="math inline"><em>a</em></span> | <span class="math inline"><em>b</em></span> | … | <span class="math inline"><em>z</em></span></li></ul></li></ul><h3 id="regular-language-grammar-and-regex">Regular Language / Grammar,and Regex</h3><p><img src="image-5.png" srcset="/img/loading/loading3.gif" lazyload></p><ul><li><strong>Regular Expression</strong> <span class="math inline"><em>r</em></span> denotes a Language <span class="math inline"><em>L</em>(<em>r</em>)</span>.<ul><li>Regular Language is Type-3 Language （正则语言是类型3语言）</li><li>Regular Language is that denoted by Regular Expressions.（正则语言是由正则表达式表示的）</li></ul></li><li><strong>Regular Grammar</strong> is the grammar describes a RegularLanguage.<ul><li>with the production form of <span class="math inline"><strong>A</strong> → <em>α</em></span> or <span class="math inline"><strong>A</strong> → <em>α</em><strong>B</strong></span></li></ul></li></ul><h2 id="recognition-of-tokens">Recognition of Tokens</h2><h3 id="input-buffer">Input Buffer</h3><p><img src="image-8.png" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="transition-diagrams">Transition Diagrams</h3><ul><li><strong>Transition Diagram = Nodes + Edges</strong>, a Flowchart（状态流程图 = 节点 + 边）<ul><li><strong>Nodes</strong>: <strong>states, conditions</strong> thatcould occur when looking for a lexeme that matches one pattern.（节点：状态）<ul><li><strong>States</strong>: Circles （状态：圆圈）</li><li><strong>Start State</strong>: Arrowhead, Beginning of a Pattern（起始状态：箭头，开始）</li><li><strong>End State(s)</strong>: <strong>Double Circles</strong>, Endof a Pattern （终止状态：双圆圈，结束）</li></ul></li><li><strong>Edge</strong>: <strong>actions</strong>, taken to transitfrom one State to Another. （边：动作）<ul><li>labeled by a Symbol or a set of Symbols for matching（标记为符号或符号集以进行匹配）</li></ul></li><li><strong>Deterministic</strong>: at most ONE edge out of a givenstate with a given label. （确定性：在给定状态下，最多有一条边）</li></ul></li><li><strong>Example</strong>: <img src="image-51.png" srcset="/img/loading/loading3.gif" lazyload><ul><li>*<strong>(Retract)</strong>: A Token has been accepted while anotherchar has been read which must be unread.（回退：一个Token已经被接受，而另一个不应读取字符已经被读取，必须回退）</li></ul></li></ul><h3 id="reserved-words-保留字">Reserved Words （保留字）</h3><ul><li>Keywords look like Identifiers.<ul><li>if, then, …</li></ul></li><li>Add reserved words into symbol table initially.（在符号表中添加保留字）</li><li>Create <strong>separate transition diagrams</strong> for eachkeyword. （为每个关键字创建单独的转换图）<ul><li>thenextone</li><li><img src="image-52.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h2 id="有穷自动机finite-automata">有穷自动机：Finite Automata</h2><h3 id="finite-automata">Finite Automata</h3><ul><li><strong>What</strong>: an Abstract Machine that can be in exactlyone of a Finite number of States at any given time.（有限自动机：在任何给定时间只能处于有限数量的状态之一的抽象机器）<ul><li>Finite Automation = Finite-state Automation (FSA, plural: automata)（有限自动机 = 有限状态自动机）<ul><li>Finite-state Machine (FSM), or simply State Machine（有限状态机，或简单地称为状态机）</li></ul></li><li>changes from one state to another according to Inputs, calledTransition （根据输入，从一个状态变化到另一个状态，称为转换）</li></ul></li><li><strong>Why</strong>: used as the Recognizer for Scanning,identifying Tokens （用于扫描的识别器，识别token）</li><li><strong>How</strong>: answers “YES” or “NO” about each input String（如何：对每个输入字符串回答“是”或“否”）<ul><li>determines whether the String is valid for the given Grammar（确定字符串是否符合给定的语法）</li></ul></li></ul><h3 id="dfa-vs.-nfa">DFA vs.&nbsp;NFA</h3><ul><li>FA: <strong>Deterministic (DFA) or Non-deterministic(NFA)</strong></li><li><strong>DFA</strong>: have <strong>exactly/at most oneaction</strong> for each input symbol （每个输入符号有一个动作）<ul><li>can be represented with a Transition Diagram</li><li>Recognition with DFA: Faster, may take More Space（识别DFA：更快，可能占用更多空间）</li><li>complex to represent Regex, but more Precise, widely used（复杂表示正则表达式，但更精确，广泛使用）</li></ul></li><li><strong>NFA</strong>: can have <strong>multiple actions</strong> forthe same input symbol （同一输入符号可以有多个动作）<ul><li>can be represented with a Transition Graph</li><li>Recognition with NFA: Slower, may take Less Space（识别NFA：较慢，可能占用更少的空间）</li><li>simply represents Regex, but less Precise（简单表示正则表达式，但不够精确）</li></ul></li><li><strong>Example</strong>: <img src="image-9.png" srcset="/img/loading/loading3.gif" lazyload></li><li>Lexical Analysis <strong>Workflow</strong> with FA:<ul><li>Regex -&gt; NFA -&gt; DFA</li><li>Regex -&gt; DFA</li></ul></li></ul><h3 id="nondeterministic-finite-automata-nfa">Nondeterministic FiniteAutomata (NFA)</h3><ul><li><strong>An NFA M = <span class="math inline"><strong>(</strong><strong>S</strong><strong>,</strong> <strong>𝜮</strong><strong>,</strong> <strong>m</strong><strong>o</strong><strong>v</strong><strong>e</strong><strong>,</strong> <strong>𝒔</strong><sub><strong>0</strong></sub><strong>,</strong> <strong>F</strong><strong>)</strong></span></strong>consists of:<ul><li><span class="math inline"><strong>S</strong></span>: a finite set ofStates （有限状态集）</li><li><span class="math inline"><strong>𝜮</strong></span>: the InputAlphabet, excluding 𝜖 （不包含𝜖的输入符号集合）</li><li><span class="math inline"><strong>m</strong><strong>o</strong><strong>v</strong><strong>e</strong></span>,a Transition Function （转换函数）<ul><li>move(State, Symbol) = set of Next States</li><li>move: <span class="math inline"><em>𝑆</em> × (<em>Σ</em> ∪ {<em>𝜖</em>}) ⟶ <em>ℙ</em>(<em>𝑆</em>)</span></li></ul></li><li><span class="math inline"><strong>s</strong><sub><strong>0</strong></sub> ∈ <strong>S</strong></span>,the Start State (or Initial State) （起始状态）</li><li><span class="math inline"><strong>F</strong> ⊆ <strong>S</strong></span>, aset of Accepting States (or Final States) （终止状态）</li></ul></li><li>An NFA accepts Input String <span class="math inline"><em>s</em></span> iff<ul><li>there exists some path in the Transition Graph from the Start Stateto one Accepting State, （存在一条路径从起始状态到一个接受状态）</li><li>such that symbols along the path spell out <span class="math inline"><em>s</em></span> （路径上的符号拼写出<span class="math inline"><em>s</em></span>）</li></ul></li><li><strong>Transition Tables</strong>：<strong>rows</strong> forStates, <strong>columns</strong> for Input Symbols and 𝝐<ul><li>Example: <img src="image-10.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h3 id="deterministic-finite-automata-dfa">Deterministic Finite Automata(DFA)</h3><ul><li><strong>What</strong>: a Special Case of an NFA, where<ul><li>there are <strong>no moves</strong> on symbol 𝜖, and</li><li>for each state s and input symbol a, there is <strong>ExactlyONE</strong> edge out of s labeled by a.（每个状态s和输入符号a，恰好有一条边出s标记为a）<ul><li><strong>COMPLETE</strong>: It defines from each state a transitionfor each input symbol. （完整：它定义了从每个状态到每个输入符号的转换）<ul><li>Transition function is a total function.</li></ul></li><li><strong>Local Automation</strong>: DFA not necessarily complete (…At Most ONE edge …) （局部自动机：DFA不一定是完全图）<ul><li>Transition function is a partial function.</li></ul></li></ul></li></ul></li></ul><h2 id="algorithm-for-simulation">Algorithm for Simulation</h2><h3 id="conversion-nfa-dfa">Conversion: NFA –&gt; DFA</h3><ul><li><strong>Subset Construction</strong> （子集构造）<ul><li>removing 𝜖-transitions</li><li>combining multiple NFA’s states into ONE constructed DFA’s state（将多个NFA的状态组合成一个构造的DFA的状态，即：等势点合并）</li></ul></li><li><strong>Definitions</strong>:<ul><li><strong>𝜖-closure(s)</strong>:<ul><li>s: some State</li><li>= Set of NFA <strong>States</strong> reached by state s via𝜖-transitions, including s itself.（NFA中可以通过若干个空变换到达的状态的集合）</li></ul></li><li><strong>𝜖-closure(T)</strong>:<ul><li>T: set of <strong>States</strong></li><li>= <span class="math inline">∪<sub><em>s</em> ∈ <em>T</em></sub></span>𝜖-closure(s)</li></ul></li><li><strong>move(T, a)</strong>:<ul><li>T: set of States</li><li>a: Input Symbol</li><li>= NFA’s <strong>States</strong> reached by 𝑠 ∈ 𝑇 on a.</li></ul></li></ul></li><li><strong>Algorithm Subset Construction</strong><ul><li>Input: the start State <strong>s0</strong> and the TransitionDiagram of NFA <strong>N</strong>.</li><li>Output: Transition Graph of DFA <strong>Dtran</strong><figure class="shiki java"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">add 𝝐</span><span style="color: #56B6C2">-</span><span style="color: #61AFEF">closure</span><span style="color: #E06C75">(s0) into Dstates </span><span style="color: #7F848E; font-style: italic">//将初始状态s0的𝝐闭包加入Dstates</span></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">Dstates</span><span style="color: #E06C75"> has unsearched state S) { </span><span style="color: #7F848E; font-style: italic">//当Dstates有未搜索的状态S时</span></span><span class="line"><span style="color: #E06C75">    tag </span><span style="color: #E5C07B">S</span><span style="color: #E06C75"> as searched </span><span style="color: #7F848E; font-style: italic">//将S标记为已搜索</span></span><span class="line"><span style="color: #E06C75">    foreach input symbol a { </span><span style="color: #7F848E; font-style: italic">//对每个输入符号a</span></span><span class="line"><span style="color: #E06C75">        U </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> 𝝐</span><span style="color: #56B6C2">-</span><span style="color: #61AFEF">closure</span><span style="color: #E06C75">(</span><span style="color: #61AFEF">move</span><span style="color: #E06C75">(S</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a)) </span><span style="color: #7F848E; font-style: italic">//设U为S进行a动作后状态S'的𝝐闭包</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">U</span><span style="color: #E06C75"> is </span><span style="color: #C678DD">new</span><span style="color: #E06C75"> to Dstates) { </span><span style="color: #7F848E; font-style: italic">//如果U是Dstates中的新状态</span></span><span class="line"><span style="color: #E06C75">            add </span><span style="color: #E5C07B">U</span><span style="color: #E06C75"> into </span><span style="color: #E5C07B">Dstates</span><span style="color: #E06C75"> as unsearched </span><span style="color: #7F848E; font-style: italic">//将U加入Dstates并标记为未搜索</span></span><span class="line"><span style="color: #E06C75">        }</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #61AFEF">Dtran</span><span style="color: #E06C75">(S</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a) </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> U </span><span style="color: #7F848E; font-style: italic">//将Dtran(S, a)设为U</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">}</span></span></code></pre></div></div></figure></li><li><strong>最后得到的Dtran是一个DFA的转换表</strong>，Dstates是DFA的状态集合。</li></ul></li><li><strong>Algorithm 𝜖-closure(T) Computation</strong>:<ul><li>上一步中<code>U = 𝝐-closure(move(S, a))</code>的实现逻辑：</li><li>Input: the State Set T</li><li>Output: 𝜖-closure(T) <figure class="shiki java"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">push all states in </span><span style="color: #E5C07B">T</span><span style="color: #E06C75"> onto Stack </span><span style="color: #7F848E; font-style: italic">//将T中的所有状态压入栈中</span></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">Stack</span><span style="color: #E06C75"> is not empty) { </span><span style="color: #7F848E; font-style: italic">//当栈不为空时</span></span><span class="line"><span style="color: #E06C75">    s </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> </span><span style="color: #E5C07B">Stack</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">pop</span><span style="color: #ABB2BF">()</span><span style="color: #E06C75"> </span><span style="color: #7F848E; font-style: italic">//弹出栈顶元素s</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #61AFEF">foreach</span><span style="color: #E06C75"> (state u reached by s via 𝜖) { </span><span style="color: #7F848E; font-style: italic">//对于每个s通过𝜖能达到的状态u</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (u is not in 𝜖</span><span style="color: #56B6C2">-</span><span style="color: #61AFEF">closure</span><span style="color: #E06C75">(T)) { </span><span style="color: #7F848E; font-style: italic">//如果u不在T的𝜖闭包中</span></span><span class="line"><span style="color: #E06C75">            add u into 𝜖</span><span style="color: #56B6C2">-</span><span style="color: #61AFEF">closure</span><span style="color: #E06C75">(T) </span><span style="color: #7F848E; font-style: italic">// 将其加入T的𝜖闭包</span></span><span class="line"><span style="color: #E06C75">            </span><span style="color: #E5C07B">Stack</span><span style="color: #ABB2BF">.</span><span style="color: #61AFEF">push</span><span style="color: #ABB2BF">(u)</span><span style="color: #E06C75"> </span><span style="color: #7F848E; font-style: italic">//将u压入栈中</span></span><span class="line"><span style="color: #E06C75">        }</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">}</span></span></code></pre></div></div></figure></li></ul></li><li><strong>Example</strong>: <img src="image-11.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="conversion-regex-nfa">Conversion: Regex –&gt; NFA</h3><ul><li>McNaughton-Yamada-Thompson Algorithm</li><li>Regex’s Definition:<ul><li><strong>BASIS</strong>: <img src="image-12.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>INDUCTION</strong>: <img src="image-13.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>Example</strong>: <img src="image-14.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h2 id="workflow">Workflow</h2><ul><li>The <strong>Workflow</strong> of Lexical Analyzer<ul><li>Regex –&gt; NFA Construction</li><li>NFA –&gt; DFA Construction</li><li>Simulating DFA to Recognize Tokens</li></ul></li><li>Convert Regex Directly into DFA: PASS</li><li><strong>DFA Simplification</strong>: Minimizing the Number ofStates</li></ul><h2 id="dfa-simplification">DFA Simplification</h2><ul><li><strong>What and Why</strong>:<ul><li><strong>no REDUNDANT states</strong> （无冗余状态）<ul><li>REDUNDANCE: the states that NO accepted input string’s path passesthrough （没有路径到达终止状态的状态）</li><li>(in the transition graph)</li></ul></li><li><strong>no EQUIVALENT states</strong> （无等效状态）<ul><li>EQUIVALENCE: states with the SAME side effects（具有相同副作用的状态）</li><li>(making the states indistinguishable)</li></ul></li><li><strong>Distinguish States via Input String</strong>（通过输入字符串区分状态）<ul><li>State: s, t</li><li>String: x</li><li>x distinguishes s from t,<ul><li>if one state can reach an accepting state via x, while the othercannot. （如果一个状态可以通过x到达终止状态，而另一个状态不能）</li></ul></li><li>s is distinguishable from t,<ul><li>if there is some string distinguishes them.（存在一些字符串可以区分它们）</li></ul></li><li>Unify Indistinguishable States into One.（将不可区分的状态合并为一个）</li></ul></li></ul></li><li><strong>How</strong>：<ol type="1"><li>Start with the initial partition <span class="math inline"><strong>Π</strong></span> with two groups, the<strong>accepting</strong> and <strong>non-accepting</strong> states ofthe DFA. （将DFA的接受状态和非接受状态分为两个组）</li><li>Let <span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub> <strong>:=</strong> <strong>Π</strong></span>.Then, for each group <span class="math inline"><strong>G</strong></span>of <span class="math inline"><strong>Π</strong></span>: （初始时令<span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub> <strong>=</strong> <strong>Π</strong></span>，然后对于每个组G）<ul><li>For each input symbol <span class="math inline"><strong>a</strong></span>, states <span class="math inline"><strong>s</strong>, <strong>t</strong></span> in<span class="math inline"><strong>G</strong></span> are partitioned ifthey transit to different groups of <span class="math inline"><strong>Π</strong></span> via <span class="math inline"><strong>a</strong></span>;（对于每个输入符号a，如果状态s和t通过a转移到不同的组，则他们被划分为不同的组）</li><li>Replace <span class="math inline"><strong>G</strong></span> in <span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub></span>by the new subgroups. （用新的子组替换<span class="math inline"><strong>G</strong></span>）</li></ul></li><li>If <span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub> ≠ <strong>Π</strong></span>,<span class="math inline"><strong>Π</strong> <strong>:</strong>  <strong>=</strong> <strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub></span>and repeat Step 2, Step 4 otherwise. （如果<span class="math inline"><strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub> ≠ <strong>Π</strong></span>，则令<span class="math inline"><strong>Π</strong> <strong>:</strong>  <strong>=</strong> <strong>Π</strong><sub><strong>n</strong><strong>e</strong><strong>w</strong></sub></span>并重复步骤2，否则跳到步骤4）</li><li>Aggregate the transitions among groups. （将组之间的转换聚合）</li><li>The resulting DFA is the minimized DFA.（得到的DFA是最小化的DFA）</li></ol></li><li><strong>Example</strong>:<img src="image-15.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h1 id="ch4-parsing">Ch4 Parsing</h1><h2 id="词法分析lexical-analysis-2">词法分析：Lexical Analysis</h2><h3 id="parser">Parser</h3><ul><li><strong>What</strong>: Given Tokens, Parsing Verifies whether theToken Names Can Be Generated by the Grammar for the Source Language.（给定tokens，解析会验证token名称是否可以由源语言的语法生成）</li><li><strong>Why</strong>: We expect the Parser<ul><li>to <strong>report Syntax Errors</strong> （报告语法错误）</li><li>to recover from Errors to continue following processes.（从错误中恢复以继续后续过程）</li></ul></li><li><strong>How</strong>: Derivation or Reduction<ul><li><strong>Top-down</strong> and <strong>Bottom-up</strong>Parsing</li></ul></li></ul><p><img src="image-16.png" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="compiler-errors">Compiler Errors</h3><ul><li>Lexical Errors<ul><li>The string does not match the pattern of any token.（字符串与任何token的模式不匹配）</li></ul></li><li>Syntactic Errors<ul><li>The string does not meet the requirements of the grammar.（字符串不符合语法要求）</li></ul></li><li>Semantic Errors: Type Mismatching （语义错误：类型不匹配）</li></ul><h3 id="error-recovery-strategies">Error-Recovery Strategies</h3><ul><li><strong>Panic-Mode Recovery</strong><ul><li>Discarding input symbols one at a time until meeting synchronizingtokens （丢弃输入符号，直到遇到同步tokens）<ul><li>synchronizing tokens, e.g.&nbsp;“;”, “}”, etc., decided by designers</li></ul></li><li>simple, but may cause more errors</li></ul></li><li><strong>Phrase-Level Recovery</strong><ul><li>Local Correction on Input, allowing the parser to continue（允许解析器继续）<ul><li>e.g., “,” → “;”, delete/insert “;”</li><li>designers’ responsibility</li></ul></li><li>helpless if error occurs before the point of detection</li></ul></li><li><strong>Error Productions</strong><ul><li>augmenting grammar with productions generating erroneous constructs（用产生错误构造的产生式扩充语法）</li><li>relying on designers</li></ul></li><li><strong>Global Correction</strong><ul><li>choosing a minimal sequence of changes for a globally least-costcorrection （选择一系列最小的变化，以实现全局最低成本的修正）</li><li>costly, yardstick? should defined by designers</li></ul></li></ul><h2 id="context-free-grammar-cfg">Context-Free Grammar (CFG)</h2><h3 id="definition">Definition</h3><ul><li>A <strong>Context-Free Grammar</strong> consists of:<ul><li>Terminals</li><li>Non-terminals</li><li>Start Symbol</li><li>Productions: <span class="math inline"><strong>A</strong> → <strong>α</strong></span><ul><li>Header / Left Side → Body / Right Side<ul><li>Header: A <strong>Non-terminal</strong></li><li>Body: <strong>zero or more Terminals or Non-terminals</strong></li></ul></li><li><span class="math inline"><strong>V</strong><sub><strong>N</strong></sub> → (<strong>V</strong><sub><strong>T</strong></sub>|<strong>V</strong><sub><strong>N</strong></sub>)<sup>*</sup></span></li></ul></li></ul></li></ul><h3 id="derivation">Derivation</h3><ul><li><p><strong>What</strong>: Beginning with the Start Symbol, replace aNon-terminal by the body of one of its Production.（从起始符号开始，用其产生式的右侧替换非终结符）</p></li><li><p><strong>Why</strong>:</p><ul><li>corresponding to <strong>Top-down</strong> Construction of a ParseTree （对应于自顶向下构造解析树）</li><li>helpful for Bottom-up Parsing</li></ul></li><li><p><strong>How</strong>:</p><ul><li>$$ : derive in one step</li><li>$ $ : derive in zero or more steps<ul><li><span class="math inline">$\alpha \overset{*}{\Rightarrow}\alpha$</span></li><li>if <span class="math inline">$\alpha \overset{*}{\Rightarrow}\beta$</span> and <span class="math inline">$\beta\overset{*}{\Rightarrow} \gamma$</span>, then <span class="math inline">$\alpha \overset{*}{\Rightarrow} \gamma$</span></li></ul></li><li>$ $ : derive in one or more steps</li></ul></li><li><p><span class="math inline">$\mathbf{S} \overset{*}{\Rightarrow}\alpha$</span></p><ul><li><span class="math inline"><em>α</em></span> is a <strong>SententialForm</strong> of S. （<span class="math inline"><em>α</em></span>是S的一个句子形式）</li><li><span class="math inline"><em>α</em></span> may contain<strong>Terminals</strong>, <strong>Non-terminals</strong>, or may be<strong>Empty</strong>.</li><li>Sentence: a Sentential Form without Non-terminals.（没有非终结符的句子形式）</li></ul></li><li><p>What is a <strong>Language</strong>?</p><ul><li><span class="math inline"><em>L</em>(<em>G</em>)</span>: set ofSentences generated by the Grammar <span class="math inline"><em>G</em></span></li><li>A string of terminals $ L(G) $ if and only if $ $ is a Sentence of $G $ (or $ S $).</li></ul></li><li><p><strong>Example</strong>: <img src="image-17.png" srcset="/img/loading/loading3.gif" lazyload></p></li><li><p><strong>Leftmost Derivation</strong>: the Leftmost Non-terminalis always replaced at first （最左边的非终结符总是第一个被替换）</p><ul><li>$ $</li></ul></li><li><p><strong>Rightmost Derivation</strong>: $ $</p></li><li><p><strong>Parse Trees and Derivations</strong></p><ul><li>What: A Graphical Representation of a Derivation （派生的图形表示）<ul><li>filtering out the order in which productions applied to replacenon-terminals （过滤出应用于替换非终结符的产生式的顺序）</li></ul></li><li><strong>Example</strong>： <img src="image-18.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h2 id="top-down-parsing">Top-Down Parsing</h2><ul><li><strong>What</strong>: Create the Parse Tree from Top to Bottom（从上到下创建解析树）<ul><li>from root to leaves （从根到叶）</li></ul></li><li><strong>Why</strong>: for Parsing</li><li><strong>How</strong>: Derive an Input String in the<strong>Leftmost</strong> Manner （以最左边的方式派生输入字符串）<ul><li>consistent with string scanning （与字符串扫描一致）</li><li><strong>Key</strong>: determine the production to be applied for anon-terminal （确定要应用于非终结符的产生式）</li><li><strong>Recursive-Descent Parsing</strong><ul><li>require <strong>backtracking</strong> to find right production（需要回溯以找到正确的产生式）</li><li>general, but inefficient</li></ul></li><li><strong>Predictive Parsing</strong><ul><li>a special case of Recursive-Descent Parsing</li><li>no backtracking, choosing by <strong>looking ahead</strong> at inputsymbols （无需回溯，通过提前查看输入符号进行选择）</li></ul></li></ul></li></ul><h3 id="recursive-descent-parsing">Recursive-Descent Parsing</h3><figure class="shiki java"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #C678DD">void</span><span style="color: #E06C75"> </span><span style="color: #61AFEF">A</span><span style="color: #E06C75">() {</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #7F848E; font-style: italic">// Choose an A-production, A --&gt; X1 X2 ...Xk;</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">for</span><span style="color: #E06C75"> (i </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> </span><span style="color: #D19A66">1</span><span style="color: #E06C75"> to k) {</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">Xi</span><span style="color: #E06C75"> is a non</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">terminal)</span></span><span class="line"><span style="color: #E06C75">            call </span><span style="color: #61AFEF">Xi</span><span style="color: #E06C75">()</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">Xi</span><span style="color: #E06C75"> equals the current input symbol a)</span></span><span class="line"><span style="color: #E06C75">            advance the input to the next symbol</span><span style="color: #ABB2BF">;</span></span><span class="line"><span style="color: #E06C75">        </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> </span><span style="color: #ABB2BF">...</span><span style="color: #E06C75"> </span><span style="color: #7F848E; font-style: italic">// an error has occurred</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">}</span></span></code></pre></div></div></figure><ul><li>Example: <img src="image-19.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="left-recursion-左递归">Left Recursion （左递归）</h4><ul><li><strong>What</strong>: The Grammar has a non-terminal A such thatthere exists a derivation <span class="math inline">$\mathbf{A}\overset{+}{\Rightarrow} \mathbf{A} \alpha$</span>（文法有一个非终结符A，使得存在一个派生<span class="math inline">$\mathbf{A} \overset{+}{\Rightarrow} \mathbf{A}\alpha$</span>）</li><li><strong>Why</strong>: Recursive-Descent Parsing cannot handle LeftRecursion. （递归下降解析无法处理左递归）</li><li><strong>How</strong>: Transform the grammar to <strong>eliminateLeft Recursion</strong>. （转换文法以消除左递归）<ul><li>==<strong>Immediate Elimination</strong>: <span class="math inline"><strong>A</strong> → <strong>A</strong><em>α</em>|<em>β</em>   ⇒ <strong>A</strong> → <em>β</em><strong>A</strong><sup><strong>′</strong></sup>, <strong>A</strong><sup><strong>′</strong></sup> → <em>α</em><strong>A</strong><sup><strong>′</strong></sup>|<em>𝝐</em></span>==</li><li>$ _1 | | _m &nbsp;| &nbsp;_1 | | _n &nbsp; (_1 | | _n) , (_1 | | _m) | $</li></ul></li><li><strong>Example</strong>: <img src="image-20.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="left-recursion-elimination-消除左递归">Left RecursionElimination （消除左递归）</h4><ul><li><strong>INPUT</strong>: Grammar G without Cycles or 𝝐-productions（无循环或𝝐产生式的文法）<ul><li>Cycle: <span class="math inline">$\mathbf{A}\overset{+}{\Rightarrow} \mathbf{A}$</span></li><li>𝝐-production: <span class="math inline"><strong>A</strong> → <em>ϵ</em></span></li></ul></li><li><strong>OUTPUT</strong>: Equivalent Grammar <strong>without LeftRecursions</strong> （没有左递归的等效文法）</li><li><strong>Steps</strong>: <figure class="shiki javascript"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">supposing</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">there</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">are</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">the</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Non</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">terminals</span><span style="color: #ABB2BF"> </span><span style="color: #C678DD">with</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Order</span><span style="color: #ABB2BF"> </span><span style="color: #E5C07B">A1</span><span style="color: #ABB2BF">, </span><span style="color: #E5C07B">A2</span><span style="color: #ABB2BF">..., </span><span style="color: #E06C75">An</span></span><span class="line"><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">i</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">from</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">to</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">n</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #C678DD">for</span><span style="color: #ABB2BF"> (</span><span style="color: #E06C75">j</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">from</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">1</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">to</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">i</span><span style="color: #56B6C2">-</span><span style="color: #D19A66">1</span><span style="color: #ABB2BF">) {</span></span><span class="line"><span style="color: #ABB2BF">        </span><span style="color: #E06C75">replace</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">each</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Ai</span><span style="color: #ABB2BF"> → </span><span style="color: #E06C75">Aj𝛾</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">by</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Ai</span><span style="color: #ABB2BF"> → </span><span style="color: #E06C75">𝛿1𝛾</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">𝛿2𝛾</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> ... </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">𝛿𝑘𝛾</span><span style="color: #ABB2BF">, </span><span style="color: #E06C75">where</span><span style="color: #ABB2BF">:</span></span><span class="line"><span style="color: #ABB2BF">            </span><span style="color: #E06C75">Aj</span><span style="color: #ABB2BF">  → </span><span style="color: #E06C75">𝛿1</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">𝛿2</span><span style="color: #ABB2BF"> </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> ... </span><span style="color: #56B6C2">|</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">𝛿𝑘</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">are</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">all</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">current</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Aj</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">productions</span></span><span class="line"><span style="color: #ABB2BF">    }</span></span><span class="line"><span style="color: #ABB2BF">    </span><span style="color: #E06C75">eliminate</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">the</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Immediate</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Left</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Recursion</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">among</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">the</span><span style="color: #ABB2BF"> </span><span style="color: #E06C75">Ai</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">productions</span></span><span class="line"><span style="color: #ABB2BF">}</span></span></code></pre></div></div></figure></li><li><strong>Example</strong>: <img src="image-21.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="predictive-parsing">Predictive Parsing</h3><ul><li><strong>What</strong>: recursive-descent parsers needing nobacktracking （不需要回溯的递归下降解析器）<ul><li>can be constructed for LL(k) grammar （可以为LL(k)文法构造）<ul><li><strong>L</strong>: scanning input <strong>from Left toright</strong></li><li><strong>L</strong>: producing a <strong>Leftmostderivation</strong></li><li><strong>k</strong>: using <strong>k input symbols</strong> oflookahead at each step to make decision</li></ul></li></ul></li><li><strong>Why</strong>: a unique production to apply, or none to use(error)</li><li><strong>Example: LL(1)</strong><ul><li>stmt → <strong>i</strong>f (expr) stmt else stmt |<strong>w</strong>hile (expr) stmt | <strong>{</strong> stmt_list}</li></ul></li><li><strong>How</strong>: FIRST and FOLLOW<ul><li>assist in choosing which production to apply, based on the nextinput symbol （根据下一个输入符号选择应用哪个产生式）</li></ul></li></ul><h4 id="first-and-follow">FIRST and FOLLOW</h4><ul><li><strong>FIRST</strong>: the set of terminals that begin stringsderived from a non-terminal or a string of grammar symbols.（从非终结符或语法符号字符串派生的字符串开始的终结符集合）<ul><li><strong>FIRST(𝜶)</strong>: what the first symbol would be for 𝜶</li><li><strong>𝜶</strong>: string of grammar symbols</li><li><strong>return</strong>: set of terminals that begin strings derivedfrom 𝜶<ul><li>first symbols of strings derived from 𝜶</li></ul></li><li><strong>HOW</strong>：<ul><li>if <span class="math inline"><strong>X</strong></span> is aterminal, then <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong> = {<strong>X</strong>}</span></li><li>if <span class="math inline"><strong>X</strong></span> is anon-terminal, and <span class="math inline"><strong>X</strong> → <strong>Y</strong><sub><strong>1</strong></sub><strong>Y</strong><sub><strong>2</strong></sub>…<strong>Y</strong><sub><strong>k</strong></sub></span><ul><li>add all <strong>non-𝝐</strong> symbols of <span class="math inline"><strong>Y</strong><sub><strong>1</strong></sub></span>to <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong></span></li><li>add all <strong>non-𝝐</strong> symbols of <span class="math inline"><strong>Y</strong><sub><strong>2</strong></sub></span>to <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong></span>,if <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>1</strong></sub><strong>)</strong></span></li><li>···</li><li>add all <strong>non-𝝐</strong> symbols of <span class="math inline"><strong>Y</strong><sub><strong>k</strong></sub></span>to <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong></span>,if <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>1</strong></sub><strong>)</strong></span>and <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>2</strong></sub><strong>)</strong></span>and ··· and <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>k</strong> <strong>−</strong> <strong>1</strong></sub><strong>)</strong></span></li><li>add <strong>𝝐</strong> to <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>X</strong><strong>)</strong></span>,if <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>1</strong></sub><strong>)</strong></span>and <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>2</strong></sub><strong>)</strong></span>and ··· and <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>Y</strong><sub><strong>k</strong></sub><strong>)</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-22.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>FOLLOW</strong>: the set of terminals that can appearimmediately to the right of a non-terminal in some sentential form.（在某些句子形式中，可以出现在非终结符右侧的终结符集合）<ul><li><strong>FOLLOW(N)</strong>: what is the next symbol of N</li><li><strong>N</strong>: a non-terminal</li><li><strong>return</strong>: set of terminals can appear immediatelyafter N in a sentential form</li><li><strong>HOW</strong>:<ul><li>place <strong>$</strong> in <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>S</strong><strong>)</strong></span><ul><li><strong>S</strong>: start symbol</li><li><strong>$</strong>: input right end-marker</li></ul></li><li>for each production <span class="math inline"><strong>M</strong> → <em>α</em><strong>N</strong><em>β</em></span><ul><li>add all symbols in <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>to <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>N</strong><strong>)</strong></span>,except 𝝐</li><li>if <span class="math inline"><em>ϵ</em> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>,add all symbols in <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>M</strong><strong>)</strong></span>to <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>N</strong><strong>)</strong></span></li></ul></li><li>for each production <span class="math inline"><strong>M</strong> → <em>α</em><strong>N</strong></span><ul><li>add all symbols in <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>M</strong><strong>)</strong></span>to <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>N</strong><strong>)</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-23.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h4 id="ll1-grammar">LL(1) Grammar</h4><ul><li><strong>What</strong>: Any <span class="math inline"><strong>A</strong> → <strong>α</strong>&nbsp;|&nbsp;<strong>β</strong></span>Represents two Distinct Productions （<span class="math inline"><strong>A</strong> → <strong>α</strong>&nbsp;|&nbsp;<strong>β</strong></span>表示两个不同的产生式）<ul><li><span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>and <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>are disjoint sets.（二者是互不相交的集合）<ul><li>For no terminal <span class="math inline"><strong>a</strong></span>,do both <span class="math inline"><strong>α</strong></span> and <span class="math inline"><strong>β</strong></span> derive strings beginningwith <span class="math inline"><strong>a</strong></span>.（二者不会同时派生以<span class="math inline"><strong>a</strong></span>开头的字符串）</li><li>At most one of <span class="math inline"><strong>α</strong></span>and <span class="math inline"><strong>β</strong></span> can derive theempty string. （至多一个<span class="math inline"><strong>α</strong></span>和<span class="math inline"><strong>β</strong></span>可以派生空字符串）</li></ul></li><li>If <span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>,then <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>and <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>are disjoint sets. （如果<span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>)</strong></span>，则<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>和<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>是互不相交的集合）</li></ul></li><li><strong>Why</strong>: Proper Production is Selected by Looking<strong>ONLY</strong> at the Next Input Symbol.（通过仅查看下一个输入符号来选择适当的产生式）</li><li><strong>How</strong>: By Parsing Table, a Two-Dimensional Array<ul><li><span class="math inline"><strong>M</strong><strong>[</strong><strong>A</strong><strong>,</strong> <strong>a</strong><strong>]</strong> = <strong>α</strong></span>,when deriving <span class="math inline"><strong>A</strong></span>, apply<span class="math inline"><strong>A</strong> → <strong>α</strong></span>if coming up with <span class="math inline"><strong>a</strong></span>.（当派生<span class="math inline"><strong>A</strong></span>时，如果出现<span class="math inline"><strong>a</strong></span>，则应用<span class="math inline"><strong>A</strong> → <strong>α</strong></span>）</li></ul></li></ul><h4 id="ll1-parsing">LL(1) Parsing</h4><ul><li><strong>Predictive Parsing Table Construction</strong><ul><li><strong>INPUT</strong>: Grammar G.</li><li><strong>OUTPUT</strong>: Parsing Table M.</li><li><strong>STEPS</strong>: For each production <span class="math inline"><strong>A</strong> → <strong>α</strong></span>:<ol type="1"><li>For each terminal <span class="math inline"><strong>a</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>,add <span class="math inline"><strong>A</strong> → <strong>α</strong></span> to<span class="math inline"><strong>M</strong><strong>[</strong><strong>A</strong><strong>,</strong> <strong>a</strong><strong>]</strong></span>.</li><li>If <span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>,then for each terminal <span class="math inline"><strong>b</strong> ∈ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>,add <span class="math inline"><strong>A</strong> → <strong>α</strong></span> to<span class="math inline"><strong>M</strong><strong>[</strong><strong>A</strong><strong>,</strong> <strong>b</strong><strong>]</strong></span>.</li><li>If <span class="math inline"><strong>ϵ</strong> ∈ <strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>α</strong><strong>)</strong></span>and <span class="math inline"><strong>$</strong> ∈ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>,add <span class="math inline"><strong>A</strong> → <strong>α</strong></span> to<span class="math inline"><strong>M</strong><strong>[</strong><strong>A</strong><strong>,</strong> <strong>$</strong><strong>]</strong></span>.</li></ol></li><li><strong>Example</strong>: <img src="image-24.png" srcset="/img/loading/loading3.gif" lazyload> <img src="image-25.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>Implementation</strong><ul><li>Stack-based Method, mimicking a leftmost derivation（基于栈的方法，模仿最左派生）</li></ul><img src="image-26.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="left-factoring">Left Factoring</h4><ul><li>When the decision is not clear, defer it until seeing enoughsymbols. （当决策不明确时，推迟到看到足够的符号为止）</li><li><strong>Left-Factored</strong>:<ul><li><span class="math inline"><strong>A</strong> → <strong>𝜶</strong><strong>𝜷</strong><sub><strong>1</strong></sub>|<strong>𝜶</strong><strong>𝜷</strong><sub><strong>2</strong></sub>  <em>b</em><em>y</em>  <strong>A</strong> → <strong>𝜶</strong><strong>A</strong><sup><strong>′</strong></sup>, <strong>A</strong><sup><strong>′</strong></sup> → <strong>𝜷</strong><sub><strong>1</strong></sub>|<strong>𝜷</strong><sub><strong>2</strong></sub></span></li></ul></li><li><strong>How</strong>:<ul><li>For each non-terminal <span class="math inline"><strong>A</strong></span>, find the longest commonprefix <span class="math inline"><strong>𝜶</strong></span> of itsalternatives.</li><li>If <span class="math inline"><strong>𝜶</strong></span> is not empty,replace all of the <span class="math inline"><strong>A</strong></span>-productions</li></ul></li><li><strong>Example</strong>:<ul><li><span class="math inline"><strong>A</strong> → <strong>𝜶</strong><strong>𝜷</strong><sub><strong>1</strong></sub>|<strong>𝜶</strong><strong>𝜷</strong><sub><strong>2</strong></sub>|...|<strong>𝜶</strong><strong>𝜷</strong><sub><strong>n</strong></sub>|<strong>𝜸</strong>    <em>b</em><em>y</em>    <strong>A</strong> → <strong>𝜶</strong><strong>A</strong><sup><strong>′</strong></sup>|<em>𝜸</em>, <strong>A</strong><sup><strong>′</strong></sup> → <strong>𝜷</strong><sub><strong>1</strong></sub>|<strong>𝜷</strong><sub><strong>2</strong></sub>|...|<strong>𝜷</strong><sub><strong>n</strong></sub></span></li></ul></li></ul><h4 id="non-ll1-grammar">Non-LL(1) Grammar</h4><ul><li>Non-LL(1) Grammars:<ul><li>grammars with Left Recursion （左递归的文法）</li><li>grammars not Left Factored （未左因子化的文法）</li><li>grammars with Ambiguity （歧义文法）</li></ul></li><li>Thus, before Predictive Parsing,<ul><li><strong>perform Left Factoring</strong> （左因子化）</li><li><strong>eliminate Left Recursion</strong> (prerequisite of theelimination?) （消除左递归）</li><li>remove Ambiguity （消除歧义）</li></ul></li></ul><h2 id="bottom-up-parsing">Bottom-Up Parsing</h2><ul><li><strong>What</strong>: the construction of a parse tree beginning atthe leaves and working up to the root（从叶子开始构建解析树，直到根）</li><li><strong>Why</strong>: not all grammars can be made LL(1)</li><li><strong>How</strong>: construct rightmost derivation in the reverseorder<ul><li><strong>Reduction</strong>: “Reversed Derivation”（归约：反向派生）<ul><li>from the string to the start symbol （从字符串到起始符号）</li><li>The body of a production is replaced by the non-terminal at itsheader. （用产生式的头部替换产生式的主体）</li></ul></li><li><span class="math inline">$S \overset{rm}{\Rightarrow} \gamma_0\overset{rm}{\Rightarrow} \gamma_1 \overset{rm}{\Rightarrow} \dots\overset{rm}{\Rightarrow} \gamma_n \overset{rm}{\Rightarrow}\omega$</span><ul><li>find the rightmost derivation in the reverse order: “leftmostreduction” （找到右侧派生的反向顺序：最左侧归约）</li></ul></li><li>“<strong>L</strong>eft-to-Right, <strong>R</strong>ightmostDerivation in Reverse”: <strong>LR Parsing</strong></li></ul></li><li><strong>Example</strong>： <img src="image-27.png" srcset="/img/loading/loading3.gif" lazyload><ul><li><span class="math inline"><em>E</em> ⇒ <em>T</em> ⇒ <em>T</em> * <em>F</em> ⇒ <em>T</em> * <em>i</em><em>d</em> ⇒ <em>F</em> * <em>i</em><em>d</em> ⇒ <em>i</em><em>d</em> * <em>i</em><em>d</em></span></li></ul></li></ul><h3 id="handles">Handles</h3><ul><li><strong>What</strong>: if <span class="math inline">$\mathbf{S}\overset{*}{\Rightarrow} \mathbf{\alpha A \omega}\overset{}{\Rightarrow} \mathbf{\alpha \beta \omega}$</span>, thenproduction <span class="math inline"><strong>A</strong> <strong>→</strong> <strong>β</strong></span>in the position following <span class="math inline"><strong>α</strong></span> is a<strong>handle</strong> of <span class="math inline"><strong>α</strong><strong>β</strong><strong>ω</strong></span>.<ul><li>a substring that matches the body of a production, representing astep of reduction （与产生式的主体匹配的子字符串，表示归约的一步）</li><li>a pair of values: <strong>(production, position)</strong></li></ul></li><li><strong>Why</strong>: handle pruning for bottom-up parsing（处理底向上解析的剪枝）<ul><li>identify handles and reduce them to the appropriate leftmostnon-terminals （识别句柄并将其归约到适当的最左非终结符）</li></ul></li><li><strong>How</strong>: by using a stack to keep track of the currentposition in the input string and the corresponding production rules（使用栈来跟踪输入字符串中的当前位置和相应的产生式规则）</li><li><strong>Example</strong>： <img src="image-28.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="shift-reduce-parsing-移进归约解析">Shift-Reduce Parsing（移进归约解析）</h3><ul><li><strong>How</strong>: Stack + Input Buffer<ul><li><strong>Stack</strong>: reduced Grammar Symbols</li><li><strong>Input Buffer</strong>: rest of the String to be parsed</li></ul></li><li><strong>Actions</strong><ul><li><strong>Shift</strong>: move the next symbol onto stack</li><li><strong>Reduce</strong>: replace the handle on the top of stack</li><li><strong>Accept</strong>: announce the success of parsing</li><li><strong>Error</strong>: discover syntax errors, and call forrecovery</li></ul></li><li><strong>Example</strong>: <img src="image-29.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="operator-precedence-parsing-运算符优先解析">Operator-PrecedenceParsing （运算符优先解析）</h3><ul><li><strong>What</strong>: a shift-reduce parser handlingoperator-precedence grammar （处理运算符优先文法的移位归约解析器）<ul><li>operator-precedence grammar: a subset of LR(1) grammar（运算符优先文法：LR(1)文法的一个子集）</li><li>for each Production:<ul><li>no 𝝐 in the body （主体中没有空字符）</li><li>no two consecutive non-terminals in the body（在主体中没有两个连续的非终结符）</li></ul></li></ul></li><li><strong>Why</strong>: to handle expressions with operator precedenceand associativity （处理具有运算符优先级和结合性的表达式）</li><li><strong>How</strong>: find handles according precedence<ul><li><strong>Precedence</strong> （优先级）<ul><li><span class="math inline"><strong>a</strong> &lt; ·<strong>b</strong></span>:a’s precedence is lower than b’s</li><li><span class="math inline"><strong>a</strong> = ·<strong>b</strong></span>: …is equal to …</li><li><span class="math inline"><strong>a</strong> &gt; ·<strong>b</strong></span>:… is higher than …</li></ul></li><li><strong>Precedence Climbing Method</strong> （优先级爬升法）<ul><li>scan the input <strong>from Left to Right</strong> until &gt;· isencountered</li><li>then, scan <strong>backward</strong> until &lt;· is encountered</li><li>that between &lt;· and &gt;· is the <strong>handle</strong></li></ul></li><li><strong>Implementation with STACK</strong> (栈实现)<ul><li>let <span class="math inline"><strong>a</strong></span> be the<strong>top Terminal</strong> on the STACK （栈顶终结符）</li><li>let <span class="math inline"><strong>b</strong></span> be the INPUTSymbol under processing （正在处理的输入符号）</li><li>if <span class="math inline"><strong>a</strong> &lt; ·<em>o</em><em>r</em> = ·<strong>b</strong></span>,<strong>Shift</strong></li><li>else if <span class="math inline"><strong>a</strong> &gt; ·<strong>b</strong></span>,<strong>Reduce</strong></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-30.png" srcset="/img/loading/loading3.gif" lazyload> <img src="image-31.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="opp-precedence-relation-construction-优先级关系构造">OPP:Precedence Relation Construction （优先级关系构造）</h3><h4 id="precedence-relation">Precedence Relation</h4><ul><li>If operator <span class="math inline"><strong>a</strong></span> hashigher precedence than <span class="math inline"><strong>b</strong></span><ul><li><span class="math inline"><strong>a</strong> &gt; ·<strong>b</strong></span></li><li><span class="math inline"><strong>b</strong> &lt; ·<strong>a</strong></span></li></ul></li><li>If <span class="math inline"><strong>a</strong></span> and <span class="math inline"><strong>b</strong></span> has equal precedence<ul><li>if left-associative, then <span class="math inline"><strong>a</strong> &gt; ·<strong>b</strong></span>and <span class="math inline"><strong>b</strong> &gt; ·<strong>a</strong></span></li><li>if right-associative, then <span class="math inline"><strong>a</strong> &lt; ·<strong>b</strong></span>and <span class="math inline"><strong>b</strong> &lt; ·<strong>a</strong></span></li></ul></li><li>For all operator <span class="math inline"><strong>a</strong></span><ul><li><span class="math inline"><strong>a</strong> &lt; ·<em>i</em><em>d</em>,  <em>i</em><em>d</em> &gt; ·<strong>a</strong></span></li><li><span class="math inline">$ &lt; ·<strong>a</strong>,  <strong>a</strong> &gt; ·$</span></li><li><span class="math inline"><strong>a</strong> &lt; ·(,  ( &lt; ·<strong>a</strong>,  <strong>a</strong> &gt; ·),  ) &gt; ·<strong>a</strong></span></li><li><span class="math inline">( = ·)</span></li></ul></li></ul><h4 id="leading-and-trailing">LEADING and TRAILING</h4><ul><li><strong>LEADING</strong>: the set of symbols that can appear at thebeginning of a string derived from a non-terminal（可以出现在从非终结符派生的字符串开头的符号集合）<ul><li><span class="math inline">$\mathbf{LEADING(Q)} = \{\mathbf{Y},\mathbf{N} \ | \ \mathbf{Q} \overset{+}{\Rightarrow} \mathbf{Y\delta} \or\  \mathbf{Q} \overset{+}{\Rightarrow} \mathbf{N Y \delta}, \mathbf{N}\in \mathbf{V_n}, \mathbf{Y} \in \mathbf{V_t}\}$</span></li><li>for <span class="math inline"><strong>Q</strong> → <strong>Y</strong><strong>δ</strong></span>or <span class="math inline"><strong>Q</strong> → <strong>N</strong><strong>Y</strong><strong>δ</strong></span>,we have:<ul><li><span class="math inline"><strong>Y</strong>, <strong>N</strong> ∈ <strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>Q</strong><strong>)</strong></span></li><li><span class="math inline"><strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>N</strong><strong>)</strong> ⊆ <strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>Q</strong><strong>)</strong></span></li></ul></li></ul></li><li><strong>TRAILING</strong>: the set of symbols that can appear at theend of a string derived from a non-terminal（可以出现在从非终结符派生的字符串末尾的符号集合）<ul><li><span class="math inline">$\mathbf{TRAILING(P)} = \{\mathbf{X},\mathbf{N} \ | \ \mathbf{P} \overset{+}{\Rightarrow} \mu \mathbf{X} \ or\ \mathbf{P} \overset{+}{\Rightarrow} \mu \mathbf{X} \mathbf{N},\mathbf{N} \in \mathbf{V_n}, \mathbf{X} \in \mathbf{V_t}\}$</span></li><li>for <span class="math inline"><strong>P</strong> → <em>μ</em><strong>X</strong></span>or <span class="math inline"><strong>P</strong> → <em>μ</em><strong>X</strong><strong>N</strong></span>,we have:<ul><li><span class="math inline"><strong>X</strong>, <strong>N</strong> ∈ <strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>P</strong><strong>)</strong></span></li><li><span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>N</strong><strong>)</strong> ⊆ <strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>P</strong><strong>)</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-32.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="constructing-precedence-relations">Constructing PrecedenceRelations</h4><ul><li><span class="math display"><strong>X</strong> = ·<strong>Y</strong></span><ul><li>if there is <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>Y</strong><strong>β</strong></span>,where <span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong></span>,<span class="math inline"><strong>α</strong>, <strong>β</strong> ∈ <strong>V</strong><sup><strong>*</strong></sup></span></li><li>or, there is <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>N</strong><strong>Y</strong><strong>β</strong></span>,where <span class="math inline"><strong>N</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub> ∪ {<strong>ϵ</strong>}</span>,<span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong><sub><strong>t</strong></sub></span><ul><li>adjacent symbols have equal precedence （相邻符号具有相等的优先级）<ul><li>at least one of them is a terminal （至少有一个是终结符）</li></ul></li><li>e.g., <span class="math inline"><strong>E</strong> + <strong>T</strong></span>,<span class="math inline"><strong>T</strong> * <strong>F</strong></span>,<span class="math inline"><strong>E</strong>+ = <strong>T</strong></span></li></ul></li></ul></li><li><span class="math display"><strong>X</strong> &lt; ·<strong>Y</strong></span><ul><li>if there is <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>Q</strong><strong>β</strong></span>,and <span class="math inline">$\mathbf{Q} \overset{+}{\Rightarrow}\mathbf{Y \delta}$</span>, where <span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong></span>,<span class="math inline"><strong>Q</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,<span class="math inline"><strong>α</strong>, <strong>β</strong>, <strong>δ</strong> ∈ <strong>V</strong><sup><strong>*</strong></sup></span></li><li>or, there is <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>Q</strong><strong>β</strong></span>,and <span class="math inline">$\mathbf{Q} \overset{+}{\Rightarrow}\mathbf{N Y \delta}$</span>, where <span class="math inline"><strong>N</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub> ∪ {<strong>ϵ</strong>}</span>,<span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong><sub><strong>t</strong></sub></span><ul><li><span class="math inline">$\mathbf{LEADING(Q)} = \{\mathbf{Y},\mathbf{N} \ | \ \mathbf{Q} \overset{+}{\Rightarrow} \mathbf{Y\delta} \or\  \mathbf{Q} \overset{+}{\Rightarrow} \mathbf{N Y \delta}\}$</span><ul><li>for <span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong><strong>Q</strong><strong>β</strong></span>,we have <span class="math inline"><strong>X</strong></span> &lt;·Symbols in <span class="math inline"><strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>Q</strong><strong>)</strong></span></li></ul></li></ul></li></ul></li><li><span class="math display"><strong>X</strong> &gt; ·<strong>Y</strong></span><ul><li>if there is <span class="math inline"><strong>A</strong> → <em>α</em><strong>P</strong><strong>Y</strong><em>β</em></span>,and <span class="math inline">$\mathbf{P} \overset{+}{\Rightarrow} \mu\mathbf{X}$</span>, where <span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong></span>,<span class="math inline"><strong>P</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,<span class="math inline"><em>α</em>, <em>β</em>, <em>μ</em> ∈ <strong>V</strong><sup>*</sup></span></li><li>or, there is <span class="math inline"><strong>A</strong> → <em>α</em><strong>P</strong><strong>Y</strong><em>β</em></span>,and <span class="math inline">$\mathbf{P} \overset{+}{\Rightarrow} \mu\mathbf{X} \mathbf{N}$</span>, where <span class="math inline"><strong>N</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub> ∪ {<em>ϵ</em>}</span>,<span class="math inline"><strong>P</strong> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,<span class="math inline"><strong>X</strong>, <strong>Y</strong> ∈ <strong>V</strong><sub><strong>T</strong></sub></span></li><li><span class="math inline">$\mathbf{TRAILING(P)} = \{\mathbf{X},\mathbf{N} \ | \ \mathbf{P} \overset{+}{\Rightarrow} \mu \mathbf{X} \\text{or} \ \mathbf{P} \overset{+}{\Rightarrow} \mu \mathbf{X}\mathbf{N}\}$</span><ul><li>for <span class="math inline"><strong>A</strong> → <em>α</em><strong>P</strong><strong>Y</strong><em>β</em></span>,we have Symbols in <span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>P</strong><strong>)</strong> &gt; ·<strong>Y</strong></span></li></ul></li></ul></li></ul><h4 id="precedence-table">Precedence Table</h4><ul><li><strong>Steps</strong>：<ul><li>for each production <span class="math inline"><strong>A</strong> → <strong>X</strong><sub><strong>1</strong></sub><strong>X</strong><sub><strong>2</strong></sub><strong>…</strong><strong>X</strong><sub><strong>k</strong></sub></span>:<ul><li>for each <span class="math inline"><strong>X</strong></span><ul><li>if <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>,then <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> = ·<strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub></span></li><li>if <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>2</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,then <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> = ·<strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>2</strong></sub></span></li><li>if <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>,then <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> &lt; ·<strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub><strong>)</strong></span></li><li>if <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> ∈ <strong>V</strong><sub><strong>n</strong></sub></span>and <span class="math inline"><strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub> ∈ <strong>V</strong><sub><strong>t</strong></sub></span>,then <span class="math inline"><strong>X</strong><sub><strong>i</strong></sub> = ·<strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub></span>and <span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>X</strong><sub><strong>i</strong></sub><strong>)</strong> &gt; ·<strong>X</strong><sub><strong>i</strong> <strong>+</strong> <strong>1</strong></sub></span></li></ul></li></ul></li><li>for the Start Symbol <span class="math inline"><strong>S</strong></span>:<ul><li><span class="math inline">$ &lt; ·<strong>L</strong><strong>E</strong><strong>A</strong><strong>D</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>S</strong><strong>)</strong></span></li><li><span class="math inline"><strong>T</strong><strong>R</strong><strong>A</strong><strong>I</strong><strong>L</strong><strong>I</strong><strong>N</strong><strong>G</strong><strong>(</strong><strong>S</strong><strong>)</strong> &gt; ·$</span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-33.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="opp-some-more">OPP: Some More</h3><ul><li>Unary Minus vs.&nbsp;Binary Minus （一元负号与二元负号）</li><li>Leave It to Scanners （留给扫描器）<ul><li>return two different tokens for the two（返回两个不同的tokens）</li><li>lookahead is required （需要向前看）</li></ul></li><li>OPPs are not used often in practice （运算符优先级在实践中不常用）<ul><li>limited scenarios and applications （有限的场景和应用）</li><li>but, simple -&gt; part of a complex parsing system（但简单，是复杂解析系统的一部分）</li></ul></li></ul><h2 id="lr-parsing">LR Parsing</h2><ul><li><strong>What</strong>:<ul><li>left-to-right scanning</li><li>rightmost derivation in reverse</li></ul></li><li><strong>Why</strong><ul><li>can recognize virtually all programming languages of context-freegrammars （几乎可以识别所有上下文无关文法的编程语言）</li><li>is the most general non-backtracking shift-reduce parsing methodknown （已知的最通用的非回溯移位归约解析方法）<ul><li>yet is still efficient （仍然高效）</li></ul></li><li>can detect a syntax error as soon as possible（尽快检测语法错误）</li><li>is a proper superset of the predictive parsing（是预测解析的适当超集）</li></ul></li></ul><h3 id="lr0-parsing">LR(0) Parsing</h3><h4 id="items-and-the-lr0-automaton">Items and the LR(0) Automaton</h4><ul><li><strong>Problem</strong>: when to shift and when to reduce?<ul><li>how to decide whether that on the top of the stack is a handle?（如何判断栈顶的句柄？）</li></ul></li><li><strong>LR(0) Items</strong>: a production with a dot at someposition in its body （LR(0) 项目：在其主体的某个位置有一个点的产生式）<ul><li>prefixes of a valid production, indicating how much we have seen atthe point （有效产生式的前缀，指示我们在该点上已经看到多少）</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong><strong>Z</strong></span>yields four items（例如<span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong><strong>Z</strong></span>产生四个项）：<ul><li><span class="math inline"><strong>A</strong> → ⋅<strong>X</strong><strong>Y</strong><strong>Z</strong></span>:hope to see <span class="math inline"><strong>X</strong><strong>Y</strong><strong>Z</strong></span>next on the input</li><li><span class="math inline"><strong>A</strong> → <strong>X</strong> ⋅ <strong>Y</strong><strong>Z</strong></span>:hope to see <span class="math inline"><strong>Y</strong><strong>Z</strong></span> next onthe input</li><li><span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong> ⋅ <strong>Z</strong></span>:hope to see <span class="math inline"><strong>Z</strong></span> next onthe input</li><li><span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong><strong>Z</strong>⋅</span>:hope to see nothing next on the input</li></ul></li><li>kind of state + transition → automaton</li></ul></li><li><strong>Kernel and Non-Kernel Items</strong><ul><li><strong>Kernel Items</strong>: the Initial Item + those whose dotsare not at the left</li><li><strong>Non-Kernel Items</strong>: Otherwise</li></ul></li><li><strong>LR(0) Automaton</strong>: <strong>CLOSURE + GOTO</strong><ul><li><strong>CLOSURE</strong>: set of <strong>Items</strong>（项集的闭包）</li><li><strong>GOTO</strong>: the <strong>Transition Function</strong>（转换函数）</li></ul></li></ul><h4 id="closure-and-goto">CLOSURE and GOTO</h4><ul><li><span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>:<ul><li><span class="math inline"><strong>I</strong></span>: a set of Itemsfor a grammar <span class="math inline"><strong>G</strong></span>（文法<span class="math inline"><strong>G</strong></span>的项集）</li><li>construct by two rules:<ol type="1"><li>every Item in <span class="math inline"><strong>I</strong></span> isadded in to <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>（<span class="math inline"><strong>I</strong></span>中的每个项目都添加到<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>中）</li><li>if <span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>B</strong><strong>β</strong></span>is in <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>and <span class="math inline"><strong>B</strong> → <strong>γ</strong></span> is aproduction of <span class="math inline"><strong>G</strong></span>, thenadd <span class="math inline"><strong>B</strong> → ⋅<strong>γ</strong></span> to<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>（如果<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>B</strong><strong>β</strong></span>在<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>中，并且<span class="math inline"><strong>B</strong> → <strong>γ</strong></span>是<span class="math inline"><strong>G</strong></span>的一个产生式，则将<span class="math inline"><strong>B</strong> → ⋅<strong>γ</strong></span>添加到<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>中）</li></ol></li><li><strong>Example</strong>: <img src="image-34.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>:<ul><li><span class="math inline"><strong>I</strong></span>: a set of Itemsfor a grammar <span class="math inline"><strong>G</strong></span>（文法<span class="math inline"><strong>G</strong></span>的项集）</li><li><span class="math inline"><strong>X</strong></span>: a grammarsymbol （文法符号）</li><li>the closure of the set of items [<span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong> ⋅ <strong>β</strong></span>]such that [<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>X</strong><strong>β</strong></span>]is in <span class="math inline"><strong>I</strong></span> （<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>是<span class="math inline"><strong>I</strong></span>中所有形如[<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>X</strong><strong>β</strong></span>]的项所对应的项[<span class="math inline"><strong>A</strong> → <strong>α</strong><strong>X</strong> ⋅ <strong>β</strong></span>]的集合的闭包）<ul><li>the transition from the state for <span class="math inline"><strong>I</strong></span> under input <span class="math inline"><strong>X</strong></span> （在输入<span class="math inline"><strong>X</strong></span>下，<span class="math inline"><strong>I</strong></span>的状态转换）</li></ul></li><li>construct by<ol type="1"><li>for each Item <span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>X</strong><strong>β</strong></span>in <span class="math inline"><strong>I</strong></span></li><li>then every Item in <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>A</strong> <strong>→</strong> <strong>α</strong><strong>X</strong> <strong>⋅</strong> <strong>β</strong><strong>)</strong></span>is added to <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span></li></ol></li><li><strong>Example</strong>: <img src="image-35.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li></ul><h4 id="automaton-construction">Automaton Construction</h4><ul><li><strong>INPUT</strong>: a grammar <span class="math inline"><strong>G</strong></span></li><li><strong>OUTPUT</strong>: a LR(0) automaton</li><li><strong>Construction</strong>:<ol type="1"><li>augment <span class="math inline"><strong>G</strong></span> to <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>by adding a new start symbol <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup></span>and production <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong></span>（通过添加新的起始符号<span class="math inline"><strong>S</strong><sup><strong>′</strong></sup></span>和产生式<span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong></span>扩展文法<span class="math inline"><strong>G</strong></span>至<span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>）</li><li><span class="math inline"><strong>C</strong></span>:= {<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>S</strong><sup><strong>′</strong></sup> <strong>→</strong> <strong>⋅</strong><strong>S</strong><strong>)</strong></span>}（先求<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>S</strong><sup><strong>′</strong></sup> <strong>→</strong> <strong>⋅</strong><strong>S</strong><strong>)</strong></span>，作为闭包的集合<span class="math inline"><strong>C</strong></span>中的第一个闭包）</li><li>repeat:<ul><li>for each Item <span class="math inline"><strong>I</strong></span> in<span class="math inline"><strong>C</strong></span> and each grammarsymbol <span class="math inline"><strong>X</strong></span> in <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>（对<span class="math inline"><strong>C</strong></span>中每个项目<span class="math inline"><strong>I</strong></span>和<span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>中的每个文法符号<span class="math inline"><strong>X</strong></span>）<ul><li>if <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>is not empty and not in <span class="math inline"><strong>C</strong></span> （如果<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>不为空且不在<span class="math inline"><strong>C</strong></span>中，注意<span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>是项集<span class="math inline"><strong>I</strong></span>在输入符号<span class="math inline"><strong>X</strong></span>下的转换的闭包）<ul><li>add <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>to <span class="math inline"><strong>C</strong></span></li></ul></li></ul></li></ul></li><li>until no new Items are added to <span class="math inline"><strong>C</strong></span></li></ol></li><li><strong>Example</strong>: <img src="image-36.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="parsing-table-construction">Parsing Table Construction</h4><ul><li><strong>LR(0) Parsing Table <span class="math inline">𝕋</span></strong>:<ul><li><strong>Rows</strong>: <strong>states</strong></li><li><strong>Columns</strong>: <strong>grammar symbols</strong><ul><li><strong>terminals</strong> for <span class="math inline"><strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong></span>and <span class="math inline"><strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong></span>actions</li><li><strong>non-terminals</strong> for <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>actions</li></ul></li><li><strong>Construction</strong>: each edge <span class="math inline"><strong>X</strong></span>: <span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span>（对于每条边<span class="math inline"><strong>X</strong></span>，<span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span>为其起始和终止状态，X为文法符号）<ul><li>if <span class="math inline"><strong>X</strong></span> is a<strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong>&nbsp;<em>n</em></span>（记作s n）</li><li>if <span class="math inline"><strong>X</strong></span> is a<strong>non-terminal</strong> <span class="math inline"><strong>A</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>A</em>] = <strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong>&nbsp;<em>n</em></span>（记作n）</li><li>if <span class="math inline"><strong>A</strong> → <strong>β</strong>⋅</span> isin <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then for each <strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong>&nbsp;<strong>A</strong> → <strong>β</strong></span>（记作r n，其中n是产生式的编号，用罗马数字表示）</li><li>if <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅</span>is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then for each <strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>A</strong><strong>C</strong><strong>C</strong><strong>E</strong><strong>P</strong><strong>T</strong></span>（记作a/acc）</li></ul></li><li><img src="image-37.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>Example</strong>: <img src="image-38.png" srcset="/img/loading/loading3.gif" lazyload> &gt;注：在上面的例子中，状态1、2、9均存在移进-归约冲突，因此不属于LR(0)文法。</li></ul><h4 id="alogrithm-and-implementation-算法与实现">Alogrithm andImplementation （算法与实现）</h4><ul><li><p><strong>INPUT</strong>: an input string <span class="math inline"><strong>ω</strong></span> and an LR-parsing table<span class="math inline">𝕋</span> for a grammar <span class="math inline"><strong>G</strong></span></p></li><li><p><strong>OUTPUT</strong>: if <span class="math inline"><strong>ω</strong> ∈ <strong>L</strong><strong>(</strong><strong>G</strong><strong>)</strong></span>,the reduction steps of a bottom-up parse for <span class="math inline"><strong>ω</strong></span></p></li><li><p><strong>STEPS</strong>: </p><figure class="shiki java"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #E06C75">let a be the first symbol of 𝜔$ </span><span style="color: #7F848E; font-style: italic">//设a是输入字符串𝜔$的第一个符号</span></span><span class="line"><span style="color: #E06C75">push state </span><span style="color: #D19A66">0</span><span style="color: #E06C75"> onto the stack </span><span style="color: #7F848E; font-style: italic">//将状态0推入栈中</span></span><span class="line"><span style="color: #C678DD">while</span><span style="color: #E06C75"> (</span><span style="color: #D19A66">1</span><span style="color: #E06C75">) {</span></span><span class="line"><span style="color: #E06C75">    let s be the state on top of the stack </span><span style="color: #7F848E; font-style: italic">//设s是栈顶的状态</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">ACTION</span><span style="color: #E06C75">[s</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a] </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> shift t) { </span><span style="color: #7F848E; font-style: italic">//如果ACTION[s, a] = shift t</span></span><span class="line"><span style="color: #E06C75">        push t onto the stack </span><span style="color: #7F848E; font-style: italic">//将t推入栈中</span></span><span class="line"><span style="color: #E06C75">        let a be the next input symbol </span><span style="color: #7F848E; font-style: italic">//设a是下一个输入符号</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">ACTION</span><span style="color: #E06C75">[s</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a] </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> reduce A→𝛽) { </span><span style="color: #7F848E; font-style: italic">//如果ACTION[s, a] = reduce A→𝛽</span></span><span class="line"><span style="color: #E06C75">        pop </span><span style="color: #56B6C2">|</span><span style="color: #E06C75">𝛽</span><span style="color: #56B6C2">|</span><span style="color: #E06C75"> symbols off the stack </span><span style="color: #7F848E; font-style: italic">//从栈中弹出|𝛽|（𝛽包含的符号数）个状态</span></span><span class="line"><span style="color: #E06C75">        let t be the top of the stack now </span><span style="color: #7F848E; font-style: italic">//设t是栈顶的状态</span></span><span class="line"><span style="color: #E06C75">        push </span><span style="color: #E5C07B">GOTO</span><span style="color: #E06C75">[t</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> A] onto the stack </span><span style="color: #7F848E; font-style: italic">//将GOTO[t, A]推入栈中</span></span><span class="line"><span style="color: #E06C75">    }</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> </span><span style="color: #C678DD">if</span><span style="color: #E06C75"> (</span><span style="color: #E5C07B">ACTION</span><span style="color: #E06C75">[s</span><span style="color: #ABB2BF">,</span><span style="color: #E06C75"> a] </span><span style="color: #56B6C2">=</span><span style="color: #E06C75"> accept) </span><span style="color: #C678DD">break</span><span style="color: #E06C75"> </span><span style="color: #7F848E; font-style: italic">//如果ACTION[s, a] = accept，则结束</span></span><span class="line"><span style="color: #E06C75">    </span><span style="color: #C678DD">else</span><span style="color: #E06C75"> call error</span><span style="color: #56B6C2">-</span><span style="color: #E06C75">handling routine</span></span><span class="line"><span style="color: #E06C75">}</span></span></code></pre></div></div></figure><p></p></li><li><p><strong>Example</strong>: <img src="image-39.png" srcset="/img/loading/loading3.gif" lazyload></p></li></ul><h4 id="lr0-conflicts">LR(0) Conflicts</h4><ul><li><strong>Reduce-Reduce Conflicts</strong>:<ul><li>state has two reduce items</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>α</strong>⋅</span> and<span class="math inline"><strong>B</strong> → <strong>β</strong>⋅</span></li></ul></li><li><strong>Shift-Reduce Conflicts</strong>:<ul><li>state has a reduce item and a shift item</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>k</strong><strong>γ</strong></span>and <span class="math inline"><strong>B</strong> → <strong>β</strong>⋅</span></li></ul></li><li>To avoid conflicts: <strong>SLR(1) Parsing</strong></li></ul><h3 id="slr1-parsing">SLR(1) Parsing</h3><h4 id="parsing-table-construction-1">Parsing Table Construction</h4><ul><li><strong>LR(0) Parsing Table</strong> <span class="math inline">𝕋</span> <span class="math inline">⇒</span><strong>SLR(1) Parsing Table</strong> <span class="math inline">𝕋</span><ul><li><strong>Rows</strong>: <strong>states</strong></li><li><strong>Columns</strong>: <strong>grammar symbols</strong><ul><li><strong>terminals</strong> for <span class="math inline"><strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong></span>and <span class="math inline"><strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong></span>actions</li><li><strong>non-terminals</strong> for <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>actions</li></ul></li><li><strong>Construction</strong>: each edge <span class="math inline"><strong>X</strong></span>: <span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span><ul><li>if <span class="math inline"><strong>X</strong></span> is a<strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline"><strong>X</strong></span> is a<strong>non-terminal</strong> <span class="math inline"><strong>A</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>A</em>] = <strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline"><strong>A</strong> → <strong>β</strong>⋅</span> isin <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then for each <strong>terminal</strong> <span class="math inline"><strong>a</strong> ∈ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>,<span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong>&nbsp;<strong>A</strong> → <strong>β</strong></span>（只对<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong></span>中的终结符进行归约）</li><li>if <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅</span>is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, $] = <strong>A</strong><strong>C</strong><strong>C</strong><strong>E</strong><strong>P</strong><strong>T</strong></span>（只对$进行归约）</li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-40.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="slr1-conflicts">SLR(1) Conflicts</h4><ul><li><strong>Reduce-Reduce Conflicts</strong>:<ul><li>state has two reduce items</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>α</strong>⋅</span> and<span class="math inline"><strong>B</strong> → <strong>β</strong>⋅</span><ul><li>if <span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong> ∩ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>B</strong><strong>)</strong> = ∅</span>,safe for SLR(1) （如果<span class="math inline"><strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>A</strong><strong>)</strong> ∩ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>B</strong><strong>)</strong> = ∅</span>，则SLR(1)安全）</li></ul></li></ul></li><li><strong>Shift-Reduce Conflicts</strong>:<ul><li>state has a reduce item and a shift item</li><li>e.g.&nbsp;<span class="math inline"><strong>A</strong> → <strong>α</strong> ⋅ <strong>k</strong><strong>γ</strong></span>and <span class="math inline"><strong>B</strong> → <strong>β</strong>⋅</span><ul><li>if <span class="math inline"><strong>k</strong> ∉ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>B</strong><strong>)</strong></span>,safe for SLR(1) （如果<span class="math inline"><strong>k</strong> ∉ <strong>F</strong><strong>O</strong><strong>L</strong><strong>L</strong><strong>O</strong><strong>W</strong><strong>(</strong><strong>B</strong><strong>)</strong></span>，则SLR(1)安全）</li></ul></li></ul></li></ul><h3 id="lr1-parsing">LR(1) Parsing</h3><ul><li><strong>How</strong>: check the <strong>immediate</strong> followingsymbols of non-terminals for reduction（检查非终结符的直接后续符号以进行归约）</li><li><strong>LR(1) Item</strong> = [<strong>LR(0) Item</strong>,<strong>Following Symbol</strong>]<ul><li>e.g.&nbsp;<span class="math inline">[<strong>A</strong> → <strong>X</strong><strong>Y</strong> ⋅ <strong>Z</strong>, <strong>a</strong>]</span></li><li>where <span class="math inline"><strong>a</strong></span> is thefollowing <strong>terminal</strong> symbol of <span class="math inline"><strong>A</strong></span> （<span class="math inline"><strong>a</strong></span>是<span class="math inline"><strong>A</strong></span>的后续终结符）</li><li>when <span class="math inline"><strong>Z</strong></span> is notempty, the same as LR(0) Item （当<span class="math inline"><strong>Z</strong></span>不为空时，与LR(0)项相同）</li><li>otherwise, <span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong> ⋅ <strong>Z</strong></span>is applied only when the next input symbol is <span class="math inline"><strong>a</strong></span>（否则，只有在下一个输入符号为<span class="math inline"><strong>a</strong></span>时才应用<span class="math inline"><strong>A</strong> → <strong>X</strong><strong>Y</strong> ⋅ <strong>Z</strong></span>）<ul><li>instead of SLR(1)’s ALL <span class="math inline"><strong>A</strong></span>’s following symbols, letalong LR(0)’s ALL terminal symbols （而不是SLR(1)的所有<span class="math inline"><strong>A</strong></span>的后续符号，甚至LR(0)的所有终结符）</li></ul></li></ul></li></ul><h4 id="lr1s-closure-and-goto">LR(1)’s CLOSURE and GOTO</h4><ul><li><strong>LR(1)’s <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span></strong><ul><li>every Item in <span class="math inline"><strong>I</strong></span> isadded in to <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span></li><li>repeat:<ul><li>if <span class="math inline">[<strong>A</strong> → <strong>α</strong> ⋅ <strong>B</strong><strong>β</strong>, <strong>a</strong>]</span>is in <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span>and <span class="math inline"><strong>B</strong> → <strong>γ</strong></span> is aproduction of <span class="math inline"><strong>G</strong></span>, thenfor each terminal <span class="math inline"><strong>b</strong></span> in<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>a</strong><strong>)</strong></span>,add <span class="math inline">[<strong>B</strong> → ⋅<strong>γ</strong>, <strong>b</strong>]</span>into <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span></li><li>until no more new Items can be added into <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>I</strong><strong>)</strong></span></li></ul></li><li>only reduce <span class="math inline"><strong>B</strong></span> whenit is followed by that in <span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>a</strong><strong>)</strong></span>（仅在后面跟着<span class="math inline"><strong>F</strong><strong>I</strong><strong>R</strong><strong>S</strong><strong>T</strong><strong>(</strong><strong>β</strong><strong>a</strong><strong>)</strong></span>中的项时才归约<span class="math inline"><strong>B</strong></span>）</li></ul></li><li><strong>LR(1)’s <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>B</strong><strong>)</strong></span></strong><ul><li>if <span class="math inline">[<strong>A</strong> → <strong>α</strong> ⋅ <strong>B</strong><strong>β</strong>, <strong>a</strong>]</span>in <span class="math inline"><strong>I</strong></span></li><li>then every Item in <span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>{</strong><strong>[</strong><strong>A</strong> <strong>→</strong> <strong>α</strong><strong>B</strong> <strong>⋅</strong> <strong>β</strong><strong>,</strong> <strong>a</strong><strong>]</strong><strong>}</strong><strong>)</strong></span>is in <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>B</strong><strong>)</strong></span><ul><li><span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>B</strong><strong>)</strong> ⊇ <strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>{</strong><strong>[</strong><strong>A</strong> <strong>→</strong> <strong>α</strong><strong>B</strong> <strong>⋅</strong> <strong>β</strong><strong>,</strong> <strong>a</strong><strong>]</strong><strong>}</strong><strong>)</strong></span><ul><li></li></ul></li><li><strong>Those of Kernel Items inherited from the previousstate</strong> （从前一个状态继承的内核项）</li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-41.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="automaton-construction-1">Automaton Construction</h4><ul><li><strong>INPUT</strong>: a grammar <span class="math inline"><strong>G</strong></span></li><li><strong>OUTPUT</strong>: a LR(1) automaton</li><li><strong>Construction</strong>:<ol type="1"><li>augment <span class="math inline"><strong>G</strong></span> to <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>by adding a new start symbol <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup></span>and production <span class="math inline"><strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong></span>（扩展文法）</li><li><span class="math inline"><strong>C</strong></span>:= {<span class="math inline"><strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>[</strong><strong>S</strong><sup><strong>′</strong></sup> <strong>→</strong> <strong>⋅</strong><strong>S</strong><strong>,</strong> <strong>$</strong><strong>]</strong><strong>)</strong></span>}（初始化项集C）</li><li>repeat:<ul><li>for each Item <span class="math inline"><strong>I</strong></span> in<span class="math inline"><strong>C</strong></span> and each grammarsymbol <span class="math inline"><strong>X</strong></span> in <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span><ul><li>if <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>is not empty and not in <span class="math inline"><strong>C</strong></span><ul><li>add <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><strong>,</strong> <strong>X</strong><strong>)</strong></span>to <span class="math inline"><strong>C</strong></span></li></ul></li></ul></li></ul></li><li>until no new Items are added to <span class="math inline"><strong>C</strong></span></li></ol></li><li><strong>Example</strong>:<ol type="1"><li><strong>Example</strong>: <img src="image-42.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>Exercise</strong>: <img src="image-44.png" srcset="/img/loading/loading3.gif" lazyload></li></ol></li></ul><h4 id="parsing-table-construction-2">Parsing Table Construction</h4><ul><li><strong>LR(1) Parsing Table <span class="math inline">𝕋</span></strong>:<ul><li><strong>Rows</strong>: <strong>states</strong></li><li><strong>Columns</strong>: <strong>grammar symbols</strong><ul><li><strong>terminals</strong> for <span class="math inline"><strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong></span>and <span class="math inline"><strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong></span>actions</li><li><strong>non-terminals</strong> for <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>actions</li></ul></li><li><strong>Construction</strong>: each edge <span class="math inline"><strong>X</strong></span>: <span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span><ul><li>if <span class="math inline"><strong>X</strong></span> is a<strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline"><strong>X</strong></span> is a<strong>non-terminal</strong> <span class="math inline"><strong>A</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>A</em>] = <strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline">[<strong>A</strong> → <strong>β</strong>⋅, <strong>a</strong>]</span>(the kernel) is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong>&nbsp;<strong>A</strong> → <strong>β</strong></span></li><li>if <span class="math inline">[<strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅, $]</span>is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, $] = <strong>A</strong><strong>C</strong><strong>C</strong><strong>E</strong><strong>P</strong><strong>T</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-43.png" srcset="/img/loading/loading3.gif" lazyload> &gt;注：上表中<span class="math inline">[11, <em>i</em><em>d</em>]</span>应为<span class="math inline"><em>s</em>12</span>，即<span class="math inline">𝕋[11, <em>i</em><em>d</em>] = <em>s</em>12</span>。</li></ul><h3 id="lalr1-parsing">LALR(1) Parsing</h3><ul><li><strong>What</strong>: <strong>L</strong>ook <strong>A</strong>head<strong>LR(1)</strong></li><li><strong>Why</strong>: smaller parsing table than<strong>LR(1)</strong> for practice（比LR(1)小的解析表）<ul><li>equal to <strong>SLR(1)</strong> in state number（与SLR(1)状态数相等）<ul><li>e.g.&nbsp;In C, serveral hundred for SLR(1), serverals of thousands forLR(1)</li></ul></li><li>more powerful than <strong>SLR(1)</strong> in processing moregrammars （比SLR(1)更强大，能处理更多文法）</li></ul></li><li><strong>How</strong>: combine <strong>Items</strong> with the same<strong>Production Set</strong> in LR(1)（将LR(1)中具有相同产生式集的项（同心集）组合在一起）<ul><li>e.g.&nbsp;<span class="math inline">[<strong>A</strong> → <strong>α</strong>⋅, <strong>a</strong>]</span>and <span class="math inline">[<strong>A</strong> → <strong>α</strong>⋅, <strong>b</strong>]</span>are combined into one state</li></ul></li><li>Compared to <strong>LR(1)</strong>: <img src="image-45.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="automaton-construction-2">Automaton Construction</h4><ul><li><strong>INPUT</strong>: a grammar <span class="math inline"><strong>G</strong></span></li><li><strong>OUTPUT</strong>: a LALR(1) automaton</li><li><strong>Construction</strong>:<ol type="1"><li>Construct <strong>LR(0)</strong> items as <strong>LALR(1)</strong>items’ cores for the grammar <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>，thenremove the non-kernel items （为文法<span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>构造LR(0)项作为LALR(1)项的核心，然后删除非核心项）</li><li>For each kernal items <span class="math inline"><strong>K</strong></span> in <span class="math inline"><strong>I</strong><sub><strong>i</strong></sub></span>and each grammar symbol <span class="math inline"><strong>X</strong></span> in <span class="math inline"><strong>G</strong><sup><strong>′</strong></sup></span>,calculate the lookahead symbols’ <strong>INIT</strong> and<strong>PROPAGATION</strong>. （对于每个项集<span class="math inline"><strong>I</strong><sub><strong>i</strong></sub></span>中的核心项<span class="math inline"><strong>K</strong></span>和文法符号<span class="math inline"><strong>X</strong></span>，计算前瞻符号的初始值和传播）<ul><li>For each item <span class="math inline">(<strong>A</strong> → <strong>α</strong> ⋅ <strong>β</strong>)</span>in <span class="math inline"><strong>K</strong></span><ul><li><span class="math inline"><strong>J</strong> := {<strong>C</strong><strong>L</strong><strong>O</strong><strong>S</strong><strong>U</strong><strong>R</strong><strong>E</strong><strong>(</strong><strong>[</strong><strong>A</strong> <strong>→</strong> <strong>α</strong> <strong>⋅</strong> <strong>β</strong><strong>,</strong> <strong>#</strong><strong>]</strong><strong>)</strong>}</span>（初始化<span class="math inline"><strong>J</strong></span>）</li><li>if <span class="math inline">[<strong>B</strong> <strong>→</strong> <strong>γ</strong> <strong>⋅</strong> <strong>X</strong><strong>δ</strong><strong>,</strong> <strong>a</strong>]</span>in <span class="math inline"><strong>J</strong></span> and <span class="math inline"><strong>a</strong> <strong>≠</strong> <strong>#</strong></span>,then <span class="math inline"><strong>B</strong> <strong>→</strong> <strong>γ</strong><strong>X</strong> <strong>⋅</strong> <strong>δ</strong></span>in <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><sub><strong>i</strong></sub><strong>,</strong> <strong>X</strong><strong>)</strong></span>has a <strong>SELF-generated</strong> lookahead symbol <span class="math inline"><strong>a</strong></span> （<span class="math inline"><strong>J</strong></span>中的项若出现不为#的前瞻符号，则它是自发生成的）</li><li>if <span class="math inline">[<strong>B</strong> <strong>→</strong> <strong>γ</strong> <strong>⋅</strong> <strong>X</strong><strong>δ</strong><strong>,</strong> <strong>#</strong>]</span>in <span class="math inline"><strong>J</strong></span>, then lookaheadsymbols are <strong>propagated</strong> from <span class="math inline"><strong>A</strong> <strong>→</strong> <strong>α</strong> <strong>⋅</strong> <strong>β</strong></span>to <span class="math inline"><strong>B</strong> <strong>→</strong> <strong>γ</strong><strong>X</strong> <strong>⋅</strong> <strong>δ</strong></span>in <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong><strong>(</strong><strong>I</strong><sub><strong>i</strong></sub><strong>,</strong> <strong>X</strong><strong>)</strong></span>.（<span class="math inline"><strong>J</strong></span>中的项若出现#的前瞻符号，则该项会传播前瞻符号）</li></ul></li><li>Specifically, <span class="math inline"><strong>$</strong></span> in<span class="math inline"><strong>[</strong><strong>S</strong><sup><strong>′</strong></sup> <strong>→</strong> <strong>S</strong><strong>⋅</strong><strong>,</strong> <strong>$</strong><strong>]</strong></span>is SELF-generated.</li></ul></li><li>Construct the <span class="math inline"><strong>F</strong><strong>R</strong><strong>O</strong><strong>M</strong> <strong>−</strong> <strong>T</strong><strong>O</strong></span>table base on <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>for the kernel items to show the propagation of lookahead symbols（为核心项构建<span class="math inline"><strong>F</strong><strong>R</strong><strong>O</strong><strong>M</strong> <strong>−</strong> <strong>T</strong><strong>O</strong></span>表，以显示前瞻符号的传播）<ul><li>in step 2, we calculate <strong>propagated</strong>relationships.</li></ul></li><li>Propagate the lookahead symbols according to the <span class="math inline"><strong>F</strong><strong>R</strong><strong>O</strong><strong>M</strong> <strong>−</strong> <strong>T</strong><strong>O</strong></span>relationships until the fixed point achieved （根据<span class="math inline"><strong>F</strong><strong>R</strong><strong>O</strong><strong>M</strong> <strong>−</strong> <strong>T</strong><strong>O</strong></span>关系传播前瞻符号，直到达到不变点）<ul><li>in step 2, we calculate <strong>self-generated</strong> lookaheadsymbols.</li></ul></li></ol></li><li><strong>Example</strong>: <img src="image-54.png" srcset="/img/loading/loading3.gif" lazyload> <img src="image-46.png" srcset="/img/loading/loading3.gif" lazyload> &gt;注：上右表中，前瞻符号在传播时，每一行的前瞻符号可以向右填满右侧列，最右一列是最终结果</li></ul><h4 id="parsing-table-construction-3">Parsing Table Construction</h4><ul><li>the same as <strong>LR(1)</strong> method</li><li><strong>LALR(1) Parsing Table <span class="math inline">𝕋</span></strong>:<ul><li><strong>Rows</strong>: <strong>states</strong></li><li><strong>Columns</strong>: <strong>grammar symbols</strong><ul><li><strong>terminals</strong> for <span class="math inline"><strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong></span>and <span class="math inline"><strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong></span>actions</li><li><strong>non-terminals</strong> for <span class="math inline"><strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong></span>actions</li></ul></li><li><strong>Construction</strong>: each edge <span class="math inline"><strong>X</strong></span>: <span class="math inline">(<em>s</em><sub><em>m</em></sub>, <em>s</em><sub><em>n</em></sub>)</span><ul><li>if <span class="math inline"><strong>X</strong></span> is a<strong>terminal</strong> <span class="math inline"><strong>a</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>S</strong><strong>H</strong><strong>I</strong><strong>F</strong><strong>T</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline"><strong>X</strong></span> is a<strong>non-terminal</strong> <span class="math inline"><strong>A</strong></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>A</em>] = <strong>G</strong><strong>O</strong><strong>T</strong><strong>O</strong>&nbsp;<em>n</em></span></li><li>if <span class="math inline">[<strong>A</strong> → <strong>β</strong>⋅, <strong>a</strong>]</span>(the kernel) is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>, then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, <em>a</em>] = <strong>R</strong><strong>E</strong><strong>D</strong><strong>U</strong><strong>C</strong><strong>E</strong>&nbsp;<strong>A</strong> → <strong>β</strong></span></li><li>if <span class="math inline">[<strong>S</strong><sup><strong>′</strong></sup> → <strong>S</strong>⋅, $]</span>is in <span class="math inline"><em>s</em><sub><em>m</em></sub></span>,then <span class="math inline">𝕋[<em>s</em><sub><em>m</em></sub>, $] = <strong>A</strong><strong>C</strong><strong>C</strong><strong>E</strong><strong>P</strong><strong>T</strong></span></li></ul></li></ul></li><li><strong>Example</strong>: <img src="image-53.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="capabilities-vs.-conflicts">Capabilities vs.&nbsp;Conflicts</h4><ul><li>LALR never introduces new SHIFT-REDUCE conflicts:<ul><li><strong>SHIFT does not depend on lookaheads</strong></li></ul></li><li><strong>Example</strong>: <img src="image-47.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h3 id="summary">Summary</h3><ul><li><strong>LR(0)</strong>, <strong>SLR(1)</strong>,<strong>LR(1)</strong>, <strong>LALR(1)</strong><ul><li>all working in <strong>SHIFT-REDUCE</strong> mode</li><li>only different in Parsing Tables</li></ul></li><li><strong>Parsing Tables - Capabilities</strong><ul><li>LR(0) &lt; SLR(1) &lt; LALR(1) &lt; LR(1)</li><li>LR(0): Items</li><li>SLR(1): Items with FOLLOW</li><li>LALR(1): Items Combined from SLR(1) and LR(1)</li><li>LR(1): Items with Subset of FOLLOW</li></ul><img src="image-48.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h2 id="using-ambiguous-grammars">Using Ambiguous Grammars</h2><ul><li>In Theory: grammar for LR parsing tables should be unambiguous（在理论上：LR解析表的文法应该是无歧义的）</li><li>For ambiguous grammars:<ul><li>there will be conflicts</li><li>add new information/restrictions to resolve ambiguity（添加新信息/限制以解决歧义）<ul><li>precedence, associativity, etc.</li><li>get LR tables without conflicts</li></ul></li></ul></li><li>Why embracing ambiguous grammars?<ul><li>some are much natural, the unambiguous one can be very complex（有些是非常自然的，无歧义的可能非常复杂）</li><li>isolate common syntactic constructs for special-case optimizations（隔离常见的语法结构以进行特殊情况优化）</li></ul></li><li>Example: <img src="image-49.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h2 id="summary-1">Summary</h2><p><img src="image-50.png" srcset="/img/loading/loading3.gif" lazyload></p>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>量子力学</title>
    <link href="/posts/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/"/>
    <url>/posts/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文章基于<a href="https://teruteru.space/2023/02/24/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%AC%94%E8%AE%B0/">Teruteru的学习笔记</a>进行整理，针对2024-2025 学年春季学期教学内容进行修改。</p></blockquote><h1 id="量子力学基础">量子力学基础</h1><h2 id="热辐射">热辐射</h2><ul><li>任何固体或液体都是由分子、原子构成的，由于热运动发射各种电磁波，称为<strong>热辐射</strong>。</li><li>物体向周围辐射的能量称为<strong>辐射能</strong> 。</li><li>实验表明，热辐射具有<strong>连续的辐射谱</strong></li><li>热辐射的电磁波的波长、强度与物体的温度有关，还与物体的性质表面形状有关。一般温度越高，所发射电磁波的能量越大，在光谱分布中，强度向较短波长转移。</li><li>这说明同一物体的热辐射谱在不同波长区域分布不均匀，温度越高，光谱中最大辐射对应的波长越短，同时辐射总能量增加。</li><li>加热一物体，若物体所吸收的能量等于在同一时间内辐射的能量，则物体的温度恒定。这种温度不变的热辐射称之为<strong>平衡热辐射</strong>。</li></ul><h3 id="单色辐出度">单色辐出度</h3><p>单位时间内，从物体表面单位面积上发射波长为 <span class="math inline"><em>λ</em> ∼ <em>λ</em> + d<em>λ</em></span>的辐射能<span class="math inline">d<em>E</em><sub><em>λ</em></sub></span>，与波长间隔成正比，<span class="math inline">d<em>E</em><sub><em>λ</em></sub></span> 与 <span class="math inline">d<em>λ</em></span>的比值称为<strong>单色辐出度</strong> 。单色辐出度用 <span class="math inline"><em>M</em>(<em>λ</em>, <em>T</em>)</span> 表示，即<span class="math display">$$\begin{aligned}M(\lambda,T)=\frac{\mathrm{d} E_{\lambda}}{\mathrm{d} \lambda}\\M(\mu,T)=\frac{\mathrm{d} E_{\mu}}{\mathrm{d} \mu}\end{aligned}$$</span></p><ul><li>热辐射实验表明，<span class="math inline"><em>M</em>(<em>λ</em>, <em>T</em>)</span>与辐射物体的 <strong>温度</strong> 和辐射的 <strong>波长</strong>有关，是 <span class="math inline"><em>λ</em></span> 和 <span class="math inline"><em>T</em></span> 的函数。</li><li>单色辐出度表示在单位时间内从物体表面单位面积内发射的波长在 <span class="math inline"><em>λ</em></span> 附近窄带辐射功率密度。</li><li>单色辐出度反映了物体在不同温度下辐射能按波长分布的情况，它的单位是<span class="math inline">W/m<sup>3</sup></span>。</li></ul><h3 id="总辐出度">总辐出度</h3><p>单位时间内，从物体表面单位面积上所发射的各种波长的总辐射能称为物体的<strong>总辐出度</strong>。显然，对于一个给定的物体，总辐出度只是温度的函数，常用 <span class="math inline"><em>M</em>(<em>T</em>)</span> 表示，单位是 <span class="math inline">W/m<sup>2</sup></span>。在一定温度 <span class="math inline"><em>T</em></span>时，物体的总辐出度与单色辐出度的关系为 <span class="math display">$$\begin{aligned}M(T)&amp;=\int_{0}^{\infty} M(\lambda,T) \mathrm{d} \lambda\\&amp;=\int_{0}^{\infty} M(\nu,T) \mathrm{d} \nu \\\end{aligned}$$</span></p><p>上式表明，在相同温度下，不同物体的 <span class="math inline"><em>M</em>(<em>λ</em>, <em>T</em>)</span>不同，相应的 <span class="math inline"><em>M</em>(<em>T</em>)</span>值也不同。 <span class="math display">$$\begin{aligned}&amp;\int_{0}^{\infty}M_{\nu}\left(T\right)\text{d}\nu=M_{\nu}\left(T\right)\text{d}\left(\frac{c}{\lambda}\right)=\int_{\infty}^{0}-\frac{c}{\lambda^{2}}M_{\nu}(T)\text{d}\lambda=-\int_{0}^{\infty}M_{\lambda}\left(T\right)\text{d}\lambda\\&amp;\RightarrowM_{\lambda}\left(T\right)=M_{\nu}\left(T\right)\frac{c}{\lambda^{2}}\\\end{aligned}$$</span></p><h3 id="吸收比">吸收比</h3><p>任一物体向周围发射辐射能的同时，也吸收周围物体的辐射能。当辐射从外界入射到不透明物体时，一部分能量吸收，一部分能量反射，如果物体透明，还有一部分能量透射。吸收能量与入射能量之比称为物体的<strong>吸收比</strong>，用<span class="math inline"><em>a</em>(<em>T</em>)</span> 表示，在波长为<span class="math inline"><em>λ</em> ∼ <em>λ</em> + d<em>λ</em></span>范围内的吸收比称为<strong>单色吸收比</strong> ，用 <span class="math inline"><em>a</em>(<em>λ</em>, <em>T</em>)</span> 表示。定义吸收比 <span class="math display">$$a(T)=\frac{E^{\text {吸收 }}}{E^{\text {入射 }}}$$</span></p><p>单色吸收比 <span class="math display">$$a(\lambda, T)=\frac{E_{\lambda}^{\text {吸收 }}}{E_{\lambda}^{\text{入射 }}}$$</span></p><ul><li>如果物体在任意温度下，对任何波长的辐射吸收比都等于 <span class="math inline">1</span>，则该物体称为<strong>绝对黑体</strong>，简称<strong>黑体</strong> 。</li></ul><h3 id="反射比">反射比</h3><p>同理定义反射比 <span class="math display">$$r(T)=\frac{E^{\text {反射 }}}{E^{\text {入射 }}}$$</span></p><p>单色反射比 <span class="math display">$$r(\lambda, T)=\frac{E_{\lambda}^{\text {反射 }}}{E_{\lambda}^{\text{入射 }}}$$</span></p><p>对于不透明物体，<span class="math inline"><em>a</em>(<em>λ</em>, <em>T</em>) + <em>r</em>(<em>λ</em>, <em>T</em>) = 1</span></p><h2 id="基尔霍夫辐射定律">基尔霍夫辐射定律</h2><p>基尔霍夫从理论上提出了物体的辐出度与吸收比关系的重要定律：在相同的温度下，不同物体对相同波长的单色辐出度与单色吸收比之间的<strong>比值都相等</strong>，并等于该温度下黑体对同一波长的单色辐出度。可以表示为<span class="math display">$$\frac{M_{1}(\lambda,T)}{a_{1}(\lambda,T)}=\frac{M_{2}(\lambda,T)}{a_{2}(\lambda,T)}=\cdots=M_{0}(\lambda,T)$$</span></p><p>式中，<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>)</span>是<strong>黑体单色辐出度</strong> 。</p><ul><li>基尔霍夫辐射定律说明好的发射体一定也是好的吸收体。黑体是<strong>完全</strong> 吸收体，也是理想的发射体。</li><li>带小孔的封闭空腔体可以视为绝对黑体的模型，空腔内电磁辐射为黑体辐射。</li></ul><h2 id="斯特藩-玻耳兹曼定律">斯特藩-玻耳兹曼定律</h2><p>实验证明，黑体的总辐出度与温度的四次方成正比，即 <span class="math display"><em>M</em><sub>0</sub>(<em>T</em>) = <em>σ</em><em>T</em><sup>4</sup></span></p><ul><li>式中，<span class="math inline"><em>σ</em> = 5.67 × 10<sup>−8</sup>&nbsp;W/(m<sup>2</sup> ⋅ K<sup>4</sup>)</span>称为 Stefen 恒量。</li><li>总辐出度随着绝对温度的升高而快速增加。</li></ul><h2 id="维恩位移定律">维恩位移定律</h2><p>单色辐出度的峰值波长 <span class="math inline"><em>λ</em><sub>m</sub></span> 满足维恩位移定律，即<span class="math display"><em>λ</em><sub>m</sub><em>T</em> = <em>b</em></span></p><ul><li>式中，<span class="math inline"><em>b</em> = 2.897 × 10<sup>−3</sup>&nbsp;m ⋅ K</span>称为 Wien 常数。</li><li>随着温度的增加，热辐射的峰值波长向短波移动。</li></ul><h2 id="普朗克黑体辐射公式">普朗克黑体辐射公式</h2><p>1900 年，普朗克给出了黑体辐射满足实验结果的公式： <span class="math display">$$\begin{aligned}M_{0}(\lambda,T)=2 \pi h c^{2} \lambda^{-5} \frac{1}{\mathrm{e}^{h c /k_{\mathrm{B}} T \lambda}-1}\\M_{0}(\nu,T)=\frac{2\pi\nu^2}{c^2}\frac{h\nu}{\mathrm{e}^{h \nu /k_{\mathrm{B}} T }-1}\end{aligned}$$</span></p><ul><li>式中，<ul><li><span class="math inline"><em>c</em> = 3.0 × 10<sup>8</sup>m ⋅ s<sup>−1</sup></span>是光速</li><li><span class="math inline"><em>k</em><sub>B</sub> = 1.38 × 10<sup>−23</sup>J ⋅ K<sup>−1</sup></span>是玻尔兹曼常量</li><li><span class="math inline"><em>h</em> = 6.626 × 10<sup>−34</sup>J ⋅ s = 4.136 × 10<sup>−15</sup>eV ⋅ s</span>是普朗克常量，是一个普适常量。</li></ul></li><li>无论是短波还是长波，普朗克公式的计算结果都与实验结果一致。从理论上推导该公式时，普朗克采用了当时物理认识上一个非同寻常的假设：谐振子能量值只取某个最小能量的整数倍，即<span class="math display"><em>ε</em>, 2<em>ε</em>, 3<em>ε</em>, ⋯, <em>n</em><em>ε</em></span>式中，<span class="math inline"><em>n</em></span>为正整数，称为<strong>量子数</strong> 。对于频率为 <span class="math inline"><em>ν</em></span> 的谐振子，最小能量是 <span class="math inline"><em>ε</em> = <em>h</em><em>ν</em></span>。在辐射或吸收能量时，振子从这些状态中的一个状态跃迁到另一个状态，即振子只能跳跃式地辐射或吸收能量。</li><li>由普朗克公式可导出其他所有热辐射公式： <span class="math display">$$  M_{0}(\nu, T)=\frac{2 \pi \nu^{2}}{c^{2}} \frac{h \nu}{e^{h \nu / kT}-1}\left\{\begin{array}{l} \text { 积分 } \rightarrow M=\sigma T^{4}\\ \text { 求导 } \rightarrow T \lambda_{m}=b \\ \text { 低频 }\rightarrow M_{\nu}(T)=\frac{2 \pi \nu^{2}}{c^{2}} k T \\ \text { 高频 }\rightarrow M_{\nu}(T)=\alpha \nu^{3} e^{-\beta \nu / T}\end{array}\right.  $$</span></li></ul><h3 id="普朗克公式频率波长转换">普朗克公式频率波长转换</h3><p><span class="math display">$$\begin{aligned}&amp;M_0(\lambda)=\int_{0}^{\infty} M_{0}(\lambda, T) d\lambda=\int_{0}^{\infty} M_{0}(\nu, T) d \nu \\\Rightarrow &amp;\int_{0}^{\infty} M_{0}(\lambda,T) d\lambda=\int_{\infty}^{0} M_{0}(\nu,T)\left(-\frac{c}{\lambda^{2}}\right) d \lambda \\\Rightarrow &amp;M_{0}(\lambda, T)=M_{0}(\nu, T) \frac{c}{\lambda^{2}}\end{aligned}$$</span></p><h3 id="维恩公式">维恩公式</h3><p>当波长很短或温度较低时，普朗克公式可近似写成 <span class="math display">$$\begin{aligned}M_{0}(\lambda,T)=2 \pi h c^{2} \lambda^{-5} \mathrm{e}^{-h c /k_{\mathrm{B}} T \lambda} \\M_{0}(\nu,T)=\alpha \nu^{3} e^{-\beta \nu / T}\end{aligned}$$</span></p><p>这就是维恩公式。将黑体空腔壁分子或原子当成线性谐振子，维恩用经典热力学物理证明了<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>) = <em>c</em><sup>5</sup><em>λ</em><sup>−5</sup><em>ϕ</em>(<em>λ</em>, <em>T</em>)</span>，假设黑体辐射能谱与麦克斯韦速率分布相类似，可得出公式<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>) = <em>C</em><sub>1</sub><em>λ</em><sup>−5</sup>e<sup>−<em>C</em><sub>2</sub>/<em>T</em><em>λ</em></sup></span>，其中<span class="math inline"><em>C</em><sub>1</sub></span> 和 <span class="math inline"><em>C</em><sub>2</sub></span>是两个常数。通过对比可知，<span class="math inline"><em>C</em><sub>1</sub> = 2<em>π</em><em>h</em><em>c</em><sup>2</sup></span>，<span class="math inline"><em>C</em><sub>2</sub> = <em>h</em><em>c</em>/<em>k</em><sub>B</sub></span>。</p><h3 id="瑞利-金斯公式">瑞利-金斯公式</h3><p>当波长较长或温度较高时，普朗克公式可近似写成 <span class="math display">$$\begin{aligned}M_{0}(\lambda,T)=2 \pi k_{\mathrm{B}} c \lambda^{-4} T \\M_{0}(\nu,T)=\frac{2 \pi \nu^{2}}{c^{2}} k T\end{aligned}$$</span></p><p>这就是瑞利-金斯公式。瑞利和金斯从能量均分定律出发，每个谐振子自由度的平均能量等于<span class="math inline"><em>k</em><sub>B</sub><em>T</em></span>，从而得到了理论公式<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>) = <em>C</em><sub>3</sub><em>λ</em><sup>−4</sup><em>T</em></span>。当波长很长时，计算结果与实验结果相符，但在短波紫外区方面，随着波长趋向于零而<span class="math inline"><em>M</em><sub>0</sub>(<em>λ</em>, <em>T</em>)</span>趋向于无穷大，则计算结果与实验数据不吻合，这一结果被称为“<strong>紫外灾难</strong>”。</p><h2 id="光电效应">光电效应</h2><h3 id="实验模型">实验模型</h3><p>当光照射在金属表面上，使电子从金属中脱出的现象，称作<strong>光电效应</strong>。</p><p><img src="image-37.png" srcset="/img/loading/loading3.gif" lazyload></p><p>上图所示为研究光电效应的实验装置。在抽成真空的容器中，<span class="math inline"><em>K</em></span> 是阴极，<span class="math inline"><em>A</em></span> 是阳极。当光通过石英窗照射到金属板<span class="math inline"><em>K</em></span>上时，金属板释放电子，这种电子称为光电子。如果在 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>K</em></span>两端加上电势差，则电子在加速电场的作用下，飞向阳极 <span class="math inline"><em>A</em></span>，电路中出现电流，成为光电流，电流计可测出这个光电流。</p><h3 id="基本参数">基本参数</h3><h4 id="饱和电流">饱和电流</h4><p>实验表明，当入射光强度不变，加速电势差 <span class="math inline"><em>U</em> = <em>U</em><sub><em>A</em></sub> − <em>U</em><sub><em>K</em></sub></span>越大，光电流 <span class="math inline"><em>I</em></span>也越大，当电势差增大到一定值时，光电流达到饱和值，此时的光电流称为<strong>饱和电流</strong>。若改变入射光强，<strong>饱和电流的大小与入射光强成正比</strong>，说明从阴极逸出的电子数全部飞到阳极，单位时间从金属表面逸出的电子数与入射光强成正比。</p><h4 id="遏制电势差">遏制电势差</h4><p>当 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>K</em></span>两极的电势差为零时，光电流不为零，这说明从金属表面逸出的电子有初始动能；当负电势差不大时，尽管存在电场阻碍，但依然有部分电子可能到达阳极；如果负电势差足够大，从阴极表面逸出的具有最大速度的电子也不能到达<span class="math inline">A</span> 极，则光电流变为零。只有改变电压<span class="math inline"><em>U</em> = −<em>U</em><sub>0</sub></span>时，光电流为零，<span class="math inline"><em>U</em><sub>0</sub></span>称为<strong>遏制电势差</strong>。光电子从表面逸出的最大初速度 <span class="math inline"><em>v</em><sub>m</sub></span> 满足 <span class="math display">$$\frac{1}{2} m v_{\mathrm{m}}^{2}=e U_{0}$$</span></p><p>式中，<span class="math inline"><em>e</em></span> 和 <span class="math inline"><em>m</em></span>分别为电子电荷量和质量。<strong>最大初动能与入射光的强度无关。</strong></p><h4 id="红限频率">红限频率</h4><p>实验发现，改变入射光的频率，遏止电势差与入射光的频率之间具有线性关系，即<span class="math display"><em>U</em><sub>0</sub> = <em>K</em><em>ν</em> − <em>U</em><sub>1</sub></span></p><p>式中，<span class="math inline"><em>K</em></span>是不随金属种类变化的普适恒量；<span class="math inline"><em>U</em><sub>1</sub></span> 随金属种类不同而变化。<span class="math display">$$\frac{1}{2} m v_{\mathrm{m}}^{2}=e K \nu-e U_{1}$$</span></p><p>光电子从金属表面逸出时的最大初动能随着入射光的频率线性增加。电子初动能必须是正的，光照射金属逸出电子的条件是光的频率<span class="math inline"><em>ν</em> ≥ <em>U</em><sub>1</sub>/<em>K</em></span>。令<span class="math inline"><em>ν</em><sub>0</sub> = <em>U</em><sub>1</sub>/<em>K</em></span>，<span class="math inline"><em>ν</em><sub>0</sub></span>称为光电效应的<strong>红限频率</strong>。这意味着无论光的强度多大，当入射光的频率小于<span class="math inline"><em>ν</em><sub>0</sub></span>时，都不会发生光电效应。</p><p><img src="image-38.png" srcset="/img/loading/loading3.gif" lazyload></p><h4 id="弛豫时间">弛豫时间</h4><p>实验证明，无论入射光的强度如何，入射光照射到金属释放电子几乎是瞬时的，弛豫时间不超过<span class="math inline">1 × 10<sup>−9</sup>s</span></p><h3 id="爱因斯坦光子理论">爱因斯坦光子理论</h3><ul><li>爱因斯坦认为光的能量以颗粒形式在空间传播，这种颗粒形式的光能量称为<strong>光量子</strong>或<strong>光子</strong> ，一束光就是以光速运动的<strong>光子流</strong>。</li><li>每个光子的能量是 <span class="math inline"><em>ε</em> = <em>h</em><em>ν</em></span>，不同频率的光子具有不同的能量，光的能流密度<span class="math inline"><em>S</em></span>决定于单位时间内通过该单位面积的光子数 <span class="math inline"><em>N</em></span>。频率为 <span class="math inline"><em>ν</em></span> 的单色光的能流密度 <span class="math inline"><em>S</em> = <em>N</em><em>h</em><em>ν</em></span>。</li><li>光电效应的解释如下：当金属中一个电子从入射光中吸收一个频率为 <span class="math inline"><em>ν</em></span> 的光子后，就获得能量 <span class="math inline"><em>h</em><em>ν</em></span>，如果 <span class="math inline"><em>h</em><em>ν</em></span>大于电子从金属表面逸出所需的逸出功 <span class="math inline"><em>A</em></span>，那么这个电子就可以从金属中飞出。根据能量守恒定律，则有爱因斯坦光电效应方程<span class="math display">$$ h \nu=\frac{1}{2} mv_{\mathrm{m}}^{2}+A$$</span> 式中，<span class="math inline">$\frac{1}{2} m v_{\mathrm{m}}^{2}$</span>是光电子的<strong>最大初动能</strong> 。</li><li>如果出射电子动能为零，<span class="math inline"><em>ν</em><sub>0</sub> = <em>A</em>/<em>h</em></span>，这表明频率为<span class="math inline"><em>ν</em><sub>0</sub></span>的光子具有发射光电子的最小能量。如果光子频率低于红限频率 <span class="math inline"><em>ν</em><sub>0</sub></span>，不管有多少光子，单个光子都没有足够的能量去发射光电子，所以当光电子吸收的能量全部消耗于电子的逸出功时，入射光的频率对应于红限频率。</li><li>当光子频率大于红限频率 <span class="math inline"><em>ν</em><sub>0</sub></span>，光的强度增加时，光子数目增大，单位时间内发射的光电子数目也将增大，这说明了饱和电流与光的强度之间的正比关系。另外，当光子能量被电子全部吸收后，不需要积累能量的时间，这说明了光电效应发生的瞬时性。</li></ul><h3 id="光的波粒二象性">光的波粒二象性</h3><p><strong>光子本性是波粒二象性</strong>。光子不仅具有能量，还具有质量、动量等一般粒子共有的特性。光子质量可由爱因斯坦质能关系得到，表示为<span class="math display">$$m=\frac{\varepsilon}{c^{2}}=\frac{h \nu}{c^{2}}$$</span></p><p>光子质量是由光子能量决定的。光子的动量为 <span class="math display">$$p=m c=\frac{h \nu}{c}=\frac{h}{\lambda}$$</span></p><p>由于光子有动量，光照射到物体上时，就对物体表面施加了压力，这就是<strong>光压</strong>，这已被实验所证实。光的波动理论已被光的干涉和衍射实验所证实，而光子理论成功解释了光电效应，并且能解释光的波动理论无法解释的其他现象。因此<strong>光既有波动性又有粒子性</strong>，光具有双重性质，即光的<strong>波粒二象性</strong>。光子的能量和动量是描述粒子性的，而频率和波长是描述波动性的。</p><h2 id="康普顿效应">康普顿效应</h2><p>康普顿研究了 <span class="math inline"><em>X</em></span>射线经物质散射的实验，为光子的粒子性概念提供了有力证据。<span class="math inline"><em>X</em></span> 射线源发出一束波长为 <span class="math inline"><em>λ</em><sub>0</sub></span> 的 <span class="math inline"><em>X</em></span>射线，照射到一块石墨上。经石墨散射后，散射的 <span class="math inline">X</span>射线的波长和强度可以由晶体和探测器所组成的摄谱仪来测定。改变散射角 <span class="math inline"><em>θ</em></span>，再进行同样的测量。康普顿发现：</p><ul><li>散射光谱中除了有与入射波长 <span class="math inline"><em>λ</em><sub>0</sub></span> 相同的射线，还有波长<span class="math inline"><em>λ</em> &gt; <em>λ</em><sub>0</sub></span>的射线，这种改变波长的散射称为<strong>康普顿效应</strong> 。</li><li>波长差 <span class="math inline"><em>Δ</em><em>λ</em> = <em>λ</em> − <em>λ</em><sub>0</sub></span>随着散射角的改变而改变。散射角<strong>增大</strong>时，波长差也随着<strong>增加</strong>，而且随着散射角的增大，<strong>原波长的谱线强度减小</strong>，而<strong>新波长的谱线强度增大</strong> 。</li><li>在<strong>同一散射角</strong>下，对于所有散射物质，<strong>波长差都相同</strong>，但原波长的谱线强度随着散射物质的原子序数的增大而<strong>增加</strong>，新波长的谱线强度随之<strong>减小</strong> 。</li></ul><h3 id="解释">解释</h3><ul><li>一个光子和散射体中的一个自由电子或束缚微弱电子（原子的外层电子）发生碰撞后，从散射体射出光子的方向就是康普顿散射的方向</li><li>电子吸收一个光子能量后，发射一个散射光子，电子同时受到反冲而获得一定的能量和动量。在碰撞过程中，动量和能量守恒，入射光子的能量一部分给了电子，因此<strong>散射光子能量比入射光子能量低</strong></li><li>又根据光子满足的关系 <span class="math inline"><em>E</em> = <em>h</em><em>ν</em></span>，则<strong>散射光的频率小于入射光的频率</strong>，意味着<strong>散射光的波长大于入射光的波长</strong>。如果光子与原子中束缚很紧的电子（原子的内层电子）碰撞，光子将与整个原子做弹性碰撞。因为原子的质量比光子的质量大很多，<strong>散射光的能量不会显著减小</strong>，从而散射光的频率也不会发生显著变化，康普顿移动非常小，所以实验散射线中有与入射光波长相同的射线。</li></ul><h3 id="计算">计算</h3><p>我们利用能量守恒和动量守恒定律来定量解释散射光子的波长改变。一个光子与一个自由电子碰撞，电子一开始处于静止状态，如下图所示。<br><img src="image-39.png" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>频率为 <span class="math inline"><em>ν</em><sub>0</sub></span>的一束光沿着 <span class="math inline"><em>x</em></span>方向照射物体表面，具有能量 <span class="math inline"><em>h</em><em>ν</em><sub>0</sub></span> 和动量 <span class="math inline">$\frac{h \nu_{0}}{c}$</span>的光子与电子碰撞后被散射，之后光子与原入射光子方向成 <span class="math inline"><em>θ</em></span> 角，散射光子能量为 <span class="math inline"><em>h</em><em>ν</em></span>，动量为 <span class="math inline">$\frac{h \nu}{c}$</span>。</li><li>同时，反冲电子获得一个与光速差不多的速率并沿着某一角度 <span class="math inline"><em>φ</em></span> 飞出，电子能量从静止时的 <span class="math inline"><em>m</em><sub>e</sub><em>c</em><sup>2</sup></span>变成了 <span class="math inline"><em>m</em><em>c</em><sup>2</sup></span>，动量变为<span class="math inline"><em>m</em><em>v</em></span>，其中 <span class="math inline">$m=\frac{m_{\mathrm{e}}}{\sqrt{1-v^{2} /c^{2}}}$</span>，即电子动能要用相对论公式表示。</li><li>根据碰撞中遵守能量守恒和动量守恒定律，有<span class="math display"><em>h</em><em>ν</em><sub>0</sub> = <em>h</em><em>ν</em> + (<em>m</em> − <em>m</em><sub>e</sub>)<em>c</em><sup>2</sup></span></li><li><span class="math inline"><em>x</em></span> 方向的动量守恒方程写为<span class="math display">$$ \frac{h \nu_{0}}{c}=\frac{h \nu}{c} \cos\theta+m v \cos \varphi$$</span></li><li><span class="math inline"><em>y</em></span> 方向的动量守恒方程写为<span class="math display">$$ 0=\frac{h \nu}{c} \sin \theta-m v \sin\varphi$$</span></li><li>利用 <span class="math inline">$p=\frac{h\nu}{c}=\frac{h}{\lambda}$</span> 关系，求得 <span class="math display">$$ \Delta\lambda=\lambda-\lambda_{0}=\frac{h}{m_{\mathrm{e}} c}(1-\cos \theta)=2\lambda_{\mathrm{c}} \sin ^{2} \frac{\theta}{2}$$</span> 式中，<span class="math inline">$\lambda_{\mathrm{c}}=\frac{h}{m_{\mathrm{e}}c}=2.43 \times 10^{-12} \mathrm{~m}$</span>，<span class="math inline"><em>λ</em><sub>c</sub></span>称为电子的<strong>康普顿波长</strong> 。</li></ul><p>上式说明波长差 <span class="math inline"><em>Δ</em><em>λ</em></span>与散射物质以及入射光的波长无关，<strong>仅决定于散射方向</strong>，<span class="math inline"><em>Δ</em><em>λ</em></span>随着散射角度的增大而增大，计算得到的理论值与实验结果相符。这不仅有力地证实了光子理论，说明了光子的粒子性（有质量、能量、动量的光量子），整个散射过程是单个光子与个别电子的碰撞；还说明在微观过程中，微观粒子的相互作用也严格遵守了能量守恒和动量守恒定律。正如在空腔辐射和光电效应中，康普顿效应中的普朗克常量起着主要作用，揭示了光具有粒子性。可以这么说，光电效应揭示了光子能量与频率的关系，而康普顿效应则进一步揭示了光子动量与波长的关系。</p><h3 id="解题方法">解题方法</h3><ol type="1"><li>若只涉及到波长差和散射角，则使用 <span class="math display">$$\Delta \lambda=2 \lambda_{\mathrm{c}} \sin ^{2} \frac{\theta}{2}$$</span> 得出答案</li><li>若涉及到能量、动量，则列出康普顿效应方程组 <span class="math display">$$ \left\{\begin{array}{l} h \nu_{0}=h\nu+\left(m-m_{\mathrm{e}}\right) c^{2}\\ \frac{h \nu_{0}}{c}=\frac{h\nu}{c} \cos \theta+m v \cos \varphi\\ 0=\frac{h \nu}{c} \sin \theta-m v\sin \varphi \end{array}\right.$$</span>并加上题目条件（通常是两个方程），联立求解</li></ol><h2 id="卢瑟福原子模型">卢瑟福原子模型</h2><p>卢瑟福根据 <span class="math inline"><em>α</em></span>粒子散射实验结果在理论上提出原子的有核模型，即原子的正电荷以及几乎全部的质量集中在原子中心很小的区域中，形成原子核，带负电的电子围绕原子核旋转，类似于太阳系中行星绕太阳旋转一样，但原子核与电子之间服从库仑定律。此模型很好地解释了<span class="math inline"><em>α</em></span>粒子的大角度偏转，但也遇到了几个困难：</p><ul><li>缺乏合理表征原子大小的量</li><li>原子的稳定性问题</li><li>无法解释原子光谱</li></ul><h2 id="玻尔原子理论">玻尔原子理论</h2><h3 id="氢原子光谱">氢原子光谱</h3><p>在 <span class="math inline">1888</span>年瑞典物理学家、数学家里德伯将巴尔末公式表示为更一般化的形式，即里德伯公式：<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{m^{2}}-\frac{1}{n^{2}}\right)\quad(m=1,2,3,\cdots;n=m+1,m+2,m+3,\cdots)$$</span></p><p>式中</p><ul><li><span class="math inline"><em>ν̃</em> = <em>λ</em><sup>−1</sup></span>为波长的倒数，称为<strong>波数</strong></li><li><span class="math inline"><em>m</em> = 1, 2, 3, ⋯</span> 为整数</li><li><span class="math inline"><em>n</em> = <em>m</em> + 1, <em>m</em> + 2, <em>m</em> + 3, ⋯</span>亦为整数</li><li><span class="math inline"><em>R</em> = 1.096776 × 10<sup>7</sup>&nbsp;m<sup>−1</sup></span>为<strong>里德伯恒量</strong></li><li>给定 <span class="math inline"><em>m</em></span> 后，<span class="math inline"><em>n</em></span> 取不同值对应不同谱线系<ul><li>当 <span class="math inline"><em>m</em> = 2</span>，里德伯公式变为巴尔末公式，所对应的谱线系称为<strong>巴尔末系</strong>。</li><li>当 <span class="math inline"><em>m</em> = 1</span> 时里德伯公式变为<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{1^{2}}-\frac{1}{n^{2}}\right)\quad(n=2,3,4,\cdots)$$</span> 对应的谱线系在紫外区，由赖曼在 <span class="math inline">1914</span> 年发现，称为<strong>赖曼系</strong>。</li><li>当 <span class="math inline"><em>m</em> = 3</span>的光谱线位于红外线区，由帕邢在 <span class="math inline">1908</span>年发现，称为<strong>帕邢系</strong> ：<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{3^{2}}-\frac{1}{n^{2}}\right)\quad(n=4,5,6,\cdots)$$</span></li><li>当 <span class="math inline"><em>m</em> = 4</span>的光谱线位于近红外区，称为<strong>布拉开系</strong> ：<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{4^{2}}-\frac{1}{n^{2}}\right)\quad(n=5,6,7,\cdots)$$</span></li><li>当 <span class="math inline"><em>m</em> = 5</span>的光谱线位于远红外区，称为<strong>普丰德系</strong> ：<span class="math display">$$\widetilde{\nu}=R\left(\frac{1}{5^{2}}-\frac{1}{n^{2}}\right)\quad(n=6,7,8,\cdots)$$</span></li><li>当 <span class="math inline"><em>m</em> = 6</span>的光谱线位于远红外区，称为<strong>汉弗莱系</strong> 。</li></ul></li></ul><h3 id="玻尔半径">玻尔半径</h3><p><span class="math display">$$a=\frac{\varepsilon_0 h^2}{\pi m_e e^2}\approx 0.05 \mathrm{~nm}$$</span></p><h3 id="玻尔理论">玻尔理论</h3><p>玻尔在得知原子线状光谱的规律后，提出了革命性的理论。该理论包括两条基本假设：</p><ul><li>原子能够且只能稳定处于与一些分立的能量相对应的状态上，这些状态称为<strong>定态</strong>。原子处于定态中，<strong>不发射</strong> 也<strong>不吸收</strong>电磁辐射。（注意：若吸收光子跃迁，光子能量必须等于能级能量差；若用粒子轰击则不需要）</li><li>当原子从一个定态跃迁到另一个定态时，以发射或吸收特定频率 <span class="math inline"><em>ν</em></span>的光子与电磁场交换能量（分立定态的能量值称为<strong>能级</strong>，两个定态能量分别对应能级 <span class="math inline"><em>E</em><sub><em>n</em></sub></span>、<span class="math inline"><em>E</em><sub><em>m</em></sub></span>，假设 <span class="math inline"><em>E</em><sub><em>n</em></sub> &gt; <em>E</em><sub><em>m</em></sub></span>），且满足<span class="math display"><em>h</em><em>ν</em> = <em>E</em><sub><em>n</em></sub> − <em>E</em><sub><em>m</em></sub></span>这是频率条件。</li><li>结论：<span class="math display">$$\nu=\frac{E_{n}-E_{m}}{h}=\frac{m e^{4}}{8 \varepsilon_{0}^{2}h^{3}}\left(\frac{1}{m^{2}}-\frac{1}{n^{2}}\right)$$</span></li></ul><h3 id="玻尔角动量量子化条件">玻尔角动量量子化条件</h3><p>为了将原子分立能级确定下来，玻尔提出对应原理，即在大量子数极限情况下，量子体系的行为将趋于与经典系统相同。根据对应原理，玻尔提出质量为<span class="math inline"><em>m</em><sub>e</sub></span>的电子绕质子做半径为 <span class="math inline"><em>r</em></span>的圆周运动，电子角动量满足量子化条件： <span class="math display">$$L=n \frac{h}{2 \pi}=n \hbar,n=1,2,3,\cdots$$</span></p><p>式中，<span class="math inline"><em>n</em></span>为正整数，称为<strong>量子数</strong> ；<span class="math inline">ℏ = <em>h</em>/2<em>π</em></span>为<strong>约化普朗克常量</strong> 。</p><h3 id="索末菲量子化条件">索末菲量子化条件</h3><p>索末菲后来把玻尔角动量量子化条件推广为 <span class="math display">∮<em>p</em>&nbsp;d<em>q</em> = <em>n</em><em>h</em></span></p><p>式中，<span class="math inline"><em>q</em></span>是电子的广义坐标；<span class="math inline"><em>p</em></span>是广义动量；积分沿着电子轨道运行一周。</p><h3 id="玻尔半径-1">玻尔半径</h3><p>电子受到氢原子的带正电质子的库仑引力作用，由牛顿定律得 <span class="math display">$$\frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{r^{2}}=m_{\mathrm{e}}\frac{v^{2}}{r}$$</span></p><p>根据角动量量子化条件 <span class="math inline"><em>L</em> = <em>m</em><sub>e</sub><em>v</em><em>r</em> = <em>n</em>ℏ</span>，消去式<span class="math inline">(1 − 27)</span> 中的 <span class="math inline"><em>v</em></span>，得 <span class="math display">$$r_{n}=\frac{4 \pi \varepsilon_{0} \hbar^{2}}{m_{\mathrm{e}} e^{2}} n^{2}= \frac{\varepsilon_{0} h^{2}}{\pi m_{\mathrm{e}} e^{2}} n^{2}$$</span></p><p>这就是原子中第 <span class="math inline"><em>n</em></span>个稳定轨道的半径。<span class="math inline"><em>n</em></span>只能取正整数，轨道是分立的。当 <span class="math inline"><em>n</em> = 1</span>，给出 <span class="math inline"><em>r</em><sub>1</sub> = 0.529<em>Å</em></span>，这是氢原子的<strong>核外电子最小轨道半径</strong>，称为<strong>玻尔半径</strong> 。</p><h3 id="电子能量">电子能量</h3><p>当电子在半径为 <span class="math inline"><em>r</em><sub><em>n</em></sub></span>的轨道上，氢原子系统的能量等于电子质子系统的静电势能与电子的动能之和，如以电子无穷远处静电势能为零，则<span class="math display">$$E_{n}=-\frac{1}{4 \pi \varepsilon_{0}} \frac{e^{2}}{r_{n}}+\frac{1}{2}m_{\mathrm{e}} v_{n}^{2}=-\frac{1}{8 \pi \varepsilon_{0}}\frac{e^{2}}{r_{n}}$$</span></p><p>代入得到 <span class="math display">$$E_{n}=-\frac{m_{e} e^{4}}{8 \varepsilon_{0}^{2} h^{2}}\frac{1}{n^{2}}=-\frac{13.6}{n^2}\mathrm{eV}$$</span></p><p>该式表示电子在第 <span class="math inline"><em>n</em></span>个稳定轨道运动时氢原子系统的能量。</p><ul><li>氢原子能量是不连续的，这就是<strong>能量量子化</strong> 。</li><li>以 <span class="math inline"><em>n</em> = 1</span> 代入式 <span class="math inline">(1 − 29)</span> 得 <span class="math inline"><em>E</em><sub><em>n</em></sub> = −13.6eV</span>，这是氢原子的最低能级，称为<strong>基态能级</strong>。</li><li>若定义基态能级的能量为零，将氢原子基态电子移动到无限远时所需要的能量就是氢原子<strong>电离能</strong>。</li><li>对于 <span class="math inline"><em>n</em> &gt; 1</span>的各稳定态，其能量大于基态能量，随着量子数 <span class="math inline"><em>n</em></span>的增大而增大，能量间隔减小，这种状态称为<strong>激发态</strong> 。</li><li>当 <span class="math inline"><em>n</em> → ∞</span> 时，<span class="math inline"><em>r</em><sub><em>n</em></sub> → ∞</span>，<span class="math inline"><em>E</em><sub><em>n</em></sub> → 0</span>，能级趋于连续。<span class="math inline"><em>E</em> &gt; 0</span>时，原子处于<strong>电离状态</strong> ，能量可连续变化。</li><li>里德伯常量的理论值：<span class="math display">$$R_{\mathrm{H}}=\frac{m_{e} e^{4}}{8 \varepsilon_{0}^{2} h^{3}c}=1.0973731 \times 10^{7} \mathrm{~m}^{-1}$$</span>它与实验值符合得很好。</li></ul><h3 id="玻尔理论的局限性">玻尔理论的局限性</h3><p>玻尔理论存在的问题和局限性后来被逐渐揭示。首先，该理论无法解释复杂原子的光谱，例如氦原子光谱。其次，玻尔理论无法系统地计算光谱线的相对强度，即便是氢原子的光谱线强度；也不能处理非束缚态问题，例如散射问题。最后，从理论体系上看，玻尔理论与经典力学不相容，如角动量量子化、能量量子化等，但这些结果并没有揭示出不连续的本质。量子力学就是在克服这些困难和局限性的过程中逐渐发展成一个完整的理论体系。</p><h1 id="量子力学入门">量子力学入门</h1><h2 id="物质波">物质波</h2><p>德布罗意认为光有波粒二象性，物质或许也有波粒二象性。他提出物质波假说：一个能量为<span class="math inline"><em>E</em></span>、动量为 <span class="math inline"><em>p</em></span> 的粒子具有波动性，波长 <span class="math inline"><em>λ</em></span> 和频率 <span class="math inline"><em>ν</em></span> 分别与粒子的动量和能量成正比，即<span class="math display">$$\lambda=\frac{h}{p},\nu=\frac{E}{h}$$</span></p><p>这与光的波粒二象性的关系相同。</p><ul><li>上式把波的概念与粒子的概念联系起来。第一个关系称为<strong>德布罗意关系</strong>。这种与实物粒子相联系的波称为<strong>德布罗意波</strong>，或称为<strong>物质波</strong> 。</li><li>由于 <span class="math inline"><em>h</em></span>很小，通常实物粒子波长非常短，波动性无法表现。但是在原子世界中，就显现出微观粒子的波动性。</li></ul><h3 id="微观波粒二象性粒子属性转换">微观波粒二象性粒子属性转换</h3><table><thead><tr><th>物理量</th><th>波动性</th><th>粒子性</th></tr></thead><tbody><tr><td>波长 <span class="math inline"><em>λ</em></span></td><td><span class="math inline"><em>h</em>/<em>p</em></span></td><td><span class="math inline"><em>v</em>/<em>ν</em></span></td></tr><tr><td>频率 <span class="math inline"><em>ν</em></span></td><td><span class="math inline"><em>E</em>/<em>h</em></span></td><td><span class="math inline"><em>v</em>/<em>λ</em></span></td></tr><tr><td>动量 <span class="math inline"><em>p</em></span></td><td><span class="math inline"><em>h</em>/<em>λ</em></span></td><td><span class="math inline"><em>m</em><em>v</em></span> = <span class="math inline">$\sqrt{2 m E}$</span></td></tr><tr><td>能量 <span class="math inline"><em>E</em></span></td><td><span class="math inline"><em>h</em><em>ν</em></span></td><td><span class="math inline">$\frac{1}{2}mv^2 = \frac{p^2}{2m}$</span></td></tr></tbody></table><h3 id="相对论公式">相对论公式</h3><p><span class="math display">$$\begin{aligned}E &amp;= E_0 + E_k = m_0 c^2 + E_k \\E^2 &amp;= E_0^2 + p^2 c^2 = m_0^2 c^4 + p^2 c^2 \\\Rightarrow p &amp;= \frac{1}{c} \sqrt{E^2 - E_0^2} \\&amp;= \frac{1}{c} \sqrt{(E_0 + E_k)^2 - E_0^2} \\&amp;= \frac{1}{c} \sqrt{E_k^2 + 2 E_0 E_k} \\&amp;= \frac{1}{c} \sqrt{E_k^2 + 2 m_0 c^2 E_k} \\\Rightarrow \lambda &amp;= \frac{h}{p} = \frac{h c}{\sqrt{E_k^2 + 2 E_0E_k}} \\&amp;= \frac{h c}{\sqrt{E_k^2 + 2 m_0 c^2 E_k}} \\\end{aligned}$$</span></p><h3 id="革末实验">革末实验</h3><p>晶体的X射线衍射实验中，同一晶面上相邻原子散射的光波的光程差等于零，它们相干加强,反射给出强度最大的方向。一组晶面，可实现多光束相干叠加。若要在该方向上不同晶面上原子散射光相干加强,满足布拉格公式： <span class="math display"><em>δ</em> = 2<em>d</em>sin <em>θ</em> = <em>k</em><em>λ</em></span></p><p>式中，<span class="math inline"><em>δ</em></span> 为光程差，<span class="math inline"><em>d</em></span> 为晶面间距，<span class="math inline"><em>θ</em></span> 为入射角，<span class="math inline"><em>k</em></span> 为整数。</p><h2 id="不确定度关系">不确定度关系</h2><p>在经典力学中，一个粒子的位置和动量可以同时确定，而且知道了某一时刻粒子的位置和动量，原则上可以预言以后任意时刻粒子的位置和动量。然后，微观粒子的衍射实验已经表明微观粒子有明显的波性。粒子位置是不确定的，出现在某区域，例如出现在b<span class="math inline"><em>Δ</em><em>x</em><em>Δ</em><em>y</em><em>Δ</em><em>z</em></span>范围内，可以称 <span class="math inline"><em>Δ</em><em>x</em></span>、<span class="math inline"><em>Δ</em><em>y</em></span>、<span class="math inline"><em>Δ</em><em>z</em></span>为粒子<strong>位置不确定量</strong>。粒子的动量、角动量等力学量也是如此。由 <span class="math inline">$p=\frac{h}{\lambda}$</span> 算出动量的可能范围<span class="math inline"><em>Δ</em><em>p</em></span>，<span class="math inline"><em>Δ</em><em>p</em></span> 就是动量不确定量。<br>海森伯发现物理量的不确定量受到普朗克常量支配。他在 <span class="math inline">1927</span>年提出了微观粒子的位置和动量两者的不确定量满足 <span class="math display">$$\Delta x \Delta p_{x} \geqslant \frac{\hbar}{2},\quad \Delta y \Deltap_{y} \geqslant \frac{\hbar}{2},\quad \Delta z \Delta p_{z} \geqslant\frac{\hbar}{2}$$</span></p><p>上式称为位置和动量的<strong>不确定度关系</strong>。它的物理意义是客观上微观粒子不可能同时具有确定的坐标位置和相应的动量，粒子的位置不确定量<span class="math inline"><em>Δ</em><em>x</em></span> 越小，动量不确定量<span class="math inline"><em>Δ</em><em>p</em><sub><em>x</em></sub></span>就越大，反之亦然。</p><p>同样，微观粒子能量和时间的不确定量满足 <span class="math display">$$\Delta E \Delta t \geqslant \frac{\hbar}{2}$$</span></p><p>上式称为时间和能量的<strong>不确定度关系</strong>。它的物理意义是客观上微观粒子不可能同时具有确定的能量和相应的时间，粒子的能量不确定量<span class="math inline"><em>Δ</em><em>E</em></span> 越小，时间不确定量<span class="math inline"><em>Δ</em><em>t</em></span>就越大，反之亦然。</p><h3 id="不确定度关系解题步骤">不确定度关系解题步骤</h3><ol type="1"><li>确定已知定值条件、已知差值条件和要求的差值</li><li>根据“微观波粒二象性粒子属性转换”，拿到相关的物理量</li><li>应用“时间和能量不确定性关系/位置和动量不确定性关系”（最多一次），得到答案</li></ol><p><img src="image-40.png" srcset="/img/loading/loading3.gif" lazyload></p><h2 id="波函数单色平面波">波函数（单色平面波）</h2><p>既然微观粒子具有波动性，应引入描述这种波的波函数。德布罗意认为能量为<span class="math inline"><em>E</em></span>、动量大小为 <span class="math inline"><em>p</em></span> 的“自由粒子”沿 <span class="math inline"><em>x</em></span>方向运动时，对应的物质波应为“单色平面波”。即对应一列角波数和圆频率分别为<span class="math inline"><em>k</em>, <em>ω</em></span> 的单色波 <span class="math display"><em>Ψ</em>(<em>x</em>, <em>t</em>) = <em>ψ</em><sub>0</sub>e<sup>−i(<em>ω</em><em>t</em> − <em>k</em><em>x</em>)</sup></span></p><p>式中 <span class="math inline"><em>ψ</em><sub>0</sub></span>为复数（待定），可见波函数 <span class="math inline"><em>Ψ</em>(<em>x</em>, <em>t</em>)</span>为一复变函数。按德布罗意假设，可将波函数用粒子的能量和动量表示为 <span class="math display">$$\Psi(x,t)=\psi_{0} \mathrm{e}^{-\frac{i}{\hbar}(E t-p x)}$$</span></p><p>式中 <span class="math inline">ℏ = <em>h</em>/2<em>π</em></span>，称为约化普朗克常数。<br>若粒子为三维自由运动，则波函数可表示为 <span class="math display">$$\Psi(\boldsymbol{r},t)=\psi_{0} \mathrm{e}^{-\frac{i}{\hbar}(E t-p \cdotr)}$$</span></p><p>的概率密度。</p><ul><li>微观粒子物质波的波函数只能用复数形式来表达，不能用实数形式来表达</li><li>在一般情况下，粒子的波函数不是单色平面波的形式，而是空间和时间的复杂函数。</li><li>波函数既不描述粒子的形状，也不描述粒子运动的轨迹，它只给出粒子运动的概率分布。</li></ul><h3 id="波函数的统计意义">波函数的统计意义</h3><p>波函数模的平方代表在时刻 <span class="math inline"><em>t</em></span>、空间 <span class="math inline"><em>r</em></span> 处单位体积中微观粒子出现的概率，即<span class="math display"><em>ρ</em>(<strong>r</strong>, <em>t</em>) = |<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup> = <em>Ψ</em>(<strong>r</strong>, <em>t</em>)<sup>*</sup><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span></p><p>为粒子的<strong>概率密度</strong> ，其中 <span class="math inline"><em>Ψ</em><sup>*</sup>(<strong>r</strong>, <em>t</em>)</span>是 <span class="math inline"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>的复共轭。波函数是不可观测量，而概率密度可观测量。由于波函数的模方具有概率的意义，故也将德布罗意波称为概率波。在体积元<span class="math inline">d<em>V</em></span> 中发现粒子的概率为 <span class="math display"><em>ρ</em>(<strong>r</strong>, <em>t</em>)d<em>V</em> = <em>Ψ</em>(<strong>r</strong>, <em>t</em>)<sup>*</sup><em>Ψ</em>(<strong>r</strong>, <em>t</em>)d<em>V</em> = |<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup>&nbsp;d<em>V</em></span></p><h3 id="性质">性质</h3><ul><li>连续性</li><li>有限性</li><li>单值性</li></ul><h3 id="归一化条件">归一化条件</h3><p>由于在全空间一定能找到粒子，故概率密度在全空间积分为 <span class="math inline">1</span>，即 <span class="math display">∫<sub><em>Ω</em></sub><em>Ψ</em><sup>*</sup>(<strong>r</strong>, <em>t</em>)<em>Ψ</em>(<strong>r</strong>, <em>t</em>)d<em>V</em> = 1</span></p><p>式中 <span class="math inline"><em>Ω</em></span>表示全空间区域，称该式为波函数的归一化条件。</p><h3 id="波粒二象性">波粒二象性</h3><p>量子力学中微观粒子的“粒子性”和“波动性”含义与经典粒子和经典波的不同</p><ul><li>“粒子性”主要指微观粒子的整体性和不可分性，粒子没有确定的轨道；</li><li>“波动性”主要指描述微观粒子状态的波函数是可以叠加的，像经典波一样可以出现“干涉”“衍射”等现象。但与经典的波不同，波函数并不对应真实物理量的波动。</li><li>“波粒二象性”是指微观粒子可显示出“波动”和“粒子”两种不同属性。在一些情况下，微观粒子突出显示出其粒子特性，而在另一些情况下，则突出显示出波动特性。</li></ul><h3 id="动量概率分布">动量概率分布</h3><p><span class="math display">$$\begin{aligned}\Phi(\vec p,t) = \int_\infty\Psi(\vecr,t)\sqrt{\frac{1}{(2\pi\hbar)^3}}e^{-i\ \vec p\cdot \vec r/\hbar}\mathrm{d}x\mathrm{d}y\mathrm{d}z \\\Psi(\vec r,t) = \int_\infty\Phi(\vecp,t)\sqrt{\frac{1}{(2\pi\hbar)^3}}e^{i\ \vec p\cdot \vec r/\hbar}\mathrm{d}p_x\mathrm{d}p_y\mathrm{d}p_z\end{aligned}$$</span></p><p>我们发现，由于 <span class="math inline">$\Psi(\vec{r_{}},t)$</span>和 <span class="math inline">$\Phi(\vec{p_{}},t)$</span>可以唯一地互相求出，也就意味着它们包含了同样多的信息。既然 <span class="math inline">$\Psi(\vec{r_{}},t)$</span> 描述了体系的状态，那么<span class="math inline">$\Phi(\vec{p_{}},t)$</span>也描写了体系的状态。<span class="math inline">$\Phi(\vec{p_{}},t)$</span>的物理意义是动量概率振幅，即 <span class="math inline">$|\Phi(\vec{p_{}},t)|^{2}$</span>代表动量概率密度。</p><h1 id="量子力学深入">量子力学深入</h1><h2 id="物理量与算符">物理量与算符</h2><ul><li>由于微观客体的运动具有统计规律性（表现为概率波），测量一个与微观运动相关的物理量时，一般就不像在经典的宏观物理中那样具有确定值。例如，一个电子的位置在经典物理中是完全可以确定的，无论是理论计算还是实验方法，均可以测定它。但是电子具有波粒二象性，位置一般不确定，按照统计规律分布于空间，因而只能表达为电子的平均位置。</li><li>设电子处于 <span class="math inline"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>，<span class="math inline"><strong>r</strong></span> ： <span class="math inline">(<em>x</em>, <em>y</em>, <em>z</em>)</span>表示其位置，则在 <span class="math inline"><em>t</em></span>时刻，电子的位置在 <span class="math inline"><em>x</em> → <em>x</em> + d<em>x</em>, <em>y</em> → <em>y</em> + d<em>y</em>, <em>z</em> → <em>z</em> + d<em>z</em></span>之间的概率正比于 <span class="math inline">|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup>&nbsp;d<em>x</em>&nbsp;d<em>y</em>&nbsp;d<em>z</em></span>，因此电子的平均位置用<span class="math inline">⟨<strong>r</strong>⟩</span> 表示为 <span class="math display">$$ \langle\boldsymbol{r}\rangle=\frac{\iiint\boldsymbol{r}|\Psi(\boldsymbol{r},t)|^{2} \mathrm{~d} x \mathrm{~d} y\mathrm{~d} z}{\iiint|\Psi(\boldsymbol{r},t)|^{2} \mathrm{~d} x\mathrm{~d} y \mathrm{~d} z}$$</span> 如果 <span class="math inline"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>是归一化的，则 <span class="math inline">∭|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup>&nbsp;d<em>x</em>&nbsp;d<em>y</em>&nbsp;d<em>z</em> = 1</span>，于是<span class="math display">⟨<strong>r</strong>⟩ = ∭<strong>r</strong>|<em>Ψ</em>(<strong>r</strong>, <em>t</em>)|<sup>2</sup>&nbsp;d<em>x</em>&nbsp;d<em>y</em>&nbsp;d<em>z</em></span></li><li>人们发现，各个力学量在量子力学中都表现为作用于波函数的某种算符，如动量算符、角动量算符、能量算符、自旋算符等。因此，作为量子力学基本假设之一而提出：<strong>每一个力学量（不限于经典的力学量，如自旋）都与一个算符相对应。算符对波函数的作用就是把一个波函数（态）变换为另一个波函数（态）。</strong></li><li>设有某种运算 <span class="math inline"><em>F̂</em></span>，把某一函数<span class="math inline"><em>Ψ</em></span> 变成另一函数 <span class="math inline"><em>ϕ</em></span> ：<span class="math display"><em>F̂</em><em>Ψ</em> = <em>ϕ</em></span>式中，<span class="math inline"><em>F̂</em></span>称为<strong>算符</strong>。</li></ul><h3 id="线性算符">线性算符</h3><p>设任意两个函数 <span class="math inline"><em>ϕ</em><sub>1</sub>, <em>ϕ</em><sub>2</sub></span>，<span class="math inline"><em>F̂</em></span> 满足 <span class="math display"><em>F̂</em>(<em>c</em><sub>1</sub><em>ϕ</em><sub>1</sub> + <em>c</em><sub>2</sub><em>ϕ</em><sub>2</sub>) = <em>c</em><sub>1</sub><em>F̂</em><em>ϕ</em><sub>1</sub> + <em>c</em><sub>2</sub><em>F̂</em><em>ϕ</em><sub>2</sub></span></p><p>式中，<span class="math inline"><em>c</em><sub>1</sub>, <em>c</em><sub>2</sub></span>为任意常数；<span class="math inline"><em>F̂</em></span>称为线性算符。显然，<span class="math inline">$\frac{\partial}{\partialx}$</span> 和 <span class="math inline"><em>x</em></span> 为线性算符，而<span class="math inline">$\sqrt{ }$</span>就不是。量子力学中只讨论线性算符。</p><h3 id="算符相等">算符相等</h3><p>对任意 <span class="math inline"><em>ϕ</em><sub>1</sub></span>，若<span class="math display"><em>F̂</em><em>ϕ</em><sub>1</sub> = <em>Ĝ</em><em>ϕ</em><sub>1</sub></span></p><p>则称两个算符相等，即 <span class="math inline"><em>F̂</em> = <em>Ĝ</em></span>。</p><h3 id="算符加法">算符加法</h3><p>对任意 <span class="math inline"><em>ϕ</em></span>，若 <span class="math display">(<em>F̂</em> + <em>Ĝ</em>)<em>ϕ</em> = <em>F̂</em><em>ϕ</em> + <em>Ĝ</em><em>ϕ</em> = (<em>Ĝ</em> + <em>F̂</em>)<em>ϕ</em></span></p><p>则称 <span class="math inline"><em>F̂</em> + <em>Ĝ</em></span> 为算符<span class="math inline"><em>F̂</em></span> 和 <span class="math inline"><em>Ĝ</em></span> 之和，且满足 <span class="math inline"><em>F̂</em> + <em>Ĝ</em> = <em>Ĝ</em> + <em>F̂</em></span>。</p><h3 id="算符的乘法">算符的乘法</h3><p>两个算符相乘，<span class="math inline">(<em>F̂</em><em>Ĝ</em>)<em>ϕ</em> = <em>F̂</em>(<em>Ĝ</em><em>ϕ</em>)</span>，满足分配律和结合律：<span class="math display">$$\begin{aligned}&amp;(\hat{F}+\hat{G}) \hat{R}=\hat{F} \hat{R}+\hat{G} \hat{R}\\&amp;\hat{F} \hat{G} \hat{R}=(\hat{F} \hat{G}) \hat{R}=\hat{F}(\hat{G}\hat{R})\end{aligned}$$</span></p><h3 id="乘法交换律与对易性">乘法交换律与对易性</h3><p>算符乘法交换律一般不成立，即 <span class="math display">$$\begin{aligned}&amp;\hat{F} \hat{G} \neq \hat{G} \hat{F} \\&amp;\hat{F} \hat{G}-\hat{G} \hat{F} \equiv[\hat{F},\hat{G}] \neq 0\end{aligned}$$</span></p><ul><li>式中，<span class="math inline">[  ]</span>称为<strong>对易括号</strong> ，例如 <span class="math inline"><em>F̂</em> = <em>x</em></span>，<span class="math inline">$\hat{G}=\hat{p}_{x}=-\mathrm{i} \hbar\frac{\partial}{\partial x}$</span>，有 <span class="math inline">[<em>x</em>, <em>p̂</em><sub><em>x</em></sub>] = iℏ</span>。</li><li>经典物理中的位置和动量等力学量都是数值变量，<span class="math inline"><em>x</em><em>p</em><sub><em>x</em></sub></span> 与<span class="math inline"><em>p</em><sub><em>x</em></sub><em>x</em></span>并无不同，而在量子力学中，力学量之间的运算是算符的运算，<span class="math inline"><em>x</em><em>p̂</em><sub><em>x</em></sub></span> 和<span class="math inline"><em>p̂</em><sub><em>x</em></sub><em>x</em></span>作用于波函数会得到不一样的结果，即 <span class="math inline"><em>x</em><em>p̂</em><sub><em>x</em></sub> ≠ <em>p̂</em><sub><em>x</em></sub><em>x</em></span>，也就是说，<span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>p̂</em><sub><em>x</em></sub></span> 不对易。</li><li>若 <span class="math inline"><em>F̂</em><em>Ĝ</em> − <em>Ĝ</em><em>F̂</em> ≡ [<em>F̂</em>, <em>Ĝ</em>] = 0</span>，则说明<span class="math inline"><em>F̂</em></span>、<span class="math inline"><em>Ĝ</em></span> 是<strong>彼此对易</strong>的。例如 <span class="math inline"><em>x</em><em>y</em> − <em>y</em><em>x</em> ≡ [<em>x</em>, <em>y</em>] = 0</span>。</li><li>不难验证 <span class="math display">$$\begin{array}{c}{[\hat{F},\hat{G}]=-[\hat{G},\hat{F}]} \\{[\hat{F},\hat{G}+\hat{R}]=[\hat{F},\hat{G}]+[\hat{F},\hat{R}]} \\{[\hat{F},\hat{G} \hat{R}]=[\hat{F},\hat{G}]\hat{R}+\hat{G}[\hat{F},\hat{R}]} \\{[\hat{G} \hat{R},\hat{F}]=[\hat{G},\hat{F}]\hat{R}+\hat{G}[\hat{R},\hat{F}]} \\{[\hat{F},[\hat{G},\hat{R}]]+[\hat{G},[\hat{R},\hat{F}]]+[\hat{R},[\hat{F},\hat{G}]]=0}\end{array}$$</span></li></ul><h3 id="厄密算符">厄密算符</h3><p>若线性算符 <span class="math inline"><em>F̂</em></span> 满足 <span class="math display">∭<em>ψ</em><sup>*</sup><em>F̂</em><em>φ</em>d<em>τ</em> = ∭(<em>F̂</em><em>ψ</em>)<sup>*</sup><em>φ</em>d<em>τ</em></span></p><p>则 <span class="math inline"><em>F̂</em></span>称为<strong>自厄（厄密）算符</strong> ，其中 <span class="math inline"><em>ψ</em></span>、<span class="math inline"><em>φ</em></span>是任意两个波函数（模平方可积函数）。例如 <span class="math inline"><em>x</em></span>、<span class="math inline"><em>p̂</em><sub><em>x</em></sub></span>为厄密算符。</p><p>厄密算符的本征值为实数，若 <span class="math inline"><em>F̂</em><em>ψ</em> = <em>λ</em><em>ψ</em></span>，则<span class="math inline"><em>λ</em></span> 是实数。 <span class="math display">$$\begin{aligned}&amp;\iint \psi^{*} \hat{F} \psi \mathrm{d} \tau =\iint(\hat{F}\psi)^{*} \psi \mathrm{d} \tau =\lambda^{*} \iint \psi^{*} \psi\mathrm{d} \tau \\&amp;\iint \psi^{*} \hat{F} \psi \mathrm{d} \tau =\lambda \iint \psi^{*}\psi \mathrm{d} \tau \\&amp;\therefore \lambda=\lambda^{*}\end{aligned}$$</span></p><h3 id="线性厄密算符">线性厄密算符</h3><p>与 <strong>力学量</strong> 对应的算符是<strong>线性厄密算符</strong>，在任何状态下，厄密算符所代表的力学量平均值都是实数，即 <span class="math display">⟨<em>Â</em>⟩ = ∬<em>ψ</em><sup>*</sup><em>Â</em><em>ψ</em>d<em>τ</em> = 实数</span></p><p>取上式的复数共轭 <span class="math display">$$\begin{aligned}\langle\hat{A}\rangle^{*} &amp;= \iint (\psi^{*} \hat{A} \psi)^{*}\mathrm{d} \tau = \iint \psi (\hat{A} \psi)^{*} \mathrm{d} \tau \\&amp;=\iint (\hat{A} \psi)^{*} \psi \mathrm{d} \tau = \iint \psi^{*}\hat{A} \psi \mathrm{d} \tau = \langle\hat{A}\rangle\end{aligned}$$</span></p><p>这也是力学量的<strong>平均值</strong> 。</p><h2 id="算符与本征方程">算符与本征方程</h2><h3 id="定义">定义</h3><ul><li>量子力学中，算符作用在一个函数（态）上，得到另一个函数（态）。</li><li>任何一个力学量均对应一个算符，算符的<strong>本征值</strong>就是力学量的可能取值，这就是<strong>力学量算符表示假设</strong> 。</li></ul><h3 id="狄拉克符号">狄拉克符号</h3><p>下面用<strong>狄拉克符号</strong> 来表示波函数。</p><p>这里引入 <span class="math inline">|<em>x</em>⟩</span>表示波函数，<span class="math inline">|<em>x</em>⟩</span>称为<strong>右矢</strong> ，而 <span class="math inline">⟨<em>x</em>|</span> 称为<strong>左矢</strong> ，符号<span class="math inline">⟨<em>x</em> ∣ <em>y</em>⟩</span> 表示 <span class="math inline">⟨<em>x</em>|</span> 与 <span class="math inline">|<em>y</em>⟩</span> 的<strong>内积</strong>。内积满足 <span class="math inline">⟨<em>x</em> ∣ <em>y</em>⟩ = ⟨<em>y</em> ∣ <em>x</em>⟩<sup>*</sup></span>，<span class="math inline">⟨<em>x</em> ∣ <em>x</em>⟩ = ⟨<em>x</em> ∣ <em>x</em>⟩<sup>*</sup>=</span>实数。<br>波函数 <span class="math inline">|<em>x</em>⟩</span>表示某本征态，波函数 <span class="math inline">|<em>y</em>⟩</span>表示另一本征态，则波函数 <span class="math inline">|<em>ψ</em>⟩</span>应由 <span class="math inline">|<em>x</em>⟩</span> 和 <span class="math inline">|<em>y</em>⟩</span> 组合来表示 <span class="math display">|<em>ψ</em>⟩ = <em>C</em><sub>1</sub>|<em>x</em>⟩ + <em>C</em><sub>2</sub>|<em>y</em>⟩</span></p><h3 id="态基">态基</h3><p>正如普通矢量空间中通常选取正交坐标轴和单位基矢，在量子态矢空间通常选取的态基<span class="math inline">|<em>e</em><sub><em>i</em></sub>⟩(<em>i</em> = 1, 2, 3, ⋯)</span>满足正交归一条件 <span class="math display">$$\left\langle e_{i} \mid e_{j}\right\rangle=\delta_{i j}\equiv\left\{\begin{array}{ll} 1,&amp; i=j \\ 0,&amp; i \neq j\end{array}\right.$$</span></p><p>式中，<span class="math inline"><em>δ</em><sub><em>i</em><em>j</em></sub></span>称为<strong>克罗内克符号</strong> 。任何态矢 <span class="math inline"><em>ψ</em></span>的线性叠加可以表示为基矢的线性叠加，即 <span class="math inline"><em>ψ</em> = ∑<sub><em>i</em></sub><em>C</em><sub><em>i</em></sub>|<em>e</em><sub><em>i</em></sub>⟩</span>。</p><h3 id="正交">正交</h3><p>当两个函数 <span class="math inline"><em>ψ</em><sub>1</sub></span> 和<span class="math inline"><em>ψ</em><sub>2</sub></span> 满足下列关系：<span class="math display">∫<em>ψ</em><sub>1</sub><sup>*</sup><em>ψ</em><sub>2</sub>&nbsp;d<em>τ</em> = ⟨<em>ψ</em><sub>1</sub> ∣ <em>ψ</em><sub>2</sub>⟩ = 0</span></p><p>式中变量在全部区域积分为零，则称两函数<strong>相互正交</strong>。<span class="math inline">⟨<em>ψ</em><sub>1</sub> ∣ <em>ψ</em><sub>2</sub>⟩</span>称为两个函数的<strong>内积</strong> 。</p><h3 id="本征值本征态">本征值、本征态</h3><p>实验测量的结果只有有限种，把可能的测量值称为波函数的<strong>本征值</strong>，而把相应的波函数 <span class="math inline">|<em>x</em>⟩</span> 和<span class="math inline">|<em>y</em>⟩</span>表示的态称为<strong>本征态</strong>，两个波函数则称为对应力学量的<strong>本征函数</strong> 。<br>对于任意本征态 <span class="math inline">|<em>χ</em>⟩</span>，有 <span class="math display">|<em>χ</em>⟩ = |<em>x</em>⟩⟨<em>x</em> ∣ <em>χ</em>⟩ + |<em>y</em>⟩⟨<em>y</em> ∣ <em>χ</em>⟩ = ∑<sub><em>i</em></sub>|<em>e</em><sub><em>i</em></sub>⟩⟨<em>e</em><sub><em>i</em></sub> ∣ <em>χ</em>⟩</span></p><p>式中，<span class="math inline">⟨<em>e</em><sub><em>i</em></sub> ∣ <em>χ</em>⟩</span>是处于 <span class="math inline">|<em>χ</em>⟩</span> 的光子处在 <span class="math inline">|<em>e</em><sub><em>i</em></sub>⟩</span>基的概率幅，则 <span class="math inline">|⟨<em>e</em><sub><em>i</em></sub> ∣ <em>χ</em>⟩|<sup>2</sup></span>为该光子处在 <span class="math inline">|<em>e</em><sub><em>i</em></sub>⟩</span>基的概率，且有 <span class="math inline">∑<sub><em>i</em></sub>|<em>e</em><sub><em>i</em></sub>⟩⟨<em>e</em><sub><em>i</em></sub>| = 1</span>，称为<strong>恒等变化算符</strong>。</p><h3 id="本征方程">本征方程</h3><ul><li>人们从实验事实总结出量子力学的另一基本假设：<strong>在任何状态下测一个力学量，单次测量的结果必是这个力学量的某一本征值，而经过测量后，原先的状态转变为与这个特殊本征值相应的本征态。</strong>如果在这个本征态下测量同一力学量，测得的当然是同一本征值。力学量的本征态具有一个重要的基本特性，即在本征态下测量这个力学量，测量值是确定的。一般的态总可以表示为本征态的叠加，这也是本征态的一个重要和基本的特性。</li><li>若算符 <span class="math inline"><em>F̂</em></span> 作用于某个函数<span class="math inline"><em>u</em></span> 有 <span class="math display"><em>F̂</em><em>u</em> = <em>λ</em><em>u</em></span>所得结果是一常数 <span class="math inline"><em>λ</em></span> 与 <span class="math inline"><em>u</em></span> 的乘积，则 <span class="math inline"><em>λ</em></span> 称为算符的<strong>本征值</strong>，<span class="math inline"><em>u</em></span>称为算符的<strong>本征函数</strong> 。</li><li>一般而言，对应于不同的本征值，算符有不同的本征函数。为了强调本征值与本征函数的关系，我们说<span class="math inline"><em>u</em></span> 是算符 <span class="math inline"><em>F</em></span> 属于本征值 <span class="math inline"><em>λ</em></span>的本征函数。本征值方程的解不仅取决于算符的本身性质，还取决于函数所满足的边界条件。</li><li>算符 <span class="math inline"><em>F̂</em></span>的本征方程的本征值数目可以是有限的，也可以是无限的。本征值的分布可以是分立的，也可以是连续的。这些都由算符的性质和本征函数满足的边界条件决定。算符本征值的集合称为<strong>本征值谱</strong> 。如果本征值是一些分立值，则称这些本征值组成<strong>分立谱</strong> ；如果本征值是连续分布的，则称这些本征值组成<strong>连续谱</strong> 。</li><li>对于一个本征值，若只有一个本征函数，则称为 <strong>无简并</strong>。若同一本征值，对应 <span class="math inline"><em>f</em></span> 个<strong>线性无关</strong> 本征函数，则该本征值 <strong>有简并</strong>，<strong>简并度</strong> 为 <span class="math inline"><em>f</em></span>。对应同一本征值的 <span class="math inline"><em>f</em></span> 个本征函数的任意线性组合，有 <span class="math display"><em>F̂</em>(<em>C</em><sub>1</sub><em>u</em><sub>1</sub> + <em>C</em><sub>2</sub><em>u</em><sub>2</sub> + ⋯ + <em>C</em><sub><em>f</em></sub><em>u</em><sub><em>f</em></sub>) = <em>λ</em>(<em>C</em><sub>1</sub><em>u</em><sub>1</sub> + <em>C</em><sub>2</sub><em>u</em><sub>2</sub> + ⋯ + <em>C</em><sub><em>f</em></sub><em>u</em><sub><em>f</em></sub>)</span>其中 <span class="math inline"><em>C</em><sub><em>i</em></sub>(<em>i</em> = 1, 2, ⋯, <em>f</em>)</span>是系数。所以仍为 <span class="math inline"><em>F̂</em></span>的本征函数，本征值不变。</li><li>如果 <span class="math inline"><em>F̂</em></span>是<strong>厄密算符</strong> ，它的本征值是<strong>实数</strong> 。设<span class="math inline"><em>λ</em></span> 和 <span class="math inline"><em>ψ</em></span> 表示 <span class="math inline"><em>F̂</em></span>的一个特征值和相应的本征函数，满足本征方程，以 <span class="math inline"><em>ψ</em><sup>*</sup></span>左乘本征方程，并对全空间积分，得到 <span class="math display">∫<em>ψ</em><sup>*</sup><em>F̂</em><em>ψ</em>d<em>τ</em> = <em>λ</em>∫<em>ψ</em><sup>*</sup><em>ψ</em>d<em>τ</em></span>而 <span class="math display">∫(<em>F̂</em><em>ψ</em>)<sup>*</sup><em>ψ</em>d<em>τ</em> = <em>λ</em><sup>*</sup>∫<em>ψ</em><sup>*</sup><em>ψ</em>d<em>τ</em></span>由此得到 <span class="math display"><em>λ</em> = <em>λ</em><sup>*</sup></span> 所以<span class="math inline"><em>λ</em></span> 是实数。</li></ul><h3 id="常用算符">常用算符</h3><ul><li>坐标算符 <span class="math display">$$\hat{\boldsymbol{r}}=\boldsymbol{r}$$</span></li><li>动量算符 <span class="math display">$$\hat{\boldsymbol{p}}=-\mathrm{i} \hbar \boldsymbol{\nabla}$$</span></li><li>动能算符 <span class="math display">$$\hat{E}_{\mathrm{k}}=\frac{\hat{\boldsymbol{p}} \cdot\hat{\boldsymbol{p}}}{2 m}=\frac{-\hbar^{2} \boldsymbol{\nabla}^{2}}{2m}$$</span></li><li>哈密顿算符（能量算符）<span class="math display">$$\hat{H}=\frac{\hat{\boldsymbol{p}}^{2}}{2 m}+U(\boldsymbol{r}) =\frac{-\hbar^{2} \boldsymbol{\nabla}^{2}}{2 m} +U(\boldsymbol{r})$$</span></li><li>角动量算符 <span class="math display">$$ \begin{array}{l}\hat{L}_{x}=y \hat{p}_{z}-z \hat{p}_{y} \\ \hat{L}_{y}=z \hat{p}_{x}-x\hat{p}_{z} \\ \hat{L}_{z}=x \hat{p}_{y}-y \hat{p}_{x} \\\end{array}$$</span></li><li>角动量矢量算符 <span class="math display">$$\hat{\boldsymbol{L}}=\hat{\boldsymbol{r}} \times\hat{\boldsymbol{p}}=\left|\begin{array}{ccc} \boldsymbol{i} &amp;\boldsymbol{j} &amp; \boldsymbol{k} \\ x &amp; y &amp; x \\ \hat{p}_{x}&amp; \hat{p}_{y} &amp; \hat{p}_{z} \end{array}\right|$$</span></li><li>角动量的平方算符 <span class="math display">$$\hat{L}^{2}=\hat{\boldsymbol{L}} \cdot\hat{\boldsymbol{L}}=\hat{L}_{x}^{2}+\hat{L}_{y}^{2}+\hat{L}_{z}^{2}$$</span></li><li>角动量在不同坐标下<ul><li>直角坐标系 <span class="math display">$$  \begin{array}{c}  \hat{L}_{x}=-\mathrm{i} \hbar\left(y \frac{\partial}{\partial z}-z\frac{\partial}{\partial y}\right) \\  \hat{L}_{y}=-\mathrm{i} \hbar\left(z \frac{\partial}{\partial x}-x\frac{\partial}{\partial z}\right) \\ \hat{L}_{z}=-\mathrm{i}\hbar\left(x \frac{\partial}{\partial y}-y \frac{\partial}{\partialx}\right) \\  \hat{L}^{2}=-\hbar^{2}\left[\left(y \frac{\partial}{\partial z}-z\frac{\partial}{\partial y}\right)^{2}+\left(z \frac{\partial}{\partialx}-x \frac{\partial}{\partial z}\right)^{2}+\left(x\frac{\partial}{\partial y}-y \frac{\partial}{\partialx}\right)^{2}\right] \\  \end{array}  $$</span></li><li>球坐标系 <span class="math display">$$  \begin{array}{c}  \hat{L}^{2}=-\hbar^{2}\left[\frac{1}{\sin \theta}\frac{\partial}{\partial \theta}\left(\sin \theta\frac{\partial}{\partial \theta}\right)+\frac{1}{\sin ^{2} \theta}\frac{\partial^{2}}{\partial \phi^{2}}\right] \\  \hat{L}_{x}=\mathrm{i} \hbar\left(\sin \phi \frac{\partial}{\partial\theta}+\cot \theta \cos \phi \frac{\partial}{\partial \phi}\right) \\  \hat{L}_{y}=\mathrm{i} \hbar\left(-\cos \phi \frac{\partial}{\partial\theta}+\cot \theta \sin \phi \frac{\partial}{\partial \phi}\right) \\  \hat{L}_{z}=-\mathrm{i} \hbar \frac{\partial}{\partial \phi} \\  \end{array}  $$</span></li></ul></li></ul><h2 id="力学量算符的性质">力学量算符的性质</h2><ul><li><p>厄密算符本征函数的正交性。两个不同本征值的本征函数总是正交的，有简并时，属于同一本征值的本征函数可以不正交，但可以通过线性组合的方法使之正交化。</p></li><li><p>厄密算符本征函数的完备性。厄密算符 <span class="math inline"><em>F̂</em></span> 所对应的一组本征函数 <span class="math inline"><em>u</em><sub>1</sub>, <em>u</em><sub>2</sub>, ⋯, <em>u</em><sub><em>n</em></sub></span>是完备的。即对任意模平方可积函数 <span class="math inline"><em>ψ</em></span>，可表示为 <span class="math display"><em>ψ</em> = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub><em>u</em><sub><em>l</em></sub> = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub>|<em>u</em><sub><em>l</em></sub>⟩</span></p><p>式中，<span class="math inline"><em>C</em><sub><em>l</em></sub></span>为展开系数。这里假定本征值是分立的，即量子化的，因而叠加表现为求和。如果全体本征函数都是非简并的，上式展开系数可以利用本征函数的正交性求出<span class="math inline">(</span> 假定所有本征函数都是归一化的 <span class="math inline">)</span>，做内积 <span class="math display">⟨<em>u</em><sub><em>n</em></sub> ∣ <em>ψ</em>⟩ = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub>⟨<em>u</em><sub><em>n</em></sub> ∣ <em>u</em><sub><em>l</em></sub>⟩ = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub><em>δ</em><sub><em>n</em><em>l</em></sub> = <em>C</em><sub><em>n</em></sub></span>因此 <span class="math display"><em>ψ</em> = ∑<sub><em>l</em></sub>⟨<em>u</em><sub><em>l</em></sub> ∣ <em>ψ</em>⟩<em>u</em><sub><em>l</em></sub> = ∑<sub><em>l</em></sub>⟨<em>u</em><sub><em>l</em></sub> ∣ <em>ψ</em>⟩|<em>u</em><sub><em>l</em></sub>⟩ = ∑<sub><em>l</em></sub>|<em>u</em><sub><em>l</em></sub>⟩⟨<em>u</em><sub><em>l</em></sub> ∣ <em>ψ</em>⟩</span>这种展开与傅里叶展开类似，因此称为广义傅里叶展开。如果本征值是连续的，则展开系数是积分形式。关于这种展开系数的物理意义，在讨论平面波叠加时已经提到。现在的展开虽然是普遍的，物理意义仍与之前相似。设 <span class="math inline"><em>u</em><sub><em>l</em></sub></span>是力学量 <span class="math inline"><em>F̂</em></span>的本征态，相应本征值为 <span class="math inline"><em>λ</em><sub><em>l</em></sub></span>，则式 <span class="math inline">(1 − 131)</span> 中展开系数 <span class="math inline"><em>C</em><sub><em>l</em></sub> = ⟨<em>u</em><sub><em>ι</em></sub> ∣ <em>ψ</em>⟩</span>的模方 <span class="math display">|<em>C</em><sub><em>l</em></sub>|<sup>2</sup> = |⟨<em>u</em><sub><em>l</em></sub> ∣ <em>ψ</em>⟩|<sup>2</sup></span>正比于在 <span class="math inline"><em>ψ</em></span> 下测得力学量 <span class="math inline"><em>F̂</em></span> 的值为 <span class="math inline"><em>λ</em><sub><em>l</em></sub></span>的概率。这一结论从下面可以得到：假定 <span class="math inline"><em>ψ</em></span> 是归一化的，则在 <span class="math inline"><em>ψ</em></span> 态中，力学量的平均值 <span class="math display">$$  \begin{aligned}  \langle\hat{F}\rangle &amp; =\langle\psi|\hat{F}|\psi\rangle=\sum_{l,m} C_{m}^{*} C_{l}\left\langle u_{m}|\hat{F}|u_{l}\right\rangle \\  &amp; =\sum_{l,m} C_{m}^{*} C_{l} \lambda_{l}\delta_{m,l}=\sum_{l}\left|C_{l}\right|{ }^{2} \lambda_{l}  \end{aligned}  $$</span> 如果波函数随着时间变化，则展开系数 <span class="math inline"><em>C</em><sub><em>l</em></sub></span>也是时间的函数，即 <span class="math display"><em>ψ</em>(<em>t</em>) = ∑<sub><em>l</em></sub><em>C</em><sub><em>l</em></sub>(<em>t</em>)<em>u</em><sub><em>l</em></sub></span>这种情况下，测得概率 <span class="math inline">|<em>C</em><sub><em>l</em></sub>(<em>t</em>)|<sup>2</sup></span>将随着时间变化。我们将在双态系统中具体讨论。若 <span class="math inline"><em>ψ</em></span> 已经归一化，则 <span class="math display">$$  \begin{aligned}  1 &amp; =\int \psi^{*} \psi \mathrm{d} \tau \\  &amp; =\sum_{m,l} C_{m}^{*} C_{l}\left\langle u_{m} \midu_{l}\right\rangle \\  &amp; =\sum_{m,l} C_{m}^{*} C_{l}\delta_{m,l}=\sum_{l}\left|C_{l}\right|^{2}  \end{aligned}  $$</span> 所得结果是归一化条件，就是总的概率等于 <span class="math inline">1</span>。</p></li><li><p>由此可见，测量力学量 <span class="math inline"><em>F̂</em></span>测得的可能值必定是 <span class="math inline"><em>F̂</em></span>的本征值中的一个。系统状态发生改变，从 <span class="math inline"><em>ψ</em></span> 变成了某一个本征态 <span class="math inline"><em>u</em><sub><em>l</em></sub></span>，称为波包坍缩。对处于同一状态<span class="math inline"><em>ψ</em></span> 的大量体系 <span class="math inline">(</span> 纯系统 <span class="math inline">)</span>进行测量，每次可能给出不同测量值，但测量的平均值 <span class="math inline">(</span> 期待值 <span class="math inline">)</span>为 <span class="math inline">∑<sub><em>l</em></sub>|<em>C</em><sub><em>l</em></sub>|<sup>2</sup><em>λ</em><sub><em>l</em></sub></span>。测量有确定值的条件：当体系处于<span class="math inline"><em>F̂</em></span> 某一本征态时，即初态 <span class="math inline"><em>ψ</em> = <em>u</em><sub><em>l</em></sub></span>，测量后依然处在<span class="math inline"><em>u</em><sub><em>l</em></sub></span>，测量值为<span class="math inline"><em>λ</em><sub><em>l</em></sub></span>，测量前后状态不变。</p></li></ul><h2 id="常用算符的对易性质">常用算符的对易性质</h2><h3 id="动量与位置算符">动量与位置算符</h3><p><span class="math display">$$\begin{array}{c}\left[x,\hat{p}_{x}\right] = \left[y,\hat{p}_{y}\right] =\left[z,\hat{p}_{z}\right] = \mathrm{i} \hbar \\\left[x,\hat{p}_{y}\right] = \left[x,\hat{p}_{z}\right]=0,\cdots\end{array}$$</span></p><p>对任意函数 <span class="math inline"><em>F</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>，有<span class="math display">$$\begin{aligned}\left[\hat{p}_{x},F\right]=-\mathrm{i} \hbar \frac{\partial F}{\partialx} \\\left[\hat{p}_{y},F\right]=-\mathrm{i} \hbar \frac{\partial F}{\partialy} \\\left[\hat{p}_{z},F\right]=-\mathrm{i} \hbar \frac{\partial F}{\partialz}\end{aligned}$$</span></p><p>即 <span class="math display">$$[\hat{\boldsymbol{p}},F]=-\mathrm{i} \hbar \nabla F$$</span></p><h3 id="角动量算符">角动量算符</h3><p><span class="math display">$$\begin{array}{l}{\left[\hat{L}_{x},\hat{L}_{y}\right]=\mathrm{i} \hbar\hat{L}_{z}} \\{\left[\hat{L}_{y},\hat{L}_{z}\right]=\mathrm{i} \hbar \hat{L}_{x}} \\{\left[\hat{L}_{z},\hat{L}_{x}\right]=\mathrm{i} \hbar \hat{L}_{y}} \\{\left[\hat{L}_{x},x\right]=0,\left[\hat{L}_{x},y\right]=\mathrm{i}\hbar z,\left[\hat{L}_{x},z\right]=-\mathrm{i} \hbar y} \\{\left[\hat{L}_{y},x\right]=-\mathrm{i} \hbarz,\left[\hat{L}_{y},y\right]=0,\left[\hat{L}_{y},z\right]=\mathrm{i}\hbar x}\\{\left[\hat{L}_{z},x\right]=\mathrm{i} \hbary,\left[\hat{L}_{z},y\right]=-\mathrm{i} \hbarx,\left[\hat{L}_{z},z\right]=0}\end{array}$$</span></p><p>可表示为 <span class="math display">$$\begin{aligned}\left[\hat{L}_{i},r_{j}\right]=\mathrm{i} \hbar \varepsilon_{i j k}r_{k}\\\left[\hat{L}_{i},\hat{L}_{j}\right]=\mathrm{i} \hbar \varepsilon_{i jk} \hat{L}_{k}\end{aligned}$$</span></p><p>式中，<span class="math inline"><em>ε</em><sub><em>i</em><em>j</em><em>k</em></sub></span>是<strong>反对称张量</strong>，<span class="math inline"><em>ε</em><sub>123</sub> = <em>ε</em><sub>231</sub> = <em>ε</em><sub>312</sub> = 1</span>，<span class="math inline"><em>ε</em><sub>213</sub> = <em>ε</em><sub>132</sub> = <em>ε</em><sub>321</sub> = −1</span>。同理，可证明角动量算符与动量算符之间的关系，有 <span class="math display">[<em>L̂</em><sub><em>i</em></sub>, <em>p̂</em><sub><em>j</em></sub>] = iℏ<em>ε</em><sub><em>i</em><em>j</em><em>k</em></sub><em>p̂</em><sub><em>k</em></sub></span></p><h3 id="角动量平方算符">角动量平方算符</h3><p><span class="math display">$$\left[\hat{\vec{L_{}}}^{2},\hat{L}_{x}\right]=\left[\hat{\vec{L_{}}}^{2},\hat{L}_{y}\right]=\left[\hat{\vec{L_{}}}^{2}, \hat{L}_{z}\right]=0$$</span></p><h2 id="不同力学量同时有确定值的条件">不同力学量同时有确定值的条件</h2><ul><li><p>在经典物理学中，在任何状态下测量多个物理量都能得到确定的结果。</p></li><li><p>在量子力学中，系统遵循波粒二象性规律，测量力学量不一定都能得到确定的数值。</p></li><li><p>在量子力学中，只有在一个力学量的本征态下测量该力学量，才能得到确定值。因此，当两个力学量具有共同的本征态，测量这两个力学量均得到确定值。</p></li><li><p>两个力学量 <strong>具有共同本征态</strong>满足的条件是代表这两个力学量的两个算符 <span class="math inline"><em>F̂</em></span> 和 <span class="math inline"><em>Ĝ</em></span> 可以<strong>对易</strong>，即<span class="math display"><em>F̂</em><em>Ĝ</em> − <em>Ĝ</em><em>F̂</em> ≡ [<em>F̂</em>, <em>Ĝ</em>] = 0</span></p></li><li><p>如果一组算符有共同的本征函数，而且这些本征函数组成完全系，则这组算符中<strong>任何</strong> 一个算符与所有其他算符 <strong>对易</strong>。例如动量算符 <span class="math inline"><em>p̂</em><sub><em>x</em></sub></span>、<span class="math inline"><em>p̂</em><sub><em>y</em></sub></span>、<span class="math inline"><em>p̂</em><sub><em>z</em></sub></span>相互对易，所以它们有共同的本征函数 <span class="math inline"><em>ψ</em><sub>P</sub></span>，在这个状态中，这三个算符具有确定值<span class="math inline"><em>p</em><sub><em>x</em></sub></span>、<span class="math inline"><em>p</em><sub><em>y</em></sub></span>、<span class="math inline"><em>p</em><sub><em>z</em></sub></span>。</p></li><li><p>两个力学量 <span class="math inline"><em>Â</em></span>、<span class="math inline"><em>B̂</em></span>，若彼此不对易，<span class="math inline">[<em>Â</em>, <em>B̂</em>] ≠ 0</span>，则一般不能同时有确定值。在任一量子态中，其测量值的不确定程度满足不确定度关系：<span class="math display">$$  \Delta A \Delta B \geqslant\frac{1}{2}|\langle[\hat{A},\hat{B}]\rangle|  $$</span></p><p>其中</p><p><span class="math display">$$  \begin{array}{l}  (\Delta A)^{2}=\int \psi^{*}(\hat{A}-\langle\hat{A}\rangle)^{2} \psi\mathrm{d}\tau=\left\langle\psi\left|(\hat{A}-\langle\hat{A}\rangle)^{2}\right|\psi\right\rangle=\overline{(\hat{A}-\langle\hat{A}\rangle)^{2}} \\  (\Delta B)^{2}=\int \psi^{*}(\hat{B}-\langle\hat{B}\rangle)^{2} \psi\mathrm{d}\tau=\left\langle\psi\left|(\hat{B}-\langle\hat{B}\rangle)^{2}\right|\psi\right\rangle=\overline{(\hat{B}-\langle\hat{B}\rangle)^{2}}  \end{array}  $$</span></p><p>式中，<span class="math inline"><em>Δ</em><em>A</em></span>、<span class="math inline"><em>Δ</em><em>B</em></span> 分别是力学量 <span class="math inline"><em>Â</em></span>、<span class="math inline"><em>B̂</em></span>的方均根偏差，代表它们的不确定程度。上式说明两个线性厄密算符方均根偏差乘积存在的下限。<span class="math inline">⟨<em>Ĉ</em>⟩</span> 是算符 <span class="math inline"><em>Ĉ</em></span>在给定量子态的平均值，在特定的量子态 <span class="math inline">|<em>ϕ</em>⟩</span>，当 <span class="math inline">⟨<em>Ĉ</em>⟩ = 0</span> 时，<span class="math inline"><em>Δ</em><em>A</em><em>Δ</em><em>B</em> = 0</span>。</p></li><li><p>对于两个不对易算符：位置 <span class="math inline"><em>x</em></span> 和动量 <span class="math inline"><em>p̂</em><sub><em>x</em></sub></span>，<span class="math inline"><em>x</em></span> 和 <span class="math inline"><em>p</em><sub><em>x</em></sub></span>的不确定程度用它们的方均偏差表示，为 <span class="math display">$$  \begin{aligned}  &amp;(\Delta x)^{2}=\overline{(x-\langlex\rangle)^{2}}=\overline{x^{2}-2 x\langle x\rangle+\langlex\rangle^{2}}=\overline{x^{2}}-\langle x\rangle^{2}\\  &amp;(\Deltap_{x})^{2}=\overline{\left(\hat{p}_{x}-\left\langle\hat{p}_{x}\right\rangle\right)^{2}}=\overline{\hat{p}_{x}^{2}}-\left\langle\hat{p}_{x}\right\rangle^{2}  \end{aligned}  $$</span></p></li></ul><h2 id="态叠加原理">态叠加原理</h2><p>设 <span class="math inline"><em>Ψ</em><sub>1</sub>(<em>x</em>, <em>t</em>)</span>是描述粒子运动的一个态，<span class="math inline"><em>Ψ</em><sub>2</sub>(<em>x</em>, <em>t</em>)</span>也是描述粒子运动的一个态，则它们的线性叠加 <span class="math display"><em>Ψ</em>(<em>x</em>, <em>t</em>) = <em>c</em><sub>1</sub><em>Ψ</em><sub>1</sub>(<em>x</em>, <em>t</em>) + <em>c</em><sub>2</sub><em>Ψ</em><sub>2</sub>(<em>x</em>, <em>t</em>)</span></p><p>也是描述粒子运动的一个态，这是物质波所满足的态叠加原理。</p><p>叠加原理可以写成 <span class="math inline"><em>n</em></span>个波函数的线性组合 <span class="math display"><em>Ψ</em> = ∑<sub><em>n</em></sub><em>c</em><sub><em>n</em></sub><em>Ψ</em><sub><em>n</em></sub></span></p><p>这导致了量子力学的一个重要概念（也即我们之后解决量子力学问题的一个重要方法）：对于一个指定的量子体系，如果找到了它的完备的基本状态（所有可能的基本状态），例如<span class="math display">{<em>Ψ</em><sub>1</sub>, <em>Ψ</em><sub>2</sub>, ⋯, <em>Ψ</em><sub><em>n</em></sub>}</span></p><p>那么任何状态就都可以由这些基本状态叠加而得到（通过线性组合可以互相求出）。</p><h2 id="波函数坍缩">波函数坍缩</h2><p>若粒子处在叠加态 <span class="math display"><em>Ψ</em> = ∑<sub><em>i</em></sub><em>C</em><sub><em>i</em></sub><em>φ</em><sub><em>i</em></sub></span></p><p>上，其中 <span class="math inline"><em>φ</em><sub><em>i</em></sub></span> 为某算符<span class="math inline"><em>F̂</em></span> 的本征态，对应的本征值为<span class="math inline"><em>λ</em><sub><em>i</em></sub></span>。现在问对力学量<span class="math inline"><em>F</em></span> 进行测量，测量结果如何 <span class="math inline">?</span>这涉及量子力学的另一个假设：测量结果可能出现本征值中的任一个，出现 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 的概率为<span class="math inline">|<em>C</em><sub><em>i</em></sub>|<sup>2</sup></span>。也就是说，测量会对叠加态<span class="math inline"><em>Ψ</em></span> 产生严重干扰，测量会使波函数<span class="math inline"><em>Ψ</em></span> 向本征态 <span class="math inline"><em>φ</em><sub><em>i</em></sub></span>突变，造成波函数塌缩。<span class="math inline"><em>Ψ</em></span>向哪个本征态塌缩完全是随机的、不可逆的、非局域的，但塌缩的概率是确定的，等于<span class="math inline">|<em>C</em><sub><em>i</em></sub>|<sup>2</sup></span>。关于波函数的塌缩目前尚末完全了解。</p><h2 id="薛定谔方程">薛定谔方程</h2><h3 id="自由粒子的薛定谔方程">自由粒子的薛定谔方程</h3><p><span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\Psi(x,t)=-\frac{\hbar^{2}}{2 m} \frac{\partial^{2}}{\partial x^{2}}\Psi(x,t)$$</span></p><p>这就是自由粒子波函数满足的波动方程，可以称为<strong>自由粒子的薛定谔方程</strong>。</p><h3 id="含时薛定谔方程">含时薛定谔方程</h3><p>对非自由粒子（例如势场中的粒子），粒子的能量为 <span class="math display">$$E=\frac{p_{x}^{2}}{2 m}+U(x,t)$$</span></p><p>令能量算符或<strong>哈密顿算符</strong> <span class="math display">$$\widehat{H}=-\frac{\hbar^{2}}{2 m} \frac{\partial^{2}}{\partialx^{2}}+U(x,t)$$</span></p><p>则有 <span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t} \Psi(x,t)=\hat{H} \Psi(x,t)$$</span></p><p>称上式为<strong>含时薛定谔方程</strong>。进一步将一维势场推广到三维势场 <span class="math inline"><em>U</em>(<strong>r</strong>, <em>t</em>)</span>中，三维运动粒子的能量为 <span class="math display">$$E=\frac{p_{x}^{2}+p_{y}^{2}+p_{z}^{2}}{2 m}+U(\boldsymbol{r},t)$$</span></p><p>对应的哈密顿算符取如下形式 <span class="math display">$$\hat{H}=-\frac{\hbar^{2}}{2 m}\left(\frac{\partial^{2}}{\partialx^{2}}+\frac{\partial^{2}}{\partial y^{2}}+\frac{\partial^{2}}{\partialz^{2}}\right)+U(\boldsymbol{r},t)=-\frac{\hbar^{2}}{2 m}\nabla^{2}+U(\boldsymbol{r},t)$$</span></p><p>式中 <span class="math inline">$\boldsymbol{\nabla}=\frac{\partial}{\partial x}\boldsymbol{i}+\frac{\partial}{\partial y} j+\frac{\partial}{\partial z}\boldsymbol{k}$</span>。最后得到三维势场中运动粒子的含时薛定谔方程为<span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\Psi(\boldsymbol{r},t)=\hat{H} \Psi(\boldsymbol{r},t)$$</span></p><h3 id="定态薛定谔方程">定态薛定谔方程</h3><p>一般情况下势函数是时间和坐标的函数，若微观粒子处在稳定的势场中，则势能函数与时间无关，称这类问题为定态问题。在定态问题中，哈密顿算符也与时间无关<span class="math display">$$\widehat{H}=-\frac{\hbar^{2}}{2 m} \nabla^{2}+U(r)$$</span></p><p>含时的薛定谔方程可用分离变量法求解，将波函数 <span class="math inline"><em>Ψ</em>(<strong>r</strong>, <em>t</em>)</span>分离为坐标函数和时间函数两个因子的乘积，即 <span class="math display"><em>Ψ</em>(<strong>r</strong>, <em>t</em>) ≡ <em>Φ</em>(<strong>r</strong>)<em>T</em>(<em>t</em>)</span></p><p>代入薛定谔方程中 <span class="math display">$$\mathrm{i} \hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t}\Phi(\boldsymbol{r})=[\hat{H} \Phi(\boldsymbol{r})] T(t)$$</span></p><p>两边同时除以 <span class="math inline"><em>T</em>(<em>t</em>)<em>Φ</em>(<strong>r</strong>)</span>，得到<span class="math display">$$\mathrm{i} \hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t}\frac{1}{T(t)}=\frac{1}{\Phi(\boldsymbol{r})} \hat{H}\Phi(\boldsymbol{r})$$</span></p><p>在上式中，等式左边只含变量 <span class="math inline"><em>t</em></span>，右边只含变量 <span class="math inline"><strong>r</strong></span>，若该式对任意 <span class="math inline">(<em>t</em>, <strong>r</strong>)</span>成立，等式左右两边只能是与时间和坐标均无关的常数，设该常数为 <span class="math inline"><em>E</em></span>，则有 <span class="math display">$$\begin{aligned}&amp;\mathrm{i} \hbar \frac{\mathrm{d} T(t)}{\mathrm{d} t}=E T(t) \\&amp;\hat{H} \Phi(\boldsymbol{r})=E \Phi(\boldsymbol{r})\end{aligned}$$</span></p><p>第一个方程是关于变量为 <span class="math inline"><em>t</em></span>的微分方程，其解为 <span class="math display">$$T(t) \propto \mathrm{e}^{-\frac{i}{\hbar} E t}$$</span></p><p>是时间的振动函数。<br>第二个方程变为如下形式 <span class="math display">$$\left[-\frac{\hbar^{2}}{2 m} \nabla^{2}+U(x,y,z)\right] \Phi(x,y,z)=E\Phi(x,y,z)$$</span></p><p>是关于坐标 <span class="math inline">(<em>x</em>, <em>y</em>, <em>z</em>)</span>的二阶微分方程，称为<strong>定态薛定谔方程</strong>，又称为能量算符的本征方程。其解 <span class="math inline"><em>Φ</em>(<em>x</em>, <em>y</em>, <em>z</em>)</span>与粒子所处的外力场 <span class="math inline"><em>U</em></span>和边界条件有关。若求得该方程的解，则可将波函数表示为两部分的乘积： <span class="math display">$$\Psi(\boldsymbol{r},t)=\Phi(\boldsymbol{r}) \mathrm{e}^{-\frac{i}{\hbar}E t}$$</span></p><p>粒子概率密度 <span class="math display">$$\rho(\boldsymbol{r},t)=|\Psi(\boldsymbol{r},t)|^{2}=\left|\Phi(\boldsymbol{r})\mathrm{e}^{-\frac{i}{k} E t}\right|^{2}=|\Phi(\boldsymbol{r})|^{2}$$</span></p><p>与时间无关，只由定态波函数确定。可见定态问题最后归结为求解定态薛定谔方程。</p><h2 id="概率流密度">概率流密度</h2><p>如果粒子没有产生和湮灭现象，在随着时间演化的过程中，粒子数目保持不变，在全空间中找到它的概率之和与时间无关。</p><p>定义<strong>概率流密度</strong> <span class="math display">$$j=-\frac{\mathrm{i} \hbar}{2 m}\left(\Psi^{*} \nabla \Psi-\Psi \nabla\Psi^{*}\right)$$</span></p><p>则有 <span class="math display">$$\frac{\partial \rho}{\partial t}+\nabla \cdot \boldsymbol{j}=0$$</span></p><p>平面波波函数形式为 <span class="math display"><em>A</em><em>e</em><sup><em>i</em><em>k</em><em>x</em></sup></span></p><p>则其概率流密度为 <span class="math display">$$|A|^2\frac{\hbar k}{m}$$</span></p><p>透射系数 = 透射波的概率流密度/入射波的概率流密度； 反射系数 =反射波的概率流密度/入射波的概率流密度</p><h1 id="量子力学应用">量子力学应用</h1><h2 id="一维定态问题">一维定态问题</h2><h3 id="一维无限深方势阱">一维无限深方势阱</h3><p>金属中的电子由于金属表面势能（势垒）的束缚，被限制在一个有限的空间范围内运动。如果金属表面势垒很高，可以将金属表面看作一刚性盒子的壁。若只考虑一维运动，金属就是一维的刚性盒子，其势能函数可简化为<span class="math display">$$U(x)=\left\{\begin{array}{ll}0,&amp; 0 \leqslant x \leqslant L \\\infty,&amp; x&lt;0,x&gt;L\end{array}\right.$$</span></p><p>称为一维无限深方势阱。 一维无限深方势阻中运动的粒子的哈密顿算符为<span class="math display">$$\hat{H}=\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}},&amp; 0\leqslant x \leqslant L \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}+\infty,&amp;x&lt;0,x&gt;L\end{array}\right.$$</span></p><p>在势阱内，定态薛定谔方程 <span class="math display">$$-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{i}}(x)=E \Phi_{\mathrm{i}}(x)$$</span></p><p>令 <span class="math display">$$k^{2}=\frac{2 m E}{\hbar^{2}}$$</span></p><p>得 <span class="math display">$$\frac{\mathrm{d}^{2} \Phi_{\mathrm{i}}}{\mathrm{d} x^{2}}+k^{2}\Phi_{\mathrm{i}}=0$$</span></p><p>该方程的解为 <span class="math display"><em>Φ</em><sub>i</sub>(<em>x</em>) = <em>C</em>sin (<em>k</em><em>x</em> + <em>δ</em>)</span></p><p>待定常数 <span class="math inline"><em>C</em></span> 和 <span class="math inline"><em>δ</em></span> 由波函数的自然条件确定。<br>在势阱外， <span class="math display"><em>Φ</em><sub>e</sub>(<em>x</em>) = 0</span></p><p>利用波函数的连续性条件，阱内波函数在阱壁上也应为零，即 <span class="math display">$$\begin{array}{c} \Phi_{\mathrm{i}}(0)=\Phi_{\mathrm{e}}(0)=0 \\\Phi_{\mathrm{i}}(L)=\Phi_{\mathrm{e}}(L)=0 \end{array}$$</span></p><p>得：<span class="math inline"><em>δ</em> = 0</span>，<span class="math inline">$k=\frac{n \pi}{L}$</span>，<span class="math inline"><em>C</em></span> 由归一化条件确定。 解得波函数<span class="math display">$$\Phi_{n}(x)=\left\{\begin{array}{ll}\sqrt{\frac{2}{L}} \sin \frac{n \pi}{L} x,&amp; 0 \leqslant x \leqslantL \\0,&amp; 0&gt;x,x&gt;L \end{array}\right.$$</span></p><p>粒子的能量本征值为 <span class="math display">$$E_{n}=\frac{k^{2} \hbar^{2}}{2 m}=n^{2} E_{1}$$</span></p><p>式中 <span class="math inline">$E_{1}=\frac{\pi^{2} \hbar^{2}}{2 mL^{2}}$</span>，势阱中粒子能量取分立值，能量是量子化的，不同能量对应不同的能级，能量间隔为<span class="math display">$$\Delta E_{n}=E_{n+1}-E_{n}=(2 n+1) E_{1}=(2 n+1) \frac{\pi^{2}\hbar^{2}}{2 m L^{2}}$$</span></p><p>能级间隔与粒子的质量有关，微观粒子的质量越小，粒子的能级间隔越大，量子效应越明显。当粒子质量变大，粒子的能级间隔越小，对于宏观粒子，能级间隔趋于零，粒子的能量可以连续取值，量子效应消失。另一方面能级间隔与势阱宽度有关，势阱宽度越小，能级间隔越大，量子效应明显；势阱宽度越大，能级间隔越小，如果<span class="math inline"><em>L</em> → ∞</span>，能级间隔趋于零，粒子的能量可以连续取值，即自由粒子的能量可以取任意值。</p><p>束缚在势阱中的粒子，能量的最小值不能任意取值，有一个下限，称其为最低能量或称<strong>零点能</strong> 。对方势阱中的粒子，零点能为 <span class="math inline"><em>n</em> = 1</span> 时对应的能量为 <span class="math display">$$E_{1} = \frac{\pi^{2} \hbar^{2}}{2 m L^{2}} = \frac{h^{2}}{8 m L^{2}}$$</span></p><p>可见零点能不为零，这是粒子波动性的必然结果，是另一个量子效应。<br>利用能量动量关系将势阱中粒子的动量表示为 <span class="math display">$$p_{n}= \pm \sqrt{2 m E_{n}}= \pm n \frac{\pi \hbar}{L} = \pm n\frac{h}{2 L}$$</span></p><p>再利用德布罗意关系可将粒子的波长表示为 <span class="math display">$$\lambda_{n}=\frac{h}{\left|p_{n}\right|}=\frac{2 L}{n}$$</span></p><p>上式也可写成 <span class="math inline">$L=n\frac{\lambda_{n}}{2}$</span>，势阱宽度正好为半波长的整数倍。说明势阱中粒子的每一个能态<span class="math inline">(<em>n</em></span> 确定 <span class="math inline">)</span>对应的波函数为一个特定波长的驻波。将波函数的时间振荡因子与定态波函数相乘，得到粒子在阱内的波函数<span class="math display">$$\begin{aligned}\Psi_{n}(x,t) &amp; =\Phi_{n}(x) \mathrm{e}^{-\frac{i}{\hbar} E_{n} t}\\&amp; =\frac{1}{2 \mathrm{i}}\sqrt{\frac{2}{L}}\left[\mathrm{e}^{-\frac{i}{\hbar}\left(E_{n} t-p_{n}x\right)}-\mathrm{e}^{-\frac{i}{\hbar}\left(E_{n} t+p_{n}x\right)}\right] \\&amp; =C_{1} \mathrm{e}^{-\frac{i}{\hbar}\left(E_{n} t-p_{n}x\right)}+C_{2} \mathrm{e}^{-\frac{i}{\hbar}\left(E_{n} t+p_{n}x\right)}\end{aligned}$$</span></p><p>泡利根据上式认为，方势阱中粒子波函数为 <strong>两列平面波</strong>的叠加，这两列波的 <strong>频率相同</strong> 、<strong>波长相同</strong>，只是 <strong>传播方向相反</strong> ，叠加后形成 <strong>驻波</strong>，而且在阱壁处为 <strong>波节</strong> 。</p><h3 id="一维有限深方势阱">一维有限深方势阱</h3><p>一维有限深方势阱是指粒子被限制在一个有限深度的势阱中。势阱的势能函数为<span class="math display">$$U(x)=\left\{\begin{array}{ll}0,&amp; 0 \leqslant |x| \leqslant a \\U_{0},&amp; |x|&gt;a\end{array}\right.$$</span></p><p>粒子的哈密顿算符为 <span class="math display">$$\hat{H}=\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}},&amp; 0\leqslant |x| \leqslant a \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}+U_{0},&amp;|x|&gt;a\end{array}\right.$$</span></p><p>定态薛定谔方程为 <span class="math display">$$\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{i}}(x)=E \Phi_{\mathrm{i}}(x), &amp; 0 \leqslant |x|\leqslant a \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{e}}(x)+U_{0} \Phi_{\mathrm{e}}(x)=E \Phi_{\mathrm{e}}(x),&amp; |x|&gt;a\end{array}\right.$$</span></p><p>讨论 <span class="math inline">0 &lt; <em>E</em> &lt; <em>U</em><sub>0</sub></span>的情况，令 <span class="math display">$$k^{2}=\frac{2 m E}{\hbar^{2}}, \quad k'^{2}=\frac{2m(U_{0}-E)}{\hbar^{2}}$$</span></p><p>得到 <span class="math display">$$\left\{\begin{array}{ll}\frac{\mathrm{d}^{2} \Phi_{\mathrm{i}}}{\mathrm{d}x^{2}}+k^{2} \Phi_{\mathrm{i}}=0, &amp; 0 \leqslant x \leqslant a \\\frac{\mathrm{d}^{2} \Phi_{\mathrm{e}}}{\mathrm{d} x^{2}}-k'^{2}\Phi_{\mathrm{e}}=0, &amp; |x|&gt;a\end{array}\right.$$</span></p><p>该方程的解为 <span class="math display"><em>Φ</em><sub>i</sub>(<em>x</em>) = <em>C</em>sin (<em>k</em><em>x</em> + <em>δ</em>),  <em>Φ</em><sub>e</sub>(<em>x</em>) = <em>A</em><em>e</em><sup><em>k</em><sup>′</sup><em>x</em></sup> + <em>B</em><em>e</em><sup>−<em>k</em><sup>′</sup><em>x</em></sup></span></p><p>因为波函数在 <span class="math inline"><em>x</em> → ±∞</span>时应趋于零，所以 <span class="math inline"><em>x</em> &lt; 0</span> 时取<span class="math inline"><em>B</em> = 0</span>，<span class="math inline"><em>x</em> &gt; <em>a</em></span> 时取 <span class="math inline"><em>A</em> = 0</span>。因此波函数化为 <span class="math display">$$\Phi(x)=\left\{\begin{array}{ll}A e^{k' x}, &amp; x&lt; -a \\C \sin (k x+\delta), &amp; 0 \leqslant |x| \leqslant a \\B e^{-k' x}, &amp; x&gt;a \\\end{array}\right.$$</span></p><p>利用波函数的连续性条件，阱内波函数及一阶导数在阱壁处连续，则 <span class="math display">$$\begin{aligned}\Phi_{\mathrm{i}}(-a) &amp; =\Phi_{\mathrm{e}}(-a) \\\Phi_{\mathrm{i}}(a) &amp; =\Phi_{\mathrm{e}}(a) \\\frac{\mathrm{d} \Phi_{\mathrm{i}}}{\mathrm{d} x}\bigg|_{x=-a} &amp;=\frac{\mathrm{d} \Phi_{\mathrm{e}}}{\mathrm{d} x}\bigg|_{x=-a} \\\frac{\mathrm{d} \Phi_{\mathrm{i}}}{\mathrm{d} x}\bigg|_{x=a} &amp;=\frac{\mathrm{d} \Phi_{\mathrm{e}}}{\mathrm{d} x}\bigg|_{x=a}\end{aligned}$$</span></p><p>将波函数代入上式，得到 <span class="math display">$$\begin{aligned}&amp; A e^{-k' a}=C \sin (-k a+\delta) \\&amp; C \sin (k a+\delta)=B e^{-k' a} \\&amp; -A k' e^{-k' a}=C k \cos (-k a+\delta) \\&amp; C k \cos (k a+\delta)=-B k' e^{-k' a}\end{aligned}$$</span></p><p>则有 <span class="math display">$$\begin{aligned}&amp; k \cot (k a+\delta)=-k' \\&amp; k \cot (-k a+\delta)=k' \\\end{aligned}$$</span></p><p>则 <span class="math display">cot (<em>k</em><em>a</em> + <em>δ</em>) = −cot (−<em>k</em><em>a</em> + <em>δ</em>)</span></p><p>因此 <span class="math inline"><em>δ</em></span> 有两组解 <span class="math display">$$\delta= \left\{\begin{array}{l}n \pi\\(n + \frac{1}{2}) \pi\end{array}\right., \quad n=0,\pm 1,\pm 2,\cdots$$</span></p><p>不妨取 <span class="math inline"><em>n</em> = 0</span>，则<span class="math inline">$\delta=0 或 \frac{\pi}{2}$</span> 当 <span class="math inline"><em>δ</em> = 0</span> 时，代入上面四条等式得到 <span class="math inline"><em>A</em> = −<em>B</em></span>，波函数为奇宇称<span class="math display">$$\Phi(x)=\left\{\begin{array}{ll}A e^{k' x}, &amp; x&lt; -a \\C \sin (k x), &amp; 0 \leqslant |x| \leqslant a \\-A e^{-k' x}, &amp; x&gt;a\end{array}\right.$$</span></p><p>当 <span class="math inline">$\delta=\frac{\pi}{2}$</span>时，代入上面四条等式得到 <span class="math inline"><em>A</em> = <em>B</em></span>，波函数为偶宇称 <span class="math display">$$\Phi(x)=\left\{\begin{array}{ll}A e^{k' x}, &amp; x&lt; -a \\C \cos (k x), &amp; 0 \leqslant |x| \leqslant a \\A e^{-k' x}, &amp; x&gt;a\end{array}\right.$$</span></p><p>常数 <span class="math inline"><em>A</em></span> 和 <span class="math inline"><em>C</em></span> 由归一化条件和连接条件决定。</p><p><strong>奇宇称</strong>下，<span class="math inline"><em>δ</em> = 0</span>，此时 <span class="math inline"><em>k</em>cot (<em>k</em><em>a</em>) = −<em>k</em><sup>′</sup></span>，又有<span class="math inline">$k^{2} + k'^{2} = \frac{2 m E}{\hbar^{2}} +\frac{2 m (U_{0} - E)}{\hbar^{2}} = \frac{2 mU_{0}}{\hbar^{2}}$</span>，因此令 <span class="math display">$$\begin{aligned}&amp;u=ka, \quad v=k'a&gt;0 \\&amp;u\cot u=-v \\&amp;u^{2}+v^{2}=\frac{2 m U_{0} a^{2}}{\hbar^{2}}\end{aligned}$$</span></p><p>作图求解得：当 <span class="math inline">$\frac{2 m U_{0}a^{2}}{\hbar^{2}} \geqslant \frac{\pi^2}{4}$</span>时，才有第一奇宇称的束缚态存在。</p><p><strong>偶宇称</strong>下，<span class="math inline">$\delta =\frac{\pi}{2}$</span>，此时 <span class="math inline">$k \cot (k a +\frac{\pi}{2})=k \tan(k a)=k'$</span>，又有 <span class="math inline">$k^{2} + k'^{2} = \frac{2 m E}{\hbar^{2}} + \frac{2m (U_{0} - E)}{\hbar^{2}} = \frac{2 m U_{0}}{\hbar^{2}}$</span>，因此令<span class="math display">$$\begin{aligned}&amp;u=ka, \quad v=k'a&gt;0 \\&amp;u\tan u=v \\&amp;u^{2}+v^{2}=\frac{2 m U_{0} a^{2}}{\hbar^{2}}\end{aligned}$$</span></p><p>作图求解得：无论 <span class="math inline">$\frac{2 m U_{0}a^{2}}{\hbar^{2}}$</span>的大小，均有一个偶宇称的束缚态（基态）存在。</p><p><img src="image.png" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="一维方势垒和隧道效应">一维方势垒和隧道效应</h3><p>一维方势垒的势能函数为 <span class="math display">$$U(x)=\left\{\begin{array}{ll}U_{0},&amp; 0 \leqslant x \leqslant a \\0,&amp; x&lt;0,x&gt;a\end{array}\right.$$</span> 假设粒子的能量 <span class="math inline"><em>E</em> &lt; <em>U</em><sub>0</sub></span>，则粒子的哈密顿算符为<span class="math display">$$\hat{H}=\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}},&amp;x&lt;0,x&gt;a \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}+U_{0},&amp; 0\leqslant x \leqslant a\end{array}\right.$$</span></p><p>定态薛定谔方程为 <span class="math display">$$\left\{\begin{array}{ll}-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{i}}(x)=E \Phi_{\mathrm{i}}(x), &amp; x&lt;0,x&gt;a \\-\frac{\hbar^{2} \mathrm{~d}^{2}}{2 m \mathrm{~d} x^{2}}\Phi_{\mathrm{e}}(x)+U_{0} \Phi_{\mathrm{e}}(x)=E \Phi_{\mathrm{e}}(x),&amp; 0 \leqslant x \leqslant a\end{array}\right.$$</span></p><p>令 <span class="math display">$$k^{2}=\frac{2 m E}{\hbar^{2}}, \quad k'^{2}=\frac{2m(U_{0}-E)}{\hbar^{2}}$$</span></p><p>得到 <span class="math display">$$\left\{\begin{array}{ll}\frac{\mathrm{d}^{2} \Phi_{\mathrm{i}}}{\mathrm{d}x^{2}}+k^{2} \Phi_{\mathrm{i}}=0, &amp; x&lt;0,x&gt;a \\\frac{\mathrm{d}^{2} \Phi_{\mathrm{e}}}{\mathrm{d} x^{2}}-k'^{2}\Phi_{\mathrm{e}}=0, &amp; 0 \leqslant x \leqslant a\end{array}\right.$$</span></p><p>该方程的解为 <span class="math display">$$\Psi(x)=\left\{\begin{array}{ll}A e^{ikx}+ A' e^{-ikx}, &amp; x&lt;0 \\B e^{k'x}+ B' e^{-k'x}, &amp; 0 \leqslant x \leqslant a \\C e^{ikx}+ C' e^{-ikx}, &amp; x&gt;a\end{array}\right.$$</span></p><p>其中，<span class="math inline"><em>e</em><sup><em>i</em><em>k</em><em>x</em></sup></span>和 <span class="math inline"><em>e</em><sup>−<em>i</em><em>k</em><em>x</em></sup></span>分别表示向右和向左传播的平面波，<span class="math inline"><em>e</em><sup><em>k</em><sup>′</sup><em>x</em></sup></span>和 <span class="math inline"><em>e</em><sup>−<em>k</em><sup>′</sup><em>x</em></sup></span>分别表示向右和向左衰减的指数波。</p><p>从物理条件考虑，<span class="math inline"><em>C</em><sup>′</sup> = 0</span>，再由波函数和一阶导数的连续性条件，得到<span class="math display">$$\begin{aligned}&amp; \Psi_1(0)=A + A' = B + B'= \Psi_2(0)\\&amp; \Psi_1'(0)=ik(A - A') = k' (B - B') = \Psi_2'(0)\\&amp; \Psi_2(a)=B e^{k'a} + B' e^{-k'a} = C e^{ika} = \Psi_3(a)\\&amp; \Psi_2'(a)=k' (B e^{k'a} - B' e^{-k'a}) = ik C e^{ika} =\Psi_3'(a)\end{aligned}$$</span></p><p>解得反射系数 <span class="math display">$$R = \left| \frac{A'}{A} \right|^2 = \frac{(k^2+k'^2)^2\sinh^2(k'a)}{(k^2+k'^2)^2 \sinh^2(k'a) + 4 k^2 k'^2}$$</span></p><p>透射系数 <span class="math display">$$T = \left| \frac{C}{A} \right|^2 = \frac{4 k^2 k'^2}{(k^2+k'^2)^2\sinh^2(k'a) + 4 k^2 k'^2}$$</span></p><p>势垒 <span class="math inline"><em>U</em><sub>0</sub></span>越高，宽度 <span class="math inline"><em>a</em></span>越大，粒子穿透的概率越小，反射系数 <span class="math inline"><em>R</em></span> 越大，透射系数 <span class="math inline"><em>T</em></span>越小，但总有一定几率穿透，这一现象称为<strong>量子隧道效应</strong>。</p><p>透射系数 <span class="math inline"><em>T</em></span> 和反射系数 <span class="math inline"><em>R</em></span> 满足 <span class="math display"><em>R</em> + <em>T</em> = 1</span></p><p>且透射系数 <span class="math inline"><em>T</em></span> 对势垒的宽度<span class="math inline"><em>a</em></span> 和粒子质量 <span class="math inline"><em>m</em></span> 的变化很敏感。</p><p>当 <span class="math inline"><em>E</em> &gt; <em>U</em><sub>0</sub></span>时，透射系数表示为 <span class="math display">$$T = \frac{4 k^2 k'^2}{(k^2-k'^2)^2 \sin^2(k'a) + 4 k^2 k'^2} = \frac{4 E(E-U_0)}{U_0^2 \sin^2(k'a) + 4 E (E-U_0)}$$</span></p><h2 id="谐振子">谐振子</h2><h3 id="定义-1">定义</h3><p>一般而言，任何一个体系在稳定平衡点附近都可以近似地用线性谐振子来表示。谐振子的势能可以表示为<span class="math display">$$V=\frac{1}{2} \mu \omega^{2} x^{2}$$</span></p><p>式中，<span class="math inline"><em>ω</em></span> 是常量；<span class="math inline"><em>μ</em></span>是谐振子的质量。这种体系为线性振子。在经典力学中，线性振子所做的运动是简谐振动。振子满足运动方程<span class="math inline"><em>x</em> = <em>A</em>cos (<em>ω</em><em>t</em> + <em>ϕ</em>)</span>，<span class="math inline"><em>A</em></span> 是振幅，<span class="math inline"><em>ϕ</em></span>是初相位，谐振子能量与振幅的平方成正比。量子理论的结果与经典力学的结果有着根本性的差异。我们用量子力学来解线性谐振子问题，求出能量和波函数。</p><h3 id="厄密方程">厄密方程</h3><p>选取适当的坐标系，则体系的薛定谔方程为 <span class="math display">$$\left(-\frac{\hbar^{2}}{2 \mu} \frac{\mathrm{d}^{2}}{\mathrm{~d}x^{2}}+\frac{1}{2} \mu \omega^{2} x^{2}\right) \psi(x)=E \psi(x)$$</span></p><p>引入无量纲参数 <span class="math inline"><em>ξ</em></span> 代替 <span class="math inline"><em>x</em></span>，即 <span class="math display">$$\xi=\alpha x,\alpha=\sqrt{\frac{\mu \omega}{\hbar}}$$</span></p><p>令 <span class="math inline">$\lambda=\frac{E}{\frac{1}{2} \hbar\omega}$</span>，把薛定谔方程改写为 <span class="math display">$$\frac{\mathrm{d}^{2}}{\mathrm{~d} \xi^{2}}\psi(\xi)+\left(\lambda-\xi^{2}\right) \psi(\xi)=0$$</span></p><p>首先求出 <span class="math inline"><em>ξ</em> → ±∞</span>时的渐进行为。当 <span class="math inline"><em>ξ</em></span>很大时，上式的解应接近 <span class="math display">$$\frac{\mathrm{d}^{2}}{\mathrm{~d} \xi^{2}} \psi(\xi)-\xi^{2} \psi(\xi)=0$$</span></p><p>其解为 <span class="math display">$$\psi(\xi) \sim \mathrm{e}^{ \pm \frac{1}{2} \xi^{2}}$$</span></p><p>满足物理边界条件的解为 <span class="math display">$$\psi(\xi) \sim \mathrm{e}^{-\frac{1}{2} \xi^{2}}$$</span></p><p>因此设 <span class="math inline">$\psi(\xi)=\mathrm{e}^{-\frac{1}{2}\xi^{2}} u(\xi)$</span>，代入式 <span class="math inline">(2 − 56)</span>，得到 <span class="math inline"><em>u</em>(<em>ξ</em>)</span> 满足方程 <span class="math display">$$\frac{\mathrm{d}^{2} u}{\mathrm{~d} \xi^{2}}-2 \xi \frac{\mathrm{d}u}{\mathrm{~d} \xi}+(\lambda-1) u=0$$</span></p><p>上式是厄密方程。</p><h3 id="方程的解">方程的解</h3><p>可采用幂级数展开求解 <span class="math display">$$\begin{aligned}u(\xi)&amp;=\sum_{k=0}^{\infty} c_{k} \xi^{k} \\u^{\prime}(\xi)&amp;=\sum_{k} c_{k} k \xi^{k-1} \\u^{\prime \prime}(\xi)&amp;=\sum_{k} c_{k} k(k-1) \xi^{k-2}\end{aligned}$$</span></p><p>所以得到 <span class="math display">$$\sum_{k=0}^{\infty} c_{k} k(k-1) \xi^{k-2}-2 \sum_{k} c_{k}k\xi^{k}+(\lambda-1) \sum_{k} c_{k} \xi^{k}=0$$</span></p><p>比较 <span class="math inline"><em>ξ</em><sup><em>j</em></sup></span>的系数 <span class="math display"><em>c</em><sub><em>j</em> + 2</sub>(<em>j</em> + 2)(<em>j</em> + 1) − 2<em>c</em><sub><em>j</em></sub><em>j</em> + (<em>λ</em> − 1)<em>c</em><sub><em>j</em></sub> = 0</span></p><p>求得 <span class="math display">$$c_{j+2}=\frac{2 j-(\lambda-1)}{(j+2)(j+1)} c_{j}$$</span></p><p>即系数递推关系式。厄密方程的解或者是偶次幂，或者是奇次幂。这两个解在<span class="math inline"><em>ξ</em></span>取有限值时都收敛。所有偶次幂系数都可以 <span class="math inline"><em>c</em><sub>0</sub></span>表示，所有奇次幂系数都可以 <span class="math inline"><em>c</em><sub>1</sub></span>表示。两个线性无关的解分别表示为 <span class="math display">$$\begin{aligned}u_{1}(\xi)&amp;=c_{0}+c_{2} \xi^{2}+c_{4} \xi^{4}+\cdots \\u_{2}(\xi)&amp;=c_{1} \xi+c_{3} \xi^{3}+c_{5} \xi^{5}+\cdots\end{aligned}$$</span></p><p>这两个解在 <span class="math inline"><em>ξ</em> → ∞</span>时取无限项时都发散，因此必须截断，所以当 <span class="math inline"><em>λ</em> − 1 = 2<em>n</em></span> 时，系数 <span class="math inline"><em>c</em><sub><em>n</em> + 2</sub>, <em>c</em><sub><em>n</em> + 4</sub>, <em>c</em><sub><em>n</em> + 6</sub>, ⋯</span>都为零。</p><h3 id="能量本征值">能量本征值</h3><p>上述要求给出的能量有一定限制，即谐振子的能量本征值为 <span class="math display">$$E_{n}=\frac{\lambda}{2} \hbar \omega=\left(n+\frac{1}{2}\right) \hbar\omega = \left(n+\frac{1}{2}\right) h \nu$$</span></p><p>可以看到，谐振子的能级是量子化且均匀分布的，相邻能级间隔是 <span class="math inline">ℏ<em>ω</em></span>。对应的能量本征函数为 <span class="math display">$$\psi_{n}(x)=N_{n} H_{n}(\xi) \mathrm{e}^{-\frac{1}{2} \xi^{2}}$$</span></p><p>式中，<span class="math inline"><em>N</em><sub><em>n</em></sub></span>为归一化常数；<span class="math inline"><em>H</em><sub><em>n</em></sub>(<em>ξ</em>)</span>为厄密多项式。</p><h3 id="波函数">波函数</h3><p>谐振子波函数表述为 <span class="math display">$$\psi_{n}(x)=\left(\frac{\mu \omega}{\pi \hbar}\right)^{\frac{1}{4}}\frac{1}{\sqrt{2^{n} n !}} H_{n}(\sqrt{\frac{\mu \omega}{\hbar}} x)\mathrm{e}^{-\frac{\mu \omega}{2 \hbar} x^{2}}$$</span></p><p>其中 <span class="math display">$$H_{n}(\xi)=(-1)^{n} \mathrm{e}^{\xi^{2}}\frac{\mathrm{d}^{n}}{\mathrm{~d} \xi^{n}} \mathrm{e}^{-\xi^{2}}$$</span></p><p>前面几项厄密多项式如下： <span class="math display">$$\begin{array}{l} H_{0}(\xi)=1 \\ H_{1}(\xi)=2 \xi \\ H_{2}(\xi)=4\xi^{2}-2 \\ H_{3}(\xi)=8 \xi^{3}-12 \xi \end{array}$$</span></p><p>三个能量最低能级的波函数如下。</p><ul><li>基态：<span class="math display">$$ \psi_{0}(x)=\left(\frac{\mu\omega}{\pi \hbar}\right)^{\frac{1}{4}} \mathrm{e}^{-\frac{\mu \omega}{2\hbar} x^{2}}$$</span></li><li>第一激发态：<span class="math display">$$\psi_{1}(x)=\left(\frac{\mu \omega}{\pi \hbar}\right)^{\frac{1}{4}}\sqrt{\frac{2 \mu \omega}{\hbar}} x \mathrm{e}^{-\frac{\mu \omega}{2\hbar} x^{2}}$$</span></li><li>第二激发态：<span class="math display">$$\psi_{2}(x)=\left(\frac{\mu \omega}{4 \pi\hbar}\right)^{\frac{1}{4}}\left(\frac{2 \mu \omega}{\hbar}x^{2}-1\right) \mathrm{e}^{-\frac{\mu \omega}{2 \hbar}x^{2}}$$</span></li></ul><h2 id="氢原子">氢原子</h2><h3 id="定义-2">定义</h3><p>氢原子是一个质子（电荷为 <span class="math inline">+<em>e</em></span>）和一个电子（电荷为 <span class="math inline">−<em>e</em></span>）组成的两体系统，二者之间存在库仑相互作用。由于质子的质量<span class="math inline">(<em>M</em>)</span> 大约是电子质量 <span class="math inline"><em>m</em><sub>e</sub></span>的两千倍，作为近似处理，可以建立以质子为坐标原点的坐标系，电子位置用球坐标<span class="math inline">(<em>r</em>, <em>θ</em>, <em>φ</em>)</span>表示。氢原子如同一个电子的陷阱，它把一个电子限定在某一区域。</p><h3 id="薛定谔方程-1">薛定谔方程</h3><p>氢原子中电子的势能为 <span class="math display">$$V(r)=-\frac{Z e^{2}}{4 \pi \varepsilon_{0} r}$$</span></p><p>式中，<span class="math inline"><em>Z</em><em>e</em></span>是原子核的电荷，对于氢原子核，<span class="math inline"><em>Z</em> = 1</span>。设原子核静止，将 <span class="math inline"><em>V</em>(<em>r</em>)</span> 代入定态薛定谔方程，得<span class="math display">$$\hat{H} \psi=\left(-\frac{\hbar^{2}}{2 m} \nabla^{2}-\frac{e^{2}}{4 \pi\varepsilon_{0} r}\right) \psi=E \psi$$</span></p><p>式中，<span class="math inline">∇<sup>2</sup></span>是拉普拉斯算符，<span class="math inline"><em>m</em></span> 是约化质量<span class="math inline"><em>M</em><em>m</em><sub><em>e</em></sub>/(<em>M</em> + <em>m</em><sub><em>e</em></sub>)</span>。由于哈密顿量有球对称性，在球坐标中讨论比较方便，拉普拉斯算符用球坐标表示为<span class="math display">$$\begin{aligned}\nabla^{2} &amp; =\frac{1}{r^{2}} \frac{\partial}{\partial r}\left(r^{2}\frac{\partial}{\partial r}\right)+\frac{1}{r^{2} \sin \theta}\frac{\partial}{\partial \theta}\left(\sin \theta\frac{\partial}{\partial \theta}\right) +\frac{1}{r^{2} \sin \theta}\frac{\partial^{2}}{\partial \varphi^{2}} \\&amp; =\frac{1}{r^{2}} \frac{\partial}{\partial r}\left(r^{2}\frac{\partial}{\partial r}\right)-\frac{L^{2}}{r^{2} \hbar^{2}}\end{aligned}$$</span></p><p>用分离变量法求解 <span class="math display">$$\hat{H}=-\frac{\hbar^{2}}{2 m r^{2}} \frac{\partial}{\partialr}\left(r^{2} \frac{\partial}{\partial r}\right)+\frac{L^{2}}{2 mr^{2}}+V(r)$$</span></p><p>式中，第一项是径向动能算符；第二项是离心势能。容易证明，<span class="math inline">$\hat{H},\hat{\boldsymbol{L}}^{2},\hat{L}_{z}$</span>三者是彼此对易的，所以三者构成力学量完全集，有一套<strong>共同本征函数</strong>。</p><p>在这套本征函数中，能量、角动量、角动量 <span class="math inline"><em>z</em></span> 分量有确定值。而 <span class="math inline"><em>L</em><sup>2</sup></span> 和 <span class="math inline"><em>L</em><sub><em>z</em></sub></span>的本征函数和本征值如下： <span class="math display">$$\begin{aligned}&amp;\hat{\mathbf{L}}^{2} Y_{l m}(\theta,\phi)=l(l+1) \hbar^{2} Y_{lm}(\theta,\phi) \\&amp;\hat{L}_{z} Y_{l m}(\theta,\phi)=m_{l} \hbar Y_{l m}(\theta,\phi)\\&amp;l=0,1,2,\cdots \\&amp;m_{l}=-l,-l+1,\cdots,+l\end{aligned}$$</span></p><p>式中，<span class="math inline"><em>l</em></span> 是角量子数；<span class="math inline"><em>m</em><sub><em>l</em></sub></span>是磁量子数。对一个确定的角量子数 <span class="math inline"><em>l</em></span>，<span class="math inline"><em>m</em><sub><em>l</em></sub></span> 可以取 <span class="math inline">2<em>l</em> + 1</span>个值。这表明角动量在空间取向只有 <span class="math inline">2<em>l</em> + 1</span> 个可能。</p><h3 id="氢原子束缚态能量本征函数">氢原子束缚态能量本征函数</h3><p>所以，氢原子束缚态能量本征函数为 <span class="math display">$$\begin{aligned}&amp;\Psi_{n l m}(r, \theta, \phi)=R_{n l}(r) Y_{l m}(\theta, \phi)\\&amp;n=1,2,3,\cdots \\&amp;l=0,1,2,\cdots,n-1 \\&amp;m_{l}=-l,-l+1,\cdots,0,\cdots,l-1,l\end{aligned}$$</span></p><p>其中，<span class="math inline"><em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)</span>是径向波函数，<span class="math inline"><em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>ϕ</em>)</span>是球谐函数，<span class="math inline"><em>n</em></span>是主量子数，<span class="math inline"><em>l</em></span>是角量子数，<span class="math inline"><em>m</em><sub><em>l</em></sub></span>是磁量子数。</p><p>哈密顿算符 <span class="math inline"><em>Ĥ</em></span> 对应本征函数<span class="math inline"><em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)</span>的本征值为 <span class="math display">$$E_{n}=-\frac{Z^{2} e^{4} m_{e}}{8 \varepsilon_{0}^{2} h^{2}n^{2}}=-\frac{e^{4} m_{e}}{8 \varepsilon_{0}^{2} h^{2}} \frac{1}{n^{2}}= -\frac{13.6 \mathrm{eV}}{n^{2}}, \quad n=1,2,3,\cdots$$</span></p><p>角动量平方算符 <span class="math inline"><em>L̂</em><sup>2</sup></span> 对应本征函数 <span class="math inline"><em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>ϕ</em>)</span>的本征值为 <span class="math display"><em>L</em><sup>2</sup> = <em>l</em>(<em>l</em> + 1)ℏ<sup>2</sup>,  <em>l</em> = 0, 1, 2, ⋯</span></p><p>则角动量大小为 <span class="math display">$$L=\sqrt{l(l+1)} \hbar, \quad l=0,1,2,\cdots$$</span></p><p>角动量的 <span class="math inline"><em>z</em></span> 分量算符 <span class="math inline"><em>L̂</em><sub><em>z</em></sub></span> 对应本征函数<span class="math inline"><em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>ϕ</em>)</span>的本征值为 <span class="math display"><em>L</em><sub><em>z</em></sub> = <em>m</em><sub><em>l</em></sub>ℏ,  <em>m</em><sub><em>l</em></sub> = −<em>l</em>, −<em>l</em> + 1, ⋯, +<em>l</em></span></p><h3 id="电子的概率分布">电子的概率分布</h3><p>按照波函数的物理解释，对于定态，<span class="math inline">|<em>ψ</em><sub><em>n</em><em>l</em><em>m</em></sub>|<sup>2</sup> = |<em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)<em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>ϕ</em>)|<sup>2</sup></span>代表电子的概率密度。概率密度乘以球坐标的体积元 <span class="math display">d<em>τ</em> = <em>r</em><sup>2</sup>sin <em>θ</em>d<em>r</em>&nbsp;d<em>θ</em>d<em>φ</em> = <em>r</em><sup>2</sup>&nbsp;d<em>r</em>&nbsp;d<em>Ω</em></span></p><p>其中 <span class="math inline">d<em>Ω</em> = sin <em>θ</em>d<em>θ</em>d<em>φ</em>, d<em>Ω</em></span>是 <span class="math inline">(<em>θ</em>, <em>φ</em>)</span>方向上的立体角元，则电子出现在体积元 <span class="math inline">d<em>τ</em></span> 中的概率密度 <span class="math display">|<em>ψ</em><sub><em>n</em><em>l</em><em>m</em></sub>|<sup>2</sup> = |<em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)<em>Y</em><sub><em>l</em><em>m</em></sub>(<em>θ</em>, <em>φ</em>)|<sup>2</sup></span></p><p>且满足归一化条件 <span class="math display">∫|<em>ψ</em><sub><em>n</em><em>l</em><em>m</em></sub>(<em>r</em>, <em>θ</em>, <em>ϕ</em>)|<sup>2</sup><em>r</em><sup>2</sup>&nbsp;d<em>r</em>&nbsp;d<em>Ω</em> = 1</span></p><p>电子沿径向的概率密度为 <span class="math display"><em>P</em><sub><em>n</em><em>l</em></sub>(<em>r</em>) = |<em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)|<sup>2</sup><em>r</em><sup>2</sup></span></p><p>电子沿角向的概率密度为 <span class="math display"><em>P</em><sub><em>l</em><em>m</em><sub><em>l</em></sub></sub>(<em>θ</em>, <em>φ</em>) = |<em>Y</em><sub><em>l</em><em>m</em><sub><em>l</em></sub></sub>(<em>θ</em>, <em>φ</em>)|<sup>2</sup></span></p><p>定义最可几半径为电子沿径向的概率密度最大值对应的 <span class="math inline"><em>r</em></span> 值，即 <span class="math display"><em>r</em><sub><em>n</em><em>l</em></sub> = arg max<sub><em>r</em></sub><em>P</em><sub><em>n</em><em>l</em></sub>(<em>r</em>) = arg max<sub><em>r</em></sub>|<em>R</em><sub><em>n</em><em>l</em></sub>(<em>r</em>)|<sup>2</sup><em>r</em><sup>2</sup></span></p><p>则有 <span class="math inline"><em>r</em><sub>10</sub> = <em>a</em><sub>0</sub></span>，其中<span class="math inline"><em>a</em><sub>0</sub></span> 是玻尔半径。</p><h3 id="电子自旋角动量">电子自旋角动量</h3><p>电子自旋角动量是电子的内禀角动量，与电子的轨道角动量不同。电子自旋角动量的大小为<span class="math display">$$S=\sqrt{s(s+1)} \hbar$$</span></p><p><span class="math inline"><em>z</em></span> 分量为 <span class="math display"><em>S</em><sub><em>z</em></sub> = <em>m</em><sub><em>s</em></sub>ℏ</span></p><p>其中，<span class="math inline"><em>s</em></span> 是自旋量子数，<span class="math inline"><em>m</em><sub><em>s</em></sub></span>是自旋磁量子数，则有 <span class="math inline">2<em>s</em> + 1</span>个可能的自旋状态。对于电子，<span class="math inline">2<em>s</em> + 1 = 2</span>，即 <span class="math inline">$s=\frac{1}{2}$</span>，<span class="math inline"><em>m</em><sub><em>s</em></sub></span> 可以取 <span class="math inline">$\pm \frac{1}{2}$</span>。</p><p>所以有电子自旋角动量的大小 <span class="math display">$$S=\frac{\sqrt{3}}{2} \hbar$$</span></p><p><span class="math inline"><em>z</em></span> 分量大小为 <span class="math display">$$S_{z}=m_{s} \hbar=\pm \frac{1}{2} \hbar$$</span></p><h3 id="泡利不相容原理">泡利不相容原理</h3><ol type="1"><li>费米子和玻色子<ul><li>费米子：自旋量子数为半整数的粒子</li><li>玻色子：自旋量子数为整数的粒子</li></ul></li><li>泡利不相容原理<ul><li>不能有两个电子具有相同的四个量子数 <span class="math inline">(<em>n</em>, <em>l</em>, <em>m</em><sub><em>l</em></sub>, <em>m</em><sub><em>s</em></sub>)</span></li></ul></li><li>玻色凝聚<ul><li>玻色子不受泡利不相容原理的限制，一个单粒子态可以容纳多个玻色子</li></ul></li></ol><h3 id="原子核外电子排布">原子核外电子排布</h3><p>同一主壳层可容纳的电子数为 <span class="math inline">2<em>n</em><sup>2</sup></span>，其中 <span class="math inline"><em>n</em></span> 是主量子数。每个次壳层的电子数为<span class="math inline">2(2<em>l</em> + 1)</span>，其中 <span class="math inline"><em>l</em></span> 是角量子数。 <span class="math display">$$N_n = \sum_{l=0}^{n-1} 2(2l + 1) = 2 [1+3+5+\cdots+(2n-1)] = 2n^2$$</span></p><p>原子核外电子排布遵循以下原则：</p><ol type="1"><li><strong>能量最低原则</strong>：电子总是先填充能量最低的轨道。</li><li><strong>泡利不相容原理</strong>：每个轨道最多只能容纳两个电子，且自旋方向相反。</li><li><strong>洪特规则</strong>：在同一能级的轨道中，电子会尽量单独占据每个轨道，直到所有轨道都被占据后才会成对填充。</li><li><strong>能级顺序</strong>：电子填充的顺序遵循能级从低到高的原则，通常遵循<span class="math inline"><em>n</em> + <em>l</em></span> 规则，即先填充<span class="math inline"><em>n</em> + <em>l</em></span>值小的轨道。</li></ol><h2 id="双态系统">双态系统</h2><h3 id="薛定谔方程矩阵形式">薛定谔方程矩阵形式</h3><p>考虑一个量子系统，它的态空间是二维的，将薛定谔方程表达为矩阵形式，有<span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\left[\begin{array}{l}C_{1}\\C_{2} \end{array}\right]=\left[\begin{array}{ll} H_{11} &amp;H_{12} \\ H_{21} &amp; H_{22} \end{array}\right]\left[\begin{array}{l}C_{1} \\ C_{2} \end{array}\right]$$</span></p><p><strong>哈密顿算符</strong> 用矩阵表示。如果选取<strong>基矢</strong><span class="math inline">|<em>χ</em><sub><em>α</em></sub>⟩(<em>α</em> = ±</span>，即<span class="math inline">|<em>χ</em><sub>+</sub>⟩</span> 和 <span class="math inline">|<em>χ</em><sub>−</sub>⟩)</span>是哈密顿算符的本征矢，则 <span class="math display">$$\begin{aligned}\hat{H}\left|\chi_{+}\right\rangle=E_{1}\left|\chi_{+}\right\rangle \\\hat{H}\left|\chi_{-}\right\rangle=E_{2}\left|\chi_{-}\right\rangle\end{aligned}$$</span></p><p>以此为基的表象是<strong>能量表象</strong>。由于本征矢的正交归一性，有 <span class="math display">$$\begin{array}{c}H_{11}=\left\langle\chi_{+}|\hat{H}|\chi_{+}\right\rangle=E_{1},H_{22}=\left\langle\chi_{-}|\hat{H}|\chi_{-}\right\rangle=E_{2}\\H_{12}=\left\langle\chi_{+}|\hat{H}|\chi_{-}\right\rangle=0,H_{21}=\left\langle\chi_{-}|\hat{H}|\chi_{+}\right\rangle=0\end{array}$$</span></p><p>所以在能量表象中哈密顿矩阵是对角的： <span class="math display">$$\left[\begin{array}{ll} H_{11} &amp; H_{12} \\ H_{21} &amp; H_{22}\end{array}\right]=\left[\begin{array}{cc} E_{1} &amp; 0 \\ 0 &amp;E_{2} \end{array}\right]$$</span></p><p>在能量表象下，哈密顿矩阵是对角的，薛定谔方程有 <span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\left[\begin{array}{l} C_{+}\\ C_{-} \end{array}\right]=\left[\begin{array}{cc} E_{1} &amp; 0 \\ 0&amp; E_{2} \end{array}\right]\left[\begin{array}{l} C_{+} \\ C_{-}\end{array}\right]$$</span></p><p>由此得到 <span class="math display">$$C_{\alpha}(t)=C_{\alpha}(0) \mathrm{e}^{-\frac{i E_{\alpha} t}{h}} \quad\alpha= \pm$$</span></p><p>可见，概率幅的模方是不随时间变化的常量。如果初态是哈密顿矩阵的一个本征态<span class="math inline">|<em>χ</em><sub><em>α</em></sub>⟩</span>，则概率幅是<span class="math inline">$|\psi(t)\rangle=\mathrm{e}^{-i\frac{E_{\alpha}t}{h}}\left|\chi_{\alpha}\right\rangle$</span>，其模方是不变的，系统处于<strong>定态</strong>。</p><p>一般表象下，哈密顿矩阵不是对角化的，<span class="math inline">|<em>u</em><sub>1</sub>⟩</span> 和 <span class="math inline">|<em>u</em><sub>2</sub>⟩</span>不是哈密顿算符本征态，因而不是定态。如果系统初始处于态 <span class="math inline">|<em>u</em><sub>1</sub>⟩</span>，则这个系统有一定概率<span class="math inline"><em>P</em><sub>12</sub></span> 在 <span class="math inline"><em>t</em></span> 时刻处于态 <span class="math inline">|<em>u</em><sub>2</sub>⟩</span>。这是因为 <span class="math inline"><em>H</em><sub>12</sub></span> 和 <span class="math inline"><em>H</em><sub>21</sub></span>引起了两个态之间的跃迁。因此，可以称非对角元为耦合。</p><h3 id="氨分子的双态模型">氨分子的双态模型</h3><p>氨分子中，三个氢原子分别位于正三角形的三个顶点上，而一个氮原子则位于三角形中心偏左方，整个分子呈四面体结构。因此，氨分子内部可能产生振荡，也就是说，氮原子以三角形平面为对称面在两边来回振动。这个体系的势能<span class="math inline"><em>V</em>(<em>x</em>)</span>是氮原子与氢原子所在平面之间距离 <span class="math inline"><em>z</em></span> 的函数。</p><p>设两种结构的量子态分别是 <span class="math inline">|1⟩</span> 和<span class="math inline">|2⟩</span>，它们具有相同的能量，即<span class="math inline"><em>H</em><sub>11</sub> = <em>H</em><sub>22</sub> = <em>E</em><sub>0</sub></span>。由于氮原子穿越氢原子中央而翻转到另一侧，即穿透势垒发生量子隧穿，所以<span class="math inline"><em>H</em><sub>12</sub></span> 和 <span class="math inline"><em>H</em><sub>21</sub></span>不为零。不妨假定它们是负的实数，即 <span class="math inline"><em>H</em><sub>12</sub> = <em>H</em><sub>21</sub> = <em>A</em>(<em>A</em> &lt; 0)</span>，于是得到氨分子双态的薛定谔方程为<span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\left[\begin{array}{l}C_{1}\\ C_{2} \end{array}\right]=\left[\begin{array}{cc} E_{0} &amp; A\\ A &amp; E_{0} \end{array}\right]\left[\begin{array}{l} C_{1} \\ C_{2}\end{array}\right]$$</span></p><p>令 <span class="math inline">$C_{ \pm}=\frac{1}{\sqrt{2}}\left(C_{1}\pm C_{2}\right)$</span>，则上式变成 <span class="math display">$$\mathrm{i} \hbar \frac{\partial}{\partial t}\left[\begin{array}{l} C_{+}\\ C_{-} \end{array}\right]=\left[\begin{array}{cc} E_{0}+A &amp; 0 \\ 0&amp; E_{0}-A \end{array}\right]\left[\begin{array}{l} C_{+} \\ C_{-}\end{array}\right]$$</span></p><p>由于哈密顿矩阵是对角的，本征值 <span class="math inline"><em>E</em><sub>±</sub> = <em>E</em><sub>0</sub> ± <em>A</em></span>，对应本征矢<span class="math inline">|<em>χ</em><sub>+</sub>⟩</span> 和 <span class="math inline">|<em>χ</em><sub>−</sub>⟩</span> 为 <span class="math display">$$\left|\chi_{ \pm}\right\rangle=\frac{1}{\sqrt{2}}(|1\rangle\pm|2\rangle)$$</span></p><p>上式积分后得到 <span class="math display">$$C_{ \pm}(t)=C_{ \pm}(0) \mathrm{e}^{-\frac{i E_{ \pm} t}{h}}$$</span></p><p>式中，<span class="math inline"><em>C</em><sub>±</sub>(0)</span>是由初始条件决定的积分常量。<br>由 <span class="math inline">$C_{ \pm}=\frac{1}{\sqrt{2}}\left(C_{1} \pmC_{2}\right)$</span> 解得 <span class="math display">$$\begin{aligned}C_{1}(t) &amp;=\frac{1}{\sqrt{2}}\left[C_{+}(t)+C_{-}(t)\right] \\&amp;=\frac{1}{\sqrt{2}}\left[C_{+}(0) \mathrm{e}^{-\mathrm{i}\frac{E_{+} t}{h}}+C_{-}(0) \mathrm{e}^{-i \frac{E_{-} t}{h}}\right] \\C_{2}(t) &amp;=\frac{1}{\sqrt{2}}\left[C_{+}(t)-C_{-}(t)\right] \\&amp;=\frac{1}{\sqrt{2}}\left[C_{+}(0) \mathrm{e}^{-\mathrm{i}\frac{E_{+} t}{h}}-C_{-}(0) \mathrm{e}^{-i \frac{E_{-} t}{h}}\right]\end{aligned}$$</span></p><p>由上面各式可以看出，<span class="math inline"><em>C</em><sub>±</sub></span>是定态的概率幅，其模方不变。如果 <span class="math inline"><em>C</em><sub>−</sub>(0) = 0</span>，氨分子“ <span class="math inline"><em>L</em></span> ”或“ <span class="math inline"><em>R</em></span>”的两个状态具有相同的振幅，则氨分子具有确定的能量 <span class="math inline"><em>E</em><sub>+</sub> = <em>E</em><sub>0</sub> + <em>A</em></span>。如果初始系统处于<span class="math inline">|1⟩</span> 态，即 <span class="math display">$$\begin{aligned}C_{1}(0)&amp;=\frac{1}{\sqrt{2}}\left[C_{+}(0)+C_{-}(0)\right]=1 \\C_{2}(0)&amp;=\frac{1}{\sqrt{2}}\left[C_{+}(0)-C_{-}(0)\right]=0\end{aligned}$$</span></p><p>由此得 <span class="math display">$$C_{+}(0)=C_{-}(0)=\frac{1}{\sqrt{2}}$$</span></p><p>于是本征态 <span class="math display">$$\begin{aligned}C_{1}(t)=\mathrm{e}^{-\frac{E_{0} t}{\hbar}} \cos \frac{A t}{\hbar} \\C_{2}(t)=-\mathrm{ie}^{-\frac{E_{0} t}{\hbar}} \sin \frac{A t}{\hbar}\end{aligned}$$</span></p><p>两振幅随时间做简谐变化。它们的模方是系统分别处于态 <span class="math inline">|1⟩</span> 和 <span class="math inline">|2⟩</span>的概率。由于 <span class="math inline"><em>C</em><sub>1</sub>(<em>t</em>)</span> 和 <span class="math inline"><em>C</em><sub>2</sub>(<em>t</em>)</span>的模方随时间变化，氨分子处于两个状态的概率是时间相关的。 <span class="math display">$$\begin{aligned}P_{1}(t) &amp;=\left|C_{1}(t)\right|^{2}=\cos ^{2} \frac{A t}{\hbar}\\P_{2}(t) &amp;=\left|C_{2}(t)\right|^{2}=\sin ^{2} \frac{A t}{\hbar}\end{aligned}$$</span></p>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>量子力学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息论基础</title>
    <link href="/posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/"/>
    <url>/posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>唐俊华老师</em> 2024-2025学年春季学期教学内容进行整理，部分图片来自唐教授的笔记，若有侵权请联系删除。</p></blockquote><h1 id="第一章-绪论">第一章 绪论</h1><h2 id="信息理论研究内容">信息理论研究内容</h2><ul><li>狭义信息论：香农信息论</li><li>一般信息论：香农+维纳</li><li>广义信息论</li></ul><h2 id="信息消息信号">信息、消息、信号</h2><ul><li><strong>信息</strong>：指各个事物运动的状态及状态变化的方式。信息是抽象的意识或知识，它是看不见、摸不到的。当由人脑的思维活动产生的一种想法仍被存储在脑子里时，它就是一种信息。<ul><li>特征：<ol type="1"><li>接收者在收到信息之前，对其内容是未知的，所以信息是新知识、新内容；</li><li>信息是能使认识主体对某一事物的未知性或不确定性减少的有用知识；</li><li>信息可以产生，也可以消失，同时信息可以被携带、存储及处理；</li><li>信息是可以量度的，信息量有多少的差别。</li></ol></li></ul></li><li><strong>消息</strong>：指包含信息的语言、文字和图像等。在通信中，消息是指担负着传送信息任务的单个符号或符号序列。这些符号包括字母、文字、数字和语言等。</li><li><strong>信号</strong>：消息的物理体现，为了在信道上传输消息，就必须把消息加载（调制）到具有某种物理特征的信号上去。信号是信息的载荷子或载体，是物理性的，如电信号、光信号等。</li></ul><h2 id="通信系统模型">通信系统模型</h2><figure><img src="image.png" srcset="/img/loading/loading3.gif" lazyload alt="通信系统模型"><figcaption aria-hidden="true">通信系统模型</figcaption></figure><h1 id="第二章-信源与信息熵">第二章 信源与信息熵</h1><h2 id="信源的分类及数学模型">2.1 信源的分类及数学模型</h2><figure><img src="image-1.png" srcset="/img/loading/loading3.gif" lazyload alt="信源分类"><figcaption aria-hidden="true">信源分类</figcaption></figure><h3 id="无记忆的单符号">无记忆的单符号</h3><ul><li><strong>离散</strong><ul><li><p>信源输出单个符号的消息，出现的消息数是有限的，且只可能是符号集中的一种</p></li><li><p>各符号出现的概率与信源相互确定</p></li><li><p><strong>数学表示</strong>： <span class="math display">$$  \begin{bmatrix} X \\ P \end{bmatrix} =  \begin{bmatrix} a_1 &amp; a_2 &amp; \cdots &amp; a_n \\ p(a_1) &amp;p(a_2) &amp; \cdots &amp; p(a_n) \end{bmatrix}  $$</span></p><p>其中符号集 <span class="math inline"><em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span>，<span class="math inline"><em>X</em> ∈ <em>A</em></span>。显然有 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>) ≥ 0</span>，<span class="math inline">$\sum_{i = 1}^{n} p(a_i) = 1$</span>。</p></li></ul></li><li><strong>连续</strong><ul><li><p>信源输出单个符号的消息，出现的消息数是无限的</p></li><li><p><strong>数学表示</strong>： <span class="math display">$$  \begin{bmatrix} X \\ P \end{bmatrix} =  \begin{bmatrix} (a,b) \\ p_X(x) \end{bmatrix}  或  \begin{bmatrix} R \\p_X(x) \end{bmatrix}  $$</span></p><p>显然应满足 <span class="math inline"><em>p</em><sub><em>X</em></sub>(<em>x</em>) ≥ 0</span>，<span class="math inline">∫<sub><em>a</em></sub><sup><em>b</em></sup><em>p</em><sub><em>X</em></sub>(<em>x</em>)d<em>x</em> = 1</span>或 <span class="math inline">∫<sub><em>R</em></sub><em>p</em><sub><em>X</em></sub>(<em>x</em>)d<em>x</em> = 1</span>。</p></li></ul></li></ul><h3 id="无记忆的符号序列">无记忆的符号序列</h3><ul><li><p>每次发出一组含2个以上符号的符号序列来代表一个消息</p></li><li><p>需要用随机序列（或随机矢量）<span class="math inline"><strong>X</strong> = (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>l</em></sub>, ⋯, <em>X</em><sub><em>L</em></sub>)</span>来描述信源输出的消息，用联合概率分布来表示信源特性。</p></li><li><p>最简单的符号序列信源是<span class="math inline"><em>L</em></span>为2的情况，此时信源<span class="math inline"><strong>X</strong> = (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>)</span>，其信源的概率空间为：<span class="math display">$$  \begin{bmatrix} \mathbf{X} \\ P \end{bmatrix} =  \begin{bmatrix} a_1,a_1 &amp; a_1,a_2 &amp; \cdots &amp; a_n,a_n \\p(a_1,a_1) &amp; p(a_1,a_2) &amp; \cdots &amp; p(a_n,a_n) \end{bmatrix}\quad  $$</span></p><p>显然有 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>a</em><sub><em>j</em></sub>) ≥ 0</span>，<span class="math inline">$\sum_{i,j = 1}^{n} p(a_i,a_j) =1$</span>。</p></li><li><p><strong><em>无记忆</em></strong></p><ul><li>符号序列的各维相独立（<strong>有放回取球</strong>）</li><li><span class="math inline"><em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>l</em></sub>, ⋯, <em>X</em><sub><em>L</em></sub>) = <em>p</em>(<em>X</em><sub>1</sub>)<em>p</em>(<em>X</em><sub>2</sub>)⋯<em>p</em>(<em>X</em><sub><em>l</em></sub>)⋯<em>p</em>(<em>X</em><sub><em>L</em></sub>)</span></li></ul></li><li><p><strong><em>平稳</em></strong></p><ul><li>信源发出的序列的统计性质与时间的推移无关，是平稳的随机序列。</li><li>强：信源输出序列的各维概率分布都不随时间推移而发生变化</li><li>弱：信源输出序列的均值与起始时刻无关、协方差函数也与起始时刻无关而仅与时间间隔有关</li></ul></li><li><p><strong><em>独立同分布(i.i.d.)</em></strong></p><ul><li>离散、平稳、无记忆、具有相同概率空间</li><li><span class="math inline"><em>p</em>(<em>X</em><sub>1</sub>) = <em>p</em>(<em>X</em><sub>2</sub>) = ⋯ = <em>p</em>(<em>X</em><sub><em>l</em></sub>) = ⋯ = <em>p</em>(<em>X</em><sub><em>L</em></sub>)</span></li><li><span class="math inline">$p(X_1,X_2,\cdots,X_L)=\prod_{l =1}^{L}p(X_l)=[p(X)]^L$</span></li><li>其中 <span class="math inline"><em>X</em> ∈ <em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span>，<span class="math inline"><strong>X</strong></span>有<span class="math inline"><em>n</em><sup><em>L</em></sup></span>种可能性，<span class="math inline">$\sum_{i = 1}^{n^L} p(\mathbf{X}=\mathbf{X_i}) =1$</span>。</li></ul></li></ul><h3 id="有记忆的符号序列">有记忆的符号序列</h3><ul><li>信源在不同时刻发出的符号之间是相互依赖的。（<strong>不放回取球</strong>）<span class="math display">$$  \begin{align*}  p(x_1,x_2,x_3,\cdots,x_L)&amp;=p(x_L\mid x_1,x_2,x_3,\cdots,x_{L -1})p(x_1,x_2,x_3,\cdots,x_{L - 1})\\  &amp;=\cdots\\  &amp;=p(x_1)p(x_2|x_1)p(x_3|x_2,x_1)\cdots p(x_L|x_{L-1},\cdots, x_1)  \end{align*}  $$</span></li><li>表述的复杂度将随着序列长度的增加而增加。</li></ul><h4 id="马尔可夫信源">马尔可夫信源</h4><ul><li><strong>m阶马尔可夫信源</strong><ul><li>当信源的记忆长度为<span class="math inline"><em>m</em> + 1</span>时，该时刻发出的符号与前m个符号有关联性，而与更前面的符号无关<span class="math display">$$  \begin{align*}  p(x_1,x_2,x_3,\cdots,x_L)&amp;=p(x_L\mid x_1,x_2,x_3,\cdots,x_{L -1})p(x_1,x_2,x_3,\cdots,x_{L - 1})\\  &amp;=p(x_L\mid x_{L - m},\cdots,x_{L - 1})p(x_1,x_2,x_3,\cdots,x_{L -1})\\  &amp;=p(x_L\mid x_{L - m},\cdots,x_{L - 1})p(x_{L - 1}\mid x_{L - m -1},\cdots,x_{L - 2})p(x_1,x_2,x_3,\cdots,x_{L - 2})\\  &amp;=\cdots  \end{align*}  $$</span></li><li>若<span class="math inline"><em>m</em> = 1</span>，则称为<strong>一阶马尔可夫信源</strong>，有：<span class="math display"><em>p</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, <em>x</em><sub>3</sub>, ⋯, <em>x</em><sub><em>L</em></sub>) = <em>p</em>(<em>x</em><sub><em>L</em></sub> ∣ <em>x</em><sub><em>L</em> − 1</sub>)<em>p</em>(<em>x</em><sub><em>L</em> − 1</sub> ∣ <em>x</em><sub><em>L</em> − 2</sub>)⋯<em>p</em>(<em>x</em><sub>2</sub> ∣ <em>x</em><sub>1</sub>)<em>p</em>(<em>x</em><sub>1</sub>)</span></li><li><strong>齐次马尔可夫信源</strong>：条件概率与时间起点无关</li></ul></li><li><strong>状态<span class="math inline"><em>s</em><sub><em>i</em></sub></span></strong><ul><li>对于 <span class="math inline"><em>m</em></span>阶马尔可夫信源，将该时刻以前出现的 <span class="math inline"><em>m</em></span> 个符号组成的序列定义为状态 <span class="math inline"><em>s</em><sub><em>i</em></sub></span></li><li><span class="math inline"><em>s</em><sub><em>i</em></sub> = (<em>x</em><sub><em>i</em><sub>1</sub></sub>, <em>x</em><sub><em>i</em><sub>2</sub></sub>, ⋯, <em>x</em><sub><em>i</em><sub><em>m</em></sub></sub>)  <em>x</em><sub><em>i</em><sub>1</sub></sub>, <em>x</em><sub><em>i</em><sub>2</sub></sub>, ⋯, <em>x</em><sub><em>i</em><sub><em>m</em></sub></sub> ∈ <em>A</em> = (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>)</span></li><li><span class="math inline"><em>s</em><sub><em>i</em></sub></span>共有 <span class="math inline"><em>Q</em> = <em>n</em><sup><em>m</em></sup></span>种可能取值，即状态集 <span class="math inline"><em>S</em> = {<em>s</em><sub>1</sub>, <em>s</em><sub>2</sub>, ⋯, <em>s</em><sub><em>Q</em></sub>}</span></li><li>则有： <span class="math display"><em>p</em>(<em>x</em><sub><em>j</em></sub> ∣ <em>x</em><sub><em>j</em> − <em>m</em></sub>, ⋯, <em>x</em><sub><em>j</em> − 1</sub>) = <em>p</em>(<em>x</em><sub><em>j</em></sub> ∣ <em>s</em><sub><em>i</em></sub>)  <em>i</em> = 1, 2, ⋯, <em>Q</em>, <em>j</em> = 1, 2, ⋯, <em>n</em></span></li></ul></li><li><strong>状态转移概率</strong><ul><li>在时刻 <span class="math inline"><em>m</em></span> 系统处于状态<span class="math inline"><em>s</em><sub><em>i</em></sub></span>（即<span class="math inline"><em>S</em><sub><em>m</em></sub> = <em>s</em><sub><em>i</em></sub></span>）的条件下，经<span class="math inline"><em>n</em> − <em>m</em></span> 步后转移到状态<span class="math inline"><em>s</em><sub><em>j</em></sub></span> （即<span class="math inline"><em>S</em><sub><em>n</em></sub> = <em>s</em><sub><em>j</em></sub></span>）的概率用状态转移概率<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>m</em>, <em>n</em>)</span>表示：</li><li><span class="math display"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>m</em>, <em>n</em>) = <em>P</em>{<em>S</em><sub><em>n</em></sub> = <em>s</em><sub><em>j</em></sub> ∣ <em>S</em><sub><em>m</em></sub> = <em>s</em><sub><em>i</em></sub>} = <em>P</em>{<em>s</em><sub><em>j</em></sub> ∣ <em>s</em><sub><em>i</em></sub>}  <em>s</em><sub><em>i</em></sub>, <em>s</em><sub><em>j</em></sub> ∈ <em>S</em></span></li><li>性质：<ol type="1"><li><span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>m</em>, <em>n</em>) ≥ 0</span>，<span class="math inline"><em>i</em>, <em>j</em> ∈ <em>S</em></span></li><li><span class="math inline">∑<sub><em>j</em> ∈ <em>S</em></sub><em>p</em><sub><em>i</em><em>j</em></sub>(<em>m</em>, <em>n</em>) = 1</span>，<span class="math inline"><em>i</em> ∈ <em>S</em></span></li></ol></li></ul></li><li><strong>状态转移矩阵</strong><ul><li>一步转移矩阵<span class="math inline"><strong>P</strong> = {<em>p</em><sub><em>i</em><em>j</em></sub>, <em>i</em>, <em>j</em> ∈ <em>S</em>}</span><span class="math display">$$  \mathbf{P}=  \begin{bmatrix}  p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1Q} \\  p_{21} &amp; p_{22} &amp; \cdots &amp; p_{2Q} \\  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  p_{Q1} &amp; p_{Q2} &amp; \cdots &amp; p_{QQ}  \end{bmatrix}  $$</span></li><li>k步转移矩阵<span class="math inline"><strong>P</strong> = {<em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup>(<em>m</em>), <em>i</em>, <em>j</em> ∈ <em>S</em>}</span></li></ul></li><li><strong>状态图</strong><ul><li>状态转移图/马尔科夫状态图/香农线图</li><li>元素<ul><li>圆圈：状态<span class="math inline"><em>S</em><sub><em>i</em></sub></span></li><li>箭头：转移</li><li>箭头旁标数字：转移概率</li></ul></li></ul></li><li><strong>一步转移概率</strong><ul><li><span class="math inline"><em>n</em> − <em>m</em> = 1</span>时，即<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>t</em>, <em>t</em> + 1)</span>，记为<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub>(<em>t</em>)</span>，<span class="math inline"><em>t</em> ≥ 0</span>，并称为基本转移概率，也可称为一步转移概率。</li><li><span class="math display">$$  p_{ij}(t)=p_{ij}(t,t + 1)=P\{S_{t + 1}=j\mid S_t =i\}\overset{齐次}{=}p_{ij}\quad i,j\in S  $$</span></li><li>性质：<ol type="1"><li><span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub> ≥ 0</span>，<span class="math inline"><em>i</em>, <em>j</em> ∈ <em>S</em></span></li><li><span class="math inline">∑<sub><em>j</em> ∈ <em>S</em></sub><em>p</em><sub><em>i</em><em>j</em></sub> = 1</span>，<span class="math inline"><em>i</em> ∈ <em>S</em></span></li></ol></li></ul></li><li><strong>k步转移概率</strong><ul><li><p><span class="math display">$$  p_{ij}^{(k)}(t)=p_{ij}(t,t + k)=P\{S_{t + k}=j\mid S_t =i\}\overset{齐次}{=}p_{ij}^{(k)}\quad i,j\in S  $$</span></p></li><li><p>切普曼 - 柯尔莫戈洛夫方程： <span class="math display"><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = ∑<sub><em>r</em></sub><em>p</em><sub><em>i</em><em>r</em></sub><sup>(<em>l</em>)</sup><em>p</em><sub><em>r</em><em>j</em></sub><sup>(<em>k</em> − <em>l</em>)</sup>  <em>l</em> &lt; <em>k</em></span></p><p>特别地，当 <span class="math inline"><em>l</em> = 1</span> 时，有<span class="math display"><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = ∑<sub><em>r</em></sub><em>p</em><sub><em>i</em><em>r</em></sub><em>p</em><sub><em>r</em><em>j</em></sub><sup>(<em>k</em> − 1)</sup> = ∑<sub><em>r</em></sub><em>p</em><sub><em>i</em><em>r</em></sub><sup>(<em>k</em> − 1)</sup><em>p</em><sub><em>r</em><em>j</em></sub> = <em>p</em><sub><em>i</em><em>j</em></sub><sup><em>k</em></sup></span></p></li><li><p>若用矩阵表示，则 <span class="math display"><strong>P</strong><sup>(<em>k</em>)</sup> = <strong>P</strong><strong>P</strong><sup>(<em>k</em> − 1)</sup> = <strong>P</strong><strong>P</strong><strong>P</strong><sup>(<em>k</em> − 2)</sup> = ⋯ = <strong>P</strong><sup><em>k</em></sup></span></p><p>其中 <span class="math inline"><strong>P</strong><sup>(<em>k</em>)</sup> = {<em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup>}</span>为k步转移概率矩阵，<span class="math inline"><strong>P</strong><sup><em>k</em></sup></span>为一步转移矩阵的k次方。</p></li><li><p>对于齐次马尔可夫链，一步转移概率完全决定了k步转移概率，引入初始概率<span class="math inline"><em>p</em><sub>0<em>i</em></sub> = <em>P</em>(<em>S</em><sub>0</sub> = <em>s</em><sub><em>i</em></sub>)</span><span class="math display">$$  \begin{align*}  P(S_{k}=s_{j})&amp;=\sum_{i}P(S_{k}=s_{j},S_{0}=s_{i})\\  &amp;=\sum_{i}P(S_{0}=s_{i})P(S_{k}=s_{j}\mid S_{0}=s_{i})\\  &amp;=\sum_{i}p_{0i}p_{ij}^{(k)}  \end{align*}  $$</span></p></li></ul></li><li><strong>马尔可夫链的稳定(稳态分布)</strong><ul><li><p><strong>定义</strong>：<span class="math inline">lim<sub><em>k</em> → ∞</sub><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = <em>W</em><sub><em>j</em></sub> = <em>P</em>(<em>S</em><sub><em>k</em></sub> = <em>s</em><sub><em>j</em></sub>)</span>，信源达到稳定状态，所有变量<span class="math inline"><em>x</em><sub><em>k</em></sub></span>的概率分布不变</p></li><li><p><strong>求取</strong>： <span class="math display">$$  \left\{  \begin{array}{l}  \mathbb{W}\mathbf{P}=\mathbb{W}\\  \sum_{i}W_j = 1  \end{array}  \right.  $$</span></p><p>其中<span class="math inline">$\mathbb{W}=\begin{bmatrix} W_1 &amp;W_2 &amp; \cdots &amp; W_Q \end{bmatrix}$</span>，<span class="math inline"><em>W</em><sub><em>j</em></sub> = lim<sub><em>k</em> → ∞</sub><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = <em>P</em>(<em>S</em><sub><em>k</em></sub> = <em>s</em><sub><em>j</em></sub>)</span></p></li><li><p><strong>条件</strong></p><ul><li>必要不充分：上式有唯一解，则<span class="math inline">lim<sub><em>k</em> → ∞</sub><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup></span>存在</li><li><strong>不可约性</strong><ul><li>对任意一对 <span class="math inline"><em>i</em></span> 和 <span class="math inline"><em>j</em></span>，都存在至少一个 <span class="math inline"><em>k</em></span>，使 <span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> &gt; 0</span>，这就是说从<span class="math inline"><em>s</em><sub><em>i</em></sub></span>开始，总有可能到达 <span class="math inline"><em>s</em><sub><em>j</em></sub></span></li><li>反之若对所有 <span class="math inline"><em>k</em></span>，<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub><sup>(<em>k</em>)</sup> = 0</span>，就意味着一旦出现<span class="math inline"><em>s</em><sub><em>i</em></sub></span>以后不可能到达 <span class="math inline"><em>s</em><sub><em>j</em></sub></span>，也就是不能各态遍历<ul><li>此时状态中把 <span class="math inline"><em>s</em><sub><em>j</em></sub></span>取消就成为可约的了</li></ul></li></ul></li><li><strong>非周期性</strong><ul><li>在所有 <span class="math inline"><em>p</em><sub><em>i</em><em>i</em></sub><sup>(<em>n</em>)</sup> &gt; 0</span>的 <span class="math inline"><em>n</em></span> 中没有比 1大的公因子，即从<span class="math inline"><em>s</em><sub><em>i</em></sub></span>出发回到<span class="math inline"><em>s</em><sub><em>i</em></sub></span>的步数没有大于1 的公因子</li></ul></li></ul></li><li><p><strong>例题</strong>：</p><ul><li><figure><img src="image-104.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li><li><figure><img src="image-105.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li><li><figure><img src="image-106.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li></ul></li></ul></li></ul><h3 id="时间连续幅度连续的模拟信号随机波形信源">时间连续、幅度连续的模拟信号（随机波形信源）</h3><ul><li>例如语音、图像，可看作随机过程<span class="math inline"><em>x</em>(<em>t</em>)</span> 。</li><li>通过采样、量化，可将其转换为时间离散、幅度离散的符号序列。</li><li>假设<span class="math inline"><em>x</em>(<em>t</em>)</span>频带受限，<span class="math inline"><em>f</em><sub><em>m</em></sub></span>为最高频率，根据采样定理，<strong>不失真采样频率</strong><span class="math inline"><em>f</em><sub><em>s</em></sub> ≥ 2<em>f</em><sub><em>m</em></sub></span>。若时间受限为<span class="math inline"><em>t</em><sub><em>B</em></sub></span>，则<strong>采样点数</strong>为<span class="math inline">2<em>f</em><sub><em>m</em></sub><em>t</em><sub><em>B</em></sub> = <em>L</em></span>（形成长度为<span class="math inline"><em>L</em></span>的符号序列）。</li><li>一般情况下，<span class="math inline"><em>L</em> = 2<em>f</em><sub><em>m</em></sub><em>t</em><sub><em>B</em></sub></span>维连续型随机序列是有记忆的。</li></ul><h2 id="离散信源熵和互信息">2.2 离散信源熵和互信息</h2><h3 id="自信息量">自信息量</h3><ul><li><p>信源 <span class="math inline"><em>X</em></span>，概率空间 <span class="math display">$$\begin{bmatrix} X \\ p \end{bmatrix}=\begin{bmatrix} x_1 &amp; x_2 &amp; \cdots &amp; x_n \\ p(x_1) &amp;p(x_2) &amp; \cdots &amp; p(x_n) \end{bmatrix}$$</span></p></li><li><p>定义具有概率 <span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>的符号 <span class="math inline"><em>x</em><sub><em>i</em></sub></span>的自信息量为 <span class="math display">$$I(x_i)=-\logp(x_i)=\log\frac{1}{p(x_i)}$$</span></p><ul><li>底数为 <span class="math inline">2</span>，信息量单位比特（bit）</li><li>底数为自然常数 <span class="math inline"><em>e</em></span>，单位为奈特（nat）</li><li>底数为 <span class="math inline">10</span>，单位为笛特（det）<ul><li><span class="math inline">1nat = log<sub>2</sub><em>e</em> ≈ 1.433bit</span></li><li><span class="math inline">1det = log<sub>2</sub>10 ≈ 3.322bit</span></li></ul></li><li>性质：<ol type="1"><li><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = 1</span>，<span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>) = 0</span></li><li><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = 0</span>，<span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>) = ∞</span></li><li>非负性：<span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>) ≥ 0</span></li><li>单调递减性：若 <span class="math inline"><em>p</em>(<em>x</em><sub>2</sub>) &gt; <em>p</em>(<em>x</em><sub>1</sub>)</span>则 <span class="math inline"><em>I</em>(<em>x</em><sub>2</sub>) &lt; <em>I</em>(<em>x</em><sub>1</sub>)</span></li><li>可加性：<ul><li>两符号 <span class="math inline"><em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub></span>同时出现，<span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = −log <em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span></li><li><span class="math inline"><em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub></span>相互独立，<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = <em>p</em>(<em>x</em><sub><em>i</em></sub>)<em>p</em>(<em>y</em><sub><em>j</em></sub>)</span><ul><li><span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = −log <em>p</em>(<em>x</em><sub><em>i</em></sub>)<em>p</em>(<em>y</em><sub><em>j</em></sub>) = <em>I</em>(<em>x</em><sub><em>i</em></sub>) + <em>I</em>(<em>y</em><sub><em>j</em></sub>)</span></li></ul></li><li><span class="math inline"><em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub></span>不独立，定义<strong>条件自信息量</strong> <span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>) = −log <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span><ul><li><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = <em>p</em>(<em>x</em><sub><em>i</em></sub>)<em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = <em>p</em>(<em>y</em><sub><em>j</em></sub>)<em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span></li><li><span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = <em>I</em>(<em>x</em><sub><em>i</em></sub>) + <em>I</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = <em>I</em>(<em>y</em><sub><em>j</em></sub>) + <em>I</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span></li></ul></li></ul></li></ol></li><li>单位：bit</li></ul></li><li><p>示例：<img src="image-107.png" srcset="/img/loading/loading3.gif" lazyload alt="示例"></p></li><li><p><strong>自信息量与信源符号不确定度</strong></p><ul><li>自信息量：符号出现后，提供给收信者的信息量，<strong>是接收者获得的</strong>。</li><li>信源符号不确定度：具有某种概率的信源符号在发出之前，存在不确定度，不确定度表征了该符号的特性，<strong>是信源本身固有的</strong>。</li><li><strong>二者在数量上相等</strong></li></ul></li></ul><h3 id="离散信源熵---熵的定义">离散信源熵 - 熵的定义</h3><ul><li><p>给定概率空间 <span class="math inline">$\begin{bmatrix} X \\ p\end{bmatrix}=\begin{bmatrix} x_1 &amp; x_2 &amp; \cdots &amp; x_n \\ p(x_1) &amp;p(x_2) &amp; \cdots &amp; p(x_n) \end{bmatrix}$</span>，自信息量<span class="math inline">$I(x_i)=-\logp(x_i)=\log\frac{1}{p(x_i)}$</span></p></li><li><p><strong>信源 <span class="math inline"><em>X</em></span> 的熵<span class="math inline"><em>H</em>(<em>X</em>)</span>定义为</strong>： <span class="math display">$$H(X)\overset{数量}{=}E[I(X)]=\sum_{i}p(x_i)I(x_i)=-\sum_{i} p(x_i)\log p(x_i)$$</span> 信源 <span class="math inline"><em>X</em></span>的熵也被称为平均自信息量、总体平均不确定度。</p></li><li><p>性质：</p><ul><li><span class="math inline"><em>H</em>(<em>X</em>)</span> 非负，因为<span class="math inline">0 ≤ <em>p</em>(<em>x</em><sub><em>i</em></sub>) ≤ 1</span>，<span class="math inline">log <em>p</em>(<em>x</em><sub><em>i</em></sub>) ≤ 0</span>，所以<span class="math inline"><em>H</em>(<em>X</em>) ≥ 0</span>。</li><li>若 <span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = 0</span>，规定<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)log <em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>为 <span class="math inline">0</span>。</li><li>若 <span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = 1</span>，<span class="math inline"><em>H</em>(<em>X</em>) = 0</span>，即确定信源熵为<span class="math inline">0</span>。</li></ul></li><li><p>单位：bit/符号</p></li><li><p>例题：<img src="image-109.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h4 id="二元信源">二元信源</h4><ul><li>二元信源概率空间 <span class="math inline">$\begin{bmatrix} X \\ p\end{bmatrix}=\begin{bmatrix} 0 &amp; 1 \\ p &amp; q \end{bmatrix}$</span>，其中 <span class="math inline"><em>p</em> + <em>q</em> = 1</span></li><li>则 <span class="math inline"><em>H</em>(<em>X</em>) = −<em>p</em>log <em>p</em> − <em>q</em>log <em>q</em> = −<em>p</em>log <em>p</em> − (1 − <em>p</em>)log (1 − <em>p</em>) = <em>H</em><sub>2</sub>(<em>p</em>) = <em>H</em>(<em>p</em>)</span></li><li><figure><img src="image-108.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li>性质：<ul><li>当 <span class="math inline"><em>p</em> = 1</span> 或 <span class="math inline"><em>q</em> = 1</span>（<span class="math inline"><em>p</em> = 0</span>）时，该信源不提供任何信息，即H(0)=0。</li><li>当 <span class="math inline">$p=q=\frac{1}{2}$</span>时，符号等概率发生，熵最大，为 <span class="math inline">$H(\frac{1}{2})=1\text{bit}/\text{符号}$</span>。</li></ul></li></ul><h3 id="条件熵">条件熵</h3><ul><li><p>给定 <span class="math inline"><em>y</em><sub><em>j</em></sub></span>的条件下，<span class="math inline"><em>x</em><sub><em>i</em></sub></span>的<strong>条件自信息量</strong>为 <span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>) = −log <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span>，<strong><span class="math inline"><em>X</em></span> 集合的条件熵 <span class="math inline"><em>H</em>(<em>X</em>|<em>y</em><sub><em>j</em></sub>)</span>定义为</strong>：<span class="math display"><em>H</em>(<em>X</em>|<em>y</em><sub><em>j</em></sub>) = ∑<sub><em>i</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)<em>I</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span></p></li><li><p>给定 <span class="math inline"><em>Y</em></span>（即各个 <span class="math inline"><em>y</em><sub><em>j</em></sub></span>）条件下，<strong><span class="math inline"><em>X</em></span> 集合的条件熵 <span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span>定义为</strong>： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) = −∑<sub><em>i</em><em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)log <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span>即条件熵是联合符号集合 <span class="math inline">(<em>X</em>, <em>Y</em>)</span>上的条件自信息量的<strong>联合概率加权统计平均值</strong>。条件熵 <span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span> 表示已知<span class="math inline"><em>Y</em></span> 后，<span class="math inline"><em>X</em></span> 的不确定度。</p></li><li><p>推导： <span class="math display">$$  \begin{align*}  H(X|Y)&amp;=\sum_{j}p(y_j)H(X|y_j)\\  &amp;=\sum_{j}p(y_j)\sum_{i}p(x_i|y_j)I(x_i|y_j)\\  &amp;=\sum_{i}\sum_{j}p(y_j)p(x_i|y_j)I(x_i|y_j)\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)I(x_i|y_j)\\  &amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log p(x_i|y_j)  \end{align*}  $$</span></p></li><li><p><strong>同理</strong>，<span class="math display"><em>H</em>(<em>Y</em>|<em>X</em>) = ∑<sub><em>i</em></sub>∑<sub><em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)<em>I</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = −∑<sub><em>i</em></sub>∑<sub><em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)log <em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span></p></li></ul><h3 id="联合熵">联合熵</h3><ul><li>联合熵是联合符号集合 <span class="math inline">(<em>X</em>, <em>Y</em>)</span> 上的每个元素对 <span class="math inline">(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span>的自信息量的<strong>概率加权统计平均值</strong>，定义为：</li></ul><p><span class="math display"><em>H</em>(<em>X</em>, <em>Y</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)<em>I</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = −∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)log <em>p</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span></p><ul><li>联合熵 <span class="math inline"><em>H</em>(<em>X</em>, <em>Y</em>)</span> 表示 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span> 同时发生的不确定度。</li><li>联合熵 <span class="math inline"><em>H</em>(<em>X</em>, <em>Y</em>)</span> 与熵 <span class="math inline"><em>H</em>(<em>X</em>)</span> 及条件熵 <span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>)</span>之间存在下列<strong>关系</strong>： <span class="math display"><em>H</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>Y</em>) + <em>H</em>(<em>X</em>|<em>Y</em>)</span><ul><li>推导： <span class="math display">$$  \begin{align*}  H(X,Y)&amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log p(x_i,y_j)\\  &amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log [p(x_i)p(y_j|x_i)]\\  &amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\logp(x_i)-\sum_{i}\sum_{j}p(x_i,y_j)\log p(y_j|x_i)\\  &amp;=-\sum_{i}p(x_i)\log p(x_i)+H(Y|X)\\  &amp;=H(X)+H(Y|X)  \end{align*}  $$</span></li><li>同理可得 <span class="math inline"><em>H</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>Y</em>) + <em>H</em>(<em>X</em>|<em>Y</em>)</span></li></ul></li><li>例题：<img src="image-110.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h3 id="互信息">互信息</h3><ul><li><p>未收到消息时，信源 <span class="math inline"><em>X</em></span>的不确定度为 <span class="math inline"><em>H</em>(<em>X</em>)</span>，收到消息 <span class="math inline"><em>Y</em></span> 后关于 <span class="math inline"><em>x</em><sub><em>i</em></sub></span> 的不确定度为<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span>。<img src="image-111.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"></p></li><li><p><strong>定义</strong>：</p><ul><li><span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span>的互信息为接收者通过通信信道接收到的信源 <span class="math inline"><em>X</em></span> 的信息量</li><li><strong>平均互信息</strong>：<span class="math display">$$I(X;Y)=H(X)-H(X|Y)=\sum_{ij}p(x_i,y_j)\log\frac{p(x_i,y_j)}{p(x_i)p(y_j)}$$</span></li></ul></li><li><p><strong>平均互信息的推导</strong></p><ul><li><p><strong>定义单符号之间的互信息</strong> <span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>; <em>y</em><sub><em>j</em></sub>)</span>为 <span class="math display">$$  \begin{align*}  I(x_i;y_j)&amp;=I(x_i)-I(x_i|y_j)\\  &amp;=\log\frac{1}{p(x_i)}-\log\frac{1}{p(x_i|y_j)}\\  &amp;=\log\frac{p(x_i|y_j)}{p(x_i)}=\log\frac{\text{后验概率}}{\text{先验概率}}  \end{align*}  $$</span></p></li><li><p>在 <span class="math inline"><em>X</em></span>集合上<strong>统计平均值，即平均条件互信息量</strong> <span class="math inline"><em>I</em>(<em>X</em>; <em>y</em><sub><em>j</em></sub>)</span>为 <span class="math display">$$  I(X;y_j)=\sum_{i}p(x_i|y_j)I(x_i;y_j)=\sum_{i}p(x_i|y_j)\log\frac{p(x_i|y_j)}{p(x_i)}  $$</span></p></li><li><p><span class="math inline"><em>I</em>(<em>X</em>; <em>y</em><sub><em>j</em></sub>)</span>在 <span class="math inline"><em>Y</em></span>集合的<strong>概率加权统计平均值，即平均互信息</strong> <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 为 <span class="math display">$$  \begin{align*}  I(X;Y)&amp;=\sum_{j}p(y_j)I(X;y_j)=\sum_{j}p(y_j)\sum_{i}p(x_i|y_j)\log\frac{p(x_i|y_j)}{p(x_i)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i|y_j)}{p(x_i)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\logp(x_i|y_j)-\sum_{i}\sum_{j}p(x_i,y_j)\log p(x_i)\\  &amp;=H(X)-H(X|Y)\\  I(X;Y)&amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i|y_j)}{p(x_i)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i|y_j)p(y_j)}{p(x_i)p(y_j)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i,y_j)}{p(x_i)p(y_j)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{p(y_j)}\\  &amp;=I(Y;X)\\  \therefore I(X;Y)&amp;=H(Y)-H(Y|X)=I(Y;X)=H(X)+H(Y)-H(X,Y)  \end{align*}  $$</span></p></li></ul></li><li><p><strong>例题</strong>：<img src="image-112.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li><li><p><strong>性质</strong>：</p><ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>I</em>(<em>Y</em>; <em>X</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>) − <em>H</em>(<em>X</em>, <em>Y</em>)</span><ul><li><figure><img src="image-2.png" srcset="/img/loading/loading3.gif" lazyload alt="H(X，Y)"><figcaption aria-hidden="true">H(X，Y)</figcaption></figure></li></ul></li><li><span class="math inline">0 ≤ <em>I</em>(<em>X</em>; <em>Y</em>) ≤ <em>H</em>(<em>X</em>)</span>（非负性证明见<a href="#互信息的非负性">互信息的非负性</a>）</li><li><strong>若<span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span>相互独立时</strong><ul><li><span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>X</em>)</span></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) = 0</span>，对应<strong>全损离散信道</strong></li></ul></li><li><strong>若<span class="math inline"><em>Y</em></span>是由<span class="math inline"><em>X</em></span>确定的一一对应函数</strong>，即<span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = 0或1</span><ul><li><span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Y</em>|<em>X</em>) = 0</span></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) = <em>H</em>(<em>Y</em>)</span>，对应<strong>无损信道</strong></li></ul></li><li><strong>一般情况下</strong>，<span class="math inline"><em>X</em></span>与<span class="math inline"><em>Y</em></span>既非相互独立，也不是一一对应 <span class="math display">$$  \begin{align*}  I(X;Y)&amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{p(y_j)}\\  &amp;=\sum_{i}\sum_{j}p(x_i)p(y_j|x_i)\log\frac{p(y_j|x_i)}{p(y_j)}\\  p(y_j)&amp;=\sum_{i}p(x_i)p(y_j|x_i)\\  I(X;Y)&amp;=f\left[p(x_i),p(y_j|x_i)\right]  \end{align*}  $$</span><ul><li><strong>结论</strong>：（证明见<a href="#互信息的凹凸性">互信息的凹凸性</a>）<ol type="1"><li><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>一定时，<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>是 <span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span>的<span class="math inline">∪</span>型凸函数，存在极小值。</li><li><span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span>一定时，<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>是关于<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>的<span class="math inline">∩</span>型凸函数，存在极大值。</li></ol></li></ul></li></ul></li><li><p><strong>收发两端的熵关系</strong></p><ul><li>条件熵 <span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span>又可以看作由于信道上的干扰和噪声，使接收端获得 <span class="math inline"><em>Y</em></span> 后还剩余的对信源符号 <span class="math inline"><em>X</em></span>的平均不确定度，故又称为<strong>疑义度</strong>。</li><li>条件熵 <span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>)</span>可看作唯一地确定信道噪声所需要的平均信量，故又称<strong>噪声熵或散布度</strong>。</li><li><figure><img src="image-3.png" srcset="/img/loading/loading3.gif" lazyload alt="收发两端熵关系"><figcaption aria-hidden="true">收发两端熵关系</figcaption></figure></li></ul></li></ul><h3 id="相对熵">相对熵</h3><ul><li><span class="math inline"><em>p</em>, <em>q</em></span>为同一信源两个不同的概率分布，<strong>相对熵<span class="math inline"><em>D</em>(<em>p</em>||<em>q</em>)</span>是两个随机分布之间距离的度量</strong>，<strong><span class="math inline"><em>p</em></span>相对于<span class="math inline"><em>q</em></span>的相对熵定义</strong>为： <span class="math display">$$D(p||q)=\sum_{i}p(x_{i})\log\frac{p(x_{i})}{q(x_{i})}$$</span></li><li>约定 <span class="math inline">$0\log\frac{0}{0} = 0$</span>，<span class="math inline">$0\log\frac{0}{q}=0$</span>，<span class="math inline">$p\log\frac{p}{0} = \infty$</span></li><li><strong>性质</strong>：<ul><li><p><span class="math inline"><em>D</em>(<em>p</em>||<em>q</em>) ≠ <em>D</em>(<em>q</em>||<em>p</em>)</span></p></li><li><p>互信息可定义为联合分布<span class="math inline"><em>p</em>(<em>x</em>, <em>y</em>)</span>与乘积分布<span class="math inline"><em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>)</span>之间的相对熵<span class="math display">$$I(X;Y)=\sum_{i,j}p(x_{i},y_{j})\log\frac{p(x_{i}|y_{j})}{p(x_{i})}=\sum_{i,j}p(x_{i},y_{j})\log\frac{p(x_{i},y_{j})}{p(x_{i})p(y_{j})}=D(p(x,y)||p(x)p(y))$$</span></p></li><li><p><span class="math inline"><em>D</em>(<em>p</em>||<em>q</em>) ≥ 0</span>（证明见<a href="#信息不等式相对熵的非负性">信息不等式/相对熵的非负性</a>）</p></li><li><p>信源符号 <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub></span>概率分布 <span class="math inline"><em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub></span>编码方案1：<span class="math inline">−log <em>p</em><sub>1</sub>, −log <em>p</em><sub>2</sub>, ⋯, −log <em>p</em><sub><em>n</em></sub></span>（按照码长 <span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>) = −log <em>p</em><sub><em>i</em></sub></span>进行编码） 编码方案2：<span class="math inline">−log <em>q</em><sub>1</sub>, −log <em>q</em><sub>2</sub>, ⋯, −log <em>q</em><sub><em>n</em></sub></span></p><p>编码1平均码长 <span class="math inline"><em>K</em><sub><em>p</em></sub> = −∑<sub><em>i</em></sub><em>p</em><sub><em>i</em></sub>log <em>p</em><sub><em>i</em></sub></span>编码2平均码长 <span class="math inline"><em>K</em><sub><em>q</em></sub> = −∑<sub><em>i</em></sub><em>p</em><sub><em>i</em></sub>log <em>q</em><sub><em>i</em></sub></span><span class="math display">$$K_q - K_p=\sum_{i}p_{i}\log\frac{p_{i}}{q_{i}}=D(p||q)\geq0$$</span></p><ul><li><strong>结论</strong>：按概率分布编码最短</li></ul></li></ul></li></ul><h3 id="熵相对熵与互信息的链式法则">熵、相对熵与互信息的链式法则</h3><h4 id="熵的链式法则">熵的链式法则</h4><ul><li><p><strong>熵的链式法则</strong>：</p><ul><li>设随机变量 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>服从 <span class="math inline"><em>p</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>)</span>，则<span class="math display">$$H(X_1,X_2,\cdots,X_n)=\sum_{i =1}^{n}H(X_i|X_{i - 1},\cdots,X_1)$$</span></li></ul></li><li><p><strong>证明</strong>：重复利用两个随机变量情形时熵的展开法则，有<span class="math display"><em>H</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>) = <em>H</em>(<em>X</em><sub>1</sub>) + <em>H</em>(<em>X</em><sub>2</sub>|<em>X</em><sub>1</sub>)</span><span class="math display">$$  \begin{align*}  H(X_1,X_2,X_3)&amp;=H(X_1)+H(X_2,X_3|X_1)\\  &amp;=H(X_1)+H(X_2|X_1)+H(X_3|X_2,X_1)  \end{align*}  $$</span><span class="math display">$$  \begin{align*}  H(X_1,X_2,\cdots,X_n)&amp;=H(X_1)+H(X_2|X_1)+\cdots +H(X_n|X_{n -1},\cdots,X_1)\\  &amp;=\sum_{i = 1}^{n}H(X_i|X_{i - 1},\cdots,X_1)  \end{align*}  $$</span></p></li><li><p><strong>另一证明</strong>：由 <span class="math inline">$p(x_1,x_2,\cdots,x_n)=\prod_{i = 1}^{n}p(x_i|x_{i -1},\cdots,x_1)$</span>，可得 <span class="math display">$$  \begin{align*}  &amp;H(X_1,X_2,\cdots,X_n)\\  =&amp;-\sum_{x_1,x_2,\cdots,x_n}p(x_1,x_2,\cdots,x_n)\logp(x_1,x_2,\cdots,x_n)\\  =&amp;-\sum_{x_1,x_2,\cdots,x_n}p(x_1,x_2,\cdots,x_n)\log\prod_{i =1}^{n}p(x_i|x_{i - 1},\cdots,x_1)\\  =&amp;-\sum_{x_1,x_2,\cdots,x_n}\sum_{i =1}^{n}p(x_1,x_2,\cdots,x_n)\log p(x_i|x_{i - 1},\cdots,x_1)\\  =&amp;-\sum_{i =1}^{n}\sum_{x_1,x_2,\cdots,x_n}p(x_1,x_2,\cdots,x_n)\log p(x_i|x_{i -1},\cdots,x_1)\\  =&amp;\sum_{i = 1}^{n}H(X_i|X_{i - 1},\cdots,X_1)\\  \end{align*}  $$</span></p></li></ul><h4 id="互信息的链式法则">互信息的链式法则</h4><ul><li><p><strong>条件互信息定义</strong>：</p><ul><li>随机变量 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span> 在给定随机变量 <span class="math inline"><em>Z</em></span> 时的条件互信息（conditional mutualinformation）定义为 <span class="math display">$$  \begin{align*}  I(X;Y|Z)&amp;=H(X|Z)-H(X|Y,Z)\\  &amp;=E_{p(x,y,z)}\log\frac{p(X,Y|Z)}{p(X|Z)p(Y|Z)}\\  &amp;=\sum_{i}\sum_{j}\sum_{k}p(x_i,y_j,z_k)\log\frac{p(x_i,y_j|z_k)}{p(x_i|z_k)p(y_j|z_k)}\\  &amp;=\sum_{i}\sum_{j}\sum_{k}p(x_i,y_j,z_k)\log\frac{p(x_i,y_j,z_k)p(z_k)}{p(x_i,z_k)p(y_j,z_k)}  \end{align*}  $$</span></li></ul></li><li><p><strong>互信息的链式法则</strong> <span class="math display">$$I(X_1,X_2,\cdots,X_n;Y)=\sum_{i =1}^{n}I(X_i;Y|X_{i - 1},X_{i - 2},\cdots,X_1)$$</span></p></li><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  &amp;I(X_1,X_2,\cdots,X_n;Y)\\  =&amp;H(X_1,X_2,\cdots,X_n)-H(X_1,X_2,\cdots,X_n|Y)\\  =&amp;\sum_{i = 1}^{n}H(X_i|X_{i - 1},\cdots,X_1)-\sum_{i =1}^{n}H(X_i|X_{i - 1},\cdots,X_1,Y)\\  =&amp;\sum_{i = 1}^{n}I(X_i;Y|X_1,X_2,\cdots,X_{i - 1})  \end{align*}  $$</span></p></li></ul><h4 id="相对熵的链式法则">相对熵的链式法则</h4><ul><li><p><strong>条件相对熵定义</strong>：</p><ul><li>对于联合概率密度函数 <span class="math inline"><em>p</em>(<em>x</em>, <em>y</em>)</span> 和 <span class="math inline"><em>q</em>(<em>x</em>, <em>y</em>)</span>，条件相对熵（conditionalrelative entropy <span class="math inline"><em>D</em>(<em>p</em>(<em>y</em>|<em>x</em>)∥<em>q</em>(<em>y</em>|<em>x</em>))</span>）定义为条件概率密度函数<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span> 和<span class="math inline"><em>q</em>(<em>y</em>|<em>x</em>)</span>之间的平均相对熵，其中取平均是关于概率密度函数 <span class="math inline"><em>p</em>(<em>x</em>)</span> 而言的。 <span class="math display">$$  \begin{align*}  D(p(y|x)\|q(y|x))&amp;=\sum_{x}p(x)\sum_{y}p(y|x)\log\frac{p(y|x)}{q(y|x)}\\  &amp;=E_{p(x,y)}\log\frac{p(Y|X)}{q(Y|X)}\\  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{q(y_j|x_i)}  \end{align*}  $$</span></li></ul></li><li><p><strong>相对熵的链式法则</strong> <span class="math display"><em>D</em>(<em>p</em>(<em>x</em>, <em>y</em>)∥<em>q</em>(<em>x</em>, <em>y</em>)) = <em>D</em>(<em>p</em>(<em>x</em>)∥<em>q</em>(<em>x</em>)) + <em>D</em>(<em>p</em>(<em>y</em>|<em>x</em>)∥<em>q</em>(<em>y</em>|<em>x</em>))</span></p></li><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  &amp;D(p(x,y)\|q(x,y))\\  =&amp;\sum_{x}\sum_{y}p(x,y)\log\frac{p(x,y)}{q(x,y)}\\  =&amp;\sum_{x}\sum_{y}p(x,y)\log\frac{p(x)p(y|x)}{q(x)q(y|x)}\\  =&amp;\sum_{x}\sum_{y}p(x,y)\log\frac{p(x)}{q(x)}+\sum_{x}\sum_{y}p(x,y)\log\frac{p(y|x)}{q(y|x)}\\  =&amp;\sum_{x}p(x)\log\frac{p(x)}{q(x)}+\sum_{x}\sum_{y}p(x,y)\log\frac{p(y|x)}{q(y|x)}\\  =&amp;D(p(x)\|q(x))+D(p(y|x)\|q(y|x))  \end{align*}  $$</span></p></li></ul><h3 id="jensen不等式">Jensen不等式</h3><h4 id="凸函数与凹函数">凸函数与凹函数</h4><ul><li><strong>凸函数(Convex)定义</strong><ul><li>若对于任意的 <span class="math inline"><em>x</em><sub>1</sub>, <em>x</em><sub>2</sub> ∈ (<em>a</em>, <em>b</em>)</span>及 <span class="math inline">0 ≤ <em>λ</em> ≤ 1</span>，满足 <span class="math display"><em>f</em>(<em>λ</em><em>x</em><sub>1</sub> + (1 − <em>λ</em>)<em>x</em><sub>2</sub>) ≤ <em>λ</em><em>f</em>(<em>x</em><sub>1</sub>) + (1 − <em>λ</em>)<em>f</em>(<em>x</em><sub>2</sub>)</span></li></ul>则称函数 <span class="math inline"><em>f</em>(<em>x</em>)</span> 在区间<span class="math inline">(<em>a</em>, <em>b</em>)</span>上是凸的（convex）。<ul><li>如果仅当 <span class="math inline"><em>λ</em> = 0</span> 或 <span class="math inline"><em>λ</em> = 1</span>，上式等号成立，则称函数 <span class="math inline"><em>f</em></span> 是严格凸的（strictly convex）</li><li>如果函数总是位于任何一条弦的下面，则该函数是凸的</li><li><figure><img src="image-7.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul></li><li><strong>凹函数(Concave)定义</strong><ul><li>如果 <span class="math inline">−<em>f</em></span> 为凸函数，则称函数<span class="math inline"><em>f</em></span> 是凹的</li><li>如果函数总是位于任何一条弦的上面，则该函数是凹的</li><li><figure><img src="image-113.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul></li><li><strong>定理</strong>：如果函数 <span class="math inline"><em>f</em></span>在某个区间上存在非负（正）的二阶导数，则 <span class="math inline"><em>f</em></span> 为该区间的凸函数（严格凸函数）。<ul><li><strong>证明</strong>： 根据泰勒公式，<span class="math inline">$f(x)=f(x_0)+f^{\prime}(x_0)(x -x_0)+\frac{f^{\prime\prime}(x^*)}{2}(x - x_0)^2$</span> ，其中 <span class="math inline"><em>x</em> ≤ <em>x</em><sup>*</sup> ≤ <em>x</em><sub>0</sub></span>。根据假设<span class="math inline"><em>f</em><sup>′′</sup>(<em>x</em><sup>*</sup>) ≥ 0</span>，上式末项非负。设 <span class="math inline"><em>x</em><sub>0</sub> = <em>λ</em><em>x</em><sub>1</sub> + (1 − <em>λ</em>)<em>x</em><sub>2</sub></span>，<ul><li>取 <span class="math inline"><em>x</em> = <em>x</em><sub>1</sub></span>，可得<span class="math inline"><em>f</em>(<em>x</em><sub>1</sub>) ≥ <em>f</em>(<em>x</em><sub>0</sub>) + <em>f</em><sup>′</sup>(<em>x</em><sub>0</sub>)((1 − <em>λ</em>)(<em>x</em><sub>1</sub> − <em>x</em><sub>2</sub>))</span>①；</li><li>取 <span class="math inline"><em>x</em> = <em>x</em><sub>2</sub></span>，可得<span class="math inline"><em>f</em>(<em>x</em><sub>2</sub>) ≥ <em>f</em>(<em>x</em><sub>0</sub>) + <em>f</em><sup>′</sup>(<em>x</em><sub>0</sub>)(<em>λ</em>(<em>x</em><sub>2</sub> − <em>x</em><sub>1</sub>))</span>②。</li></ul>①<span class="math inline">×<em>λ</em>+</span>②<span class="math inline">×(1 − <em>λ</em>)</span> ： <span class="math display">$$  \begin{align*}  \lambda f(x_1)+(1 - \lambda)f(x_2)&amp;\geq\lambda f(x_0)+\lambdaf^{\prime}(x_0)((1 - \lambda)(x_1 - x_2))\\  &amp;+(1 - \lambda)f(x_0)+(1 - \lambda)f^{\prime}(x_0)\lambda(x_2 -x_1)\\  &amp;=f(x_0)\\  &amp;=f(\lambda x_1+(1 - \lambda)x_2)  \end{align*}  $$</span></li></ul></li></ul><h4 id="jensen不等式-1">Jensen不等式</h4><ul><li><p><strong>Jensen不等式</strong>：若给定凸函数 <span class="math inline"><em>f</em></span> 和一个随机变量 <span class="math inline"><em>X</em></span>，则 <span class="math display"><em>E</em>(<em>f</em>(<em>X</em>)) ≥ <em>f</em>(<em>E</em>(<em>X</em>))</span></p></li><li><p>若 <span class="math inline"><em>f</em></span>是严格凸的，上式等号成立时 <span class="math inline"><em>X</em> = <em>E</em>(<em>X</em>)</span>，即 <span class="math inline"><em>X</em></span> 是个常量。</p><ul><li><strong>证明</strong>： 对于两点分布 <span class="math inline">$\begin{bmatrix}x_1&amp;x_2\\p_1&amp;p_2\end{bmatrix}$</span>，<span class="math inline"><em>f</em></span> 是凸函数，因此有<span class="math inline"><em>p</em><sub>1</sub><em>f</em>(<em>x</em><sub>1</sub>) + <em>p</em><sub>2</sub><em>f</em>(<em>x</em><sub>2</sub>) ≥ <em>f</em>(<em>p</em><sub>1</sub><em>x</em><sub>1</sub> + <em>p</em><sub>2</sub><em>x</em><sub>2</sub>)</span>，即满足<span class="math inline"><em>E</em>(<em>f</em>(<em>X</em>)) ≥ <em>f</em>(<em>E</em>(<em>X</em>))</span>假定当分布点数为 <span class="math inline"><em>k</em> − 1</span>时，定理成立，此时记 <span class="math inline">$p_i^{\prime}=\frac{p_i}{1 - p_k}$</span> <span class="math inline">(<em>i</em> = 1, 2, ⋯, <em>k</em> − 1)</span> <span class="math display">$$  \begin{align*}  \sum_{i = 1}^{k}p_if(x_i)&amp;=p_kf(x_k)+(1 - p_k)\sum_{i = 1}^{k -1}p_i^{\prime}f(x_i)\\  &amp;\geq p_kf(x_k)+(1 - p_k)f(\sum_{i = 1}^{k - 1}p_i^{\prime}x_i)\\  &amp;\geq f(p_kx_k+(1 - p_k)\sum_{i = 1}^{k - 1}p_i^{\prime}x_i)\\  &amp;=f(\sum_{i = 1}^{k}p_ix_i)  \end{align*}  $$</span><ul><li>其中，“分布点数为 <span class="math inline"><em>k</em> − 1</span>时定理成立”用于推导第二步；“<span class="math inline"><em>f</em></span>的下凸性”用于推导第三步</li></ul></li></ul></li><li><p><strong>对凹函数</strong>：</p><ul><li>若 <span class="math inline"><em>f</em>(<em>x</em>)</span>是凹函数，则有 <span class="math inline"><em>E</em>(<em>f</em>(<em>X</em>)) ≤ <em>f</em>(<em>E</em>(<em>X</em>))</span></li><li>取 <span class="math inline"><em>f</em>(<em>x</em>) = log (<em>x</em>)</span>，有 <span class="math inline"><em>E</em>[log (<em>X</em>)] ≤ log (<em>E</em>(<em>X</em>))</span></li></ul></li></ul><h4 id="信息不等式相对熵的非负性">信息不等式/相对熵的非负性</h4><ul><li><strong><a href="#相对熵">信息不等式</a></strong>：设 <span class="math inline"><em>p</em>(<em>x</em>)</span>、<span class="math inline"><em>q</em>(<em>x</em>)</span>（<span class="math inline"><em>x</em> ∈ <em>X</em></span>）为两个概率密度函数，则<span class="math display"><em>D</em>(<em>p</em>||<em>q</em>) ≥ 0</span>当且仅当对任意 <span class="math inline"><em>x</em></span>，<span class="math inline"><em>p</em>(<em>x</em>) = <em>q</em>(<em>x</em>)</span>，等号成立。<ul><li><strong>证明</strong>： 设 <span class="math inline"><em>A</em> = {<em>x</em> : <em>p</em>(<em>x</em>) &gt; 0}</span>为 <span class="math inline"><em>p</em>(<em>x</em>)</span> 的支撑集，则<span class="math display">$$  \begin{align*}  -D(p||q)&amp;=-\sum_{x\in A}p(x)\log\frac{p(x)}{q(x)}=\sum_{x\inA}p(x)\log\frac{q(x)}{p(x)}\\  &amp;\leq\log\sum_{x\in A}p(x)\frac{q(x)}{p(x)}（由Jensen不等式）\\  &amp;=\log\sum_{x\in A}q(x)\\  &amp;\leq\log\sum_{x\in X}q(x)\\  &amp;=\log1 = 0  \end{align*}  $$</span> <span class="math inline">∴ <em>D</em>(<em>p</em>||<em>q</em>) ≥ 0</span> ，当<span class="math inline"><em>p</em>(<em>x</em>) = <em>q</em>(<em>x</em>)</span>时，等号成立。</li></ul></li></ul><h4 id="互信息的非负性">互信息的非负性</h4><ul><li><strong><a href="#互信息">互信息的非负性</a></strong>：任意两个随机变量 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span>， <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) ≥ 0</span>当且仅当 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span> 相互独立，等号成立。<ul><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  I(X;Y)&amp;=\sum_{x,y}p(x,y)\log\frac{p(x|y)}{p(x)}\\  &amp;=\sum_{x,y}p(x,y)\log\frac{p(x|y)p(y)}{p(x)p(y)}\\  &amp;=\sum_{x,y}p(x,y)\log\frac{p(x,y)}{p(x)p(y)}\\  &amp;=D(p(x,y)\|p(x)p(y))\\  &amp;\geq0  \end{align*}  $$</span></li></ul></li><li><strong>推论</strong>：<ul><li><span class="math inline"><em>D</em>(<em>p</em>(<em>y</em>|<em>x</em>)∥<em>q</em>(<em>y</em>|<em>x</em>)) ≥ 0</span>，当且仅当对任意的 <span class="math inline"><em>y</em></span> 以及满足<span class="math inline"><em>p</em>(<em>x</em>) &gt; 0</span> 的 <span class="math inline"><em>x</em></span>，有 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>) = <em>q</em>(<em>y</em>|<em>x</em>)</span>，等号成立。</li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>) ≥ 0</span>，当且仅当 <span class="math inline"><em>p</em>(<em>x</em>, <em>y</em>|<em>z</em>) = <em>p</em>(<em>x</em>|<em>z</em>)<em>p</em>(<em>y</em>|<em>z</em>)</span>时，等号成立。</li></ul></li></ul><h3 id="熵的性质">熵的性质</h3><ol type="1"><li><strong>非负性</strong><ul><li><span class="math display">$$H(X)=\sum_{i}p(x_i)\log\frac{1}{p(x_i)}\geq0$$</span></li></ul></li><li><strong>确定性</strong><ul><li><span class="math display"><em>H</em>(0, 1) = <em>H</em>(1, 0, ⋯, 0) = 0</span></li><li>只要有一个事件概率为1，熵就为0。</li></ul></li><li><strong>对称性</strong><ul><li><span class="math display"><em>H</em>(<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub>) = <em>H</em>(<em>p</em><sub>2</sub>, <em>p</em><sub>1</sub>, ⋯, <em>p</em><sub><em>n</em></sub>)</span></li></ul></li><li><strong>香农辅助定理</strong><ul><li>任意n维概率矢量 <span class="math inline"><em>P</em> = (<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub>)</span>，<span class="math inline"><em>Q</em> = (<em>q</em><sub>1</sub>, <em>q</em><sub>2</sub>, ⋯, <em>q</em><sub><em>n</em></sub>)</span></li><li><span class="math display">$$H(p_1,p_2,\cdots,p_n)=\sum_{i =1}^{n}p_i\log\frac{1}{p_i}\leq\sum_{i =1}^{n}p_i\log\frac{1}{q_i}$$</span></li><li><strong>证明</strong>：<span class="math inline">$D(P\|Q)=\sum_{i}p_i\log\frac{p_i}{q_i}\geq0$</span></li></ul></li><li><strong>最大熵定理</strong><ul><li><span class="math display">$$H(X)\leqH(\frac{1}{M},\frac{1}{M},\cdots,\frac{1}{M}) = \log M$$</span></li><li><span class="math inline"><em>M</em></span>：信源符号个数</li><li>符号等概率出现时，熵最大。</li><li><strong>证明</strong>：<span class="math inline"><em>X</em></span>的两种概率分布 <span class="math inline"><em>P</em></span>、<span class="math inline"><em>u</em></span>，<span class="math inline">$u(x)=\frac{1}{M}$</span> <span class="math display">$$  \begin{align*}  D(P\|u)&amp;=\sum p(x)\log\frac{p(x)}{u(x)}\\  &amp;=\sum p(x)\log p(x)+\sum p(x)\log M\\  &amp;=-H(X)+\log M\\  &amp;\geq0\\  &amp;\therefore H(X)\leq\log M  \end{align*}  $$</span></li></ul></li><li><strong>条件熵小于无条件熵</strong><ul><li><span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>X</em>)</span></li><li><strong>证明</strong>：<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) ≥ 0</span>，<span class="math inline"><em>H</em>(<em>X</em>) ≥ <em>H</em>(<em>X</em>|<em>Y</em>)</span>。</li></ul></li><li><strong>扩展性</strong><ul><li><span class="math display">lim<sub><em>ε</em> → 0</sub><em>H</em><sub><em>n</em> + 1</sub>(<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub> − <em>ε</em>, <em>ε</em>) = <em>H</em><sub><em>n</em></sub>(<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub>)</span></li><li><span class="math display">lim<sub><em>ε</em> → 0</sub><em>ε</em>log <em>ε</em> = 0</span></li><li>信源取值增多时，若这些取值概率很小(<span class="math inline"><em>ε</em> → 0</span>)，信源熵不变。</li></ul></li><li><strong>可加性</strong><ul><li><span class="math display"><em>H</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>|<em>X</em>)</span></li><li>当 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span> 相互独立时，<span class="math inline"><em>H</em>(<em>X</em>, <em>Y</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>)</span>。</li><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  H(X,Y)&amp;=\sum p(x,y)\log p(x,y)=\sum p(x,y)\log (p(x)p(y|x))\\  &amp;=\sum p(x,y)\log p(x)+\sum p(x,y)\log p(y|x)\\  &amp;=H(X)+H(Y|X)  \end{align*}  $$</span></li></ul></li><li><strong>递增性</strong><ul><li><span class="math display">$$H_{n + m - 1}(p_1,p_2,\cdots,p_{n - 1},q_1,q_2,\cdots,q_m)\\=H_n(p_1,p_2,\cdots,p_n)+p_nH_m\left(\frac{q_1}{p_n},\frac{q_2}{p_n},\cdots,\frac{q_m}{p_n}\right)$$</span></li><li>其中<span class="math inline">$\sum_{i = 1}^{n}p_i =1$</span>，<span class="math inline">$\sum_{j = 1}^{m}q_j =p_n$</span></li><li>利用上式： <span class="math display">$$  \begin{align*}  H_n(p_1,p_2,\cdots,p_n)&amp;=H_{n - 1}(p_1,p_2,\cdots,p_{n -1}+p_n)+\\  \quad &amp;(p_{n - 1}+p_n)H_2\left(\frac{p_{n - 1}}{p_{n -1}+p_n},\frac{p_n}{p_{n - 1}+p_n}\right)  \end{align*}  $$</span></li></ul></li></ol><h3 id="对数和不等式及其应用">对数和不等式及其应用</h3><h4 id="对数和不等式">对数和不等式</h4><ul><li>非负数 <span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub></span>，和<span class="math inline"><em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>n</em></sub></span>，约定 <span class="math inline">0log 0 = 0</span>，<span class="math inline">$a\log\frac{a}{0}=\infty$</span>，<span class="math inline">$0\log\frac{0}{b}=0$</span> <span class="math display">$$  \sum_{i = 1}^{n}a_i\log\frac{a_i}{b_i}\geq\left(\sum_{i =1}^{n}a_i\right)\log\frac{\sum_{i = 1}^{n}a_i}{\sum_{i = 1}^{n}b_i}  $$</span> 当且仅当 <span class="math inline">$\frac{a_i}{b_i}=$</span> 常数时，等号成立。<ul><li><strong>证明</strong>： 假定 <span class="math inline"><em>a</em><sub><em>i</em></sub> &gt; 0</span>，<span class="math inline"><em>b</em><sub><em>i</em></sub> &gt; 0</span>，<span class="math inline"><em>f</em>(<em>t</em>) = <em>t</em>log <em>t</em></span>是严格下凸，因为 <span class="math inline">$f^{\prime\prime}(t)=\frac{1}{t}\loge&gt;0$</span>。 因此，由Jensen不等式，有 <span class="math inline">∑<em>α</em><sub><em>i</em></sub><em>f</em>(<em>t</em><sub><em>i</em></sub>) ≥ <em>f</em>(∑<em>α</em><sub><em>i</em></sub><em>t</em><sub><em>i</em></sub>)</span>，其中<span class="math inline"><em>α</em><sub><em>i</em></sub> ≥ 0</span>，<span class="math inline">∑<em>α</em><sub><em>i</em></sub> = 1</span>。 令<span class="math inline">$\alpha_i=\frac{b_i}{\sum_{j =1}^{n}b_j}$</span> ，<span class="math inline">$t_i=\frac{a_i}{b_i}$</span> ，可得 <span class="math display">$$  \begin{align*}  \sum\frac{b_i}{\sum_{j =1}^{n}b_j}\cdot\frac{a_i}{b_i}\log\frac{a_i}{b_i}&amp;\geq\left(\sum\alpha_it_i\right)\log\left(\sum\alpha_it_i\right)\\  &amp;=\sum\left(\frac{b_i}{\sum_{j =1}^{n}b_j}\cdot\frac{a_i}{b_i}\right)\log\left(\sum\frac{b_i}{\sum_{j =1}^{n}b_j}\cdot\frac{a_i}{b_i}\right)\\  \sum_{i}a_i\log\frac{a_i}{b_i}&amp;\geq\left(\sum_{i}a_i\right)\log\left(\sum_{i}\frac{a_i}{\sum_{j= 1}^{n}b_j}\right)\\  \sum_{i}a_i\log\frac{a_i}{b_i}&amp;\geq\left(\sum_{i}a_i\right)\log\frac{\sum_{i= 1}^{n}a_i}{\sum_{i = 1}^{n}b_j}  \end{align*}  $$</span></li></ul></li></ul><h4 id="相对熵的下凸性">相对熵的下凸性</h4><ul><li><span class="math inline"><em>D</em>(<em>p</em>||<em>q</em>)</span>关于 <span class="math inline">(<em>p</em>, <em>q</em>)</span>是下凸的</li><li>即如果 <span class="math inline">(<em>p</em><sub>1</sub>, <em>q</em><sub>1</sub>)</span>，<span class="math inline">(<em>p</em><sub>2</sub>, <em>q</em><sub>2</sub>)</span>为两对概率密度函数，则对所有的 <span class="math inline">0 ≤ <em>λ</em> ≤ 1</span>，有 <span class="math display"><em>D</em>(<em>λ</em><em>p</em><sub>1</sub> + (1 − <em>λ</em>)<em>p</em><sub>2</sub>∥<em>λ</em><em>q</em><sub>1</sub> + (1 − <em>λ</em>)<em>q</em><sub>2</sub>) ≤ <em>λ</em><em>D</em>(<em>p</em><sub>1</sub>∥<em>q</em><sub>1</sub>) + (1 − <em>λ</em>)<em>D</em>(<em>p</em><sub>2</sub>∥<em>q</em><sub>2</sub>)</span><ul><li><strong>证明</strong>： 已知 <span class="math inline">$\sum_{i =1}^{n}a_i\log\frac{a_i}{b_i}\geq\left(\sum_{i =1}^{n}a_i\right)\log\frac{\sum_{i = 1}^{n}a_i}{\sum_{i =1}^{n}b_i}$</span> 令 <span class="math inline"><em>a</em><sub>1</sub> = <em>λ</em><em>p</em><sub>1</sub>(<em>x</em>)</span>，<span class="math inline"><em>b</em><sub>1</sub> = <em>λ</em><em>q</em><sub>1</sub>(<em>x</em>)</span><span class="math inline"><em>a</em><sub>2</sub> = (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>x</em>)</span>，<span class="math inline"><em>b</em><sub>2</sub> = (1 − <em>λ</em>)<em>q</em><sub>2</sub>(<em>x</em>)</span><span class="math display">$$  \begin{align*}  &amp;\quad \lambda p_1(x)\log\frac{\lambda p_1(x)}{\lambda q_1(x)}+(1- \lambda)p_2(x)\log\frac{(1 - \lambda)p_2(x)}{(1 - \lambda)q_2(x)}\\  &amp;\geq(\lambda p_1(x)+(1 - \lambda)p_2(x))\log\frac{\lambdap_1(x)+(1 - \lambda)p_2(x)}{\lambda q_1(x)+(1 - \lambda)q_2(x)}\\  &amp;\quad \sum_{x}\left[\lambda p_1(x)\log\frac{p_1(x)}{q_1(x)}+(1 -\lambda)p_2(x)\log\frac{p_2(x)}{q_2(x)}\right]\\  &amp;\geq\sum_{x}(\lambda p_1(x)+(1 - \lambda)p_2(x))\log\frac{\lambdap_1(x)+(1 - \lambda)p_2(x)}{\lambda q_1(x)+(1 - \lambda)q_2(x)}\\  &amp;\quad \lambda D(p_1\|q_1)+(1 - \lambda)D(p_2\|q_2)\\  &amp;\geq D(\lambda p_1+(1 - \lambda)p_2\|\lambda q_1+(1 -\lambda)q_2)  \end{align*}  $$</span></li></ul></li></ul><h4 id="熵的凹性">熵的凹性</h4><ul><li><span class="math inline"><em>H</em>(<em>p</em>)</span> 是关于 <span class="math inline"><em>p</em></span> 的凹函数。<ul><li><strong>证明</strong>： 均匀分布 <span class="math inline">$u(x_i)=\frac{1}{M}$</span> <span class="math display">$$  \begin{align*}  D(p\|u)&amp;=\sum_{i}p(x_i)\log\frac{p(x_i)}{u(x_i)}\\  &amp;=\sum_{i}p(x_i)\log p(x_i)-\sum_{i}p(x_i)\log u(x_i)\\  &amp;=-H(p)+\log M  \end{align*}  $$</span> <span class="math inline">∴ <em>H</em>(<em>p</em>) = log <em>M</em> − <em>D</em>(<em>p</em>∥<em>u</em>)</span>，因为<span class="math inline"><em>D</em>(<em>p</em>∥<em>u</em>)</span>是凸函数，所以 <span class="math inline"><em>H</em>(<em>p</em>)</span>是凹函数。</li></ul></li></ul><h4 id="互信息的凹凸性">互信息的凹凸性</h4><ul><li><strong><a href="#互信息">互信息的凹凸性</a></strong><ul><li>设 <span class="math inline">(<em>X</em>, <em>Y</em>) ∼ <em>p</em>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>|<em>x</em>)</span>。</li><li>如果固定 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>，则互信息<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>是关于 <span class="math inline"><em>p</em>(<em>x</em>)</span>的凹函数；</li><li>如果固定 <span class="math inline"><em>p</em>(<em>x</em>)</span>，则互信息 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是关于<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>的凸函数。</li></ul></li><li><strong>证明</strong>：<ol type="1"><li><p><strong>证明第一部分</strong> <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>Y</em>) − ∑<sub><em>x</em></sub><em>p</em>(<em>x</em>)<em>H</em>(<em>Y</em>|<em>X</em> = <em>x</em>)</span>如果固定 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>，<span class="math inline"><em>p</em>(<em>y</em>) = ∑<sub><em>x</em></sub><em>p</em>(<em>x</em>, <em>y</em>) = ∑<sub><em>x</em></sub><em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>|<em>x</em>)</span>是 <span class="math inline"><em>p</em>(<em>x</em>)</span> 的线性函数。<span class="math inline"><em>H</em>(<em>Y</em>)</span> 是关于 <span class="math inline"><em>p</em>(<em>y</em>)</span> 的凹函数，因而也是关于<span class="math inline"><em>p</em>(<em>x</em>)</span>的凹函数。上式第二项是关于 <span class="math inline"><em>p</em>(<em>x</em>)</span>的线性函数，因此它们的差仍是关于 <span class="math inline"><em>p</em>(<em>x</em>)</span> 的凹函数。</p></li><li><p><strong>证明第二部分</strong></p><ul><li><p><strong>方法1</strong>： 固定 <span class="math inline"><em>p</em>(<em>x</em>)</span>，考虑两个不同的条件分布<span class="math inline"><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)</span>和 <span class="math inline"><em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>。相应的联合分布分别为<span class="math inline"><em>p</em><sub>1</sub>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)</span>和 <span class="math inline"><em>p</em><sub>2</sub>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>，且各自的边际分布为<span class="math inline"><em>p</em>(<em>x</em>), <em>p</em><sub>1</sub>(<em>y</em>)</span>和 <span class="math inline"><em>p</em>(<em>x</em>), <em>p</em><sub>2</sub>(<em>y</em>)</span>。考虑条件分布 <span class="math display"><em>p</em><sub><em>λ</em></sub>(<em>y</em>|<em>x</em>) = <em>λ</em><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>它是 <span class="math inline"><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)</span>和 <span class="math inline"><em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>的组合，其中 <span class="math inline">0 ≤ <em>λ</em> ≤ 1</span>。相应的联合分布也是对应的两个联合分布的线性组合 <span class="math display"><em>p</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>) = <em>λ</em><em>p</em><sub>1</sub>(<em>x</em>, <em>y</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>x</em>, <em>y</em>)</span><span class="math inline"><em>Y</em></span> 的分布也是一个组合 <span class="math display"><em>p</em><sub><em>λ</em></sub>(<em>y</em>) = <em>λ</em><em>p</em><sub>1</sub>(<em>y</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>y</em>)</span>因此，如果设 <span class="math inline"><em>q</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em><sub><em>λ</em></sub>(<em>y</em>)</span>为边际分布的乘积，则有 <span class="math display"><em>q</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>) = <em>λ</em><em>q</em><sub>1</sub>(<em>x</em>, <em>y</em>) + (1 − <em>λ</em>)<em>q</em><sub>2</sub>(<em>x</em>, <em>y</em>)</span>由于互信息是联合分布和边际分布乘积的相对熵，有 <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>D</em>(<em>p</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>)∥<em>q</em><sub><em>λ</em></sub>(<em>x</em>, <em>y</em>))</span>因为相对熵 <span class="math inline"><em>D</em>(<em>p</em>∥<em>q</em>)</span> 是关于<span class="math inline">(<em>p</em>, <em>q</em>)</span> 的凸函数，因此<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是<span class="math inline">(<em>p</em><sub><em>λ</em></sub>, <em>q</em><sub><em>λ</em></sub>)</span>的凸函数，由于 <span class="math inline"><em>p</em><sub><em>λ</em></sub>, <em>q</em><sub><em>λ</em></sub></span>都是 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>的线性组合，所以 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是条件分布<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>的凸函数。</p></li><li><p><strong>方法2</strong>： 设 <span class="math inline"><em>p</em>(<em>x</em>)</span> 为固定信源分布，令<span class="math inline"><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)</span>和 <span class="math inline"><em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>为两条不同信道，相应的互信息分别记为 <span class="math inline"><em>I</em>[<em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)]</span>和 <span class="math inline"><em>I</em>[<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)]</span>。令 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>) = <em>λ</em><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)</span>，<span class="math inline">0 ≤ <em>λ</em> ≤ 1</span>，相应的互信息为 <span class="math inline"><em>I</em>[<em>p</em>(<em>y</em>|<em>x</em>)]</span><span class="math display">$$\begin{align*}①\ &amp;I[p(y|x)]-\lambda I[p_1(y|x)]-(1 - \lambda)I[p_2(y|x)]\\&amp;=\sum_{x,y}p(x,y)\log\frac{p(y|x)}{p(y)}-\sum_{x,y}\lambdap_1(x,y)\log\frac{p_1(y|x)}{p_1(y)}-\\&amp;\quad \sum_{x,y}(1 -\lambda)p_2(x,y)\log\frac{p_2(y|x)}{p_2(y)}\\&amp;=\sum_{x,y}[\lambda p_1(x,y)+(1 -\lambda)p_2(x,y)]\log\frac{p(y|x)}{p(x)}-\\&amp;\quad\sum_{x,y}\lambdap_1(x,y)\log\frac{p_1(y|x)}{p(x)}-\sum_{x,y}(1 -\lambda)p_2(x,y)\log\frac{p_2(y|x)}{p(x)}\\&amp;=\lambda\underbrace{\sum_{x,y}p_1(x,y)\log\frac{p(x|y)}{p_1(x|y)}}_{(②)}+(1 -\lambda)\underbrace{\sum_{x,y}p_2(x,y)\log\frac{p(x|y)}{p_2(x|y)}}_{(③)}\end{align*}$$</span> 应用Jensen不等式 <span class="math display">$$\begin{align*}②\\lambda\sum_{x,y}p_1(x,y)\log\frac{p(x|y)}{p_1(x|y)}&amp;\leq\lambda\log\left[\sum_{x,y}p_1(x,y)\frac{p(x|y)}{p_1(x|y)}\right]\\&amp;=\lambda\log\left[\sum_{y}p_1(y)\sum_{x}p(x|y)\right]\\&amp;=\lambda\log\left[\sum_{y}p_1(y)\sum_{x}\frac{p(x)p(y|x)}{p(y)}\right]\\&amp;=\lambda\log1 = 0\end{align*}$$</span> 同理 <span class="math inline">③ = 0</span>，则 <span class="math inline">① ≤ 0</span> <span class="math display"><em>I</em>(<em>λ</em><em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>) + (1 − <em>λ</em>)<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)) ≤ <em>λ</em><em>I</em>[<em>p</em><sub>1</sub>(<em>y</em>|<em>x</em>)] + (1 − <em>λ</em>)<em>I</em>[<em>p</em><sub>2</sub>(<em>y</em>|<em>x</em>)]</span></p></li></ul></li></ol><ul><li>由此可知，互信息 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 关于 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span> 下凸。</li></ul></li></ul><h2 id="数据处理不等式">2.3 数据处理不等式</h2><h3 id="三变量互信息">三变量互信息</h3><ul><li><strong>定义</strong>：<ol type="1"><li><strong><span class="math inline"><em>x</em><sub><em>i</em></sub></span>与符号对<span class="math inline">(<em>y</em><sub><em>j</em></sub>, <em>z</em><sub><em>k</em></sub>)</span>间的互信息量</strong><ul><li><span class="math inline">$I(x_i;y_j,z_k)=\log\frac{p(x_i|y_j,z_k)}{p(x_i)}$</span></li></ul></li><li><strong>条件互信息量</strong><ul><li><span class="math display">$$\begin{align*}I(x_i;y_j|z_k)&amp;=\log\frac{p(x_i|y_j,z_k)}{p(x_i|z_k)}=\log(\frac{p(x_i|y_j,z_k)}{p(x_i)}\frac{p(x_i)}{p(x_i|z_k)})\\&amp;=\log\frac{p(x_i|y_j,z_k)}{p(x_i)}-\log\frac{p(x_i|z_k)}{p(x_i)}\\&amp;=I(x_i;y_j,z_k)-I(x_i;z_k)\end{align*}$$</span></li><li><span class="math inline"><em>I</em>(<em>x</em><sub><em>i</em></sub>; <em>y</em><sub><em>j</em></sub>, <em>z</em><sub><em>k</em></sub>) = <em>I</em>(<em>x</em><sub><em>i</em></sub>; <em>z</em><sub><em>k</em></sub>) + <em>I</em>(<em>x</em><sub><em>i</em></sub>; <em>y</em><sub><em>j</em></sub>|<em>z</em><sub><em>k</em></sub>)</span></li><li>对其求平均可得<ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>, <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Z</em>) + <em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>)</span></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>, <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Z</em>, <em>Y</em>) = <em>I</em>(<em>X</em>; <em>Y</em>) + <em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>)</span>①</li></ul></li></ul></li><li><strong><span class="math inline"><em>x</em><sub><em>i</em></sub>，<em>y</em><sub><em>j</em></sub></span>与符号对<span class="math inline">(<em>z</em><sub><em>k</em></sub>)</span>间的互信息量</strong><ul><li><span class="math display">$$\begin{align*}I(x_i,y_j;z_k)&amp;=\log\frac{p(x_iy_j|z_k)}{p(x_iy_j)}=\log\frac{p(x_i|z_k)p(y_j|x_iz_k)}{p(x_i)p(y_j|x_i)}\\&amp;=\log\frac{p(x_i|z_k)}{p(x_i)}+\log\frac{p(y_j|x_iz_k)}{p(y_j|x_i)}\\&amp;=I(x_i;z_k)+I(y_j;z_k|x_i)\end{align*}$$</span></li><li>对其求平均可得<ul><li><span class="math inline"><em>I</em>(<em>X</em>, <em>Y</em>; <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Z</em>) + <em>I</em>(<em>Y</em>; <em>Z</em>|<em>X</em>)</span></li><li><span class="math inline"><em>I</em>(<em>X</em>, <em>Y</em>; <em>Z</em>) = <em>I</em>(<em>Y</em>, <em>X</em>; <em>Z</em>) = <em>I</em>(<em>Y</em>; <em>Z</em>) + <em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>)</span>②</li></ul></li></ul></li></ol></li><li><strong>互信息操作</strong>：<ul><li>由①、②：<ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>) = <em>I</em>(<em>X</em>; <em>Y</em>, <em>Z</em>) − <em>I</em>(<em>X</em>; <em>Y</em>)</span><ul><li>把条件<span class="math inline"><em>Y</em></span>移到分号后面，然后减去该条件与分号前面的变量之间的互信息</li><li><span class="math inline"><em>Y</em></span>的条件下<span class="math inline"><em>X</em><em>和</em><em>Z</em></span>+ <span class="math inline"><em>X</em><em>和</em><em>Y</em></span> = <span class="math inline"><em>X</em><em>和</em>(<em>Y</em>, <em>Z</em>)</span></li></ul></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>) = <em>I</em>(<em>X</em>, <em>Y</em>; <em>Z</em>) − <em>I</em>(<em>Y</em>; <em>Z</em>)</span><ul><li>把条件<span class="math inline"><em>Y</em></span>移到分号前面，然后减去该条件与分号后面的变量之间的互信息</li></ul></li></ul></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>, <em>W</em>) = <em>I</em>(<em>X</em>; <em>Z</em>, <em>Y</em>|<em>W</em>) − <em>I</em>(<em>X</em>; <em>Y</em>|<em>W</em>) = <em>I</em>(<em>X</em>, <em>Y</em>; <em>Z</em>|<em>W</em>) − <em>I</em>(<em>Y</em>; <em>Z</em>|<em>W</em>)</span></li><li><span class="math display">$$\begin{align*}I(X;Y|Z)&amp;=\sum_{i,j,k}p(x_i,y_j,z_k)\log\frac{p(x_i|y_j,z_k)}{p(x_i|z_k)}\\&amp;=\sum_{i,j,k} p(x_i,y_j,z_k)\log p(x_i|y_j,z_k)-\sum_{i,j,k}p(x_i,y_j,z_k)\log p(x_i|z_k)\\&amp;=H(X|Z)-H(X|Y,Z)\\&amp;=H(Y|Z)-H(Y|X,Z)\\&amp;=I(Y;X|Z)\end{align*}$$</span></li></ul></li><li><strong>三变量通用信息图</strong>：<ul><li>信息图表示：<ul><li>$H/I $区域</li><li><span class="math inline">,  ⇔ ⋃</span>(并集)</li><li><span class="math inline">;  ⇔ ⋂</span>(交集)</li><li><span class="math inline">| ⇔ −</span> (减)</li></ul></li><li><figure><img src="image-4.png" srcset="/img/loading/loading3.gif" lazyload alt="三变量通用信息图"><figcaption aria-hidden="true">三变量通用信息图</figcaption></figure></li><li>不相变的7个区域分别表示<ul><li><span class="math inline"><em>a</em><sub>1</sub> : <em>H</em>(<em>Y</em>|<em>X</em>, <em>Z</em>)</span></li><li><span class="math inline"><em>a</em><sub>2</sub> : <em>H</em>(<em>X</em>|<em>Y</em>, <em>Z</em>)</span></li><li><span class="math inline"><em>a</em><sub>3</sub> : <em>H</em>(<em>Z</em>|<em>X</em>, <em>Y</em>)</span></li><li><span class="math inline"><em>a</em><sub>4</sub> : <em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>)</span><br></li><li><span class="math inline"><em>a</em><sub>5</sub> : <em>I</em>(<em>Y</em>; <em>Z</em>|<em>X</em>)</span></li><li><span class="math inline"><em>a</em><sub>6</sub> : <em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>)</span></li><li><span class="math inline"><em>a</em><sub>7</sub> : <em>I</em>(<em>X</em>; <em>Y</em>; <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Y</em>) − <em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>)</span></li></ul></li><li>一般情况下，<span class="math inline"><em>a</em><sub>7</sub></span>可能为负，即<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>; <em>Z</em>)</span>可能小于0 。</li></ul></li><li>示例：<img src="image-114.png" srcset="/img/loading/loading3.gif" lazyload alt="示例"></li></ul><h3 id="一阶马尔可夫链">一阶马尔可夫链</h3><h4 id="定义">定义</h4><ol type="1"><li><strong>定义（两变量独立）</strong><ul><li>两个随机变量 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span> 独立，记为 <span class="math inline"><em>X</em> ⟂ <em>Y</em></span>，有 <span class="math display"><em>p</em>(<em>x</em>, <em>y</em>) = <em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>)</span></li></ul></li><li><strong>定义（相互独立）</strong><ul><li>设 <span class="math inline"><em>n</em> ≥ 3</span>，随机变量 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>相互独立，有 <span class="math display"><em>p</em>(<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>) = <em>p</em>(<em>x</em><sub>1</sub>)<em>p</em>(<em>x</em><sub>2</sub>)⋯<em>p</em>(<em>x</em><sub><em>n</em></sub>)</span></li></ul></li><li><strong>定义（条件独立）</strong><ul><li>随机变量 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span> 和 <span class="math inline"><em>Z</em></span>，若 <span class="math inline"><em>X</em></span> 与 <span class="math inline"><em>Z</em></span> 关于 <span class="math inline"><em>Y</em></span> 条件独立，记为 <span class="math inline"><em>X</em> ⟂ <em>Z</em>|<em>Y</em></span></li><li>有 <span class="math inline"><em>p</em>(<em>x</em>, <em>y</em>, <em>z</em>)<em>p</em>(<em>y</em>) = <em>p</em>(<em>x</em>, <em>y</em>)<em>p</em>(<em>y</em>, <em>z</em>)</span>或 <span class="math inline"><em>p</em>(<em>x</em>, <em>z</em>|<em>y</em>) = <em>p</em>(<em>x</em>|<em>y</em>)<em>p</em>(<em>z</em>|<em>y</em>)</span></li><li>等价地 <span class="math display"><em>p</em>(<em>x</em>, <em>y</em>, <em>z</em>) = <em>p</em>(<em>x</em>)<em>p</em>(<em>y</em>|<em>x</em>)<em>p</em>(<em>z</em>|<em>y</em>)</span></li></ul></li><li><strong>定义（马尔可夫链）</strong><ul><li>随机变量 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>（<span class="math inline"><em>n</em> ≥ 3</span>）构成一个马尔可夫链，记作<span class="math inline"><em>X</em><sub>1</sub> → <em>X</em><sub>2</sub> → ⋯ → <em>X</em><sub><em>n</em></sub></span>，则有<span class="math display"><em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>)<em>p</em>(<em>X</em><sub>2</sub>)<em>p</em>(<em>X</em><sub>3</sub>)⋯<em>p</em>(<em>X</em><sub><em>n</em> − 1</sub>) = <em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>)<em>p</em>(<em>X</em><sub>2</sub>, <em>X</em><sub>3</sub>)⋯<em>p</em>(<em>X</em><sub><em>n</em> − 1</sub>, <em>X</em><sub><em>n</em></sub>)</span></li><li>或等价地 <span class="math display"><em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>) = <em>p</em>(<em>X</em><sub>1</sub>)<em>p</em>(<em>X</em><sub>2</sub>|<em>X</em><sub>1</sub>)<em>p</em>(<em>X</em><sub>3</sub>|<em>X</em><sub>2</sub>)⋯<em>p</em>(<em>X</em><sub><em>n</em></sub>|<em>X</em><sub><em>n</em> − 1</sub>)</span></li><li>即系统在时刻<span class="math inline"><em>n</em></span>的状态只取决于时刻<span class="math inline"><em>n</em> − 1</span>的状态，而与时刻<span class="math inline"><em>n</em> − 1</span>之前的状态无关</li><li>可见：<span class="math inline"><em>X</em> → <em>Y</em> → <em>Z</em></span> 等价于<span class="math inline"><em>X</em> ⟂ <em>Z</em>|<em>Y</em></span></li></ul></li></ol><h4 id="结论">结论</h4><ol type="1"><li><span class="math inline"><em>X</em><sub>1</sub> → <em>X</em><sub>2</sub> → ⋯ → <em>X</em><sub><em>n</em></sub></span>构成一个马尔可夫链，则有 <span class="math inline"><em>X</em><sub><em>n</em></sub> → <em>X</em><sub><em>n</em> − 1</sub> → ⋯ → <em>X</em><sub>1</sub></span>也构成一个马尔可夫链。（可由马尔可夫链定义的对称性直接得到）。</li><li><span class="math inline"><em>X</em><sub>1</sub> → <em>X</em><sub>2</sub> → ⋯ → <em>X</em><sub><em>n</em></sub></span>构成一个马尔可夫链，则有 <span class="math display">$$\begin{align*}&amp;X_1 \to X_2 \to X_3\\&amp;(X_1,X_2) \to X_3 \to X_4\\&amp;\vdots\\&amp;(X_1,X_2,\cdots,X_{n - 2}) \to X_{n - 1} \to X_n\end{align*}$$</span> 构成马尔可夫链。<ul><li><p><strong>证明</strong>：</p><p><span class="math display">$$  \begin{align*}  &amp;若X_1 \to X_2 \to X_3 \to X_4构成马尔可夫链，则有\\  &amp;p(x_1,x_2,x_3,x_4)p(x_2)p(x_3) =p(x_1,x_2)p(x_2,x_3)p(x_3,x_4)\quad ①\\  &amp;\therefore \sum_{x_4} p(x_1,x_2,x_3,x_4)p(x_2)p(x_3) = \sum_{x_4}p(x_1,x_2)p(x_2,x_3)p(x_3,x_4)\\  &amp;\therefore p(x_1,x_2,x_3)p(x_2)p(x_3) =p(x_1,x_2)p(x_2,x_3)p(x_3)\\  &amp;\therefore p(x_1,x_2,x_3)p(x_2) = p(x_1,x_2)p(x_2,x_3)\quad ②\\  &amp;\Rightarrow X_1 \to X_2 \to X_3 构成马尔可夫链\\  &amp;把②代入①得 p(x_1,x_2,x_3,x_4)p(x_2)p(x_3) =p(x_1,x_2,x_3)p(x_2)p(x_3,x_4)\\  &amp;\therefore p(x_1,x_2,x_3,x_4)p(x_3) = p(x_1,x_2,x_3)p(x_3,x_4)\\  &amp;\Rightarrow (X_1,X_2) \to X_3 \to X_4 构成马尔可夫链  \end{align*}  $$</span></p></li><li><p>例题：<img src="image-115.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul></li><li><span class="math inline"><em>X</em> → <em>Y</em> → <em>Z</em> → <em>W</em></span>构成马尔可夫链，则有<ul><li><span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>X</em>|<em>Y</em><em>Z</em>) = <em>H</em>(<em>X</em>|<em>Y</em><em>Z</em><em>W</em>)</span><ul><li><strong>证明</strong>： 由马尔可夫链性质： <span class="math display">$$  \begin{align*}  &amp;p(x,y,z)p(y) = p(x,y)p(y,z)\\  &amp;\Rightarrow \frac{p(x,y,z)}{p(y,z)} = \frac{p(x,y)}{p(y)}\\  &amp;\Rightarrow p(x|yz) = p(x|y)\\  &amp;\Rightarrow \underset{x,y}{\mathbb{E}}p(x|yz)=\underset{x,y}{\mathbb{E}} p(x|y)\\  &amp;即 H(X|YZ) = H(X|Y)  \end{align*}  $$</span> 类似地： <span class="math display">$$  \begin{align*}  &amp;p(x,y,z,w)p(y)p(z) = p(x,y)p(y,z)p(z,w)\\  &amp;\Rightarrow p(x,y,z,w) = \frac{p(x,y)}{p(y)} \cdot\frac{p(y,z)p(z,w)}{p(z)} = p(x|y) p(y,z,w)\\  &amp;\Rightarrow p(x|yzw) = p(x|y)\\  &amp;即 H(X|Y) = H(X|YZW)  \end{align*}  $$</span></li><li>注：<span class="math inline">$\frac{p(y,z)p(z,w)}{p(z)} =p(y,z,w)$</span> 由 <span class="math inline"><em>Y</em> → <em>Z</em> → <em>W</em></span>得到</li></ul></li><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>|<em>Y</em>) = <em>H</em>(<em>X</em>|<em>Y</em>) − <em>H</em>(<em>X</em>|<em>Y</em><em>Z</em>) = 0</span></li><li><span class="math inline"><em>I</em>(<em>Y</em>; <em>W</em>|<em>Z</em>) = 0</span></li><li><span class="math inline"><em>I</em>(<em>Y</em>; <em>Z</em>) = <em>I</em>(<em>X</em><em>Y</em>; <em>Z</em>) = <em>I</em>(<em>Y</em>; <em>Z</em><em>W</em>) = <em>I</em>(<em>X</em><em>Y</em>; <em>Z</em><em>W</em>)</span><ul><li><strong>证明</strong>： <span class="math inline">$I(XY;Z) = I(Y;Z)+ I(X;Z|Y) = I(Y;Z)\\  I(Y;ZW) = I(Y;Z) + I(Y;W|Z) = I(Y;Z)$</span></li></ul></li><li><span class="math inline">$I(XY;Z|W) - I(X;Z|W) = I(Y;Z|XW) \geq 0\\  \Rightarrow I(XY;Z|W) \geq I(X;Z|W)$</span></li></ul></li></ol><h3 id="数据处理不等式-1">数据处理不等式</h3><ul><li><strong>定理</strong>：若 <span class="math inline"><em>X</em> → <em>Y</em> → <em>Z</em></span>构成马尔可夫链，则有 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) ≥ <em>I</em>(<em>X</em>; <em>Z</em>)</span>。<ul><li><strong>证明</strong>：<span class="math display">$$  \begin{align*}  &amp;\because I(X;YZ) = I(X;Y) + I(X;Z|Y)= I(X;Z) + I(X;Y|Z)\\  &amp;\therefore I(X;Y)= I(X;Z) + I(X;Y|Z) - I(X;Z|Y)\\  &amp;又\because 马尔可夫链 X \to Y \to Z 中，I(X;Z|Y) = 0 且 I(X;Y|Z)\geq 0\\  &amp;\therefore I(X;Y) \geq I(X;Z)，同理 I(Y;Z) \geq I(X;Z)  \end{align*}      $$</span></li></ul></li><li><strong>三变量马尔可夫链的信息图</strong><ul><li>对于马尔可夫链 <span class="math inline"><em>X</em> → <em>Y</em> → <em>Z</em></span>，其信息图及相关性质如下：<ul><li><figure><img src="image-5.png" srcset="/img/loading/loading3.gif" lazyload alt="三变量马尔可夫链的信息图"><figcaption aria-hidden="true">三变量马尔可夫链的信息图</figcaption></figure></li></ul></li><li><strong>相关等式与性质</strong>：<ul><li><span class="math inline"><em>a</em><sub>1</sub></span> ：条件熵<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>X</em>|<em>Y</em>, <em>Z</em>)</span>。</li><li><span class="math inline"><em>a</em><sub>2</sub></span> ：条件互信息<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>)</span>。</li><li><span class="math inline"><em>a</em><sub>3</sub></span>：互信息<span class="math inline"><em>I</em>(<em>X</em>; <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Y</em>; <em>Z</em>) = <em>I</em>(<em>X</em>; <em>Y</em>) − <em>I</em>(<em>X</em>; <em>Y</em>|<em>Z</em>) ≥ 0</span>。</li><li><span class="math inline"><em>a</em><sub>4</sub></span> ：条件熵<span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>, <em>Z</em>)</span>。</li><li><span class="math inline"><em>a</em><sub>5</sub></span> ：条件互信息<span class="math inline"><em>I</em>(<em>Y</em>; <em>Z</em>|<em>X</em>)</span>。</li><li><span class="math inline"><em>a</em><sub>6</sub></span> ：条件熵<span class="math inline"><em>H</em>(<em>Z</em>|<em>Y</em>) = <em>H</em>(<em>Z</em>|<em>Y</em>, <em>X</em>)</span>。</li></ul></li><li>由此可见，在马尔可夫链的信息图中，每个不相交的区域值都大于等于 0。</li></ul></li><li>例题：<img src="image-116.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h3 id="费诺不等式">费诺不等式</h3><h4 id="定义-1">定义</h4><ul><li><figure><img src="image-6.png" srcset="/img/loading/loading3.gif" lazyload alt="定义"><figcaption aria-hidden="true">定义</figcaption></figure><ul><li>信源发出<span class="math inline"><em>X</em></span>，信宿收到<span class="math inline"><em>Y</em></span>，作出判决：认为<span class="math inline"><em>X</em></span>传出的是<span class="math inline"><em>X̂</em></span></li><li>已知 <span class="math inline"><em>p</em>(<em>X</em>, <em>Y</em>)</span>，<span class="math inline"><em>X̂</em></span> 是 <span class="math inline"><em>Y</em></span> 的函数 <span class="math display">$$  \begin{align*}  \hat{X}(y)&amp;=\arg\underset{x_{i}}{\max} p(x_{i}|y)\\  &amp;=\arg\underset{x_{i}}{\max} \frac{p(x_{i}|y)p(y)}{p(y)}\\  &amp;=\arg\underset{x_{i}}{\max} p(x_{i}, y)  \end{align*}  $$</span></li><li>设 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X̂</em></span> 取值空间同为 <span class="math inline">𝒳</span>，<span class="math inline">|𝒳|</span>表示取值个数。</li></ul></li><li><strong>定义错误概率</strong> <span class="math inline"><em>P</em><sub><em>e</em></sub> = Pr {<em>X</em> ≠ <em>X̂</em>}</span>。<ul><li>若 <span class="math inline"><em>P</em><sub><em>e</em></sub> = 0</span>，即 <span class="math inline"><em>X</em> = <em>X̂</em></span> 以概率 1 成立，<span class="math inline"><em>H</em>(<em>X</em>|<em>X̂</em>) = 0</span>。</li><li>这里讨论 <span class="math inline"><em>P</em><sub><em>e</em></sub> ≠ 0</span> 时，<span class="math inline"><em>P</em><sub><em>e</em></sub></span> 和 <span class="math inline"><em>H</em>(<em>X</em>|<em>X̂</em>)</span>之间的关系。</li></ul></li><li><strong>例题</strong>： <img src="image-117.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h4 id="费诺不等式-1">费诺不等式</h4><ul><li>设 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X̂</em></span> 取值空间同为 <span class="math inline">𝒳</span> 的随机变量，则有 <span class="math display"><em>H</em>(<em>X</em>|<em>X̂</em>) ≤ <em>H</em>(<em>P</em><sub><em>e</em></sub>) + <em>P</em><sub><em>e</em></sub>log (|𝒳|−1)</span>其中 <span class="math inline"><em>H</em>(<em>P</em><sub><em>e</em></sub>) = <em>H</em>(<em>P</em><sub><em>e</em></sub>, 1 − <em>P</em><sub><em>e</em></sub>)</span>为二元熵函数，<span class="math inline">|𝒳|</span> 为 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X̂</em></span> 的取值数量。</li><li><strong>证明1</strong>: 定义随机变量 <span class="math inline">$Z =\begin{cases}0, &amp; 若 X = \hat{X} \\ 1, &amp; 若 X \neq \hat{X}\end{cases}$</span> ，则 <span class="math inline">$P_r(Z) =\begin{cases}1 - P_e, &amp; 若 Z = 0 \\ P_e, &amp; 若 Z = 1\end{cases}$</span>，则<span class="math inline"><em>H</em>(<em>Z</em>) = <em>H</em>(<em>P</em><sub><em>e</em></sub>, 1 − <em>P</em><sub><em>e</em></sub>) = <em>H</em>(<em>P</em><sub><em>e</em></sub>)</span>由于 <span class="math inline"><em>Z</em></span> 是 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X̂</em></span> 的函数，有 <span class="math inline"><em>H</em>(<em>Z</em>|<em>X</em><em>X̂</em>) = 0</span>，则 <span class="math display">$$  \begin{align*}  H(X|\hat{X})&amp;=H(X|\hat{X})+H(Z|X\hat{X})\\  &amp;=H(XZ|\hat{X})\\  &amp;=H(Z|\hat{X})+H(X|Z\hat{X})\\  &amp;\leq H(Z)+H(X|\hat{X}Z)\\  &amp;=H(Z)+\Pr(Z = 0)H(X|\hat{X}, Z = 0)+\Pr(Z = 1)H(X|\hat{X}, Z =1)\\  &amp;=H(Z)+\Pr(Z = 1)H(X|\hat{X}, Z = 1)\\  &amp;\leq H(P_e)+P_e\log(|\mathcal{X}|-1) （其中H(X|\hat{X}, Z = 1)\leq \log(|\mathcal{X}|-1)）  \end{align*}  $$</span> 因为 <span class="math inline"><em>X</em> → <em>Y</em> → <em>X̂</em></span>构成马尔可夫链， 所以 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) ≥ <em>I</em>(<em>X</em>; <em>X̂</em>)</span>，进而 <span class="math inline"><em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) ≥ <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>X̂</em>)</span>，即 <span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>X</em>|<em>X̂</em>)</span>。</li><li><strong>证明2</strong>（不等式放缩）：见<a href="./Ch6sup_信道编码定理.md/#译码错误与信道条件的关系">译码错误与信道条件的关系</a>，其中令<span class="math inline"><em>Y</em> = <em>X̂</em></span>，<span class="math inline"><em>n</em> = |𝒳|</span></li></ul><h4 id="费诺不等式一般形式">费诺不等式（一般形式）</h4><ul><li><p>对于任何满足 <span class="math inline"><em>X</em> → <em>Y</em> → <em>X̂</em></span> 的估计量<span class="math inline"><em>X̂</em></span>，设 <span class="math inline"><em>P</em><sub><em>e</em></sub> = Pr (<em>X</em> ≠ <em>X̂</em>)</span>，有：<span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>X</em>|<em>X̂</em>) ≤ <em>H</em>(<em>P</em><sub><em>e</em></sub>) + <em>P</em><sub><em>e</em></sub>log (|𝒳|−1)</span>其中 <span class="math inline">𝒳</span> 为 <span class="math inline"><em>X</em></span> 的取值空间。</p></li><li><p>上述不等式可以减弱为： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ 1 + <em>P</em><sub><em>e</em></sub>log |𝒳|</span>或者 <span class="math display">$$P_e \geq \frac{H(X|Y) -1}{\log|\mathcal{X}|}$$</span></p></li><li><p><strong>推论</strong>：对于任意两个随机变量 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span>，设 <span class="math inline"><em>p</em> = Pr (<em>X</em> ≠ <em>Y</em>)</span>，有<span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>p</em>) + <em>p</em>log |𝒳|</span>在费诺不等式中令 <span class="math inline"><em>X̂</em> = <em>Y</em></span>，即可得到上式。</p></li></ul><h4 id="其他不等式">其他不等式</h4><ul><li><p>设 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X</em><sup>′</sup></span>为两个相互独立的随机变量，且 <span class="math inline"><em>X</em> ∼ <em>p</em>(<em>x</em>)</span>，<span class="math inline"><em>X</em><sup>′</sup> ∼ <em>r</em>(<em>x</em>)</span>，那么<span class="math inline"><em>X</em> = <em>X</em><sup>′</sup></span>的概率为 <span class="math inline">Pr (<em>X</em> = <em>X</em><sup>′</sup>) = ∑<sub><em>x</em></sub><em>p</em>(<em>x</em>)<em>r</em>(<em>x</em>)</span>，有如下不等式：</p><ol type="1"><li>如果 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X</em><sup>′</sup></span>独立同分布，具有相同的熵 <span class="math inline"><em>H</em>(<em>X</em>)</span>，则 <span class="math inline"><em>X</em> = <em>X</em><sup>′</sup></span> 的概率为<span class="math inline">Pr (<em>X</em> = <em>X</em><sup>′</sup>) = ∑<sub><em>x</em></sub><em>p</em><sup>2</sup>(<em>x</em>)</span>，且有<span class="math display">Pr (<em>X</em> = <em>X</em><sup>′</sup>) ≥ 2<sup>−<em>H</em>(<em>X</em>)</sup></span>当且仅当 <span class="math inline"><em>X</em></span>服从均匀分布，等号成立。<ul><li><strong>证明</strong>： 假定 <span class="math inline"><em>X</em> ∼ <em>p</em>(<em>x</em>)</span>，由Jensen不等式，令<span class="math inline"><em>f</em>(<em>y</em>) = 2<sup><em>y</em></sup></span>为下凸函数。 则 <span class="math inline"><em>f</em>(<em>E</em>(<em>Y</em>)) ≤ <em>E</em>(<em>f</em>(<em>Y</em>))</span>，令 <span class="math inline"><em>y</em> = log <em>p</em>(<em>x</em>)</span>，则有：<span class="math display">$$  \begin{align*}  2^{-H(X)}&amp;=2^{\sum_{x} p(x)\log p(x)}\\  &amp;\leq \sum_{x} p(x)2^{\log p(x)}\\  &amp;=\sum_{x} p(x)p(x)\\  &amp;=\sum_{x} p^2(x)\\  &amp;=\Pr(X = X')  \end{align*}  $$</span> 所以 <span class="math inline">2<sup>−<em>H</em>(<em>X</em>)</sup> ≤ Pr (<em>X</em> = <em>X</em><sup>′</sup>)</span>，当且仅当 <span class="math inline"><em>X</em></span>服从均匀分布时，Jensen不等式取等，上式等号成立。</li></ul></li><li>设 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>X</em><sup>′</sup></span> 相互独立，且 <span class="math inline"><em>X</em> ∼ <em>p</em>(<em>x</em>)</span>，<span class="math inline"><em>X</em><sup>′</sup> ∼ <em>r</em>(<em>x</em>)</span>，<span class="math inline"><em>x</em>, <em>x</em><sup>′</sup> ∈ 𝒳</span>，则<span class="math display">$$\Pr(X = X') \geq 2^{-H(p)-D(p||r)}\\\Pr(X = X') \geq 2^{-H(r)-D(r||p)}$$</span><ul><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  2^{-H(p)-D(p||r)}&amp;=2^{\sum p(x)\log p(x)+\sum p(x)\log\frac{r(x)}{p(x)}}\\  &amp;=2^{\sum p(x)\log r(x)}\\  &amp;\leq \sum p(x)2^{\log r(x)}\\  &amp;=\sum p(x)r(x)\\  &amp;=\Pr(X = X')  \end{align*}  $$</span></li></ul></li></ol></li><li><p><strong>例题</strong>：<img src="image-118.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="离散序列信源的熵">2.4 离散序列信源的熵</h2><h3 id="离散无记忆信源的序列熵">离散无记忆信源的序列熵</h3><ul><li><p>随机序列<span class="math inline"><em>X⃗</em> = (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub>)</span>，其中<span class="math inline"><em>X</em><sub><em>l</em></sub> ∈ {<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>n</em></sub>}</span>，<span class="math inline"><em>l</em> = 1, 2, ⋯, <em>L</em></span></p></li><li><p><span class="math inline">$p(\vec{X}=\vec{x_{i}}) = p(X_1 =x_{i1}, X_2 = x_{i2}, \cdots, X_L = x_{iL})$</span>，这里<span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em><sup><em>L</em></sup></span>，<span class="math inline"><em>i</em><sub><em>l</em></sub> = 1, 2, ⋯, <em>n</em></span></p></li><li><p><strong>定义信息熵<span class="math inline"><em>H</em>(<em>X⃗</em>)</span>为</strong>： <span class="math display">$$  \begin{align*}  H(\vec{X}) &amp;= -\sum_{i = 1}^{n^L}p(\vec{x_{i}})\logp(\vec{x_{i}})\\  &amp;=-\sum_{i_1 = 1}^{n}\sum_{i_2 = 1}^{n}\cdots\sum_{i_L =1}^{n}p(x_{i1}, x_{i2}, \cdots, x_{iL})\log p(x_{i1}, x_{i2}, \cdots,x_{iL})  \end{align*}  $$</span></p></li><li><p><span class="math display">$$\begin{align*}p(\vec{X}=\vec{x_{i}})&amp;=p(x_{i1}, x_{i2}, \cdots, x_{iL})\\&amp;=p(x_{i1})p(x_{i2}|x_{i1})p(x_{i3}|x_{i1}x_{i2})\cdotsp(x_{iL}|x_{i1}x_{i2}\cdots x_{iL - 1})\\&amp;\overset{无记忆}{=}p(x_{i1})p(x_{i2})\cdots p(x_{iL})\end{align*}$$</span> 则 <span class="math display">$$\begin{align*}H(\vec{X})&amp;=-\sum_{i_1 = 1}^{n}\sum_{i_2 = 1}^{n}\cdots\sum_{i_L =1}^{n}p(x_{i1})p(x_{i2})\cdots p(x_{iL})[\log p(x_{i1})+\log p(x_{i2})\\&amp;\quad +\cdots+\log p(x_{iL})]\\&amp;=-\sum_{i_1 = 1}^{n}p(x_{i1})\sum_{i_2 =1}^{n}p(x_{i2})\cdots\sum_{i_L = 1}^{n}p(x_{iL})\log p(x_{i1}) \quad\leftarrow H(X_1)\\&amp;\quad -\sum_{i_1 = 1}^{n}p(x_{i1})\sum_{i_2 =1}^{n}p(x_{i2})\cdots\sum_{i_L = 1}^{n}p(x_{iL})\log p(x_{i2}) \quad\leftarrow H(X_2)\\&amp;\quad -\cdots\\&amp;=H(X_1)+H(X_2)+\cdots+H(X_L)\\&amp;=\sum_{l = 1}^{L}H(X_l)\end{align*}$$</span></p></li><li><p>若信源是平稳的，即<span class="math inline"><em>H</em>(<em>X</em><sub>1</sub>) = <em>H</em>(<em>X</em><sub>2</sub>) = ⋯ = <em>H</em>(<em>X</em><sub><em>L</em></sub>) = <em>H</em>(<em>X</em>)</span>，则<span class="math display"><em>H</em>(<em>X⃗</em>) = <em>L</em><em>H</em>(<em>X</em>)</span><strong>用 <span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>)</span>表示长度为 <span class="math inline"><em>L</em></span>的序列平均每个符号的熵</strong>，则 <span class="math display">$$H_L(\vec{X})=\frac{1}{L}H(\vec{X}) =H(X)$$</span></p></li><li><p>例题：<img src="image-119.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h3 id="离散有记忆信源的序列熵">离散有记忆信源的序列熵</h3><ul><li>长度为 <span class="math inline"><em>L</em></span> 的符号序列 <span class="math inline"><em>X⃗</em> = (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub>)</span><span class="math display">$$  \begin{align*}  H(\vec{X})&amp;=H(X_1,X_2,X_3,\cdots,X_L)\\  &amp;=H(X_1)+H(X_2|X_1)+H(X_3|X_1X_2)+\cdots+H(X_L|X_1X_2,\cdots,X_{L- 1})  \end{align*}  $$</span></li><li>记作 <span class="math display">$$H(\vec{X}) = H(X^L)=\sum_{l =1}^{L}H(X_l|X^{l - 1})$$</span></li><li>平均每个符号的熵 <span class="math display">$$H_L(\vec{X})=\frac{1}{L}H(X^L)$$</span></li><li>例题：<img src="image-120.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h3 id="离散平稳信源序列熵">离散平稳信源序列熵</h3><h4 id="定义-2">定义</h4><ul><li><strong>离散平稳信源</strong>：联合概率具有时间推移不变性。 <span class="math display"><em>p</em>{<em>X</em><sub><em>i</em>1</sub> = <em>x</em><sub>1</sub>, <em>X</em><sub><em>i</em>2</sub> = <em>x</em><sub>2</sub>, ⋯, <em>X</em><sub><em>i</em><em>L</em></sub> = <em>x</em><sub><em>L</em></sub>} = <em>p</em>{<em>X</em><sub><em>i</em>1 + <em>k</em></sub> = <em>x</em><sub>1</sub>, <em>X</em><sub><em>i</em>2 + <em>k</em></sub> = <em>x</em><sub>2</sub>, ⋯, <em>X</em><sub><em>i</em><em>L</em> + <em>k</em><em>h</em></sub> = <em>x</em><sub><em>L</em></sub>}</span></li></ul><h4 id="结论-1">结论</h4><ol type="1"><li><span class="math inline"><em>H</em>(<em>X</em><sub><em>L</em></sub>|<em>X</em><sup><em>L</em> − 1</sup>)</span>是 <span class="math inline"><em>L</em></span> 的单调非增函数<ul><li>依据：条件多的熵小于等于条件少的熵，平稳信源联合/条件概率时间推移不变</li><li><strong>证明</strong>：<span class="math display">$$  \begin{align*}  H(X_L|X_1X_2\cdots X_{L - 1})&amp;\leq H(X_L|X_2X_3\cdots X_{L - 1})\\  &amp;= H(X_{L - 1}|X_1X_2\cdots X_{L - 2}) \text{（平稳性）}\\  &amp;\leq H(X_{L - 1}|X_2\cdots X_{L - 2})\\  &amp;= H(X_{L - 2}|X_1\cdots X_{L - 3})\\  &amp;\vdots\\  &amp;\leq H(X_2|X_1)  \end{align*}  $$</span></li></ul></li><li><span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>) ≥ <em>H</em>(<em>X</em><sub><em>L</em></sub>|<em>X</em><sup><em>L</em> − 1</sup>)</span><ul><li><strong>证明</strong>：<span class="math display">$$  \begin{align*}  H_L(\vec{X})&amp;=\frac{1}{L}H(X_1,X_2,\cdots,X_L)\\  &amp;=\frac{1}{L}\sum_{l = 1}^{L}H(X_l|X^{l - 1})\\  &amp;=\frac{1}{L}(H(X_1)+H(X_2|X_1)+H(X_3|X_1,X_2)+\cdots+H(X_L|X_1X_2,\cdots,X_{L- 1}))\\  &amp;\geq\frac{1}{L}\cdot L\cdot H(X_L|X_1,X_2,\cdots,X_{L - 1})\\  &amp;= H(X_L|X_1,X_2,\cdots,X_{L - 1})  \end{align*}  $$</span></li></ul></li><li><span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>)</span>是 <span class="math inline"><em>L</em></span> 的单调非增函数<ul><li><strong>证明</strong>：<span class="math display">$$  \begin{align*}  L H_L(\vec{X})&amp;=H(X_1,X_2,\cdots,X_L)\\  &amp;=H(X_1,X_2,\cdots,X_{L - 1})+H(X_L|X_1,X_2,\cdots,X_{L - 1})\\  &amp;=(L - 1)H_{L - 1}(\vec{X})+H(X_L|X_1,X_2,\cdots,X_{L - 1})\\  &amp;\leq (L - 1)H_{L - 1}(\vec{X})+H_L(\vec{X})\\  \therefore (L - 1)H_L(\vec{X})&amp;\leq (L - 1)H_{L - 1}(\vec{X})\\  H_L(\vec{X})&amp;\leq H_{L - 1}(\vec{X})  \end{align*}  $$</span></li></ul></li><li>当 <span class="math inline"><em>L</em> → ∞</span> 时，定义<span class="math inline"><em>H</em><sub>∞</sub>(<em>X⃗</em>)</span>为<strong>极限熵</strong>，有<span class="math display"><em>H</em><sub>∞</sub>(<em>X⃗</em>) ≜ lim<sub><em>L</em> → ∞</sub><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>) = lim<sub><em>L</em> → ∞</sub><em>H</em>(<em>X</em><sub><em>L</em></sub>|<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em> − 1</sub>)</span><ul><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  H_{L + k}(\vec{X})&amp;=\frac{1}{L + k}[H(X_1,X_2,\cdots,X_{L -1})+H(X_L|X_1X_2\cdots X_{L - 1})+\\  &amp;\quad \cdots + H(X_{L + k}|X_1X_2\cdots X_{L + k - 1})]\\  &amp;\leq\frac{1}{L + k}[H(X_1,X_2,\cdots,X_{L -1})+H(X_L|X_1X_2\cdots X_{L - 1})+\\  &amp;\quad H(X_L|X_1X_2,\cdots,X_{L - 1})+\cdots + H(X_L|X_1\cdotsX_{L - 1})]\\  &amp;=\frac{1}{L + k}H(X_1,X_2,\cdots,X_{L - 1})+\frac{k + 1}{L +k}H(X_L|X_1,X_2,\cdots,X_{L - 1})  \end{align*}  $$</span> 当 <span class="math inline"><em>k</em> → ∞</span> 时，<span class="math inline">lim<sub><em>k</em> → ∞</sub><em>H</em><sub><em>L</em> + <em>k</em></sub>(<em>X⃗</em>) ≤ <em>H</em>(<em>X</em><sub><em>L</em></sub>|<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em> − 1</sub>) ≤ <em>H</em><sub><em>L</em></sub>(<em>X⃗</em>)</span>当 <span class="math inline"><em>L</em> → ∞</span> 时，<span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>) = <em>H</em><sub><em>L</em> + <em>k</em></sub>(<em>X⃗</em>)</span>，得到<span class="math display">lim<sub><em>L</em> → ∞</sub><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>) = lim<sub><em>L</em> → ∞</sub><em>H</em>(<em>X</em><sub><em>L</em></sub>|<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em> − 1</sub>)</span></p><p>若<span class="math inline"><em>H</em><sub>0</sub>(<em>X</em>)</span>为等概率无记忆信源单个符号熵，有 <span class="math display"><em>H</em><sub>0</sub>(<em>X</em>) ≥ <em>H</em><sub>1</sub>(<em>X</em>) ≥ <em>H</em><sub>2</sub>(<em>X⃗</em>) ≥ <em>H</em><sub>3</sub>(<em>X⃗</em>)⋯ ≥ <em>H</em><sub>∞</sub>(<em>X⃗</em>)</span></p><p><strong>只有极限熵最真实地反映信源的实际情况。</strong></p></li></ul></li></ol><h3 id="马尔可夫信源的极限熵">马尔可夫信源的极限熵</h3><ul><li><p><strong>定义</strong>： <span class="math display"><em>H</em><sub>∞</sub>(<em>X⃗</em>) = lim<sub><em>L</em> → ∞</sub><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>) = lim<sub><em>L</em> → ∞</sub><em>H</em>(<em>X</em><sub><em>L</em></sub>|<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em> − 1</sub>)</span></p></li><li><p>实际常取有限长度 <span class="math inline"><em>L</em></span>下的条件熵 <span class="math inline"><em>H</em>(<em>X</em><sub><em>L</em></sub>|<em>X</em><sup><em>L</em> − 1</sup>)</span>作为 <span class="math inline"><em>H</em><sub>∞</sub>(<em>X⃗</em>)</span>的近似值。</p></li><li><p><strong>m阶马尔可夫信源（齐次）的推导</strong> <span class="math display"><em>p</em>(<em>X</em><sub><em>t</em></sub>|<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>t</em> − 1</sub>) = <em>p</em>(<em>X</em><sub><em>t</em></sub>|<em>X</em><sub><em>t</em> − <em>m</em></sub>, ⋯, <em>X</em><sub><em>t</em> − 1</sub>)</span><span class="math display">$$  \begin{align*}  H_{\infty}(\vec{X})&amp;=\lim_{L \to \infty} H(X_L|X_1,X_2,\cdots,X_{L- 1}) \\  &amp;= \lim_{L \to \infty} H(X_L|X_{L - m},\cdots,X_{L - 1})\\  &amp;=H(X_{m + 1}|X_1,X_2,\cdots,X_m)  \end{align*}  $$</span></p><p>对于齐次、稳定马尔可夫链，其状态 <span class="math inline"><em>s</em><sub><em>i</em></sub></span> 由 <span class="math inline">(<em>x</em><sub><em>i</em>1</sub>, <em>x</em><sub><em>i</em>2</sub>, ⋯, <em>x</em><sub><em>i</em><em>m</em></sub>)</span>唯一确定，所以 <span class="math display"><em>p</em>(<em>x</em><sub><em>i</em><sub><em>m</em> + 1</sub></sub>|<em>x</em><sub><em>i</em>1</sub>, <em>x</em><sub><em>i</em>2</sub>, ⋯, <em>x</em><sub><em>i</em><em>m</em></sub>) = <em>p</em>(<em>x</em><sub><em>i</em><sub><em>m</em> + 1</sub></sub>|<em>s</em><sub><em>i</em></sub>)</span></p><p>上式两边同时取对数，并对 <span class="math inline"><em>x</em><sub><em>i</em>1</sub>, ⋯, <em>x</em><sub><em>i</em><em>m</em></sub>, <em>x</em><sub><em>i</em><sub><em>m</em> + 1</sub></sub></span>和 <span class="math inline"><em>s</em><sub><em>i</em></sub></span>取统计平均，再取负，得到：</p><p><span class="math display">$$  \begin{align*}  \mathbf{Left}&amp;=-\sum_{i_1,\cdots,i_{m + 1}}p(x_{i1},x_{i2},\cdots,x_{im},x_{i_{m + 1}},s_i) \log p(x_{i_{m +1}}|x_{i1},x_{i2},\cdots,x_{im})\\  &amp;=-\sum_{i_1,\cdots,i_{m + 1}} p(x_{i1},\cdots,x_{i_{m + 1}}) \logp(x_{i_{m + 1}}|x_{i1},\cdots,x_{im})\\  &amp;=H(X_{m + 1}|X_1,X_2,\cdots,X_m)\\  &amp;=H_{\infty}(\vec{X})\\  \mathbf{Right}&amp;=-\sum_{i_1,\cdots,i_{m + 1};i}p(x_{i1},x_{i2},\cdots,x_{i_{m + 1}},s_i) \log p(x_{i_{m + 1}}|s_i)\\  &amp;=-\sum_{i_1,\cdots,i_{m + 1};i}p(x_{i1},x_{i2},\cdots,x_{im},s_i) p(x_{i_{m +1}}|x_{i1},x_{i2},\cdots,x_{im},s_i) \log p(x_{i_{m + 1}}|s_i)\\  &amp;=-\sum_{i_{m + 1}} \sum_{i} p(s_i) p(x_{i_{m + 1}}|s_i) \logp(x_{i_{m + 1}}|s_i)\\  &amp;=\sum_{i} p(s_i) \sum_{i_{m + 1}} p(x_{i_{m + 1}}|s_i) \log\frac{1}{p(x_{i_{m + 1}}|s_i)}\\  &amp;=\sum_{i} p(s_i) H(X|s_i)  \end{align*}  $$</span></p><p><span class="math display">$$  \begin{align*}  \therefore H_{\infty}(\vec{X}) &amp;= \sum_{i} p(s_i) H(X|s_i)\\  H(X|s_i)&amp;=-\sum_{j} p(x_j|s_i)\log p(x_j|s_i) \\  &amp;= -\sum_{j} p(s_j|s_i)\log p(s_j|s_i)  \end{align*}  $$</span></p></li><li><p>例题： <img src="image-10.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="连续信源的熵和互信息">2.5 连续信源的熵和互信息</h2><h3 id="微分熵连续信源熵">微分熵（连续信源熵）</h3><ul><li>详见 <strong><a href="Ch2sup_微分熵.md">第二章补充微分熵</a></strong></li><li>微分熵即连续信源熵，记作 <span class="math inline"><em>h</em>(<em>X</em>)</span> 或 <span class="math inline"><em>H</em><sub><em>c</em></sub>(<em>X</em>)</span>。</li></ul><h3 id="幅度连续的单符号信源">幅度连续的单符号信源</h3><h4 id="连续信源熵">连续信源熵</h4><ul><li><strong>定义</strong>：<ul><li>用n个离散变量逼近连续变量，概率密度函数为 <span class="math inline"><em>P</em><sub><em>X</em></sub>(<em>x</em>)</span><ul><li><figure><img src="image-8.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul></li><li>设 <span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>) = ∫<sub><em>a</em> + (<em>i</em> − 1)<em>Δ</em><em>x</em></sub><sup><em>a</em> + <em>i</em><em>Δ</em><em>x</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em> = <em>P</em><sub><em>X</em></sub>(<em>x</em><sub><em>i</em></sub>)<em>Δ</em><em>x</em></span></li><li>离散熵 <span class="math display">$$H_n(X)=-\sum_{i =1}^{n}p(x_i)\log p(x_i)=-\sum_{i = 1}^{n}P_X(x_i)\Delta x\log(P_X(x_i)\Delta x)$$</span></li><li>当 <span class="math inline"><em>n</em> → ∞</span>，<span class="math inline"><em>Δ</em><em>x</em> → 0</span> 时： <span class="math display"><em>H</em>(<em>X</em>) = lim<sub><em>n</em> → ∞</sub><em>H</em><sub><em>n</em></sub>(<em>X</em>) = −∫<sub><em>a</em></sub><sup><em>b</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)log <em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em> − lim<sub><em>Δ</em><em>x</em> → 0</sub>log <em>Δ</em><em>x</em>∫<sub><em>a</em></sub><sup><em>b</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em></span>其中 <span class="math inline">∫<sub><em>a</em></sub><sup><em>b</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em> = 1</span>，后一项趋于无穷大。</li><li><strong>定义连续信源熵为</strong> <span class="math display"><em>H</em><sub><em>c</em></sub>(<em>X</em>) = −∫<sub>−∞</sub><sup>∞</sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)log <em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em></span></li></ul></li><li><strong>性质</strong>：<ul><li>连续信源不确定度为无穷大，熵为无穷大，需要无限多位二进制数表示。</li><li>连续信源的熵具有相对性（只有相对意义），在取两熵之差时才具有信息的所有特征。</li></ul></li></ul><h4 id="联合熵条件熵和互信息">联合熵、条件熵和互信息</h4><ul><li><strong>联合熵</strong>： <span class="math display"><em>H</em><sub><em>c</em></sub>(<em>X</em>, <em>Y</em>) = −∫<sub>−∞</sub><sup>∞</sup>∫<sub>−∞</sub><sup>∞</sup><em>P</em><sub><em>X</em>, <em>Y</em></sub>(<em>x</em>, <em>y</em>)log <em>P</em><sub><em>X</em>, <em>Y</em></sub>(<em>x</em>, <em>y</em>)<em>d</em><em>x</em><em>d</em><em>y</em></span></li><li><strong>条件熵</strong>： <span class="math display"><em>H</em><sub><em>c</em></sub>(<em>Y</em>|<em>X</em>) = −∫<sub>−∞</sub><sup>∞</sup>∫<sub>−∞</sub><sup>∞</sup><em>P</em><sub><em>X</em>, <em>Y</em></sub>(<em>x</em>, <em>y</em>)log <em>P</em><sub><em>Y</em></sub>(<em>y</em>|<em>x</em>)<em>d</em><em>x</em><em>d</em><em>y</em></span><span class="math display"><em>H</em><sub><em>c</em></sub>(<em>X</em>, <em>Y</em>) = <em>H</em><sub><em>c</em></sub>(<em>X</em>) + <em>H</em><sub><em>c</em></sub>(<em>Y</em>|<em>X</em>) = <em>H</em><sub><em>c</em></sub>(<em>Y</em>) + <em>H</em><sub><em>c</em></sub>(<em>X</em>|<em>Y</em>)</span></li><li><strong>互信息</strong>： <span class="math display">$$  \begin{align*}  I(X;Y)=I(Y;X)&amp;=H_c(X)-H_c(X|Y)\\  &amp;=H_c(Y)-H_c(Y|X)\\  &amp;=H_c(X)+H_c(Y)-H_c(X,Y)  \end{align*}  $$</span></li></ul><h3 id="波形信源的熵">波形信源的熵</h3><ul><li>平稳随机过程通过采样变换可得到平稳随机序列，例如：<ul><li>随机过程 <span class="math inline"><em>x</em>(<em>t</em>)</span>变换为 <span class="math inline"><em>X⃗</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub>)</span>。</li><li>随机过程 <span class="math inline"><em>y</em>(<em>t</em>)</span>变换为 <span class="math inline"><em>Y⃗</em>(<em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>L</em></sub>)</span>。</li></ul></li><li><figure><img src="image-9.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li>相关熵的计算公式如下：<ul><li><span class="math inline">$H_c(\vec{X}) = H_c(X_1, X_2, \cdots,X_L)=-\int_{\vec{R}} P_{\vec{X}}(\vec{x})\logP_{\vec{X}}(\vec{x})d\vec{x_{}}$</span></li><li><span class="math inline">$H_c(\vec{Y}|\vec{X}) = H_c(Y_1, Y_2,\cdots, Y_L|X_1, X_2, \cdots, X_L)=-\int_{\vec{R}}\int_{\vec{R}}P_{\vec{X}\vec{Y}}(\vec{x}, \vec{y})\logP_{\vec{Y}}(\vec{y}|\vec{x})d\vec{x}d\vec{y_{}}$</span></li></ul></li><li>波形信源熵由上述各项的极限表达式（<span class="math inline"><em>L</em> → ∞</span> ）给出：<ul><li><span class="math inline"><em>H</em><sub><em>c</em></sub>(<em>x</em>(<em>t</em>)) ≜ lim<sub><em>L</em> → ∞</sub><em>H</em><sub><em>c</em></sub>(<em>X⃗</em>)</span></li><li><span class="math inline"><em>H</em><sub><em>c</em></sub>(<em>y</em>(<em>t</em>)|<em>x</em>(<em>t</em>)) ≜ lim<sub><em>L</em> → ∞</sub><em>H</em><sub><em>c</em></sub>(<em>Y⃗</em>|<em>X⃗</em>)</span></li></ul></li><li>对于<strong>限频 <span class="math inline"><em>f</em><sub><em>m</em></sub></span>，限时 <span class="math inline"><em>t</em><sub><em>B</em></sub></span></strong>的平稳随机过程，可用 <span class="math inline"><em>L</em> = 2<em>f</em><sub><em>m</em></sub><em>t</em><sub><em>B</em></sub></span>随机矢量表示，且有： <span class="math display">$$  \begin{align*}  H_c(\vec{X}) =&amp; H_c(X_1, X_2, \cdots, X_L)\\  =&amp;H_c(X_1)+H_c(X_2|X_1)+H_c(X_3|X_1X_2)+\\  &amp;\cdots+H_c(X_L|X_1,X_2,\cdots,X_{L - 1})\\  \leq&amp; H_c(X_1)+H_c(X_2)+\cdots + H_c(X_L)  \end{align*}  $$</span></li></ul><h3 id="最大熵定理连续信源">最大熵定理(连续信源)</h3><ol type="1"><li><strong>无限制条件时</strong>：<strong>最大熵为无穷大</strong>。</li><li><strong>限峰功率最大熵定理</strong><ul><li><strong>对于定义域为有限的随机变量 <span class="math inline"><em>X</em></span>，当它是均匀分布时，具有最大熵。</strong></li><li><span class="math inline"><em>X</em></span> 幅度取值限制在 <span class="math inline">[<em>a</em>, <em>b</em>]</span>，有 <span class="math inline">∫<sub><em>a</em></sub><sup><em>b</em></sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em> = 1</span>。</li><li>当 <span class="math inline">$P_X(x)=\begin{cases}\frac{1}{b -a},&amp;a\leq x\leq b\\0,&amp;其他\end{cases}$</span> 时，信息熵最大，<span class="math display">$$H_c(X)=-\int_{a}^{b}\frac{1}{b -a}\log\frac{1}{b - a}dx=\log(b - a)$$</span></li></ul></li><li><strong>限平均功率最大熵定理</strong><ul><li><p><strong>对于相关矩阵一定的随机变量 <span class="math inline"><em>X</em></span>，当它是正态分布时具有最大熵。</strong></p></li><li><p>概率密度函数 <span class="math inline">$P_X(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x -\mu)^2}{2\sigma^2}}$</span></p><ul><li>其中 <span class="math inline"><em>μ</em></span> 为均值，<span class="math inline"><em>σ</em><sup>2</sup></span> 为方差，<span class="math inline"><em>σ</em><sup>2</sup> = ∫(<em>x</em> − <em>μ</em>)<sup>2</sup><em>P</em><sub><em>X</em></sub>(<em>x</em>)<em>d</em><em>x</em></span>。</li></ul></li><li><p>信息熵 <span class="math inline"><em>H</em><sub><em>c</em></sub>(<em>X</em>)</span>的计算过程如下： <span class="math display">$$\begin{align*}H_c(X)&amp;=-\int_{-\infty}^{+\infty}P_X(x)\log P_X(x)dx\\&amp;=E[-\log P_X(x)]\\&amp;=E\left[-\log\frac{1}{\sqrt{2\pi\sigma^2}}-\log e^{-\frac{(x -m)^2}{2\sigma^2}}\right]\\&amp;=E\left[\frac{1}{2}\log(2\pi\sigma^2)+\frac{(x -m)^2}{2\sigma^2}\log e\right]\\&amp;=\frac{1}{2}\log(2\pi\sigma^2)+\frac{\log e}{2}\\&amp;=\frac{1}{2}\log(2\pi e\sigma^2)\end{align*}$$</span></p></li><li><p><strong>证明</strong>： 设 <span class="math inline"><em>φ</em>(<em>x</em>) ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span>，<span class="math inline"><em>g</em>(<em>x</em>)</span> 满足 <span class="math inline">∫<em>x</em><sup>2</sup><em>g</em>(<em>x</em>)<em>d</em><em>x</em> = <em>σ</em><sup>2</sup></span>，因为 <span class="math inline"><em>D</em>(<em>g</em>(<em>x</em>)∥<em>φ</em>(<em>x</em>)) ≥ 0</span>，即：<span class="math display">$$  \begin{align*}  D(g(x)\|\varphi(x))&amp;=\int_{-\infty}^{+\infty}g(x)\log\frac{g(x)}{\varphi(x)}dx\\  &amp;=\int_{-\infty}^{+\infty}g(x)\logg(x)dx-\int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx\\  &amp;=-H_c(g(x))-\int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx\\  &amp;\geq0\\  \therefore \quadH_c(g(x))&amp;\leq-\int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx  \end{align*}  $$</span></p><p>又因为</p><p><span class="math display">$$  \begin{align*}  \int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx &amp;=\int_{-\infty}^{+\infty}g(x)\log\left(\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}\right)dx\\  &amp;=\int_{-\infty}^{+\infty}g(x)\left[-\frac{1}{2}\log(2\pi\sigma^2)-\frac{x^2}{2\sigma^2}\loge\right]dx\\  &amp;=-\frac{1}{2}\log(2\pi\sigma^2)\int_{-\infty}^{+\infty}g(x)dx-\frac{\loge}{2\sigma^2}\int_{-\infty}^{+\infty}x^2g(x)dx\\  &amp;=-\frac{1}{2}\log(2\pi e\sigma^2)  \end{align*}  $$</span></p><p>所以 <span class="math inline">$H_c(g(x))\leq\frac{1}{2}\log(2\pie\sigma^2)=H_c(\varphi(x))$</span>，当且仅当 <span class="math inline"><em>g</em>(<em>x</em>) = <em>φ</em>(<em>x</em>)</span>，为正态分布时等号成立。</p></li></ul></li></ol><h2 id="信源的冗余度">2.6 信源的冗余度</h2><ul><li><p>冗余度也称多余度或剩余度，表示给定信源在实际发出消息时所包含的多余信息。</p></li><li><p><strong>例子</strong>：英文字母26个，加上空格共27个符号，则<strong>单符号最大熵</strong>为<span class="math display"><em>H</em><sub>0</sub>(<em>X</em>) = log<sub>2</sub>27 ≈ 4.76bit/符号</span></p><p>对英文书中各符号出现的概率加以统计，可得一组数值。若字母间无记忆，有<span class="math display">$$H_1(X)= - \sum_{i = 1}^{n}p_i\log p_i =4.03 \text{ bit/符号}$$</span></p><p>若考虑2阶、3阶直至高阶平稳信源，有 <span class="math display">$$  \begin{align*}  &amp;H_2(X)= 3.32 \text{ bit/符号}\\  &amp;H_3(X)= 3.1 \text{ bit/符号}\\  &amp;\cdots\\  &amp;H_{\infty}(X)=1.4 \text{ bit/符号}\\  \end{align*}  $$</span></p><p>且满足 <span class="math inline"><em>H</em><sub>∞</sub> &lt; ⋯ &lt; <em>H</em><sub>3</sub>(<em>X</em>) &lt; <em>H</em><sub>2</sub>(<em>X</em>) &lt; <em>H</em><sub>1</sub>(<em>X</em>) &lt; <em>H</em><sub>0</sub>(<em>X</em>)</span></p><p>若发送消息时用 <span class="math inline"><em>H</em><sub>0</sub>(<em>X</em>) = 4.76 bit</span>表示一个信源符号，则信源效率为 <span class="math display">$$\eta =\frac{H_{\infty}(X)}{H_0(X)}=\frac{1.4}{4.76}\approx0.29$$</span></p><p>冗余度<span class="math display"><em>γ</em> = 1 − <em>η</em> = 0.71</span></p><p>这是因为符号间的相关性、分布不均匀性</p></li><li><p><strong>信源编码</strong>：压缩冗余，提高传输效率</p></li><li><p><strong>信道编码</strong>：加入特殊的冗余，抗干扰，提高可靠性</p></li></ul><h1 id="第二章补充-微分熵">第二章补充 微分熵</h1><h2 id="微分熵预备知识">微分熵预备知识</h2><h3 id="定义-3">定义</h3><ol type="1"><li><strong>随机变量 <span class="math inline"><em>X</em></span> 的均值<span class="math inline"><em>μ</em></span></strong>：<ul><li>定义为 <span class="math display"><em>μ</em> = <em>E</em>(<em>X</em>) = ∫<em>x</em><em>f</em>(<em>x</em>)<em>d</em><em>x</em></span>其中 <span class="math inline"><em>f</em>(<em>x</em>)</span> 为 <span class="math inline"><em>X</em></span> 的概率密度函数。</li></ul></li><li><strong>随机变量 <span class="math inline"><em>X</em></span>的方差</strong>：<ul><li>定义为 <span class="math display">$$  \begin{align*}  Var(X)&amp;=E(X - EX)^2 \\  &amp;= E(X - \mu)^2\\  &amp;=E(X^{2}-2X\mu+\mu^{2})\\  &amp;=E(X^{2})-\mu^{2}  \end{align*}  $$</span></li></ul></li><li><strong>两个随机变量 <span class="math inline"><em>X</em></span> 和<span class="math inline"><em>Y</em></span> 之间的协方差</strong>：<ul><li>定义为 <span class="math display"><em>C</em><em>o</em><em>v</em>(<em>X</em>, <em>Y</em>) = <em>E</em>(<em>X</em> − <em>E</em><em>X</em>)(<em>Y</em> − <em>E</em><em>Y</em>) = <em>E</em>(<em>X</em><em>Y</em>) − <em>μ</em><sub><em>X</em></sub><em>μ</em><sub><em>Y</em></sub></span></li></ul></li><li><strong>对于随机变量 <span class="math inline"><em>X⃗</em> = [<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub>]<sup><em>T</em></sup></span>（列向量）</strong>：<ul><li>其<strong>协方差矩阵</strong>定义为 <span class="math display"><em>K</em><sub><em>X⃗</em></sub> = <em>E</em>(<em>X⃗</em> − <em>E</em><em>X⃗</em>)(<em>X⃗</em> − <em>E</em><em>X⃗</em>)<sup><em>T</em></sup> = [<em>C</em><em>o</em><em>v</em>(<em>X</em><sub><em>i</em></sub>, <em>X</em><sub><em>j</em></sub>)]</span></li><li>其<strong>相关矩阵</strong>定义为 <span class="math display"><em>K̃</em><sub><em>X⃗</em></sub> = <em>E</em>(<em>X⃗</em><em>X⃗</em><sup><em>T</em></sup>) = [<em>E</em>(<em>X</em><sub><em>i</em></sub><em>X</em><sub><em>j</em></sub>)]</span></li><li>若 <span class="math inline">$E(\vec{X})=\vec{\mu}=\vec{0_{}}$</span>，则 <span class="math inline"><em>K</em><sub><em>X⃗</em></sub> = <em>K̃</em><sub><em>X⃗</em></sub></span></li></ul></li><li><strong>高斯分布</strong></li></ol><ul><li><p>令 <span class="math inline"><em>N</em>(<em>μ</em>, <em>σ</em><sup>2</sup>)</span>表示均值为 <span class="math inline"><em>μ</em></span>，方差为 <span class="math inline"><em>σ</em><sup>2</sup></span>的<strong>高斯（正态）分布</strong>，即它的概率密度函数为 <span class="math display">$$f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{(x- \mu)^{2}}{2\sigma^{2}}}$$</span></p></li><li><p>令 <span class="math inline"><em>N</em>(<em>μ⃗</em>, <em>K</em>)</span> 表示均值为<span class="math inline"><em>μ⃗</em></span>，协方差矩阵为 <span class="math inline"><em>K</em></span>的<strong>多元高斯分布</strong>，即对所有的 <span class="math inline"><em>x⃗</em> ∈ <em>R</em><sup><em>n</em></sup></span>，其联合概率密度函数为<span class="math display">$$f(\vec{x})=\frac{1}{(\sqrt{2\pi})^n|K|^{\frac{1}{2}}}e^{-\frac{1}{2}(\vec{x}-\vec{\mu})^TK^{-1}(\vec{x}-\vec{\mu})}$$</span></p><p>其中 <span class="math inline">|<em>K</em>|</span> 表示 <span class="math inline"><em>K</em></span> 的行列式值，<span class="math inline"><em>K</em></span> 是正定对称矩阵。</p></li></ul><h3 id="基本结论">基本结论</h3><ul><li>以下是关于矩阵和随机变量的线性变换的基本结论。所有的量和相关矩阵都假定为实值</li></ul><h4 id="定义-4">定义</h4><ul><li><strong>定义（对称矩阵）</strong>：如果 <span class="math inline"><em>K</em><sup><em>T</em></sup> = <em>K</em></span>，则称矩阵<span class="math inline"><em>K</em></span> 是对称的。</li><li><strong>定义（正定矩阵）</strong>：<ul><li>一个 <span class="math inline"><em>n</em> × <em>n</em></span> 矩阵<span class="math inline"><em>K</em></span>，如果对所有非零 <span class="math inline"><em>n</em></span> 维列向量 <span class="math inline">$\vec{x_{}}$</span>，<span class="math inline"><em>x⃗</em><sup><em>T</em></sup><em>K</em><em>x⃗</em> &gt; 0</span>成立，则称矩阵 <span class="math inline"><em>K</em></span>为正定的；</li><li>如果对所有 <span class="math inline"><em>n</em></span> 维列向量<span class="math inline">$\vec{x_{}}$</span>，<span class="math inline"><em>x⃗</em><sup><em>T</em></sup><em>K</em><em>x⃗</em> ≥ 0</span>成立，则称矩阵 <span class="math inline"><em>K</em></span>为半正定的。</li></ul></li></ul><h4 id="命题">命题</h4><ol type="1"><li><strong>命题1</strong>：<ul><li><strong>协方差（相关）矩阵是对称且半正定的。</strong></li><li>如果矩阵 <span class="math inline"><em>K</em></span>是对称的，则它可以对角化为 <span class="math inline"><em>K</em> = <em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup></span>。其中，<span class="math inline"><em>Λ</em></span> 是对角矩阵，<span class="math inline"><em>Q</em></span> 和 <span class="math inline"><em>Q</em><sup><em>T</em></sup></span>是正交矩阵，即 <span class="math inline"><em>Q</em><sup>−1</sup> = <em>Q</em><sup><em>T</em></sup></span>，<span class="math inline">|<em>Q</em>| = |<em>Q</em><sup><em>T</em></sup>| = 1</span>，<span class="math inline"><em>Q</em><em>Q</em><sup><em>T</em></sup> = <em>I</em></span>。<span class="math display"><em>K</em><em>Q</em> = (<em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup>)<em>Q</em> = <em>Q</em><em>Λ</em>(<em>Q</em><sup><em>T</em></sup><em>Q</em>) = <em>Q</em><em>Λ</em></span>令 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 表示<span class="math inline"><em>Λ</em></span> 的第 <span class="math inline"><em>i</em></span> 个对角元素，<span class="math inline">$\vec{q_{i}}$</span> 表示 <span class="math inline"><em>Q</em></span> 的第 <span class="math inline"><em>i</em></span> 列，则： <span class="math display">$$\begin{align*}&amp;K[\vec{q_{1}},\vec{q_{2}},\cdots,\vec{q_{n}}]=[\vec{q_{1}},\vec{q_{2}},\cdots,\vec{q_{n}}]\begin{bmatrix}\lambda_1&amp;&amp; \\ &amp;\ddots&amp; \\ &amp; &amp;\lambda_n\end{bmatrix}\\&amp;K\vec{q_{i}}=\lambda_i\vec{q_{i}}\end{align*}$$</span> 即 <span class="math inline">$\vec{q_{i}}$</span> 是矩阵 <span class="math inline"><em>K</em></span> 对应于特征值 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span>的特征向量。</li></ul></li><li><strong>命题2</strong>：<ul><li><p><strong>半正定矩阵的特征值是非负的</strong>。</p></li><li><p><strong>证明</strong>： 令 <span class="math inline"><em>K</em></span> 表示一个半正定矩阵，<span class="math inline">$\vec{u_{}}$</span> 是矩阵 <span class="math inline"><em>K</em></span> 对应于特征值 <span class="math inline"><em>λ</em></span> 的特征向量，即 <span class="math display">$$K\vec{u}=\lambda\vec{u_{}}$$</span></p><p>由于 <span class="math inline"><em>K</em></span> 是半正定的，有 <span class="math display"><em>u⃗</em><sup><em>T</em></sup><em>K</em><em>u⃗</em> = <em>u⃗</em><sup><em>T</em></sup><em>λ</em><em>u⃗</em> = <em>λ</em><em>u⃗</em><sup><em>T</em></sup><em>u⃗</em> ≥ 0</span></p><p>又因为 <span class="math inline"><em>u⃗</em><sup><em>T</em></sup><em>u⃗</em> &gt; 0</span>，所以有<span class="math inline"><em>λ</em> ≥ 0</span>。</p></li></ul></li><li><strong>命题3</strong>：<ul><li>令 <span class="math inline">$\vec{Y} = A\vec{X_{}}$</span>，其中<span class="math inline">$\vec{X_{}}$</span> 和 <span class="math inline">$\vec{Y_{}}$</span>均为由几个随机变量构成的列向量，<span class="math inline"><em>A</em></span> 是 <span class="math inline"><em>m</em> × <em>n</em></span> 矩阵，则 <span class="math display"><em>K</em><sub><em>Y⃗</em></sub> = <em>A</em><em>K</em><sub><em>X⃗</em></sub><em>A</em><sup><em>T</em></sup></span>且 <span class="math display"><em>K̃</em><sub><em>Y⃗</em></sub> = <em>A</em><em>K̃</em><sub><em>X⃗</em></sub><em>A</em><sup><em>T</em></sup></span></li><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  K_{\vec{Y}}&amp;=E(\vec{Y}-E\vec{Y})(\vec{Y}-E\vec{Y})^T\\  &amp;=E[A(\vec{X}-E\vec{X})][A(\vec{X}-E\vec{X})]^T\\  &amp;=E[A(\vec{X}-E\vec{X})(\vec{X}-E\vec{X})^TA^T]\\  &amp;=A[E(\vec{X}-E\vec{X})(\vec{X}-E\vec{X})^T]A^T\\  &amp;=AK_{\vec{X}}A^T  \end{align*}  $$</span></li></ul></li><li><strong>命题4</strong><ul><li><p>设<span class="math inline">$\vec{X_{}}$</span>和<span class="math inline">$\vec{Y_{}}$</span>均为由<span class="math inline"><em>n</em></span>个随机变量构成的列向量，且满足<span class="math display">$$\vec{Y} = Q^T\vec{X_{}}$$</span> 其中<span class="math inline"><em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup></span>是<span class="math inline"><em>K</em><sub><em>X⃗</em></sub></span>（<span class="math inline">$\vec{X_{}}$</span>的协方差矩阵）的一个对角化。则有<span class="math display"><em>K</em><sub><em>Y⃗</em></sub> = <em>Λ</em></span>即<span class="math inline">$\vec{Y_{}}$</span>中的随机变量是不相关的，且<span class="math inline"><em>V</em><em>a</em><em>r</em>(<em>Y</em><sub><em>i</em></sub>) = <em>λ</em><sub><em>i</em></sub></span>，<span class="math inline"><em>λ</em><sub><em>i</em></sub></span>是<span class="math inline"><em>Λ</em></span>的第<span class="math inline"><em>i</em></span>个对角元素。</p></li><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  K_{\vec{Y}}&amp;=Q^TK_{\vec{X}}Q\\  &amp;=Q^T(Q\Lambda Q^T)Q\\  &amp;=(Q^TQ)\Lambda(Q^TQ)\\  &amp;=\Lambda  \end{align*}  $$</span></p></li><li><p><strong>推论</strong>：设<span class="math inline">$\vec{X_{}}$</span>是由<span class="math inline"><em>n</em></span>个随机变量构成的列向量，且<span class="math inline"><em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup></span>是<span class="math inline"><em>K</em><sub><em>X⃗</em></sub></span>的一个对角化，则<span class="math display">$$\vec{X}=Q\vec{Y_{}}$$</span> 其中<span class="math inline">$\vec{Y}=Q^T\vec{X_{}}$</span>是由<span class="math inline"><em>n</em></span>个不相关的随机变量构成的列向量。</p><ul><li>证明： <span class="math display">$$\vec{X}=QQ^T\vec{X}=Q(Q^T\vec{X})=Q\vec{Y_{}}$$</span></li></ul></li></ul></li><li><strong>命题5</strong><ul><li>设<span class="math inline">$\vec{X_{}}$</span>，<span class="math inline">$\vec{Y_{}}$</span>和<span class="math inline">$\vec{Z_{}}$</span>是由<span class="math inline"><em>n</em></span>个随机变量构成的列向量，<span class="math inline">$\vec{X_{}}$</span>和<span class="math inline">$\vec{Z_{}}$</span>相互独立，且<span class="math inline">$\vec{Y}=\vec{X}+\vec{Z_{}}$</span>，则<span class="math display"><em>K</em><sub><em>Y⃗</em></sub> = <em>K</em><sub><em>X⃗</em></sub> + <em>K</em><sub><em>Z⃗</em></sub></span></li></ul></li><li><strong>命题6</strong><ul><li>设<span class="math inline">$\vec{Y}=Q\vec{X_{}}$</span>，其中<span class="math inline">$\vec{X_{}}$</span>和<span class="math inline">$\vec{Y_{}}$</span>是由<span class="math inline"><em>n</em></span>个随机变量构成的列向量，<span class="math inline"><em>Q</em></span>是一个正交矩阵，则<span class="math display">$$E(\sum_{i = 1}^{n}Y_{i}^{2}) = E(\sum_{i =1}^{n}X_{i}^{2})$$</span> 即随机变量的总能量在正交变换下不变</li><li><strong>证明</strong>： <span class="math display">$$  \begin{align*}  \sum_{i = 1}^{n}Y_{i}^{2}&amp;=\vec{Y}^T\vec{Y}\\  &amp;=(Q\vec{X})^T(Q\vec{X})\\  &amp;=\vec{X}^TQ^TQ\vec{X}\\  &amp;=\vec{X}^T\vec{X}\\  &amp;=\sum_{i = 1}^{n}X_{i}^{2}  \end{align*}  $$</span> 上式两边取期望，得证。</li></ul></li></ol><h2 id="微分熵">微分熵</h2><h3 id="微分熵-1">微分熵</h3><ol type="1"><li><p><strong>定义</strong> 一个概率密度函数为 <span class="math inline"><em>f</em>(<em>x</em>)</span> 的连续随机变量 <span class="math inline"><em>X</em></span> 的微分熵 <span class="math inline"><em>h</em>(<em>X</em>)</span> 定义为 <span class="math display"><em>h</em>(<em>X</em>) = −∫<sub><em>S</em></sub><em>f</em>(<em>x</em>)log <em>f</em>(<em>x</em>)<em>d</em><em>x</em> = −<em>E</em>log <em>f</em>(<em>x</em>)</span></p><p>其中 <span class="math inline"><em>S</em></span> 为 <span class="math inline"><em>X</em></span> 的支撑集，即（<span class="math inline"><em>f</em>(<em>x</em>) &gt; 0</span>，<span class="math inline"><em>x</em> ∈ <em>S</em></span>），<span class="math inline"><em>h</em>(<em>x</em>)</span>单位为<span class="math inline"><em>b</em><em>i</em><em>t</em></span>。</p></li><li><p><strong>均匀分布</strong> 设 <span class="math inline"><em>X</em> ∼ <em>U</em>(<em>a</em>, <em>b</em>)</span>,即<span class="math inline"><em>X</em></span> 服从 <span class="math inline">[<em>a</em>, <em>b</em>]</span> 上的均匀分布，则<span class="math display">$$h(X)=-\int_{a}^{b}\frac{1}{b-a}\log\frac{1}{b-a}dx= \log (b-a)$$</span></p><p>若 <span class="math inline"><em>b</em> − <em>a</em> &lt; 1</span>，则 <span class="math inline"><em>h</em>(<em>X</em>) &lt; 0</span>，因此微分熵可以为负。</p></li><li><p><strong>正态分布/高斯分布</strong> 设 <span class="math inline"><em>X</em> ∼ <em>N</em>(<em>μ</em>, <em>σ</em><sup>2</sup>)</span>，<span class="math inline">$f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}}$</span>。 <span class="math display">$$\begin{align*}h(X)&amp;=-\int f(x)\log f(x)dx\\&amp;=-\intf(x)\left(-\log\sqrt{2\pi\sigma^{2}}-\frac{x^{2}}{2\sigma^{2}}\loge\right)dx\\&amp;=\frac{1}{2}\log(2\pi\sigma^{2})\int f(x)dx+\frac{\loge}{2\sigma^{2}}\int x^{2}f(x)dx\\&amp;=\frac{1}{2}\log(2\pi\sigma^{2})+\frac{1}{2}\log e\\&amp;=\frac{1}{2}\log(2\pi e\sigma^{2})\end{align*}$$</span></p><p>其中 <span class="math display"><em>σ</em><sup>2</sup> = <em>V</em><em>a</em><em>r</em>(<em>X</em>) = <em>E</em>(<em>X</em> − <em>E</em>(<em>X</em>))<sup>2</sup> = ∫(<em>x</em> − <em>μ</em>)<sup>2</sup><em>f</em>(<em>x</em>)<em>d</em><em>x</em></span></p><p>若<span class="math inline"><em>X</em> ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span>，<span class="math inline">$f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{x^{2}}{2\sigma^{2}}}$</span>，则有 <span class="math inline">$h(X)=\frac{1}{2}\log(2\pie\sigma^{2})$</span> 其中 <span class="math display"><em>σ</em><sup>2</sup> = <em>V</em><em>a</em><em>r</em>(<em>X</em>) = ∫<em>x</em><sup>2</sup><em>f</em>(<em>x</em>)<em>d</em><em>x</em></span></p></li><li><p><strong>平移性质</strong> <span class="math display"><em>h</em>(<em>X</em> + <em>c</em>) = <em>h</em>(<em>X</em>)</span></p><ul><li><figure><img src="image-11.png" srcset="/img/loading/loading3.gif" lazyload alt="图示"><figcaption aria-hidden="true">图示</figcaption></figure></li><li><strong>证明</strong>： 令 <span class="math inline"><em>Y</em> = <em>X</em> + <em>c</em></span>，则<span class="math inline"><em>f</em><sub><em>Y</em></sub>(<em>y</em>) = <em>f</em><sub><em>X</em></sub>(<em>y</em> − <em>c</em>)</span>，且 <span class="math inline"><em>S</em><sub><em>Y</em></sub> = {<em>x</em> + <em>c</em> : <em>x</em> ∈ <em>S</em><sub><em>X</em></sub>}</span>将 <span class="math inline"><em>x</em> = <em>y</em> − <em>c</em></span>代入下式： <span class="math display">$$  \begin{align*}  h(X)&amp;=-\int_{S_X}f_X(x)\log f_X(x)dx\\  &amp;=-\int_{S_Y}f_X(y - c)\log f_X(y - c)dy\\  &amp;=-\int_{S_Y}f_Y(y)\log f_Y(y)dy\\  &amp;=h(Y)\\  &amp;=h(X + c)  \end{align*}  $$</span></li></ul></li><li><p><strong>缩放性质</strong> <span class="math display"><em>对</em><em>a</em> ≠ 0，<em>有</em><em>h</em>(<em>a</em><em>X</em>) = <em>h</em>(<em>X</em>) + log |<em>a</em>|</span></p><ul><li><figure><img src="image-12.png" srcset="/img/loading/loading3.gif" lazyload alt="图示"><figcaption aria-hidden="true">图示</figcaption></figure></li><li><strong>证明</strong>： 令 <span class="math inline"><em>Y</em> = <em>a</em><em>X</em></span>，则 <span class="math inline">$f_Y(y)=\frac{1}{|a|}f_X(\frac{y}{a})$</span>，且<span class="math inline"><em>S</em><sub><em>Y</em></sub> = {<em>a</em><em>x</em> : <em>x</em> ∈ <em>S</em><sub><em>X</em></sub>}</span>。将 <span class="math inline">$x = \frac{y}{a}$</span> 代入 <span class="math inline"><em>h</em>(<em>X</em>)</span> 的表达式： <span class="math display">$$  \begin{align*}  h(X)&amp;=-\int_{S_X}f_X(x)\log f_X(x)dx\\  &amp;=-\int_{S_Y}f_X(\frac{y}{a})\log f_X(\frac{y}{a})\frac{dy}{|a|}\\  &amp;=-\int_{S_Y}|a|f_Y(y)\log (f_Y(y)|a|)\frac{1}{|a|}dy\\  &amp;=-\int_{S_Y}f_Y(y)(\log f_Y(y)+\log|a|)dy\\  &amp;=-\int_{S_Y}f_Y(y)\log f_Y(y)dy-\log|a|\int_{S_Y}f_Y(y)dy\\  &amp;=h(Y)-\log|a|\\  &amp;=h(aX)-\log|a|  \end{align*}  $$</span> 移项可得 <span class="math inline"><em>h</em>(<em>a</em><em>X</em>) = <em>h</em>(<em>X</em>) + log |<em>a</em>|</span></li><li>示例：<img src="image-103.png" srcset="/img/loading/loading3.gif" lazyload alt="示例"></li></ul></li></ol><h3 id="联合微分熵条件微分熵及互信息">联合微分熵，条件微分熵及互信息</h3><ol type="1"><li><p><strong>定义（联合微分熵）</strong> 联合概率密度函数为 <span class="math inline"><em>f</em>(<em>x⃗</em>)</span> 的随机向量 <span class="math inline">$\vec{x_{}}$</span> 的联合微分熵 <span class="math inline"><em>h</em>(<em>x⃗</em>)</span> 定义为 <span class="math display"><em>h</em>(<em>x⃗</em>) = −∫<sub><em>S</em></sub><em>f</em>(<em>x⃗</em>)log <em>f</em>(<em>x⃗</em>)<em>d</em><em>x⃗</em> = −<em>E</em>log <em>f</em>(<em>x⃗</em>)</span></p><p>如果 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>n</em></sub></span>相互独立，则有 <span class="math display">$$h(\vec{x})=\sum_{i =1}^{n}h(X_i)$$</span></p></li><li><p><strong>平移</strong> 令 <span class="math inline">$\vec{c_{}}$</span> 是 <span class="math inline">ℝ<sup><em>n</em></sup></span>（<span class="math inline"><em>n</em></span> 维实数空间）中的一个列向量，则<span class="math display"><em>h</em>(<em>x⃗</em> + <em>c⃗</em>) = <em>h</em>(<em>x⃗</em>)</span></p></li><li><p><strong>缩放</strong> 令 <span class="math inline"><em>A</em></span> 是一个 <span class="math inline"><em>n</em> × <em>n</em></span> 的非奇异矩阵，则<span class="math display"><em>h</em>(<em>A</em><em>x⃗</em>) = <em>h</em>(<em>x⃗</em>) + log |det (<em>A</em>)|</span></p></li><li><p><strong>多元高斯分布</strong> 设 <span class="math inline"><em>X⃗</em> ∼ <em>N</em>(<em>μ⃗</em>, <em>K</em>)</span>。 令 <span class="math inline"><em>N</em>(<em>μ⃗</em>, <em>K</em>)</span> 表示均值为<span class="math inline"><em>μ⃗</em></span>，协方差矩阵为 <span class="math inline"><em>K</em></span> 的多元高斯分布，即对于所有 <span class="math inline"><em>x⃗</em> ∈ ℝ<sup><em>n</em></sup></span>，其联合概率密度函数为： <span class="math display">$$f(\vec{x}) =\frac{1}{(\sqrt{2\pi})^n|K|^{\frac{1}{2}}}e^{-\frac{1}{2}(\vec{x}-\vec{\mu})^TK^{-1}(\vec{x}-\vec{\mu})}$$</span></p><p>其中 <span class="math inline"><em>K</em></span>是正定对称矩阵，<span class="math inline">|<em>K</em>|</span> 表示 <span class="math inline"><em>K</em></span> 的行列式值，<span class="math inline"><em>x⃗</em>, <em>μ⃗</em></span> 为列向量。</p><p>其微分熵 <span class="math inline"><em>h</em>(<em>X⃗</em>)</span> 为：<span class="math display">$$h(\vec{X}) = \frac{1}{2} \log[(2\pie)^n|K|]$$</span></p><p>这里 <span class="math inline">|<em>K</em>|</span> 为 <span class="math inline"><em>K</em></span> 的行列式值。</p><ul><li><strong>证明</strong>： 设 <span class="math inline"><em>K</em></span> 可以对角化为 <span class="math inline"><em>Q</em><em>Λ</em><em>Q</em><sup><em>T</em></sup></span>，记 <span class="math inline">$\vec{X} = Q\vec{Y_{}}$</span> ，其中<span class="math inline">$\vec{Y_{}}$</span> 中的随机变量不相关，且有<span class="math inline"><em>V</em><em>a</em><em>r</em>(<em>Y</em><sub><em>i</em></sub>) = <em>λ</em><sub><em>i</em></sub></span>，为 <span class="math inline"><em>Λ</em></span> 中第 <span class="math inline"><em>i</em></span> 个对角元素。由于 <span class="math inline">$\vec{X_{}}$</span> 是高斯的，所以 <span class="math inline">$\vec{Y_{}}$</span> 也是高斯的。又由于 <span class="math inline">$\vec{Y_{}}$</span>中的随机变量是不相关的，可知它们相互独立。 <span class="math display">$$  \begin{align*}  h(\vec{X})&amp;=h(Q\vec{Y})\\  &amp;=h(\vec{Y})+\log|\det(Q)|\\  &amp;=h(\vec{Y}) + 0\\  &amp;=\sum_{i = 1}^{n}h(Y_i)\\  &amp;=\sum_{i = 1}^{n}\frac{1}{2}\log(2\pi e\lambda_i)\\  &amp;=\frac{1}{2}\log[(2\pi e)^n\prod_{i = 1}^{n}\lambda_i]\\  &amp;=\frac{1}{2}\log[(2\pi e)^n|\Lambda|]\\  &amp;=\frac{1}{2}\log[(2\pi e)^n|K|]  \end{align*}  $$</span></li></ul></li><li><p><strong>定义（条件微分熵）</strong> 如果 <span class="math inline"><em>X</em></span>，<span class="math inline"><em>Y</em></span> 的联合密度函数为 <span class="math inline"><em>f</em>(<em>x</em>, <em>y</em>)</span>，定义条件微分熵<span class="math inline"><em>h</em>(<em>X</em>|<em>Y</em>)</span> 为：<span class="math display"><em>h</em>(<em>X</em>|<em>Y</em>) = −∫<em>f</em>(<em>x</em>, <em>y</em>)log <em>f</em>(<em>x</em>|<em>y</em>)<em>d</em><em>x</em><em>d</em><em>y</em></span></p><p>由于 <span class="math inline"><em>f</em>(<em>x</em>|<em>y</em>) = <em>f</em>(<em>x</em>, <em>y</em>)/<em>f</em>(<em>y</em>)</span>，所以有：<span class="math display"><em>h</em>(<em>X</em>|<em>Y</em>) = <em>h</em>(<em>X</em>, <em>Y</em>) − <em>h</em>(<em>Y</em>)</span></p></li><li><p><strong>定义（相对熵）</strong> 两个密度函数 <span class="math inline"><em>f</em></span> 和 <span class="math inline"><em>g</em></span> 之间的相对熵 <span class="math inline"><em>D</em>(<em>f</em>||<em>g</em>)</span> 定义为：<span class="math display">$$D(f||g)=\intf\log\frac{f}{g}$$</span></p></li><li><p><strong>定义（互信息）</strong> 联合概率密度函数为 <span class="math inline"><em>f</em>(<em>x</em>, <em>y</em>)</span>的两个随机变量间的互信息 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 定义为：<span class="math display">$$I(X;Y)=\intf(x,y)\log\frac{f(x,y)}{f(x)f(y)}dxdy$$</span></p><p>显然有：<span class="math display">$$\begin{align*}I(X;Y)&amp;=h(X)-h(X|Y)=h(Y)-h(Y|X)\\&amp;=h(X)+h(Y)-h(X,Y)\end{align*}$$</span></p><p>以及：<span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>D</em>(<em>f</em>(<em>x</em>, <em>y</em>)||<em>f</em>(<em>x</em>)<em>f</em>(<em>y</em>))</span></p></li><li><p><strong>定理：相对熵的非负性</strong> <span class="math display"><em>D</em>(<em>f</em>||<em>g</em>) ≥ 0</span></p><ul><li><strong>证明</strong>： 设 <span class="math inline"><em>f</em></span> 的支撑集是 <span class="math inline"><em>S</em></span> <span class="math display">$$  \begin{align*}  -D(f||g)&amp;=\int_{S} f \log\frac{g}{f}\\  &amp;\leq \log\int_{S} f\frac{g}{f} \quad (\text{Jensen 不等式})\\  &amp;=\log\int_{S} g\\  &amp;\leq \log 1 = 0  \end{align*}  $$</span></li><li><strong>推论</strong>：<ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) ≥ 0</span>，当且仅当 <span class="math inline"><em>X</em></span> 与 <span class="math inline"><em>Y</em></span> 相互独立等号成立。</li><li><span class="math inline"><em>h</em>(<em>X</em>|<em>Y</em>) ≤ <em>h</em>(<em>X</em>)</span>。</li></ul></li></ul></li><li><p><strong>定理(链式法则)</strong> <span class="math display">$$h(X_1,X_2,X_3,\cdots,X_n)=\sum_{i =1}^{n}h(X_i|X_1,X_2,\cdots,X_{i - 1})$$</span></p><ul><li><strong>推论</strong>：<ul><li><span class="math inline">$h(X_1,X_2,\cdots,X_n) \leq \sum_{i =1}^{n}h(X_i)$</span></li></ul></li></ul></li><li><p><strong>Hadamard 阿达玛不等式</strong> 设 <span class="math inline"><em>X⃗</em> ∼ <em>N</em>(0, <em>K</em>)</span>是一个多元正态分布。 则有 <span class="math display">$$\begin{align*}h(X_1,X_2,\cdots,X_n)&amp;=\frac{1}{2}\log((2\pi e)^n|K|)\\&amp;\leq \sum_{i = 1}^{n}\frac{1}{2}\log(2\pi e K_{ii})\\&amp;=\frac{1}{2}\log((2\pi e K_{11} \times 2\pi e K_{22} \times \cdots\times 2\pi e K_{nn}))\end{align*}$$</span></p><p>即 <span class="math inline">$|K| \leq \prod_{i =1}^{n}K_{ii}$</span></p><ul><li>注意有关行列式的不等式可以由信息论中的不等式推导而得到。</li></ul></li></ol><h1 id="第三章-信道与信道容量">第三章 信道与信道容量</h1><h2 id="信道的数学模型">3.1 信道的数学模型</h2><h3 id="基本数学模型">基本数学模型</h3><ul><li><figure><img src="image-13.png" srcset="/img/loading/loading3.gif" lazyload alt="数学模型"><figcaption aria-hidden="true">数学模型</figcaption></figure></li><li><span class="math inline"><em>X⃗</em> = (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>i</em></sub>, ⋯)</span>，<span class="math inline"><em>X</em><sub><em>i</em></sub> ∈ <em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span>为输入；</li><li><span class="math inline"><em>Y⃗</em> = (<em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>j</em></sub>, ⋯)</span>，<span class="math inline"><em>Y</em><sub><em>j</em></sub> ∈ <em>B</em> = {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span>为输出。</li><li>用条件概率（转移概率）<span class="math inline"><em>p</em>(<em>Y⃗</em>|<em>X⃗</em>)</span>来描述输入、输出之间的依赖关系。</li></ul><h3 id="无干扰信道无噪声">无干扰信道（无噪声）</h3><ul><li><span class="math inline"><em>Y⃗</em> = <em>f</em>(<em>X⃗</em>)</span>，已知<span class="math inline">$\vec{X_{}}$</span>就能确知<span class="math inline">$\vec{Y_{}}$</span> <span class="math display">$$  p(\vec{Y}|\vec{X}) =  \begin{cases}  1, &amp;\vec{Y} = f(\vec{X}) \\  0, &amp;\vec{Y} \neq f(\vec{X})  \end{cases}  $$</span></li><li>例子：<ul><li>当输入<span class="math inline"><em>a</em><sub>1</sub></span>对应输出<span class="math inline"><em>b</em><sub>1</sub></span>，输入<span class="math inline"><em>a</em><sub>2</sub></span>对应输出<span class="math inline"><em>b</em><sub>2</sub></span>时，转移概率矩阵<span class="math inline">$P = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1\end{bmatrix}$</span></li><li><figure><img src="image-14.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul></li></ul><h3 id="有干扰无记忆信道">有干扰无记忆信道</h3><ul><li>无记忆：<span class="math display"><em>p</em>(<em>Y⃗</em>|<em>X⃗</em>) = <em>p</em>(<em>y</em><sub>1</sub>|<em>x</em><sub>1</sub>)<em>p</em>(<em>y</em><sub>2</sub>|<em>x</em><sub>2</sub>)⋯<em>p</em>(<em>y</em><sub><em>l</em></sub>|<em>x</em><sub><em>l</em></sub>)</span></li><li>只需分析单个符号的转移概率<span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span></li></ul><h4 id="二进制离散对称信道binary-symmetric-channelbsc">二进制离散对称信道（BinarySymmetric Channel，BSC）</h4><ul><li>输入<span class="math inline"><em>X</em> ∈ <em>A</em> = {0, 1}</span></li><li>输出<span class="math inline"><em>Y</em> ∈ <em>B</em> = {0, 1}</span></li><li>$ BSC$</li><li>其中<span class="math inline"><em>p</em></span>为错误概率，其转移关系和转移概率矩阵如下：</li><li><figure><img src="image-15.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li></ul><h4 id="离散无记忆信道discrete-memoryless-channeldmc">离散无记忆信道（DiscreteMemoryless Channel，DMC）</h4><ul><li>输入<span class="math inline"><em>X</em> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>输出<span class="math inline"><em>Y</em> ∈ {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li><li>转移概率矩阵<span class="math inline">$P = [p(b_j|a_i)] =[p_{ij}]_{n \times m} =  \begin{bmatrix}  p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1m} \\  \vdots &amp; &amp; &amp; \\  p_{n1} &amp; p_{n2} &amp; \cdots &amp; p_{nm}  \end{bmatrix}_{n \times m}$</span></li><li>并且满足<span class="math inline">$\sum_{j = 1}^{m} p(b_j|a_i) =1$</span>，<span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span></li><li><figure><img src="image-16.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li>二进制离散对称信道（BSC）是离散无记忆信道（DMC）的特例</li></ul><h4 id="离散输入连续输出信道">离散输入、连续输出信道</h4><ul><li>输入<span class="math inline"><em>X</em> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>输出<span class="math inline"><em>Y</em> ∈ {−∞, +∞}</span></li><li>信道模型为<span class="math inline"><em>Y</em> = <em>X</em> + <em>G</em></span>，其中<span class="math inline"><em>G</em> ∈ {−∞, +∞}</span>，<span class="math inline"><em>p</em><sub><em>G</em></sub>(<em>n</em>) ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span></li><li>条件概率密度<span class="math inline">$p_Y(y|a_i) \sim N(a_i,\sigma^2)=\frac{1}{\sqrt{2 \pi \sigma^2}}e^{-\frac{(y -a_i)^2}{2\sigma^2}}$</span></li><li>图例：<img src="image-17.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"></li></ul><h4 id="波形信道">波形信道</h4><ul><li>当 <span class="math inline"><em>t</em><sub><em>B</em></sub></span>、<span class="math inline"><em>f</em><sub><em>m</em></sub></span> 受限，<span class="math inline"><em>L</em> = 2<em>t</em><sub><em>B</em></sub><em>f</em><sub><em>m</em></sub></span>时</li><li>输入 <span class="math inline"><em>X⃗</em> = (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub>)</span></li><li>输出 <span class="math inline"><em>Y⃗</em> = (<em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>L</em></sub>)</span></li><li><figure><img src="image-19.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li><strong>时间离散，取值连续的多维连续信道</strong>，信道转移概率密度函数为：<span class="math display"><em>p</em><sub><em>Y</em></sub>(<em>y⃗</em>|<em>x⃗</em>) = <em>p</em><sub><em>y</em></sub>(<em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>, ⋯, <em>y</em><sub><em>L</em></sub>|<em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, ⋯, <em>x</em><sub><em>L</em></sub>)</span></li><li><strong>连续无记忆信道</strong>： <span class="math display">$$p_Y(\vec{y}|\vec{x}) = p_y(y_1 | x_1)p_y(y_2 |x_2)\cdots p_y(y_L | x_L) = \prod_{l = 1}^{L} p_Y (y_l|x_l)$$</span></li></ul><h4 id="因此无记忆时重点讨论单符号信道">因此无记忆时重点讨论单符号信道！</h4><ul><li><p>信道模型为 <span class="math inline"><em>y</em>(<em>t</em>) = <em>x</em>(<em>t</em>) + <em>n</em>(<em>t</em>)</span></p></li><li><p>其中 <strong><span class="math inline"><em>n</em>(<em>t</em>)</span> 为加性噪声，与信号<span class="math inline"><em>x</em>(<em>t</em>)</span>相互独立</strong></p></li><li><figure><img src="image-18.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li><p>根据概率关系有： <span class="math display"><em>p</em><sub><em>X</em>, <em>Y</em></sub>(<em>x</em>, <em>y</em>) = <em>p</em><sub><em>X</em>, <em>n</em></sub>(<em>x</em>, <em>n</em>) = <em>p</em><sub><em>X</em></sub>(<em>x</em>)<em>p</em><sub><em>n</em></sub>(<em>n</em>)</span></p><p><span class="math display">$$p_Y(y|x)=\frac{p_{X,Y}(x,y)}{p_X(x)}=\frac{p_{X,n}(x,n)}{p_X(x)}= p_n(n)$$</span></p></li><li><p>进一步考虑条件熵： <span class="math display">$$  \begin{align*}  H_c(Y|X)&amp;=-\iint_{R}p_{X,Y}(x,y)\log p_Y(y|x)dxdy\\  &amp;=-\int_{R}p_X(x)dx\int_{R}p_Y(y|x)\log p_Y(y|x)dy\\  &amp;=-\int_{R}p_n(n)\log p_n(n)dn\\  &amp;=H_c(n)  \end{align*}  $$</span></p><p>条件熵 <span class="math inline"><em>H</em><sub><em>c</em></sub>(<em>Y</em>|<em>X</em>)</span>称为<strong>噪声熵</strong></p></li><li><p>在加性多维连续信道中</p><ul><li><span class="math display">$$\vec{y}=\vec{x}+\vec{n_{}}$$</span></li><li>同理有 <span class="math inline"><em>p</em><sub><em>Y⃗</em></sub>(<em>y⃗</em>|<em>x⃗</em>) = <em>p</em><sub><em>n</em></sub>(<em>n⃗</em>)</span>，<span class="math inline"><em>H</em><sub><em>c</em></sub>(<em>y⃗</em>|<em>x⃗</em>) = <em>H</em><sub><em>c</em></sub>(<em>n⃗</em>)</span></li></ul></li></ul><h3 id="有干扰有记忆信道">有干扰有记忆信道</h3><blockquote><p>略</p></blockquote><h3 id="信道容量的定义">信道容量的定义</h3><ul><li>定义信道的<strong>信息传输率 <span class="math inline"><em>R</em></span></strong>为信道中平均每个符号所传输的信息量： <span class="math display">$$  \begin{align*}  R=I(X;Y)&amp;=H(X)-H(X|Y)\quad \text{bit}/\text{信道符号}\\  &amp;=H(Y)-H(Y|X)  \end{align*}  $$</span></li><li>设 <span class="math inline"><em>T</em></span>为信道中符号的平均传输时间，定义<strong>信息传输速率</strong>： <span class="math display">$$R_t = \frac{R}{T}=\frac{I(X;Y)}{T}\quad\text{bit}/\text{秒}$$</span><ul><li><span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>是输入符号分布概率 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>和信道转移概率 <span class="math inline"><em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>)</span>的函数，即 <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>f</em>(<em>p</em>(<em>a</em><sub><em>i</em></sub>), <em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>))</span></li></ul></li><li>对于某特定信道，<span class="math inline"><em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>)</span>确定，则 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是关于<span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>的凹函数（<span class="math inline">∩</span>型上凸函数），也即可以找到某种概率分布 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>，使<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>达到最大，该最大值为<strong>信道容量</strong>： <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>I</em>(<em>X</em>; <em>Y</em>)  bit/符号</span><ul><li>若符号传送时间周期为 <span class="math inline"><em>T</em></span>秒，则<strong>单位时间信道容量</strong>为： <span class="math display"><em>C</em><sub><em>t</em></sub> = <em>C</em>/<em>T</em>  bit/秒</span></li></ul></li><li>对于固定信道参数信道，信道容量是个定值。实际传输时能否提供最大传输能力，取决于输入端的概率分布，定义<strong>信道绝对冗余度和相对冗余度</strong>：<span class="math display"><em>信</em><em>道</em><em>绝</em><em>对</em><em>冗</em><em>余</em><em>度</em> = <em>C</em> − <em>I</em>(<em>X</em>; <em>Y</em>)</span><span class="math display">$$信道相对冗余度=1-\frac{I(X;Y)}{C}$$</span></li></ul><h2 id="离散单个符号信道及其容量">3.2 离散单个符号信道及其容量</h2><h3 id="无干扰离散信道">无干扰离散信道</h3><ul><li>信道输入<span class="math inline"><em>X</em> ∈ <em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>输出<span class="math inline"><em>Y</em> ∈ <em>B</em> = {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li></ul><h4 id="无噪无损信道n-mxy一一对应">无噪无损信道：n =m，X、Y一一对应</h4><ul><li>输入输出关系：<img src="image-20.png" srcset="/img/loading/loading3.gif" lazyload alt="输入输出关系"></li><li>转移概率矩阵<span class="math inline">$P = \{p(y_j|x_i)\} =  \begin{bmatrix}  1 &amp; 0 &amp; \cdots \\  0 &amp; 1 &amp; \cdots \\  \vdots &amp; \vdots &amp; \ddots &amp;  \end{bmatrix}$</span>，<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>) ∈ {0, 1}</span>。</li><li><strong>噪声熵与疑义度</strong>： <span class="math display"><em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>X</em>|<em>Y</em>) = 0</span></li><li><strong>互信息</strong>： <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>I</em>(<em>Y</em>; <em>X</em>) = <em>H</em>(<em>X</em>) = <em>H</em>(<em>Y</em>)</span>当输入符号等概率分布时，<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>最大。</li><li><strong>信道容量</strong>: <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>I</em>(<em>X</em>; <em>Y</em>) = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>H</em>(<em>X</em>) = log <em>n</em></span></li></ul><h4 id="无噪有损信道n-m多个x对应一个y">无噪有损信道：n &gt;m，多个X对应一个Y</h4><ul><li>输入输出关系：<img src="image-21.png" srcset="/img/loading/loading3.gif" lazyload alt="输入输出关系"></li><li>多个输入对应一个输出，即<span class="math inline"><em>n</em> &gt; <em>m</em></span></li><li><strong>噪声熵</strong>: <span class="math display"><em>H</em>(<em>Y</em>|<em>X</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)log <em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>) = 0</span></li><li><strong>疑义度</strong>: <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)log <em>p</em>(<em>a</em><sub><em>i</em></sub>|<em>b</em><sub><em>j</em></sub>) ≠ 0</span></li><li><strong>互信息</strong>: <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>Y</em>) ≠ 0</span>其中<span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>) = 0</span>，<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) ≠ 0</span>由此可得<span class="math inline"><em>H</em>(<em>X</em>) = <em>H</em>(<em>Y</em>) + <em>H</em>(<em>X</em>|<em>Y</em>)</span>，所以<span class="math inline"><em>H</em>(<em>X</em>) ≥ <em>H</em>(<em>Y</em>)</span>。</li><li><strong>信道容量</strong>： <span class="math display">$$C =\max_{p(a_i)} I(X;Y)=\max_{p(a_i)} H(Y) \overset{?}{=} \logm$$</span></li></ul><h4 id="有噪无损信道n-m一个x对应多个y">有噪无损信道：n &lt;m，一个X对应多个Y</h4><ul><li>输入输出关系：<img src="image-22.png" srcset="/img/loading/loading3.gif" lazyload alt="输入输出关系"></li><li>信道噪声使一个输入对应多个输出，<span class="math inline"><em>n</em> &lt; <em>m</em></span></li><li><strong>噪声熵</strong>： <span class="math display"><em>H</em>(<em>Y</em>|<em>X</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)log <em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>) ≠ 0</span></li><li><strong>疑义度</strong>： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) = ∑<sub><em>i</em>, <em>j</em></sub><em>p</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)log <em>p</em>(<em>a</em><sub><em>i</em></sub>|<em>b</em><sub><em>j</em></sub>) = 0</span></li><li><strong>互信息</strong>： <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>X</em>) ≠ 0</span>其中<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = 0</span>，<span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>) ≠ 0</span>由此可得<span class="math inline"><em>H</em>(<em>Y</em>) = <em>H</em>(<em>X</em>) + <em>H</em>(<em>Y</em>|<em>X</em>)</span>，所以<span class="math inline"><em>H</em>(<em>Y</em>) ≥ <em>H</em>(<em>X</em>)</span>。</li><li><strong>信道容量</strong>： <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>I</em>(<em>X</em>; <em>Y</em>) = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>H</em>(<em>X</em>) = log <em>n</em></span></li></ul><h3 id="对称离散无记忆信道">对称离散无记忆信道</h3><ul><li><p>以下是两个转移概率矩阵示例： <span class="math display">$$  \begin{bmatrix}  \frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{6} \\  \frac{1}{6} &amp; \frac{1}{6} &amp; \frac{1}{3} &amp; \frac{1}{3}  \end{bmatrix}_{2\times4}  \quad  \begin{bmatrix}  \frac{1}{2} &amp; \frac{1}{3} &amp; \frac{1}{6} \\  \frac{1}{6} &amp; \frac{1}{2} &amp; \frac{1}{3} \\  \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{2}  \end{bmatrix}_{3\times3}  $$</span></p></li><li><p><strong>对称特性判断</strong>：</p><ul><li>若每一行包含相同元素，称为输入对称</li><li>若每一列包含相同元素，称为输出对称</li><li>当行列都对称时，为<strong>对称DMC（离散无记忆信道）</strong>。</li></ul></li><li><p><strong>相关信息论公式</strong>：</p><ul><li><strong>互信息</strong>: <span class="math display"><em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>X</em>) − <em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>)</span></li><li><strong>条件熵</strong>: <span class="math display">$$  \begin{align*}  H(Y|X)&amp;=-\sum_{i,j} p(a_i, b_j)\log p(b_j|a_i)\\  &amp;=-\sum_{i,j} p(a_i) p(b_j|a_i)\log p(b_j|a_i)\\  &amp;=-\sum_{i} p(a_i) \sum_{j} p(b_j|a_i)\log p(b_j|a_i)\\  &amp;=\sum_{i} p(a_i) H(Y|a_i) （输入对称）\\  &amp;= H(Y|a_i)，i = 1, 2, \cdots, n  \end{align*}  $$</span></li><li><strong>信道容量</strong>: <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>I</em>(<em>X</em>; <em>Y</em>) = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = max<sub><em>p</em>(<em>a</em><sub><em>i</em></sub>)</sub><em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>a</em><sub><em>i</em></sub>)</span></li></ul></li><li><p>当<strong>输入符号等概率分布</strong>，即<span class="math inline">$p(a_i)=\frac{1}{n}$</span>时，设<span class="math inline"><em>m</em></span>为输出符号数目，则有：</p><ul><li><span class="math inline">$p(b_j)=\sum_{i}p(a_i)p(b_j|a_i)=\frac{1}{n}\sum_{i} p(b_j|a_i)=\frac{1}{n}\cdot\frac{n}{m}=\frac{1}{m}$</span></li><li><span class="math inline">$H(Y)=-\sum_{j} p(b_j)\log p(b_j)=\sum_{j}\frac{1}{m}\log m=m\frac{1}{m}\log m=\log m$</span></li><li><strong>信道容量</strong><span class="math display"><em>C</em> = log <em>m</em> − <em>H</em>(<em>Y</em>|<em>a</em><sub><em>i</em></sub>)</span></li><li>其中<span class="math inline"><em>m</em></span>为输出符号<span class="math inline"><em>Y</em></span>数目，<span class="math inline"><em>i</em> = 1, ⋯, <em>n</em></span></li></ul></li><li><p>例题：<img src="image-98.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li><li><p><strong>一般离散无记忆模k加性噪声信道</strong></p><ul><li>信道模型: <span class="math inline"><em>Y</em> = <em>X</em> ⊕ <em>Z</em>&nbsp;mod &nbsp;<em>k</em></span>，其中<span class="math inline"><em>X</em>, <em>Y</em>, <em>Z</em> ∈ {0, 1, ⋯, <em>k</em> − 1}</span></li><li>图例:<img src="image-23.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"></li><li><strong>加性噪声</strong>，有 <span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>) = <em>p</em>(<em>z</em>)</span><ul><li><strong>条件熵</strong>: <span class="math display">$$  \begin{align*}  H(Y|X)&amp;=-\sum_{x,y}p(x)p(y|x)\log p(y|x)\\  &amp;=-\sum_{x,z}p(x)p(z)\log p(z)\\  &amp;=-\sum_{x}p(x)\sum_{z}p(z)\log p(z)\\  &amp;=H(Z)  \end{align*}  $$</span></li><li><strong>信道容量</strong>: <span class="math display">$$  \begin{align*}  C&amp;=\max_{p(x)}H(Y)-H(Y|X)\\  &amp;=\max_{p(x)}H(Y)-H(Z)\\  &amp;=\log k - H(Z) \quad (\text{对称性})  \end{align*}  $$</span></li></ul></li><li>例题：<img src="image-26.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul></li></ul><h3 id="准对称离散无记忆信道">准对称离散无记忆信道</h3><ul><li><p>以下是两个转移概率矩阵示例： <span class="math display">$$P_1=\begin{bmatrix}\frac{1}{3}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{6}\\\frac{1}{6}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{3}\end{bmatrix}_{2\times4} \quadP_2=\begin{bmatrix}0.7&amp;0.1&amp;0.2\\0.2&amp;0.1&amp;0.7\end{bmatrix}_{2\times3}$$</span></p></li><li><p><strong>信道特性</strong>：</p><ul><li>矩阵中<strong>各行元素相同，但各列元素不同</strong>，这种信道称为<strong>准对称DMC（离散无记忆信道）</strong>。</li></ul></li><li><p><strong>相关信息论公式</strong>：</p><ul><li><p>因为各行元素相同，所以 <span class="math inline"><em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em>(<em>Y</em>|<em>a</em><sub><em>i</em></sub>)</span>，其中 <span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span></p><ul><li>这表明在给定不同输入符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span>时，输出的条件熵是相同的</li></ul></li><li><p>由于各列元素不同，信道的输入和输出分布概率可以不同，并且 <span class="math inline"><em>H</em>(<em>Y</em>) ≤ log <em>m</em></span>（<span class="math inline"><em>m</em></span>为输出符号的数目）</p></li><li><p><strong>信道容量</strong>： <span class="math display">$$  \begin{align*}  C &amp;= \max_{p(x)}[H(Y)-H(Y|X)] \\  &amp;\leq\log m - H(Y|a_i)\\  &amp;=\log m+\sum_{j = 1}^{m}p_{ij}\log p_{ij}  \end{align*}  $$</span> 其中<span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span> ，<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>是转移概率矩阵中的元素</p><ul><li>这给出了准对称离散无记忆信道容量的一个<strong>上限估计</strong></li><li>求解：<strong>矩阵分解法</strong>、极值求导法</li></ul></li><li><p>例题：<img src="image-99.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul></li></ul><h3 id="矩阵分解法">矩阵分解法</h3><ul><li><strong>转移矩阵分解</strong>：<ul><li>将<strong>准对称</strong>转移概率矩阵<strong>按概率列</strong>分成若干个互不相交的<strong>对称的子集</strong>。例如：<ul><li><span class="math display">$$P_1 =\begin{bmatrix}\frac{1}{3}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{6}\\\frac{1}{6}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{3}\end{bmatrix}$$</span>可分解成<span class="math inline">$\begin{bmatrix}\frac{1}{3}&amp;\frac{1}{6}\\\frac{1}{6}&amp;\frac{1}{3}\end{bmatrix}$</span>，<span class="math inline">$\begin{bmatrix}\frac{1}{3}\\\frac{1}{3}\end{bmatrix}$</span>，<span class="math inline">$\begin{bmatrix}\frac{1}{6}\\\frac{1}{6}\end{bmatrix}$</span></li><li><span class="math display">$$P_2 =\begin{bmatrix}0.7&amp;0.1&amp;0.2\\0.2&amp;0.1&amp;0.7\end{bmatrix}$$</span>可分解成<span class="math inline">$\begin{bmatrix}0.7&amp;0.2\\0.2&amp;0.7\end{bmatrix}$</span>，<span class="math inline">$\begin{bmatrix}0.1\\0.1\end{bmatrix}$</span>。</li></ul></li></ul></li><li><strong>信道容量</strong>：<ul><li>可以证明，当<strong>输入等概率分布</strong>时，可达到信道容量。<span class="math display">$$C=\log n - H(P_1',P_2',\cdots,P_m')-\sum_{k= 1}^{r}N_k\log M_k$$</span></li><li>其中：<ul><li><span class="math inline"><em>n</em></span>为输入符号个数。</li><li><span class="math inline"><em>P</em><sub>1<sup>′</sup></sub>, <em>P</em><sub>2<sup>′</sup></sub>, ⋯, <em>P</em><sub><em>m</em><sup>′</sup></sub></span>是原转移概率矩阵<span class="math inline"><em>P</em></span>中一行的元素。</li><li><span class="math inline"><em>N</em><sub><em>k</em></sub></span>是第<span class="math inline"><em>k</em></span>个子矩阵中行元素之和。</li><li><span class="math inline"><em>M</em><sub><em>k</em></sub></span>是第<span class="math inline"><em>k</em></span>个子矩阵中列元素之和。</li><li><span class="math inline"><em>r</em></span>是子矩阵个数。</li></ul></li></ul></li><li><strong>例题</strong>：<img src="image-100.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h3 id="一般离散无记忆信道">一般离散无记忆信道</h3><ul><li><p><strong>转移概率<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>)</span>固定</strong></p></li><li><p><strong>信道容量</strong>： <span class="math display"><em>C</em> = max<sub><em>p</em>(<em>x</em>)</sub><em>I</em>(<em>X</em>; <em>Y</em>) = max<sub><em>p</em>(<em>x</em>)</sub><em>I</em>(<em>p</em>(<em>x</em>), <em>p</em>(<em>y</em>|<em>x</em>))</span></p><p>即求互信息<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>关于输入概率分布<span class="math inline"><em>p</em>(<em>x</em>)</span>的极大值。</p></li><li><p><strong>互信息</strong>： <span class="math display">$$  \begin{align*}  I(X;Y)&amp;=\sum_{i}p(a_i)I(a_i;Y)\\  &amp;=\sum_{i}p(a_i)\sum_{j}p(b_j|a_i)\log\frac{p(a_i|b_j)}{p(a_i)}  \end{align*}  $$</span></p></li><li><p>为使<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>达到最大，输入符号概率集<span class="math inline">{<em>p</em>(<em>a</em><sub><em>i</em></sub>)}</span>必须满足的<strong>充分和必要条件</strong>是：</p><ul><li>对于所有<span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>) &gt; 0</span>的符号<span class="math inline"><em>a</em><sub><em>i</em></sub></span>，有<span class="math inline"><em>I</em>(<em>a</em><sub><em>i</em></sub>; <em>Y</em>) = <em>C</em></span></li><li>对于所有<span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>) = 0</span>的符号<span class="math inline"><em>a</em><sub><em>i</em></sub></span>，有<span class="math inline"><em>I</em>(<em>a</em><sub><em>i</em></sub>; <em>Y</em>) ≤ <em>C</em></span></li><li>这意味着除概率为0的符号<span class="math inline"><em>a</em><sub><em>i</em></sub></span>外，每个符号<span class="math inline"><em>a</em><sub><em>i</em></sub></span> 对<span class="math inline"><em>Y</em></span>提供相同的互信息</li></ul></li><li><p>注意：<strong>最佳输入分布不唯一！</strong></p></li><li><p>例题：<img src="image-33.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="离散序列信道及其容量">3.3 离散序列信道及其容量</h2><h3 id="信道模型与符号定义">信道模型与符号定义</h3><ul><li><figure><img src="image-24.png" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"><figcaption aria-hidden="true">信道模型</figcaption></figure></li><li>输入矢量为<span class="math inline"><em>X⃗</em> = (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub>)</span>，其中<span class="math inline"><em>X</em><sub><em>l</em></sub> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>输出矢量为<span class="math inline"><em>Y⃗</em> = (<em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>L</em></sub>)</span>，其中<span class="math inline"><em>Y</em><sub><em>l</em></sub> ∈ {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li><li>条件概率表示为<span class="math inline"><em>p</em>(<em>Y⃗</em>|<em>X⃗</em>)</span>，即给定输入<span class="math inline">$\vec{X_{}}$</span>时输出<span class="math inline">$\vec{Y_{}}$</span>的概率。</li></ul><h3 id="无记忆离散序列信道">无记忆离散序列信道</h3><ul><li>对于无记忆离散序列信道： <span class="math display">$$p(\vec{Y}|\vec{X}) =p(Y_1,\cdots,Y_L|X_1,\cdots,X_L)=\prod_{l = 1}^{L}p(Y_l|X_l)$$</span><ul><li>若信道是平稳的： <span class="math display"><em>p</em>(<em>Y⃗</em>|<em>X⃗</em>) = (<em>p</em>(<em>y</em>|<em>x</em>))<sup><em>L</em></sup> = <em>p</em><sup><em>L</em></sup>(<em>y</em>|<em>x</em>)</span></li></ul></li><li><strong>互信息与信道容量</strong>: <span class="math display">$$  \begin{align*}  I(\vec{X};\vec{Y})&amp;=H(\vec{X}) - H(\vec{X}|\vec{Y})=\sump(\vec{X},\vec{Y})\log\frac{p(\vec{X}|\vec{Y})}{p(\vec{X})}\\  &amp;=H(\vec{Y}) - H(\vec{Y}|\vec{X})=\sump(\vec{X},\vec{Y})\log\frac{p(\vec{Y}|\vec{X})}{p(\vec{Y})}  \end{align*}  $$</span><ul><li><strong>信道无记忆时</strong>： <span class="math display">$$I(\vec{X};\vec{Y})\leq\sum_{l =1}^{L}I(X_l;Y_l)$$</span><ul><li>证明： 由定义有：<span class="math inline"><em>I</em>(<em>X⃗</em>; <em>Y⃗</em>) = <em>H</em>(<em>Y⃗</em>) − <em>H</em>(<em>Y⃗</em>|<em>X⃗</em>)</span>和<span class="math inline"><em>I</em>(<em>X</em><sub><em>l</em></sub>; <em>Y</em><sub><em>l</em></sub>) = <em>H</em>(<em>Y</em><sub><em>l</em></sub>) − <em>H</em>(<em>Y</em><sub><em>l</em></sub>|<em>X</em><sub><em>l</em></sub>)</span>，利用<span class="math inline"><em>H</em>(<em>X</em>)</span>的链式法则有： ①<span class="math inline">$H(\vec{Y})=H(Y_1,Y_2,\cdots,Y_L)=H(Y_1)+H(Y_2|Y_1)+\cdots+H(Y_L|Y_1,Y_2,\cdots,Y_{L- 1})\leq \sum_{l = 1}^{L}H(Y_l)$</span> ②<span class="math inline">$H(\vec{Y}|\vec{X})=H(Y_1|\vec{X})+H(Y_2|Y_1,\vec{X})+\cdots+H(Y_L|Y_1,Y_2,\cdots,Y_{L- 1},\vec{X})=\sum_{l =1}^{L}H(Y_l|X_l)$</span>（无记忆信道下，给定&nbsp;<span class="math inline"><em>X</em><sub><em>l</em></sub></span>&nbsp;后，其他时刻的输入输出对确定&nbsp;<span class="math inline"><em>Y</em><sub><em>l</em></sub></span>&nbsp;的不确定性没有额外帮助）所以有：<span class="math inline">$I(\vec{X};\vec{Y})=H(\vec{Y})-H(\vec{Y}|\vec{X})\leq\sum_{l = 1}^{L}H(Y_l)-\sum_{l = 1}^{L}H(Y_l|X_l)=\sum_{l =1}^{L}I(X_l;Y_l)$</span>。</li></ul></li><li><strong>输入矢量<span class="math inline">$\vec{X_{}}$</span>中各分量相互独立时</strong>：<span class="math display">$$I(\vec{X};\vec{Y})\geq\sum_{l =1}^{L}I(X_l;Y_l)$$</span><ul><li>证明： 由定义有：<span class="math inline"><em>I</em>(<em>X⃗</em>; <em>Y⃗</em>) = <em>H</em>(<em>X⃗</em>) − <em>H</em>(<em>X⃗</em>|<em>Y⃗</em>)</span>和<span class="math inline"><em>I</em>(<em>X</em><sub><em>l</em></sub>; <em>Y</em><sub><em>l</em></sub>) = <em>H</em>(<em>X</em><sub><em>l</em></sub>) − <em>H</em>(<em>X</em><sub><em>l</em></sub>|<em>Y</em><sub><em>l</em></sub>)</span>，利用<span class="math inline"><em>H</em>(<em>X</em>)</span>的链式法则有： ①<span class="math inline">$H(\vec{X})=H(X_1,X_2,\cdots,X_L)=H(X_1)+H(X_2|X_1)+\cdots+H(X_L|X_1,X_2,\cdots,X_{L- 1})=\sum_{l = 1}^{L}H(X_l)$</span>（由于各分量相互独立） ②<span class="math inline">$H(\vec{X}|\vec{Y})=H(X_1|\vec{Y})+H(X_2|X_1,\vec{Y})+\cdots+H(X_L|X_1,X_2,\cdots,X_{L- 1},\vec{Y})=\sum_{l = 1}^{L}H(X_l|\vec{Y})\leq \sum_{l =1}^{L}H(X_l|Y_l)$</span>（已知更多信息&nbsp;<span class="math inline">$\vec{Y_{}}$</span>&nbsp;时，<span class="math inline"><em>X</em><sub><em>l</em></sub></span>&nbsp;的不确定性不会比仅知道&nbsp;<span class="math inline"><em>Y</em><sub><em>l</em></sub></span>&nbsp;时更大）所以有：<span class="math inline">$I(\vec{X};\vec{Y})=H(\vec{X})-H(\vec{X}|\vec{Y})\geq\sum_{l = 1}^{L}H(X_l)-\sum_{l = 1}^{L}H(X_l|\vec{Y})=\sum_{l =1}^{L}I(X_l;Y_l)$</span>。</li></ul></li><li><strong>当输入矢量<span class="math inline">$\vec{X_{}}$</span>独立且信道无记忆时</strong>，上述两个性质统一取等号，此时<strong>信道容量</strong>：<span class="math display">$$  \begin{align*}  C_L&amp;=\max_{p(x)}I(\vec{X};\vec{Y})=\max_{p(x)}\sum_{l =1}^{L}I(X_l;Y_l)\\  &amp;=\sum_{l = 1}^{L}\max_{p(x)}I(X_l;Y_l)=\sum_{l = 1}^{L}C_l  \end{align*}  $$</span><ul><li>当信道平稳时<span class="math inline"><em>C</em><sub><em>L</em></sub> = <em>L</em><em>C</em><sub>1</sub></span></li><li>一般情况下，<span class="math inline"><em>I</em>(<em>X⃗</em>; <em>Y⃗</em>) ≤ <em>L</em><em>C</em><sub>1</sub></span>，其中<span class="math inline"><em>C</em><sub>1</sub></span>是单个时刻的信道容量</li></ul></li></ul></li><li>输入矢量独立且信道无记忆时，相当于对单个信道进行<span class="math inline"><em>L</em></span>次扩展的信道，也相当于<span class="math inline"><em>L</em></span>个独立的信道并联在一起。</li><li>示例：<img src="image-101.png" srcset="/img/loading/loading3.gif" lazyload alt="示例"></li></ul><h3 id="独立并联信道">独立并联信道</h3><ul><li>图例: <img src="image-25.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"></li><li>每个信道输出<span class="math inline"><em>Y</em><sub><em>l</em></sub></span>只与本信道的输入<span class="math inline"><em>X</em><sub><em>l</em></sub></span>有关，即：<span class="math display"><em>p</em>(<em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>L</em></sub>|<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub>) = <em>p</em>(<em>Y</em><sub>1</sub>|<em>X</em><sub>1</sub>)<em>p</em>(<em>Y</em><sub>2</sub>|<em>X</em><sub>2</sub>)⋯<em>p</em>(<em>Y</em><sub><em>L</em></sub>|<em>X</em><sub><em>L</em></sub>)</span><strong>信道无记忆</strong>, 并且有 <span class="math display">$$I(\vec{X};\vec{Y})\leq\sum_{l =1}^{L}I(X_l;Y_l)$$</span></li><li>并联信道容量 <span class="math display">$$C_{12\cdots L}=\maxI(\vec{X};\vec{Y})\leq\sum_{l = 1}^{L}C_l$$</span></li><li>当输入符号<span class="math inline"><em>X</em><sub><em>l</em></sub></span>相互独立，且<span class="math inline"><em>p</em>(<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub>)</span>达到最佳分布时，容量最大，此时：<span class="math display">$$C_{12\cdots L}=\sum_{l =1}^{L}C_l$$</span></li></ul><h3 id="有记忆离散序列信道">有记忆离散序列信道</h3><blockquote><p>有记忆的离散序列信道复杂得多，不作介绍。</p></blockquote><h2 id="连续信道及其容量">3.4 连续信道及其容量</h2><h3 id="连续单符号加性信道">连续单符号加性信道</h3><h4 id="加性高斯信道">加性高斯信道</h4><ul><li><p><strong>信道模型</strong>：</p><ul><li><figure><img src="image-27.png" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"><figcaption aria-hidden="true">信道模型</figcaption></figure></li><li>$ y = x + n $</li><li>$ n $：加性噪声</li><li>$P_n(n) N(0, ^2) = e^{-} $。</li></ul></li><li><p><strong>微分熵</strong>： <span class="math display">$$H_c(n) =-\int_{-\infty}^{+\infty} P_n(n) \log P_n(n) dn = \frac{1}{2} \log(2\pie \sigma^2) $$</span></p></li><li><p><strong>互信息</strong>： <span class="math display">$$  \begin{align*}  I(X;Y) &amp;= H_c(X) - H_c(X|Y) \\  &amp;= H_c(Y) - H_c(Y|X) \\  \end{align*}  $$</span></p></li><li><p><strong>信道容量</strong>： <span class="math display">$$  \begin{align*}  C = \max_{p(x)} I(X;Y) &amp;= \max_{p(x)} [H_c(Y) - H_c(Y|X)] \\  &amp;= \max_{p(x)} H_c(Y) - \frac{1}{2} \log(2\pi e \sigma^2)  \end{align*}  $$</span></p><p>其中 $ H_c(Y|X) $ 是噪声熵，由于<span class="math inline"><em>x</em></span>与<span class="math inline"><em>n</em></span>相独立，所以<span class="math inline"><em>p</em>(<em>y</em>|<em>x</em>) = <em>p</em>(<em>x</em> + <em>n</em>|<em>x</em>) = <em>p</em>(<em>n</em>)</span>，所以$H_c(Y|X) = H_n(n) = (2e ^2) $。</p></li><li><p><strong>求 $ H_c(Y) $ 最大值</strong>： <span class="math display">$$  \begin{align*}  &amp;y = x + n , y \in (-\infty, +\infty) ，y是功率受限信号\\  &amp;\Rightarrow Y 正态分布时熵最大\\  &amp;\Rightarrow Y 正态分布时信道容量最大\\  \end{align*}  $$</span></p></li><li><p><span class="math inline"><em>y</em></span> 的功率 <span class="math inline"><em>P</em></span>（其中 <span class="math inline"><em>S</em></span> 是输入信号 <span class="math inline"><em>x</em></span> 的平均功率，<span class="math inline"><em>σ</em><sup>2</sup></span> 是噪声功率） <span class="math display"><em>P</em> = <em>S</em> + <em>σ</em><sup>2</sup></span></p><ul><li><p>若 <span class="math inline"><em>P</em><sub><em>Y</em></sub>(<em>y</em>) ∼ <em>N</em>(0, <em>P</em>)</span>，<span class="math inline"><em>P</em><sub><em>n</em></sub>(<em>n</em>) ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span>，<span class="math inline"><em>x</em> = <em>y</em> − <em>n</em></span>，则<span class="math inline"><em>P</em><sub><em>X</em></sub>(<em>x</em>) ∼ <em>N</em>(0, <em>S</em>)</span>。</p></li><li><p>当输入 $ X $ 是均值为 0，方差为 $ S $的高斯分布时，<strong>信息传输率</strong>达最大，等于<strong>信道容量</strong>：<span class="math display">$$  \begin{align*}  C &amp;= \frac{1}{2} \log(2\pi e P) - \frac{1}{2} \log(2\pi e\sigma^2) \\  &amp;= \frac{1}{2} \log \frac{P}{\sigma^2} \\  &amp;= \frac{1}{2} \log \left(1 + \frac{S}{\sigma^2}\right)\\  &amp;= \frac{1}{2} \log(1 + SNR) \quad bit/符号  \end{align*}  $$</span></p><p>其中 <span class="math inline">$SNR=\frac{S}{\sigma^2}$</span>，<span class="math inline"><em>S</em><em>N</em><em>R</em><sub><em>d</em><em>B</em></sub> = 10log<sub>10</sub><em>S</em><em>N</em><em>R</em></span>。</p></li></ul></li></ul><h4 id="加性非高斯信道">加性非高斯信道</h4><ul><li><p>对于加性、均值为 0、平均功率为 $ ^2 $ 的非高斯信道： <span class="math display"><em>C</em> = max (<em>H</em><sub><em>c</em></sub>(<em>Y</em>) − <em>H</em><sub><em>c</em></sub>(<em>n</em>))</span></p></li><li><p>高斯分布时： <span class="math display">$$H_c(Y)_{max} =\frac{1}{2} \log(2\pi e P) $$</span></p><p><span class="math display">$$H_c(n)_{max} = \frac{1}{2} \log(2\pi e\sigma^2) $$</span></p></li><li><p>满足： <span class="math display">$$\frac{1}{2} \log(2\pi e P) -\frac{1}{2} \log(2\pi e \sigma^2) \leq C \leq \frac{1}{2} \log(2\pi e P)- H_c(n) $$</span></p></li></ul><h3 id="多维无记忆加性连续信道">多维无记忆加性连续信道</h3><ul><li><p><strong>信道模型</strong>：</p><ul><li><figure><img src="image-28.png" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"><figcaption aria-hidden="true">信道模型</figcaption></figure><ul><li>输入<span class="math inline"><em>X</em></span>的总功率<span class="math inline">$P = \sum_{l = 1}^{L}P_l$</span>，<span class="math inline"><em>P</em><sub><em>l</em></sub></span>是第<span class="math inline"><em>l</em></span>个输入信号的功率</li><li><span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup></span>是第<span class="math inline"><em>l</em></span>个噪声的功率</li></ul></li><li>信道无记忆 <span class="math display">$$  p(\vec{y}|\vec{x}) = \prod_{l = 1}^{L} p(y_l|x_l)  $$</span></li><li>加性噪声各时刻独立 <span class="math display">$$  p_n(\vec{n}) = p_y(\vec{y}|\vec{x}) = \prod_{l = 1}^{L} p_n(n_l) \quadn_l \sim N(0, \sigma_l^2)  $$</span></li></ul></li><li><p><strong>互信息</strong>： <span class="math display">$$  I(\vec{X}; \vec{Y}) \leq \sum_{l = 1}^{L} I(X_l; Y_l) \leq \sum_{l =1}^{L} \frac{1}{2} \log(1 + \frac{P_l}{\sigma_l^2})  $$</span></p></li><li><p><strong>信道容量</strong>： <span class="math display">$$  C = \max_{p(x)} I(\vec{X}; \vec{Y}) = \sum_{l = 1}^{L} \frac{1}{2}\log(1 + \frac{P_l}{\sigma_l^2}) \quad \text{bit}/L \text{ 序列}  $$</span></p><p>当且仅当输入随机变量 <span class="math inline">$\vec{X_{}}$</span>中各分量统计独立，且均值为0，方差为 <span class="math inline"><em>P</em><sub><em>l</em></sub></span>的高斯分布时，才能达到此容量。</p></li></ul><ol type="1"><li><p><strong><span class="math inline"><em>L</em></span>个高斯噪声每个单元时刻噪声功率相等</strong>，<span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup> = <em>σ</em><sup>2</sup></span>，<span class="math inline"><em>l</em> ∈ {1, 2, ⋯, <em>L</em>}</span>，有 <span class="math display">$$C = \frac{L}{2} \log(1 + \frac{S}{\sigma^2}) \quad, \quad S =\frac{P}{L}$$</span> <span class="math inline">$\vec{X_{}}$</span> 的各分量满足<span class="math inline"><em>N</em>(0, <em>S</em>)</span>分布时，达到信道容量。</p></li><li><p><strong><span class="math inline"><em>L</em></span>个高斯噪声均值为0，方差不同且为 <span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup></span>时</strong>，若输入信号的总平均功率受限，即 <span class="math display">$$E\left[\sum_{l = 1}^{L} x_l^2\right] = \sum_{l = 1}^{L} E[x_l^2] =\sum_{l = 1}^{L} P_l = P$$</span></p><ul><li><figure><img src="image-29.png" srcset="/img/loading/loading3.gif" lazyload alt="图例"><figcaption aria-hidden="true">图例</figcaption></figure></li><li><p><strong>怎样合理分配各单元时刻的信号平均功率，才能使信道传输率最大？</strong>用拉格朗日乘数法，作辅助函数 <span class="math display">$$  f(P_1, P_2, \cdots, P_L) = \sum_{l = 1}^{L} \frac{1}{2} \log(1 +\frac{P_l}{\sigma_l^2}) + \lambda (\sum_{l = 1}^{L} P_l - P)  $$</span></p><p>对第一项求最大，第二项为约束条件 令 <span class="math inline">$\frac{\partial f( )}{\partial P_l} =0$</span>，<span class="math inline"><em>l</em> = 1, 2, ⋯, <em>L</em></span> 得 <span class="math display">$$  \begin{align*}  \frac{1}{2} \frac{1}{P_l + \sigma_l^2} + \lambda = 0 \quad, \quad l =1,2,\cdots,L\\  \Rightarrow P_l + \sigma_l^2 = -\frac{1}{2\lambda} \quad, \quad l =1,2,\cdots,L  \end{align*}  $$</span></p><p>令各时刻信道输出总功率（信号功率 <span class="math inline"><em>P</em><sub><em>l</em></sub></span> + 噪声功率<span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup></span>）相等，设为<span class="math inline"><em>V</em></span> <span class="math display">$$  V = \frac{P + \sum_{l = 1}^{L} \sigma_l^2}{L}  $$</span></p><p>当 <span class="math inline">$P_l = V - \sigma_l^2 = \frac{P +\sum_{l = 1}^{L} \sigma_l^2}{L} - \sigma_l^2$</span>，<span class="math inline"><em>l</em> = 1, 2, ⋯, <em>L</em></span>时，<strong>信道传输率达到最大</strong> <span class="math display">$$  \begin{align*}  C &amp;= \sum_{l = 1}^{L} \frac{1}{2} \log(1 +\frac{P_l}{\sigma_l^2})  = \frac{1}{2} \sum_{l = 1}^{L} \log \frac{P +\sum_{l = 1}^{L} \sigma_l^2}{L\sigma_l^2} \\  &amp;= \frac{1}{2} \sum_{l = 1}^{L} \log \frac{V}{\sigma_l^2}  \end{align*}  $$</span></p><p>若 <span class="math inline"><em>σ</em><sub><em>l</em></sub><sup>2</sup></span>太大，大于 <span class="math inline"><em>V</em></span>，则置 <span class="math inline"><em>P</em><sub><em>l</em></sub> = 0</span>，然后重新调整功率分配，直到<span class="math inline"><em>P</em><sub><em>l</em></sub></span>不再出现负值。</p></li><li><p><strong>例题</strong>：<img src="image-88.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul></li></ol><h3 id="限时限频限功率加性高斯白噪声信道">限时限频限功率加性高斯白噪声信道</h3><h4 id="波形信道限时-t_b限频-omega">波形信道，限时 <span class="math inline"><em>t</em><sub><em>B</em></sub></span>，限频 <span class="math inline"><em>ω</em></span></h4><ul><li><strong>信道模型</strong>：<ul><li><figure><img src="image-30.png" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"><figcaption aria-hidden="true">信道模型</figcaption></figure></li></ul></li><li><strong>互信息</strong>： <span class="math display">$$  \begin{align*}  I(x(t); y(t)) &amp;= \lim_{L \to \infty} I(\vec{X}; \vec{Y}) \\  &amp;= \lim_{L \to \infty} [H_c(\vec{X}) - H_c(\vec{X}|\vec{Y})] \\  &amp;= \lim_{L \to \infty} [H_c(\vec{Y}) - H_c(\vec{Y}|\vec{X})] \quad\text{bit/波形}  \end{align*}  $$</span></li><li><strong>单位时间内的信息传输率</strong> <span class="math inline"><em>R</em><sub><em>t</em></sub></span> 为： <span class="math display">$$  R_t=\lim_{t_B \to \infty}\frac{1}{t_B}I(\vec{X}; \vec{Y})\quad \text{bit/秒} \quad (t_B：\text{秒/波形})  $$</span></li><li><strong>信道容量</strong>: <span class="math display">$$  C_t=\max_{p(x)}[\lim_{t_B \to \infty}\frac{1}{t_B}I(\vec{X};\vec{Y})]\quad \text{ bit/秒}  $$</span></li><li>带宽受限加性高斯白噪声 <span class="math inline"><em>n</em>(<em>t</em>)</span>，均值为0，功率谱密度<span class="math inline">$\frac{N_0}{2}$</span></li></ul><h4 id="加性高斯白噪声">加性高斯白噪声</h4><ul><li><strong>模型</strong>： <img src="image-31.png" srcset="/img/loading/loading3.gif" lazyload alt="模型"><ul><li><span class="math inline"><em>y</em>(<em>t</em>) = <em>x</em>(<em>t</em>) + <em>n</em>(<em>t</em>)</span></li><li>相关函数:<ul><li><span class="math inline"><em>P</em><sub><em>n</em></sub>(<em>n</em>) ∼ <em>N</em>(0, <em>σ</em><sup>2</sup>)</span></li><li><span class="math inline">$R_n(\tau) =\frac{N_0}{2}\delta(\tau)$</span></li><li>功率谱密度 <span class="math inline">$\Phi_n(f) =\frac{N_0}{2}$</span></li><li>总噪声功率 $^2 = = N_0$</li><li><span class="math inline"><em>N</em><sub>0</sub> = <em>k</em><em>T</em></span></li><li>波茨曼常数 <span class="math inline"><em>k</em></span></li><li>绝对温度 <span class="math inline"><em>T</em></span></li></ul></li></ul></li></ul><h4 id="低频带宽受限通信系统">低频带宽受限通信系统</h4><ul><li><p>在 <span class="math inline">[0, <em>t</em><sub><em>B</em></sub>]</span>内，采样个数 <span class="math inline"><em>L</em> = 2<em>ω</em><em>t</em><sub><em>B</em></sub></span>，各样本值彼此独立。</p></li><li><p>通信带宽为 $2$，噪声功率为 $2=N_0$ <span class="math display">$$  \begin{align*}  &amp;C=\frac{1}{2}\sum_{l = 1}^{L}\log(1 + \frac{P_l}{\sigma_l^2})\\  &amp;\sigma_l^2 = P_n=\frac{\frac{N_0}{2}\cdot 2\omega \cdott_B}{L}=\frac{\frac{N_0}{2}\cdot 2\omega \cdot t_B}{2\omega \cdott_B}=\frac{N_0}{2}\\  &amp;P_l = \frac{P_s t_B}{2\omega t_B}=\frac{P_s}{2\omega }  \end{align*}  $$</span></p></li><li><p>对于平稳系统 <span class="math display">$$  \begin{align*}  C&amp;=\frac{L}{2}\log(1 + \frac{P_s}{2\omega }\cdot\frac{2}{N_0})\\  &amp;=\frac{L}{2}\log(1 + \frac{P_s}{N_0\omega })\\  &amp;=\omega t_B\log(1 + \frac{P_s}{N_0\omega }) \quad \text{ bit}/L\text{维符号序列}  \end{align*}  $$</span></p></li><li><p>单位时间的信道容量 <span class="math display">$$  \begin{align*}  C_t&amp;=\lim_{t_B \to \infty}\frac{C}{t_B}\\  &amp;=\omega \log(1 + \frac{P_s}{N_0\omega })\quad \text{ bit/秒}\\  &amp;=\omega \log(1 + SNR)\quad \text{ bit/秒}  \end{align*}  $$</span></p><p>其中:</p><ul><li><span class="math inline"><em>P</em><sub><em>s</em></sub></span>：信号平均功率</li><li><span class="math inline"><em>N</em><sub>0</sub><em>ω</em></span>：噪声在系统中的平均功率（<span class="math inline">$\frac{N_0}{2}\cdot 2\omega=N_0\omega$</span>）</li><li><span class="math inline"><em>S</em><em>N</em><em>R</em><sub><em>d</em><em>B</em></sub> = 10log<sub>10</sub><em>S</em><em>N</em><em>R</em></span></li></ul></li><li><p>例题：<img src="image-102.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="多输入多输出信道及其容量">3.5 多输入多输出信道及其容量</h2><blockquote><p>略</p></blockquote><h2 id="信源与信道的匹配">3.6 信源与信道的匹配</h2><ul><li><strong>符号匹配</strong><ul><li><figure><img src="image-32.png" srcset="/img/loading/loading3.gif" lazyload alt="符号匹配"><figcaption aria-hidden="true">符号匹配</figcaption></figure></li><li>信源编码：将信源符号转换为信道符号</li></ul></li><li><strong>信息匹配</strong><ul><li>信道绝对冗余度 <span class="math inline"><em>R</em><sub><em>a</em></sub> = <em>C</em> − <em>I</em>(<em>X</em>; <em>Y</em>)</span></li><li>信道相对冗余度 <span class="math inline">$R_r = 1 -\frac{I(X;Y)}{C}$</span></li><li>信道效率 <span class="math inline">$E =\frac{I(X;Y)}{C}$</span></li></ul></li></ul><h1 id="第四章-信息率失真函数">第四章 信息率失真函数</h1><h2 id="信息率失真函数的概念和性质">4.1 信息率失真函数的概念和性质</h2><h3 id="失真函数">失真函数</h3><ul><li><p><strong>信源编码器模型</strong>：</p><ul><li><figure><img src="image-34.png" srcset="/img/loading/loading3.gif" lazyload alt="失真函数"><figcaption aria-hidden="true">失真函数</figcaption></figure></li><li>信源 <span class="math inline"><em>X</em> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li>经信源编码器输出 <span class="math inline"><em>Y</em> ∈ {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li></ul></li><li><p><strong>失真函数</strong> <span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span>定义为： <span class="math display">$$d(x_i,y_j)=\begin{cases}0, &amp;x_i = y_j \\ \alpha, &amp; \alpha&gt;0, x_i\neqy_j\end{cases}$$</span></p></li><li><p><strong>失真矩阵</strong> <span class="math inline"><em>d</em></span> 定义为： <span class="math display">$$d = [d(x_i,y_j)]_{n×m} =\begin{bmatrix}d(a_1,b_1)&amp;d(a_1,b_2)&amp;\cdots&amp;d(a_1,b_m)\\\cdots\\d(a_n,b_1)&amp;d(a_n,b_2)&amp;\cdots&amp;d(a_n,b_m)\end{bmatrix}$$</span></p></li><li><p><span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span>的函数形式可任意选择，常用的有：</p><ul><li><strong>均方失真</strong>：<span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = (<em>x</em><sub><em>i</em></sub> − <em>y</em><sub><em>j</em></sub>)<sup>2</sup></span>（连续信源）</li><li><strong>绝对失真</strong>：<span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = |<em>x</em><sub><em>i</em></sub> − <em>y</em><sub><em>j</em></sub>|</span>（连续信源）</li><li><strong>相对失真</strong>：<span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>) = |<em>x</em><sub><em>i</em></sub> − <em>y</em><sub><em>j</em></sub>|/|<em>x</em><sub><em>i</em></sub>|</span>（连续信源）</li><li><strong>误码失真</strong>：<span class="math inline">$d(x_i,y_j)=\delta(x_i,y_j)=\begin{cases}0, &amp;x_i = y_j \\ 1, &amp; 其他\end{cases}$</span> （离散信源）</li></ul></li><li><p>例题：<img src="image-89.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h3 id="平均失真">平均失真</h3><ul><li><p>对于离散随机变量，<strong>平均失真</strong> <span class="math inline">$\overline{D}$</span> 的计算公式为： <span class="math display">$$  \begin{aligned}  \overline{D} = E(d(x_i,y_j)) &amp;= \sum_{i = 1}^{n}\sum_{j =1}^{m}p(a_i,b_j)d(a_i,b_j) \\  &amp;= \sum_{i = 1}^{n}\sum_{j = 1}^{m}p(a_i)p(b_j|a_i)d(a_i,b_j)  \end{aligned}  $$</span></p><p>其中:</p><ul><li><span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>是信源符号分布</li><li><span class="math inline"><em>p</em>(<em>b</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub>)</span>是有失真编码器转移概率分布</li><li><span class="math inline"><em>d</em>(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>j</em></sub>)</span>是离散随机变量失真函数</li></ul></li></ul><h3 id="信息率失真函数-rd">信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span></h3><ul><li><p>将信源编码器看作信道：<img src="image-35.png" srcset="/img/loading/loading3.gif" lazyload alt="假想信道"></p></li><li><p>编码的目的：</p><ul><li>使传输率 <span class="math inline"><em>R</em></span> 尽量小</li><li>但是<span class="math inline"><em>R</em></span> 越小，<span class="math inline">$\overline{D}$</span> 越大</li><li>在满足 <span class="math inline">$\overline{D} \leq D$</span>条件下，选择一种编码方法使 <span class="math inline"><em>R</em></span>尽量小</li></ul></li><li><p><strong>信息传输率</strong> <span class="math inline"><em>R</em> = <em>I</em>(<em>X</em>; <em>Y</em>)</span>，计算公式为：<span class="math display">$$  \begin{aligned}  R = I(X;Y) &amp; =\sum_{i,j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{p(y_j)} \\  &amp;=\sum_{i,j}p(x_i)p(y_j|x_i)\log\frac{p(y_j|x_i)}{\sum_{i}p(x_i)p(y_j|x_i)}  \end{aligned}  $$</span></p></li><li><p>对于某特定信源，<span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span>确定，<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 是关于<span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span>的凸函数（<span class="math inline">∪</span>型下凸函数），可以从信道集合<span class="math inline"><em>P</em><sub><em>D</em></sub></span>中找到一种信道 <span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span>，使<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span>最小。</p><ul><li><strong>信道集合</strong> <span class="math inline"><em>P</em><sub><em>D</em></sub></span>（<span class="math inline"><em>D</em></span>允许试验信道）定义为： <span class="math display">$$P_D = \{p(b_j|a_i) \quad|\quad \overline{D} \leqD, i = 1,2,\cdots,n;j = 1,2,\cdots,m\}$$</span></li><li><strong>信息率失真函数</strong> <span class="math inline"><em>R</em>(<em>D</em>)</span> 为： <span class="math display"><em>R</em>(<em>D</em>) = min<sub><em>P</em><sub><em>D</em></sub></sub><em>I</em>(<em>X</em>; <em>Y</em>)</span></li><li>对于<strong>离散无记忆信道</strong>，<span class="math inline"><em>R</em>(<em>D</em>)</span> 可写成： <span class="math display">$$R(D)=\min_{P_{ij}\in P_D}\sum_{i = 1}^{n}\sum_{j= 1}^{m}p(a_i)p(b_j|a_i)\log\frac{p(b_j|a_i)}{p(b_j)}$$</span></li></ul></li><li><p>例题：<img src="image-36.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h3 id="信息率失真函数的性质">信息率失真函数的性质</h3><h4 id="rd函数的定义域"><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的定义域</h4><ol type="1"><li><strong><span class="math inline"><em>D</em><sub><em>m</em><em>i</em><em>n</em></sub></span>和<span class="math inline"><em>R</em>(<em>D</em><sub><em>m</em><em>i</em><em>n</em></sub>)</span></strong><ul><li>平均失真<span class="math inline"><em>D</em></span>是失真函数<span class="math inline"><em>d</em>(<em>x</em>, <em>y</em>)</span>的数学期望，因此<span class="math inline"><em>D</em></span>也是非负实数，所以<span class="math inline"><em>D</em><sub><em>m</em><em>i</em><em>n</em></sub> = 0</span>。</li><li><span class="math display"><em>R</em>(<em>D</em><sub><em>m</em><em>i</em><em>n</em></sub>) = <em>R</em>(0) = <em>H</em>(<em>X</em>)</span>等式成立的条件：<ul><li><span class="math inline"><em>D</em><sub><em>m</em><em>i</em><em>n</em></sub> = 0</span>：失真矩阵中每行至少有一个零，令条件概率在该行该处为1</li><li><span class="math inline"><em>R</em>(0) = <em>H</em>(<em>X</em>)</span>：每一列最多只有一个零，否则多个<span class="math inline"><em>X</em></span>对应一个<span class="math inline"><em>Y</em></span>，<span class="math inline"><em>R</em>(0) = <em>H</em>(<em>Y</em>) &lt; <em>H</em>(<em>X</em>)</span>。</li></ul></li><li>对于连续信源，<span class="math inline"><em>R</em>(<em>D</em><sub><em>m</em><em>i</em><em>n</em></sub>) = <em>R</em>(0) = <em>H</em><sub><em>c</em></sub>(<em>X</em>) = ∞</span>。</li></ul></li><li><strong><span class="math inline"><em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>和<span class="math inline"><em>R</em>(<em>D</em><sub><em>m</em><em>a</em><em>x</em></sub>)</span></strong><ul><li><p><span class="math display"><em>D</em><sub><em>m</em><em>a</em><em>x</em></sub> = min<sub><em>R</em>(<em>D</em>) = 0</sub><em>D</em></span><span class="math display"><em>R</em>(<em>D</em><sub><em>m</em><em>a</em><em>x</em></sub>) = 0</span></p></li><li><p>当<span class="math inline"><em>R</em>(<em>D</em>) = 0</span>，即<span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>) = 0</span>，<span class="math inline"><em>X</em></span>、<span class="math inline"><em>Y</em></span>互相独立，<span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>) = <em>p</em>(<em>y</em><sub><em>j</em></sub>) = <em>p</em><sub><em>j</em></sub></span></p></li><li><p><span class="math display">$$\overline{D}=\sum_{i = 1}^{n}\sum_{j= 1}^{m}p_ip_jd_{ij}$$</span> 其中<span class="math inline"><em>p</em><sub><em>i</em></sub></span>、<span class="math inline"><em>d</em><sub><em>i</em><em>j</em></sub></span>已知，<span class="math inline"><em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>为满足<span class="math inline">∑<sub><em>j</em></sub><em>p</em><sub><em>j</em></sub> = 1</span>条件下<span class="math inline">$\overline{D}$</span>的最小值。</p></li><li><p><span class="math display">$$\begin{align*}D_{max} &amp; =\min\sum_{j = 1}^{m}p_j\sum_{i = 1}^{n}p_id_{ij} \\&amp;=\min_{j = 1,2,\cdots,m}\sum_{i = 1}^{n}p_id_{ij}\end{align*}$$</span> 即在<span class="math inline"><em>j</em> = 1, 2, ⋯, <em>m</em></span>中，找到<span class="math inline">$\sum_{i = 1}^{n}p_id_{ij}$</span>值最小的一列<span class="math inline"><em>j</em></span>，此时取<span class="math inline"><em>p</em><sub><em>j</em></sub> = 1</span>，其余置<span class="math inline">0</span></p></li></ul></li><li><strong><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的定义域和值域</strong><ul><li><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的最大定义域为<span class="math display">$$[0\quad, \min_{j = 1,2,\cdots,m}\sum_{i =1}^{n}p_id_{ij}]$$</span></li><li><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的最大值域为<span class="math display">[0, <em>H</em>(<em>X</em>)]</span></li><li><figure><img src="image-37.png" srcset="/img/loading/loading3.gif" lazyload alt="函数图像"><figcaption aria-hidden="true">函数图像</figcaption></figure></li></ul></li></ol><ul><li>例题：<ul><li><figure><img src="image-90.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li><li><figure><img src="image-91.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li></ul></li></ul><h4 id="rd函数的下凸性和连续性"><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的下凸性和连续性</h4><ul><li><figure><img src="image-38.png" srcset="/img/loading/loading3.gif" lazyload alt="函数图像"><figcaption aria-hidden="true">函数图像</figcaption></figure></li><li><p><strong>下凸性</strong>： <span class="math display"><em>D</em><sup><em>α</em></sup> = <em>α</em><em>D</em><sup>′</sup> + (1 − <em>α</em>)<em>D</em><sup>″</sup>  0 ≤ <em>α</em> ≤ 1</span></p><p>有 <span class="math display"><em>R</em>(<em>D</em><sup><em>α</em></sup>) ≤ <em>α</em><em>R</em>(<em>D</em><sup>′</sup>) + (1 − <em>α</em>)<em>R</em>(<em>D</em><sup>″</sup>)</span></p></li><li><p><strong>连续性</strong>： 设 <span class="math inline"><em>D</em><sup>′</sup> = <em>D</em> + <em>δ</em></span>，当<span class="math inline"><em>δ</em> → 0</span> 时，<span class="math inline"><em>P</em><sub><em>D</em><sup>′</sup></sub> → <em>P</em><sub><em>D</em></sub></span>，<span class="math inline"><em>R</em>(<em>D</em><sup>′</sup>) → <em>R</em>(<em>D</em>)</span>。</p></li></ul><h4 id="rd函数的单调递减性"><span class="math inline"><em>R</em>(<em>D</em>)</span>函数的单调递减性</h4><ul><li>允许的失真度越大，所要求的信息率就越小。</li><li>规定了允许失真 <span class="math inline"><em>D</em></span>，及失真函数 <span class="math inline"><em>d</em>(<em>i</em>, <em>j</em>)</span>，可以找到<span class="math inline"><em>R</em>(<em>D</em>)</span>，作为衡量信源编码压缩难度的一把尺子。</li></ul><h4 id="信息率失真函数与信道容量">信息率失真函数与信道容量</h4><table><thead><tr><th style="text-align: left;"></th><th style="text-align: left;">信道容量 <span class="math inline"><em>C</em></span></th><th style="text-align: left;">信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span></th></tr></thead><tbody><tr><td style="text-align: left;">研究对象</td><td style="text-align: left;">信道</td><td style="text-align: left;">信源</td></tr><tr><td style="text-align: left;">给定条件</td><td style="text-align: left;"><span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>∥<em>x</em><sub><em>i</em></sub>)</span></td><td style="text-align: left;"><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span></td></tr><tr><td style="text-align: left;">选择参数</td><td style="text-align: left;"><span class="math inline"><em>p</em>(<em>x</em><sub><em>i</em></sub>)</span></td><td style="text-align: left;"><span class="math inline"><em>p</em>(<em>y</em><sub><em>j</em></sub>∥<em>x</em><sub><em>i</em></sub>)</span></td></tr><tr><td style="text-align: left;">结论</td><td style="text-align: left;"><span class="math inline"><em>C</em> = max<sub><em>p</em>(<em>x</em>)</sub><em>I</em>(<em>X</em>; <em>Y</em>)</span></td><td style="text-align: left;"><span class="math inline"><em>R</em>(<em>D</em>) = min<sub><em>P</em><sub><em>D</em></sub></sub><em>I</em>(<em>X</em>; <em>Y</em>)</span></td></tr><tr><td style="text-align: left;"><span class="math inline"><em>H</em>(<em>X</em>∥<em>Y</em>) = <em>H</em>(<em>X</em>) − <em>I</em>(<em>X</em>; <em>Y</em>)</span></td><td style="text-align: left;">噪声干扰丢失的信息量</td><td style="text-align: left;">编码压缩损失的信息量</td></tr></tbody></table><h2 id="信息率失真函数rd的计算参量表示法">4.2 信息率失真函数<span class="math inline"><em>R</em>(<em>D</em>)</span>的计算（参量表示法）</h2><h3 id="例题">例题</h3><ol type="1"><li><strong>例题1</strong>： 已知<span class="math inline"><em>X</em>, <em>Y</em> ∈ {0, 1}</span>，<span class="math inline">$p(X) =\begin{cases}p, &amp;X=0 \\ 1-p, &amp;X=1\end{cases}$</span>，<span class="math inline">$0 &lt;p\leq\frac{1}{2}$</span>，<span class="math inline">$d(x,y)=\begin{cases}1, &amp; x\neq y \\ 0, &amp; x= y\end{cases}$</span> <strong>证明</strong>：<span class="math inline">$R(D)=\begin{cases}H_b(p)-H_b(D), &amp; 0\leq D\leqp \\ 0, &amp; D &gt; p\end{cases}$</span>，其中<span class="math inline"><em>H</em><sub><em>b</em></sub>(<em>p</em>) = <em>H</em>(<em>p</em>, 1 − <em>p</em>)</span>，<span class="math inline"><em>H</em><sub><em>b</em></sub>(<em>D</em>) = <em>H</em>(<em>D</em>, 1 − <em>D</em>)</span><ul><li>由<span class="math inline"><em>R</em>(<em>D</em>)</span>性质可得<strong>定义域</strong>：失真矩阵 <span class="math inline">$d=\begin{bmatrix}0&amp;1\\1&amp;0\end{bmatrix}$</span>，令转移概率矩阵<span class="math inline">$P=\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix}$</span><span class="math inline"><em>D</em><sub><em>m</em><em>i</em><em>n</em></sub> = 0</span>，<span class="math inline"><em>R</em>(0) = <em>H</em>(<em>X</em>) = <em>H</em><sub><em>b</em></sub>(<em>p</em>)</span><span class="math inline"><em>D</em><sub><em>m</em><em>a</em><em>x</em></sub> = min [<em>p</em>, 1 − <em>p</em>]</span>= p</li><li><strong>求<span class="math inline"><em>R</em>(<em>D</em>)</span></strong>： <span class="math inline"><em>R</em>(<em>D</em>) = min <em>I</em>(<em>X</em>; <em>Y</em>)</span>，限制条件<span class="math inline">$P_D = \{p(y|x) | \overline{D}=E(d(X,Y))\leq D\leqD_{max} = p\}$</span> 令 <span class="math inline">$Z = d(X,Y) =\begin{cases}1, &amp; x\neq y \\ 0, &amp; x = y\end{cases}$</span> <span class="math inline"><em>p</em>(<em>x</em>|<em>y</em>) = <em>p</em>(<em>z</em>|<em>y</em>)</span>，<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>) = <em>H</em>(<em>Z</em>|<em>Y</em>)</span>又<span class="math inline">$p(z=1) = p_r(x \neq y)=E(d(X,Y))\leq D\leqp\leq \frac{1}{2}$</span> 且<span class="math inline"><em>H</em><sub><em>b</em></sub>(<em>x</em>)</span>函数关于<span class="math inline">$\frac{1}{2}$</span>对称，在<span class="math inline">$0\leq x \leq\frac{1}{2}$</span>范围内，<span class="math inline"><em>H</em><sub><em>b</em></sub>(<em>x</em>)</span>函数单调递增。则<span class="math inline"><em>H</em>(<em>Z</em>) = <em>H</em><sub><em>b</em></sub>(<em>p</em><sub><em>r</em></sub>(<em>x</em> ≠ <em>y</em>)) ≤ <em>H</em><sub><em>b</em></sub>(<em>D</em>)</span><span class="math display">$$  \begin{align*}  I(X;Y)&amp;=H(X)-H(X|Y)\\  &amp;=H_b(p)-H(X|Y)\\  &amp;=H_b(p)-H(Z|Y)（令z=d(x,y)）\\  &amp;\geq H_b(p)-H(Z) （H(Z|Y)\leq H(Z)）\\  &amp;\geq H_b(p)-H_b(D) （H(Z) \leq H_b(D)）  \end{align*}  $$</span> 所以<span class="math inline"><em>R</em>(<em>D</em>) ≥ <em>H</em><sub><em>b</em></sub>(<em>p</em>) − <em>H</em><sub><em>b</em></sub>(<em>D</em>)</span></li><li><strong>证明下界可达</strong>： 构造反向BSC信道如图：<img src="image-41.png" srcset="/img/loading/loading3.gif" lazyload alt="BSC信道"> 令<span class="math inline"><em>X</em>, <em>Y</em> ∈ {0, 1}</span>，<span class="math inline">$p(Y) =\begin{cases}p, &amp;Y=0 \\ 1-p, &amp;Y=1\end{cases}$</span>，<span class="math inline">$d(x,y)=\begin{cases}1,&amp; x\neq y \\ 0, &amp; x = y\end{cases}$</span> 转移概率矩阵 <span class="math inline">$P=\begin{bmatrix}1-D &amp; D\\D &amp; 1-D\end{bmatrix}$</span> 则<span class="math inline"><em>R</em> = <em>I</em>(<em>X</em>; <em>Y</em>) = <em>H</em>(<em>Y</em>) − <em>H</em>(<em>Y</em>|<em>X</em>) = <em>H</em><sub><em>b</em></sub>(<em>p</em>) − <em>H</em><sub><em>b</em></sub>(<em>D</em>)</span>，达到下界只需证明存在<span class="math inline"><em>α</em></span>满足<span class="math inline">0 ≤ <em>α</em> ≤ 1</span>，使得<span class="math inline">$p(X) =\begin{cases}\alpha, &amp;X=0 \\ 1-\alpha,&amp;X=1 \end{cases}$</span> 易知<span class="math inline"><em>p</em> = <em>α</em>(1 − <em>D</em>) + <em>D</em>(1 − <em>α</em>)</span>，即<span class="math inline">$\alpha=\frac{p - D}{1 - 2D}$</span> 因为<span class="math inline">$0 \leq D \leq p \leq \frac{1}{2}$</span>，<span class="math inline"><em>p</em> + <em>D</em> ≤ 1</span> 由此可得<span class="math inline">$0\leq\alpha=\frac{p - D}{1 -2D}\leq1$</span>，即存在<span class="math inline"><em>α</em></span>满足条件</li></ul></li><li><strong>例题2</strong>：<img src="image-40.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li><li><strong>结论</strong>：<strong>二元信源失真函数<span class="math inline">$R(D)=\begin{cases}H_b(p)-H_b(D), &amp; 0\leq D\leqp \\ 0, &amp; D &gt; p\end{cases}$</span></strong></li></ol><h3 id="参量表示法">参量表示法</h3><ol type="1"><li><p><strong>条件与记号</strong> 设离散信源的输入序列为 <span class="math display">$$\begin{bmatrix} X \\ P \end{bmatrix} =\begin{bmatrix} x_1 &amp; x_2 &amp; \cdots &amp; x_n \\ p(x_1) &amp;p(x_2) &amp; \cdots &amp; p(x_n) \end{bmatrix}$$</span></p><p>输出序列为 <span class="math display">$$\begin{bmatrix} Y \\ P \end{bmatrix} =\begin{bmatrix} y_1 &amp; y_2 &amp; \cdots &amp; y_m \\ p(y_1) &amp;p(y_2) &amp; \cdots &amp; p(y_m) \end{bmatrix}$$</span></p><p>字符传输的失真函数为 <span class="math inline"><em>d</em>(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>j</em></sub>)</span>， <span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span> ；<span class="math inline"><em>j</em> = 1, 2, ⋯, <em>m</em></span> 。为了书写方便，引入记号： <span class="math display">$$d_{ij} = d(x_i,y_j), \quad p_{ij} = p(y_j\mid x_i)\\p_i = p(x_i), \quad q_j = p(y_j)$$</span></p><p>式中 <span class="math display">$$p(y_j)=\sum_{i =1}^{n}p(x_i)p(y_j\mid x_i)=\sum_{i = 1}^{n}p_ip_{ij}$$</span></p></li><li><p><strong>问题转换</strong> 信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span> 的计算为在约束条件<span class="math display">$$\begin{cases}\sum_{i = 1}^{n}\sum_{j = 1}^{m}p_ip_{ij}d_{ij} = D \\\sum_{j = 1}^{m}p_{ij} = 1 \quad i = 1,2,\cdots,n\end{cases} \quad ①$$</span></p><p>下，求下式极小值问题。 <span class="math display">$$I(X;Y)=\sum_{i = 1}^{n}\sum_{j = 1}^{m}p_ip_{ij}\ln\frac{p_{ij}}{q_j}\quad ②$$</span></p><p>应用拉格朗日乘法，引入乘子 <span class="math inline"><em>s</em></span> 和 <span class="math inline"><em>μ</em><sub><em>i</em></sub></span> ， <span class="math inline"><em>i</em> = 1, 2, ⋯, <em>n</em></span>将上述条件极值问题化成无条件极值问题： <span class="math display">$$\frac{\partial}{\partial p_{ij}}\left[I(X;Y)-sD - \mu_i\sum_{j =1}^{m}p_{ij}\right]=0\quad i = 1,2,\cdots,n \quad ③$$</span></p></li><li><p><strong>求解</strong> 由上式 ③ 解出 <span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>，代入式 ② 中得到在约束条件式 ① 下的 <span class="math inline"><em>I</em>(<em>X</em>; <em>Y</em>)</span> 极小值，即<span class="math inline"><em>R</em>(<em>D</em>)</span> 。</p><p><span class="math display">$$\begin{align*}\frac{\partial I(X;Y)}{\partial p_{ij}}&amp;=\frac{\partial}{\partialp_{ij}}\left[\sum_{i = 1}^{n}\sum_{j =1}^{m}p_ip_{ij}\ln\frac{p_{ij}}{q_j}\right]\\&amp;=\frac{\partial}{\partial p_{ij}}\left[\sum_{i = 1}^{n}\sum_{j =1}^{m}p_ip_{ij}\ln p_{ij}-\sum_{i = 1}^{n}\left(\sum_{j =1}^{m}p_ip_{ij}\right)\ln q_j\right]\\&amp;=\frac{\partial}{\partial p_{ij}}\left[\sum_{i = 1}^{n}\sum_{j =1}^{m}p_ip_{ij}\ln p_{ij}-\sum_{j = 1}^{m}q_j\ln q_j\right]\\&amp;=\left[p_ip_{ij}\frac{1}{p_{ij}} + p_i\lnp_{ij}\right]-\left[q_j\frac{1}{q_j}\frac{\partial q_j}{\partialp_{ij}}+\frac{\partial q_j}{\partial p_{ij}}\ln q_j\right]\\&amp;=\left[p_i + p_i\ln p_{ij}\right]-\left[p_i + p_i\ln q_j\right]\\&amp;=p_i\ln\frac{p_{ij}}{q_j}\\     \frac{\partial [sD]}{\partial p_{ij}}&amp;=\frac{\partial}{\partialp_{ij}}\left[s\sum_{i = 1}^{n}\sum_{j =1}^{m}p_ip_{ij}d_{ij}\right]=sp_id_{ij}\\\frac{\partial}{\partial p_{ij}}&amp;\left[\mu_i\sum_{j =1}^{m}p_{ij}\right]=\mu_i\end{align*}$$</span></p><p>所以式 ③ 化为： <span class="math display">$$p_i\ln\frac{p_{ij}}{q_j}-sp_id_{ij}-\mu_i = 0\quad     i =1,2,\cdots,n;j = 1,2,\cdots,m \quad ④$$</span></p><p>由式 ④ 解出 <span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span> ：<span class="math display">$$p_{ij} = q_j\exp\{sd_{ij}\}\exp\left\{\frac{\mu_i}{p_i}\right\} \quad i= 1,2,\cdots,n;j = 1,2,\cdots,m \quad ⑤$$</span></p><p>令 <span class="math inline">$\lambda_i=\exp\left\{\frac{\mu_i}{p_i}\right\}$</span>，代入式 ⑤ 中得到： <span class="math display"><em>p</em><sub><em>i</em><em>j</em></sub> = <em>λ</em><sub><em>i</em></sub><em>q</em><sub><em>j</em></sub>exp {<em>s</em><em>d</em><sub><em>i</em><em>j</em></sub>}  <em>i</em> = 1, 2, ⋯, <em>n</em>; <em>j</em> = 1, 2, ⋯, <em>m</em>  ⑥</span></p><p>由 <span class="math inline">$\sum_{j = 1}^{m}p_{ij} = 1$</span>，将式 ⑥ 对 <span class="math inline"><em>j</em></span> 求和可得到 <span class="math display">$$1=\sum_{j = 1}^{m}\lambda_iq_j\exp\{sd_{ij}\} \quad i = 1,2,\cdots,n\quad ⑦$$</span></p><p>由式 ⑦ 可解出 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 的值 <span class="math display">$$\lambda_i=\frac{1}{\sum_{j = 1}^{m}q_j\exp\{sd_{ij}\}} \quad ⑧$$</span></p><p>由 <span class="math inline">$q_j=\sum_{i = 1}^{n}p_ip_{ij}$</span>，将式 ⑥ 两边同乘 <span class="math inline"><em>p</em><sub><em>i</em></sub></span> ，并对 <span class="math inline"><em>i</em></span> 求和可得到 <span class="math display">$$q_j=\sum_{i = 1}^{n}p_ip_{ij}=\sum_{i =1}^{n}\lambda_ip_iq_j\exp\{sd_{ij}\} \quad j = 1,2,\cdots,m \quad$$</span></p><p>即 <span class="math display">$$\sum_{i = 1}^{n}\lambda_ip_i\exp\{sd_{ij}\}=1 \quad j = 1,2,\cdots,m\quad ⑨$$</span></p><p>将式 ⑧ 代入式 ⑨ 中，可得到关于 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 的 <span class="math inline"><em>m</em></span> 个方程 <span class="math display">$$\sum_{i = 1}^{n}\frac{p_i\exp\{sd_{ij}\}}{\sum_{l =1}^{m}q_l\exp\{sd_{il}\}} = 1 \quad j = 1,2,\cdots,m \quad ⑩$$</span></p><p>由式 ⑩ 中可以解出以 <span class="math inline"><em>s</em></span>为参量的 <span class="math inline"><em>m</em></span> 个 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 值，将这<span class="math inline"><em>m</em></span> 个 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 值代入式 ⑧中可以解出以 <span class="math inline"><em>s</em></span> 为参量的 <span class="math inline"><em>n</em></span> 个 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span>值，再将解得的 <span class="math inline"><em>m</em></span> 个 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 值和 <span class="math inline"><em>n</em></span> 个 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 值代入式 ⑥中，可以解出以 <span class="math inline"><em>s</em></span> 为参量的<span class="math inline"><em>m</em><em>n</em></span> 个 <span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>值。</p><p>将解出的 <span class="math inline"><em>m</em><em>n</em></span> 个<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>值代入定义式中求出以 <span class="math inline"><em>s</em></span>为参量的平均失真度 <span class="math inline"><em>D</em>(<em>s</em>)</span> <span class="math display">$$D(s)=\sum_{i = 1}^{n}\sum_{j =1}^{m}\lambda_ip_iq_jd_{ij}\exp\{sd_{ij}\} \quad ⑪$$</span></p><p>其中， <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 和 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> 由式 ⑦ 和 ⑩求得。</p><p>将解出的 <span class="math inline"><em>m</em><em>n</em></span> 个<span class="math inline"><em>p</em><sub><em>i</em><em>j</em></sub></span>值代入式 ② 中得到在约束条件 ① 下的 <span class="math inline"><em>I</em>(<em>X</em>, <em>Y</em>)</span>的极小值，即以 <span class="math inline"><em>s</em></span>为参量的信息率失真函数 <span class="math inline"><em>R</em>(<em>s</em>)</span> <span class="math display">$$\begin{align*}R(s)&amp;=\sum_{i = 1}^{n}\sum_{j =1}^{m}\lambda_ip_iq_j\exp\{sd_{ij}\}\ln\frac{\lambda_iq_j\exp\{sd_{ij}\}}{q_j}\\&amp;=\sum_{i = 1}^{n}\sum_{j =1}^{m}\lambda_ip_iq_j\exp\{sd_{ij}\}(\ln\lambda_i + sd_{ij})\\&amp;=\sum_{i = 1}^{n}p_i\ln\lambda_i\left[\sum_{j =1}^{m}\lambda_iq_j\exp\{sd_{ij}\}\right]+s\sum_{i = 1}^{n}\sum_{j =1}^{m}\lambda_ip_iq_jd_{ij}\exp\{sd_{ij}\}\\&amp;=\sum_{i = 1}^{n}p_i\ln\lambda_i\left(\sum_{j =1}^{m}p_{ij}\right)+sD(s)\\&amp;=\sum_{i = 1}^{n}p_i\ln\lambda_i + sD(s) \quad ⑫\end{align*}$$</span></p><p>一般情况下，参量 <span class="math inline"><em>s</em></span>无法消去，因此得不到 <span class="math inline"><em>R</em>(<em>D</em>)</span>的闭式解，只有在某些特定的简单问题中才能消去参量 <span class="math inline"><em>s</em></span> ，得到 <span class="math inline"><em>R</em>(<em>D</em>)</span>的闭式解。若无法消去参量 <span class="math inline"><em>s</em></span>，就需要进行逐点计算。下面分析一下参量 <span class="math inline"><em>s</em></span> 的意义。</p><p>将 <span class="math inline"><em>R</em>(<em>D</em>)</span> 看成 <span class="math inline"><em>D</em>(<em>s</em>)</span> 和 <span class="math inline"><em>s</em></span> 的隐函数，而 <span class="math inline"><em>λ</em><sub><em>i</em></sub></span> 又是 <span class="math inline"><em>s</em></span> 的函数，利用全微分公式对 <span class="math inline"><em>R</em>(<em>D</em>)</span> 求导，可得 <span class="math display">$$\begin{align*}\frac{\mathrm{d}R(D)}{\mathrm{d}D}&amp;=\frac{\partial R(s)}{\partialD(s)}+\frac{\partial R(s)}{\partials}\left(\frac{\mathrm{d}s}{\mathrm{d}D}\right)+\sum_{i =1}^{n}\frac{\partial R(s)}{\partial\lambda_i}\left(\frac{\mathrm{d}\lambda_i}{\mathrm{d}D}\right)\\&amp;=s + D(s)\frac{\mathrm{d}s}{\mathrm{d}D}+\sum_{i =1}^{n}\frac{p_i}{\lambda_i}\cdot\frac{\mathrm{d}\lambda_i}{\mathrm{d}D}\\&amp;=s+\left[D(s)+\sum_{i =1}^{n}\frac{p_i}{\lambda_i}\cdot\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}\right]\frac{\mathrm{d}s}{\mathrm{d}D}\quad ⑬\end{align*}$$</span></p><p>为求出 <span class="math inline">$\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}$</span>，将式 ⑦ 对 <span class="math inline"><em>s</em></span> 求导，得到 <span class="math display">$$\sum_{i =1}^{n}\left[p_i\exp\{sd_{ij}\}\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+\lambda_ip_id_{ij}\exp\{sd_{ij}\}\right]=0$$</span></p><p>将上式两边同乘以 <span class="math inline"><em>q</em><sub><em>j</em></sub></span> ，并对 <span class="math inline"><em>j</em></span> 求和，可得 <span class="math display">$$\sum_{j = 1}^{m}q_j\sum_{i =1}^{n}\left[p_i\exp\{sd_{ij}\}\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+\lambda_ip_id_{ij}\exp\{sd_{ij}\}\right]=0$$</span></p><p>即 <span class="math display">$$\sum_{i = 1}^{n}p_i\left[\sum_{j =1}^{m}q_j\exp\{sd_{ij}\}\right]\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+\sum_{i= 1}^{n}\sum_{j = 1}^{m}\lambda_ip_iq_jd_{ij}\exp\{sd_{ij}\}=0$$</span></p><p>将式 ⑧ 和 ⑫ 代入上式，可得 <span class="math display">$$\sum_{i =1}^{n}p_i\frac{1}{\lambda_i}\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+D(s)=0\quad ⑭$$</span></p><p>将式 ⑭ 代入式 ⑬ 中，可得 <span class="math display">$$\frac{\mathrm{d}R(D)}{\mathrm{d}D}=s \quad ⑮$$</span></p><p>式 ⑮ 表明，参量 <span class="math inline"><em>s</em></span>是信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span>的斜率。由 <span class="math inline"><em>R</em>(<em>D</em>)</span> 在<span class="math inline">0 &lt; <em>D</em> &lt; <em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>之间是严格单调减函数可知， <span class="math inline"><em>s</em></span>是负值，且是 <span class="math inline"><em>D</em></span> 的递增函数，即<span class="math inline"><em>s</em></span> 将随 <span class="math inline"><em>D</em></span> 的增加而增加。 由 <span class="math inline"><em>R</em>(<em>D</em>)</span> 的性质可知，在 <span class="math inline"><em>D</em> = 0</span> 处， <span class="math inline"><em>R</em>(<em>D</em>)</span> 的斜率有可能为 <span class="math inline">−∞</span> ；当 <span class="math inline"><em>D</em> &gt; <em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>时， <span class="math inline"><em>R</em>(<em>D</em>) = 0</span>，其斜率为零。所以参量 <span class="math inline"><em>s</em></span>的取值为 <span class="math inline">(−∞, 0)</span> 。进一步还可以证明：信息率失真函数 <span class="math inline"><em>R</em>(<em>D</em>)</span> 是参量 <span class="math inline"><em>s</em></span> 的连续函数； <span class="math inline"><em>R</em>(<em>D</em>)</span> 的斜率，即参量 <span class="math inline"><em>s</em></span> 是失真度 <span class="math inline"><em>D</em></span> 的连续函数，在 <span class="math inline"><em>D</em> = <em>D</em><sub><em>m</em><em>a</em><em>x</em></sub></span>处， <span class="math inline"><em>R</em>(<em>D</em>)</span>的斜率可能是不连续的。</p></li></ol><h1 id="第五章-信源编码">第五章 信源编码</h1><h2 id="信源编码与信道编码">信源编码与信道编码</h2><ul><li><strong>信源编码</strong><ul><li><strong>无失真信源编码——第一极限定理</strong>：离散信源</li><li><strong>限失真信源编码——第三极限定理</strong>：连续信源</li><li>在不失真或允许一定失真条件下，如何用尽可能少的符号来传送信源信息，以便提高信息传输率。</li></ul></li><li><strong>信道编码</strong><ul><li><strong>第二极限定理</strong>：离散和连续信道</li><li>在信道受干扰的情况下如何增加信号的抗干扰能力，同时又使得信息传输率最大。</li></ul></li><li><strong>信源编码的作用</strong><ol type="1"><li><strong>符号变换</strong>：使信源的输出符号与信道的输入符号相匹配；</li><li><strong>信息匹配</strong>：使信息传输率达到信道容量；</li><li><strong>冗余度压缩</strong>：使编码效率等于或接近100%。</li></ol><ul><li>例题：<img src="image-42.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul></li><li><strong>信源编码的基础</strong><ol type="1"><li><strong>无失真编码定理</strong>：可精确复制信源输出的消息，只适用于离散信源</li><li><strong>限失真编码定理</strong>：对于连续信源，只能在失真受限制的情况下进行限失真编码</li></ol></li></ul><h2 id="编码的概念">5.1 编码的概念</h2><h3 id="分组码">分组码</h3><ul><li><strong>分组码(Block Codes)</strong>：也叫块码<ul><li>将信源消息分成若干组，即符号序列 <span class="math inline"><em>x</em><sub><em>i</em></sub></span> ， <span class="math display">$$\begin{align*}x_{i}&amp;=(x_{i1}x_{i2} \cdotsx_{il} \cdots x_{iL})\\x_{il}&amp;\in A=\{a_{1}, a_{2}, \cdots, a_{i},\cdots, a_{n}\}\end{align*}$$</span></li><li>每个符号序列 <span class="math inline"><em>x</em><sub><em>i</em></sub></span>依照<strong>固定码表</strong>映射成一个码字 <span class="math inline"><em>y</em><sub><em>i</em></sub></span> ， <span class="math display">$$\begin{align*}y_{i}&amp;=(y_{i1}y_{i2} \cdotsy_{ik} \cdots y_{iK})\\y_{ik}&amp;\in B=\{b_{1}, b_{2}, \cdots, b_{i},\cdots, b_{m}\}\end{align*}$$</span></li><li>只有分组码才有对应的码表，而非分组码中则不存在码表。</li><li><strong>模型</strong>：<img src="image-43.png" srcset="/img/loading/loading3.gif" lazyload alt="模型"></li></ul></li><li><strong>定长码与变长码</strong>：码可分为两类：<ul><li><strong>定长码</strong>：码中所有码字的长度都相同，如码1就是定长码(FixedLength Codes)。</li><li><strong>变长码</strong>：码中的码字长短不一，如码2就是变长码(VariableLength Codes)。</li><li><table><thead><tr><th>符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span></th><th>信源符号出现概率 <span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span></th><th>码1</th><th>码2</th></tr></thead><tbody><tr><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline"><em>p</em>(<em>a</em><sub>1</sub>)</span></td><td>00</td><td>0</td></tr><tr><td><span class="math inline"><em>a</em><sub>2</sub></span></td><td><span class="math inline"><em>p</em>(<em>a</em><sub>2</sub>)</span></td><td>01</td><td>01</td></tr><tr><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline"><em>p</em>(<em>a</em><sub>3</sub>)</span></td><td>10</td><td>001</td></tr><tr><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline"><em>p</em>(<em>a</em><sub>4</sub>)</span></td><td>11</td><td>111</td></tr></tbody></table></li></ul></li><li><strong>码的属性</strong>：<ul><li><strong>奇异码与非奇异码</strong>：<ul><li>若信源符号和码字是一一对应的，则该码为<strong>非奇异码</strong>(Non-SingularCodes)；</li><li>反之为<strong>奇异码</strong>(Singular Codes)</li></ul></li><li><strong>唯一可译码(Uniquely Decodable Codes_)</strong>：<ul><li>任意有限长的码元序列，只能被唯一地分割成一个个的码字，便称为唯一可译码。</li><li>奇异码不是唯一可译码</li><li>唯一可译码分为非即时码和即时码<ul><li><strong>非即时码</strong>指接收端收到一个完整的码字后不能立即译码，还需等下一个码字开始接收后才能判断是否可以译码</li><li><strong>即时码</strong>只要收到符号就表示该码字已完整，可以立即译码，又称为<strong>非延长码</strong>(UndelayedCodes)，任意一个码字都不是其它码字的前缀部分，又称为<strong>异前缀码</strong>(PrefixCodes)。</li></ul></li></ul></li></ul></li></ul><h3 id="码的分类">码的分类</h3><figure><img src="image-121.png" srcset="/img/loading/loading3.gif" lazyload alt="码的分类"><figcaption aria-hidden="true">码的分类</figcaption></figure><h3 id="即时码及其树图构造法">即时码及其树图构造法</h3><ul><li><p>即时码(非延长码或异前缀码)是唯一可译码的一类子码，可用树图来构造</p></li><li><p><strong>构造的要点</strong>：</p><ul><li>最上端为树根A，从根出发向下伸出树枝，树枝总数等于m(<strong>进制数</strong>)，树枝的尽头为节点。</li><li>从每个节点再伸出m个树枝，当某个节点被安排为码字后，就不再伸枝，这节点为<strong>终端节点</strong>。能再伸枝的节点成为<strong>中间节点</strong>。一直继续下去，直至都不能伸枝为止。</li><li>每个节点所伸出的树枝标上码符号，从根出发到终端点所走路径对应的码符号序列则为终端节点的码字。</li></ul></li><li><p><strong>用码树图构造码</strong></p><ul><li>在树的生长过程中，节点生出树枝，各树枝旁标出相应的码符，为了清晰起见相同码符的树枝方向相同，终端节点表示信源符号，从树根到终端节点所经过的树枝旁的码符按经过的顺序组成的序列构成码字。</li></ul></li><li><p><strong>用码树图判断即时码</strong></p><ul><li>如果表示信源符号的终端节点不再延伸，或到达任一信源符号终端节点的路径不经过其它的终端节点，这样构造的码满足即时码条件。</li></ul></li><li><p><strong>码树与码字对应关系</strong></p><table><thead><tr><th>树结构概念</th><th>编码概念</th></tr></thead><tbody><tr><td>树根</td><td>码字的起点</td></tr><tr><td>树枝数</td><td>码的进制数</td></tr><tr><td>节点</td><td>码字或码字的一部分</td></tr><tr><td>终端节点</td><td>码字</td></tr><tr><td>节数</td><td>码长</td></tr><tr><td>非满树</td><td>变长码（码字为叶节点）</td></tr><tr><td>满树</td><td>等长码（码字为叶节点）</td></tr></tbody></table></li></ul><h3 id="克劳夫特不等式">克劳夫特不等式</h3><ul><li><p><strong>唯一可译码存在</strong>的充分必要条件是各码字的长度 <span class="math inline"><em>K</em><sub><em>i</em></sub></span>应符合<strong>克劳夫特不等式</strong>(Kraft Inequality) <span class="math display">$$\sum_{i=1}^{n} m^{-K_{i}} \leq 1$$</span></p><p>式中，m是编码进制数，n是信源符号数。</p><ul><li>必要性表现在如果码是唯一可译码，则必定满足该不等式</li><li>充分性表现在如果满足该不等式，则这种码长的唯一可译码一定存在，但并不表示所有满足不等式的一定是唯一可译码。</li><li>所以说，该不等式是唯一可译码存在的充要条件，而不是判别一个编码是否唯一可译码的充要条件</li></ul></li><li><p><strong>唯一可译码的判断方法</strong></p><ol type="1"><li><strong>基本判断</strong>：<ol type="1"><li>观察是否是非奇异码，若是奇异码则一定不是唯一可译码。</li><li>计算是否满足Kraft不等式，若不满足一定不是唯一可译码。</li><li>将码画成一棵树图，观察是否满足即时码的树图的构造，若满足则是唯一可译码。</li></ol></li><li><strong>尾随后缀法</strong>： <img src="image-46.png" srcset="/img/loading/loading3.gif" lazyload><ol type="1"><li>考查 <span class="math inline"><em>C</em></span> 中所有的码字，若<span class="math inline"><em>W</em><sub><em>i</em></sub></span> 是<span class="math inline"><em>W</em><sub><em>j</em></sub></span>的前缀，则将相应的后缀作为一个尾随后缀码放入集合 <span class="math inline"><em>F</em><sub>0</sub></span> 中</li><li>考查 <span class="math inline"><em>C</em></span> 和 <span class="math inline"><em>F</em><sub><em>i</em></sub></span> 两个集合,<span class="math inline"><em>W</em><sub><em>i</em></sub> ∈ <em>C</em></span>是 <span class="math inline"><em>W</em><sub><em>j</em></sub> ∈ <em>F</em><sub><em>i</em></sub></span>的前缀或 <span class="math inline"><em>W</em><sub><em>i</em></sub> ∈ <em>F</em><sub><em>i</em></sub></span>是 <span class="math inline"><em>W</em><sub><em>j</em></sub> ∈ <em>C</em></span>的前缀，则将相应的后缀作为尾随后缀码放入集合 <span class="math inline"><em>F</em><sub><em>i</em> + 1</sub></span> 中;</li><li><span class="math inline"><em>F</em> = ∪<sub><em>i</em></sub><em>F</em><sub><em>i</em></sub></span>即为码 <span class="math inline"><em>C</em></span> 的尾随后缀集合;</li><li>构造尾随后缀集合F，若F中出现了<span class="math inline"><em>C</em></span>中的元素，则算法终止，返回假(<span class="math inline"><em>C</em></span>不是唯一可译码)；否则若F中没有出现新的元素，则返回真。</li></ol><ul><li><strong>例题</strong>：判断码<span class="math inline"><em>C</em></span>：<span class="math inline">{0, 1001, 1011, 1101, 1111, 011}</span>是否是唯一可译码。<ul><li>构造尾随后缀集合<span class="math inline"><em>F</em></span>：码字“0” 是 “011” 的前缀，其尾随后缀 “11” 是码字 “1011” 和 “1111”的前缀，得尾随后缀为 “01” 和 “11” ，其中 “0” 是 “01” 的前缀，尾随后缀为“1” ，“1” 又是 “1011” 的前缀，得到尾随后缀 “011” ，而 <strong>“011”是<span class="math inline"><em>C</em></span>中码字</strong>，所以码<span class="math inline"><em>C</em></span>不是唯一可译码。</li><li>尾随后缀集合<span class="math inline"><em>F</em> = {11, 01, 1, 001, 011, 111}</span> ，“011” 是一个码字，因此不唯一可译。 <span class="math inline">0 → 11 → 01 → 1 → 001</span>，<span class="math inline">$\colorbox{yellow}{011}$</span>，<span class="math inline">111</span></li></ul></li></ul></li></ol></li></ul><h2 id="无失真信源编码定理">5.2 无失真信源编码定理</h2><h3 id="无失真信源编码">无失真信源编码</h3><ul><li><strong>模型</strong>：<img src="image-44.png" srcset="/img/loading/loading3.gif" lazyload alt="模型"><ul><li><p>信源编码器输入的消息序列： <span class="math display">$$\begin{align*}X=(X_{1}X_{2} \cdots X_{l} \cdotsX_{L})\quad X_{l}\in\{a_{1}, \cdots a_{n}\}\end{align*}$$</span></p><p>输入的消息总共有 <span class="math inline"><em>n</em><sup><em>L</em></sup></span> 种可能的组合输出的码字为： <span class="math display">$$\begin{align*}Y=(Y_{1}Y_{2}\cdots Y_{k} \cdots Y_{K_{L}})\quad Y_{k}\in\{b_{1}, \cdotsb_{m}\}\end{align*}$$</span></p><p>输出的码字总共有 <span class="math inline"><em>m</em><sup><em>K</em><sub><em>L</em></sub></sup></span>种可能的组合。</p></li><li><p><span class="math inline"><em>Y</em><sub><em>k</em></sub></span>有<span class="math inline"><em>m</em></span>种可能取值，所以平均每个符号输出的最大信息量为<span class="math inline">log <em>m</em></span>（等概分布）。</p></li><li><p><span class="math inline"><em>K</em><sub><em>L</em></sub></span>长码字的最大信息量为<span class="math inline"><em>K</em><sub><em>L</em></sub>log <em>m</em></span>，用该码字表示<span class="math inline"><em>L</em></span>长的信源序列。</p></li><li><p>则传送一个信源符号需要的平均信息率为： <span class="math display">$$\overline{K}=\frac{K_{L}}{L}\log m =\frac{1}{L}\log M \text{ bit/信源符号}$$</span></p><p>其中，<span class="math inline"><em>M</em> = <em>m</em><sup><em>K</em><sub><em>L</em></sub></sup></span>是<span class="math inline"><em>Y</em></span>所能编成的码字的个数。</p></li></ul></li><li><strong>无失真信源编码</strong><ul><li><strong>实现无失真的信源编码要求</strong>：<ul><li>信源符号 <span class="math inline"><em>X</em><sub>1</sub><em>X</em><sub>2</sub>⋯<em>X</em><sub><em>l</em></sub>⋯<em>X</em><sub><em>L</em></sub></span>与码字 <span class="math inline"><em>Y</em><sub>1</sub><em>Y</em><sub>2</sub>⋯<em>Y</em><sub><em>k</em></sub>⋯<em>Y</em><sub><em>K</em><sub><em>L</em></sub></sub></span>是一一对应的；</li><li>能够无失真或无差错地从Y恢复X，也就是能正确地进行反变换或译码 ；</li><li>传送Y时所需要的信息率最小，信息率最小就是找到一种编码方式使<span class="math inline">$\overline{K}  = \frac{K_L}{L} \log m =\frac{1}{L}\log M$</span>最小</li></ul></li><li><strong>无失真信源编码定理研究内容</strong>：<ul><li>最小信息率为多少时，才能得到无失真的译码？</li><li>若小于这个信息率是否还能无失真地译码？</li></ul></li></ul></li></ul><h3 id="定长编码">定长编码</h3><h4 id="定长编码的基本概念">定长编码的基本概念</h4><ul><li>码长<span class="math inline"><em>K</em></span>是定值，且是唯一可译码。</li><li>由<span class="math inline"><em>L</em></span>个符号组成的、每个符号的熵为<span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X</em>)</span>的无记忆平稳信源符号序列<span class="math inline"><em>X</em><sub>1</sub><em>X</em><sub>2</sub>...<em>X</em><sub><em>l</em></sub>...<em>X</em><sub><em>L</em></sub></span>（每个符号<span class="math inline"><em>n</em></span>种可能值）</li><li>输入的消息总共有<span class="math inline"><em>n</em><sup><em>L</em></sup></span>种可能的组合。</li><li>可用<span class="math inline"><em>K</em><sub><em>L</em></sub> = <em>K</em></span>个符号<span class="math inline"><em>Y</em><sub>1</sub></span>，<span class="math inline"><em>Y</em><sub>2</sub></span>，…，<span class="math inline"><em>Y</em><sub><em>k</em></sub></span>，…，<span class="math inline"><em>Y</em><sub><em>K</em><sub><em>L</em></sub></sub></span>（每个符号有<span class="math inline"><em>m</em></span>种可能值）进行定长编码</li><li>输出的码字总共有<span class="math inline"><em>m</em><sup><em>K</em></sup></span>种可能的组合</li><li><strong>若要对信源进行定长编码且无失真</strong>，必须满足： <span class="math display">$$n^{L} \leq m^{K} 或 \frac{K}{L} \geq \frac{\logn}{\log m}$$</span><ul><li>只有当<span class="math inline"><em>K</em></span>长的码符号序列数<span class="math inline"><em>m</em><sup><em>K</em></sup></span>大于或等于信源的符号数<span class="math inline"><em>n</em><sup><em>L</em></sup></span>时，才可能存在定长非奇异码。</li></ul></li></ul><h4 id="渐进均分性定理aep">渐进均分性定理（AEP）</h4><ul><li><strong>定理</strong>：<span class="math inline"><em>X⃗</em> = (<em>X</em><sub>1</sub><em>X</em><sub>2</sub>⋯<em>X</em><sub><em>L</em></sub>)</span>，为独立同分布（i.i.d）随机变量序列，具有渐近均分性质（AEP，Asymptoticequipartition property）： <span class="math display">$$\forall\varepsilon &gt; 0，当 L \to \infty时，p(X_1,X_2,\cdots,X_L) \to 2^{-LH(X)}$$</span></li><li><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#渐进均分性定理aep">无失真信源编码定理</a></strong></li></ul><h4 id="定长编码定理">定长编码定理</h4><ul><li><p><strong>定理</strong>：对于由 <span class="math inline"><em>L</em></span> 个符号组成的，每个符号的熵为 <span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>)</span>的无记忆平稳符号序列 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub></span>，可用<span class="math inline"><em>K</em><sub><em>L</em></sub></span> 个符号<span class="math inline"><em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>K</em><sub><em>L</em></sub></sub></span>（每个符号有<span class="math inline"><em>m</em></span> 种可能值，即<span class="math inline"><em>m</em></span>进制编码）进行定长编码。对于任意<span class="math inline"><em>ε</em> &gt; 0</span>，<span class="math inline"><em>δ</em> &gt; 0</span>，只要 <span class="math display">$$\overline{K} = \frac{K_L}{L}\log m \geqH_L(\vec{X}) + \varepsilon$$</span></p><p>则当 <span class="math inline"><em>L</em></span>足够大时，必可使译码差错小于 <span class="math inline"><em>δ</em></span>； 反之，当 <span class="math display">$$\overline{K} = \frac{K_L}{L}\log m \leqH_L(\vec{X}) - 2\varepsilon$$</span></p><p>时，译码差错一定是有限值，当 <span class="math inline"><em>L</em> → ∞</span>时，译码几乎必定出错。</p></li><li><p><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#定长编码定理">无失真信源编码定理</a></strong></p></li><li><p><strong>定长编码定理含义</strong></p><ul><li><p>当编码器容许的输出信息率，也就是当每个信源符号所必须输出的二进制码长是<span class="math display">$$  \overline{K}=\frac{K_{L}}{L}\log m=\frac{1}{L}\log M  $$</span></p><p>时，只要 <span class="math inline">$\overline{K}&gt;H_{L}(X)$</span>，这种编码器一定可以做到<strong>几乎无失真</strong>，也就是收端的译码差错概率接近于零，<strong>条件是所取的符号数<span class="math inline"><em>L</em></span>足够大</strong>。</p></li><li><p>将定理的条件改写成： <span class="math display"><em>K</em><sub><em>L</em></sub>log <em>m</em> &gt; <em>L</em><em>H</em><sub><em>L</em></sub>(<em>X</em>) = <em>H</em>(<em>X</em>)</span>其中：</p><ul><li>左边：<span class="math inline"><em>K</em><sub><em>L</em></sub></span>长码字所能携带的最大信息。</li><li>右边：<span class="math inline"><em>L</em></span>长信源序列携带的信息量。</li></ul><p>则：</p><ul><li>码字所能携带的信息量<strong>大于</strong>信源序列输出的信息量，则可以使传输<strong>几乎无失真</strong>，当然<strong>条件是<span class="math inline"><em>L</em></span>足够大</strong>。</li><li>反之，当 <span class="math inline">$\overline{K} &lt;H_{L}(X)$</span>时，不可能构成无失真的编码，也就是不可能做一种编码器，能使收端译码时差错概率趋于零。</li><li><span class="math inline">$\overline{K}=H_{L}(X)$</span>时，则为临界状态，可能无失真，也可能有失真。</li></ul></li></ul></li><li><p><strong>信源长度 <span class="math inline"><em>L</em></span></strong></p><ul><li><p>对定长编码，若要实现几乎无失真编码，则信源长度必须满足： <span class="math display">$$L \geq \frac{\sigma^{2}(X)}{\varepsilon^{2}\delta}$$</span></p><p>其中：</p><ul><li><span class="math inline"><em>σ</em><sup>2</sup>(<em>X</em>) = <em>E</em>{[<em>I</em>(<em>x</em><sub><em>i</em></sub>) − <em>H</em>(<em>X</em>)]<sup>2</sup>}</span>，表示信源序列的自信息方差。</li><li><span class="math inline"><em>δ</em></span>：差错率要求（如<span class="math inline">10<sup>−6</sup></span>）</li><li><span class="math inline">$\varepsilon =\overline{K}-H_{L}(X)$</span></li></ul></li><li><p>证明：见<a href="Ch5sup_无失真信源编码定理.md/#定长编码定理">无失真信源编码定理</a></p></li></ul></li><li><p><strong>编码效率<span class="math inline"><em>η</em></span></strong></p><ul><li><p>编码效率定义为 <span class="math display">$$\eta =\frac{H_{L}(X)}{\overline{K}}$$</span> 即信源的平均符号熵为<span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X</em>)</span>，采用平均二进制符号码长为<span class="math inline">$\overline{K}$</span>来编码，所得的效率。</p></li><li><p>无失真编码效率总是小于<span class="math inline">1</span>，且<strong>最佳编码效率</strong>为 <span class="math display">$$\eta =\frac{H_{L}(X)}{H_{L}(X)+\varepsilon},\varepsilon &gt;0$$</span></p></li><li><p>定长编码定理从理论上阐明了编码效率接近<span class="math inline">1</span>的理想定长编码器的存在性，它使输出符号的信息率与信源熵之比接近于<span class="math inline">1</span>，即只要<span class="math inline"><em>L</em></span>足够大 <span class="math display">$$\frac{H_{L}(X)}{\frac{K_{L}}{L}\log m} \to1$$</span></p><ul><li>但要在实际中实现，<span class="math inline"><em>L</em></span>必须取无限长的信源符号进行统一编码。这样做实际上是不可能的，因<span class="math inline"><em>L</em></span>非常大，无法实现。</li><li>当<span class="math inline"><em>L</em></span>有限时，要做到高编码效率、低错误率，对于定长编码来说是不可能做到的。</li></ul></li></ul></li><li><p><strong>例题</strong>：<img src="image-92.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h3 id="变长编码">变长编码</h3><h4 id="变长编码的基本概念">变长编码的基本概念</h4><ul><li>在变长编码中，码长<span class="math inline"><em>K</em><sub><em>i</em></sub></span>是变化的。</li><li><span class="math inline"><em>m</em></span>进制平均码长：<span class="math inline">$\overline{K^{'}} = \sum_{i}p(a_{i})K_{i}$</span></li><li>根据信源各个符号的统计特性，如概率大的符号用短码，概率小的用较长的码，使得编码后平均码长降低，从而提高编码效率。（统计匹配）</li></ul><h4 id="单个符号变长编码定理">单个符号变长编码定理</h4><ul><li><strong>定理</strong>：若离散无记忆信源的符号熵为 <span class="math inline"><em>H</em>(<em>X</em>)</span>，每个信源符号用m进制码元进行变长编码，一定存在一种无失真编码方法，其(m进制)码字平均长度<span class="math inline">$\overline{K'}$</span> 满足下列不等式 <span class="math display">$$\frac{H(X)}{\log m} \leq\overline{K'}&lt;\frac{H(X)}{\log m}+1$$</span></li><li><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#单符号变长编码定理">无失真信源编码定理</a></strong></li></ul><h4 id="离散平稳无记忆序列变长编码定理香农第一定理">离散平稳无记忆序列变长编码定理(香农第一定理)</h4><ul><li><p>由单个符号变长编码定理推广而来： <span class="math display">$$  \begin{align*}  \frac{H(X)}{\log m} \leq &amp;\overline{K^{'}} &lt; \frac{H(X)}{\logm} + 1 \\  \Rightarrow \frac{LH_{L}(X)}{\log m} \leq &amp;\overline{K_{L}} &lt;\frac{LH_{L}(X)}{\log m} + 1\\  \Rightarrow H_{L}(X) \leq &amp;\overline{K} &lt; H_{L}(X)+\frac{\logm}{L}  \end{align*}  $$</span></p></li><li><p><strong>定理</strong>：对于离散平稳无记忆信源，必存在一种无失真编码方法，使平均信息率<span class="math inline">$\overline{K}$</span> 满足不等式 <span class="math display">$$H_{L}(X) \leq \overline{K} &lt;H_{L}(X)+\frac{\log m}{L}$$</span></p><p>其中<span class="math inline">$\overline{K} =\frac{\overline{K_{L}}}{L}\log m$</span>，当L足够大时，可使 <span class="math inline">$\frac{\log m}{L}&lt;\varepsilon$</span> ，得到<span class="math display">$$H_{L}(X) \leq \overline{K} &lt;H_{L}(X)+\varepsilon$$</span></p><p>其中<span class="math inline"><em>ε</em></span>是任意小的正数。</p></li><li><p><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#离散平稳无记忆序列变长编码定理香农第一定理">无失真信源编码定理</a></strong></p></li><li><p><strong>变长编码效率</strong>变长编码效率的<strong>下界</strong>： <span class="math display">$$  \eta=\frac{H_{L}(X)}{\overline{K}} &gt; \frac{H_{L}(X)}{H_{L}(X) +\frac{\log m}{L}}  $$</span></p><p>无失真编码效率总是小于1，可以用它来衡量各种编码方法的优劣。为了衡量各种编码方法与最佳码的差距，定义<strong>码的剩余度</strong>为：<span class="math display">$$  \gamma = 1 - \eta = 1 - \frac{H_{L}(X)}{\frac{\overline{K_{L}}}{L}\logm}= 1 - \frac{H_{L}(X)}{\overline{K}}  $$</span></p><p>对某一信源和某一码符号集，若有一个唯一可译码，其平均长度小于所有其他唯一可译码的平均长度，则称该码为<strong>最佳码</strong>或<strong>紧致码</strong>。</p></li><li><p><strong>例题</strong>：</p><ul><li>例题1：<img src="image-93.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li><li>例题2：<img src="image-94.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul></li></ul><h3 id="香农编码">香农编码</h3><ul><li><p>香农第一定理指出了平均码长与信源熵之间的关系，同时也指出了可以通过编码使平均码长达到极限值，这是一个很重要的极限定理。</p></li><li><p>香农第一定理指出，选择每个码字的长度<span class="math inline"><em>l</em><sub><em>i</em></sub></span>满足下式：<span class="math display">$$l_{i} =\left\lceil\log\frac{1}{p(x_{i})}\right\rceil（向上取整）$$</span>或：<span class="math display"><em>I</em>(<em>x</em><sub><em>i</em></sub>) ≤ <em>l</em><sub><em>i</em></sub> &lt; <em>I</em>(<em>x</em><sub><em>i</em></sub>) + 1</span></p><p>这种编码方法称为香农编码</p></li><li><p><strong>编码步骤</strong></p><ol type="1"><li>将信源消息符号按其出现的概率大小依次排列：<span class="math display"><em>p</em><sub>1</sub> ≥ <em>p</em><sub>2</sub> ≥ ⋯ ≥ <em>p</em><sub><em>n</em></sub></span></li><li>依照下列不等式确定整数的码长<span class="math inline"><em>K</em><sub><em>i</em></sub></span>：<span class="math display">−log<sub>2</sub>(<em>p</em><sub><em>i</em></sub>) ≤ <em>l</em><sub><em>i</em></sub> &lt; −log<sub>2</sub>(<em>p</em><sub><em>i</em></sub>) + 1</span></li><li>为了编成唯一可译码，计算第<span class="math inline"><em>i</em></span>个消息的累加概率：<span class="math display">$$P_{i}=\sum_{k = 1}^{i - 1}p(a_{k})$$</span></li><li>将累加概率<span class="math inline"><em>P</em><sub><em>i</em></sub></span>变换成二进制数</li><li>取<span class="math inline"><em>P</em><sub><em>i</em></sub></span>二进制数的小数点后<span class="math inline"><em>l</em><sub><em>i</em></sub></span>位即为该消息符号的二进制码字</li></ol></li><li><p><strong>香农编码图示</strong></p><ul><li>累加概率<span class="math inline"><em>P</em><sub><em>i</em></sub></span>把区间<span class="math inline">[0, 1)</span>分割成许多小区间，每个小区间的长度等于各符号的概率<span class="math inline"><em>p</em><sub><em>i</em></sub></span>，小区间内的任一点可用来代表该符号：<span class="math inline">$P_{i}=\sum_{k = 1}^{i -1}p(a_{k})$</span></li><li><figure><img src="image-45.png" srcset="/img/loading/loading3.gif" lazyload alt="香农编码图示"><figcaption aria-hidden="true">香农编码图示</figcaption></figure></li></ul></li><li><p><strong>例题</strong>：<img src="image-58.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li></ul><h2 id="限失真信源编码定理">5.3 限失真信源编码定理</h2><h3 id="无失真与有失真信源编码">无失真与有失真信源编码</h3><ul><li>无失真信源编码是<strong>保熵的</strong>：通过信道的信息传输率<span class="math inline"><em>R</em></span>等于信源熵<span class="math inline"><em>H</em>(<em>X</em>)</span>。</li><li>有失真信源编码属<strong>熵压缩编码</strong>，即编码后的信息率得到压缩。</li><li>采用有失真的熵压缩编码的原因：<ul><li>保熵编码并非总是必需的；</li><li>保熵编码并非总是可能的；</li><li>降低信息率有利于传输和处理。</li></ul></li></ul><h3 id="限失真信源编码定理-1">限失真信源编码定理</h3><ul><li><p>信息率失真函数给出了失真小于<span class="math inline"><em>D</em></span>时所必须具有的最小信息率<span class="math inline"><em>R</em>(<em>D</em>)</span>；只要信息率大于<span class="math inline"><em>R</em>(<em>D</em>)</span>，一定可以找到一种编码，使译码后的失真小于<span class="math inline"><em>D</em></span>。</p></li><li><p><strong>限失真信源编码定理</strong>：设<strong>离散无记忆信源</strong><span class="math inline"><em>X</em></span>的信息率失真函数为<span class="math inline"><em>R</em>(<em>D</em>)</span>，则当信息率<span class="math inline"><em>R</em> &gt; <em>R</em>(<em>D</em>)</span>，只要信源序列长度<span class="math inline"><em>L</em></span>足够长，一定存在一种编码方法，其译码失真小于或等于<span class="math inline"><em>D</em> + <em>ε</em></span>，<span class="math inline"><em>ε</em></span>为任意小的正数。反之，若<span class="math inline"><em>R</em> &lt; <em>R</em>(<em>D</em>)</span>，则无论采用什么样的编码方法，其译码失真必大于<span class="math inline"><em>D</em></span>。</p></li><li><p>二元信源编码：</p><ul><li><p>对于任意小的<span class="math inline"><em>ε</em></span>，每一个信源符号的平均码长满足如下公式：<span class="math display">$$R(D) \leq \overline{K} &lt; R(D) +\varepsilon$$</span></p><p>在失真限度内使信息率任意接近<span class="math inline"><em>R</em>(<em>D</em>)</span>的编码方法是存在的。然而，如果使信息率小于<span class="math inline"><em>R</em>(<em>D</em>)</span>，平均失真一定会超过失真限度<span class="math inline"><em>D</em></span>。</p></li></ul></li><li><p>对于<strong>连续</strong>平稳无记忆信源，无法进行无失真编码，在<strong>限失真</strong>情况下，有与上述定理一样的编码定理。</p></li><li><p>限失真信源编码定理只能说明<strong>最佳编码是存在的</strong>，而具体构造编码方法却一无所知。因而就不能象无失真编码那样从证明过程中引出概率匹配的编码方法。一般只能从优化的思路去求最佳编码。实际上迄今尚无合适的可实现的编码方法可接近<span class="math inline"><em>R</em>(<em>D</em>)</span>这个界。</p></li></ul><h2 id="常用信源编码方法简介">5.4 常用信源编码方法简介</h2><h3 id="变长码与存储器容量">变长码与存储器容量</h3><ul><li><p><span class="math inline"><em>T</em></span>秒内有<span class="math inline"><em>N</em></span>个信源符号输出，信源输出符号速率<span class="math inline"><em>S</em> = <em>N</em>/<em>T</em></span>，若符号的平均码长为<span class="math inline">$\overline{K}$</span>，则信道<strong>传输速率</strong>需要<span class="math display">$$R_{t}=S\overline{K}$$</span></p></li><li><p><span class="math inline"><em>N</em></span>个码字的长度分别为<span class="math inline"><em>K</em><sub><em>i</em></sub>, <em>i</em> = 1, …, <em>N</em></span>，即在此期间输入存储器<span class="math inline">$\sum_{i = 1}^{N}K_{i}$</span> bit，输出信道<span class="math inline"><em>R</em><sub><em>t</em></sub><em>T</em></span>bit，则在<strong>存储器里还剩</strong>： <span class="math display">$$X=\sum_{i = 1}^{N}K_{i}-R_{t}T$$</span></p></li><li><p>已知<span class="math inline"><em>K</em><sub><em>i</em></sub></span>是随机变量，其均值和方差为：<span class="math display">$$  \overline{K}=E[K_{i}]=\sum_{j = 1}^{m}p_{j}K_{j}\\  \sigma^{2}=E[K_{i}^{2}]-\overline{K}^{2}=\sum_{j =1}^{m}p_{j}K_{j}^{2}-\overline{K}^{2}  $$</span></p><p>式中<span class="math inline"><em>m</em></span>为信源符号集的元数。当<span class="math inline"><em>N</em></span>足够大时，<span class="math inline"><em>X</em></span>是许多独立同分布的随机变量之和，它近似于正态分布<span class="math display">$$p_{X}(x)=\frac{1}{\sqrt{2\pi}\sigma_{X}}e^{-\frac{(x- E[X])^{2}}{2\sigma_{X}^{2}}}$$</span></p><p>其均值和方差分别为： <span class="math display">$$  E[X]=N\overline{K}-R_{t}T$$</span><span class="math display"><em>σ</em><sub><em>X</em></sub><sup>2</sup> = <em>N</em><em>σ</em><sup>2</sup></span></p></li><li><p>若信道速率满足<span class="math inline">$R_{t}=S\overline{K}$</span>，<span class="math inline"><em>E</em>[<em>X</em>] = 0</span>。假设存储器容量为<span class="math inline">2<em>A</em><em>σ</em><sub><em>X</em></sub></span>，起始时存储器为半满，则<strong>溢出概率</strong>为：<span class="math display"><em>P</em>(<em>X</em> &gt; <em>A</em><em>σ</em><sub><em>X</em></sub>) = <em>ϕ</em>(−<em>A</em>) = ∫<sub>−∞</sub><sup>−<em>A</em></sup><em>φ</em>(<em>x</em>)<em>d</em><em>x</em></span></p><p><strong>取空概率</strong>为： <span class="math display"><em>P</em>(<em>X</em> &lt; −<em>A</em><em>σ</em><sub><em>X</em></sub>) = <em>ϕ</em>(−<em>A</em>)</span></p><p>其中<span class="math inline"><em>ϕ</em>(<em>x</em>)</span>为标准正态分布函数，<span class="math inline"><em>φ</em>(<em>x</em>)</span>为标准正态分布密度函数。</p></li><li><p>若要求溢出和取空概率<span class="math inline"><em>P</em><sub><em>e</em></sub> = 0.001</span>，查表得<span class="math inline"><em>A</em> = 3.08</span>，则存储器容量为： <span class="math display">$$C&gt;2A\sigma_{X}=2A\sqrt{N}\sigma =6.16\sqrt{N}\sigma$$</span></p><ul><li>码方差<span class="math inline"><em>σ</em></span>越大，要求存储器的容量也越大。</li><li>时间越长，<span class="math inline"><em>N</em></span>越大，要求存储器的容量也越大。</li><li>存储器容量设定后，随着时间的增长，存储器溢出和取空的概率都将增大。</li></ul></li><li><p>一般来说，变长码只适用于有限长的信息传输（如传真）。实际使用时，可把长信息分段发送，也可以实时检测存储器的状态，调整输出。</p></li></ul><h3 id="分组码-1">分组码</h3><h4 id="香农shannon编码">香农(Shannon)编码</h4><ul><li>见<a href="#香农编码">香农编码</a></li><li><strong>编码步骤</strong><ol type="1"><li>将信源消息符号按其出现的概率大小依次排列：<span class="math display"><em>p</em><sub>1</sub> ≥ <em>p</em><sub>2</sub> ≥ ⋯ ≥ <em>p</em><sub><em>n</em></sub></span></li><li>依照下列不等式确定整数的码长<span class="math inline"><em>K</em><sub><em>i</em></sub></span>：<span class="math display">−log<sub>2</sub>(<em>p</em><sub><em>i</em></sub>) ≤ <em>l</em><sub><em>i</em></sub> &lt; −log<sub>2</sub>(<em>p</em><sub><em>i</em></sub>) + 1</span></li><li>为了编成唯一可译码，计算第<span class="math inline"><em>i</em></span>个消息的累加概率：<span class="math display">$$P_{i}=\sum_{k = 1}^{i - 1}p(a_{k})$$</span></li><li>将累加概率<span class="math inline"><em>P</em><sub><em>i</em></sub></span>变换成二进制数</li><li>取<span class="math inline"><em>P</em><sub><em>i</em></sub></span>二进制数的小数点后<span class="math inline"><em>l</em><sub><em>i</em></sub></span>位即为该消息符号的二进制码字</li></ol></li></ul><h4 id="哈夫曼huffman编码">哈夫曼(Huffman)编码</h4><ul><li><strong>特点</strong><ul><li>哈夫曼（Huffman）编码是分组码。</li><li>依据各符号出现的<strong>概率</strong>来构造码字。</li><li>基于二叉树的编码思想，所有可能的符号在哈夫曼树上对应为一个节点，节点的位置就是该符号的码字。这些节点都是终极节点，不再延伸，不会出现前缀码，因而唯一可译。</li><li>哈夫曼编码是一种效率比较高的<strong>变长无失真信源编码</strong>方法。</li></ul></li><li><strong>编码步骤</strong>：<ol type="1"><li>将信源消息符号按其出现的概率大小依次排列 <span class="math display"><em>p</em><sub>1</sub> ≥ <em>p</em><sub>2</sub> ≥ ⋯ ≥ <em>p</em><sub><em>n</em></sub></span></li><li>取两个概率最小的符号分别配以0和1两个码元，并将这两个概率相加作为一个新符号的概率，与未分配的二进符号的符号重新排队。</li><li>对重排后的两个概率最小符号重复步骤 2 的过程。</li><li>不断继续上述过程，直到最后两个符号配以0和1为止。</li><li>从最后一级开始，<strong>向前</strong>返回得到各个信源符号所对应的码元序列，即相应的码字。</li></ol></li><li>哈夫曼编码方法得到的码<strong>并非唯一</strong>的。<ul><li>每次对信源缩减时，赋予信源最后两个概率最小的符号时，0和1是可以任意的，所以可以得到不同的哈夫曼码，但不会影响码字的长度。</li><li>对信源进行缩减时，若两个概率最小的符号合并后的概率与其它信源符号的概率相同时，这两者在缩减信源中进行概率排序，其位置放置次序是可以任意的，故会得到不同的哈夫曼码。此时将影响码字的长度，一般将<strong>合并的概率放在靠前位置</strong>，这样可获得<strong>较小的码方差</strong>。</li><li>不同的编法得到的码字长度<span class="math inline"><em>K</em><sub><em>i</em></sub></span>也不尽相同。</li></ul></li><li>单符号信源编二进制哈夫曼码，编码效率主要决定于信源熵和平均码长之比。<ul><li>对相同的信源编码，其熵是一样的，采用不同的编法得到的平均码长可能不同。</li><li>平均码长越短，编码效率就越高。</li></ul></li><li><strong>码方差</strong>： <span class="math display">$$  \sigma_{I}^{2}=E\left[\left(K_{i}-\overline{K}\right)^{2}\right]=\sum_{i= 1}^{q}p(a_{i})(K_{i}-\overline{K})^{2}  $$</span><ul><li>例题：<img src="image-95.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul></li><li><strong>N进制哈夫曼编码</strong>：<ul><li>在N进制哈夫曼编码中，为了得到最短平均码长，有时需要对信源符号作添加，使信源符号数量满足<span class="math display"><em>N</em> + <em>k</em>(<em>N</em> − 1)  <em>k</em> ∈ <em>N</em></span></li><li>平均二进制码长(信息率)为 <span class="math display">$$\overline{K} =\frac{\overline{K_L}}{L}\log_2 N$$</span></li></ul></li><li><strong>用哈夫曼方法对信源序列编码</strong><ul><li>随着序列长度<span class="math inline"><em>L</em></span>的增加，平均（二进制）码长迅速降低，接近信源熵值。</li><li>例题：信源输出两个符号，概率分布为<span class="math inline"><em>P</em> = (0.9, 0.1)</span>，信源熵<span class="math inline"><em>H</em>(<em>X</em>) = 0.469</span>比特/符号。采用二进制哈夫曼编码。<ul><li><span class="math inline">$L = 1,\overline{K}=1$</span>bit/符号</li><li><span class="math inline">$L = 2,P'=(0.81, 0.09, 0.09,0.01),\overline{K}=0.645$</span> bit/符号</li><li><span class="math inline">$L = 3,\overline{K}=0.533$</span>bit/符号</li><li><span class="math inline">$L = 4,\overline{K}=0.494$</span>bit/符号</li></ul></li></ul></li></ul><h4 id="费诺fano编码">费诺(Fano)编码</h4><ul><li><strong>特点</strong>：<ul><li>费诺（Fano）编码方法属于概率匹配编码</li><li>费诺码的编码方法实际上是一种构造码树的方法，所以费诺码是即时码。</li><li>费诺码考虑了信源的统计特性，使概率大的信源符号能对应码长短的码字，从而有效地提高了编码效率。</li><li>但是费诺编码方法不一定使短码得到充分利用。尤其当信源符号较多时，若有一些符号概率分布很接近时，分两大组的组合方法会很多。可能某种分大组的结果，会使后面小组的“概率和”相差较远，使平均码长增加。</li></ul></li><li><strong>编码步骤</strong>：<ol type="1"><li>将信源消息符号按其出现的概率大小依次排列 <span class="math display"><em>p</em><sub>1</sub> ≥ <em>p</em><sub>2</sub> ≥ ⋯ ≥ <em>p</em><sub><em>n</em></sub></span></li><li>将依次排列的信源符号按概率值分为两大组，使两个组的概率之和近于相同，并对各组赋予一个二进制码元“0”和“1”；</li><li>将每一大组的信源符号进一步再分成两组，使划分后的两个组的概率之和近于相同，并又赋予两个组一个二进制符号“0”和“1”。</li><li>如此重复，直至每个组只剩下一个信源符号为止。</li><li>信源符号所对应的码字即为费诺码。</li></ol></li><li>适用场景：费诺码比较适合于每次分组概率都很接近的信源，特别是对每次分组概率都相等的信源进行编码时，可达到理想的编码效率。</li><li>例题：<img src="image-96.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h4 id="分组码的局限性">分组码的局限性</h4><ul><li>概率特性必须得到精确的测定，若其略有变化，还需更换码表。</li><li>对于二元信源，常常需要将多个符号合起来编码才能取得较好的效果。</li><li>当合并的符号数不大时，编码效率提高不明显，尤其是对于相关信源，结果难以令人满意。</li><li>而合并的符号数增大时，码表中的码字数增多，会导致设备越来越复杂。</li></ul><h3 id="非分组码">非分组码</h3><h4 id="算术编码">算术编码</h4><ul><li><strong>特点</strong>：<ul><li>算术码是一种<strong>非分组码</strong>，其基本思路是：<ul><li>积累概率<span class="math inline"><em>P</em>(<em>S</em>)</span>把区间<span class="math inline">[0, 1)</span>分割成许多小区间，每个小区间的长度等于各序列的概率<span class="math inline"><em>p</em>(<em>S</em>)</span>，小区间内的任一点可用来代表这序列。</li><li><figure><img src="image-47.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"><figcaption aria-hidden="true">例题</figcaption></figure></li></ul></li><li><strong>与<a href="#香农编码">香农编码</a>的区别</strong>：香农码考虑单个符号，算术编码考虑的是整个数据文件。</li></ul></li><li><strong>求序列的概率<span class="math inline"><em>p</em>(<em>S</em>)</span>和累计概率<span class="math inline"><em>P</em>(<em>S</em>)</span></strong>：<ul><li>信源符号集<span class="math inline"><em>A</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span>，<span class="math inline"><em>L</em></span>长信源序列共有<span class="math inline"><em>n</em><sup><em>L</em></sup></span>种可能序列，因为序列长度<span class="math inline"><em>L</em></span>很大，很难得到对应序列的概率和累积概率，只能从已知的信源符号概率中递推得到。</li><li>信源符号概率分布为：<span class="math display"><em>P</em> = [<em>p</em>(<em>a</em><sub>1</sub>), <em>p</em>(<em>a</em><sub>2</sub>), ⋯, <em>p</em>(<em>a</em><sub><em>n</em></sub>)] = [<em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, ⋯, <em>p</em><sub><em>n</em></sub>]</span></li><li>定义各符号的累积概率为：<span class="math display">$$P_{r}=\sum_{i =1}^{r - 1}p_{i}\quad p_{r}=P_{r + 1}-P_{r}$$</span></li></ul></li><li><strong>累积概率递推公式</strong><ul><li><p><strong>二元序列</strong>： 有二元符号序列<span class="math inline"><em>S</em> = 011</span>，把3个二元符号的序列按自然二进制数排列，<span class="math inline">000, 001, 010, 011, ⋯</span>，则<span class="math inline"><em>S</em></span>的累积概率为： <span class="math display"><em>P</em>(<em>S</em>) = <em>p</em>(000) + <em>p</em>(001) + <em>p</em>(010)</span></p><p>如果<span class="math inline"><em>S</em></span>后面接一个“<span class="math inline">0</span>”，累积概率就成为： <span class="math display">$$  \begin{align*}  P(S,0)=&amp;P(0110)\\  =&amp;p(0000)+p(0001)+p(0010)+\\  &amp;p(0011)+p(0100)+p(0101)  \end{align*}  $$</span></p><p>由归一律，<span class="math inline"><em>p</em>(0000) + <em>p</em>(0001) = <em>p</em>(000)</span>等，得：<span class="math display"><em>P</em>(<em>S</em>, 0) = <em>P</em>(0110) = <em>p</em>(000) + <em>p</em>(001) + <em>p</em>(010) = <em>P</em>(<em>S</em>)</span></p><p>同理， <span class="math display">$$  \begin{align*}  P(S,1)=&amp;P(0111)\\  =&amp;p(0000)+p(0001)+p(0010)+\\  &amp;p(0011)+p(0100)+p(0101)+p(0110)\\  =&amp;P(S)+p(0110)\\  =&amp;P(S)+p(S)p_{0}  \end{align*}  $$</span></p><p>当<span class="math inline"><em>A</em> = {0, 1}</span>，即<strong>二元信源</strong>时：<span class="math inline"><em>P</em><sub>0</sub> = 0</span>；<span class="math inline"><em>P</em><sub>1</sub> = <em>p</em><sub>0</sub></span><img src="image-48.png" srcset="/img/loading/loading3.gif" lazyload> <span class="math display">$$  \begin{align*}  &amp;P(S,0)=P(S)=P(S)+p(S)P_{0}\\  &amp;P(S,1)=P(S)+p(S)p_{0}=P(S)+p(S)P_{1}  \end{align*}  $$</span></p><p>统一写作 <span class="math display"><em>P</em>(<em>S</em>, <em>r</em>) = <em>P</em>(<em>S</em>) + <em>p</em>(<em>S</em>)<em>P</em><sub><em>r</em></sub>  <em>r</em> = 0, 1</span><img src="image-49.png" srcset="/img/loading/loading3.gif" lazyload></p></li><li><p><strong>一般递推公式</strong>推广到多元序列，即可得到一般的递推公式： <span class="math display">$$  \begin{align*}  P(S,a_{r})=&amp;P(S)+p(S)P_{r}\\  p(S,a_{r})=&amp;p(S)p_{r}  \end{align*}  $$</span> <img src="image-50.png" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>随着序列的长度不断增加，<span class="math inline"><em>p</em>(<em>S</em>)</span>越来越小，<span class="math inline"><em>P</em>(<em>S</em>)</span>所在区间的长度就越短，也就可以更加精确地确定<span class="math inline"><em>P</em>(<em>S</em>)</span>的位置。</li></ul></li></ul></li><li><strong>编码过程</strong>：<ul><li>实际应用中，<strong>用码字<span class="math inline"><em>C</em>(<em>S</em>)</span>表示累积概率<span class="math inline"><em>P</em>(<em>S</em>)</span>，用状态区间<span class="math inline"><em>A</em>(<em>S</em>)</span>表示序列的概率<span class="math inline"><em>p</em>(<em>S</em>)</span></strong>，则递推公式为：<span class="math display">$$  \begin{cases}  C(S,r)=C(S)+A(S)P_{r}\\  A(S,r)=A(S)p_{r}  \end{cases}  $$</span> <img src="image-51.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><ol type="1"><li>设置两个存储器，起始时令<span class="math inline"><em>A</em>(<em>φ</em>) = 1, <em>C</em>(<em>φ</em>) = 0</span>，<span class="math inline"><em>φ</em></span>表示空集，即起始时码字为<span class="math inline">0</span>，状态区间为<span class="math inline">1</span>。</li><li>每输入一个信源符号，存储器<span class="math inline"><em>C</em></span>和<span class="math inline"><em>A</em></span>就按照递推公式更新一次，直至信源符号输入完毕。</li><li>确定码长 <span class="math display">$$L=\left\lceil\log\frac{1}{A(S)}\right\rceil$$</span>其中<span class="math inline">⌈<em>x</em>⌉</span>代表大于或等于<span class="math inline"><em>x</em></span>的最小整数。</li><li>取存储器<span class="math inline"><em>C</em></span>小数点后<span class="math inline"><em>L</em></span>位的内容作为该序列的码字输出；如果有尾数，就进位到第<span class="math inline"><em>L</em></span>位，这样得到一个数<span class="math inline"><em>C</em></span>。</li></ol></li><li><strong>译码过程</strong>：<ol type="1"><li>判断接收到的码字 <span class="math inline"><em>C</em>(<em>S</em>)</span>落在哪个初始概率区间，从而确定第一个符号。</li><li>从 <span class="math inline"><em>C</em>(<em>S</em>)</span>中减去对应首个符号的累积概率 <span class="math inline"><em>P</em><sub><em>r</em></sub></span> 。</li><li>将相减后的数值乘以当前符号概率 <span class="math inline"><em>p</em><sub><em>r</em></sub></span>的倒数，放大至 <span class="math inline">[0, 1]</span>区间，以确定下一个符号所在的概率区间，进而确定下一个符号。</li><li>不断重复上述去掉累积概率、区间放大和确定符号的步骤，直到处理完整个码字，译出完整的符号序列。</li></ol></li><li><strong>示例</strong>：有四个符号<span class="math inline"><em>a</em></span>，<span class="math inline"><em>b</em></span>，<span class="math inline"><em>c</em></span>，<span class="math inline"><em>d</em></span>构成简单序列<span class="math inline"><em>S</em> = <em>a</em><em>b</em><em>d</em><em>a</em></span>，各符号及其对应概率如下表<img src="image-75.png" srcset="/img/loading/loading3.gif" lazyload><ul><li><table><thead><tr><th>符号</th><th>符号概率<span class="math inline"><em>p</em><sub><em>i</em></sub></span></th><th>符号累积概率<span class="math inline"><em>P</em><sub><em>j</em></sub></span></th></tr></thead><tbody><tr><td><span class="math inline"><em>a</em></span></td><td><span class="math inline">0.100(1/2)</span></td><td><span class="math inline">0.000</span></td></tr><tr><td><span class="math inline"><em>b</em></span></td><td><span class="math inline">0.010(1/4)</span></td><td><span class="math inline">0.100</span></td></tr><tr><td><span class="math inline"><em>c</em></span></td><td><span class="math inline">0.001(1/8)</span></td><td><span class="math inline">0.110</span></td></tr><tr><td><span class="math inline"><em>d</em></span></td><td><span class="math inline">0.001(1/8)</span></td><td><span class="math inline">0.111</span></td></tr></tbody></table></li><li><p><strong>算术编码过程如下</strong>：</p><ol type="1"><li>设起始状态为空序列<span class="math inline"><em>φ</em></span>，则<span class="math inline"><em>A</em>(<em>φ</em>) = 1</span>，<span class="math inline"><em>C</em>(<em>φ</em>) = 0</span>。</li><li>计算<span class="math inline"><em>C</em>(<em>φ</em><em>a</em>)</span>和<span class="math inline"><em>A</em>(<em>φ</em><em>a</em>)</span>： <span class="math display">$$  \begin{cases}  C(\varphi a)=C(\varphi)+A(\varphi)P_a = 0 + 1\times0 = 0\\  A(\varphi a)=A(\varphi)p_a = 1\times0.1 = 0.1  \end{cases}  $$</span></li><li>计算<span class="math inline"><em>C</em>(<em>a</em><em>b</em>)</span>和<span class="math inline"><em>A</em>(<em>a</em><em>b</em>)</span>： <span class="math display">$$  \begin{cases}  C(ab)=C(a)+A(a)P_b = 0 + 0.1\times0.1 = 0.01\\  A(ab)=A(a)p_b = 0.1\times0.01 = 0.001  \end{cases}  $$</span></li><li>计算<span class="math inline"><em>C</em>(<em>a</em><em>b</em><em>d</em>)</span>和<span class="math inline"><em>A</em>(<em>a</em><em>b</em><em>d</em>)</span>：<span class="math display">$$  \begin{cases}  C(abd)=C(ab)+A(ab)P_d = 0.01 + 0.001\times0.111 = 0.010111\\  A(abd)=A(ab)p_d = 0.001\times0.001 = 0.000001  \end{cases}  $$</span></li><li>计算<span class="math inline"><em>C</em>(<em>a</em><em>b</em><em>d</em><em>a</em>)</span>和<span class="math inline"><em>A</em>(<em>a</em><em>b</em><em>d</em><em>a</em>)</span>：<span class="math display">$$  \begin{cases}  C(abda)=C(abd)+A(abd)P_a = 0.010111 + 0.000001\times0 = 0.010111\\  A(abda)=A(abd)p_a = 0.000001\times0.1 = 0.0000001  \end{cases}  $$</span></li><li>计算编码长度<span class="math inline"><em>L</em></span>：<span class="math display">$$L = \left\lceil\log\frac{1}{A(abcd)}\right\rceil= 7$$</span> 取<span class="math inline"><em>C</em>(<em>a</em><em>b</em><em>d</em><em>a</em>)</span>的小数点后<span class="math inline">7</span>位即为编码后的码字<span class="math inline">0101110</span>。</li></ol></li><li><p>该信源的熵为： <span class="math display">$$H(X)=\frac{1}{2}\log2+\frac{1}{4}\log4 +2\times\frac{1}{8}\log8 = 1.75\ bit/符号$$</span></p><p>编码效率<span class="math display">$$\eta=\frac{1.75}{\frac{7}{4}} =100\%$$</span></p></li><li><p><strong>译码过程如下</strong>： <img src="image-74.png" srcset="/img/loading/loading3.gif" lazyload></p><ol type="1"><li>已知编码后的数值<span class="math inline"><em>C</em>(<em>S</em>) = 0.010111</span>，因为<span class="math inline"><em>C</em>(<em>S</em>) = 0.010111 ∈ [0, 0.1)</span>，根据符号累积概率表，第一个符号为<span class="math inline"><em>a</em></span>。</li><li>去掉累积概率<span class="math inline"><em>P</em><sub><em>a</em></sub></span>：<span class="math inline">0.010111 − 0 = 0.010111</span>， 放大至<span class="math inline">[0, 1]</span>（乘以<span class="math inline"><em>p</em><sub><em>a</em></sub><sup>−1</sup></span>）：<span class="math inline">0.010111 × 2<sup>1</sup> = 0.10111 ∈ [0.1, 0.110)</span>第二个符号为<span class="math inline"><em>b</em></span>。</li><li>去掉累积概率<span class="math inline"><em>P</em><sub><em>b</em></sub></span>：<span class="math inline">0.10111 − 0.1 = 0.00111</span>。 放大至<span class="math inline">[0, 1]</span>（乘以<span class="math inline"><em>p</em><sub><em>b</em></sub><sup>−1</sup></span>）：<span class="math inline">0.00111 × 2<sup>2</sup> = 0.111 ∈ [0.111, 1)</span>第三个符号为<span class="math inline"><em>d</em></span>。</li><li>去掉累积概率<span class="math inline"><em>P</em><sub><em>d</em></sub></span>：<span class="math inline">0.111 − 0.111 = 0</span>。 放大至<span class="math inline">[0, 1]</span>（乘以<span class="math inline"><em>p</em><sub><em>d</em></sub><sup>−1</sup></span>）：<span class="math inline">0 × 2<sup>3</sup> = 0 ∈ [0, 0.1)</span>第四个符号为<span class="math inline"><em>a</em></span>。</li></ol></li></ul></li></ul><h4 id="lz编码">LZ编码</h4><ul><li><strong>特点</strong>：<ul><li>LZ编码是一种<strong>字典编码</strong>，无需确定信源的统计特性。</li></ul></li><li><strong>LZ78 编码步骤</strong><ul><li>设信源符号集<span class="math inline"><em>A</em> = (<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>K</em></sub>)</span>共<span class="math inline"><em>K</em></span>个符号，输入信源符号序列<span class="math inline"><em>U</em> = (<em>u</em><sub>1</sub>, <em>u</em><sub>2</sub>, ⋯, <em>u</em><sub><em>L</em></sub>)</span>，编码是将此序列分成不同的段。</li><li><strong>分段规则</strong>：尽可能取最少个相连的信源符号，并保证各段都不相同。<ol type="1"><li>在第<span class="math inline"><em>i</em></span>步，从<span class="math inline"><em>s</em><sub><em>i</em> − 1</sub></span>短语后的第一个符号开始向后搜索此前未出现过的最短短语<span class="math inline"><em>s</em><sub><em>i</em></sub></span>，将该短语添入字典第<span class="math inline"><em>i</em></span>段。</li><li>假设<span class="math inline"><em>s</em><sub><em>i</em></sub></span>去掉最后一个符号<span class="math inline"><em>x</em></span>后所得的前缀是在第<span class="math inline"><em>j</em></span>步出现的短语。</li><li>对<span class="math inline"><em>s</em><sub><em>i</em></sub></span>的编码为<span class="math inline">(<em>j</em>, <em>x</em>)</span>。<strong>对段号<span class="math inline"><em>j</em></span>，用<span class="math inline">⌈log <em>i</em>⌉</span>比特来表示，符号<span class="math inline"><em>x</em></span>用<span class="math inline">⌈log <em>K</em>⌉</span>比特来表示。</strong></li></ol></li></ul></li><li><strong>LZ译码</strong>：无需接收方提前知晓字典内容，通过码字和逐步构建的字典就能完成译码<ol type="1"><li>接收到码字<span class="math inline">(<em>j</em>, <em>x</em>)</span>后，在已建立或正在建立的字典中找到第<span class="math inline"><em>j</em></span>个短语。</li><li>将符号<span class="math inline"><em>x</em></span>添加到找到的第<span class="math inline"><em>j</em></span>个短语后，形成新的短语。</li><li>把新生成的短语添入字典，以便后续译码使用。</li><li>对每个接收到的码字，不断重复上述步骤，直至完成所有码字的译码。</li></ol></li><li><strong>例题</strong>：<ul><li><p><strong>编码</strong>：设<span class="math inline"><em>U</em> = {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>3</sub>, <em>a</em><sub>4</sub>}</span>，信源序列为<span class="math inline"><em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>3</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>4</sub>, <em>a</em><sub>2</sub>, <em>a</em><sub>4</sub>, <em>a</em><sub>3</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>1</sub>, <em>a</em><sub>4</sub>⋯</span>，按照分段规则进行分段。符号编码表如下:</p><table><thead><tr><th><span class="math inline"><em>a</em><sub>1</sub></span></th><th><span class="math inline"><em>a</em><sub>2</sub></span></th><th><span class="math inline"><em>a</em><sub>3</sub></span></th><th><span class="math inline"><em>a</em><sub>4</sub></span></th></tr></thead><tbody><tr><td>00</td><td>01</td><td>10</td><td>11</td></tr></tbody></table><table><thead><tr><th>段号<span class="math inline"><em>i</em></span></th><th>短语</th><th><span class="math inline"><em>j</em></span></th><th><span class="math inline"><em>x</em></span></th><th>码字</th><th>编码</th></tr></thead><tbody><tr><td>1</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td>0</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>1</sub>)</span></td><td>0,00</td></tr><tr><td>2</td><td><span class="math inline"><em>a</em><sub>2</sub></span></td><td>0</td><td><span class="math inline"><em>a</em><sub>2</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>2</sub>)</span></td><td>0,01</td></tr><tr><td>3</td><td><span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>3</sub></span></td><td>1</td><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline">(1, <em>a</em><sub>3</sub>)</span></td><td>01,10</td></tr><tr><td>4</td><td><span class="math inline"><em>a</em><sub>2</sub><em>a</em><sub>4</sub></span></td><td>2</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline">(2, <em>a</em><sub>4</sub>)</span></td><td>10,11</td></tr><tr><td>5</td><td><span class="math inline"><em>a</em><sub>2</sub><em>a</em><sub>4</sub><em>a</em><sub>3</sub></span></td><td>4</td><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline">(4, <em>a</em><sub>3</sub>)</span></td><td>100,10</td></tr><tr><td>6</td><td><span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>1</sub></span></td><td>1</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline">(1, <em>a</em><sub>1</sub>)</span></td><td>001,00</td></tr><tr><td>7</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td>0</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>4</sub>)</span></td><td>000,11</td></tr></tbody></table></li><li><p><strong>译码</strong>：码序列为00000101101011100100010000011。符号编码表如下：</p><table><thead><tr><th>段号<span class="math inline"><em>i</em></span></th><th>编码</th><th><span class="math inline"><em>j</em></span></th><th><span class="math inline"><em>x</em></span></th><th>码字</th><th>短语</th></tr></thead><tbody><tr><td>1</td><td>0,00</td><td>0</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>1</sub>)</span></td><td><span class="math inline"><em>a</em><sub>1</sub></span></td></tr><tr><td>2</td><td>0,01</td><td>0</td><td><span class="math inline"><em>a</em><sub>2</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>2</sub>)</span></td><td><span class="math inline"><em>a</em><sub>2</sub></span></td></tr><tr><td>3</td><td>01,10</td><td>1</td><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline">(1, <em>a</em><sub>3</sub>)</span></td><td><span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>3</sub></span></td></tr><tr><td>4</td><td>10,11</td><td>2</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline">(2, <em>a</em><sub>4</sub>)</span></td><td><span class="math inline"><em>a</em><sub>2</sub><em>a</em><sub>4</sub></span></td></tr><tr><td>5</td><td>100,10</td><td>4</td><td><span class="math inline"><em>a</em><sub>3</sub></span></td><td><span class="math inline">(4, <em>a</em><sub>3</sub>)</span></td><td><span class="math inline"><em>a</em><sub>2</sub><em>a</em><sub>4</sub><em>a</em><sub>3</sub></span></td></tr><tr><td>6</td><td>001,00</td><td>1</td><td><span class="math inline"><em>a</em><sub>1</sub></span></td><td><span class="math inline">(1, <em>a</em><sub>1</sub>)</span></td><td><span class="math inline"><em>a</em><sub>1</sub><em>a</em><sub>1</sub></span></td></tr><tr><td>7</td><td>000,11</td><td>0</td><td><span class="math inline"><em>a</em><sub>4</sub></span></td><td><span class="math inline">(0, <em>a</em><sub>4</sub>)</span></td><td><span class="math inline"><em>a</em><sub>4</sub></span></td></tr></tbody></table></li></ul></li></ul><h4 id="游程编码rlerun-length-encoding">游程编码(RLE，run-lengthencoding)</h4><ul><li>在二元序列中，连0段称为0游程，连1段称为1游程。</li><li>例如二元码序列：<span class="math inline">000101110010001⋯</span>，可变换成下列游程序列：<span class="math inline">31132131⋯</span> 。</li><li>若已知二元序列以0起始，从游程序列很容易恢复成原来的二元序列。</li><li>游程序列是多元序列，各长度可按哈夫曼编码或其它方法处理以达到压缩码率的目的。</li></ul><h4 id="mh-编码传真编码">MH 编码(传真编码)</h4><ul><li><strong>MH编码方法</strong><ol type="1"><li>黑白游程分别对应不同的编码表。</li><li>游程长度在<span class="math inline">0 ∼ 63</span>时，码字直接用相应的终端码（结尾码）表示。<ul><li>例如：<ul><li>白游程长度为<span class="math inline">0</span>，查表得码字<span class="math inline">000</span> 。</li><li>黑游程长度为<span class="math inline">24</span> ，查表得码字<span class="math inline">11111</span> 。</li></ul></li></ul></li><li>游程长度在<span class="math inline">64 ∼ 1728</span>，用一个组合码加上一个结尾码为相应码字。<ul><li>例如：<ul><li>白游程长度为<span class="math inline">65( = 64 + 1)</span>，查表得码字<span class="math inline">11011 ∣ 000111</span> 。</li><li>黑游程长度为<span class="math inline">856( = 832 + 24)</span>，查表得码字<span class="math inline">0000001001101 ∣ 00000010111</span>。</li></ul></li></ul></li><li>规定每行都从白游程开始，若实际出现黑游程开始的话，则在行首加上零长度白游程码字，每行结束用一个结束码（EOL）。</li><li>每行恢复成<span class="math inline">1728</span>个像素，否则有错。</li><li>每页文件开始第一个数据前加一个结束码。每页尾连续使用<span class="math inline">6</span>个结束码表示结尾。</li><li>为了传输时实现同步操作，规定<span class="math inline"><em>T</em></span>为每编码行的最小传输时间。一般规定<span class="math inline"><em>T</em></span>最小为<span class="math inline">20<em>m</em><em>s</em></span>，最大为<span class="math inline">5<em>s</em></span>。若编码行传输时间小于<span class="math inline"><em>T</em></span>，则在结束码之前填以足够的“<span class="math inline">0</span>”码元（称填充码） 。</li></ol></li><li>页面数据结构<img src="image-76.png" srcset="/img/loading/loading3.gif" lazyload alt="页面数据结构"></li><li>结尾码码表<img src="image-77.png" srcset="/img/loading/loading3.gif" lazyload alt="结尾码码表"></li><li>组合基干码码表<img src="image-78.png" srcset="/img/loading/loading3.gif" lazyload alt="组合基干码码表"></li><li>例题：<img src="image-97.png" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li></ul><h1 id="第五章补充-无失真信源编码">第五章补充 无失真信源编码</h1><h2 id="渐进均分性定理aep-1">渐进均分性定理（AEP）</h2><ul><li><p><strong>定理</strong>：<span class="math inline"><em>X⃗</em> = (<em>X</em><sub>1</sub><em>X</em><sub>2</sub>⋯<em>X</em><sub><em>L</em></sub>)</span>，为独立同分布（i.i.d）随机变量序列，具有渐近均分性质（AEP，Asymptoticequipartition property）： <span class="math display">$$\forall\varepsilon &gt; 0，当 L \to \infty时，p(X_1,X_2,\cdots,X_L) \to 2^{-LH(X)}$$</span></p></li><li><p><strong>信源编码模型</strong>： <img src="image-39.png" srcset="/img/loading/loading3.gif" lazyload alt="信源模型"></p><ul><li><span class="math inline"><em>X</em><sub><em>i</em></sub> ∈ {<em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, ⋯, <em>a</em><sub><em>n</em></sub>}</span></li><li><span class="math inline"><em>Y</em><sub><em>i</em></sub> ∈ {<em>b</em><sub>1</sub>, <em>b</em><sub>2</sub>, ⋯, <em>b</em><sub><em>m</em></sub>}</span></li></ul></li><li><p><strong>证明1</strong>：</p><ul><li><strong>自信息量</strong>： <span class="math display">$$  \begin{align*}  I(\vec{X}) &amp;= -\log p(X_1,X_2,\cdots,X_L)\\  &amp;=-\log p(X_1)-\log p(X_2)-\cdots-\log p(X_L)\\  &amp;=\sum_{i = 1}^{L} I(X_i)  \end{align*}  $$</span></li><li><strong>均值</strong>(由i.i.d.)）： <span class="math display">$$  E\{I(\vec{X})\}=E\left\{\sum_{i = 1}^{L} I(X_i)\right\}=\sum_{i =1}^{L} E\{I(X_i)\}=\sum_{i = 1}^{L} H(X_i)=L H(X)  $$</span></li><li><strong>方差</strong>(由i.i.d.)： <span class="math display">$$  D\{I(\vec{X})\}=D\left\{\sum_{i = 1}^{L} I(X_i)\right\}=\sum_{i =1}^{L} D\{I(X_i)\}=L D(I(X))  $$</span> 其中 <span class="math display">$$  D(I(X)) = E\left[(I(X)-H(X))^2\right]=\sum_{i = 1}^{n} p(x_i)(-\logp(x_i)-H(X))^2  $$</span></li><li>根据切比雪夫不等式 <span class="math display">$$      P_r\{|X - \mu| \geq \varepsilon\} \leq\frac{\sigma^2}{\varepsilon^2}\quad (\varepsilon&gt;0, \sigma&gt;0)  $$</span> 有： <span class="math display">$$  P_r\left\{\left|I(\vec{X})-L H(X)\right| \geq L\varepsilon\right\}\leq \frac{L D(I(X))}{(L\varepsilon)^2}  $$</span> <span class="math display">$$  P_r\left\{\left|\frac{I(\vec{X})}{L}-H(X)\right| \geq\varepsilon\right\} \leq \frac{D(I(X))}{L\varepsilon^2}  $$</span> 当 <span class="math inline"><em>L</em> → ∞</span> 时 <span class="math display">$$  \begin{align*}  &amp;\frac{D(I(X))}{L\varepsilon^2} \to 0,\\  &amp;\frac{-\log p(X_1,X_2,\cdots,X_L)}{L} \to H(X),\\  &amp;p(X_1,X_2,\cdots,X_L) \to 2^{-L H(X)}  \end{align*}  $$</span></li></ul></li><li><p><strong>证明2</strong>：</p><ul><li>AEP 也可由弱大数定律直接得到</li><li>当 <span class="math inline"><em>X</em></span> 为 i.i.d，<span class="math inline"><em>n</em></span> 很大时，<span class="math inline">$\frac{1}{n}\sum_{i = 1}^{n} x_i \to E(X)$</span><span class="math display">$$  \begin{align*}  -\frac{1}{L}\log p(X_1,X_2,\cdots,X_L)= &amp;-\frac{1}{L}\sum_{i =1}^{L} \log p(X_i)\\  \overset{a.s.}{\to} &amp;-E(\log p(X))\\  = &amp;H(X)  \end{align*}  $$</span></li></ul></li><li><p><strong>典型集<span class="math inline"><em>A</em><sub><em>ε</em></sub></span></strong></p><ul><li><p><strong>定义</strong> <span class="math display">$$  \begin{align*}  &amp;A_{\varepsilon}=\left\{\vec{x}:\left|\frac{I(\vec{x})}{L}-H(X)\right|\leq \varepsilon\right\}\\  &amp;A_{\varepsilon}^c=\left\{\vec{x}:\left|\frac{I(\vec{x})}{L}-H(X)\right|&gt; \varepsilon\right\}\\  &amp;A_{\varepsilon}+A_{\varepsilon}^c = X^L=\{\vec{x_{i}}\}\quad i =1,2,\cdots,n^L  \end{align*}  $$</span></p></li><li><p><strong>性质</strong></p><ol type="1"><li>若 <span class="math inline"><em>x⃗</em> ∈ <em>A</em><sub><em>ε</em></sub></span>，则典型集中的元素几乎是等概率出现的：<span class="math display">2<sup>−<em>L</em>(<em>H</em>(<em>X</em>) + <em>ε</em>)</sup> ≤ <em>p</em>(<em>x⃗</em>) ≤ 2<sup>−<em>L</em>(<em>H</em>(<em>X</em>) − <em>ε</em>)</sup></span></li><li>当 <span class="math inline"><em>L</em></span>充分大时，典型集的概率近似为1： <span class="math display"><em>P</em><sub><em>r</em></sub>(<em>A</em><sub><em>ε</em></sub>) = ∑<sub><em>x⃗</em> ∈ <em>A</em><sub><em>ε</em></sub></sub><em>p</em>(<em>x⃗</em>) &gt; 1 − <em>ε</em></span></li><li>典型集中元素的个数： <span class="math display">|<em>A</em><sub><em>ε</em></sub>| ≤ 2<sup><em>L</em>(<em>H</em>(<em>X</em>) + <em>ε</em>)</sup></span><ul><li>证明： <span class="math display">$$  \begin{align*}  1&amp;=\sum_{\vec{x} \in X^L} p(\vec{x}) \geq \sum_{\vec{x} \inA_{\varepsilon}} p(\vec{x})\\  &amp;\geq \sum_{\vec{x} \in A_{\varepsilon}}2^{-L(H(X)+\varepsilon)}=|A_{\varepsilon}|2^{-L(H(X)+\varepsilon)}\\  \Rightarrow &amp;|A_{\varepsilon}| \leq 2^{L(H(X)+\varepsilon)}  \end{align*}  $$</span></li></ul></li><li>典型集中元素的个数： <span class="math display">|<em>A</em><sub><em>ε</em></sub>| ≥ (1 − <em>ε</em>)2<sup><em>L</em>(<em>H</em>(<em>X</em>) − <em>ε</em>)</sup></span>当 <span class="math inline"><em>L</em></span> 充分大时，<span class="math inline"><em>P</em><sub><em>r</em></sub>(<em>A</em><sub><em>ε</em></sub>) &gt; 1 − <em>ε</em></span><ul><li>证明： <span class="math display">$$  \begin{align*}  1-\varepsilon &amp;\leq P_r(A_{\varepsilon}) = \sum_{\vec{x} \inA_{\varepsilon}} p(\vec{x})\\  &amp; \leq \sum_{\vec{x} \in A_{\varepsilon}}2^{-L(H(X)-\varepsilon)}=|A_{\varepsilon}|2^{-L(H(X)-\varepsilon)}\\  \Rightarrow |A_{\varepsilon}| &amp;\geq (1 -\varepsilon)2^{L(H(X)-\varepsilon)}  \end{align*}  $$</span></li></ul></li></ol></li></ul></li></ul><h2 id="定长编码定理-1">定长编码定理</h2><ul><li><p><strong>定理</strong>：对于由 <span class="math inline"><em>L</em></span> 个符号组成的，每个符号的熵为 <span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>)</span>的无记忆平稳符号序列 <span class="math inline"><em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, ⋯, <em>X</em><sub><em>L</em></sub></span>，可用<span class="math inline"><em>K</em><sub><em>L</em></sub></span> 个符号<span class="math inline"><em>Y</em><sub>1</sub>, <em>Y</em><sub>2</sub>, ⋯, <em>Y</em><sub><em>K</em><sub><em>L</em></sub></sub></span>（每个符号有<span class="math inline"><em>m</em></span> 种可能值，即<span class="math inline"><em>m</em></span>进制编码）进行定长编码。对于任意<span class="math inline"><em>ε</em> &gt; 0</span>，<span class="math inline"><em>δ</em> &gt; 0</span>，只要 <span class="math display">$$\frac{K_L}{L}\log m \geq H_L(\vec{X}) +\varepsilon$$</span></p><p>则当 <span class="math inline"><em>L</em></span>足够大时，必可使译码差错小于 <span class="math inline"><em>δ</em></span>； 反之，当 <span class="math display">$$\frac{K_L}{L}\log m \leq H_L(\vec{X}) -2\varepsilon$$</span></p><p>时，译码差错一定是有限值，当 <span class="math inline"><em>L</em> → ∞</span>时，译码几乎必定出错。</p></li><li><p><strong>证明</strong></p><ul><li><p>对 <span class="math inline"><em>A</em><sub><em>ε</em></sub></span>中的元素进行定长编码，为了唯一可译，码符号个数大于等于 <span class="math inline">|<em>A</em><sub><em>ε</em></sub>|</span>，即 <span class="math display"><em>m</em><sup><em>K</em><sub><em>L</em></sub></sup> ≥ |<em>A</em><sub><em>ε</em></sub>|</span></p><p>此时<span class="math inline">|<em>A</em><sub><em>ε</em></sub>|</span>取上界，记平均符号熵<span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>)</span>为 <span class="math inline"><em>H</em>(<em>X</em>)</span> <span class="math display">$$  \begin{align*}  m^{K_L} &amp;\geq 2^{L(H(X) + \varepsilon)}\\  K_L\log m &amp;\geq L(H(X) + \varepsilon)\\  \frac{K_L}{L}\log m &amp;\geq H(X) + \varepsilon  \end{align*}  $$</span></p><p>此时，错误译码的概率为 <span class="math display">$$P_e =P_r\{A_{\varepsilon}^c\} \leq\frac{D(I(X))}{L\varepsilon^2}$$</span></p><p>若需 <span class="math inline"><em>P</em><sub><em>e</em></sub> ≤ <em>δ</em></span>，则有<span class="math display">$$  \begin{align*}  &amp;\frac{D(I(X))}{L\varepsilon^2} \leq \delta\\  &amp;L \geq \frac{D(I(X))}{\varepsilon^2\delta}  \end{align*}  $$</span></p><p>即信源长度 <span class="math inline"><em>L</em></span> 需满足 <span class="math inline">$L \geq\frac{D(I(X))}{\varepsilon^2\delta}$</span></p></li><li><p>反之，若 <span class="math display">$$  \begin{align*}  &amp;\frac{K_L}{L}\log m \leq H(X) - 2\varepsilon\\  &amp;\log m^{K_L} \leq L(H(X) - 2\varepsilon)\\  &amp;m^{K_L} \leq 2^{L(H(X) - 2\varepsilon)} &lt; (1 -\varepsilon)2^{L(H(X) - \varepsilon)} = |A_{\varepsilon}|_{min}  \end{align*}  $$</span></p><p>即 <span class="math inline"><em>m</em><sup><em>K</em><sub><em>L</em></sub></sup> &lt; |<em>A</em><sub><em>ε</em></sub>|</span>，码字个数少于<span class="math inline"><em>A</em><sub><em>ε</em></sub></span>中的元素个数</p><p>此时只能在 <span class="math inline"><em>A</em><sub><em>ε</em></sub></span> 中选取 <span class="math inline"><em>m</em><sup><em>K</em><sub><em>L</em></sub></sup></span>个元素进行一对一编码， <span class="math display">$$  \begin{align*}  P_r(只出现A_{\varepsilon}中的m^{K_L}个元素) &amp;\leq m^{K_L} \cdot\max_{\vec{x} \in A_{\varepsilon}} p(\vec{x}) = m^{K_L}2^{-L(H(X) -\varepsilon)}\\  &amp;\leq 2^{L(H(X) - 2\varepsilon) - L(H(X) - \varepsilon)}\\  &amp;= 2^{-L\varepsilon}  \end{align*}  $$</span></p><p>译码错误概率为 <span class="math inline"><em>P</em><sub><em>e</em></sub> = 1 − 2<sup>−<em>L</em><em>ε</em></sup></span>，<span class="math inline"><em>L</em> → ∞</span>，<span class="math inline"><em>P</em><sub><em>e</em></sub> → 1</span></p></li></ul></li></ul><h2 id="单符号变长编码定理">单符号变长编码定理</h2><ul><li><p><strong>定理</strong>：对于离散无记忆信源的符号 <span class="math inline"><em>X</em></span>，其熵为 <span class="math inline"><em>H</em>(<em>X</em>)</span>，每个信源符号用 <span class="math inline"><em>m</em></span>进制码元进行变长编码，一定存在一种无失真编码方法，其（<span class="math inline"><em>m</em></span> 进制）码元平均长度 <span class="math inline">$\overline{k}$</span> 满足下列不等式： <span class="math display">$$\frac{H(X)}{\log m} \leq \overline{k} &lt;\frac{H(X)}{\log m} + 1$$</span></p><p>其中，<span class="math inline">$\overline{k} = \sum_{i = 1}^{n}p(a_i)l_i$</span>，<span class="math inline"><em>l</em><sub><em>i</em></sub></span> 为符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span>的码长。</p></li><li><p><strong>证明</strong>：</p><ul><li><strong>定义</strong>：<span class="math inline"><em>l</em><sub><em>i</em></sub></span> 为符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的码长，<span class="math inline"><em>p</em>(<em>a</em><sub><em>i</em></sub>)</span>为符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span>的概率，<span class="math inline">$\overline{k} = \sum_{i = 1}^{n}p(a_i)l_i$</span> 为码元平均长度。</li><li><figure><img src="image-57.png" srcset="/img/loading/loading3.gif" lazyload alt="码元平均长度"><figcaption aria-hidden="true">码元平均长度</figcaption></figure></li></ul><ol type="1"><li><p><strong>证明必存在无失真编码，使得 <span class="math inline">$H(X) - (\log m)\overline{k} \leq 0$</span></strong><span class="math display">$$\begin{align*}H(X) - (\log m)\overline{k} &amp;= -\sum_{i = 1}^{n} p(a_i)\log p(a_i) -\sum_{i = 1}^{n} p(a_i)l_i\log m\\&amp;=\sum_{i = 1}^{n} p(a_i)\log \frac{m^{-l_i}}{p(a_i)}\end{align*}$$</span></p><p>根据Jensen不等式 <span class="math inline"><em>E</em>[<em>f</em>(<em>x</em>)] ≤ <em>f</em>(<em>E</em>(<em>x</em>))</span>，有<span class="math display">$$\begin{align*}H(X) - (\log m)\overline{k} &amp;=\sum_{i = 1}^{n} p(a_i)\log\frac{m^{-l_i}}{p(a_i)}\\&amp;\leq \log \sum_{i = 1}^{n} p(a_i)\frac{m^{-l_i}}{p(a_i)} = \log\sum_{i = 1}^{n} m^{-l_i}\end{align*}$$</span></p><p>唯一可译码存在（无失真），因此 <span class="math inline">$\sum_{i =1}^{n} m^{-l_i} \leq 1$</span> <span class="math display">$$\begin{align*}&amp;H(X) - (\log m)\overline{k} \leq \log 1 = 0\\&amp;\Rightarrow \overline{k} \geq \frac{H(X)}{\log m}\end{align*}$$</span></p><p>若要等号成立 <span class="math display">$$m^{-l_i} = p(a_i),\quad l_i = \frac{-\log p(a_i)}{\log m}$$</span></p></li><li><p><strong>证明 <span class="math inline">$\overline{k} &lt;\frac{H(X)}{\log m} + 1$</span></strong> 符号 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的码长 <span class="math inline"><em>l</em><sub><em>i</em></sub></span>需要是整数，因此取 <span class="math display">$$\frac{-\log p(a_i)}{\logm} \leq l_i &lt; \frac{-\log p(a_i)}{\log m} + 1$$</span></p><p>由 <span class="math display">$$\begin{align*}&amp;\frac{-\log p(a_i)}{\log m} \leq l_i\\&amp;\Rightarrow -\log m^{l_i} \leq \log p(a_i)\\&amp;\Rightarrow m^{-l_i} \leq p(a_i)\\&amp;\Rightarrow \sum_{i = 1}^{n} m^{-l_i} \leq \sum_{i = 1}^{n}p(a_i)=1\end{align*}$$</span></p><p>表明 <span class="math inline"><em>l</em><sub><em>i</em></sub></span>满足唯一可译码存在的条件。 又由 <span class="math display">$$\begin{align*}l_i &amp;&lt; \frac{-\log p(a_i)}{\log m} + 1\\\sum_{i = 1}^{n} l_i p(a_i) &amp;&lt; \sum_{i = 1}^{n}p(a_i)(\frac{-\log p(a_i)}{\log m} + 1)\\\overline{k} &amp;&lt; \frac{H(X)}{\log m} + 1\end{align*}$$</span></p></li></ol></li></ul><h2 id="离散平稳无记忆序列变长编码定理香农第一定理-1">离散平稳无记忆序列变长编码定理（香农第一定理）</h2><ul><li><p><strong>定理</strong>：对于平均符号熵为 <span class="math inline"><em>H</em><sub><em>L</em></sub>(<em>X⃗</em>)</span>的离散平稳无记忆信源，必存在一种无失真编码方法，使平均信息率 <span class="math inline">$\overline{K}$</span> 满足不等式： <span class="math display">$$H_L(\vec{X}) \leq \overline{K} &lt; H_L(\vec{X})+ \varepsilon$$</span></p><p>其中 <span class="math inline"><em>ε</em></span> 为任意小正数，<span class="math inline">$\overline{K} = \frac{\overline{k}_L}{L} \logm$</span>，<span class="math inline">$\overline{k}_L$</span> 为 <span class="math inline"><em>L</em></span> 个符号的平均码长。</p></li><li><p><strong>证明</strong> 将 <span class="math inline"><em>X⃗</em> = (<em>X</em><sub>1</sub><em>X</em><sub>2</sub>⋯<em>X</em><sub><em>L</em></sub>)</span>作为一个整体，构成一个新的单符号信源。因此有： <span class="math display">$$  \begin{align*}  \frac{L H_L(\vec{X})}{\log m} &amp;\leq \overline{k}_L &lt; \frac{LH_L(\vec{X})}{\log m} + 1\\  H_L(\vec{X}) &amp;\leq \frac{\overline{k}_L}{L} \log m &lt;H_L(\vec{X}) + \frac{\log m}{L}  \end{align*}  $$</span></p><p>令 <span class="math inline">$\overline{K}= \frac{\overline{k}_L}{L}\log m$</span>，则有 <span class="math display">$$H_L(\vec{X}) \leq\overline{K} &lt; H_L(\vec{X}) + \varepsilon \quad (L \to\infty)$$</span></p><p>此时编码效率<span class="math display">$$\eta =\frac{H_L(\vec{X})}{\overline{K}} &gt; \frac{H_L(\vec{X})}{H_L(\vec{X})+ \frac{\log m}{L}}$$</span></p></li></ul><h1 id="第六章-信道编码">第六章 信道编码</h1><ul><li>信道传输会使接收信号出现差错，信道编码旨在提升传输可靠性，主要涉及两个层面的问题：<ul><li>如何准确接收承载信息的信号：线路编码（通信原理）</li><li>怎样避免少量错误信号对信息内容产生影响：纠错编码</li></ul></li></ul><h2 id="信道编码概念和理论">6.1 6.2 信道编码概念和理论</h2><h3 id="差错和差错控制系统分类">差错和差错控制系统分类</h3><ul><li><p><strong>差错类型</strong></p><ul><li><strong>符号差错</strong>：由符号发生差错引起，也叫信号差错，信号差错概率用符号差错概率表示。</li><li><strong>差错比特</strong>：由信息比特发生差错引起，也叫信息差错，信息差错概率用误比特率表示。</li><li>对于二进制传输系统，符号差错等效于比特差错。</li><li>对于多进制系统，一个符号差错到底对应多少比特差错难以确定，因为一个符号由多个比特组成。</li></ul></li><li><p>两种八电平线路编码方法比较</p><table><thead><tr><th>量级</th><th>自然二进码</th><th>反射二进码(格雷码)</th></tr></thead><tbody><tr><td>0</td><td>000</td><td>000</td></tr><tr><td>1</td><td>001</td><td>001</td></tr><tr><td>2</td><td>010</td><td>011</td></tr><tr><td>3</td><td>011</td><td>010</td></tr><tr><td>4</td><td>100</td><td>110</td></tr><tr><td>5</td><td>101</td><td>111</td></tr><tr><td>6</td><td>110</td><td>101</td></tr><tr><td>7</td><td>111</td><td>100</td></tr></tbody></table><ul><li>格雷码可以通过普通二进制码转换得到。</li><li>以下是生成格雷码的常见方法：<ol type="1"><li>最高位保留：格雷码的最高位（最左边） 与二进制码的最高位相同。</li><li>逐位异或：格雷码的每一位是二进制码当前位与上一位的异或结果。</li></ol></li></ul></li><li><p><strong>差错图样</strong>（error pattern）</p><ul><li><strong>定义</strong>：<ul><li><strong>差错图样 <span class="math inline"><em>E</em>=</span> 发码<span class="math inline"><em>C</em>−</span> 收码 <span class="math inline"><em>R</em></span> <span class="math inline">( mod &nbsp;<em>q</em>)</span></strong></li><li><strong>示例</strong>：8进制(<span class="math inline"><em>q</em> = 8</span>)码，若发码 <span class="math inline"><em>C</em> = (0, 2, 5, 4, 7, 5, 2)</span> ，收码变为<span class="math inline"><em>R</em> = (0, 1, 5, 4, 7, 5, 4)</span>，差错图样 <span class="math inline"><em>E</em> = <em>C</em> − <em>R</em> = (0, 1, 0, 0, 0, 0, 6)</span>（模8）。</li></ul></li><li>二进制码：<span class="math inline"><em>E</em> = <em>C</em> ⊕ <em>R</em></span> 或 <span class="math inline"><em>C</em> = <em>R</em> ⊕ <em>E</em></span>，差错图样中的“1”既是符号差错也是比特差错。</li><li><strong>汉明距离</strong>：两码字之间不同的位数叫它们之间的汉明距离，记作<span class="math inline"><em>d</em>(<em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub>)</span>，即<span class="math display">$$d(c_i,c_j) = \sum_{k=1}^{N}c_{ik}\oplusc_{jk}$$</span></li><li><strong>差错图样类型</strong><ul><li><strong>随机差错</strong>：若差错图样上各码位的取值既与前后位置无关又与时间无关，即差错始终以相等的概率独立发生于各码字、各码元、各比特</li><li><strong>突发差错</strong>：前后相关、成堆出现。突发差错总是以差错码元开头、以差错码元结尾，头尾之间并不是每个码元都错，而是码元差错概率超过了某个额定值</li></ul></li></ul></li><li><p><strong>纠错码分类</strong></p><ul><li><strong>从功能角度</strong>：检错码 、纠错码</li><li><strong>对信息序列的处理方法</strong>：分组码、卷积码</li><li><strong>码元与原始信息位的关系</strong>：线性码、非线性码</li><li><strong>差错类型</strong>：纠随机差错码、纠突发差错码、介于中间的纠随机/突发差错码</li><li><strong>构码理论</strong>：代数码、几何码、算术码、组合码等</li></ul></li><li><p><strong>差错控制系统分类</strong></p><ul><li><strong>前向纠错（FEC）</strong>：发端信息经纠错编码后传送，收端通过纠错译码自动纠正传递过程中的差错</li><li><strong>反馈重发（ARQ）</strong>：收端通过检测接收码是否符合编码规律来判断，如判定码组有错，则通过反向信道通知发端重发该码组</li><li><strong>混合纠错（HEC）</strong>：前向纠错和反馈重发的结合，发端发送的码兼有检错和纠错两种能力</li></ul></li></ul><h3 id="矢量空间与码空间">矢量空间与码空间</h3><h4 id="矢量空间">矢量空间</h4><ul><li>**矢量*<ul><li><span class="math inline"><em>F</em></span>表示码元所在的<strong>数域</strong>，对于二进制码，<span class="math inline"><em>F</em></span>代表二元域<span class="math inline">{0, 1}</span>。</li><li>设<span class="math inline"><em>n</em></span>重有序元素（<span class="math inline"><em>n</em></span>重矢量）的集合<span class="math inline"><em>V</em> = {<em>v</em><sub><em>i</em></sub>}</span><span class="math display"><em>v</em><sub><em>i</em></sub> = (<em>v</em><sub><em>i</em>0</sub>, <em>v</em><sub><em>i</em>1</sub>, ⋯, <em>v</em><sub><em>i</em><em>j</em></sub>, ⋯, <em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub>)  <em>v</em><sub><em>j</em><em>i</em></sub> ∈ <em>F</em></span></li><li>若满足条件：<ol type="1"><li><span class="math inline"><em>V</em></span>中矢量元素在<strong>矢量加运算</strong>下构成加群。</li><li><span class="math inline"><em>V</em></span>中矢量元素与数域<span class="math inline"><em>F</em></span>元素的<strong>标乘</strong>封闭在<span class="math inline"><em>V</em></span>中。</li><li>分配律、结合律成立。</li></ol>则称集合<span class="math inline"><em>V</em></span>是数域<span class="math inline"><em>F</em></span>上的一个<span class="math inline"><em>n</em></span><strong>重矢量空间</strong>，或称<span class="math inline"><em>n</em></span>重线性空间，<span class="math inline"><em>n</em></span>重矢量又称<span class="math inline"><em>n</em></span>重(<span class="math inline"><em>n</em></span>-tuples)。</li><li>码字又叫码矢、<span class="math inline"><em>n</em></span>重(矢量)。</li><li><strong>示例</strong>：<span class="math inline"><em>n</em></span>维实数域矢量空间<span class="math inline">ℝ<sup><em>n</em></sup></span>，<span class="math inline"><em>n</em></span>维复数域矢量空间<span class="math inline">ℂ<sup><em>n</em></sup></span>，<span class="math inline"><em>n</em></span>维有限域矢量空间<span class="math inline"><em>G</em><em>F</em>(<em>q</em>)<sup><em>n</em></sup></span>等。</li></ul></li><li><strong>码矢的运算法则</strong><ul><li>码矢的运算法则遵从矢量的运算法则，对于矢量<span class="math inline"><em>v</em><sub><em>i</em></sub> = (<em>v</em><sub><em>i</em>0</sub>, <em>v</em><sub><em>i</em>1</sub>, ⋯, <em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub>)</span>，<span class="math inline"><em>v</em><sub><em>j</em></sub> = (<em>v</em><sub><em>j</em>0</sub>, <em>v</em><sub><em>j</em>1</sub>, ⋯, <em>v</em><sub><em>j</em>(<em>n</em> − 1)</sub>)</span>，及标量<span class="math inline"><em>α</em> ∈ <em>F</em></span>（数域），定义：<ul><li><strong>矢量加</strong>：<span class="math inline"><em>v</em><sub><em>i</em></sub> + <em>v</em><sub><em>j</em></sub> = (<em>v</em><sub><em>i</em>0</sub> + <em>v</em><sub><em>j</em>0</sub>, <em>v</em><sub><em>i</em>1</sub> + <em>v</em><sub><em>j</em>1</sub>, ⋯, <em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub> + <em>v</em><sub><em>j</em>(<em>n</em> − 1)</sub>)</span>，所得结果仍是矢量。</li><li><strong>标乘（标量乘矢量）</strong>：<span class="math inline"><em>α</em><em>v</em><sub><em>i</em></sub> = (<em>α</em><em>v</em><sub><em>i</em>0</sub>, <em>α</em><em>v</em><sub><em>i</em>1</sub>, ⋯, <em>α</em><em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub>)</span>，所得结果是矢量。</li><li><strong>点积或内积（矢量乘矢量）</strong>：<span class="math inline"><em>v</em><sub><em>i</em></sub> ⋅ <em>v</em><sub><em>j</em></sub> = <em>v</em><sub><em>i</em>0</sub> ⋅ <em>v</em><sub><em>j</em>0</sub> + <em>v</em><sub><em>i</em>1</sub> ⋅ <em>v</em><sub><em>j</em>1</sub> + ⋯ + <em>v</em><sub><em>i</em>(<em>n</em> − 1)</sub> ⋅ <em>v</em><sub><em>j</em>(<em>n</em> − 1)</sub></span>，所得结果是标量。</li></ul></li></ul></li><li><strong>矢量空间中各元素间的关系</strong><ul><li><strong>线性组合</strong>：若<span class="math inline"><em>v</em><sub><em>k</em></sub> = <em>a</em><sub>1</sub><em>v</em><sub>1</sub> + <em>a</em><sub>2</sub><em>v</em><sub>2</sub> + ⋯ + <em>a</em><sub><em>l</em></sub><em>v</em><sub><em>l</em></sub></span>(<span class="math inline"><em>a</em><sub><em>i</em></sub> ∈ <em>F</em></span>)，则称<span class="math inline"><em>v</em><sub><em>k</em></sub></span>是<span class="math inline"><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ⋯, <em>v</em><sub><em>l</em></sub></span>的线性组合。</li><li><strong>线性相关</strong>：若满足<span class="math inline"><em>a</em><sub>1</sub><em>v</em><sub>1</sub> + <em>a</em><sub>2</sub><em>v</em><sub>2</sub> + ⋯ + <em>a</em><sub><em>l</em></sub><em>v</em><sub><em>l</em></sub> = 0</span>，(<span class="math inline"><em>a</em><sub><em>i</em></sub> ∈ <em>F</em></span>且不全为<span class="math inline">0</span>)，则称<span class="math inline"><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ⋯, <em>v</em><sub><em>l</em></sub></span>线性相关。其中任一矢量可表示为其它矢量的线性组合。</li><li><strong>线性无关或线性独立</strong>：一组矢量中的任意一个都不可能用其它矢量的线性组合来代替。</li></ul></li><li><strong>矢量空间与基底</strong><ul><li>如果存在一组线性无关的矢量<span class="math inline"><em>v</em><sub>1</sub>, <em>v</em><sub>2</sub>, ⋯, <em>v</em><sub><em>k</em></sub></span>，这些矢量<strong>线性组合的集合</strong>就构成了一个<span class="math inline"><em>k</em></span><strong>维矢量空间</strong><span class="math inline"><em>V</em></span>，这组矢量就是这个矢量空间的<strong>基底</strong>。</li><li><strong>性质</strong>：<ul><li><strong><span class="math inline"><em>k</em></span>维矢量空间应包含<span class="math inline"><em>k</em></span>个基底</strong>，可以说：<span class="math inline"><em>k</em></span>个基底“张成”<span class="math inline"><em>k</em></span>维矢量空间。</li><li><strong>基底不是唯一的</strong>。<ul><li>示例：线性无关的两个矢量<span class="math inline">(1, 0)</span>和<span class="math inline">(0, 1)</span>以及<span class="math inline">(−1, 0)</span>和<span class="math inline">(0, −1)</span>都可张成同一个2维实数域空间(<span class="math inline"><em>x</em>, <em>y</em></span>) 。</li></ul></li></ul></li><li><strong>自然基底</strong>：矢量元素中包含一个<span class="math inline">1</span>而其余为<span class="math inline">0</span>的那组基底</li></ul></li><li><strong>子空间</strong><ul><li>若矢量空间<span class="math inline"><em>V</em></span>的一个子集<span class="math inline"><em>V</em><sub><em>s</em></sub></span>也能构成一个矢量空间，则称<span class="math inline"><em>V</em><sub><em>s</em></sub></span>是<span class="math inline"><em>V</em></span>的子空间 。</li><li><strong>示例</strong>：<ul><li>二元域<span class="math inline"><em>G</em><em>F</em>(2)</span>上三维三重矢量空间<span class="math inline"><em>V</em></span>的三个自然基底是<span class="math inline">(100)</span>，<span class="math inline">(010)</span>，<span class="math inline">(001)</span> 。</li><li>以<span class="math inline">(100)</span>为基底可张成一维三重子空间<span class="math inline"><em>V</em><sub><em>s</em>1</sub></span>，含<span class="math inline">2<sup>1</sup> = 2</span>个元素，即 <span class="math inline"><em>V</em><sub><em>s</em>1</sub> = {(000), (100)}</span>。</li><li>以<span class="math inline">(010), (001)</span>为基底可张成二维三重子空间<span class="math inline"><em>V</em><sub><em>s</em>2</sub></span>，含<span class="math inline">2<sup>2</sup> = 4</span>个元素，即 <span class="math inline"><em>V</em><sub><em>s</em>2</sub> = {(000), (001), (010), (011)}</span>。</li><li><span class="math inline"><em>V</em><sub><em>s</em>1</sub></span>和<span class="math inline"><em>V</em><sub><em>s</em>2</sub></span>都是<span class="math inline"><em>V</em></span>的子空间。</li></ul></li></ul></li><li><strong>矢量空间构成</strong><ul><li>每个矢量空间或子空间中必然包含<strong>零矢量</strong>。</li><li><strong>构成矢量的有序元素的个数称为“重”数，张成矢量空间的基底的个数称为“维”数</strong>。</li><li>一般情况下，由<span class="math inline"><em>n</em></span>个<span class="math inline"><em>n</em></span>重的基底张成<span class="math inline"><em>n</em></span>维矢量空间<span class="math inline"><em>V</em><sub><em>n</em></sub></span>，维数和重数一致。</li><li>子空间的引入使维数和重数可以不一样。</li><li><strong>维数不可能大于重数</strong>，而当维数小于重数时就说明这是一个子空间。</li></ul></li><li><strong>正交与对偶空间</strong><ul><li>若两个矢量点积为<span class="math inline">0</span>，即<span class="math inline"><em>v</em><sub>1</sub> ⋅ <em>v</em><sub>2</sub> = 0</span>，则称<span class="math inline"><em>v</em><sub>1</sub></span>和<span class="math inline"><em>v</em><sub>2</sub></span><strong>矢量正交</strong>。</li><li>若某矢量空间中的任意元素与另一矢量空间中的任意元素正交，则称这两个<strong>矢量空间正交</strong>。<ul><li>若两个矢量空间的基底正交，则这两个矢量空间一定正交。</li></ul></li><li>正交的两个子空间<span class="math inline"><em>V</em><sub>1</sub></span>、<span class="math inline"><em>V</em><sub>2</sub></span>互为<strong>对偶空间</strong>（DualSpace），其中一个空间是另一个空间的<strong>零空间</strong>（nullspace，也称零化空间）。</li></ul></li></ul><h4 id="码空间">码空间</h4><ul><li><strong>码空间</strong><ul><li><img src="image-59.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><ol type="1"><li>码字<span class="math inline"><em>c</em><sub><em>i</em></sub></span>是<span class="math inline"><em>n</em></span>个码元的有序排列，是<span class="math inline"><em>n</em></span>维<span class="math inline"><em>n</em></span>重矢量空间<span class="math inline"><em>V</em><sub><em>n</em></sub></span>的元素之一。</li><li>然而，矢量空间<span class="math inline"><em>V</em><sub><em>n</em></sub></span>的元素不一定是码字。</li><li>将码字<span class="math inline"><em>c</em><sub><em>i</em></sub></span>写作<span class="math inline">(<em>c</em><sub><em>i</em>0</sub>, <em>c</em><sub><em>i</em>1</sub>, ⋯, <em>c</em><sub><em>i</em>(<em>n</em> − 1)</sub>)</span>，将码字的集合写成<span class="math inline"><em>C</em></span>，称为码集。</li><li>码集不一定能构成<span class="math inline"><em>V</em><sub><em>n</em></sub></span>的一个子空间，但对线性分组码而言，码集<span class="math inline"><em>C</em></span>一定是<span class="math inline"><em>V</em><sub><em>n</em></sub></span>的一个子空间。</li></ol></li><li><strong>分组编码的任务</strong><ul><li>通常<span class="math inline"><em>q</em><sup><em>n</em></sup> &gt;  &gt; <em>q</em><sup><em>k</em></sup></span>，分组编码的任务是要在<span class="math inline"><em>n</em></span>维<span class="math inline"><em>n</em></span>重矢量空间的<span class="math inline"><em>q</em><sup><em>n</em></sup></span>种可能组合中选择其中的<span class="math inline"><em>q</em><sup><em>k</em></sup></span>个构成一个码空间，其元素就是许用码的码集。</li><li>因此分组编码的任务就是：<ol type="1"><li>选择一个<span class="math inline"><em>k</em></span>维<span class="math inline"><em>n</em></span>重子空间作为码空间。</li><li>确定由<span class="math inline"><em>k</em></span>维<span class="math inline"><em>k</em></span>重信息空间到<span class="math inline"><em>k</em></span>维<span class="math inline"><em>n</em></span>重码空间的映射方法。</li></ol></li><li>码空间的不同选择方法，以及信息组与码组的不同映射算法，就构成了不同的分组码。</li></ul></li></ul><h3 id="译码方法">译码方法</h3><ul><li><p><strong>译码的任务</strong></p><ul><li>译码器的任务是从受损的信息序列中尽可能正确地恢复出原信息。</li><li>译码算法的已知条件是：<ul><li>实际接收到的码字序列<span class="math inline">{<em>r</em>}</span>，<span class="math inline"><em>r</em> = (<em>r</em><sub>1</sub>, <em>r</em><sub>2</sub>, ⋯, <em>r</em><sub><em>N</em></sub>)</span>。</li><li>发端所采用的编码算法和该算法产生的码集<span class="math inline"><em>X</em><sup><em>N</em></sup></span>，满足<span class="math inline"><em>c</em><sub><em>i</em></sub> = (<em>c</em><sub><em>i</em>1</sub>, <em>c</em><sub><em>i</em>2</sub>, ⋯, <em>c</em><sub><em>i</em><em>N</em></sub>) ∈ <em>X</em><sup><em>N</em></sup></span>。</li><li>信道模型及信道参数。</li></ul></li></ul></li><li><p><strong>信道模型</strong>：<img src="image-60.png" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"></p></li><li><p><strong>译码规则</strong>：见<a href="./Ch6sup_信道编码定理.md/#译码规则">译码规则</a></p></li><li><p><strong><a href="./Ch6sup_信道编码定理.md/#最大后验概率译码">最大后验概率译码</a></strong></p><ul><li><strong>最佳译码</strong>，也叫<strong>最大后验概率译码(MAP)</strong>：<span class="math display"><em>ĉ</em><sub><em>i</em></sub> = arg max<sub>1 ≤ <em>i</em> ≤ <em>M</em></sub><em>P</em>(<em>c</em><sub><em>i</em></sub>|<em>r</em>)</span></li></ul></li><li><p><strong><a href="./Ch6sup_信道编码定理.md/#最大联合概率译码">最大联合概率译码</a></strong><span class="math display">$$P(c_i/r)=\frac{P(c_i)P(r/c_i)}{P(r)}\quad i= 1, 2, \cdots, 2^K$$</span></p><ul><li><span class="math inline"><em>P</em>(<em>c</em><sub><em>i</em></sub>/<em>r</em>)</span>最大等效于<span class="math inline"><em>P</em>(<em>c</em><sub><em>i</em></sub>)<em>P</em>(<em>r</em>/<em>c</em><sub><em>i</em></sub>)</span>最大。</li><li><strong>最大联合概率译码</strong>：<span class="math display"><em>ĉ</em><sub><em>i</em></sub> = arg max<sub>1 ≤ <em>i</em> ≤ <em>M</em></sub><em>P</em>(<em>c</em><sub><em>i</em></sub>)<em>P</em>(<em>r</em>|<em>c</em><sub><em>i</em></sub>)</span></li></ul></li><li><p><strong><a href="./Ch6sup_信道编码定理.md/#最大似然译码">最大似然译码</a></strong></p><ul><li>如果 构成码集的<span class="math inline">2<sup><em>K</em></sup></span>个码字以相同概率发送，满足<span class="math inline"><em>P</em>(<em>c</em><sub><em>i</em></sub>) = 1/2<sup><em>K</em></sup></span>，<span class="math inline"><em>i</em> = 1, 2, ⋯, 2<sup><em>K</em></sup></span>，在此前提下最佳译码等效于如下最大似然译码。</li><li><strong>最大似然译码</strong>(MLD)：码字等概率发送时：<span class="math display"><em>ĉ</em><sub><em>i</em></sub> = arg max<sub>1 ≤ <em>i</em> ≤ <em>M</em></sub><em>P</em>(<em>r</em>|<em>c</em><sub><em>i</em></sub>)</span></li></ul></li><li><p><strong><a href="./Ch6sup_信道编码定理.md/#最小汉明距离译码">最小汉明距离译码</a></strong></p><ul><li><p>对于无记忆信道：<span class="math display">$$\max P(r/c_i)=\max\prod_{j = 1}^{N}P(r_j/c_{ij})$$</span></p></li><li><p>对BSC信道： <span class="math display">$$P(r_j|c_{ij}) =  \begin{cases}  p, &amp; c_{ij} \neq r_j \\  1 - p, &amp; c_{ij} = r_j  \end{cases}$$</span></p><p><span class="math display">$$P(r|c_i)=\prod_{j = 1}^{N}P(r_j|c_{ij})= p^d(1 - p)^{N - d}=(\frac{p}{1 - p})^d(1 - p)^N$$</span> 其中<span class="math inline"><em>d</em></span>为<span class="math inline"><em>r</em></span>与<span class="math inline"><em>c</em><sub><em>i</em></sub></span>的汉明距离，可见，<strong><span class="math inline"><em>d</em></span>越小，<span class="math inline"><em>P</em>(<em>r</em>|<em>c</em><sub><em>i</em></sub>)</span>越大</strong>。</p></li><li><p>BSC信道的最大似然译码可以简化为最小汉明距离译码。 <span class="math display"><em>ĉ</em><sub><em>i</em></sub> = arg min<sub>1 ≤ <em>i</em> ≤ <em>M</em></sub><em>d</em>(<em>r</em>, <em>c</em><sub><em>i</em></sub>)</span></p><ul><li>只要在接收端将收码<span class="math inline"><em>r</em></span>与发码<span class="math inline"><em>c</em><sub><em>i</em></sub></span>的各码元逐一比较，选择其中汉明距离最小的码字作为译码估值<span class="math inline"><em>ĉ</em><sub><em>i</em></sub></span>。</li><li>由于BSC信道是对称的，只要发送的码字独立、等概，汉明距离译码也就是最佳译码。</li></ul></li></ul></li></ul><h3 id="信道编码定理">信道编码定理</h3><ul><li>信道编码定理研究的问题：<img src="image-61.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h4 id="随机编码">随机编码</h4><ul><li>所有可能的编码：平均错误概率<span class="math inline">$\overline{P}_e$</span><ul><li>若<span class="math inline">$\overline{P}_e \to0$</span>，必存在一种编码<span class="math inline"><em>P</em><sub><em>e</em></sub> → 0</span> 。</li><li>用这种方法不能得知最优码是如何具体编出来的；却能得知最优码可以好到什么程度，并进而推导出有扰离散信道的编码定理，对指导编码技术具有特别重要的理论价值。</li></ul></li><li>在<span class="math inline">(<em>N</em>, <em>K</em>)</span>分组编码器中随机选定的码集有<span class="math inline"><em>q</em><sup><em>N</em><em>M</em></sup></span>种。第<span class="math inline"><em>m</em></span>个码集(记作<span class="math inline">{<em>c</em>}<sub><em>m</em></sub></span>)被随机选中的概率是<span class="math display"><em>P</em>({<em>c</em>}<sub><em>m</em></sub>) = <em>q</em><sup>−(<em>N</em><em>M</em>)</sup></span><ul><li>设与这种选择相对应的条件差错概率是<span class="math inline"><em>P</em><sub><em>e</em></sub>({<em>c</em>}<sub><em>m</em></sub>)</span>。</li><li>全部码集的平均差错概率是<span class="math display">$$\overline{P}_e= \sum_{m = 1}^{q^{NM}} P(\{c\}_m)P_e(\{c\}_m)=q^{-NM}\sum_{m =1}^{q^{NM}} P_e(\{c\}_m)$$</span></li><li>必定存在某些码集<span class="math inline">$P_e(\{c\}_m)&gt;\overline{P}_e$</span>，某些码集<span class="math inline">$P_e(\{c\}_m)&lt;\overline{P}_e$</span> 。</li><li>若<span class="math inline">$\overline{P}_e \to0$</span>，就必然存在一批码集<span class="math inline"><em>P</em><sub><em>e</em></sub>({<em>c</em>}<sub><em>m</em></sub>) → 0</span>，即差错概率趋于零的好码一定存在。</li></ul></li><li>码集点数<span class="math inline"><em>M</em> = <em>q</em><sup><em>K</em></sup></span>占<span class="math inline"><em>N</em></span>维矢量空间总点数<span class="math inline"><em>q</em><sup><em>N</em></sup></span>的比例是<span class="math inline"><em>F</em> = <em>q</em><sup><em>K</em></sup>/<em>q</em><sup><em>N</em></sup> = <em>q</em><sup>−(<em>N</em> − <em>K</em>)</sup></span><ul><li>当<span class="math inline"><em>K</em></span>和<span class="math inline"><em>N</em></span>的差值拉大即冗余的空间点数增加时，平均而言码字的分布将变得稀疏，码字间的平均距离将变大，平均差错概率将变小。</li><li>当<span class="math inline"><em>F</em> → 0</span>即<span class="math inline">(<em>N</em> − <em>K</em>) → ∞</span>时，能否让平均差错概率<span class="math inline">$\overline{P}_e \to 0$</span> ？<ul><li>Gallager在1965年推导了<span class="math inline">$\overline{P}_e$</span>的上边界，并证明这个上边界是按指数规律收敛的。</li></ul></li></ul></li></ul><h4 id="信道编码定理-1">信道编码定理</h4><ul><li><span class="math inline">$\overline{P}_e &lt; e^{-NE(R)}$</span><ul><li><span class="math inline"><em>E</em>(<em>R</em>)</span>为可靠性函数，也叫误差指数。</li><li><strong>码率</strong>：<span class="math inline">$R = \frac{\logM}{N}=\frac{\log q^K}{N}$</span> 。</li><li><span class="math inline"><em>M</em></span>是可能的信息组合数，<span class="math inline"><em>M</em> = <em>q</em><sup><em>K</em></sup></span>；<span class="math inline"><em>N</em></span>是每码字的码元数；<span class="math inline"><em>R</em></span>表示每码元携带的信息量（bit/码元）。</li></ul></li><li><span class="math inline"><em>E</em>(<em>R</em>)</span>可靠性函数<ul><li><span class="math inline"><em>R</em></span>在<span class="math inline">[0, <em>R</em><sub>0</sub>]</span>区间时，<span class="math inline"><em>E</em>(<em>R</em>) − <em>R</em></span>曲线是斜率为<span class="math inline">−1</span>（<span class="math inline">−45<sup>∘</sup></span>）的直线，<span class="math inline"><em>E</em>(<em>R</em>)</span>反比于<span class="math inline"><em>R</em></span></li><li><span class="math inline"><em>R</em><sub>0</sub> &lt; <em>C</em></span>，临界速率</li><li>而当<span class="math inline"><em>R</em> = <em>C</em></span>时<span class="math inline"><em>E</em>(<em>R</em>) = 0</span>即可靠性为零。</li><li><img src="image-62.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>噪声信道的信道编码定理</strong><ul><li><strong><a href="./Ch6sup_信道编码定理.md#信道编码正定理">正定理</a></strong>：只要传输率<span class="math inline"><em>R</em></span> 小于信道容量 <span class="math inline"><em>C</em></span>，总存在一种信道码（及解码器），在码长 <span class="math inline"><em>N</em></span>足够长的情况下，能够以所要求的任意小的差错概率实现可靠的通信。</li><li><strong><a href="./Ch6sup_信道编码定理.md#信道编码逆定理">逆定理</a></strong>：信道容量<span class="math inline"><em>C</em></span> 是可靠通信系统传输率 <span class="math inline"><em>R</em></span> 的上边界，如果 <span class="math inline"><em>R</em> &gt; <em>C</em></span>，就不可能有任何一种编码能使差错概率任意小。</li></ul></li></ul><h4 id="联合信源信道编码定理">联合信源信道编码定理</h4><ul><li><strong>两步编码处理方法</strong>：<ul><li><strong>信源编码</strong>：针对各自信源的不同特点，进行不同的数据压缩，用最有效的二元码来表达这些不同的信源。</li><li><strong>信道编码</strong>：对于共同传输的数字信道而言，输入端只看成是一系列二元码。信道编码只针对信道特性来进行，不考虑不同信源的不同特性。</li><li>信源压缩编码只考虑信源的统计特性；信道编码只考虑信道的统计特性。</li></ul></li><li><strong>特点</strong>：<ul><li><strong>优点</strong>：设计简单、通用性好，可以分别形成标准。</li><li><strong>缺点</strong>：没有充分利用各自的优势，因而不是最佳的。</li></ul></li><li><strong>信源－信道编码定理内容</strong>：<ul><li>若信源 <span class="math inline"><em>S</em></span> 极限熵 <span class="math inline"><em>H</em><sub>∞</sub></span> 小于信道容量 <span class="math inline"><em>C</em></span> ，则存在信源信道编码，使得 <span class="math inline"><em>P</em><sub><em>e</em></sub> → 0</span></li><li>反之，对于任意平稳随机序列，若极限熵 <span class="math inline"><em>H</em><sub>∞</sub> &gt; <em>C</em></span>，则错误概率远离零，即不可能在信道中以任意小的错误概率发送这随机序列</li></ul></li><li><strong>总结</strong>：<ul><li>当且仅当信源极限熵小于信道容量，在信道上能够无错误地传输平稳遍历信源。<strong><span class="math inline"><em>H</em> &lt; <em>C</em></span>是信源通过信道有效和可靠传输的充要条件</strong>。</li><li>如果信道的容量 <span class="math inline"><em>C</em> &gt; <em>R</em>(<em>D</em>)</span>，则在信源和信道处用足够复杂的处理后，总能以失真度 <span class="math inline"><em>D</em> + <em>ε</em></span> 再现信源的消息。</li></ul></li></ul><h3 id="纠错编码的基本思路">纠错编码的基本思路</h3><ul><li><strong>思路一</strong>：<span class="math display">$$\overline{P}_e&lt; e^{-NE(R)}$$</span><ul><li><img src="image-63.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong><span class="math inline"><em>R</em></span>不变</strong>，信道容量大者其可靠性函数<span class="math inline"><em>E</em>(<em>R</em>)</span>也大<ul><li><strong>增大信道容量<span class="math inline"><em>C</em></span>的方法</strong>：<ul><li>扩展带宽。</li><li>加大功率。</li><li>降低噪声。</li></ul></li></ul></li><li><strong><span class="math inline"><em>C</em></span>不变</strong>，码率减小时其可靠性函数<span class="math inline"><em>E</em>(<em>R</em>)</span>增大<ul><li><strong>减小码率<span class="math inline"><em>R</em></span>的方法</strong>：<ul><li><span class="math inline"><em>Q</em></span>、<span class="math inline"><em>N</em></span>不变而减小<span class="math inline"><em>K</em></span>。</li><li><span class="math inline"><em>Q</em></span>、<span class="math inline"><em>K</em></span>不变而增大<span class="math inline"><em>N</em></span>。</li><li><span class="math inline"><em>N</em></span>、<span class="math inline"><em>K</em></span>不变而减小<span class="math inline"><em>Q</em></span>。</li></ul></li></ul></li><li><strong>增大码长<span class="math inline"><em>N</em></span></strong></li></ul></li><li><strong>思路二：纠错能力的获取途径</strong>：<ul><li><strong>利用冗余度</strong>：时间、频带、功率、设备复杂度。</li><li><strong>噪声均化(随机化、概率化)</strong>：增加码长、卷积、交错。</li></ul></li></ul><h2 id="线性分组码">6.3 线性分组码</h2><p><img src="image-64.png" srcset="/img/loading/loading3.gif" lazyload></p><ul><li>构造一个<span class="math inline"><em>k</em></span>维<span class="math inline"><em>n</em></span>重子空间（码空间），使<span class="math inline"><em>q</em><sup><em>k</em></sup></span>个信息元组一一对应映射到码空间。</li><li><strong>码率(编码效率)</strong>：<span class="math inline"><em>R</em><sub><em>c</em></sub> = <em>k</em>/<em>n</em></span></li></ul><h3 id="线性分组码的形成">线性分组码的形成</h3><h4 id="基本概念">基本概念</h4><ul><li><strong>码空间</strong><ul><li><strong>码空间</strong>：所有元素（即码字）都可以写成<span class="math inline"><em>k</em></span>个基底的线性组合，表达式为<span class="math display"><strong>c</strong> = <em>m</em><sub><em>k</em> − 1</sub><strong>g</strong><sub><em>k</em> − 1</sub> + ⋯ + <em>m</em><sub>1</sub><strong>g</strong><sub>1</sub> + <em>m</em><sub>0</sub><strong>g</strong><sub>0</sub></span></li><li><span class="math inline"><strong>m</strong> = (<em>m</em><sub><em>k</em> − 1</sub>, ⋯, <em>m</em><sub>1</sub>, <em>m</em><sub>0</sub>)</span>是<span class="math inline"><em>k</em></span>维<span class="math inline"><em>k</em></span>重信息组</li><li><span class="math inline"><strong>c</strong> = (<em>c</em><sub><em>n</em> − 1</sub>, ⋯, <em>c</em><sub>1</sub>, <em>c</em><sub>0</sub>)</span>是码字。</li><li><span class="math inline"><strong>g</strong> = (<strong>g</strong><sub><em>k</em> − 1</sub>, ⋯, <strong>g</strong><sub>1</sub>, <strong>g</strong><sub>0</sub>)</span>是在<span class="math inline"><em>n</em></span>维<span class="math inline"><em>n</em></span>重空间<span class="math inline"><em>V</em></span>中，从<span class="math inline"><em>n</em></span>个基底中选取出来的<span class="math inline"><em>k</em></span>个矢量作为码空间的<strong>基底</strong></li><li><img src="image-65.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>映射规律</strong>：信息元作为基底线性组合的系数。</li><li><strong>生成矩阵</strong>：<ul><li><strong>生成矩阵</strong><span class="math inline">$\mathbf{G}_{k\times n}=\begin{bmatrix}\mathbf{g}_{k-1}\\\vdots\\\mathbf{g}_{1}\\\mathbf{g}_{0}\end{bmatrix}=\begin{bmatrix}g_{(k- 1)(n - 1)}&amp;\cdots&amp;g_{(k - 1)1}&amp;g_{(k -1)0}\\\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\g_{1(n -1)}&amp;\cdots&amp;g_{11}&amp;g_{10}\\g_{0(n -1)}&amp;\cdots&amp;g_{01}&amp;g_{00}\end{bmatrix}$</span></li><li>码字<span class="math inline"><strong>c</strong></span>、消息<span class="math inline"><strong>m</strong></span>与生成矩阵<span class="math inline"><strong>G</strong></span>的关系为：<span class="math display"><strong>c</strong><sub><strong>1</strong> <strong>×</strong> <strong>n</strong></sub> = <strong>m</strong><sub><strong>1</strong> <strong>×</strong> <strong>k</strong></sub><strong>G</strong><sub><strong>k</strong> <strong>×</strong> <strong>n</strong></sub></span><ul><li>其中<span class="math inline"><strong>c</strong><sub><strong>1</strong> <strong>×</strong> <strong>n</strong></sub></span>是<span class="math inline"><em>n</em></span>维码字，<span class="math inline"><strong>m</strong><sub><strong>1</strong> <strong>×</strong> <strong>k</strong></sub></span>是<span class="math inline"><em>k</em></span>维信息组，<span class="math inline"><strong>G</strong><sub><strong>k</strong> <strong>×</strong> <strong>n</strong></sub></span>是<span class="math inline"><em>k</em> × <em>n</em></span>生成矩阵。</li><li>因为<span class="math inline"><em>k</em></span>个基底即<span class="math inline"><strong>G</strong></span>的<span class="math inline"><em>k</em></span>个行矢量线性无关，矩阵<span class="math inline"><strong>G</strong></span>的秩一定等于<span class="math inline"><em>k</em></span>。</li><li>当信息元确定后，码字仅由<span class="math inline"><strong>G</strong></span>矩阵决定，所以称这<span class="math inline"><em>k</em> × <em>n</em></span>矩阵<span class="math inline"><strong>G</strong></span>为该<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码的生成矩阵。</li></ul></li><li><strong>特点</strong>:<ul><li>想要保证<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码能够构成<span class="math inline"><em>k</em></span>维<span class="math inline"><em>n</em></span>重子空间，<span class="math inline"><em>G</em></span>的<span class="math inline"><em>k</em></span>个行矢量<span class="math inline"><em>g</em><sub><em>k</em> − 1</sub>, ⋯, <em>g</em><sub>1</sub>, <em>g</em><sub>0</sub></span>必须是线性无关的，只有这样才符合作为基底的条件。</li><li>由于基底不是唯一的，所以<span class="math inline"><em>G</em></span>也就不是唯一的。</li><li>不同的基底有可能生成同一码集，但因编码涉及码集和映射两个因素，码集一样而映射方法不同也不能说是同样的码。</li></ul></li></ul></li><li><strong>基底的选择</strong>：构造<span class="math inline">(3, 2)</span>线性分组码示例<ul><li><img src="image-66.png" srcset="/img/loading/loading3.gif" lazyload></li><li>需要构造<span class="math inline">2</span>维<span class="math inline">3</span>重码空间。</li><li><span class="math inline">3</span>维<span class="math inline">3</span>重空间的<span class="math inline">3</span>个自然基底为<span class="math inline">100</span>，<span class="math inline">010</span>，<span class="math inline">001</span>。</li><li>选择其中<span class="math inline">2</span>个基底<span class="math inline">010</span>，<span class="math inline">001</span>构成码空间，对应码集为<span class="math inline">(000, 010, 001, 011)</span></li><li><span class="math inline">2</span>个基底的线性组合<span class="math inline">010</span>，<span class="math inline">011</span>也可以张成码空间 ，对应码集为<span class="math inline">(000, 010, 011, 001)</span> 。</li><li>码集一样，对应关系不一样</li></ul></li><li><strong>示例</strong>：<ul><li>对于<span class="math inline">(6, 3)</span>线性分组码，<span class="math inline"><em>k</em> = 3</span>，<span class="math inline">2<sup><em>k</em></sup> = 8</span>（消息数量）<ul><li>基底<span class="math inline"><strong>g</strong><sub>2</sub> = 111010</span>，<span class="math inline"><strong>g</strong><sub>1</sub> = 110001</span>，<span class="math inline"><strong>g</strong><sub>0</sub> = 011101</span>。</li><li>则<span class="math inline">$\mathbf{G}=\begin{bmatrix}\mathbf{g}_{2}\\\mathbf{g}_{1}\\\mathbf{g}_{0}\end{bmatrix}=\begin{bmatrix}111010\\110001\\011101\end{bmatrix}$</span>。 $$</li><li><table><thead><tr><th>信息<span class="math inline"><strong>u</strong> = <em>m</em><sub>2</sub><em>m</em><sub>1</sub><em>m</em><sub>0</sub></span></th><th>码字<span class="math inline"><strong>c</strong> = <em>c</em><sub>5</sub><em>c</em><sub>4</sub><em>c</em><sub>3</sub><em>c</em><sub>2</sub><em>c</em><sub>1</sub><em>c</em><sub>0</sub></span></th></tr></thead><tbody><tr><td>000</td><td>000000</td></tr><tr><td>001</td><td>011101</td></tr><tr><td>010</td><td>110001</td></tr><tr><td>011</td><td>101100</td></tr><tr><td>100</td><td>111010</td></tr><tr><td>101</td><td>100111</td></tr><tr><td>110</td><td>001011</td></tr><tr><td>111</td><td>010110</td></tr></tbody></table></li></ul></li></ul></li></ul><h4 id="系统形式的生成矩阵与校验矩阵">系统形式的生成矩阵与校验矩阵</h4><ul><li><strong>系统形式的生成矩阵</strong><ul><li><p><span class="math inline">(<em>n</em>, <em>k</em>)</span>码的任何生成矩阵都可以通过行运算（以及列置换）简化成“系统形式”<span class="math display">$$\mathbf{G_S} = [I_k |P]=\begin{bmatrix}1&amp;0&amp;\cdots&amp;0&amp;p_{(k - 1)(n - k -1)}&amp;\cdots&amp;p_{(k - 1)1}&amp;p_{(k -1)0}\\0&amp;1&amp;\vdots&amp;0&amp;p_{(k - 2)(n - k -1)}&amp;\cdots&amp;p_{(k - 2)1}&amp;p_{(k -2)0}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;1&amp;p_{0(n- k - 1)}&amp;\cdots&amp;p_{01}&amp;p_{00}\end{bmatrix}$$</span></p><p>其中<span class="math inline"><em>I</em><sub><em>k</em></sub></span>是<span class="math inline"><em>k</em> × <em>k</em></span>单位矩阵，<span class="math inline"><em>P</em></span>是<span class="math inline"><em>k</em> × (<em>n</em> − <em>k</em>)</span>矩阵。</p></li></ul></li><li><strong>系统码</strong><ul><li><strong>码字结构</strong>：码字<span class="math inline"><em>c</em></span>包含信息位（<span class="math inline"><em>k</em></span>位）和校验位（<span class="math inline"><em>n</em> − <em>k</em></span>位）<img src="image-67.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>特点</strong>：<ul><li>前<span class="math inline"><em>k</em></span>位由单位矩阵<span class="math inline"><em>I</em><sub><em>k</em></sub></span>决定，等于把信息组<span class="math inline"><em>m</em></span>原封不动搬到码字的前<span class="math inline"><em>k</em></span>位</li><li>其余的<span class="math inline"><em>n</em> − <em>k</em></span>位叫<strong>冗余位</strong>或<strong>一致校验位</strong>，是前<span class="math inline"><em>k</em></span>个信息位的线性组合。</li></ul></li><li><strong>定义</strong>：具备以上系统形式的<span class="math inline">(<em>n</em>, <em>k</em>)</span>码叫做<strong>系统码</strong>。若生成矩阵<span class="math inline"><em>G</em></span>不具备系统形式，则生成的码叫做非系统码。</li><li>系统化不改变码集，只是改变了映射规则。</li><li><strong>性质</strong>：<ul><li><strong>等效矩阵</strong>：若通过行运算和列置换能将两个生成矩阵<span class="math inline"><em>G</em></span>互等，则称这两个<span class="math inline"><em>G</em></span>等效。</li><li><strong>形式转换</strong>：非系统码的<span class="math inline"><em>G</em></span>可通过运算转变为系统码的<span class="math inline"><em>G</em></span>。</li><li><strong>等效码</strong>：等效的两个<span class="math inline"><em>G</em></span>生成的两个<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码也是等效的。</li><li>因此，<strong>每个<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码都可以和一个系统的<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码等效</strong></li></ul></li></ul></li><li><strong>线性分组码空间构成</strong><ul><li><span class="math inline"><em>n</em></span>维<span class="math inline"><em>n</em></span>重空间<span class="math inline"><em>V</em><sub><em>n</em></sub></span>有相互正交的<span class="math inline"><em>n</em></span>个基底。</li><li>选择<span class="math inline"><em>k</em></span>个基底构成码空间<span class="math inline"><em>G</em></span> 。</li><li>选择另外的<span class="math inline">(<em>n</em> − <em>k</em>)</span>个基底构成空间<span class="math inline"><em>H</em></span> 。</li><li><span class="math inline"><em>G</em></span>和<span class="math inline"><em>H</em></span>是对偶的，满足<span class="math inline"><em>G</em><em>H</em><sup><em>T</em></sup> = 0</span>，<span class="math inline"><em>H</em><em>G</em><sup><em>T</em></sup> = 0</span>。</li><li><img src="image-70.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>码空间与对偶空间</strong><ul><li>将<span class="math inline"><em>H</em></span>空间的<span class="math inline"><em>n</em> − <em>k</em></span>个基底排列起来可构成一个<span class="math inline">(<em>n</em> − <em>k</em>) × <em>n</em></span>矩阵，称为<strong>校验矩阵<span class="math inline"><em>H</em></span></strong>，用于校验接收到的码字是否正确。</li><li><span class="math inline"><em>G</em></span>是<span class="math inline">(<em>n</em>, <em>k</em>)</span>码的生成矩阵，<span class="math inline"><em>H</em></span>是其校验矩阵。</li><li><span class="math inline"><em>H</em></span>是<span class="math inline">(<em>n</em>, <em>n</em> − <em>k</em>)</span>对偶码的生成矩阵，它的每一行是一个基底，<span class="math inline"><em>G</em></span>则是其校验矩阵。</li><li>满足<span class="math inline"><em>G</em><em>H</em><sup><em>T</em></sup> = 0</span>，且<span class="math inline"><em>H</em> = [−<em>P</em><sup><em>T</em></sup>|<em>I</em><sub><em>n</em> − <em>k</em></sub>]</span>，在二进制情况下，负号可省略。</li></ul></li><li><strong>生成矩阵与校验矩阵的关系</strong><ul><li>对于任何一个码字<span class="math inline"><strong>c</strong></span>，有<span class="math display"><strong>c</strong><sub>1 × <em>n</em></sub><strong>H</strong><sub><em>n</em> × (<em>n</em> − <em>k</em>)</sub><sup><em>T</em></sup> = <strong>0</strong><sub>1 × (<em>n</em> − <em>k</em>)</sub></span></li><li>因为生成矩阵的每个行矢量是一个码字，所以必有<span class="math display"><strong>G</strong><sub><em>k</em> × <em>n</em></sub><strong>H</strong><sup><strong>T</strong></sup><sub><em>n</em> × (<em>n</em> − <em>k</em>)</sub> = <strong>0</strong><sub><em>k</em> × (<em>n</em> − <em>k</em>)</sub></span></li><li>对于系统码的生成矩阵<span class="math inline"><strong>G</strong><sub><strong>S</strong></sub><sub><em>k</em> × <em>n</em></sub> = [<strong>I</strong><sub><em>k</em></sub>|<strong>P</strong><sub><em>k</em> × (<em>n</em> − <em>k</em>)</sub>]</span>，有：<span class="math display">$$  \begin{align*}  \mathbf{G_S}_{k\times n}[-\mathbf{P}_{(n - k)\times k}^T |\mathbf{I}_{n - k}]^T&amp;=[\mathbf{I}_k | \mathbf{P}_{k\times(n -k)}][-\mathbf{P}_{(n - k)\times k}^T | \mathbf{I}_{n - k}]^T\\  &amp;=[-\mathbf{I}_k\mathbf{P}_{k\times(n -k)}]+[\mathbf{P}_{k\times(n - k)}\mathbf{I}_{n - k}]\\  &amp;=[-\mathbf{P}]+[\mathbf{P}]\\  &amp;=\mathbf{0}_{k\times(n - k)}  \end{align*}  $$</span></li><li>由此可得<span class="math inline"><strong>H</strong> = [−<strong>P</strong><sup><em>T</em></sup>|<strong>I</strong><sub><em>n</em> − <em>k</em></sub>] = [<strong>P</strong><sup><em>T</em></sup>|<strong>I</strong><sub><em>n</em> − <em>k</em></sub>]</span>，二进制码省略负号</li></ul></li><li><strong>示例</strong>：<ul><li>同上例：<span class="math inline">$G =\begin{bmatrix}111010&amp;①\\110001&amp;②\\011101&amp;③\end{bmatrix}\RightarrowG_s = \begin{bmatrix}100111&amp;① + ③\\010110&amp;① + ②+ ③\\001011&amp;①+ ②\end{bmatrix}$</span></li><li><table><thead><tr><th>信息</th><th>码字</th><th>系统码字</th></tr></thead><tbody><tr><td>000</td><td>000000</td><td><strong>000000</strong></td></tr><tr><td>001</td><td>011101</td><td><strong>001011</strong></td></tr><tr><td>010</td><td>110001</td><td><strong>010110</strong></td></tr><tr><td>011</td><td>101100</td><td><strong>011101</strong></td></tr><tr><td>100</td><td>111010</td><td><strong>100111</strong></td></tr><tr><td>101</td><td>100111</td><td><strong>101100</strong></td></tr><tr><td>110</td><td>001011</td><td><strong>110001</strong></td></tr><tr><td>111</td><td>010110</td><td><strong>111010</strong></td></tr></tbody></table></li><li><strong>一致校验位</strong> <img src="image-68.png" srcset="/img/loading/loading3.gif" lazyload><ul><li><p><span class="math display">$$\mathbf{c} =(c_5c_4c_3c_2c_1c_0)=(m_2m_1m_0)G_S=(m_2m_1m_0)\begin{bmatrix}100111\\010110\\001011\end{bmatrix}$$</span></p><p>可得： <span class="math display">$$  \begin{cases}  c_5 = m_2\\  c_4 = m_1\\  c_3 = m_0  \end{cases}  $$</span> 因此，校验位可按下面方程组计算：</p><p><span class="math display">$$  \begin{cases}  c_2 = m_2 + m_1 = c_5 + c_4\\  c_1 = m_2 + m_1 + m_0 = c_5 + c_4 + c_3\\  c_0 = m_2 + m_0 = c_5 + c_3  \end{cases}  $$</span></p><p>由于校验位和信息元之间是线性运算关系，所以叫<strong>线性分组码</strong>。</p></li><li><p>编码器<img src="image-69.png" srcset="/img/loading/loading3.gif" lazyload></p></li></ul></li><li><strong>校验矩阵</strong><ul><li>由<span class="math display">$$  \begin{cases}  c_2 = c_5 + c_4\\  c_1 = c_5 + c_4 + c_3\\  c_0 = c_5 + c_3  \end{cases}  $$</span>在模2加法下可转化为<span class="math display">$$  \begin{cases}  c_5 + c_4 + 0 + c_2 + 0 + 0 = 0\\  c_5 + c_4 + c_3 + 0 + c_1 + 0 = 0\\  c_5 + 0 + c_3 + 0 + 0 + c_0 = 0  \end{cases}  $$</span></li><li>令<span class="math inline"><strong>c</strong><sub>1 × <em>n</em></sub> = (<em>c</em><sub>5</sub><em>c</em><sub>4</sub><em>c</em><sub>3</sub><em>c</em><sub>2</sub><em>c</em><sub>1</sub><em>c</em><sub>0</sub>)</span>，<span class="math inline"><strong>0</strong><sub>1 × (<em>n</em> − <em>k</em>)</sub> = (000)</span>，有<span class="math inline">$(c_5c_4c_3c_2c_1c_0)\begin{bmatrix}111\\110\\011\\100\\010\\001\end{bmatrix}=[000]$</span>，校验矩阵<span class="math inline">$\mathbf{H} =\begin{bmatrix}110100\\111010\\101001\end{bmatrix}_{(n - k)\timesn}$</span></li><li>满足<span class="math inline"><strong>c</strong><sub>1 × <em>n</em></sub><strong>H</strong><sub><em>n</em> × (<em>n</em> − <em>k</em>)</sub><sup><em>T</em></sup> = <strong>0</strong><sub>1 × (<em>n</em> − <em>k</em>)</sub></span>，<span class="math inline"><strong>H</strong></span>为校验矩阵，<strong>上式用来验证一个<span class="math inline"><em>n</em></span>重矢量是否为码字</strong>。</li></ul></li><li><strong>综上</strong>：对于<span class="math inline">(6, 3)</span>线性分组码，其中<span class="math inline"><em>k</em> = 3</span>，<span class="math inline">2<sup><em>k</em></sup> = 8</span>（消息数量） ：<ul><li>原始生成矩阵<span class="math inline">$G =\begin{bmatrix}111010\\110001\\011101\end{bmatrix}$</span></li><li>系统形式的生成矩阵<span class="math inline">$G_s =\begin{bmatrix}100111\\010110\\001011\end{bmatrix} = [I_{k} |P]$</span></li><li>校验矩阵<span class="math inline">$H = [P^T | I_{n - k}] =\begin{bmatrix}110100\\111010\\101001\end{bmatrix}$</span></li></ul></li></ul></li></ul><h3 id="伴随式与标准阵列译码">伴随式与标准阵列译码</h3><h4 id="基本概念-1">基本概念</h4><ul><li><img src="image-71.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>定义差错图案<span class="math inline"><em>E</em></span></strong> <span class="math display"><strong>E</strong> = (<em>e</em><sub><em>n</em> − 1</sub>, ⋯, <em>e</em><sub>1</sub>, <em>e</em><sub>0</sub>) = <strong>R</strong> − <strong>C</strong> = (<em>r</em><sub><em>n</em> − 1</sub> − <em>c</em><sub><em>n</em> − 1</sub>, ⋯, <em>r</em><sub>1</sub> − <em>c</em><sub>1</sub>, <em>r</em><sub>0</sub> − <em>c</em><sub>0</sub>)</span><ul><li>在二进制码中，模2加与模2减等同，因此有<span class="math display"><strong>E</strong> = <strong>R</strong> + <strong>C</strong>  <strong>R</strong> = <strong>C</strong> + <strong>E</strong></span></li></ul></li><li><strong>定义伴随式<span class="math inline"><em>S</em></span></strong> <span class="math display"><strong>S</strong> = (<em>s</em><sub><em>n</em> − <em>k</em> − 1</sub>, ⋯, <em>s</em><sub>1</sub>, <em>s</em><sub>0</sub>) = <strong>R</strong><strong>H</strong><sup><em>T</em></sup> = <strong>E</strong><strong>H</strong><sup><em>T</em></sup></span><ul><li>因为<span class="math inline"><strong>C</strong><strong>H</strong><sup><em>T</em></sup> = 0</span>，所以<span class="math inline"><strong>R</strong><strong>H</strong><sup><em>T</em></sup> = (<strong>C</strong> + <strong>E</strong>)<strong>H</strong><sup><em>T</em></sup> = <strong>C</strong><strong>H</strong><sup><em>T</em></sup> + <strong>E</strong><strong>H</strong><sup><em>T</em></sup> = <strong>E</strong><strong>H</strong><sup><em>T</em></sup></span><ul><li>若收码无误：则<span class="math inline"><strong>R</strong> = <strong>C</strong></span>即<span class="math inline"><strong>E</strong> = 0</span> ，此时<span class="math inline"><strong>C</strong><strong>H</strong><sup><em>T</em></sup> = <strong>E</strong><strong>H</strong><sup><em>T</em></sup> = <strong>R</strong><strong>H</strong><sup><em>T</em></sup> = 0</span></li><li>若收码有误：即<span class="math inline"><strong>E</strong> ≠ 0</span> ，则<span class="math inline"><strong>R</strong><strong>H</strong><sup><em>T</em></sup> = <strong>E</strong><strong>H</strong><sup><em>T</em></sup> ≠ 0</span></li></ul></li><li>在<span class="math inline"><strong>H</strong><sup><em>T</em></sup></span>固定的前提下，<span class="math inline"><strong>R</strong><strong>H</strong><sup><em>T</em></sup></span>仅与差错图案<span class="math inline"><strong>E</strong></span>有关，而与发送码<span class="math inline"><strong>C</strong></span>无关。</li></ul></li></ul><h4 id="编译码过程">编译码过程</h4><ul><li><strong>编译码过程</strong><ul><li><img src="image-72.png" srcset="/img/loading/loading3.gif" lazyload></li><li>差错图案<span class="math inline"><strong>E</strong></span>是<span class="math inline"><em>n</em></span>重矢量，共有<span class="math inline">2<sup><em>n</em></sup></span>个可能的组合，而伴随式<span class="math inline"><strong>S</strong></span>是<span class="math inline">(<em>n</em> − <em>k</em>)</span>重矢量，只有<span class="math inline">2<sup><em>n</em> − <em>k</em></sup></span>个可能的组合，因此不同的差错图案可能有相同的伴随式。</li></ul></li><li><strong>差错图案E的求解</strong><ul><li><p>可以通过解线性方程求解<span class="math inline"><strong>E</strong></span>： <span class="math display">$$  \begin{align*}  \mathbf{S}&amp;=(s_{n - k -1},\cdots,s_{1},s_{0})=\mathbf{E}\mathbf{H}^T\\  &amp;=(e_{n - 1},\cdots,e_{1},e_{0})\begin{bmatrix}h_{(n - k - 1)(n -1)}&amp;\cdots&amp;h_{(n - k - 1)1}&amp;h_{(n - k -1)0}\\\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\h_{1(n -1)}&amp;\cdots&amp;h_{11}&amp;h_{10}\\h_{0(n -1)}&amp;\cdots&amp;h_{01}&amp;h_{00}\end{bmatrix}^T  \end{align*}  $$</span></p><p>得到线性方程组： <span class="math display">$$  \begin{cases}  s_{n - k - 1}=e_{n - 1}h_{(n - k - 1)(n - 1)}+\cdots+e_{1}h_{(n - k -1)1}+e_{0}h_{(n - k - 1)0}\\  \vdots\\  s_{1}=e_{n - 1}h_{1(n - 1)}+\cdots+e_{1}h_{11}+e_{0}h_{10}\\  s_{0}=e_{n - 1}h_{0(n - 1)}+\cdots+e_{1}h_{01}+e_{0}h_{00}  \end{cases}  $$</span></p><p>上述方程组中有<span class="math inline"><em>n</em></span>个未知数<span class="math inline"><em>e</em><sub><em>n</em> − 1</sub>, ⋯, <em>e</em><sub>1</sub>, <em>e</em><sub>0</sub></span>，却只有<span class="math inline"><em>n</em> − <em>k</em></span>个方程，可知方程组有多解。在有理数或实数域中，少一个方程就可能导致无限多个解，而在二元域中，少一个方程导致两个解，少两个方程四个解，以此类推，少<span class="math inline"><em>n</em> − (<em>n</em> − <em>k</em>) = <em>k</em></span>个方程导致每个未知数有<span class="math inline">2<sup><em>k</em></sup></span>个解。因此，由上述方程组解出的<span class="math inline"><strong>E</strong></span>可以有<span class="math inline">2<sup><em>k</em></sup></span>个解。到底取哪一个作为附加在收码<span class="math inline"><strong>R</strong></span>上的差错图案<span class="math inline"><strong>E</strong></span>的估值呢？<strong>概率译码</strong>：把所有<span class="math inline">2<sup><em>k</em></sup></span>个解的重量(差错图案<span class="math inline"><strong>E</strong></span>中<span class="math inline">1</span>的个数)作比较，选择其中最轻（<span class="math inline">1</span>的个数最少）者作为<span class="math inline"><strong>E</strong></span>的估值。</p></li></ul></li><li><strong>标准阵列译码表</strong>: 列出伴随式对应的所有差错图案<ul><li><p><strong>标准阵列构造方法</strong></p><ol type="1"><li>先将<span class="math inline">2<sup><em>k</em></sup></span>个码字排成一行，作为标准阵列的第一行，并将全<span class="math inline">0</span>码字<span class="math inline"><strong>C</strong><sub>1</sub> = (00…0)</span>放在最左面的位置上。</li><li>然后在剩下的<span class="math inline">(2<sup><em>n</em></sup> − 2<sup><em>k</em></sup>)</span>个<span class="math inline"><em>n</em></span>重中选取一个重量最轻的<span class="math inline"><em>n</em></span>重<span class="math inline"><strong>E</strong><sub>2</sub></span>放在全<span class="math inline">0</span>码字<span class="math inline"><strong>C</strong><sub>1</sub></span>下面，再将<span class="math inline"><strong>E</strong><sub>2</sub></span>分别和码字<span class="math inline"><strong>C</strong><sub>2</sub>, <strong>C</strong><sub>3</sub>, ⋯, <strong>C</strong><sub>2<sup><em>k</em></sup></sub></span>相加，放在对应码字下面构成阵列第二行。</li><li>在第二次剩下的<span class="math inline"><em>n</em></span>重中，选取重量最轻的<span class="math inline"><em>n</em></span>重<span class="math inline"><strong>E</strong><sub>3</sub></span>，放在<span class="math inline"><strong>E</strong><sub>2</sub></span>下面，并将<span class="math inline"><strong>E</strong><sub>3</sub></span>分别加到第一行各码字上，得到第三行。</li><li>继续这样做下去，直到全部<span class="math inline"><em>n</em></span>重用完为止，得到给定<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码的标准阵列。</li></ol><ul><li><strong>在标准阵列的同一行中没有相同的矢量，而且<span class="math inline">2<sup><em>n</em></sup></span>个<span class="math inline"><em>n</em></span>重中任一个<span class="math inline"><em>n</em></span>重在阵列中出现一次且仅出现一次</strong></li></ul></li><li><p>标准阵列译码表：<strong>标准阵列可能不唯一</strong></p><table style="width:100%;"><thead><tr><th></th><th>伴随式</th><th>陪集首</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>子集头</td><td><span class="math inline"><em>S</em><sub>1</sub></span></td><td><span class="math inline"><strong>C</strong><sub>1</sub> = <strong>E</strong><sub>1</sub> = 0</span></td><td><span class="math inline"><strong>C</strong><sub>2</sub></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><strong>C</strong><sub>2<sup><em>k</em></sup></sub></span></td></tr><tr><td></td><td><span class="math inline"><em>S</em><sub>2</sub></span></td><td><span class="math inline"><strong>E</strong><sub>2</sub></span></td><td><span class="math inline"><strong>C</strong><sub>2</sub> + <strong>E</strong><sub>2</sub></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><strong>C</strong><sub>2<sup><em>k</em></sup></sub> + <strong>E</strong><sub>2</sub></span></td></tr><tr><td></td><td><span class="math inline"><em>S</em><sub>3</sub></span></td><td><span class="math inline"><strong>E</strong><sub>3</sub></span></td><td><span class="math inline"><strong>C</strong><sub>2</sub> + <strong>E</strong><sub>3</sub></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><strong>C</strong><sub>2<sup><em>k</em></sup></sub> + <strong>E</strong><sub>3</sub></span></td></tr><tr><td></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td><td><span class="math inline">⋮</span></td></tr><tr><td></td><td><span class="math inline"><em>S</em><sub>2<sup><em>n</em> − <em>k</em></sup></sub></span></td><td><span class="math inline"><strong>E</strong><sub>2<sup><em>n</em> − <em>k</em></sup></sub></span></td><td><span class="math inline"><strong>C</strong><sub>2</sub> + <strong>E</strong><sub>2<sup><em>n</em> − <em>k</em></sup></sub></span></td><td><span class="math inline">⋯</span></td><td><span class="math inline"><strong>C</strong><sub>2<sup><em>k</em></sup></sub> + <strong>E</strong><sub>2<sup><em>n</em> − <em>k</em></sup></sub></span></td></tr></tbody></table></li><li><p><strong>陪集和子集</strong></p><ul><li><strong>陪集</strong>：译码表中有<span class="math inline">2<sup><em>n</em> − <em>k</em></sup></span>行，每行是一个陪集，每陪集的第一个元素(位于第一列)叫<strong>陪集首</strong>。同一陪集（同一行）中的所有元素对应共同的一个伴随式。第一行陪集的陪集首是全零伴随式<span class="math inline"><strong>S</strong><sub>0</sub></span>所对应的全零差错图案<span class="math inline"><strong>E</strong><sub>0</sub></span>(无差错)，而第<span class="math inline"><em>j</em></span>行陪集的陪集首是伴随式<span class="math inline"><strong>S</strong><sub><em>j</em></sub></span>所对应的重量最小的差错图案<span class="math inline"><strong>E</strong><sub><em>j</em></sub></span>(<span class="math inline"><strong>C</strong><sub>0</sub> = 0, <strong>R</strong><sub><em>j</em></sub> = <strong>E</strong><sub><em>j</em></sub></span>)。</li><li><strong>子集</strong>：译码表中有<span class="math inline">2<sup><em>k</em></sup></span>列，每列是一个子集，每子集的第一个元素(位于第一行)叫<strong>子集头</strong>。同一子集（同一列）中的所有元素对应同一个码字，第一列子集的子集头是全零码字<span class="math inline"><strong>C</strong><sub>0</sub></span>，而第<span class="math inline"><em>i</em></span>列子集的子集头是码字<span class="math inline"><strong>C</strong><sub><em>i</em></sub></span>(<span class="math inline"><strong>E</strong><sub>0</sub> = 0, <strong>R</strong><sub><em>i</em></sub> = <strong>C</strong><sub><em>i</em></sub></span>)。</li></ul></li><li><p><strong>检错纠错能力</strong>：根据<span class="math inline"><strong>E</strong></span>在标准阵列中的位置</p><ul><li>第一行：不可检错</li><li>第一列：可检错可纠错</li><li>剩余部分：可检错不可纠错</li></ul></li></ul></li><li><strong>具体译码过程</strong>：<ol type="1"><li>求生成矩阵<span class="math inline"><strong>G</strong></span>和校验矩阵<span class="math inline"><strong>H</strong></span>。</li><li>通过信息组<span class="math inline"><strong>m</strong></span>和生成矩阵<span class="math inline"><strong>G</strong></span>求出各子集头码字<span class="math inline"><strong>C</strong></span>。</li><li>构造标准阵列译码表。</li><li>根据标准阵列译码表，对收到的码字<span class="math inline"><strong>R</strong></span>进行译码。译码方法：<ul><li>直接搜索码表，查得<span class="math inline"><strong>R</strong></span>所在列的子集头<span class="math inline"><strong>C</strong></span>，因此译码输出取为<span class="math inline"><strong>C</strong></span></li><li>先求伴随式 <span class="math inline"><strong>S</strong> = <strong>R</strong><strong>H</strong><sup><strong>T</strong></sup></span>，确定<span class="math inline"><strong>S</strong></span>所在行，再沿着行对码表作一维搜索找到<span class="math inline"><strong>R</strong></span>，最后顺着所在列向上找出码字<span class="math inline"><strong>C</strong></span></li><li>先求出伴随式 <span class="math inline"><strong>S</strong> = <strong>R</strong><strong>H</strong><sup><strong>T</strong></sup></span>并确定 <span class="math inline"><strong>S</strong></span>所对应的陪集首（差错图案）<span class="math inline"><strong>E</strong></span>，再将陪集首与收码相加得到码字<span class="math inline"><strong>C</strong> = <strong>R</strong> + <strong>E</strong></span></li></ul>上述三种方法由上而下，查表的时间下降而所需计算量增大，实际使用时可针对不同情况选用。</li></ol></li><li><strong>示例</strong>： 一个<span class="math inline">(5, 2)</span>系统线性码的生成矩阵是<span class="math inline">$G =\begin{bmatrix}10111\\01101\end{bmatrix}$</span> ，设收码<span class="math inline"><strong>R</strong> = (10101)</span>，构造标准阵列译码表，译出发码的估值。<ul><li><p>求出校验矩阵：<span class="math inline">$H = [P^T |I_3]=\begin{bmatrix}11100\\10010\\11001\end{bmatrix}$</span></p></li><li><p>分别以信息组<span class="math inline"><strong>m</strong> = (00)</span>、<span class="math inline">(01)</span>、<span class="math inline">(10)</span>、<span class="math inline">(11)</span>及已知的<span class="math inline"><em>G</em></span>求得<span class="math inline">4</span>个许用码字为<span class="math inline"><strong>C</strong><sub>0</sub> = (00000)</span>、<span class="math inline"><strong>C</strong><sub>1</sub> = (10111)</span>、<span class="math inline"><strong>C</strong><sub>2</sub> = (01101)</span>、<span class="math inline"><strong>C</strong><sub>3</sub> = (11010)</span></p></li><li><p>构造标准阵列译码表</p><table><thead><tr><th>伴随式</th><th>陪集首</th><th></th><th></th><th></th></tr></thead><tbody><tr><td><span class="math inline"><em>S</em><sub>0</sub> = 000</span></td><td><span class="math inline"><em>E</em><sub>0</sub> + <em>C</em><sub>0</sub> = 00000</span></td><td><span class="math inline"><em>C</em><sub>1</sub> = 10111</span></td><td><span class="math inline"><em>C</em><sub>2</sub> = 01101</span></td><td><span class="math inline"><em>C</em><sub>3</sub> = 11010</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>1</sub> = 111</span></td><td><span class="math inline"><em>E</em><sub>1</sub> = 10000</span></td><td><span class="math inline">00111</span></td><td><span class="math inline">11101</span></td><td><span class="math inline">01010</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>2</sub> = 101</span></td><td><span class="math inline"><em>E</em><sub>2</sub> = 01000</span></td><td><span class="math inline">11111</span></td><td><span class="math inline">00101</span></td><td><span class="math inline">10010</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>3</sub> = 100</span></td><td><span class="math inline"><em>E</em><sub>3</sub> = 00100</span></td><td><span class="math inline">10011</span></td><td><span class="math inline">01001</span></td><td><span class="math inline">11110</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>4</sub> = 010</span></td><td><span class="math inline"><em>E</em><sub>4</sub> = 00010</span></td><td><span class="math inline">10101</span></td><td><span class="math inline">01111</span></td><td><span class="math inline">11000</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>5</sub> = 001</span></td><td><span class="math inline"><em>E</em><sub>5</sub> = 00001</span></td><td><span class="math inline">10110</span></td><td><span class="math inline">01100</span></td><td><span class="math inline">11011</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>6</sub> = 011</span></td><td><span class="math inline"><em>E</em><sub>6</sub> = 00011</span></td><td><span class="math inline">10100</span></td><td><span class="math inline">01110</span></td><td><span class="math inline">11001</span></td></tr><tr><td><span class="math inline"><em>S</em><sub>7</sub> = 110</span></td><td><span class="math inline"><em>E</em><sub>7</sub> = 00110</span></td><td><span class="math inline">10001</span></td><td><span class="math inline">01011</span></td><td><span class="math inline">11100</span></td></tr></tbody></table></li><li><p>将接收码<span class="math inline"><strong>R</strong> = 10101</span>译码，可选以下三种方法之一译码：</p><ol type="1"><li>直接搜索码表，查得<span class="math inline">(10101)</span>所在列的子集头是<span class="math inline">(10111)</span>，因此译码输出取为<span class="math inline">(10111)</span>。</li><li>先求伴随式<span class="math inline"><strong>R</strong><em>H</em><sup><em>T</em></sup> = (10101) ⋅ <em>H</em><sup><em>T</em></sup> = (010) = <em>S</em><sub>4</sub></span>，确定<span class="math inline"><em>S</em><sub>4</sub></span>所在行，再沿着行对码表作一维搜索找到<span class="math inline">(10101)</span>，最后顺着所在列向上找出码字<span class="math inline">(10111)</span>。</li><li>先求出伴随式<span class="math inline"><strong>R</strong><em>H</em><sup><em>T</em></sup> = (010) = <em>S</em><sub>4</sub></span>并确定<span class="math inline"><em>S</em><sub>4</sub></span>所对应的陪集首（差错图案）<span class="math inline"><em>E</em><sub>4</sub> = (00010)</span>，再将陪集首与收码相加得到码字<span class="math inline"><strong>C</strong> = <strong>R</strong> + <em>E</em><sub>4</sub> = (10101) + (00010) = (10111)</span>。</li></ol></li></ul></li></ul><h3 id="码距纠错能力mdc码及重量谱">码距、纠错能力、MDC码及重量谱</h3><ul><li><p><strong>汉明距离</strong>：两个码字<span class="math inline"><em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub></span>之间对应码元位上符号取值不同的个数，称为码字<span class="math inline"><em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub></span>之间的汉明距离<span class="math display">$$d(c_i, c_j)=\sum_{k = 0}^{n -1}(c_{ik}\oplus c_{jk})$$</span></p></li><li><p><strong>最小距离</strong>：在<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码中，码字之间的最小汉明距离<span class="math display"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = <em>m</em><em>i</em><em>n</em>(<em>d</em>(<em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub>)), <em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub> ∈ <em>C</em></span></p></li><li><p><strong>定理6.1</strong>：任何最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>的线性分组码，其检错能力为<span class="math inline">(<em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> − 1)</span>，纠错能力<span class="math inline"><em>t</em></span>为<span class="math display">$$t =\left\lfloor\frac{d_{min}-1}{2}\right\rfloor$$</span></p><ul><li>纠错能力<span class="math inline"><em>t</em></span>是指在接收码中，最多允许有<span class="math inline"><em>t</em></span>个差错图案而不致于误译的能力。（只要不到另一个点，你就能知道出错了）</li><li>检错能力是指在接收码中，最多允许有<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> − 1</span>个差错图案而不致于误译的能力。（只要离原来的点比任何一个点都近，你就能知道原来的点）</li></ul></li><li><p><strong>纠错能力示意图</strong>：码集各码字间的距离是不同的，码距最小者决定码的特性，称之为最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span></p><ul><li><img src="image-73.png" srcset="/img/loading/loading3.gif" lazyload></li><li>如图中<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = 3</span>，纠错能力是<span class="math inline">1</span>，检错能力是<span class="math inline">2</span></li></ul></li><li><p><strong>最小距离计算</strong>：</p><ul><li><strong>汉明重量</strong>：码字中非<span class="math inline">0</span>码元符号的个数，称为该码字的汉明重量。<strong>在二元线性码中，码字重量就是码字中含“<span class="math inline">1</span>”的个数</strong> <span class="math display">$$w(c)=\sum_{i = 0}^{n - 1}c_i$$</span></li><li><strong>定理6.2</strong>：线性分组码的最小距离等于码集中非零码字的最小重量<span class="math display"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = <em>m</em><em>i</em><em>n</em>{<em>w</em>(<em>C</em><sub><em>i</em></sub>)}  <em>C</em><sub><em>i</em></sub> ∈ <em>C</em><em>及</em><em>C</em><sub><em>i</em></sub> ≠ 0</span><span class="math display"><em>d</em>(<em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub>) = <em>w</em>(<em>c</em><sub><em>i</em></sub> ⊕ <em>c</em><sub><em>j</em></sub>) = <em>w</em>(<em>c</em><sub><em>k</em></sub>)  <em>c</em><sub><em>i</em></sub>, <em>c</em><sub><em>j</em></sub>, <em>c</em><sub><em>k</em></sub> ∈ <em>C</em></span></li><li><strong>定理6.3</strong>：<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码最小距离等于<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>的<strong>必要</strong>条件是：校验矩阵<span class="math inline"><em>H</em></span>中任意<span class="math inline">(<em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> − 1)</span>列线性无关。<ul><li>将<span class="math inline"><em>H</em></span>写成<span class="math inline"><em>H</em> = [<em>h</em><sub><em>n</em> − 1</sub>, ⋯, <em>h</em><sub>1</sub>, <em>h</em><sub>0</sub>]</span>，其中<span class="math inline"><em>h</em><sub><em>n</em> − 1</sub>, ⋯, <em>h</em><sub>1</sub>, <em>h</em><sub>0</sub></span>为列矢量<span class="math display">$$  \begin{align*}  cH^T &amp;= [c_{n - 1},\cdots, c_1, c_0]\begin{bmatrix}h_{n -1}^T\\\vdots\\h_1^T\\h_0^T\end{bmatrix}\\  &amp;=c_{n - 1}h_{n - 1}^T+\cdots + c_1h_1^T + c_0h_0^T = 0  \end{align*}  $$</span></li><li>若存在一个重量为<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>的码字，则必有<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>列线性相关</li></ul></li><li><strong>定理6.4</strong>：<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码的最小距离必定小于等于<span class="math inline">(<em>n</em> − <em>k</em> + 1)</span> <span class="math display"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> ≤ (<em>n</em> − <em>k</em> + 1)</span><ul><li>计算校验矩阵的秩，则<span class="math inline"><em>H</em></span>的秩加<span class="math inline">1</span>就是最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub></span>的上限。</li></ul></li></ul></li><li><p><strong>示例</strong>：对于<span class="math inline">(7, 4)</span>线性码，<span class="math inline">$H =\begin{bmatrix}1110100\\0111010\\1101001\end{bmatrix}$</span></p><ul><li>各列都不相同，任意<span class="math inline">2</span>列之和不等于<span class="math inline">0</span>，任何<span class="math inline">2</span>列线性无关；</li><li>存在<span class="math inline">2</span>列之和等于矩阵中某一列，即存在<span class="math inline">3</span>列线性相关</li><li>存在重量为<span class="math inline">3</span>的码字</li><li>能找到的最小线性相关的列数为<span class="math inline">3</span></li><li>所以该码的最小距离为<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = 3</span>，小于<span class="math inline"><em>n</em> − <em>k</em> + 1 = 4</span> 。</li><li>该码的纠错能力为<span class="math inline">$t =\left\lfloor\frac{d_{min}-1}{2}\right\rfloor =1$</span>，检错能力为<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> − 1 = 2</span>。</li></ul></li><li><p><strong>极大最小距离码 (MDC)</strong>：</p><ul><li><strong>定义</strong>：<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = <em>n</em> − <em>k</em> + 1</span>的<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性码称为极大最小距离码(MDC - Maximized minimum Distance Code)。</li><li>总体的、平均的纠错能力不但与最小距离有关，而且与其余码距或者说与码字的重量分布特性有关。</li></ul></li></ul><h3 id="完备码perfect-code">完备码（Perfect code）</h3><h4 id="完备码定义与性质">完备码定义与性质</h4><ul><li><strong>汉明限</strong>：任何一个二元<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码都有<span class="math inline">2<sup><em>n</em> − <em>k</em></sup></span>个伴随式，若该码的纠错能力是<span class="math inline"><em>t</em></span>，则对于任何一个重量小于等于<span class="math inline"><em>t</em></span>的差错图案，都应有一个伴随式与之对应，即伴随式的数目满足条件<span class="math display">$$2^{n -k}\geq\binom{n}{0}+\binom{n}{1}+\binom{n}{2}+\cdots+\binom{n}{t}$$</span>此式称作<strong>汉明限</strong>，任何一个纠错码都应满足该条件。</li><li><strong>完备码定义</strong>：满足以下等式的二元<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码 <span class="math display">$$2^{n -k}=\binom{n}{0}+\binom{n}{1}+\binom{n}{2}+\cdots+\binom{n}{t}$$</span></li><li><strong>完备码性质</strong>：<ol type="1"><li>即该码的伴随式数目恰好和不大于<span class="math inline"><em>t</em></span>个差错的图案数目相等。</li><li>相当于在标准译码阵列中能将所有重量不大于<span class="math inline"><em>t</em></span>的差错图案选作陪集首，且没有一个陪集首的重量大于<span class="math inline"><em>t</em></span>，此时校验位得到最充分的利用。</li><li>这样的二元<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码称为<strong>完备码</strong>。</li></ol></li></ul><h4 id="汉明码hamming-code">汉明码（Hamming Code）</h4><ul><li><strong>定义</strong>：汉明码是纠错能力<span class="math inline"><em>t</em> = 1</span>的一类码的统称。</li><li><strong>性质</strong>：<ul><li><p>汉明码既有二进制的，也有非二进制的。</p></li><li><p>二进制时，汉明码码长<span class="math inline"><em>n</em></span>和信息位<span class="math inline"><em>k</em></span>服从规律<span class="math display">(<em>n</em>, <em>k</em>) = (2<sup><em>m</em></sup> − 1, 2<sup><em>m</em></sup> − 1 − <em>m</em>)</span>其中<span class="math inline"><em>m</em> = <em>n</em> − <em>k</em></span>，是正整数。</p><table><thead><tr><th>正整数<span class="math inline"><em>m</em> = <em>n</em> − <em>k</em></span></th><th>码长 <span class="math inline"><em>n</em> = 2<sup><em>m</em></sup> − 1</span></th><th>信息位 <span class="math inline"><em>k</em> = 2<sup><em>m</em></sup> − 1 − <em>m</em></span></th><th>汉明码<span class="math inline">(<em>n</em>, <em>k</em>)</span></th></tr></thead><tbody><tr><td>3</td><td><span class="math inline">2<sup>3</sup> − 1 = 7</span></td><td><span class="math inline">2<sup>3</sup> − 1 − 3 = 4</span></td><td><span class="math inline">(7, 4)</span></td></tr><tr><td>4</td><td><span class="math inline">2<sup>4</sup> − 1 = 15</span></td><td><span class="math inline">2<sup>4</sup> − 1 − 4 = 11</span></td><td><span class="math inline">(15, 11)</span></td></tr><tr><td>5</td><td><span class="math inline">2<sup>5</sup> − 1 = 31</span></td><td><span class="math inline">2<sup>5</sup> − 1 − 5 = 26</span></td><td><span class="math inline">(31, 26)</span></td></tr><tr><td>6</td><td><span class="math inline">2<sup>6</sup> − 1 = 63</span></td><td><span class="math inline">2<sup>6</sup> − 1 − 6 = 57</span></td><td><span class="math inline">(63, 57)</span></td></tr><tr><td>7</td><td><span class="math inline">2<sup>7</sup> − 1 = 127</span></td><td><span class="math inline">2<sup>7</sup> − 1 − 7 = 120</span></td><td><span class="math inline">(127, 120)</span></td></tr><tr><td>8</td><td><span class="math inline">2<sup>8</sup> − 1 = 255</span></td><td><span class="math inline">2<sup>8</sup> − 1 − 8 = 247</span></td><td><span class="math inline">(255, 247)</span></td></tr><tr><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td></tr></tbody></table></li><li><p>汉明码是完备码，因为满足等式<span class="math display">$$\binom{n}{0}+\binom{n}{1}=1 + n=1 + 2^m -1=2^m=2^{n - k}$$</span></p></li></ul></li><li><strong>校验矩阵构成</strong>：汉明码的校验矩阵<span class="math inline"><em>H</em></span>具有特殊性质，可简化构造方法。<ul><li>一个<span class="math inline">(<em>n</em>, <em>k</em>)</span>码的校验矩阵有<span class="math inline"><em>n</em> − <em>k</em></span>行和<span class="math inline"><em>n</em></span>列，二进制时<span class="math inline"><em>n</em> − <em>k</em></span>个码元所能组成的列矢量总数是<span class="math inline">2<sup><em>n</em> − <em>k</em></sup></span>，除去全<span class="math inline">0</span>矢量后为<span class="math inline">2<sup><em>n</em> − <em>k</em></sup> − 1 = 2<sup><em>m</em></sup> − 1 = <em>n</em></span>，恰好和校验矩阵的列数<span class="math inline"><em>n</em></span>相等。</li><li>只要排列所有列，通过列置换将矩阵<span class="math inline"><em>H</em></span>转换成系统形式，就可以进一步得到相应的生成矩阵<span class="math inline"><em>G</em></span>。</li></ul></li><li><strong>示例</strong>：构造一个<span class="math inline"><em>m</em> = 3</span>的二元<span class="math inline">(7, 4)</span>汉明码。<ul><li>先利用汉明码的特性构造一个<span class="math inline">(7, 4)</span>汉明码的校验矩阵<span class="math inline"><em>H</em></span>，再通过列置换将它变为系统形式：</li><li>校验矩阵<span class="math inline">$H=\begin{bmatrix}0001111\\0110011\\1010101\end{bmatrix}$</span>，经列置换得到<span class="math inline">$\begin{bmatrix}1110100\\0111010\\1101001\end{bmatrix}=[P^T| I_3]$</span>，再得生成矩阵<span class="math inline">$G = [I_4 |P]=\begin{bmatrix}1000101\\0100111\\0010110\\0001011\end{bmatrix}$</span>#### 高莱（Golay）码</li></ul></li><li>是二进制<span class="math inline">(23, 12)</span>线性码</li><li>最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = 7</span></li><li>纠错能力<span class="math inline"><em>t</em> = 3</span></li><li>高莱码是完备码，因为满足等式<span class="math display">$$2^{23 -12}=2048=1+\binom{23}{1}+\binom{23}{2}+\binom{23}{3}$$</span></li><li>在<span class="math inline">(23, 12)</span>码上添加一位奇偶位即得二进制线性<span class="math inline">(24, 12)</span>扩展高莱码，其最小距离<span class="math inline"><em>d</em><sub><em>m</em><em>i</em><em>n</em></sub> = 8</span>。</li><li>编码步骤见<a href="#高莱golay码-1">高莱码编码步骤</a></li></ul><h3 id="循环码">循环码</h3><h4 id="基本概念与多项式描述">基本概念与多项式描述</h4><ul><li><p><strong>循环码的定义</strong>：设一个<span class="math inline">(<em>n</em>, <em>k</em>)</span>线性分组码<span class="math inline"><em>C</em></span>，如果它的任一码字的每一次循环移位都还是<span class="math inline"><em>C</em></span>的一个码字，则称<span class="math inline"><em>C</em></span>是<strong>循环码</strong>。 <span class="math display">$$  \begin{align*}  \forall: &amp;\boldsymbol{c}=(c_{n - 1},c_{n - 2},\cdots,c_{0})\in C\\  &amp;\boldsymbol{c}_1=(c_{n - 2},c_{n - 3},\cdots,c_{0},c_{n - 1})\inC\\  &amp;\boldsymbol{c}_2=(c_{n - 3},c_{n - 4},\cdots,c_{0},c_{n - 1},c_{n- 2})\in C\\  &amp;\vdots\\  &amp;\boldsymbol{c}_{n - 1}=(c_{0},c_{n - 1},\cdots,c_{2},c_{1})\in C  \end{align*}  $$</span></p></li><li><p><strong>循环码的数学描述</strong>：</p><ul><li><strong>循环码的特点</strong>：<ul><li>它是线性分组码，其数学模型应具有线性特性。</li><li>具有循环特性。</li><li>码字的全体<strong>构成了<span class="math inline"><em>n</em></span>维矢量空间中具有循环特性的<span class="math inline"><em>k</em></span>维子空间</strong>。</li></ul></li><li><strong>线性分组码的多项式描述</strong>：<ul><li>码字<span class="math display"><strong>c</strong> = (<em>c</em><sub><em>n</em> − 1</sub>, <em>c</em><sub><em>n</em> − 2</sub>, ⋯, <em>c</em><sub>0</sub>)</span></li><li>码多项式<span class="math display"><em>c</em>(<em>x</em>) = <em>c</em><sub><em>n</em> − 1</sub><em>x</em><sup><em>n</em> − 1</sup> + <em>c</em><sub><em>n</em> − 2</sub><em>x</em><sup><em>n</em> − 2</sup> + ⋯ + <em>c</em><sub>1</sub><em>x</em> + <em>c</em><sub>0</sub></span></li><li>对于线性分组码<span class="math inline"><em>C</em></span>，可以表示成码多项式构成的集合：<span class="math display">$$  \begin{align*}  &amp;C\leftrightarrow C(x)\\  &amp;=\{c_{n - 1}x^{n - 1}+c_{n - 2}x^{n - 2}+\cdots + c_1x +c_0\mid(c_{n - 1},c_{n - 2},\cdots,c_{0})\in C\}  \end{align*}  $$</span></li></ul></li></ul></li><li><p><strong>示例</strong>：<span class="math inline">(7, 3)</span>线性分组码</p><ul><li>校验矩阵<span class="math inline">$H=\begin{bmatrix}1&amp;0&amp;1&amp;1&amp;0&amp;0&amp;0\\1&amp;1&amp;1&amp;0&amp;1&amp;0&amp;0\\1&amp;1&amp;0&amp;0&amp;0&amp;1&amp;0\\0&amp;1&amp;1&amp;0&amp;0&amp;0&amp;1\end{bmatrix}$</span>生成矩阵<span class="math inline">$G=\begin{bmatrix}1&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0\\0&amp;1&amp;0&amp;0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;1&amp;1&amp;0&amp;1\end{bmatrix}$</span>由<span class="math inline"><strong>c</strong> = <strong>m</strong><em>G</em></span>得码集（由两组码字循环构成的循环码）：<img src="image-79.png" srcset="/img/loading/loading3.gif" lazyload></li><li>任取一码字<ul><li>设<span class="math inline"><strong>c</strong> = 0011101</span>，则<span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>。</li><li>移一位，<span class="math inline"><strong>c</strong><sub>1</sub> = 0111010</span>，<span class="math inline"><em>c</em><sub>1</sub>(<em>x</em>) = <em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em> = <em>x</em><em>c</em>(<em>x</em>)</span>。</li><li>移两位，<span class="math inline"><strong>c</strong><sub>2</sub> = 1110100</span>，<span class="math inline"><em>c</em><sub>2</sub>(<em>x</em>) = <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>2</sup> = <em>x</em><sup>2</sup><em>c</em>(<em>x</em>)</span>。</li><li>移三位，<span class="math inline"><strong>c</strong><sub>3</sub> = 1101001</span>，<span class="math inline"><em>c</em><sub>3</sub>(<em>x</em>) = <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>3</sup> + 1 = <em>x</em><sup>3</sup><em>c</em>(<em>x</em>)&nbsp;(mod &nbsp;(<em>x</em><sup>7</sup> + 1))</span>。</li><li><span class="math inline">⋮</span></li></ul></li></ul></li><li><p><strong>结论</strong>：如果将一个循环码的某一非零码字用码多项式表示出来，那么其他的非零码字多项式就可以用这个码字多项式（或码字多项式的和）乘上<span class="math inline"><em>x</em></span>的一个幂，再求<span class="math inline">(<em>x</em><sup><em>n</em></sup> + 1)</span>的余得到。</p></li><li><p><strong>说明</strong>：一个码字的移位最多能得到<span class="math inline"><em>n</em></span>个码字，因此“循环码字的循环仍是码字”并不意味着循环码集可以从一个码字循环而得，还应包含码字的一些线性组合。</p></li></ul><h4 id="基本定理与矩阵描述">基本定理与矩阵描述</h4><ul><li><strong>循环码的生成多项式</strong>:<ul><li><strong>定义</strong>：若<span class="math inline"><em>g</em>(<em>x</em>)</span>是一个<span class="math inline">(<em>n</em> − <em>k</em>)</span>次多项式，且是<span class="math inline">(<em>x</em><sup><em>n</em></sup> + 1)</span>的因式，则由<span class="math inline"><em>g</em>(<em>x</em>)</span>可以生成一个<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码，<span class="math inline"><em>g</em>(<em>x</em>)</span>称为该循环码的<strong>生成多项式</strong>。</li><li><strong>结论</strong>：<ol type="1"><li><p><strong>结论1</strong>：<span class="math inline"><em>G</em><em>F</em>(2)</span>上的<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码中，存在着一个次数为<span class="math inline">(<em>n</em> − <em>k</em>)</span>的<strong>首一码多项式</strong><span class="math inline"><em>g</em>(<em>x</em>)</span>（首一：多项式最高幂次项系数<span class="math inline"><em>g</em><sub><em>n</em> − <em>k</em></sub> = 1</span>） <span class="math display"><em>g</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup> + <em>g</em><sub><em>n</em> − <em>k</em> − 1</sub><em>x</em><sup><em>n</em> − <em>k</em> − 1</sup> + ⋯ + <em>g</em><sub>2</sub><em>x</em><sup>2</sup> + <em>g</em><sub>1</sub><em>x</em> + 1</span></p><p>使得所有码多项式都是<span class="math inline"><em>g</em>(<em>x</em>)</span>的倍式，即 <span class="math display"><em>c</em>(<em>x</em>) = <em>m</em>(<em>x</em>) ⋅ <em>g</em>(<em>x</em>)</span></p><p>其中<span class="math display"><em>m</em>(<em>x</em>) = <em>m</em><sub><em>k</em> − 1</sub><em>x</em><sup><em>k</em> − 1</sup> + ⋯ + <em>m</em><sub>1</sub><em>x</em> + <em>m</em><sub>0</sub></span></p><p>且所有小于<span class="math inline"><em>n</em></span>次的<span class="math inline"><em>g</em>(<em>x</em>)</span>的倍式都是码多项式。<strong>故循环码完全由它的生成多项式确定</strong>。</p></li><li><p><strong>结论2</strong>：<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码的生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>一定是<span class="math inline">(<em>x</em><sup><em>n</em></sup> + 1)</span>的因子，即<span class="math display">$$g(x)\mid(x^n + 1)\quad或写成\quad x^n + 1 =g(x)h(x)$$</span> 相反，如果<span class="math inline"><em>g</em>(<em>x</em>)</span>是<span class="math inline"><em>x</em><sup><em>n</em></sup> + 1</span>的<span class="math inline">(<em>n</em> − <em>k</em>)</span>次因子，则<span class="math inline"><em>g</em>(<em>x</em>)</span>一定是<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码的生成多项式。<strong>生成多项式不唯一</strong>。</p></li><li><p><strong>结论3</strong>：任何码字的循环移位仍是码字，但并非由一个码字循环移位可以得到所有码字。</p></li><li><p><strong>结论4</strong>：当一个循环码给定其生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>后，根据生成多项式就可以进行编码，但编出的码不一定为系统码。</p></li></ol></li><li><strong><span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码的构造</strong>：<ol type="1"><li>对<span class="math inline"><em>x</em><sup><em>n</em></sup> + 1</span>做因式分解，找出<span class="math inline">(<em>n</em> − <em>k</em>)</span>次因式。</li><li>以该<span class="math inline">(<em>n</em> − <em>k</em>)</span>次因式为生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>与不高于<span class="math inline">(<em>k</em> − 1)</span>次信息多项式<span class="math inline"><em>m</em>(<em>x</em>)</span>相乘，即得到对应消息序列的码多项式。</li></ol></li></ul></li><li><strong>循环码的生成矩阵</strong>:<ul><li><p><span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码是<span class="math inline"><em>n</em></span>维线性空间中具有循环特性的<span class="math inline"><em>k</em></span>维子空间，其生成矩阵可由码空间中任一组<span class="math inline"><em>k</em></span>个线性无关的码字构成，这<span class="math inline"><em>k</em></span>个线性无关的码字组成<span class="math inline">(<em>n</em>, <em>k</em>)</span>循环码的基底，且基底不唯一。</p></li><li><p><strong>获得<span class="math inline"><em>k</em></span>个线性无关码字的方法</strong><strong>当循环码的生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>确定后，可取<span class="math inline"><em>g</em>(<em>x</em>)</span>本身加上移位<span class="math inline"><em>k</em> − 1</span>次所得到的<span class="math inline"><em>k</em> − 1</span>个码字，与<span class="math inline"><em>g</em>(<em>x</em>)</span>一起作为<span class="math inline"><em>k</em></span>个基底</strong>，即： <span class="math display">$$  \begin{align*}  G&amp;=\begin{bmatrix}x^{k - 1}g(x)\\x^{k -2}g(x)\\\vdots\\xg(x)\\g(x)\end{bmatrix}\\  &amp;=\begin{bmatrix}g_{n - k}&amp;g_{n - k -1}&amp;\cdots&amp;g_0&amp;0&amp;0&amp;\cdots&amp;0\\0&amp;g_{n -k}&amp;g_{n - k -1}&amp;\cdots&amp;g_0&amp;0&amp;\cdots&amp;0\\\vdots&amp;&amp;&amp;\ddots&amp;&amp;&amp;\vdots\\0&amp;\cdots&amp;0&amp;0&amp;g_{n- k}&amp;g_{n - k - 1}&amp;\cdots&amp;g_0\end{bmatrix}  \end{align*}  $$</span></p><p>这<span class="math inline"><em>k</em></span>个矢量线性无关，且由<span class="math inline"><em>g</em>(<em>x</em>)</span>循环移位得到，所以都是码字，它们构成一个<span class="math inline"><em>k</em> × <em>n</em></span>的矩阵，即循环码的生成矩阵。</p></li></ul></li><li><strong>循环码的系统码</strong><ul><li><strong>系统循环码的编码</strong>：<ul><li>码多项式<span class="math display"><em>c</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)</span>其中<span class="math inline"><em>r</em>(<em>x</em>)</span>是与码字中<span class="math inline">(<em>n</em> − <em>k</em>)</span>个校验元相对应的<span class="math inline">(<em>n</em> − <em>k</em> − 1)</span>次多项式。对等式两边取<span class="math inline">&nbsp;mod &nbsp;<em>g</em>(<em>x</em>)</span>：</li><li>等式左边：<span class="math inline"><em>c</em>(<em>x</em>) = <em>m</em>(<em>x</em>)<em>g</em>(<em>x</em>)</span>，所以<span class="math inline"><em>c</em>(<em>x</em>)&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = 0</span>。</li><li>等式右边：必有<span class="math inline">[<em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)]&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = 0</span>，由于<span class="math inline"><em>r</em>(<em>x</em>)</span>的幂次<span class="math inline">(<em>n</em> − <em>k</em> − 1)</span>低于<span class="math inline"><em>g</em>(<em>x</em>)</span>的幂次<span class="math inline">(<em>n</em> − <em>k</em>)</span>，要使等式右边为<span class="math inline">0</span>，必有<span class="math display"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>r</em>(<em>x</em>)</span></li></ul></li><li><strong>系统码的编码步骤</strong>：<ol type="1"><li>将信息多项式<span class="math inline"><em>m</em>(<em>x</em>)</span>乘以<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup></span>，即左移<span class="math inline">(<em>n</em> − <em>k</em>)</span>位</li><li>将<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)</span>除以<span class="math inline"><em>g</em>(<em>x</em>)</span> ，得到余式<span class="math inline"><em>r</em>(<em>x</em>)</span></li><li>得到系统循环码的码多项式：<span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)</span></li><li>将码多项式转换为码字。</li></ol></li><li><strong>系统码的生成矩阵</strong><ul><li>系统形式的生成矩阵 <span class="math inline"><em>G</em> = [<em>I</em>|<em>P</em>]</span></li><li><span class="math display">$$G(x)=\begin{bmatrix}x^{n-1} +p_{n-k}(x)\\x^{n-2} + p_{n-k-1}(x)\\\vdots\\x^{n-k+1} +p_1(x)\\x^{n-k}  + p_0(x)\end{bmatrix}_{k \times n}$$</span> 其中<span class="math display"><em>p</em><sub><em>i</em></sub>(<em>x</em>) = <em>x</em><sup><em>i</em> + (<em>n</em> − <em>k</em>)</sup>&nbsp;mod &nbsp;(<em>g</em>(<em>x</em>))</span></li></ul></li></ul></li><li><strong>示例</strong>：一个长度<span class="math inline"><em>n</em> = 7</span>的循环码的构造方法<ol type="1"><li><p><strong>求一种<span class="math inline">(7, 4)</span>循环码</strong></p><ol type="1"><li>对<span class="math inline"><em>x</em><sup>7</sup> + 1</span>作因式分解： <span class="math inline"><em>x</em><sup>7</sup> + 1 = (<em>x</em> + 1)(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1)(<em>x</em><sup>3</sup> + <em>x</em> + 1)</span>，故<span class="math inline"><em>x</em><sup>7</sup> + 1</span>有如下因式：<ul><li>一次因式：<span class="math inline"><em>x</em> + 1</span>（一个）</li><li>三次因式：<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em> + 1</span>，<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>（两个）</li><li>四次因式：<span class="math inline">(<em>x</em> + 1)(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1) = <em>x</em><sup>4</sup> + <em>x</em><sup>2</sup> + <em>x</em> + 1</span>，<span class="math inline">(<em>x</em> + 1)(<em>x</em><sup>3</sup> + <em>x</em> + 1) = <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>（两个）</li><li>六次因式：<span class="math inline">(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1)(<em>x</em><sup>3</sup> + <em>x</em> + 1) = <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + <em>x</em> + 1</span>（一个）</li></ul></li><li>以<span class="math inline">(<em>n</em> − <em>k</em>)</span>次因式作为生成多项式：<ul><li><span class="math inline"><em>n</em> − <em>k</em> = 1</span>，<span class="math inline"><em>k</em> = 6</span>，生成一种<span class="math inline">(7, 6)</span>循环码；</li><li><span class="math inline"><em>n</em> − <em>k</em> = 3</span>，<span class="math inline"><em>k</em> = 4</span>，生成两种<span class="math inline">(7, 4)</span>循环码；</li><li><span class="math inline"><em>n</em> − <em>k</em> = 4</span>，<span class="math inline"><em>k</em> = 3</span>，生成两种<span class="math inline">(7, 3)</span>循环码；</li><li><span class="math inline"><em>n</em> − <em>k</em> = 6</span>，<span class="math inline"><em>k</em> = 1</span>，生成一种<span class="math inline">(7, 1)</span>循环码。</li></ul></li></ol><ul><li><p>求一种<span class="math inline">(7, 4)</span>循环码，可选<span class="math inline"><em>n</em> − <em>k</em> = 3</span>次多项式<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>或<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em> + 1</span>为生成多项式。以选择<span class="math inline"><em>g</em>(<em>x</em>) = <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>为例，<span class="math inline"><em>n</em> − <em>k</em> = 3</span>，<span class="math inline"><em>k</em> = 4</span>（信息位为<span class="math inline">4</span> ）。 设信息多项式为<span class="math display"><em>m</em>(<em>x</em>) = <em>m</em><sub>3</sub><em>x</em><sup>3</sup> + <em>m</em><sub>2</sub><em>x</em><sup>2</sup> + <em>m</em><sub>1</sub><em>x</em> + <em>m</em><sub>0</sub></span></p><p>则循环码编码后的码多项式为<span class="math display"><em>c</em>(<em>x</em>) = <em>m</em>(<em>x</em>)<em>g</em>(<em>x</em>) = (<em>m</em><sub>3</sub><em>x</em><sup>3</sup> + <em>m</em><sub>2</sub><em>x</em><sup>2</sup> + <em>m</em><sub>1</sub><em>x</em> + <em>m</em><sub>0</sub>)(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1)</span></p><table><thead><tr><th><span class="math inline"><em>m</em></span></th><th><span class="math inline"><em>m</em>(<em>x</em>)</span></th><th><span class="math inline"><em>c</em>(<em>x</em>)</span></th><th><span class="math inline"><em>c</em></span></th></tr></thead><tbody><tr><td><span class="math inline">0000</span></td><td><span class="math inline">0</span></td><td><span class="math inline">0</span></td><td><span class="math inline">0000000</span></td></tr><tr><td><span class="math inline">0001</span></td><td><span class="math inline">1</span></td><td><span class="math inline"><em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span></td><td><span class="math inline">0001101</span></td></tr><tr><td><span class="math inline">0010</span></td><td><span class="math inline"><em>x</em></span></td><td><span class="math inline"><em>x</em><sup>4</sup> + <em>x</em><sup>3</sup> + <em>x</em></span></td><td><span class="math inline">0011010</span></td></tr><tr><td><span class="math inline">0011</span></td><td><span class="math inline"><em>x</em> + 1</span></td><td><span class="math inline"><em>x</em><sup>4</sup> + <em>x</em><sup>2</sup> + <em>x</em> + 1</span></td><td><span class="math inline">0010111</span></td></tr><tr><td><span class="math inline">0100</span></td><td><span class="math inline"><em>x</em><sup>2</sup></span></td><td><span class="math inline"><em>x</em><sup>5</sup> + <em>x</em><sup>4</sup> + <em>x</em><sup>2</sup></span></td><td><span class="math inline">0101100</span></td></tr><tr><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td><td><span class="math inline">⋯</span></td></tr></tbody></table><p>最终得： <img src="image-80.png" srcset="/img/loading/loading3.gif" lazyload></p></li></ul></li><li><p><strong>求<span class="math inline"><em>g</em>(<em>x</em>) = <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>，<span class="math inline"><em>k</em> = 4</span>的循环码的生成矩阵</strong>：<span class="math display">$$\begin{cases}x^3g(x)\leftrightarrow1101000\\x^2g(x)\leftrightarrow0110100\\xg(x)\leftrightarrow0011010\\g(x)\leftrightarrow0001101\end{cases}\RightarrowG=\begin{bmatrix}1101000\\0110100\\0011010\\0001101\end{bmatrix}$$</span></p><p>当循环码的生成矩阵确定后，编码规则为<span class="math display"><strong>c</strong> = <strong>m</strong><em>G</em></span></p><p>例如，当<span class="math inline"><strong>m</strong> = (1001)</span>时，<span class="math inline"><strong>c</strong> = (1001)<em>G</em> = 1100101</span>。 这与通过生成多项式计算结果相同：<span class="math inline"><em>m</em>(<em>x</em>)<em>g</em>(<em>x</em>) = (<em>x</em><sup>3</sup> + 1)(<em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1) = <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em><sup>2</sup> + 1</span>，对应码字也是<span class="math inline">1100101</span> 。</p></li><li><p><strong>求<span class="math inline"><em>g</em>(<em>x</em>) = <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>，<span class="math inline"><em>m</em> = (1001)</span>的系统码字。</strong></p><ol type="1"><li>计算<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)</span>：<ul><li>因为<span class="math inline"><em>n</em> = 7</span>，<span class="math inline"><em>k</em> = 4</span>，<span class="math inline"><em>m</em>(<em>x</em>) = <em>x</em><sup>3</sup> + 1</span>，所以<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) = <em>x</em><sup>3</sup>(<em>x</em><sup>3</sup> + 1) = <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup></span>。</li></ul></li><li>计算<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)</span>除以<span class="math inline"><em>g</em>(<em>x</em>)</span>的余式<span class="math inline"><em>r</em>(<em>x</em>)</span>： 用<span class="math inline"><em>x</em><sup>6</sup> + <em>x</em><sup>3</sup></span>除以<span class="math inline"><em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>，通过长除法： <img src="image-81.png" srcset="/img/loading/loading3.gif" lazyload> 得到<span class="math inline"><em>r</em>(<em>x</em>) = <em>x</em> + 1</span>。</li><li>得到系统循环码的码多项式<span class="math inline"><em>c</em>(<em>x</em>)</span>并转换为码字：<ul><li><span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>) = <em>x</em><sup>6</sup> + <em>x</em><sup>3</sup> + <em>x</em> + 1</span>，转换为码字<span class="math inline"><em>c</em> = (1001011)</span>。</li></ul></li></ol></li><li><p><strong>求<span class="math inline">(7, 4)</span>循环码<span class="math inline"><em>g</em>(<em>x</em>) = <em>x</em><sup>3</sup> + <em>x</em><sup>2</sup> + 1</span>系统形式的生成矩阵</strong>：设<span class="math inline">$G=\begin{bmatrix}g_3\\g_2\\g_1\\g_0\end{bmatrix}=\begin{bmatrix}1000p_{32}p_{31}p_{30}\\0100p_{22}p_{21}p_{20}\\0010p_{12}p_{11}p_{10}\\0001p_{02}p_{01}p_{00}\end{bmatrix}$</span>，<span class="math inline">$G(x)=\begin{bmatrix}x^6 + p_3(x)\\x^5 +p_2(x)\\x^4 + p_1(x)\\x^3 + p_0(x)\end{bmatrix}$</span> 分别计算：</p><ul><li><span class="math inline"><em>p</em><sub>3</sub>(<em>x</em>) = <em>x</em><sup>6</sup>&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>x</em><sup>2</sup> + <em>x</em></span></li><li><span class="math inline"><em>p</em><sub>2</sub>(<em>x</em>) = <em>x</em><sup>5</sup>&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>x</em> + 1</span></li><li><span class="math inline"><em>p</em><sub>1</sub>(<em>x</em>) = <em>x</em><sup>4</sup>&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>x</em><sup>2</sup> + <em>x</em> + 1</span></li><li><span class="math inline"><em>p</em><sub>0</sub>(<em>x</em>) = <em>x</em><sup>3</sup>&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>x</em><sup>2</sup> + 1</span></li></ul><p>最终得到<span class="math inline">$G=\begin{bmatrix}1000110\\0100011\\0010111\\0001101\end{bmatrix}$</span></p></li></ol></li></ul><h4 id="编译码方法及其实现电路">编译码方法及其实现电路</h4><ul><li><strong>循环码的编码</strong><ul><li><strong>编码步骤</strong>：<ol type="1"><li>将信息多项式<span class="math inline"><em>m</em>(<em>x</em>)</span>乘以<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup></span>，即左移<span class="math inline">(<em>n</em> − <em>k</em>)</span>位。</li><li>将<span class="math inline"><em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>)</span>除以<span class="math inline"><em>g</em>(<em>x</em>)</span> ，得到余式<span class="math inline"><em>r</em>(<em>x</em>)</span></li><li>得到系统循环码的码多项式<span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup><em>n</em> − <em>k</em></sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)</span></li><li>将码多项式转换为码字。</li></ol></li><li><strong>用除法器实现<span class="math inline">(7, 3)</span>循环编码器</strong>： <img src="image-82.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>除法器编码示例</strong>： <img src="image-83.png" srcset="/img/loading/loading3.gif" lazyload></li></ul></li><li><strong>循环码的译码</strong><ul><li><strong>译码步骤</strong>：<ol type="1"><li>计算接收多项式<span class="math inline"><em>R</em>(<em>x</em>)</span>的伴随多项式<span class="math inline"><em>S</em>(<em>x</em>)</span> ，伴随式为<span class="math inline">0</span>则认为无差错</li><li>根据<span class="math inline"><em>S</em>(<em>x</em>)</span>找出相应错误图样多项式<span class="math inline"><em>e</em>(<em>x</em>)</span></li><li>将<span class="math inline"><em>e</em>(<em>x</em>)</span>和<span class="math inline"><em>R</em>(<em>x</em>)</span>模<span class="math inline">2</span>加，得到译码输出<span class="math inline"><em>ĉ</em>(<em>x</em>)</span> 。</li></ol></li><li><strong>伴随式计算及错误检测</strong>：<ul><li>设接收多项式为<span class="math inline"><em>R</em>(<em>x</em>)</span> ，码多项式为<span class="math inline"><em>c</em>(<em>x</em>)</span>，错误图样多项式为<span class="math inline"><em>e</em>(<em>x</em>)</span> ，则<span class="math display"><em>R</em>(<em>x</em>) = <em>c</em>(<em>x</em>) + <em>e</em>(<em>x</em>)</span>用生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>除<span class="math inline"><em>R</em>(<em>x</em>)</span>得伴随式<span class="math display"><em>s</em>(<em>x</em>) = <em>R</em>(<em>x</em>)&nbsp;mod &nbsp;<em>g</em>(<em>x</em>) = <em>e</em>(<em>x</em>)&nbsp;mod &nbsp;<em>g</em>(<em>x</em>)</span><strong>可通过译码电路高效实现</strong></li></ul></li></ul></li></ul><h4 id="高莱golay码">高莱（Golay）码</h4><ul><li><strong>二进制高莱码（Golay (23,12)码）的编码</strong><ul><li>二进制高莱码是一种循环码，其生成多项式为： <span class="math display"><em>g</em>(<em>x</em>) = <em>x</em><sup>11</sup> + <em>x</em><sup>9</sup> + <em>x</em><sup>7</sup> + <em>x</em><sup>6</sup> + <em>x</em><sup>5</sup> + <em>x</em> + 1</span></li><li><strong>编码步骤</strong>：<ol type="1"><li><strong>信息位准备</strong>：假设有12位的信息位，记为<span class="math inline"><em>m</em>(<em>x</em>)</span>。</li><li><strong>生成多项式</strong>：使用生成多项式<span class="math inline"><em>g</em>(<em>x</em>)</span>。</li><li><strong>计算校验位</strong>：<ul><li>将信息位<span class="math inline"><em>m</em>(<em>x</em>)</span>左移11位（即乘以<span class="math inline"><em>x</em><sup>11</sup></span> ），得到<span class="math inline"><em>x</em><sup>11</sup><em>m</em>(<em>x</em>)</span>。</li><li>计算<span class="math inline"><em>x</em><sup>11</sup><em>m</em>(<em>x</em>)</span>除以<span class="math inline"><em>g</em>(<em>x</em>)</span>的余数<span class="math inline"><em>r</em>(<em>x</em>)</span>。</li><li>将余数<span class="math inline"><em>r</em>(<em>x</em>)</span>添加到<span class="math inline"><em>x</em><sup>11</sup><em>m</em>(<em>x</em>)</span>的末尾，得到编码后的码字<span class="math inline"><em>c</em>(<em>x</em>) = <em>x</em><sup>11</sup><em>m</em>(<em>x</em>) + <em>r</em>(<em>x</em>)</span>。</li></ul></li></ol></li></ul></li><li><strong>扩展高莱码（Golay (24,12)码）的编码</strong><ul><li>扩展高莱码是在二进制高莱码的基础上增加一个奇偶校验位。</li><li><strong>编码步骤</strong>：<ol type="1"><li><strong>二进制高莱码编码</strong>：首先使用二进制高莱码的编码方法，生成23位的码字<span class="math inline"><em>c</em>(<em>x</em>)</span> 。</li><li><strong>计算奇偶校验位</strong>：<ul><li>计算23位码字中1的个数。</li><li>如果1的个数为奇数，则添加1作为奇偶校验位；如果为偶数，则添加0。</li></ul></li><li><strong>生成扩展码字</strong>：将奇偶校验位添加到23位码字的末尾，得到24位的扩展高莱码。</li></ol></li></ul></li></ul><h4 id="循环冗余校验cyclic-redundancy-checkcrc">循环冗余校验（CyclicRedundancy Check，CRC）</h4><ul><li><strong>原理</strong>：<ul><li>把数据视作二进制数<span class="math inline"><em>D</em></span></li><li>确定校验序列长度<span class="math inline"><em>r</em></span></li><li>选择长度为<span class="math inline"><em>r</em> + 1</span>的生成序列<span class="math inline"><em>G</em></span></li><li><span class="math inline"><em>D</em></span>后面添加<span class="math inline"><em>r</em></span>个<span class="math inline">0</span>后除以<span class="math inline"><em>G</em></span> ，余数为校验序列<span class="math inline"><em>R</em></span></li><li>将<span class="math inline"><em>R</em></span>附加在<span class="math inline"><em>D</em></span>后面作为实际传输数据。</li><li><strong>检错</strong>：接收方将接收到的数据除以<span class="math inline"><em>G</em></span> ，若余数为<span class="math inline">0</span> ，则认为无出错，否则认为传输出错</li></ul></li><li><strong>特点</strong>：可检测长度小于<span class="math inline"><em>r</em> + 1</span> bits的所有突发错误。<img src="image-84.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>CRC示例</strong>：<img src="image-85.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>常用CRC版本</strong>：<img src="image-86.png" srcset="/img/loading/loading3.gif" lazyload></li><li><strong>CRC有效性</strong>：<img src="image-87.png" srcset="/img/loading/loading3.gif" lazyload></li></ul><h1 id="第六章补充-信道编码">第六章补充 信道编码</h1><p><img src="image-52.png" srcset="/img/loading/loading3.gif" lazyload></p><h2 id="译码规则和译码错误概率">译码规则和译码错误概率</h2><ul><li>已知信道转移错误概率 <span class="math inline"><em>p</em> = 0.9</span>，转移情况如下：<img src="image-53.png" srcset="/img/loading/loading3.gif" lazyload><ul><li>若规定：<ul><li><span class="math inline"><em>Y</em> = 0 → <em>X̂</em> = 0</span></li><li><span class="math inline"><em>Y</em> = 1 → <em>X̂</em> = 1</span></li><li>即 <span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = <em>x</em><sub>1</sub></span>，<span class="math inline"><em>F</em>(<em>y</em><sub>2</sub>) = <em>x</em><sub>2</sub></span>，则译码错误概率<span class="math inline"><em>P</em><sub><em>e</em></sub> = 0.9</span>。</li></ul></li><li>反之若：<ul><li><span class="math inline"><em>Y</em> = 0 → <em>X̂</em> = 1</span></li><li><span class="math inline"><em>Y</em> = 1 → <em>X̂</em> = 0</span></li><li>即 <span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = <em>x</em><sub>2</sub></span>，<span class="math inline"><em>F</em>(<em>y</em><sub>2</sub>) = <em>x</em><sub>1</sub></span>，则译码错误概率<span class="math inline"><em>P</em><sub><em>e</em></sub> = 0.1</span>。</li></ul></li></ul></li></ul><h3 id="译码规则">译码规则</h3><ul><li><strong>定义译码规则</strong>：<span class="math display"><em>F</em>(<em>y</em><sub><em>j</em></sub>) = <em>x</em><sub><em>i</em></sub>  <em>i</em> = 1, 2, ⋯, <em>n</em>；<em>j</em> = 1, 2, ⋯, <em>m</em></span></li><li>示例：<ul><li>设转移概率矩阵 <span class="math inline">$P=\begin{bmatrix}0.5&amp;0.3&amp;0.2\\0.2&amp;0.3&amp;0.5\\0.3&amp;0.3&amp;0.4\end{bmatrix}_{(n\timesm)}$</span>，共有<span class="math inline"><em>n</em><sup><em>m</em></sup></span>种译码规则，如：<ul><li>译码规则 <span class="math inline"><em>A</em></span>：<span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = <em>x</em><sub>1</sub></span>；<span class="math inline"><em>F</em>(<em>y</em><sub>2</sub>) = <em>x</em><sub>2</sub></span>；<span class="math inline"><em>F</em>(<em>y</em><sub>3</sub>) = <em>x</em><sub>3</sub></span>。</li><li>译码规则 <span class="math inline"><em>B</em></span>：<span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = <em>x</em><sub>1</sub></span>；<span class="math inline"><em>F</em>(<em>y</em><sub>2</sub>) = <em>x</em><sub>3</sub></span>；<span class="math inline"><em>F</em>(<em>y</em><sub>3</sub>) = <em>x</em><sub>2</sub></span>。</li><li><span class="math inline">⋯</span></li></ul></li></ul></li></ul><h3 id="错误概率">错误概率</h3><ul><li>若 <span class="math inline"><em>F</em>(<em>y</em><sub><em>j</em></sub>) = <em>x</em><sub><em>i</em></sub><sup>*</sup></span>，则：<ul><li><strong>正确概率</strong>：<span class="math display"><em>p</em>(<em>F</em>(<em>y</em><sub><em>j</em></sub>)|<em>y</em><sub><em>j</em></sub>) = <em>p</em>(<em>x</em><sub><em>i</em></sub><sup>*</sup>|<em>y</em><sub><em>j</em></sub>)</span></li><li><strong>错误概率</strong>：<span class="math display"><em>p</em>(<em>e</em>|<em>y</em><sub><em>j</em></sub>) = 1 − <em>p</em>(<em>x</em><sub><em>i</em></sub><sup>*</sup>|<em>y</em><sub><em>j</em></sub>)</span></li><li><strong>平均错误概率</strong>： <span class="math display">$$  \begin{align*}  P_e &amp;= E[p(e|y_j)]\\  &amp;=\sum_{j = 1}^{m}p(y_j)p(e|y_j)\\  &amp;=\sum_{j = 1}^{m}p(y_j)(1 - p(x_i^*|y_j))\\  &amp;=\sum_{j = 1}^{m}p(y_j)-\sum_{j = 1}^{m}p(x_i^*,y_j)\\  &amp;=1-\sum_{j = 1}^{m}p(x_i^*,y_j)\\  &amp;=\sum_{Y, X-X^*}p(x,y)  \end{align*}  $$</span></li></ul></li></ul><h3 id="最佳译码规则">最佳译码规则</h3><ul><li><p>最佳译码就是使平均错误概率最小 <span class="math display">$$P_e=\sum_{j = 1}^{m}p(y_j)p(e|y_j)$$</span></p><p>只需使 <span class="math inline"><em>p</em>(<em>e</em>|<em>y</em><sub><em>j</em></sub>)</span>最小（<span class="math inline"><em>j</em> = 1, 2, ⋯, <em>m</em></span>），而 <span class="math inline"><em>p</em>(<em>e</em>|<em>y</em><sub><em>j</em></sub>) = 1 − <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>) = 1 − <em>p</em>(<em>F</em>(<em>y</em><sub><em>j</em></sub>)|<em>y</em><sub><em>j</em></sub>)</span>。</p><p>因此，<strong>最佳译码</strong>规则 <span class="math inline"><em>F</em>(<em>y</em><sub><em>j</em></sub>) = <em>x</em><sup>*</sup></span>，满足<span class="math display"><em>p</em>(<em>x</em><sup>*</sup>|<em>y</em><sub><em>j</em></sub>) ≥ <em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>),  <em>i</em> = 1, 2, ⋯, <em>n</em></span></p></li></ul><h4 id="最大后验概率译码">最大后验概率译码</h4><ul><li>最大后验概率译码满足最佳译码规则：<span class="math display"><em>x</em><sup>*</sup> = arg max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub><em>p</em>(<em>x</em><sub><em>i</em></sub>|<em>y</em><sub><em>j</em></sub>)</span></li><li><span class="math display">$$  F:\left\{  \begin{array}{l}  F(b_j)=a_j^*\in A, b_j\in B\\  P(a_j^*|b_j)\geq P(a_i|b_j), a_i\in A  \end{array}  \right.  $$</span></li></ul><h4 id="最大联合概率译码">最大联合概率译码</h4><ul><li><p>根据贝叶斯公式<span class="math inline">$p(x_i|y_j)=\frac{p(y_j|x_i)p(x_i)}{p(y_j)}$</span>：<span class="math display">$$\max_{x_i} p(x_i|y_j) = \max_{x_i}\frac{p(y_j|x_i)p(x_i)}{p(y_j)}$$</span></p></li><li><p>则<strong>最大联合概率译码</strong>为： <span class="math display"><em>x</em><sup>*</sup> = arg max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)<em>p</em>(<em>x</em><sub><em>i</em></sub>)</span></p></li><li><p><span class="math display">$$  F:\left\{  \begin{array}{l}  F(b_j)=a_j^*\in A, b_j\in B\\  P(a_j^*, b_j)\geq P(a_i, b_j), a_i\in A  \end{array}  \right.  $$</span></p></li></ul><h4 id="最大似然译码">最大似然译码</h4><ul><li><p>当<span class="math inline">$p(x_i)=\frac{1}{n}$</span>时，即<strong>信源符号等概率分布时</strong>，有<strong>最大似然译码</strong>：<span class="math display"><em>x</em><sup>*</sup> = arg max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub><em>p</em>(<em>y</em><sub><em>j</em></sub>|<em>x</em><sub><em>i</em></sub>)</span></p></li><li><p><span class="math display">$$  F:\left\{  \begin{array}{l}  F(b_j)=a_j^*\in A, b_j\in B\\  P(b_j|a_j^*)\geq P(b_j|a_i), a_i\in A  \end{array}  \right.  $$</span></p></li><li><p><strong>示例</strong>：已知转移概率矩阵<span class="math inline">$P =      \begin{bmatrix}      \frac{1}{2}&amp;\frac{1}{3}&amp;\frac{1}{6}\\      \frac{1}{6}&amp;\frac{1}{2}&amp;\frac{1}{3}\\      \frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{2}      \end{bmatrix}$</span>，且<span class="math inline">$p(x_1)=p(x_2)=p(x_3)=\frac{1}{3}$</span>，则：</p><ul><li><span class="math inline"><em>F</em>(<em>y</em><sub>1</sub>) = arg max (<em>p</em>(<em>y</em><sub>1</sub>|<em>x</em><sub>1</sub>), <em>p</em>(<em>y</em><sub>1</sub>|<em>x</em><sub>2</sub>), <em>p</em>(<em>y</em><sub>1</sub>|<em>x</em><sub>3</sub>)) = <em>x</em><sub>1</sub></span></li><li><span class="math inline">$F(y_2)=\arg\max(\frac{1}{3},\frac{1}{2},\frac{1}{6})= x_2$</span></li><li><span class="math inline"><em>F</em>(<em>y</em><sub>3</sub>) = <em>x</em><sub>3</sub></span></li><li><strong>译码规则A</strong>：<span class="math inline">$\begin{cases}F(y_1)=x_1\\F(y_2)=x_2\\F(y_3)=x_3\end{cases}$</span>，为最佳译码规则此时<span class="math inline">$P_e=\frac{1}{3}(\frac{1}{3}+\frac{1}{6}+\frac{1}{3}+\frac{1}{6}+\frac{1}{3}+\frac{1}{6})=\frac{1}{2}$</span></li><li><strong>译码规则B</strong>：<span class="math inline">$\begin{cases}F(y_1)=x_1\\F(y_2)=x_3\\F(y_3)=x_2\end{cases}$</span>此时<span class="math inline">$P_e=\frac{1}{3}(\frac{1}{6}+\frac{1}{3}+\frac{1}{3}+\frac{1}{2}+\frac{1}{6}+\frac{1}{2})=\frac{2}{3}$</span></li><li><strong>结论：最佳译码规则的错误概率最小</strong></li></ul></li></ul><h4 id="最小汉明距离译码">最小汉明距离译码</h4><ul><li><span class="math display">$$\hat{C}_i=\arg\max_{1\leq i\leqM}p(\vec{r}|\vec{C_{0}})p(\vec{C_{0}}),\quad M = q^k$$</span></li><li>在二进制对称信道（BSC）中：<ul><li><span class="math inline">$p(\vec{r}|\vec{C_{0}})=\prod_{j =1}^{n}p(r_j|c_{ij})$</span> ，且 <span class="math inline">$p(r_j|c_{ij}) =  \begin{cases}  p, &amp; c_{ij} \neq r_j \\  1 - p, &amp; c_{ij} = r_j  \end{cases}$</span>，其中<span class="math inline">$p=P_e&lt;\frac{1}{2}$</span>。</li><li>进一步推导可得<span class="math display">$$p(\vec{r}|\vec{C_{0}})=\prod_{j =1}^{n}p(r_j|c_{ij})=p^d(1 - p)^{n - d}=(\frac{p}{1 - p})^d(1 -p)^n$$</span></li><li>其中 <span class="math display">$$d =dis(\vec{r},\vec{C_{0}})=w(\vec{r}\oplus\vec{C_{0}})=\sum_{j =1}^{n}r_j\oplus c_{ij}$$</span> 即 <span class="math inline">$\vec{r_{}}$</span> 与 <span class="math inline">$\vec{C_{0}}$</span> 的汉明距离。</li><li>由于 <span class="math inline">$\frac{p}{1 - p} \leq 1$</span>，<span class="math inline">(1 − <em>p</em>)<sup><em>n</em></sup></span>是常数，所以 <span class="math inline"><em>d</em></span> 越大，<span class="math inline">$p(\vec{r}|\vec{C_{0}})$</span> 越小。求 <span class="math inline">$\max p(\vec{r}|\vec{C_{0}})$</span>的问题就转化成求最小汉明距离问题。</li></ul></li></ul><h3 id="译码错误与信道条件的关系">译码错误与信道条件的关系</h3><ul><li><p>译码时发生的错误是由信道中噪声引起的，错误概率 <span class="math inline"><em>P</em><sub><em>e</em></sub></span> 与信道疑义度<span class="math inline"><em>H</em>(<em>X</em>|<em>Y</em>)</span>满足以下关系（<strong>费诺不等式</strong>）： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>P</em><sub><em>e</em></sub>) + <em>P</em><sub><em>e</em></sub>log (<em>n</em> − 1)</span></p></li><li><p><strong>证明</strong>： <span class="math display">$$  \begin{align*}  右式=&amp;H(P_e, 1 - P_e) + P_e \log (n - 1)\\  =&amp;P_e \log \frac{1}{P_e} + (1 - P_e) \log \frac{1}{1 - P_e} + P_e\log (n - 1)\\  =&amp;\sum_{Y, X - X^*} p(x, y) \log \frac{n - 1}{P_e} + \sum_{Y}p(x^*, y) \log \frac{1}{1 - P_e}  \end{align*}  $$</span></p><p><span class="math display">$$  \begin{align*}  左式=&amp;H(X|Y)\\  =&amp;\sum_{x, y} p(x, y) \log \frac{1}{p(x|y)}\\  =&amp;\sum_{Y, X - X^*} p(x, y) \log \frac{1}{p(x|y)} + \sum_{Y}p(x^*, y) \log \frac{1}{p(x^*|y)}  \end{align*}  $$</span></p><p>因此： <span class="math display">$$  \begin{align*}  &amp;H(X|Y) - H(P_e) - P_e \log (n - 1)\\  =&amp;\sum_{Y, X - X^*} p(x, y) \log \frac{P_e}{(n - 1) p(x|y)} +\sum_{Y} p(x^*, y) \log \frac{1 - P_e}{p(x^*|y)}\\  \leq&amp;\sum_{Y, X - X^*} p(x, y) \left[\frac{P_e}{(n - 1) p(x|y)} -1\right] + \sum_{Y} p(x^*, y) \left[\frac{1 - P_e}{p(x^*|y)} -1\right]\\  &amp;(利用\log x \leq x - 1放缩)\\  =&amp;\frac{P_e}{n - 1} \underbrace{\sum_{Y, X - X^*} p(y)}_{= n - 1}- \underbrace{\sum_{Y, X - X^*} p(x, y)}_{= P_e} + (1 - P_e) \sum_{Y}p(y) - (1 - P_e)\\  =&amp;P_e - P_e + (1 - P_e) - (1 - P_e)\\  =&amp;0  \end{align*}  $$</span></p><p>由此可得： <span class="math display"><em>H</em>(<em>X</em>|<em>Y</em>) ≤ <em>H</em>(<em>P</em><sub><em>e</em></sub>) + <em>P</em><sub><em>e</em></sub>log (<em>n</em> − 1)</span></p><p><span class="math display">$$P_e \geq \frac{H(X|Y) - 1}{\log (n -1)}$$</span></p></li></ul><h2 id="信道编码定理-2">信道编码定理</h2><p><img src="image-54.png" srcset="/img/loading/loading3.gif" lazyload></p><h3 id="错误概率与编码方法">错误概率与编码方法</h3><ul><li>转移概率如图：<img src="image-55.png" srcset="/img/loading/loading3.gif" lazyload></li><li>采用<strong>简单重复编码</strong>，<span class="math inline"><em>k</em> = 1</span> ，<span class="math inline"><em>n</em> = 3</span> ，则<span class="math inline">0 → 000</span>（<span class="math inline">$\vec{C_{1}}$</span>），<span class="math inline">1 → 111</span>（<span class="math inline">$\vec{C_{2}}$</span>）</li><li>已知信道转移概率 <span class="math inline"><em>p</em> = 0.01</span>，<span class="math inline">$\overline{p}=1-p=0.99$</span>，转移概率矩阵：<img src="image-56.png" srcset="/img/loading/loading3.gif" lazyload> <!-- $$P =\begin{bmatrix}      & 000(r_1)  & 001(r_2)  & 010(r_3)  & 011(r_4)  & 100(r_5)  & 101(r_6)  & 110(r_7)  & 111(r_8)\\  000 & (1-p)^3   & (1-p)^2p  & (1-p)^2p  & p^2(1-p)  & (1-p)^2p  & p^2(1-p)  & p^2(1-p)  & p^3\\  111 & p^3       & p^2(1-p)  & p^2(1-p)  & (1-p)^2p  & p^2(1-p)  & (1-p)^2p  & (1-p)^2p  & (1-p)^3  \end{bmatrix}$$ --></li><li>译码规则为 <span class="math inline">$F(\vec{r_{1}})=\vec{C_{1}}$</span> ，<span class="math inline">$F(\vec{r_{2}})=\vec{C_{1}}$</span> ，<span class="math inline">$F(\vec{r_{3}})=\vec{C_{1}}$</span> ，<span class="math inline">$F(\vec{r_{4}})=\vec{C_{2}}$</span> ，<span class="math inline">$F(\vec{r_{5}})=\vec{C_{1}}$</span> ，<span class="math inline">$F(\vec{r_{6}})=\vec{C_{2}}$</span> ，<span class="math inline">$F(\vec{r_{7}})=\vec{C_{2}}$</span> ，<span class="math inline">$F(\vec{r_{8}})=\vec{C_{2}}$</span> 。</li><li>错误概率 <span class="math display">$$P_e=\frac{1}{2}[p^3 + p^2(1 -p)+(1 - p)p^2 + p^2(1 - p)+p(1 - p)^2 + p^2(1 - p)+p(1 - p)^2 +p^3]\approx3\times10^{-4}$$</span></li><li>增大 <span class="math inline"><em>n</em></span>，会继续降低平均错误概率 <span class="math inline"><em>P</em><sub><em>e</em></sub></span> ：<ul><li><span class="math inline"><em>n</em> = 1</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> = 0.01</span>；</li><li><span class="math inline"><em>n</em> = 3</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 3 × 10<sup>−4</sup></span>；</li><li><span class="math inline"><em>n</em> = 5</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 10<sup>−5</sup></span>；</li><li><span class="math inline"><em>n</em> = 6</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 4 × 10<sup>−7</sup></span>；</li><li><span class="math inline"><em>n</em> = 9</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 10<sup>−8</sup></span>；</li><li><span class="math inline"><em>n</em> = 11</span> ，<span class="math inline"><em>P</em><sub><em>e</em></sub> ≈ 5 × 10<sup>−10</sup></span>。</li></ul></li><li>信息传输率 <span class="math inline">$R=\frac{H(X)}{n}=\frac{\logM}{n}=\frac{k}{n}\text{ bit/符号}$</span> 。随着 <span class="math inline"><em>n</em></span>增大，信息传输率减小。思考是否能找到一种编码方法，使 <span class="math inline"><em>P</em><sub><em>e</em></sub></span> 充分小，且<span class="math inline"><em>R</em></span> 维持在一定水平？</li></ul><h3 id="有噪信道编码定理香农第二定理">有噪信道编码定理（香农第二定理）</h3><h4 id="信道编码正定理">信道编码正定理</h4><ul><li><strong>定理</strong>：设有一离散无记忆平稳信道，其信道容量为 <span class="math inline"><em>C</em></span> ，只要待传送的信息率 <span class="math inline"><em>R</em> &lt; <em>C</em></span>，则存在一种编码，当输入长度 <span class="math inline"><em>n</em></span>足够大时，译码错误概率任意小。</li><li><strong>证明</strong>：<ul><li><p>消息序列长度为 <span class="math inline"><em>k</em></span>，个数为 <span class="math inline"><em>M</em> = 2<sup><em>k</em></sup></span> ，码长为<span class="math inline"><em>n</em></span> 。记信息传输率 <span class="math inline">$R=\frac{\log M}{n}=\frac{\log 2^k}{n}=\frac{k}{n}=C- \varepsilon$</span> （<span class="math inline"><em>ε</em> &gt; 0</span>），则 <span class="math inline"><em>k</em> = <em>n</em>(<em>C</em> − <em>ε</em>)</span>，<span class="math inline"><em>M</em> = 2<sup><em>n</em>(<em>C</em> − <em>ε</em>)</sup></span>。<strong>只需证当<span class="math inline"><em>n</em> → ∞</span> 时，可使 <span class="math inline"><em>P</em><sub><em>e</em></sub> → 0</span>。</strong></p></li><li><p><strong>编码</strong>：从 <span class="math inline">2<sup><em>n</em></sup></span> 个矢量集中找出 <span class="math inline">2<sup><em>n</em>(<em>C</em> − <em>ε</em>)</sup></span>个码字组成一组码。</p></li><li><p><strong>BSC信道</strong>：错误概率 <span class="math inline">$p&lt;\frac{1}{2}$</span> ，信道容量 <span class="math inline"><em>C</em> = 1 − <em>H</em>(<em>p</em>)</span>。</p></li><li><p>设发送码字 <span class="math inline">$\vec{C_{0}}$</span>，接收到 <span class="math inline">$\vec{r_{}}$</span> ，<span class="math inline">$\vec{C_{0}}$</span> 与 <span class="math inline">$\vec{r_{}}$</span> 之间的平均汉明距离为 <span class="math inline"><em>n</em><em>p</em></span> 。</p></li><li><p><strong>译码方法</strong>：以 <span class="math inline">$\vec{r_{}}$</span> 为球心，以 <span class="math inline"><em>n</em><em>p</em></span> 为半径的球体内寻找码字<span class="math inline">$\vec{C_{0}}$</span>。为保证译码可靠，将球体稍微扩大，令半径为 <span class="math inline"><em>n</em>(<em>p</em> + <em>ε</em>) = <em>n</em><em>p</em><sub><em>ε</em></sub></span>，<span class="math inline"><em>ε</em> &gt; 0</span> 任意小，用 <span class="math inline"><em>S</em>(<em>n</em><em>p</em><sub><em>ε</em></sub>)</span>表示这个球体。如果球体内只有一个唯一的码字，则判定这个码字为发送的码字<span class="math inline">$\vec{C_{0}}$</span> 。</p></li><li><p><strong>译码错误概率 <span class="math inline"><em>P</em><sub><em>e</em></sub></span>表达式</strong>： <span class="math display">$$  \begin{align*}  P_e &amp;= P\{\vec{C_{0}}\notinS(np_{\varepsilon})\}+P\{\vec{C_{0}}\in S(np_{\varepsilon})\}\cdotP\{\text{找到一个其他码字}\in S(np_{\varepsilon})\}\\  &amp;\leq P\{\vec{C_{0}}\notinS(np_{\varepsilon})\}+P\{\text{找到一个其他码字}\inS(np_{\varepsilon})\}  \end{align*}  $$</span></p></li><li><p>根据大数定理，<span class="math inline">$\vec{C_{0}}$</span> 与<span class="math inline">$\vec{r_{}}$</span> 之间的汉明距离（即 <span class="math inline">$\vec{C_{0}}$</span>在信道传输中错误比特数）超过平均值 <span class="math inline"><em>n</em>(<em>p</em> + <em>ε</em>)</span>的概率很小。因此当 <span class="math inline"><em>n</em></span>足够大时： <span class="math display">$$P\{\vec{C_{0}}\notinS(np_{\varepsilon})\} &lt; \delta$$</span></p><p><span class="math display">$$  \begin{align*}  P\{\text{至少有一个其他码字} \in S(np_{\varepsilon})\} &amp;\leq\sum_{\vec{C_{i}} \neq \vec{C_{0}}} P\{\vec{C_{i}} \inS(np_{\varepsilon})\} \\  &amp;\leq (M - 1)P\{\vec{C_{*}} \in S(np_{\varepsilon})\}  \end{align*}  $$</span> 其中 <span class="math inline">$P\{\vec{C_{i}} \inS(np_{\varepsilon})\} = \max_{\vec{C_{i}} \neq \vec{C_{0}}}P\{\vec{C_{i}} \in S(np_{\varepsilon})\}$</span> 。</p></li><li><p>由此可得： <span class="math display">$$P_e \leq \delta + (M -1)P\{\vec{C_{*}} \in S(np_{\varepsilon})\}$$</span> 其中<span class="math inline">$\vec{C_{*}} \neq \vec{C_{0}}$</span>，<span class="math inline">$\vec{C_{*}}$</span> 为与 <span class="math inline">$\vec{C_{0}}$</span> 距离最近的码字右式前一项与编码无关，后一项依赖于码字的选择。</p></li><li><p><strong>随机编码</strong>：从 <span class="math inline">2<sup><em>n</em></sup></span>个可能的序列中，随机选取 <span class="math inline"><em>M</em></span>个作为有效码字。每次选一个码字有 <span class="math inline">2<sup><em>n</em></sup></span> 种可能，选 <span class="math inline"><em>M</em></span> 个码字，共有 <span class="math inline">2<sup><em>n</em><em>M</em></sup></span>种不同的编码方式。</p><ul><li>对于每一种编码方式都有： <span class="math display">$$P_e \leq\delta + (M - 1)P\{\vec{C_{*}} \in S(np_{\varepsilon})\},\quad\vec{C_{*}} \neq \vec{C_{0}}$$</span></li><li>对 <span class="math inline">2<sup><em>n</em><em>M</em></sup></span>种可能的编码取平均： <span class="math display">$$E[P_e] \leq \delta +(M - 1)E[P\{\vec{C_{*}} \in S(np_{\varepsilon})\}]$$</span></li><li>于是，所有可能落在 <span class="math inline"><em>S</em>(<em>n</em><em>p</em><sub><em>ε</em></sub>)</span>内的序列总数为： <span class="math display">$$N(np_{\varepsilon}) =C_{n}^{0} + C_{n}^{1} + C_{n}^{2} + \cdots + C_{n}^{np_{\varepsilon}} =\sum_{k = 0}^{np_{\varepsilon}} C_{n}^{k}$$</span></li><li>则 <span class="math display">$$E[P\{\vec{C_{*}} \inS(np_{\varepsilon})\}] = \frac{N(np_{\varepsilon})}{2^{n}} = \sum_{k =0}^{np_{\varepsilon}} C_{n}^{k}/2^{n}$$</span></li></ul></li><li><p>引用二项式系数不等式 <span class="math inline">$\sum_{k =0}^{np_{\varepsilon}} C_{n}^{k} \leq 2^{nH(p_{\varepsilon})}$</span>（<span class="math inline">$p_{\varepsilon} &lt;\frac{1}{2}$</span>），可得：<span class="math display">$$E[P_e] \leq\delta + M2^{-n[1 - H(p_{\varepsilon})]}\quad (p_{\varepsilon} &lt;\frac{1}{2})$$</span></p><ul><li>式中 <span class="math display">$$  \begin{align*}  1 - H(p_{\varepsilon}) &amp;= 1 - H(p + \varepsilon)\\  &amp;= 1 - H(p) + H(p) - H(p + \varepsilon)\\  &amp;= C - [H(p + \varepsilon) - H(p)]  \end{align*}  $$</span></li><li>因为 <span class="math inline"><em>H</em>(<em>p</em>)</span> 是<span class="math inline"><em>p</em></span> 的上凸函数，所以有： <span class="math display">$$  \begin{align*}  H(p + \varepsilon) &amp;\leq H(p) + \varepsilon\frac{dH(p)}{dp}\\  &amp;\leq H(p) + \varepsilon\log\frac{1 - p}{p} \quad (p &lt;\frac{1}{2}, \log\frac{1 - p}{p} &gt; 0)  \end{align*}  $$</span></li><li>进而可得 <span class="math inline">$1 - H(p_{\varepsilon}) \geq C -\varepsilon\log\frac{1 - p}{p}$</span> 。</li><li>令 <span class="math inline">$\varepsilon_1 = \varepsilon\log\frac{1- p}{p}$</span> ，<span class="math inline"><em>M</em> = 2<sup><em>n</em>(<em>C</em> − <em>ε</em><sub>2</sub>)</sup></span>，则： <span class="math display"><em>E</em>[<em>P</em><sub><em>e</em></sub>] ≤ <em>δ</em> + 2<sup><em>n</em>(<em>C</em> − <em>ε</em><sub>2</sub>) − <em>n</em>(<em>C</em> − <em>ε</em><sub>1</sub>)</sup> = <em>δ</em> + 2<sup>−<em>n</em>(<em>ε</em><sub>2</sub> − <em>ε</em><sub>1</sub>)</sup></span></li><li>式中 <span class="math inline">$\varepsilon_2 - \varepsilon_1 =\varepsilon_2 - \varepsilon\log\frac{1 - p}{p}$</span> ，只要 <span class="math inline"><em>ε</em></span> 足够小，总能满足 <span class="math inline"><em>ε</em><sub>2</sub> − <em>ε</em><sub>1</sub> &gt; 0</span>。当 <span class="math inline"><em>n</em> → ∞</span> 时，<span class="math inline"><em>E</em>[<em>P</em><sub><em>e</em></sub>] → 0</span>。</li></ul></li><li><p>因为 <span class="math inline"><em>E</em>[<em>P</em><sub><em>e</em></sub>]</span>是对所有 <span class="math inline">2<sup><em>n</em><em>M</em></sup></span>种随机编码求导的平均值，所以必然存在一些码字错误概率 <span class="math inline"> &lt; <em>E</em>[<em>P</em><sub><em>e</em></sub>]</span>。故必存在一种编码，当 <span class="math inline"><em>n</em> → ∞</span>时， <span class="math inline"><em>P</em><sub><em>e</em></sub> → 0</span>。</p></li></ul></li></ul><h4 id="信道编码逆定理">信道编码逆定理</h4><ul><li><strong>逆定理</strong>：设有一离散无记忆平稳信道，其信道容量为<span class="math inline"><em>C</em></span> 。对于任意 <span class="math inline"><em>ε</em> &gt; 0</span> ，若选用码字总数 <span class="math inline"><em>M</em> = 2<sup><em>n</em>(<em>C</em> + <em>ε</em>)</sup></span>（信息传输率<span class="math inline">$R=\frac{\log M}{n}=C +\varepsilon&gt;C$</span>），则无论 <span class="math inline"><em>n</em></span>取多大，也找不到一种码，使译码错误概率 <span class="math inline"><em>P</em><sub><em>e</em></sub></span> 任意小。</li><li><strong>证明</strong>：<ul><li>已知信息传输率 <span class="math inline">$R=\frac{\log M}{n}=C +\varepsilon$</span> ，其中 <span class="math inline"><em>M</em> = 2<sup><em>n</em>(<em>C</em> + <em>ε</em>)</sup></span>为码字总数。</li><li>假设 <span class="math inline"><em>M</em></span> 个码字等概率分布<span class="math display"><em>H</em>(<em>X</em><sup><em>n</em></sup>) = log <em>M</em> = <em>n</em>(<em>C</em> + <em>ε</em>)</span><ul><li><span class="math inline"><em>n</em></span> 次扩展信道的平均互信息为<span class="math display"><em>I</em>(<em>X</em><sup><em>n</em></sup>; <em>Y</em><sup><em>n</em></sup>) = <em>H</em>(<em>X</em><sup><em>n</em></sup>) − <em>H</em>(<em>X</em><sup><em>n</em></sup>|<em>Y</em><sup><em>n</em></sup>) ≤ <em>n</em><em>C</em></span></li><li>由此可得 <span class="math display"><em>H</em>(<em>X</em><sup><em>n</em></sup>|<em>Y</em><sup><em>n</em></sup>) ≥ <em>H</em>(<em>X</em><sup><em>n</em></sup>) − <em>n</em><em>C</em> = <em>n</em><em>ε</em></span></li><li>根据费诺不等式： <span class="math display">$$  \begin{align*}  H(X^n|Y^n)&amp;\leq H(P_e,1 - P_e)+P_e\log(M - 1)\\  &amp;\leq 1+P_e\log M\\  &amp;=1+P_e n(C + \varepsilon)  \end{align*}  $$</span></li><li>由于 <span class="math inline"><em>n</em><em>ε</em> ≤ <em>H</em>(<em>X</em><sup><em>n</em></sup>|<em>Y</em><sup><em>n</em></sup>) ≤ 1 + <em>P</em><sub><em>e</em></sub><em>n</em>(<em>C</em> + <em>ε</em>)</span>，所以有： <span class="math display">$$  \begin{align*}  n\varepsilon&amp;\leq 1+P_e n(C + \varepsilon)\\  P_e&amp;\geq\frac{n\varepsilon - 1}{n(C +\varepsilon)}=\frac{\varepsilon+\frac{1}{n}}{C + \varepsilon}  \end{align*}  $$</span></li><li>当 <span class="math inline"><em>n</em> → ∞</span> 时， <span class="math inline"><em>P</em><sub><em>e</em></sub></span> 不会趋于<span class="math inline">0</span> 。</li></ul></li><li>因此，当信息传输率 <span class="math inline"><em>R</em> &gt; <em>C</em></span>时，无法完成消息的无错误传输。香农第二定理和它的逆定理表明：在任何信道中，信道容量等于进行可靠传输的最大信息传输率。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>信息论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>思想道德与法治</title>
    <link href="/posts/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/"/>
    <url>/posts/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="绪论-担当复兴大任-成就时代新人">绪论 担当复兴大任成就时代新人</h1><ul><li>新时代是我们理解当前所处历史方位的关键词。</li><li>肩负历史使命，立大志、明大德、成大才、担大任，努力成为堪当民族复兴大任的时代新人。<ul><li><strong>立大志</strong>，就是要有崇高的理想信念，牢记使命，自信自励。</li><li><strong>明大德</strong>，就是要锤炼高尚品格，崇德修身，启润青春。</li><li><strong>成大才</strong>，就是要有高强的本领才干，勤奋学习，全面发展。</li><li><strong>担大任</strong>，就是要有天下兴亡、匹夫有责的担当精神，讲求奉献，实干进取。</li></ul></li></ul><h1 id="第一章-领悟人生真谛-把握人生方向">第一章 领悟人生真谛把握人生方向</h1><h2 id="人生观是对人生的总看法">人生观是对人生的总看法</h2><ul><li>人生观的定义：<ul><li>人生观就是人们关于<strong>人生目的</strong>、<strong>人生态度</strong>、<strong>人生价值</strong>等问题的总观点和总看法。</li></ul></li><li>马克思主义关于人的本质的认识：<ul><li>“人是一切<strong>社会关系</strong>的总和。”<strong>社会属性是人的本质属性</strong>。</li></ul></li><li>个人与社会的辩证关系：<ul><li>个人与社会是<strong>对立统一</strong>的关系，两者相互依存、相互制约、相互促进。</li><li>个人与社会的关系，最<strong>根本</strong>的是个人利益与社会利益的关系。</li><li>人的<strong>社会性</strong>决定了人只有在推动社会进步的过程中，才能实现自我的发展。</li></ul></li><li>人生观的主要内容：<ul><li>人生观的主要内容包括对<strong>人生目的、人生态度和人生价值</strong>等问题的根本看法。</li><li>人生目的是人们在社会实践中关于自身行为的根本指向和人生追求，是人生观的<strong>核心</strong>：<ul><li>首先，人生目的决定人生道路。</li><li>其次，人生目的决定人生态度。</li><li>最后，人生目的决定人生价值选择。</li></ul></li><li>人生态度是指人们通过生活事件形成的对人生问题的一种相对稳定的心理倾向和精神状态。</li><li>人生价值是指人的生命及其实践活动对于社会和个人所具有的作用和意义，内在包含自我价值和社会价值，既相互区别，又密切联系、相互依存。</li></ul></li><li>世界观是人们对生活在其中的世界以及人与世界的关系的总体看法和根本观点，世界观决定人生观，有什么样的世界观，就会有什么样的人生观。</li><li>价值观是人们价值的根本观点，对于人生观的形成和发展有重要的引导作用。</li></ul><h2 id="正确的人生观">正确的人生观</h2><ul><li>高尚的人生追求：<ul><li>服务人民、奉献社会的思想以其科学而高尚的品质，代表了人类社会迄今最先进的人生追求。</li></ul></li><li>积极进取的人生态度：<ul><li>人生须<strong>认真</strong>。</li><li>人生当<strong>务实</strong>。</li><li>人生应<strong>乐观</strong>。</li><li>人生要<strong>进取</strong>。</li></ul></li><li>评价人生价值：<ul><li>根本尺度：实践活动是否符合社会的客观规律，是否促进了历史的进步。</li><li>今天的衡量标准：是否用自己的劳动和聪明才智为国家和社会真诚奉献，为人民尽心尽力服务<ul><li>既要看贡献的大小，又要看尽力的程度；</li><li>既要看物质贡献，又要看精神贡献；</li><li>既要看社会贡献，又要看自身完善。</li></ul></li></ul></li><li>人生价值的实现条件：<ul><li>实现人生价值要从社会客观条件出发。</li><li>实现人生价值要从个体自身条件出发。</li><li>不断增强实现人生价值的能力和本领，努力发挥主观能动性。</li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-e682c201" role="button" aria-expanded="false" aria-controls="collapse-e682c201">        <div class="fold-arrow">▶</div>服务人民、奉献社会的人生追求过时了吗？      </div>      <div class="fold-collapse collapse" id="collapse-e682c201">        <div class="fold-content">          <p>在现实生活中有人提出这样的疑惑：社会主义市场经济条件下，讲究的是按劳分配、等价交换，在这种背景下倡导服务人民、奉献社会的人生追求是否合适？换言之，服务人民、奉献社会的人生追求是否过时了？</p><p>社会主义市场经济鼓励人们追求个人的正当利益，因为只有各市场主体的正当利益得到满足，经济才更有活力。但同时，<strong>各市场主体正当利益的满足，不仅有赖于其他人的劳动和付出，而且需要公平有序的市场环境</strong>。</p><p>只有每个个体尽心尽力地为他人、为社会付出应有劳动，才能<strong>保证社会主义市场经济的良好运行</strong>，个体也才能在为社会发展进步<strong>作贡献的同时满足自身利益</strong>。因此，服务人民、奉献社会的人生追求与社会主义市场经济并不矛盾、并未过时。</p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-d37fae99" role="button" aria-expanded="false" aria-controls="collapse-d37fae99">        <div class="fold-arrow">▶</div>当代青年能否选择“躺平”？      </div>      <div class="fold-collapse collapse" id="collapse-d37fae99">        <div class="fold-content">          <p>近年来，“躺平”在年轻人的社交网络上成为一个热词。关于“躺平”一词的确切含义，目前并未形成共识，甚至还有较大争议。“躺平”作为一种生活态度，往往与年轻人在压力面前主动选择放弃、回避与退却有关。个人在法律和道德允许的范围内选择自己生活方式的权利应受到尊重，但当代青年也应深入思考能否把“躺平”作为生活方式和人生道路来选择。</p><p>人们在成长的过程中，总会面临各种各样的现实压力，甚至还会遭遇挫折，以“躺平”的方式<strong>主动退缩、选择放弃，无益于解决问题，甚至会使问题更加复杂和严重</strong>。唯有树立<strong>积极面对、主动进取的人生态度，才能够克服前进道路上的种种困难</strong>。当代青年正处于探索与奋斗的大好时期，应该发扬自强不息、百折不挠的精神，保持年轻人的蓬勃朝气、昂扬锐气，在创新创造、不断奋斗中，成长为实现中华民族伟大复兴的先锋力量。</p>        </div>      </div>    </div><h2 id="创造有意义的人生">创造有意义的人生</h2><ul><li>辩证对待人生矛盾，正确看待：<ul><li>得与失。</li><li>苦与乐。</li><li>顺与逆。</li><li>生与死。</li><li>荣与辱。</li></ul></li><li>反对错误人生观：<ul><li>拜金主义。</li><li>享乐主义。</li><li>极端个人主义。</li></ul>拜金主义、享乐主义、极端个人主义没有正确地把握个人和社会的辩证关系，忽视或者否认社会性是人的存在和活动的本质属性，对人的需要的理解极端、狭隘和片面，其出发点和落脚点都是一己之私利。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-9c950e4d" role="button" aria-expanded="false" aria-controls="collapse-9c950e4d">        <div class="fold-arrow">▶</div>消费越多，人生就越幸福吗？      </div>      <div class="fold-collapse collapse" id="collapse-9c950e4d">        <div class="fold-content">          <p>有人认为，人生的意义体现为消费的质和量，消费得越多，人生就越幸福。这属于消费主义思潮的一种观点，这种观点是错误的。从人生观层面来看，消费主义思潮把占有和消费物质产品作为个人自我满足和快乐的第一位要求，通过物质的占有和消耗来达到心理上的满足、感官上的享受，把消费当作人生的终极目标，把消费看作人生最大的幸福。受消费主义思潮影响，一些人会产生错误的想法和做法：一是出现超前消费、攀比消费等非理性消费行为；二是产生错误的<strong>价值观</strong>，表现为贪图享乐、爱慕虚荣、功利心作祟等；三是产生错误的<strong>认同</strong>倾向，表现为通过消费来“从众”或“立异”；四是过度被动消费，影响正常工作生活。</p>        </div>      </div>    </div><h1 id="第二章-追求远大理想-坚定崇高信念">第二章 追求远大理想坚定崇高信念</h1><h2 id="理想信念的内涵及重要性">理想信念的内涵及重要性</h2><ul><li>理想的内涵：<ul><li>理想是人们在<strong>实践中形成</strong>的、<strong>有实现可能性的</strong>、对未来社会和自身发展目标的<strong>向往和追求</strong>，是人们的世界观、人生观和价值观在奋斗目标上的集中体现。</li></ul></li><li>特征：<ul><li><strong>超越性</strong>。</li><li><strong>实践性</strong>。</li><li><strong>时代性</strong>。</li></ul></li><li>信念的内涵：<ul><li>信念是人们在<strong>一定的认识基础</strong>上确立的对某种思想或者事物坚信不疑并身体力行的精神状态。</li></ul></li><li>特征：<ul><li><strong>执着性</strong>。</li><li><strong>支撑性</strong>。</li><li><strong>多样性</strong>。</li></ul></li><li>理想信念是精神之“钙”：<ul><li>理想信念昭示奋斗目标。</li><li>理想信念催生前进动力。</li><li>理想信念提供精神支柱。</li><li>理想信念提高精神境界。</li></ul></li></ul><h2 id="坚定信仰信念信心">坚定信仰信念信心</h2><ul><li>对马克思主义、共产主义的<strong>信仰</strong>。</li><li>对中国特色社会主义的<strong>信念</strong>。</li><li>对实现中华民族伟大复兴的<strong>信心</strong>。</li><li>为什么信仰马克思主义？<ul><li>马克思主义是我们认识世界、改造世界的强大思想武器。</li><li>马克思主义是科学的理论，创造性地揭示了人类社会发展规律。</li><li>马克思主义是人民的理论，第一次创立了人民实现自身解放的思想体系（<strong>人民性是马克思主义的本质属性</strong>）。</li><li>马克思主义是实践的理论，指引着人民改造世界的行动。</li><li>马克思主义是不断发展的开放的理论，始终站在时代前沿。</li></ul></li></ul><h2 id="在实现中国梦的实践中放飞青春梦想">在实现中国梦的实践中放飞青春梦想</h2><ul><li>理想与现实对立统一：<ul><li>对立：二者的矛盾与冲突，是“应然”和“实然”的矛盾。</li><li>统一：理想受现实的规定和制约，是在对现实认识的基础上发展起来的（现实孕育理想的发展，理想包含现实的内容）。</li></ul></li><li>实现理想存在<strong>长期性、艰巨性和曲折性</strong>。<strong>艰苦奋斗</strong>是实现理想的重要条件。</li><li>个人理想：<ul><li>处于一定历史条件和社会关系中的个体对于自己未来的物质生活、精神生活所产生的向往和追求</li></ul></li><li>社会理想：<ul><li>社会集体乃至社会全体成员的共同理想，即在全社会占主导地位的共同奋斗目标</li><li>个人理想与社会理想的关系实质上是个人与社会关系在理想层面的反映</li></ul></li><li>个人理想与社会理想：个人与社会有机地联系在一起，二者相互依存、相互制约、共同发展。<ul><li>个人理想以社会理想为指引。</li><li>社会理想是个人理想的汇聚与升华。</li><li>得其大者可以兼其小。</li></ul></li><li>实现中国梦：<ul><li>立鸿鹄志，做奋斗者。</li><li>心怀“国之大者”，敢于担当。</li><li>自觉躬身实践，知行合一。</li></ul></li></ul><h1 id="第三章-继承优良传统-弘扬中国精神">第三章 继承优良传统弘扬中国精神</h1><h2 id="中国精神是兴国强国之魂">中国精神是兴国强国之魂</h2><ul><li>中国精神作为<strong>兴国强国之魂</strong>，是实现中华民族伟大复兴不可或缺的精神支撑。</li><li>崇尚精神是中华民族的优秀传统：<ul><li>中华民族崇尚精神的优秀传统，首先表现为对物质生活与精神生活相互关系的独到理解。</li><li>中华民族崇尚精神的优秀传统，也表现为对理想的不懈追求。</li><li>中华民族崇尚精神的优秀传统，亦表现为对品格养成的重视。</li></ul></li><li>中国精神：<ul><li><strong>伟大创造精神</strong>。</li><li><strong>伟大奋斗精神</strong>。</li><li><strong>伟大团结精神</strong>。</li><li><strong>伟大梦想精神</strong>。</li></ul></li><li><strong>伟大建党精神</strong>是中国共产党的精神之源：坚持真理、坚守理想，践行初心、担当使命，不怕牺牲、英勇斗争，对党忠诚、不负人民。</li><li>全面建设社会主义现代化国家、全面推进中华民族伟大复兴，必须大力弘扬中国精神，弘扬<strong>以爱国主义为核心的民族精神</strong>和<strong>以改革创新为核心的时代精神</strong>。</li><li>爱国主义的基本内涵：<ul><li>一是爱祖国的大好河山。</li><li>二是爱自己的骨肉同胞。</li><li>三是爱祖国的灿烂文化。</li><li>四是爱自己的国家。</li></ul></li><li>时代精神：<ul><li>一个国家和民族在<strong>新的历史条件下</strong>形成和发展的，<strong>体现民族特质</strong>并<strong>顺应时代潮流</strong>的思想观念、价值取向、精神风貌和社会风尚的总和。</li></ul></li><li>弘扬以改革创新为核心的时代精神：<ul><li>就是要树立突破陈规、大胆探索、敢于创造的思想观念。</li><li>就是要培养不甘落后、奋勇争先、追求进步的责任感和使命感。</li><li>就是要保持坚忍不拔、自强不息、锐意进取的精神状态。</li></ul></li></ul><h2 id="做新时代的忠诚爱国者">做新时代的忠诚爱国者</h2><ul><li>必须坚持：<ul><li>爱国爱党爱社会主义相统一</li><li>维护祖国统一和民族团结</li><li>尊重和传承中华民族历史文化</li><li>坚持立足中国又面向世界</li></ul></li><li>怎么做：<ul><li>坚持爱国爱党爱社会主义相统一。</li><li>维护祖国统一和民族团结。</li><li>尊重和传承中华民族历史文化（反对历史虚无主义）。</li><li>坚持立足中国又面向世界。<ul><li>维护国家发展主体性。</li><li>自觉维护国家安全。</li><li>推动构建人类命运共同体。</li></ul></li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-5692881c" role="button" aria-expanded="false" aria-controls="collapse-5692881c">        <div class="fold-arrow">▶</div>经济全球化背景下还需要爱国主义吗？      </div>      <div class="fold-collapse collapse" id="collapse-5692881c">        <div class="fold-content">          <p>当今世界，各国的贸易往来更加频繁，文化交流不断加深，世界正在变成一个“地球村”。虽然经济全球化对爱国主义造成了较大冲击，但是爱国主义在今天仍然有其存在的理由。经济全球化是社会生产力发展的客观要求和科技进步的必然结果。在经济全球化背景下，各个国家之间的利益冲突和竞争强度没有减弱，一定程度上还强化了人们的爱国主义情感。经济全球化不等于政治全球化，更不意味着政治一体化，只要国家存在，爱国主义就有坚实的基础和丰富的意义。</p>        </div>      </div>    </div><h2 id="让改革创新成为青春远航的动力">让改革创新成为青春远航的动力</h2><ul><li>现在，我国已转向高质量发展阶段，全面深化改革，推进国家治理体系和治理能力现代化，必须将改革进行到底。</li><li>创新是推动人类社会发展的重要力量。</li><li>创新能力是当今国际竞争新优势的集中体现。</li><li>改革创新是赢得未来的必然要求。</li><li>做改革创新生力军：<ul><li>树立改革创新的自觉意识<ul><li>增强改革创新的责任感。</li><li>树立大胆探索未知领域的信心。</li></ul></li><li>增强改革创新的能力本领<ul><li>夯实创新基础。</li><li>培养创新思维。</li><li>投身改革创新实践。</li></ul></li></ul></li></ul><h1 id="第四章-明确价值要求践行价值准则">第四章明确价值要求践行价值准则</h1><h2 id="全体人民共同的价值追求">全体人民共同的价值追求</h2><ul><li>价值观定义：价值观就是主体对客体有无价值、价值大小的立场和态度，是对价值及其相关内容的基本观点和看法。<ul><li>价值观反映着特定的<strong>时代精神</strong>。</li><li>价值观体现着鲜明的<strong>民族特色</strong>。</li><li>价值观蕴含着特定的<strong>阶级立场</strong>。</li><li>核心价值观是一定社会形态、社会性质的集中体现，在一个社会的思想观念体系中处于<strong>主导地位</strong>，体现着社会制度的阶级属性、社会运行的基本原则和社会发展的基本方向。</li></ul></li><li>社会主义核心价值观三个层面：国家、社会、公民<ul><li>国家层面：富强、民主、文明、和谐。</li><li>社会层面：自由、平等、公正、法治。</li><li>公民层面：爱国、敬业、诚信、友善。</li></ul></li><li>为什么坚持社会主义核心价值观：<ul><li>坚持和发展中国特色社会主义的价值遵循。</li><li>提高国家文化软实力的迫切要求。</li><li>推进社会团结奋进的“最大公约数”。</li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6ec3c25c" role="button" aria-expanded="false" aria-controls="collapse-6ec3c25c">        <div class="fold-arrow">▶</div>为什么只有在社会主义社会，人民才有可能真正实现平等？      </div>      <div class="fold-collapse collapse" id="collapse-6ec3c25c">        <div class="fold-content">          <p>存在剥削制度与剥削阶级的社会中，平等不可能真正实现。资本主义私有制是社会分配不公的制度根源，必然导致社会贫富分化和阶级对立。只有在社会主义社会中，生产资料公有制代替私有制，剥削制度不复存在，人民才有真正实现平等的可能。</p>        </div>      </div>    </div><h2 id="社会主义核心价值观的显著特征">社会主义核心价值观的显著特征</h2><ul><li>社会主义核心价值观的显著特征：<strong>先进性、人民性、真实性</strong>。<ul><li><strong>先进性</strong>：反映人类社会发展进步的价值理念<ul><li>体现社会主义的本质属性：“社会主义”是社会主义核心价值观的“底色”社会主义核心价值观的先进性，集中体现在它是社会主义所坚持和追求的价值理念。</li><li>扎根中华优秀传统文化土壤。</li></ul></li><li><strong>人民性</strong>：彰显人民至上的价值立场。人民性是社会主义核心价值观的<strong>根本特性</strong>。<ul><li>尊重人民群众历史主体地位。</li><li>体现以人民为中心的价值导向。</li></ul></li><li><strong>真实性</strong>：因真实可信而具有强大的道义力量（西方“普世价值”在理论和实践上都是虚伪的，我们的全人类共同价值才是可靠的）。<ul><li>社会主义核心价值观是真实可信的。</li><li>认清西方“普世价值”的实质。</li></ul></li></ul></li><li><strong>全人类共同价值</strong>：和平、发展、公平、正义、民主、自由。</li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-24573d50" role="button" aria-expanded="false" aria-controls="collapse-24573d50">        <div class="fold-arrow">▶</div>全人类共同价值与所谓“普世价值”存在根本不同      </div>      <div class="fold-collapse collapse" id="collapse-24573d50">        <div class="fold-content">          <p>反对西方所谓的“普世价值”，<strong>并不是说人类社会不存在共同价值</strong>。</p><p>2021年7月1日，习近平强调：“中国共产党将继续同一切爱好和平的国家和人民一道，弘扬和平、发展、公平、正义、民主、自由的全人类共同价值，坚持合作、不搞对抗，坚持开放、不搞封闭，坚持互利共赢、不搞零和博弈，反对箱权主义和强权政治，推动历史车轮向着光明的目标前进！”</p><p>人类生活在同一个地球村里，越来越成为你中有我、我中有你的命运共同体，客观存在共同利益，必然要求共同价值。我们所主张的共同价值，是要倡导<strong>求同存异、和而不同</strong>，充分尊重文明的<strong>多样性</strong>，尊重各国<strong>自主选择</strong>社会制度和发展道路的权利。这与<strong>唯我独尊</strong>、<strong>强施于人</strong>、旨在推行<strong>资本主义</strong>政治理念和制度模式的所谓“普世价值”根本不同。</p><ul><li><strong>理论上的虚伪性</strong><ul><li>资产阶级价值观伪装成普世的</li><li>鼓吹抽象“人性论”</li><li>没有放之四海而皆准的价值</li><li>实质是为资产阶级服务</li></ul></li><li><strong>实践上的虚伪性</strong></li></ul>        </div>      </div>    </div><h2 id="积极践行社会主义核心价值观">积极践行社会主义核心价值观</h2><ul><li>把社会主义核心价值观落细落小落实。<ul><li>勤学。下得苦功夫，求得真学问。</li><li>修德。加强道德修养，注重道德实践。</li><li>明辨。善于明辨是非，善于决断选择。</li><li>笃实。扎扎实实干事，踏踏实实做人。</li></ul></li></ul><h1 id="第五章-遵守道德规范-锤炼道德品格">第五章 遵守道德规范锤炼道德品格</h1><h2 id="社会主义道德的核心与原则">社会主义道德的核心与原则</h2><ul><li>道德是一种特殊的社会意识形态，它是以善恶为评价方式，主要依靠社会舆论、传统习俗和内心信念来发挥作用的行为规范的总和。</li><li>道德的起源与本质：<ul><li><strong>劳动</strong>是道德起源的首要前提。</li><li>社会关系是道德赖以产生的客观条件。</li><li>人的自我意识是道德产生的主观条件。</li></ul></li><li>道德是反映社会经济关系的特殊意识形态：<ul><li>其一，道德的性质和基本原则、规范反映了与之相应的社会经济关系的性质和内容。</li><li>其二，道德随着社会经济关系的变化而变化。</li><li>其三，道德作为一种社会意识，在阶级社会里总是反映着一定阶级的利益，因而不可避免地具有阶级性。</li></ul></li><li>道德是社会利益关系的特殊调节方式。</li><li>道德的<strong>功能</strong>：<ul><li><strong>认识</strong>功能。</li><li><strong>规范</strong>功能。</li><li><strong>调节</strong>功能。</li></ul></li><li>道德的<strong>作用</strong>：<ul><li>道德的认识、规范、调节、激励、导向、教育等功能的发挥和实现所产生的社会影响及实际效果。</li></ul></li><li>人类道德发展的历史过程与社会生产方式的发展进程大体一致，这是<strong>道德发展的基本规律</strong>。</li><li>社会主义道德具有显著的先进性特征：<ul><li>首先，社会主义道德是社会主义经济基础的反映。</li><li>其次，社会主义道德是对人类优秀道德资源的批判继承和创新发展。</li><li>最后，社会主义道德克服了以往阶级社会道德的片面性和局限性，坚持以为人民服务为核心，坚持以集体主义为原则，展现出真实而强大的道义力量。</li></ul></li><li><strong>坚持以为人民服务为核心，坚持以集体主义为原则</strong>。</li><li>道德原则是道德规范体系的总纲。</li><li>三个层次的道德：<ul><li>一是无私奉献、一心为公。</li><li>二是先公后私、先人后己。</li><li>三是顾全大局、遵纪守法、热爱祖国、诚实劳动，以正当合法的手段保障个人利益。</li></ul></li></ul><h2 id="吸收借鉴优秀道德成果">吸收借鉴优秀道德成果</h2><ul><li>中华传统美德的基本精神：<ul><li>重视整体利益，强调责任奉献。</li><li>推崇仁爱原则，注重以和为贵。</li><li>注重人伦关系，重视道德义务。</li><li>追求精神境界，向往理想人格。</li><li>强调道德修养，注重道德践履。</li></ul></li><li><strong>传统道德</strong>是一个矛盾体，具有鲜明的两重性：<ul><li>属于精华的部分，表现出积极、革新、进步的一面；</li><li>属于糟粕的部分，则表现出消极、保守、落后的一面。</li></ul></li><li>在对待传统道德的问题上，要反对两种错误思潮。一种是“复古论”，认为道德建设的最终目标就是要恢复中国“固有文化”，形成以中国传统文化为主体的道德体系；另一种是“虚无论”，认为中国传统道德从整体上来说在今天已经失去了价值和意义，必须从整体上予以全盘否定。</li><li>革命道德：<ul><li>为实现社会主义和共产主义的理想而奋斗。</li><li>全心全意为人民服务。</li><li>始终把革命利益放在首位。</li><li>树立社会新风，建立新型人际关系。</li><li>修身自律，保持节操。</li></ul></li><li>革命道德当代价值：<ul><li>有利于加强和巩固社会主义和共产主义的理想信念。</li><li>有利于培育和践行社会主义核心价值观。</li><li>有利于引导人们树立正确的道德观。</li><li>有利于培育良好的社会道德风尚。</li></ul></li></ul><h2 id="投身崇德向善的道德实践">投身崇德向善的道德实践</h2><ul><li>社会公德：<ul><li>每一个社会成员，都应遵守以文明礼貌、助人为乐、爱护公物、保护环境、遵纪守法为主要内容的社会公德。</li></ul></li><li>网络道德：<ul><li>正确使用网络工具。</li><li>加强网络文明自律。</li><li>营造良好网络道德环境。</li></ul></li><li>职业道德：<ul><li>爱岗敬业、诚实守信、办事公道、热情服务和奉献社会是职业生活中的基本道德规范。</li></ul></li><li>家庭美德：<ul><li>注重家庭、注重家教、注重家风，遵守恋爱、婚姻家庭生活中的道德规范，树立正确的恋爱观和婚姻观，有利于大学生的健康成长、顺利成才。</li></ul></li><li>恋爱道德：<ul><li>尊重人格平等、自觉承担责任和文明相亲相爱。</li></ul></li><li>锤炼个人品德：<ul><li>涵养高尚道德品格。</li><li>道德修养重在践行。</li><li>积极引领社会风尚。</li></ul></li></ul><h1 id="第六章-学习法治思想-提升法治素养">第六章 学习法治思想提升法治素养</h1><h2 id="社会主义法律的特征和运行">社会主义法律的特征和运行</h2><ul><li>定义：<ul><li>法律是由<strong>国家制定或认可</strong>并<strong>由国家强制力保证实施</strong>的，反映由特定社会物质生活条件所决定的<strong>统治阶级意志</strong>的规范体系。<ul><li>强制性：法律是<strong>由国家创制和实施的行为规范</strong></li><li>社会性：法律由一定的<strong>社会物质生活条件</strong>所决定</li><li>阶级性：法律是<strong>统治阶级意志</strong>的体现</li></ul></li></ul></li><li>法律不是从来就有的，也不是永恒存在的。它随着私有制、阶级和国家的产生而产生，也将随着私有制、阶级和国家的消亡而消亡。</li><li>我国社会主义法律的本质特征：<ul><li>我国社会主义法律体现了党的主张和人民意志的统一。</li><li>我国社会主义法律具有科学性和先进性。</li><li>我国社会主义法律是中国特色社会主义建设的重要保障。</li></ul></li><li>法律的运行：<ul><li>法律制定<ul><li>全国人民代表大会和全国人民代表大会常务委员会行使国家立法权。</li><li>国务院有权根据宪法和法律制定行政法规。</li><li>国家监察委员会有权根据宪法和法律制定监察法规。</li><li>中央军事委员会有权根据宪法和法律制定军事法规。</li></ul></li><li>法律执行</li><li>法律适用<ul><li>在我国，司法机关是指国家审判机关和检察机关。人民法院依照法律规定独立行使审判权，人民检察院依照法律规定独立行使检察权。</li></ul></li><li>法律遵守</li></ul></li></ul><h2 id="坚持全面依法治国">坚持全面依法治国</h2><ul><li>坚持中国特色社会主义法治道路必须遵循的原则：<ul><li><strong>坚持中国共产党的领导</strong>。</li><li><strong>坚持人民主体地位</strong>。</li><li><strong>坚持法律面前人人平等</strong>。</li><li><strong>坚持依法治国和以德治国相结合</strong>。<ul><li>既要强化道德对法治的支撑作用，重视发挥道德的教化作用，提高全社会文明程度，为全面依法治国创造良好环境；</li><li>又要把道德要求贯彻到法治建设中，以法治承载道德理念。</li></ul></li><li><strong>坚持从中国实际出发</strong>。</li></ul></li><li>建设中国特色社会主义法治体系：<ul><li>完备的法律规范体系。</li><li>高效的法治实施体系。</li><li>严密的法治监督体系。</li><li>有力的法治保障体系。</li><li>完善的党内法规体系。</li></ul></li><li>坚持全面推进科学立法、严格执法、公正司法、全民守法：<ul><li><strong>科学立法</strong>是全面依法治国的<strong>前提</strong>。</li><li><strong>严格执法</strong>是全面依法治国的<strong>关键</strong>。</li><li><strong>公正司法</strong>是全面依法治国的<strong>重点</strong>。</li><li><strong>全民守法</strong>是全面依法治国的<strong>基础</strong>。</li></ul></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-6229eb14" role="button" aria-expanded="false" aria-controls="collapse-6229eb14">        <div class="fold-arrow">▶</div>为什么说“党大还是法大”是个伪命题?      </div>      <div class="fold-collapse collapse" id="collapse-6229eb14">        <div class="fold-content">          <p>“党大还是法大”是一个<strong>政治陷阱</strong>，是一个<strong>伪命题</strong>。党的领导和依法治国不是对立的，而是<strong>统一</strong>的。我国法律充分体现了党和人民意志，我们党依法办事，这个关系是相互统一的关系。从逻辑上讲，党的本质是<strong>政治组织</strong>，而法的本质是<strong>行为规则</strong>，<strong>两者不存在谁比谁大的问题</strong>，否则就会落入话语陷阱。如果说党比法大，那就是承认法治、依法治国都是虚假的，法就不存在了；如果说法比党大，那党的领导就难以实施了。因此，在党和法之间不能搞简单的比较。</p><p>当然，我们说不存在“党大还是法大”的问题，是把党作为一个<strong>执政整体、就党的执政地位和领导地位而言</strong>的，具体到<strong>每个党政组织、每个领导干部</strong>，就<strong>必须服从和遵守宪法法律</strong>。“权大还是法大”则是一个真命题。纵观人类政治文明史，权力是一把“双刃剑”，在法治的轨道上行使可以造福人民，在法律之外行使必然祸害国家和人民。</p>        </div>      </div>    </div><h2 id="维护宪法权威">维护宪法权威</h2><ul><li>坚持依法治国首先要坚持依宪治国，坚持依法执政首先要坚持依宪执政。</li><li>1954年宪法是中华人民共和国第一部宪法。</li><li>我国现行宪法即1982年宪法。</li><li>我国宪法的地位：<ul><li>我国宪法是国家的<strong>根本法</strong>，是党和人民意志的集中体现。</li><li>我国宪法是国家各项制度和法律法规的总依据。</li><li>我国宪法规定了国家的根本制度。</li><li>宪法是实现国家认同、凝聚社会共识、促进个人发展的基本准则，是维系一个国家、一个民族凝聚力的根本纽带。</li></ul></li><li>我国宪法的基本原则：<ul><li>党的领导原则。</li><li>尊重和保障人权原则。</li><li>社会主义法治原则。</li><li>民主集中制原则。</li></ul></li></ul><h2 id="自觉尊法学法守法用法">自觉尊法学法守法用法</h2><ul><li>法治思维及其内涵：<ul><li>法治思维是指以法治价值和法治精神为导向，运用法律原则、法律规则、法律方法思考和处理问题的思维模式。</li></ul></li><li>法治思维的基本内容：<ul><li>法律至上。</li><li>权力制约。</li><li>公平正义。</li><li>权利保障。</li><li>程序正当。</li></ul></li><li>在社会生活中，每个人既是享受法律权利的主体，又是承担法律义务的主体。<ul><li>在法治国家，不存在只享受权利的主体，也不存在只承担义务的主体。</li><li>法律权利的实现必须以相应法律义务的履行为条件；</li><li>法律义务的设定和履行也必须以法律权利的行使为根据。</li></ul></li><li>我国宪法法律规定的权利：<ul><li>政治权利、宗教信仰自由、人身权利、财产权利、社会经济权利及文化教育权利。</li></ul></li><li>大学生要尊重法律权威、学习法律知识、养成守法习惯、提高用法能力，不断提升自己的法治素养。</li></ul>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>思想道德与法治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络空间安全导论</title>
    <link href="/posts/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/"/>
    <url>/posts/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-网络空间安全概述">第一章 网络空间安全概述</h1><h2 id="第一节-信息时代及信息安全">第一节 信息时代及信息安全</h2><h3 id="网络空间安全-初步接触">网络空间安全-初步接触</h3><p>信息时代特征</p><ol type="1"><li>新摩尔定律</li><li>吉尔德定律</li><li>千倍定律</li></ol><h3 id="当前网络信息安全态势">当前网络信息安全态势</h3><ol type="1"><li><strong>信息技术与产业空前繁荣</strong></li><li><strong>量子信息技术高速发展</strong></li><li><strong>信息安全形势严峻，危机四伏的网络世界</strong></li><li><strong>敌对势力破坏</strong></li><li><strong>黑客组织攻击</strong></li><li><strong>计算机病毒入侵</strong></li><li><strong>利用计算机进行经济犯罪</strong></li><li><strong>有害内容泛滥、隐私保护问题严重</strong></li><li><strong>网络安全形式严峻</strong><ul><li>信息战 网络战</li><li>网络空间安全对抗愈益加剧</li><li>信息技术对信息安全的挑战</li></ul></li><li><strong>国家对信息安全的重视</strong></li></ol><h3 id="网络信息安全发展趋势">网络信息安全发展趋势</h3><ol type="1"><li>网络信息安全已成为关系社会、文化、经济、军事乃至国家安全的重大战略问题。<ul><li>网络信息安全成为重大战略问题，涉及国家安全各方面，网络犯罪造成巨大经济损失，美国成立网络司令部加强网络空间争夺。</li></ul></li><li>网络安全威胁层出不穷，网络关键基础设施隐患重重。<ul><li>网络安全威胁不断，关键基础设施受攻击影响重大，黑客攻击针对性增强，恶意代码增长迅速。</li></ul></li><li>网络空间国家间的竞争与合作日趋凸显。<ul><li>网络空间国家间竞争合作凸显，“军备竞赛”开始，多国组建网络战部队，斯诺登事件引发网络空间新型对抗。</li></ul></li><li>国际互联网治理领域迎来新热潮，信息资源保护成为各国焦点<ul><li>国际互联网治理成热潮，信息资源保护受关注，网络基础设施漏洞威胁全球，各国重视互联网治理权。</li></ul></li></ol><h2 id="第二节-法律法规及标准概述">第二节 法律法规及标准概述</h2><h3 id="学科内涵">学科内涵</h3><ul><li><p><strong>网络空间安全的定义与内涵</strong></p><ul><li>网络空间是信息时代人类赖以生存的信息环境，是所有信息系统的集合。它以计算机和网络系统实现的信息化为特征。</li><li>网络空间是人的生存环境，也是信息的生存环境。</li><li>网络空间安全研究网络空间中安全威胁与防护问题。</li><li>核心内涵为信息安全。</li></ul></li><li><p><strong>信息的安全属性—C.I.A三要素</strong></p><ul><li><strong>机密性</strong>是指保证信息与信息系统不被非授权者截获和未经授权使用。</li><li><strong>完整性</strong>是指信息是完整的，真实的、未被篡改的、正确的。</li><li><strong>可用性</strong>是指信息与信息系统服务可被授权人正常使用</li><li>其它基本要素：非否认性、可控性</li></ul></li><li><p><strong>信息系统安全层次结构</strong></p><ul><li><strong>设备安全</strong>：信息系统设备的安全是是信息系统安全的物质基础，是信息系统安全的首要问题，软硬件系统的安全（稳定、可靠、可用）</li><li><strong>行为安全</strong>：主体行为的过程和结果来考察是否会危害信息安全，数据安全本质上是一种静态的安全，而行为体现在过程和结果之中，行为安全是一种动态安全。</li><li><strong>数据安全</strong>：数据免受未授权的泄露、篡改和毁坏。数据安全本质上是一种静态的安全，而行为体现在过程和结果之中，行为安全是一种动态安全。</li><li><strong>内容安全</strong>：信息安全在政治、法律、道德层次上的要求，是语义层次的安全，内容安全还包括信息内容保密、知识产权保护、信息隐藏和隐私保护等诸多方面</li></ul></li><li><p><strong>信息安全三大定律</strong></p><ul><li>普遍性定律指出有信息就有安全问题；</li><li>折中性定律表明安全与方便是矛盾体；</li><li>就低性定律说明系统安全性取决于最薄弱部分（木桶原理）。</li></ul></li><li><p><strong>网络空间安全学科定义</strong></p><ul><li>网络空间安全学科是研究信息获取、信息存储、信息传输和信息处理领域中信息安全保障问题的一门新兴学科。</li></ul></li><li><p><strong>理论基础</strong></p><ul><li>数学：数论、代数、组合数学、概率统计等数学分支，是密码学的理论基础</li><li>逻辑学是网络协议安全基础：协议是网络的核心，协议安全是网络安全的核心。</li><li>博弈论是网络空间安全特有理论</li><li>信息论、控制论和系统论是现代科学的理论基础：信息论是密码学和信息隐藏基础，系统论核心是整体观念，控制论体现于信息安全PDR策略。</li></ul></li><li><p><strong>方法论基础</strong></p><ul><li>以解决网络空间安全问题为目标、以适应网络空间安全需求为特征的具体科学方法论</li><li><strong>逆向分析</strong>是网络空间安全学科特有的方法论，该学科领域斗争具攻防对抗性</li><li>方法论的应用：强调底层性、系统性，综合治理追求整体效能，坚持“以人为核心”，注重定性定量分析相结合。</li></ul></li></ul><h3 id="立法现状">立法现状</h3><ol type="1"><li><strong>国际立法现状</strong><ul><li>美国通过多部法律，如信息自由法等，还有总统令及相关法案；俄罗斯颁布联邦信息相关法律；欧盟建立一系列法律，如数据保护法等，近年通过网络安全相关指令和条例。</li></ul></li><li><strong>我国立法现状</strong><ul><li>早期我国计算机信息安全立法属“渗透型”，将相关规范融入其他法律法规，初步形成法律规范体系。现有法律法规众多，包括国务院令发布的条例、全国人大通过的决定、网络安全法等一系列法律，还有部门规范如计算机信息网络国际联网安全保护管理办法等。</li><li><figure><img src="image.png" srcset="/img/loading/loading3.gif" lazyload alt="相关法律法规"><figcaption aria-hidden="true">相关法律法规</figcaption></figure></li></ul></li><li><strong>我国立法不足与体系</strong><ul><li>我国立法存在规范需完善升级、部分应用缺法律支持、执法需高技术支撑等问题，立法体系涵盖法律、行政法规、部门规章等不同层次。</li></ul></li></ol><h3 id="计算机犯罪有关刑法条款">计算机犯罪有关刑法条款</h3><ol type="1"><li><strong>相关法律条款发展历程</strong><!-- - 随着计算机技术发展，计算机犯罪相关法律条款不断演进，经历多次刑法修正案完善，包括对计算机信息系统的非法侵入、控制，对系统功能、数据和程序的破坏，以及利用计算机实施的各类犯罪等方面的规定。 --></li><li><strong>具体刑法条款内容</strong><!-- - 如《刑法》第二百八十五条规定了非法侵入特定计算机信息系统及获取数据、非法控制的刑罚；第二百八十六条规定了对计算机信息系统功能、数据和程序进行破坏以及制作传播病毒的刑罚；第二百八十七条规定利用计算机实施其他犯罪依照相关规定定罪处罚。此外，还有《全国人民代表大会常务委员会关于维护互联网安全的决定》对互联网运行安全、国家安全、市场经济秩序等方面的刑事责任作出规定，以及《中华人民共和国计算机信息系统安全保护条例》确立了信息系统安全保护的多项制度，包括等级保护、机房标准、联网备案等，同时对违反规定的行为设定了相应处罚措施。 --></li></ol><h3 id="标准的基本知识">标准的基本知识</h3><ol type="1"><li><strong>标准的定义与分类</strong><ul><li>标准是通过标准化活动，按照规定的程序协商一致制定，为各种活动或其结果提供规则、指南或特性，供共同使用和重复使用的文件。</li><li>《中华人民共和国标准化法》将标准划分为：<strong>国家标准、行业标准、地方标准和企业标准</strong></li><li>国家标准、行业标准均可分为：<strong>强制性和推荐性</strong>两种属性的标准。强制性国家标准代号：GB，推荐性国家标准代号：GB/T</li><li>标准、规范、规程都是标准的一种表现形式,习惯上统称为标准。</li></ul></li><li><strong>国际标准化组织</strong><ul><li>国际电工委员会（IEC）是最早的国际性电工标准化组织；国际标准化组织（ISO）及其从事信息安全标准化工作的分技术委员会（SC27）；互联网工程任务组（IETF）也在相关领域发挥作用。</li></ul></li><li><strong>我国标准化组织</strong><ul><li>全国信息安全标准化技术委员会（信安标委）负责全国信息安全标准化工作；密码行业标准化技术委员会（密标委CSTC）负责密码领域标准化工作。</li></ul></li></ol><h3 id="信息安全标准">信息安全标准</h3><ol type="1"><li><strong>涉密信息系统分级保护管理办法</strong><ul><li>涉密信息系统分级保护依据涉密程度分为<strong>秘密级、机密级、绝密级</strong>，<strong>国家保密局</strong>是涉密信息系统分级保护工作的主管部门。</li></ul></li><li><strong>信息系统等级保护基本要求</strong><ul><li>信息安全等级保护的核心是分级及保护</li><li>信息系统安全等级保护的内容可分为<strong>系统定级、系统备案、建设整改、测评、监督检查</strong>五个方面</li><li>信息系统的分级主要是依据对国家、社会、法人及组织的损害程度及范围来确定的。损害小、范围也小的，级别低、保护要求也低；损害大、范围大的，级别高，保护的要求就相应增加</li><li>等级保护1.0 vs 2.0<ul><li>安全分类变化：<img src="image-1.png" srcset="/img/loading/loading3.gif" lazyload alt="安全分类变化"></li><li>标准名称变化：信息安全等级保护基本要求 →网络安全等级保护基本要求</li><li>等级保护对象变化：信息系统 →增加云计算平台、大数据平台、移动互联、物联网和工业控制系统等要求</li><li>安全要求变化：安全要求 → 安全通用要求+安全扩展要求</li><li>安全管理中心：2.0在二级及以上增加了“安全管理中心”</li><li>可信验证：2.0在多个技术环节增加了“可信验证”控制点</li></ul></li></ul></li><li><strong>商用密码标准</strong><ul><li>商用密码的行业标准分为基础类标准、应用类标准、检测类标准和管理类标准。</li><li>基础类标准为其他三类标准提供了底层、共性支撑（如术语、算法、协议、产品等）；</li><li>应用类标准为上层具体的密码产品、服务应用提供支持；</li><li>检测类标准为基础类标准和应用类标准提供了合法性检测的功能，保障商用密码使用的合法性；</li><li>管理类标准为其他三类标准提供了管理功能；</li><li>我国多个商用密码算法成为国际标准，如SM2、SM3、SM4、SM9和ZUC算法等，ZUC（祖冲之）算法还被3GPP采纳为国际标准并成为国家和行业标准。</li></ul></li></ol><h2 id="第三节-保密法及密码法">第三节 保密法及密码法</h2><h3 id="保密法概述">保密法概述</h3><ol type="1"><li><strong>保密法历史</strong><ul><li>1951年6月8日，周恩来总理签署中央人民政府政密字377号命令，公布实行《保守国家机密暂行条例》。</li><li>1988年9月5日，第七届全国人民代表大会常务委员会第三次会议审议通过了《中华人民共和国保守国家秘密法》，自1989年5月1日起实行。</li><li>2010年4月29日，第十一届全国人民代表大会常务委员会第十四次会议修订通过《中华人民共和国保守国家秘密法》，自2010年10月1日起施行。</li><li>最新修订在2024年2月27日，由第十四届全国人民代表大会常务委员会第八次会议通过，自2024年5月1日起施行。</li></ul></li><li><strong>保密法结构</strong><ul><li>《中华人民共和国保守国家秘密法》共六章65条。</li><li>包括总则、国家秘密的范围和密级、保密制度、监督管理、法律责任和附则。</li></ul></li></ol><h3 id="保密法内容解读">保密法内容解读</h3><ol type="1"><li><p><strong>一些案例</strong><!-- - 2003年铁矿石交易事件导致中国经济损失高达7000亿人民币。- 2009年7月5日，胡士泰等四名力拓员工因侵犯商业秘密罪、非国家工作人员受贿罪被刑事拘留。- GoogleEarth地球服务暴露了许多国家的政府大楼、军事设施以及敏感地点。- 1964年《中国画报》封面刊出的照片泄露了大庆油田的位置、储量和产量。- 2016年，俄罗斯士兵手机拍照泄露了航母“库兹涅佐夫”号内机库细节。 --></p></li><li><p><strong>国家秘密及范围</strong></p><ul><li>国家秘密是关系国家安全和利益，依照法定程序确定，在一定时间内只限一定范围的人员知悉的事项。</li><li>包括国家事务、国防建设、外交外事、国民经济和社会发展、科学技术、国家安全活动和追查刑事犯罪等事项。</li></ul></li><li><p><strong>国家秘密的范围及密级</strong></p><ul><li>国家秘密及其密级的具体范围，即保密事项范围，由国家保密行政管理部门单独或会同有关中央国家机关规定。</li><li>国家秘密的密级分为<strong>绝密、机密、秘密</strong>三级。</li><li>国家秘密的保密期限，应当根据事项的性质和特点，按照维护国家安全和利益的需要，限定在必要的期限内；不能确定期限的，应当确定解密的条件。</li><li>国家秘密的保密期限，除另有规定外，绝密级不超过三十年，机密级不超过二十年，秘密级不超过十年。</li></ul></li><li><p><strong>保密制度</strong></p><ul><li>国家秘密载体的制作、收发、传递、使用、复制、保存、维修和销毁应符合国家保密规定。</li><li>存储、处理国家秘密的计算机信息系统应实行<strong>分级保护</strong>，并配备保密设施、设备。</li></ul></li><li><p><strong>涉密人员管理</strong></p><ul><li>涉密人员按照涉密程度分为<strong>核心涉密人员、重要涉密人员和一般涉密人员</strong>，实行分类管理。</li><li>涉密人员离岗离职应当遵守国家保密规定。机关、单位应当开展保密教育提醒，清退国家秘密载体，<strong>实行脱密期管理</strong>。</li></ul></li><li><p><strong>涉密计算机和涉密载体保密管理</strong></p><ul><li>加强对信息系统、信息设备的保密管理，建设保密自监管设施。</li><li>加强对国家秘密载体的管理，禁止非法获取、持有、买卖、转送或私自销毁国家秘密载体。</li></ul></li><li><p><strong>12种违规行为</strong></p><ul><li>（一）非法获取、持有国家秘密载体的；</li><li>（二）买卖、转送或者私自销毁国家秘密载体的；</li><li>（三）通过普通邮政、快递等无保密措施的渠道传递国家秘密载体的；</li><li>（四）寄递、托运国家秘密载体出境，或者未经有关主管部门批准，携带、传递国家秘密载体出境的；</li><li>（五）非法复制、记录、存储国家秘密的；</li><li>（六）在私人交往和通信中涉及国家秘密的；</li><li>（七）未按照国家保密规定和标准采取有效保密措施，在互联网及其他公共信息网络或者有线和无线通信中传递国家秘密的；</li><li>（八）未按照国家保密规定和标准采取有效保密措施，将涉密信息系统、涉密信息设备接入互联网及其他公共信息网络的；</li><li>（九）未按照国家保密规定和标准采取有效保密措施，在涉密信息系统、涉密信息设备与互联网及其他公共信息网络之间进行信息交换的；</li><li>（十）使用非涉密信息系统、非涉密信息设备存储、处理国家秘密的；</li><li>（十一）擅自卸载、修改涉密信息系统的安全技术程序、管理程序的</li><li>（十二）将未经安全技术处理的退出使用的涉密信息设备赠送、出售、丢弃或者改作其他用途的；</li><li>（十三）其他违反本法规定的情形。</li></ul></li><li><p><strong>法律责任</strong><!-- - 违反本法规定，发生重大泄密案件的，对直接负责的主管人员和其他直接责任人员给予处分。 --></p></li></ol><h3 id="密码法概述">密码法概述</h3><ol type="1"><li><strong>密码重要性</strong><ul><li>密码是党和国家的“命门”、“命脉”，是国家重要战略资源。密码工作是党和国家的一项特殊重要工作，直接关系国家政治、经济、国防和信息安全。</li></ul></li><li><strong>密码法发展历程</strong><ul><li>1999年国务院颁布《商用密码管理条例》，2005年国家密码管理局正式成立。</li><li>2019年10月26日，《中华人民共和国密码法》通过，习近平主席签署第35号主席令予以公布。</li><li>密码法的颁布实施，是我国密码发展史上具有里程碑意义的大事，有助于提升我国密码工作的规范化、科学化、法治化水平：一是规范密码应用和管理，促进密码事业发展；二是保障网络与信息安全，维护国家安全和社会公共利益，保护公民、法人和其他组织的合法权益。</li><li>对维护我国网络空间安全、促进信息化发展具有重要意义，也直接关系企业商业秘密的依法保护，关系社会公众在网络空间生活的安全和便利。</li></ul></li><li><strong>密码的应用</strong><ul><li>区块链技术是分布式账本技术，核心是密码技术。</li><li>增值税防伪税控系统采用商用密码技术保护涉税信息，减少税收流失。</li></ul></li></ol><h3 id="密码法内容解读">密码法内容解读</h3><ol type="1"><li><strong>中华人民共和国密码法内容</strong><ul><li>《中华人民共和国密码法》自2020年1月1日起施行，共五章44条。</li><li>密码是国家重要战略资源，是保障网络与信息安全的核心技术和基础支撑。</li><li><ol type="1"><li>什么是密码</li></ol><ul><li>“是指采用特定变换的方法对信息等进行加密保护、安全认证的技术、产品和服务”</li><li>核心密码用于保护国家绝密级、机密级、秘密级信息</li><li>普通密码用于保护国家机密级、秘密级信息</li><li>商用密码用于保护不属于国家秘密的信息</li><li>对密码实行分类管理，是党中央确定的密码管理根本原则，是保障密码安全的基本策略</li></ul></li><li><ol start="2" type="1"><li>谁来管密码</li></ol><ul><li>坚持党管密码根本原则</li><li>中央密码工作领导小组（国家密码管理委员会），对全国密码工作实行统一领导</li><li>国家、省、市、县四级密码工作管理体制</li></ul></li><li><ol start="3" type="1"><li>怎么管密码</li></ol><ul><li>第二章（第十三条至第二十条）规定了核心密码、普通密码的主要管理制度：密码管理部门依法对核心密码、普通密码实行严格统一管理，并规定了核心密码、普通密码使用要求安全管理制度以及国家加强核心密码、普通密码工作的一系列特殊保障制度和措施。核心密码、普通密码本身就是国家秘密，一旦泄密，将危害国家安全和利益</li><li>第三章（第二十一条至第三十一条）规定了商用密码的主要管理制度：商用密码的主要管理制度，包括商用密码标准化制度、检测认证制度、市场准入管理制度、使用要求、进出口管理制度、电子政务电子认证服务管理制度以及商用密码事中事后监管制度</li></ul></li><li><ol start="4" type="1"><li>怎么用密码</li></ol><ul><li>第十四条要求在有线、无线通信中传递的国家秘密信息，以及存储、处理国家秘密信息的信息系统，应当依法使用核心密码、普通密码进行加密保护、安全认证</li><li>第八条规定公民、法人和其他组织可以依法使用商用密码保护网络与信息安全，对一般用户使用商用密码没有强制性要求</li><li>为了保障关键信息基础设施安全稳定运行，维护国家安全和社会公共利益，第二十七条要求关键信息基础设施必须依法使用商用密码进行保护</li><li>党政机关存在大量的涉密信息、信息系统和关键信息基础设施，都必须依法使用密码进行保护</li></ul></li></ul></li><li><strong>商用密码标准体系</strong><ul><li>国家建立和完善商用密码标准体系，推进商用密码检测认证体系建设。</li><li>商用密码检测、认证机构应当依法取得相关资质，并依照法律、行政法规的规定和商用密码检测认证技术规范、规则开展商用密码检测认证。</li></ul></li><li><strong>商用密码产品</strong><ul><li>涉及国家安全、国计民生、社会公共利益的商用密码产品，应列入网络关键设备和网络安全专用产品目录。</li><li>商用密码产品检测认证适用《中华人民共和国网络安全法》的有关规定，避免重复检测认证。</li></ul></li><li><strong>法律责任</strong><ul><li>违反密码法规定的行为，将依法追究法律责任。</li></ul></li></ol><h2 id="第四节-网络安全法">第四节 网络安全法</h2><h3 id="网络安全立法背景">网络安全立法背景</h3><ol type="1"><li><p><strong>全球性问题</strong></p><ul><li>应对网络安全威胁已是全球性问题，国际网络安全的法治环境正发生巨大变革。</li><li>美欧等网络强国纷纷建立全方位、立体化、更具弹性与前瞻性的网络安全立法体系。</li><li><strong>网络安全立法已演变为全球范围内的国家主权与利益的斗争，有法可依成为了谈判与对抗的必要条件。</strong></li></ul></li><li><p><strong>国际背景</strong>：合作与共赢、冲突与对抗</p></li><li><p><strong>国内背景</strong></p><ul><li>网络安全人才建设滞后，人才缺乏。</li><li>大量网络安全事件和经济损失。</li><li>新技术持续发展与应用。</li><li>地下黑产不断扩大，网络攻击频繁发生。</li><li>我国信息化建设的突飞猛进。</li><li>法律法规条纹分散、监管滞后。</li></ul></li><li><p><strong>网络安全事件特点</strong></p><ul><li>目标明确：<ul><li>信息安全事件大多为敌对国家或利益集团为达到某种目的而发起的网络攻击。往往是向指定的目标发起特定的网络攻击，具有极强的针对性。</li></ul></li><li>隐蔽性强：<ul><li>攻击工业控制系统的病毒和黑客，异常熟悉工业控制系统的网络情况，攻击方法独特导致无法及时发现，具有极强的隐蔽能力，可以长时间隐藏于工业控制系统中。</li></ul></li><li>破坏严重：<ul><li>电力、能源、金融等系统如果遭到破坏，轻则造成经济损，重则会造成人身伤亡，甚至会影响地区和国家的安定，乃至国家战略和重大计划的执行都会受到阻挠。</li></ul></li></ul></li><li><p><strong>网络安全立法的需求</strong></p></li><li><p><strong>国外网络安全立法状况</strong></p></li><li><p><strong>网络空间安全顶层设计</strong></p></li><li><p><strong>国家高度重视</strong></p></li><li><p><strong>立法进程</strong></p></li></ol><h3 id="网络安全法的重大意义">网络安全法的重大意义</h3><ol type="1"><li><strong>立法里程碑</strong><ul><li>《网络安全法》的出台具有里程碑式的意义，是全面落实党的十八大和十八届三中、四中、五中、六中全会相关决策部署的重大举措。</li><li>我国<strong>第一部网络安全的专门性综合性立法</strong>，提出了应对网络安全挑战这一全球性问题的中国方案。</li><li>立法进程的快速推进，显示了党和国家对网络安全问题的高度重视，是我国网络安全法治建设的一个重大战略契机。</li><li>网络安全有法可依，信息安全行业将<strong>由合规性驱动过渡到合规性和强制性驱动并重</strong>。</li></ul></li><li><strong>服务与国家网络安全战略和网络强国建设</strong><ul><li>网络空间逐步成为世界主要国家展开竞争和战略博弈的新领域。确立网络空间行为准则和模式已是当务之急。</li><li>《网络安全法》中明确提出了有关国家网络空间安全战略和重要领域安全规划等问题的法律要求，这有助于实现推进中国在国家网络安全领域明晰战略意图，确立清晰目标，厘清行为准则，不仅能够提升我国保障自身网络安全的能力，还有助于推进与其他国家和行为体就网络安全问题展开有效的战略博弈。</li></ul></li><li><strong>助力网络空间治理，护航“互联网+”</strong><ul><li>我国是名符其实的网络大国，但现实的网络环境十分堪忧。</li><li>《网络安全法》将成为新的起点和转折点。</li></ul></li><li><strong>构建我国首部网络空间管辖基本法</strong><ul><li>《网络安全法》属于国家基本法律，是网络安全法制体系的重要基础。</li><li>《网络安全法》规定了信息安全法的总体目标和基本原则；规范网络社会中不同主体所享有的权力义务及其地位；建立网站身份认证制度，实施后台实名；建立网络信息保密制度，保护网络主体的隐私权；建立行政机关对网络信息安全的监管程序和制度，规定对网络信息安全犯罪的惩治和打击；规定具体的诉讼救济程序等等。</li><li>《网络安全法》的出台从根本上填补了<strong>我国综合性网络信息安全基本大法</strong>、核心的网络信息安全法和专门法律的三大空白。</li></ul></li><li><strong>提供维护国家网络主权的法律依据</strong><ul><li>我国在2016年7月推出了《国家安全法》，首次以法律的形式明确提出了“维护国家网络空间主权”。</li><li>《网络安全法》是《国家安全法》在网络安全领域的体现和延伸，为我国维护网络主权、国家安全提供了最主要的法律依据。</li></ul></li><li><strong>在网络空间领域贯彻落实依法治国精神</strong><ul><li>十八届四中全会通过了《中共中央关于全面推进依法治国若干重大问题的决定》。</li><li>《网络安全法》则开启了依法治网的崭新局面，成为依法治国顶层设计下一项共建共享的路径实践。</li><li>依法治网成为我国网络空间治理的主线和引领，依法治谋求网治的长治久安。</li></ul></li><li><strong>成为网络参与者普遍遵守的法律准则和依据</strong><ul><li>《网络安全法》的执行，成为各方参与互联网上的行为提供非常重要的准则。</li><li>《网络安全法》对网络产品和服务提供者的安全义务有了明确的规定，将现行的安全认证和安全检测制度上升成为了法律</li></ul></li></ol><h3 id="网络安全法概览及亮点">网络安全法概览及亮点</h3><ol type="1"><li><strong>概览</strong><ul><li>《网络安全法》亮点包括：<ul><li>监测预警与应急处置措施的制度化、法制化</li><li>明确了网络空间主权的原则</li><li>建立了关键信息基础设施安全保护制度</li><li>明确了网络产品和服务提供者的安全义务</li><li>进一步完善了个人信息保护规则</li><li>明确了网络运营者的安全义务</li></ul></li></ul></li><li><strong>亮点</strong><ul><li>全面性：<ul><li>全面和系统地确立了各个主体包括国家有关主管部门、网络运营者、网络使用者在网络安全保护方面的义务和责任；</li><li>确立了保障网络的设备设施安全、网络运行安全、网络数据安全以及网络信息安全等方面的基本制度。</li></ul></li><li>针对性：<ul><li>从我国的国情出发，坚持问题的导向，总结实践经验，也借鉴了其他国家的一些做法，建立保障网络安全的各项制度，重在管用，重在解决实际问题</li></ul></li><li>协调性：<ul><li>始终坚持安全与发展并重的原则，协调推进网络安全和发展，注重保护网络主体的合法权益，保障网络信息依法、有序、自由的流动，促进网络技术创新，最终实现以安全促发展，以发展来促安全的目的。</li></ul></li></ul></li></ol><h3 id="网络安全法重要条款解读">网络安全法重要条款解读</h3><ol type="1"><li><strong>第一章 总则</strong><ul><li>描述制定网络安全法的目的和适用范围，保障网络安全的目标以及各部门、企业、个人所承担的责任义务，并强调将大力宣传普及，加快配套制度建设，加强基础支撑力量建设，确保网络安全法有效贯彻实施。</li></ul></li><li><strong>第二章 网络安全支持与促进</strong><ul><li>要求政府、企业和相关部门通过多种形式对企业和公众开展网络安全宣传教育，提高安全意识。鼓励企业、高校等单位加强对网络安全人才的培训和教育，解决目前网络安全人才严重不足问题。另外鼓励和支持通过创新技术来提升安全管理，保护企业和个人的重要数据。</li></ul></li><li><strong>第三章 网络运行安全</strong><ul><li>特别强调要保障关键信息基础设施的运行安全。安全是重中之重，与国家安全和社会公共利益息息相关。《网络安全法》强调在网络安全等级保护制度的基础上，对关键信息基础设施实行重点保护，明确关键信息基础设施的运营者负有更多的安全保护义务，并配以国家安全审查、重要数据强制本地存储等法律措施，确保关键信息基础设施的运行安全。</li></ul></li><li><strong>第四章 网络信息安全</strong><ul><li>从三个方面要求加强网络数据信息和个人信息的安全：第一是要求网络运营者对个人信息采集和提取方面采取技术措施和管理办法，加强对公民个人信息的保护，防止公民个人信息数据被非法获取、泄露或者非法使用；第二、赋予监管部门、网络运营者、个人或组织的职责和权限并规范网络合规行为，彼此互相监督管理；第三在有害或不当信息发布和和传输过程中分别对监管者、网络运营商、个人和组织提出了具体处理办法。</li></ul></li><li><strong>第五章 监测预警与应急处置</strong><ul><li>将监测预警与应急处置工作制度化、法制化，明确国家建立网络安全监测预警和信息通报制度，建立网络安全风险评估和应急工作机制，制定网络安全事件应急预案并定期演练。这为建立统一高效的网络安全风险报告机制、情报共享机制、研判处置机制提供了法律依据，为深化网络安全防护体系，实现全天候全方位感知网络安全态势提供了法律保障。</li></ul></li><li><strong>第六章 法律责任</strong><ul><li>规定了违反网络安全法的法律责任，包括行政处罚、民事责任、治安管理处罚和刑事责任。<ul><li>行政处罚：责令改正、警告、罚款，有关机关还可以把违法行为记录到信用档案，对于“非法入侵”等，法律还建立了职业禁入的制度。&nbsp;</li><li>民事责任：违法《网络安全法》的行为给他人造成损失的，网络运营者应当承担相应的民事责任。</li><li>治安管理处罚/刑事责任：违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。</li></ul></li></ul></li></ol><h2 id="第五节-数据安全法">第五节 数据安全法</h2><h3 id="立法背景">立法背景</h3><ol type="1"><li><strong>国内外背景</strong><ul><li>数据价值凸显：随着5G、IoT、AI等信息技术革命的推进，数据量进入ZB级别，数据成为数字经济发展的新生产要素。</li><li>数据泄露事件频发：如美国棱镜事件、Facebook数据泄漏事件等，引发全球对数据安全的关注。</li><li>经济利益与数据安全发生冲突：数据跨境流动的隐蔽性削弱国家对本国数据的控制，危及数据主权。</li><li>国内外相关法律法规：巴西、欧盟、美国等国家和地区已制定数据安全和隐私保护法律。</li></ul></li></ol><h3 id="立法意义">立法意义</h3><ol type="1"><li><strong>规范数据处理，保护合法权益</strong><ul><li>规范数据活动，保障数据安全，促进数据开发利用，保护个人、组织的合法权益，维护国家主权、安全和发展利益。</li></ul></li><li><strong>对数据的有效监管实现有法可依、填补数据安全保护立法的空白</strong><ul><li>《数据安全法》构成了数字经济时代的法治基石，是构建国家安全法律制度体系的重要举措，有助于提高我国应对数据风险与挑战的能力。</li></ul></li><li><strong>提升国家数据安全保障能力</strong><ul><li>随着新技术的使用，全场景、大规模的数据应用对国家安全造成严重威胁，数据安全是国家安全的重要组成部分，通过法律的立法和实施，可以有效提升数据安全的保障能力。</li><li>为我国数字化转型的健康发展提供法治保障，为构建智慧城市、数字政务、数字社会提供法律依据。</li><li>《数据安全法》进一步提升了国家数据安全保障体系和能力建设，推动形成安全有序、公正合理的数据治理新格局，切实全面维护国家主权、安全和发展利益。</li></ul></li><li><strong>激活数字经济创新，提升数据利用价值</strong><ul><li>数据作为关键生产要素，其自身具有很大的经济价值，法律的发布标志着国家鼓励数据依法合理有效利用。</li><li>《数据安全法》的正式实施将为我国在国际数据经济市场中提供坚实有力的保障。<br></li></ul></li><li><strong>扩大数据保护范围</strong><ul><li>法律明确了数据的定义，包括电子数据和非电子形式的数据，这对数据安全保障的范围提出了更广泛的要求，比《网络安全法》中的数据范围有所扩大。</li></ul></li></ol><h3 id="概览及特点">概览及特点</h3><ol type="1"><li><strong>数据安全法概况</strong></li></ol><ul><li>总计7章55条，包括数据安全与发展、数据安全制度、数据安全保护义务、政务数据安全与开放等内容。</li><li><figure><img src="image-16.png" srcset="/img/loading/loading3.gif" lazyload alt="数据安全法"><figcaption aria-hidden="true">数据安全法</figcaption></figure></li></ul><ol start="2" type="1"><li><strong>主要亮点</strong></li></ol><ul><li>数据安全与数字经济发展的动态化平衡<ul><li>提出了数据安全制度、数据安全保护义务等确保数据活动符合安全要求</li><li>推动政务数据开放利用，利用数据提升公共服务智能化水平</li><li>家统筹发展和安全理念</li><li>数据交易制度的确立使得数据依法有序流动成为现实</li></ul></li><li>重视数据安全制度的建设<ul><li>明确提出了数据分类分级保护制度，确定重要数据具体目录，并提出了核心数据的概念。</li><li>明确了数据安全风险评估、信息共享、监测预警机制、安全审查制度等，强化内控制度建设，防控数据安全风险</li><li>《数据安全法》对数据的出境管理进行了补充和完善</li></ul></li><li>加强国家对数据安全工作的统筹<ul><li>明确了监管职责，确定给地区、各部门的主题责任，网信部门发挥统筹协调职能</li><li>通过明确国家层面的统筹协调职能，确保后续国家数据安全战略和重大方针政策的有效落地和执行。</li></ul></li><li>增加对数据泄露危及国家安全的处罚力度<ul><li>对数据安全风险设置了基本“红线”。</li></ul></li></ul><h3 id="重要条款解读">重要条款解读</h3><ol type="1"><li><strong>扩大数据保护范坚持总体国家安全发展观</strong><ul><li>第一条确立该法的立法目的：“为了规范数据处理活动，保障数据安全，促进数据开发利用，保护个人、组织的合法权益，维护国家主权、安全和发展利益，制定本法。”</li><li>规范数据处理活动的目的，是为了保障数据的安全，只有在确保数据安全的基础上，方能促进数据的有序开发和利用。</li></ul></li><li><strong>我国数据保护的域外法律效力</strong><ul><li>第二条第二款明确规定：“在中华人民共和国境外开展数据处理活动，损害中华人民共和国国家安全、公共利益或者公民、组织合法权益的，依法追究法律责任。”</li><li>“境外开展数据处理数据活动”的主体既包括位于中国境外的数据处理者，也包括位于中国境内的数据处理者，但其数据处理行为在境外。</li><li>只要损害了我国国家安全、公共利益以及公民和组织的合法数据权益，均由我国法律管辖，并追究法律责任。</li></ul></li><li><strong>促进以数据为关键要素的数字经济发展</strong><ul><li>第七条规定：“国家保护个人、组织与数据有关的权益，鼓励数据依法合理有效利用，保障数据依法有序自由流动，促进以数据为关键要素的数字经济发展。”</li><li>数据作为生产要素由市场评价贡献、按贡献决定报酬，这是党的十九届四中全会首次提出的一项重大产权创新制度。</li><li>在个人和组织与数据有关的权益得到充分保护的基础上，依法推动数据合理有效利用和依法有序自由流动</li></ul></li><li><strong>数据可以合法交易</strong><ul><li>第十三条和第十九条明确数据的合法交易可以有效推动和促进数字经济和社会的发展。</li><li>并非一味就是强调“监管”或“制约”，在保护国家安全和数据安全的前提下，可以合法交易</li><li>数据的合法交易可以有效推动和促进数字经济和社会的发展</li></ul></li><li><strong>国家数据分类分级保护</strong><ul><li>第二十一条规定：“国家建立数据分类分级保护制度，根据数据在经济社会发展中的重要程度，以及一旦遭到篡改、破坏、泄露或者非法获取、非法利用，对国家安全、公共利益或者个人、组织合法权益造成的危害程度，对数据实行分类分级保护。”</li><li>“数据分类”，采用了数据的“重要程度”＋“危害程度”的立法手段，对数据实行分类分级保护。</li><li>从国家层面提出了数据分类分级，是确定数据保护和利用之间平衡点的一个重要依据</li></ul></li><li><strong>国家数据安全审查制度</strong><ul><li>第二十四条规定：“国家建立数据安全审查制度，对影响或者可能影响国家安全的数据处理活动进行国家安全审查。”</li><li>数据安全审查制度与网络安全审查是依法确立的国家安全审查制度中两项重要的安全审查制度。</li><li>数据安全审查制度的审查对象主要针对影响或者可能影响国家安全的数据处理活动，数据处理活动包括：数据的收集、存储、使用、加工、传输、提供、公开等。</li></ul></li><li><strong>国家数据安全应急处置机制</strong><ul><li>第二十三条规定了“国家建立数据安全应急处置机制”，并要求“发生数据安全事件，有关主管部门应当依法启动应急预案，采取相应的应急处置措施，防止危害扩大，消除安全隐患，并及时向社会发布与公众有关的警示信息”</li><li>“有关单位”应当按照“谁主管谁负责、谁运行谁负责”的原则确定</li><li>采取最有效的应急处置措施，防止危害扩大，要消除安全隐患，同时要组织研判，保存证据，并做好信息通报工作</li><li>及时向社会发布与公众有关的警示信息</li><li>分为四级：由高到低依次用红色、橙色、黄色和蓝色标示，分别对应可能发生特别重大、重大、较大和一般网络安全突发事件。</li></ul></li><li><strong>数据处理者的合规义务</strong><ul><li>第二十七条到第三十条明确了数据处理者履行数据安全的四项重要合规义务。</li></ul></li><li><strong>重要数据的出境安全管理制度</strong><ul><li>第三十一条规定了关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的重要数据的出境安全管理。</li><li>关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的重要数据的出境安全管理，适用《中华人民共和国网络安全法》。</li><li>除关键信息基础设施的运营者处理的重要数据外，其他数据处理者在中华人民共和国境内运营中收集和产生的重要数据的出境安全管理办法，由国家网信部门会同国务院有关部门制定</li><li>数据出境，要求出境前必须经过“安全评估”。</li></ul></li><li><strong>提供数据处理服务的行政许可准入制度</strong><ul><li>第三十四条规定：“法律、行政法规规定提供数据处理相关服务应当取得行政许可的，服务提供者应当依法取得许可。”</li><li>许可（license）含有准许、允许或授权的意思，数据处理相关服务的行政许可，其基本性质是行政机关对特定的数据处理服务活动事前进行控制的一种管理行为。。</li></ul></li><li><strong>加大违法处罚力度</strong><ul><li>第四十五条对违反数据安全保护义务的组织、个人规定了严格的处罚措施。</li></ul></li></ol><h3 id="个人信息保护法">个人信息保护法</h3><ol type="1"><li><strong>中华人民共和国个人信息保护法</strong><ul><li>2021年8月20日通过，2021年11月1日施行，共八章74条。</li></ul></li><li><strong>立法进程</strong><ul><li>个人信息保护法的立法进程，旨在保护个人信息权益，促进个人信息合理利用。</li></ul></li><li><strong>术语界定</strong><ul><li>个人信息：是以电子或者其他方式记录的与已识别或者可识别的自然人有关的各种信息，不包括匿名化处理后的信息。</li><li>个人信息的处理：包括个人信息的收集、存储、使用、加工、传输、提供、公开、删除等。</li><li>敏感个人信息：一旦泄露或者非法使用，容易导致自然人的人格尊严受到侵害或者人身、财产安全受到危害的个人信息，包括生物识别、宗教信仰、特定身份、医疗健康、金融账户、行踪轨迹等信息，以及不满十四周岁未成年人的个人信息。</li></ul></li><li><strong>范围界定</strong><ul><li>境内：组织、个人再中华人民共和国境内处理自然人个人信息的活动。</li><li>境外：在中华人民共和国境外处理中华人民共和国境内自然人个人信息的活动，有下列情形之一的：<ul><li>以向境内自然人提供产品或者服务为目的的</li><li>分析、评估境内自然人的行为</li><li>法律、行政法规规定的其它情形</li></ul></li></ul></li><li><strong>处理规则</strong><ul><li>规定了个人信息处理的合法、正当、必要和诚信原则，以及个人信息处理者的义务。</li><li>任何组织、个人不得 非法收集、使用、加工、传输 他人个人信息，不得非法买卖、提供或者公开 他人个人信息；不得从事 危害国家安全、公共利益的个人信息处理活动。</li><li>处理个人信息应当取得个人的同意。</li><li>设专节对处理敏感个人信息作出更严格的限制</li></ul></li><li><strong>个人信息跨境提供规则</strong><ul><li>明确了个人信息跨境提供的规则和要求。</li><li>未经中华人民共和国主管机关批准，个人信息处理者不得向外国司法或者执法机构提供存储于中华人民共和国境内的个人信息。</li></ul></li><li><strong>个人信息处理活动中个人的权利和处理者义务</strong><ul><li>明确了个人在个人信息处理活动中的权利，如知情权、决定权、查询权、更正权、删除权等。</li></ul></li><li><strong>履行个人信息保护职责的部门</strong><ul><li>明确了个人信息保护职责部门的定义和职责。</li></ul></li><li><strong>法律责任</strong><ul><li>规定了违反个人信息保护法的法律责任，包括责令改正、警告、罚款等措施。</li></ul></li></ol><h1 id="第二章-密码学基础">第二章 密码学基础</h1><h2 id="第一节-密码学概述">第一节 密码学概述</h2><h3 id="密码的起源">密码的起源</h3><ol type="1"><li>原始符号</li><li>古代隐写术</li><li>古代语言隐写术</li><li>斯巴达密码棒</li><li>达·芬奇密码筒</li></ol><h3 id="古典密码">古典密码</h3><ol type="1"><li><strong>古典替换</strong>：将明文字母替换成其他的字母、数字和符号<ul><li><p><strong>凯撒密码</strong>：单表替换密码，每个字母用其后第3个字母替换（广义为移动K个位置），如“Caesarcipher is a shift substitution”加密后为“FDHVDU FLSKHU LV D VKLIWVXEVWLWXWLRQ”。</p></li><li><p><strong>维吉尼亚密码</strong>：多表替换密码，引入密钥概念，根据密钥决定用哪一行密表代换，掩盖字母频率特征，如明文“polyalphabeticcipher”，密钥“RADIO”，加密后为“GOOGOCPKTP NTLKQZPKMF”。</p></li><li><figure><img src="image-3.png" srcset="/img/loading/loading3.gif" lazyload alt="维吉尼亚密码"><figcaption aria-hidden="true">维吉尼亚密码</figcaption></figure></li><li><figure><img src="image-4.png" srcset="/img/loading/loading3.gif" lazyload alt="维吉尼亚密码"><figcaption aria-hidden="true">维吉尼亚密码</figcaption></figure></li><li><p><strong>普莱费尔密码</strong>：多字母代换密码，基于5×5字母矩阵，将明文中双字母组合转换为密文双字母组合</p><ul><li>加密规则:按成对字母加密</li><li>相同对中的字母加分隔符(任意字符，如X)，对明文进行分组，每2个字母一组，如果明文的字母数为奇数，在最后加上一个无效字母补位(如x)。</li><li>balloon → ba lx lo on</li><li>同行取右边: he → EC</li><li>同列取下边: dm → MT</li><li>其他取交叉: kt → MQ；OD → TR</li></ul></li><li><p><strong>Hill密码（仿射密码）</strong>：m个连续明文字母用m个密文字母代替，由m个线性方程决定，如m= 2时，对明文“july”加密，密钥K为特定矩阵，加密结果为“DELW”。</p></li></ul></li><li><strong>古典置换（换位密码）</strong>：通过重新排列明文字符位置实现加密<ul><li><strong>栅格换位</strong></li><li><figure><img src="image-5.png" srcset="/img/loading/loading3.gif" lazyload alt="栅格换位"><figcaption aria-hidden="true">栅格换位</figcaption></figure></li><li><strong>矩形换位</strong></li><li><figure><img src="image-6.png" srcset="/img/loading/loading3.gif" lazyload alt="矩形换位"><figcaption aria-hidden="true">矩形换位</figcaption></figure></li></ul></li><li><strong>一次一密密码</strong>：密钥本身随机，而且密钥只使用一次。<ul><li>即使获得了上次通信的密文和密钥，攻击者仍然无法确定下次通信的真正密钥；</li><li>需要建立庞大的随机字母集，工作量巨大，而且存在密钥分发的问题。</li><li><strong>费纳姆密码</strong>：将明文与密钥进行模2加法（比特XOR，即异或）运算，若密钥只使用一次，为一次一密密码。</li></ul></li></ol><h3 id="机械密码">机械密码</h3><ol type="1"><li><p><strong>转轮密码机ENIGMA</strong>：德国发明家亚瑟·谢尔乌比斯发明，二战期间德军使用，安全性高，有多个转轮，组合可能性众多，后被数学家艾伦·图灵破解，其设计体现了加密系统保密性基于密钥保密的理念。</p></li><li><p><strong>紫色密码机</strong>：日本外务省在二战期间使用的机械式密码机，工作原理与Enigma机类似，被美国威廉·弗里德曼破译小组破解，对美军在中途岛海战及击毙山本五十六等事件中发挥重要作用。</p></li><li><p><strong>其他机械密码机</strong>：包括从未被破解的Sigaba（与Enigma工作原理相似）、C- 36（瑞典海军使用）、M - 209（美军二战及朝鲜战争中使用）。</p></li></ol><h3 id="现代密码">现代密码</h3><ol type="1"><li><strong>现代密码理论基础</strong>：1949年ClaudeShannon发表保密系统的通信理论，奠定现代密码理论基础，用信息论观点分析密码系统相关概念。</li><li><strong>保密通信系统的数学模型</strong>：信源、加密器、信道、解密器、信宿。<ul><li><figure><img src="image-7.png" srcset="/img/loading/loading3.gif" lazyload alt="数学模型"><figcaption aria-hidden="true">数学模型</figcaption></figure></li></ul></li><li><strong>信息隐藏和信息保密</strong>：<ul><li>信息隐藏（隐匿信息存在）：将秘密信息嵌入表面上看起来无害的宿主信息中，使攻击者无法直观地判断他所监视的信息中是否含有秘密信息，目的是使攻击者不知道哪里有秘密,它隐藏了信息的存在形式。</li><li>信息保密（隐匿信息真意）：信息加密是利用单钥或双钥密码算法把明文变换成密文并通过公开信道送到接收者手中，保护的是信息的内容。</li></ul></li><li><strong>DES数据加密标准</strong>：组合、混乱、扩散、分组密码设计<ul><li>组合（Combine）：由简单易于实现的密码系统进行组合，构造较复杂的、密钥量较大的密码系统，如加权和及乘积法。</li><li>混乱(Confusion)：为了避免密码分析者利用明文与密文之间的依赖关系进行破译，密码的设计应该保证这种依赖关系足够复杂，使明文和密文、密钥之间的统计相关性极小化。通常的方法是“替换(Substitution)”</li><li>扩散(Diffusion)：为避免密码分析者对密钥逐段破译，密码的设计应该保证密钥的每位数字能够影响密文中的多位数字；同时，为了避免密码分析者利用明文的统计特性，密码的设计应该保证明文的每位数字能够影响密文中的多位数字，即将每一位明文及密钥尽可能迅速地散布到较多位密文数字中去，从而隐藏明文的统计特性。通常的方法是“换位(Permutation)”</li><li>分组密码设计：输入分段处理、非线性变换、左右交换和密钥控制下的多次迭代，如Feistel结构。</li></ul></li><li><strong>公钥密码体制</strong>：又称双钥密码体制或非对称密码体制（Two-key/AsymmetricCryptosystem），就是在加密和解密的过程中分别使用不同的密钥</li><li><strong>密码技术分支</strong>：包括数字签名、认证码、Hash函数、密码协议等，现代密码学研究建立安全密码体制和破译敌方密码体制。</li><li><strong>密码体制五大特性</strong>：保密性、完整性、可用性、认证性、不可否认性</li><li><strong>量子密码</strong>：利用量子态作为信息载体，基于量子力学原理（如薛定谔方程、测不准原理、不可克隆定理）实现量子密钥分发，具有不可窃听性和一次一密不可破译性，但未超出Shannon的信息理论和密码理论范畴。</li></ol><h3 id="密码学面临的挑战">密码学面临的挑战</h3><ol type="1"><li><strong>云计算/存储</strong>：用户担心云上数据丢失、失效、泄密、篡改及隐私泄露，云计算对密码有新需求，如感知数据存在、确保数据安全和隐私，研究热点包括数据持有证明、完全同态加密。</li><li><strong>大数据</strong>：数据量巨大且增长迅速，具有4V特点（Volume、Velocity、Variety、Value），密码算法需处理大规模数据，提高效率和适应性，在存储、传输处理等方面带来新挑战和需求。</li><li><strong>物联网</strong>：万物互联面临数据、网络、系统安全及隐私保护问题。<ul><li>物联网的安全要求：<ul><li>密码要适应数据多样性（物体多样性使数据多样性）</li><li>密码要适应网络多样性、多层次(传感网、无线网、有线网、内网和外网)</li><li>密码要适应各层次的资源差异较大(感知层资源弱，管理层资源强)，因此需要多密码、多密钥、多安全级别、跨域互联互通。</li></ul></li></ul></li><li><strong>新型计算机</strong>：量子计算机（如D -Wave公司产品）可在多项式时间内解决大整数分解难题，冲击RSA等加密算法，加快密钥搜索速度，量子计算机和DNA计算机发展对现有密码算法构成威胁。</li><li><strong>区块链技术</strong>：一方面区块链需要在众多节点间通过共识机制达成一致导致其性能低下；另一方面区块链核心技术的突破还需要依赖密码技术底层算法、协议的突破；密码技术是区块链基础核心，但专业人才匮乏。</li></ol><h2 id="第二节-密码学基本概念">第二节 密码学基本概念</h2><h3 id="密码体制">密码体制</h3><ol type="1"><li><strong>密码体制基本概念</strong><ul><li><strong>密码学的定义</strong>：<ul><li>保密学（密码学Cryptology）：研究信息系统安全保密的科学，包括秘密通信和破译密码的方法。</li><li>密码编码学（Cryptography）：研究对信息进行编码，实现信息隐蔽的学科。</li><li>密码分析学（Cryptanalytics）：研究加密消息的破译或消息的伪造，恢复被隐藏信息的本来面目。</li></ul></li><li><strong>密码系统组成</strong>：<ul><li>明文字母空间、密文字母空间、密钥空间和算法。</li><li>两个基本单元是算法和密钥。</li></ul></li></ul></li><li><strong>密码体制基本概念</strong><ul><li><strong>明文与密文</strong>：<ul><li>明文：需要秘密传送的可读消息，构成明文消息空间M。</li><li>密文：明文经过密码变换后的不可读消息，构成密文消息空间C。</li></ul></li><li><strong>加密与解密</strong>：<ul><li>加密：由明文到密文的数学变换。</li><li>解密：从密文恢复出明文的数学变换。</li></ul></li><li><strong>加密算法与解密算法</strong>：<ul><li>加密算法：对明文进行加密时采用的规则。</li><li>解密算法：对密文进行解密时采用的规则。</li></ul></li><li><strong>密钥</strong>：<ul><li>密钥：加密和解密时使用的秘密信息，包括加密密钥空间K和解密密钥空间K’。</li></ul></li><li><strong>加密/解密过程</strong>：<ul><li>加密算法E：M × K → C；解密算法D：C × K’ → M。</li><li>加密/解密关系：对于所有m ∈ M, c ∈ C, c = Eke(m), m = Dkd(c) =Dkd(Eke(m))。</li></ul></li></ul></li><li><strong>对称加密与非对称加密</strong><ul><li><strong>单钥加密体制（对称加密体制）</strong>：<ul><li>加密密钥ke等于解密密钥kd。</li><li>对称加密算法使用起来简单快捷，密钥较短，且破译困难。如：DES、IDEA、TDEA（即3DES）、AES</li></ul></li><li><strong>双钥加密体制（非对称加密体制）</strong>：<ul><li>加密密钥ke不等于解密密钥kd。</li><li>特点：实现多个用户加密的消息只能由一个用户解读（加密）；一个用户加密消息而使多个用户可以解读（数字签名）。</li><li>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。</li><li>加密算法可以把加密密钥和算法公开，所以任何人都可用之来加密要传送的明文信息。但只有拥有解密密钥的人才能将传送过来的已经加了密的消息解密，还原原信息。</li></ul></li></ul></li></ol><h3 id="密码分析">密码分析</h3><ol type="1"><li><strong>密码分析与密码安全性</strong><ul><li><strong>密码分析</strong>：<ul><li>密钥分析的实质是在攻击者不知道密钥的情况下，对所截获的密文或明-密文对采用各种不同的密码分析方法试图恢复出明文或密钥。</li></ul></li><li><strong>密码设计的安全性</strong>：<ul><li>无条件安全：无论破译者有多少密文，他也无法解出对应的明文，即使他解出了，他也无法验证结果的正确性；具有无限计算资源（诸如时间、空间、资金和设备等）的密码分析者也无法破译某个密码系统</li><li>计算上安全：理论上可破译，但实际运用时破译的代价超出信息本身的价值，破译的时间超出了信息的有用寿命</li></ul></li><li><strong>密码分析类型</strong>：<ul><li>唯密文攻击、已知明文攻击、选择明文攻击、选择密文攻击、选择文本攻击</li><li><figure><img src="image-8.png" srcset="/img/loading/loading3.gif" lazyload alt="密码分析"><figcaption aria-hidden="true">密码分析</figcaption></figure></li></ul></li><li><strong>密码分析方法</strong>：<ul><li>穷举攻击法<ul><li>穷尽密钥搜索攻击（完全试凑法）</li></ul></li><li>数学攻击法<ul><li>差分密码分析：通过分析明文对的差值对密文对的差值的影响来恢复某些密钥比特.（针对分组密码）</li><li>确定性分析法–线性密码分析：本质上是一种已知明文攻击方法,通过寻找一个给定密码算法的有效的线性近似表达式来破译密码系统</li><li>确定性分析法–插值攻击方法：使用一个代数函数来代表一个S-Box，此函数可以用已知明文攻击法取得样本点，再用拉格朗日插值法产生。这个代数函数可能是在有限体上的二次函数、多项式函数或有理函数。</li><li>统计分析法：利用明文的已知统计规律进行破译的方法。</li></ul></li><li>物理攻击法<ul><li>侧信道攻击：针对密码实现（包括密码芯片、密码模块、密码系统等）的物理攻击方法。</li><li>本质上是利用密码实现在执行密码相关操作的过程中产生的侧信息来恢复出密码实现中所使用的密钥。</li><li>侧信息（Side ChannelInformation）：除了攻击者通过除主通信信道以外的途径获取到的关于密码实现运行状态相关的信息，典型的侧信息包括密码实现运行过程中的能量消耗、电磁辐射、运行时间等信息。</li><li>侧信道攻击主要面向密码实现的物理安全性，采用能量分析攻击、电磁分析攻击、计时攻击、缓存攻击、故障攻击等一系列方法对其实现安全性进行分析</li></ul></li></ul></li></ul></li></ol><h3 id="密码学理论基础">密码学理论基础</h3><ul><li>密码学基本数学知识<ul><li><strong>模运算</strong>：求余运算，包括取模运算、模加法、模减法、模乘法、模指数、求逆运算（若存在𝑎𝑏=1𝑚od𝑛 ，则a、b互为逆元）。</li><li><strong>整数分解</strong>：又称为素因数分解，是将一个大于1的自然数写成素数乘积的形式。</li><li><strong>欧几里得算法</strong>：求两个整数最大公因子的快速算法。设a和b是两个任意正整数，gcd(a,b)为它们的最大公因子，gcd(a, b)= gcd(b, a mod b)</li><li><strong>有限域</strong>：元素个数有限的域，又被称为Galois域。域内定义了加法和乘法，集合内的元素经过加法和乘法计算，结果仍然在集合内。计算符合交换率、结合率、分配率，加法和乘法有单位元素（所有的集合内的值都有对应的负数，所有集合内非零值都有倒数）</li><li><strong>中国剩余定理</strong>：求解一次同余式组的方法。</li><li><strong>椭圆曲线</strong>：定义在实数域上的椭圆曲线，可以构成一个Abel群。</li></ul></li></ul><h3 id="国内外密码算法概览">国内外密码算法概览</h3><ol type="1"><li><strong>序列密码原理（流密码）</strong><ul><li>定义：明文m与伪随机序列k结合，通过加密变换生成密文c，解密过程与加密过程相同且互逆。</li><li>数学表达：由种子密钥通过密钥流发生器得到的密钥流K，加密变换为C，其中ci= mi ⊕ ki。</li><li><figure><img src="image-9.png" srcset="/img/loading/loading3.gif" lazyload alt="序列密码"><figcaption aria-hidden="true">序列密码</figcaption></figure></li><li>特点：实现简单、便于硬件实施、加解密处理速度快、没有或只有有限的错误传播</li><li>由有限状态机产生的序列是伪随机序列</li><li>典型算法：RC4</li></ul></li><li><strong>分组密码</strong><ul><li>定义：将明文消息编码表示后的数字序列划分成长度为n的组，在密钥k的控制下变换成等长的输出数字序列。</li><li>典型分组密码：DES、IDEA、RC5、RC6、CAST-128等。</li><li>设计要求：分组长度足够大，密钥量足够大，算法足够复杂，加密、解密算法简单，数据无扩展，差错传播尽可能小。</li></ul></li><li><strong>Feistel密码结构</strong><ul><li>定义：Feistel密码结构是一种迭代密码结构，由HorstFeistel提出，用于设计分组密码。</li><li>安全性：单个循环（轮）的Feistel结构不能提供足够的安全性，但多个循环（轮）可以显著提高安全性。</li><li>特点：<ul><li><strong>分组大小</strong>：明文消息编码表示后的数字序列划分成长度为n的组。</li><li><strong>密钥大小</strong>：密钥有不同的产生算法，密钥的长度影响密文的安全性。</li><li><strong>迭代轮数</strong>：多轮重复循环处理，典型的循环次数是16次。</li><li><strong>子密钥产生算法</strong>：用于产生加密过程中的密钥。</li><li><strong>轮函数</strong>：函数越复杂，安全性越好，更能抵抗密码分析，包括加法、减法和异或，固定循环/移位等。</li></ul></li></ul></li><li><strong>DES算法</strong><ul><li>定义：DES（Data EncryptionStandard）是一种分组密码，假设明文m是有0和1组成的长度为64比特的符号串，密钥k也是64比特的0,1符号串。</li><li>有效密钥：64比特密钥k只有56比特有效，其余8位是奇偶校验位，在算法中不起作用。</li><li>DES算法细节：<ul><li><strong>初始置换IP和初始逆置换IP<span class="math inline"><sup>−1</sup></span></strong>：DES过程中的初始和最终步骤，用于重新排列明文和密文的比特。</li><li><strong>S盒替代</strong>：DES中的关键步骤，使用固定的替换表（S盒）对数据进行非线性变换。</li></ul></li></ul></li><li><strong>三重DES算法(TDEA)</strong><ul><li>定义：三重DES（TripleDES）算法使用3倍DES密钥长度的密钥，执行3次DES算法，以提高安全性。</li><li>TDEA算法模式：<ul><li><strong>DES-EEE3模式</strong>：使用三个不同的密钥（k1, k2,k3），进行三次加密。</li><li><strong>DES-EDE3模式</strong>：使用三个不同的密钥（k1, k2,k3），采用加密-解密-加密模式。</li><li><strong>DES-EEE2模式</strong>：使用两个不同的密钥（k1= k3,k2），进行三次加密。</li><li><strong>DES-EDE2模式</strong>：使用两个不同的密钥（k1= k3,k2），采用加密-解密-加密模式。</li></ul></li></ul></li><li><strong>高级加密标准AES</strong><ul><li>定义: AES（Advanced EncryptionStandard）是NIST于2001年公布的加密标准，取代DES算法。</li><li>AES算法特点：<ul><li><strong>结构</strong>：AES不具有Feistel结构，而是采用基于块的密码结构。</li><li><strong>操作</strong>：每轮进行“字节替换”、“行移位”、“列混淆”、“轮密钥加”，共10轮迭代。</li></ul></li><li>AES算法举例：<ul><li>分组 16字节 128位</li><li>子秘钥 44个，每个 32位，每轮使用4个字，128位</li><li>每轮进行“字节替换”、“行移位”、“列混淆”、“轮密钥加”</li><li>10轮迭代，但是非Feistel结构</li><li>每一步都简单可逆A⊕B⊕B = A</li></ul></li></ul></li><li><strong>公钥加密体制</strong><ul><li>定义：公钥技术是加密史上的一个革命性进步，改变了密钥分发的方式，具备密钥分配和管理、数字签名和身份认证、数据加解密等功能。</li><li>特点：<ul><li>基于数学函数而不是对“位”的形式的简单操作（如替换和置换、逻辑加、乘和异或）</li><li>加/解密钥是<strong>非对称</strong>的：公钥密码体制使用两个不同的密钥，在机密性、密钥分配及认证领域中，具有深远的影响。</li><li><strong>密钥管理</strong>：私钥为密码拥有者保管，不涉及分发问题，公钥通过公开渠道分发而不影响安全性。</li><li>通常要求足够大的密钥长度 (&gt;1024 bits)，密钥太长会导致加密速度缓慢，因此公钥算法常用于密钥传递，而一般不用于实时的数据加密</li></ul></li><li>单向陷门函数<ul><li>公钥密码体制是基于单向陷门函数的概念。</li><li><strong>单向函数</strong>是一些易于计算但难于求逆的函数</li><li><strong>单向陷门函数</strong>就是在已知一些额外信息的情况下易于求逆的单向函数，这些额外信息就是所谓的陷门。</li><li>构造公钥密码系统的关键是如何在求解某个单向函数的逆函数的NP完全问题中设置合理的“陷门”。</li></ul></li><li>典型公钥算法：<ul><li>RSA算法三种方式都适合</li><li>Diffe-Hellman算法只适合于密钥交换</li><li>DSS（数字签名标准）适合于数字签名</li><li>EIGamal适合于前两种</li><li>椭圆曲线算法（ECC）三种都适合。</li></ul></li><li>加密方案：<ul><li><strong>公钥加密方案</strong><ol type="1"><li><strong>基于公开密钥的加密过程</strong>：<ul><li><strong>加密过程</strong>：当Alice给Bob发信息时，她使用Bob的公钥KB对消息加密，Bob使用自己的私钥KSB对密文解密。</li></ul></li><li><strong>公钥算法应用——认证</strong>：<ul><li><strong>认证过程</strong>：当Alice给Bob发信息时，她使用自己的私钥KSA对消息加密（签名），Bob使用Alice的公钥KAP对密文解密，认证。</li></ul></li></ol></li><li><strong>公钥+常规密钥结合的加密方案</strong><ol type="1"><li><strong>结合加密方案原理</strong>：<ul><li><strong>方案概述</strong>：利用公开加密的方法来保护常规加密密钥的传送，保证常规加密密钥的安全性，然后用常规加密方法来保护传送的数据。</li></ul></li><li><strong>结合加密方案特点</strong>：<ul><li><strong>效率与安全性</strong>：这种方法利用了公开加密方法的安全性特点和常规加密方法的速度快和适应性强的特点，同时避免了公开加密方法加/解密速度慢的缺点。</li></ul></li></ol></li></ul></li></ul></li><li><strong>RSA算法</strong><ul><li>定义：RSA算法是一种公钥密码算法，涉及两个素数p和q，计算n=pq，φ(n)=(p–1)(q–1)，随机选取整数e，计算d，满足de≡1(modφ(n))。</li><li><strong>RSA算法加密解密</strong>：<ul><li><strong>加密算法</strong>：c=E(m)≡me(mod n)</li><li><strong>解密算法</strong>：D(c)≡cd(mod n)</li></ul></li></ul></li><li><strong>Rabin公钥密码算法</strong><ul><li>定义：Rabin公钥密码算法的安全性基于<strong>模合数平方根困难的困难性</strong>。</li><li><figure><img src="image-10.png" srcset="/img/loading/loading3.gif" lazyload alt="RABIN"><figcaption aria-hidden="true">RABIN</figcaption></figure></li></ul></li><li><strong>Diffie-Hellman算法——密钥交换</strong></li></ol><ul><li>定义：Diffie-Hellman算法允许两个用户可以安全地交换一个秘密信息，用于后续的通讯过程。</li><li>算法的安全性依赖于<strong>计算离散对数的难度</strong>。</li><li>Diffie-Hellman算法过程：<ul><li>密钥交换过程：双方获得a及p：p是一个素数，a是P的原根，通过计算得到共享密钥K。</li></ul></li></ul><ol start="11" type="1"><li><strong>ElGamal公钥密码算法</strong></li></ol><ul><li>定义：ElGamal公钥密码体制安全性是基于<strong>有限域上计算离散对数的困难性</strong>。</li></ul><ol start="12" type="1"><li><strong>椭圆曲线公钥密码算法（ECC）</strong></li></ol><ul><li>定义：ECC实际上是将原有的经典的加密算法通过某些运算移植到安全的椭圆曲线方程上。</li><li>特点：<ul><li><strong>安全性与效率</strong>：椭圆曲线离散对数问题（ECDLP）是椭圆曲线密码学的基础，具有安全性高、密钥尺度小、实现速度快的优点。</li></ul></li></ul><ol start="13" type="1"><li><strong>单向散列算法</strong></li></ol><ul><li>定义：单向散列函数是根据输入消息输出固定长度数值的算法，输出数值也称为“散列值”或“消息摘要”。</li><li>特点：<ul><li><p>散列函数h=H（M），其中，M是发长的报文，h是定长的散列值。设x、x′是两个不同的消息，如果H（x）=H（x′），则称x和x′是哈希函数H的一个（对）碰撞（collision）</p></li><li><p><strong>安全性设计</strong>：强加密单向散列函数是这样设计的：不可能通过计算找出两条散列值相同的消息。</p></li></ul></li><li><strong>MD5和SHA-1</strong>：<ul><li><strong>MD5</strong>：生成128位的散列值。</li><li><strong>SHA-1</strong>：生成160位的散列值。</li></ul></li><li><strong>SHA-2系列算法</strong>：<ul><li><strong>SHA-2系列</strong>：包括SHA-224、SHA-256、SHA-384和SHA-512。</li></ul></li></ul><ol start="14" type="1"><li><strong>国产密码</strong></li></ol><ul><li>定义：国密算法是国家商用密码管理办公室指定的一系列密码标准，包括SM1、SM4、SM2、SM3、ZUC等。</li><li>特点：<ul><li><strong>自主性与安全性</strong>：从根本上摆脱对国外密码技术和产品的过度依赖，实现加密、解密和认证等功能。</li></ul></li></ul><h2 id="第三节-密码学新进展及研究方向">第三节密码学新进展及研究方向</h2><h3 id="公钥密码">公钥密码</h3><ol type="1"><li><strong>公钥基础设施 (PKI)</strong><ul><li>定义：用公钥概念与技术来实施和提供安全服务的具有普适性的安全基础设施</li><li>PKI是生成、管理、存储、分发和吊销基于公钥密码学的公钥证书所需要的硬件、软件、人员、策略和规程的总和。<strong>其最基本的元素是数字证书。</strong></li><li>证书权威（CA）对用户证书带来了复杂的管理问题</li><li><figure><img src="image-11.png" srcset="/img/loading/loading3.gif" lazyload alt="CA"><figcaption aria-hidden="true">CA</figcaption></figure></li></ul></li><li><strong>公钥证书(数字证书)</strong><ul><li>公钥证书由证书管理机构CA为用户建立，其中的数据项包括与该用户的秘密钥相匹配的公开钥及用户的身份和时间戳等，<strong>所有的数据项经CA用自己的秘密钥签字后就形成证书</strong>。</li><li><figure><img src="image-17.png" srcset="/img/loading/loading3.gif" lazyload alt="公钥证书"><figcaption aria-hidden="true">公钥证书</figcaption></figure></li><li>公钥证书是用来绑定实体姓名以及该实体的其它相关属性和相应公钥的凭证。s是网络环境中的一种身份证，用于证明某一用户的身份及其公开密钥的合法性。</li><li>使用X.509协议，广泛应用在网络安全设施：IP安全协议、SSL、SET和S/MIME。</li></ul></li><li><strong>身份基公钥密码 (IBC)</strong><ul><li>使用能唯一标识用户身份的信息作为公钥，例如电话号码或Email地址等，简化了传统公钥密码体系中的用户证书管理。</li><li>在身份基公钥密码中，用户公钥可以为任意的比特串。用户私钥通过可信第三方，即PKG生成。</li><li>身份基公钥密码密钥生成过程：</li><li><figure><img src="image-12.png" srcset="/img/loading/loading3.gif" lazyload alt="IBC"><figcaption aria-hidden="true">IBC</figcaption></figure></li><li><figure><img src="image-13.png" srcset="/img/loading/loading3.gif" lazyload alt="IBC"><figcaption aria-hidden="true">IBC</figcaption></figure></li><li>(pk,sk)：用户的公私钥对 ID：用户的公钥身份字符串PKG：私钥生成中（PrivateKeyGenerator ）</li><li>一个身份基加密方案包含四个算法：<ul><li>系统建立算法：PKG生成系统公开参数和主密钥；</li><li>密钥提取算法：用户将ID提交给PKG，PKG生成ID对应的私钥；</li><li>加密算法：利用用户身份ID加密消息，生成加密密文；</li><li>解密算法：利用身份ID对应的私钥解密密文，得到明文消息。</li></ul></li><li>身份基加密方案扩展了身份基公钥密码体制，能够较好地解决PKI证书管理复杂问题，被广泛应用于安全电子邮件、AdHoc网络密钥管理等应用场景。</li><li>优点：<ul><li>无需公钥证书，加密或签名验证不需要知道除身份外的其他信息；</li><li>无需证书机构，存在可信第三方私钥生成中心(PKG)向用户提供服务；</li></ul></li><li>缺点：<ul><li>密钥托管问题：恶意的PKG可能存储用户私钥的副本，使其有能力解密任何一个用户发送给用户ID的密文或伪造用户ID的数字签名。</li></ul></li></ul></li><li><strong>属性基公钥密码 (ABE)</strong><ul><li>数据拥有者根据用户的属性来加密数据，并且只有当用户拥有特定属性组合时才能解密数据，这种加密方式为数据共享和访问控制提供了一种细粒度的控制机制。</li><li>在属性基加密中，系统的每个权限都可以用一个<strong>属性</strong>来表示。系统中存在一个属性权威(AttributeAuthority，AA)，属性权威对每个用户的属性进行认证，并颁发相应密钥。</li><li>密钥和密文都与<strong>一组属性</strong>相关联，属性集合表示用户身份。加密者根据将要加密的消息和接收者的属性构造一个<strong>加密策略</strong>，当属性满足加密策略时，解密者才能够解密。</li><li><figure><img src="image-14.png" srcset="/img/loading/loading3.gif" lazyload alt="ABE"><figcaption aria-hidden="true">ABE</figcaption></figure></li><li>属性基签名（Attribute-BasedSignature，ABS）是由模糊身份签名发展而来的；<ul><li>根据签名的生成过程分为：密钥策略属性基签名（KP-ABS）、签名策略属性基签名（SP-ABS）</li><li>当且仅当属性集合满足访问结构时，签名者可以对消息生成合法签名</li><li>特点：匿名性</li></ul></li></ul></li></ol><h3 id="同态密码">同态密码</h3><ol type="1"><li><strong>同态密码</strong><ul><li>同态密码可以在不泄露敏感信息的前提下完成对密文的处理，成为保护数据安全，提高密文处理分析能力的关键技术。</li><li>同态是一个数学概念，如果E(f(a， b)) = f(E(a)，E(b))，则E(.)是一个同态映射。</li><li>假设加密操作为E(.)，明文为m，密文为e，如果针对明文的操作f，可以根据E构造出f，使得E(f(m)) = f(e)。 那么E就是一个针对f的同态加密算法。</li><li>同态加密是指在不知道解密算法和密钥情况下，可以对密文直接进行特定运算，而其运算结果解密后与用明文进行相同运算所得的结果一致。</li></ul></li><li><strong>同态密码技术的优缺点</strong><ul><li>优点：无密钥方的计算处理，既可以减少通信代价，又可以避免每一个密文解密后再计算而花费高昂的计算代价。</li><li>缺点：<ul><li>只能实现单比特加密，效率较低；</li><li>困难性假设未论证，寻找可论证的困难问题是个难题；</li><li>需要额外的消除噪音算法，依然不是自然同态。</li></ul></li></ul></li></ol><h3 id="抗量子密码">抗量子密码</h3><ol type="1"><li><strong>抗量子密码分类</strong><ul><li>基于量子物理学的量子密码：<ul><li>主要集中在量子密钥分配、量子秘密共享、量子认证、量子密码算法和量子密码算法的安全性等方面的研究；</li><li>安全性是基于<strong>量子物理设备</strong>的。</li></ul></li><li>基于生物学的DNA密码：<ul><li>是随着基因工程和生物计算的发展而诞生的；</li><li>安全性是建立在<strong>生物困难问题</strong>上的。</li></ul></li><li>基于数学的抗量子计算密码;<ul><li>基于量子计算机不擅长计算的<strong>数学困难问题</strong>构造的；</li><li>研究方向主要有：基于格的密码、基于Hash的数字签名、基于纠错编码的密码和基于多变量的密码。</li></ul></li></ul></li><li><strong>基于数学的抗量子密码</strong><ul><li>NIST PQC标准征集工作聚焦于以下3类抗量子密码算法的征集：加密、密钥交换、数字签名。</li><li>在 69 个候选草案中，主要包括以下 4 种数学方法构造的抗量子密码算法：<ul><li><strong>格 (Lattice-based)</strong>：<ul><li>最早出现于 1996年，主要用于构造加密、数字签名、密钥交换，以及众多高级密码学应用，如：<strong>属性加密(Attribute-based encryption)</strong>、陷门函数 (Trapdoorfunctions)、伪随机函数 (Pseudorandom functions)、同态加密 (HomomorphicEncryption) 等。代表算法：NTRU 系列、NewHope 、一系列同态加密算法(BGV、GSW、FV等)。由于其计算速度快、通信开销较小，且能被用于构造各类密码学算法和应用，因此被认为是<strong>最有希望的抗量子密码技术</strong></li></ul></li><li><strong>编码 (Code-based)</strong>：<ul><li>最早出现于 1978 年，主要用于构造加密算法。代表算法：McEliece</li></ul></li><li><strong>多变量 (Multivariate-based)</strong>：<ul><li>最早出现于 1988年，主要用于构造数字签名、加密、密钥交换等。代表算法：HFE (Hidden FieldEquations)、Rainbow (Unbalanced Oil and Vinegar (UOV) 方法)、HFEv-等</li></ul></li><li><strong>哈希 (Hash-based)</strong>：<ul><li>最早出现于 1979 年，主要用于构造数字签名。代表算法：Merkle哈希树签名、XMSS、Lamport 签名等</li></ul></li></ul></li></ul></li></ol><h3 id="轻量级密码">轻量级密码</h3><ol type="1"><li>轻量级密码概述<ul><li>轻量级密码的特性<ul><li>目标：为资源受限的设备定制专属的密码解决方案；</li><li>特点：对吞吐率的要求比普通密码算法低；</li><li>实用性：部分轻量密码采用机器内置密钥。</li></ul></li><li>轻量级密码的设计方法实现<ul><li>设计要求：存储计算开销小、能耗低、安全性；</li><li>第一种方法：在现有的密码方案上进行轻量化改进；</li><li>第二种方法：设计一个全新的轻量密码方案。</li></ul></li><li>轻量级密码的性能评估<ul><li>硬件开销：延迟、功耗、吞吐率</li><li>软件开销：寄存器、RAM、ROM的空间使用</li></ul></li></ul></li><li>轻量级密码研究现状</li></ol><h3 id="密码学主要研究方向">密码学主要研究方向</h3><ol type="1"><li>研究方向<ul><li>密码学是研究密码编码、密码分析、密码工程、密码应用、密码管理、密码安全防护等问题的一门科学，是多个学科融合形成的交叉学科。</li><li><figure><img src="image-15.png" srcset="/img/loading/loading3.gif" lazyload alt="研究方向"><figcaption aria-hidden="true">研究方向</figcaption></figure></li></ul></li></ol><h1 id="第三章-网络安全基础">第三章 网络安全基础</h1><h2 id="第一节-网络安全概述">第一节 网络安全概述</h2><h3 id="网络安全事件回放">网络安全事件回放</h3><ol type="1"><li><strong>网络的定义</strong><ul><li>定义：计算机网络是指将地理位置不同，具有<strong>独立功能(或自治能力)</strong>的多个计算机系统用<strong>通信设备和线路连接起来</strong>，并以功能完善的网络软件(网络协议、网络操作系统等)进行信息交换，实现<strong>资源共享和协同工作</strong>的系统。</li><li>特征：<ul><li>网络中包含两台以上的地理位置不同具有“自治能力”的计算机。</li><li>网络中各结点之间的连接需要有一条通道，由传输介质实现物理互联。</li><li>网络中各结点之间互相通信或交换信息，需要有某些约定和规则，实现各结点的逻辑互联。</li><li>计算机网络是以实现数据通信和网络资源(包括硬件资源和软件资源)共享和协作为目的。</li></ul></li></ul></li><li><strong>网络的结构</strong><ul><li>OSI参考模型是国际标准化组织(ISO)为解决异种机互连而制定的开放式计算机网络层次结构模型，它的最大优点是将服务、接口和协议这三个概念明确地区分开来。</li><li>网络通信分为七层，从下到上分别是：物理层(PhysicalLayer)、数据链路层(Data Link Layer，简称为链路层)、网络层(NetWorkLayer)、传输层(Transport Layer)、会话层(SessionLayer)、表示层(Presentation Layer)以及应用层(Application Layer)。</li><li><figure><img src="image-18.png" srcset="/img/loading/loading3.gif" lazyload alt="OSI"><figcaption aria-hidden="true">OSI</figcaption></figure></li></ul></li><li><strong>网络安全现状</strong><ul><li>计算机病毒层出不穷，并呈现新的传播态势和特点</li><li>黑客对全球网络的恶意攻击势头逐年攀升</li><li>由于技术和设计上的不完备，导致系统存在缺陷或安全漏洞</li><li>世界各国军方都在加紧进行信息战的研究</li></ul></li><li><strong>网络安全事件</strong><ol type="1"><li><strong>海湾战争网络安全事件</strong>：1991年，美国特工人员在安曼将伊拉克从德国进口的打印机设备中换上含有可控“计算机病毒”的芯片，导致伊方计算机系统全面瘫痪。</li><li><strong>Microsoft公司网站遭袭</strong>：2000年10月25日，Microsoft公司网站遭到来自俄罗斯黑客的袭击，系统瘫痪，部分源代码丢失。</li><li><strong>中美黑客大战</strong>：2001年4月4日，美国黑客组织攻击中国网站，随后中国黑客发起网络反击战。</li><li><strong>ATM机被黑客攻击</strong>：2010年黑帽大会上，美国安全公司IOActive展示ATM机被黑客攻击，导致现金被非法取出。</li><li><strong>飞机电脑系统被黑客攻击</strong>：2013年荷兰黑客安全大会上，德国网络安全工程师HugoTeso展示绕过飞机安全检查系统接管飞机电脑系统。</li><li><strong>特斯拉ModelS系统被攻破</strong>：2014年10月黑客大赛，特斯拉ModelS系统被攻破，实现远程操控。</li><li><strong>微信等苹果APP发现Xcode恶意后门</strong>：2015年9月14日，微信等近350款苹果APP发现存在Xcode恶意后门。</li><li><strong>汇丰银行遭受DDoS攻击</strong>：2016年1月4日和1月29日，汇丰银行遭受DDoS攻击，服务中断。</li><li><strong>WannaCry勒索病毒爆发</strong>：2017年5月12日，WannaCry勒索病毒利用“永恒之蓝”漏洞传播，影响超过10万台电脑。</li><li><strong>万豪国际酒店客户资料泄露</strong>：2018年11月30日，万豪国际酒店客户系统被黑客侵入，约5亿客户资料泄露。</li></ol></li></ol><h3 id="网络安全威胁与防护措施">网络安全威胁与防护措施</h3><ol type="1"><li><strong>网络安全概念</strong><ul><li>定义：网络安全指网络系统的硬件、软件及其系统中的数据受到保护，不因偶然的或者恶意的原因而遭受破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。</li><li>本质：网络上的信息系统安全。</li><li>网络安全包括<strong>系统安全运行</strong>和<strong>系统信息安全保护</strong>两方面：<ul><li>信息系统的安全运行是信息系统提供有效服务(即可用性)的前提</li><li>信息的安全保护主要是确保数据信息的机密性和完整性</li></ul></li><li>涉及内容：技术方面侧重于防范外部的入侵，管理方面则侧重于内部人为因素的管理。</li><li>安全领域普遍认为“最大的漏洞就是人”。</li><li>目标：<strong>机密性、完整性、可用性、非否认性、可靠性、可控性、可审查性</strong></li></ul></li><li><strong>安全威胁和攻击概念</strong><ul><li><strong>安全威胁</strong>：<ul><li>指对某一资源的保密性、完整性、可用性或合法使用所造成的危险。</li></ul></li><li>脆弱性：指在实施防护措施中或缺少防护措施时系统所具有的弱点。</li><li>风险：是对某个已知的、可能引发某种成功攻击的脆弱性的代价的测度。风险分析能够提供定量的方法，以确定是否应保证在防护措施方面的投入。</li><li>漏洞：从广义上讲，硬件、软件、协议的具体实现或系统安全策略以及人为因素上存在的缺陷，从而可以使攻击者能够在未经系统合法用户授权的情况下访问或破坏系统。</li><li><strong>攻击</strong>：<ul><li>一种故意逃避安全服务(特别是从方法和技术上)并且破坏系统安全策略的智能行为；任何可能危及机构信息安全，破坏系统安全属性的行为；攻击就是某个安全威胁的具体实施</li></ul></li></ul></li><li><strong>网络信息安全的典型威胁</strong><ul><li>包括窃听、信息泄露、病毒感染、非法使用、完整性侵犯、拒绝服务、假冒、流量分析等。</li><li>分类：<ul><li>物理威胁</li><li>操作系统缺陷</li><li>网络协议缺陷</li><li>体系结构缺陷</li><li>黑客程序</li><li>计算机病毒</li></ul></li></ul></li><li><strong>典型威胁及其相互关系</strong><ul><li><figure><img src="image-19.png" srcset="/img/loading/loading3.gif" lazyload alt="典型威胁及其关系"><figcaption aria-hidden="true">典型威胁及其关系</figcaption></figure></li></ul></li><li><strong>安全防护措施</strong><ul><li>包括技术防护和管理措施，以防范外部入侵和内部人为因素的管理。</li></ul></li></ol><h3 id="安全攻击的分类及常见形式">安全攻击的分类及常见形式</h3><ol type="1"><li><strong>安全攻击的种类</strong><ul><li>包括被动攻击和主动攻击。</li><li>被动攻击：对所传输的信息进行窃听和监测；</li><li>主动攻击：恶意篡改数据流或伪造数据流等攻击行为；</li><li>被动攻击虽然难以检测，但采取某些安全防护措施就可以有效阻止；而主动攻击虽然易于检测，但却难以阻止。</li><li><figure><img src="image-20.png" srcset="/img/loading/loading3.gif" lazyload alt="攻击"><figcaption aria-hidden="true">攻击</figcaption></figure><ul><li>Interruption 中断 破坏可用性</li><li>Interception 截取 破坏机密性</li><li>Modification 修改 破坏完整性</li><li>Fabrication 伪造 破坏真实性</li></ul></li></ul></li><li><strong>攻击树</strong><ul><li>攻击树是一种<strong>以分支模型直观地表示计算机安全威胁的方法(或威胁建模)</strong>，用来确定哪些威胁最有可能，以及如何有效地阻止威胁。</li><li>攻击的目标，如访问机密文件，是攻击树的根。</li><li>每个分支代表实现该目标的不同方法，这些分支机构可能会从多个方向跳出，有各种不同的选择来实施这些方法</li></ul></li><li><strong>攻击过程分析</strong><ul><li><strong>预攻击(踩点和扫描)</strong><ul><li>目的：收集信息，进行进一步攻击决策</li><li>内容：<ul><li>获得域名及IP分布</li><li>获得拓扑及OS等</li><li>获得端口和服务</li><li>获得应用系统情况</li><li>跟踪新漏洞发布</li></ul></li></ul></li><li><strong>攻击(入侵、获取权限、提升权限)</strong><ul><li>目的：进行攻击，获得系统的一定权限</li><li>内容：<ul><li>获得远程权限</li><li>进入远程系统</li><li>提升本地权限</li><li>进一步扩展权限</li><li>进行实质性操作</li></ul></li></ul></li><li><strong>后攻击(清除日志、安插后门)</strong><ul><li>目的：消除痕迹，长期维持一定的权限</li><li>内容：<ul><li>植入后门木马</li><li>删除日志</li><li>修补明显的漏洞</li><li>进一步渗透扩展</li></ul></li></ul></li></ul></li><li><strong>安全攻击常见八种形式</strong><ul><li>包括口令窃取、欺骗攻击、缺陷和后门攻击、认证失效攻击、协议缺陷攻击、信息泄漏攻击、指数攻击、拒绝服务攻击等。</li></ul><ol type="1"><li><strong>口令窃取</strong><ul><li><strong>口令猜测攻击的三种基本方式：</strong><ul><li>利用已知或假定的口令尝试登录(口令字典、暴力破解、社会工程学字典攻击)；</li><li>根据窃取的口令文件进行猜测；</li><li>窃听某次合法终端之间的会话，并记录所使用的口令；</li></ul></li><li><strong>抵御口令猜测攻击方式：</strong><ul><li>阻止选择低级口令，采用更为复杂的口令；</li><li>对口令文件严格保护；</li></ul></li><li><strong>彻底解决口令机制的弊端：</strong><ul><li>使用基于令牌的机制，例如一次性口令方案(OTP-One-Time Password)。</li></ul></li></ul></li><li><strong>欺骗攻击</strong><ul><li>采用欺骗的方式(假冒、伪装等)获取合法信息并加以利用，获得权限：<ul><li>Web欺骗(钓鱼邮件)；</li><li>IP欺骗；</li><li>DNS欺骗(域名劫持)；</li><li>ARP欺骗。</li></ul></li></ul></li><li><strong>缺陷和后门攻击</strong><ul><li><strong>缺陷：</strong> 指程序中某些代码不能满足特定需求。</li><li><strong>后门：</strong>指能绕开正常的安全访问机制而直接访问程序的程序代码。</li><li><strong>缓冲器溢出(堆栈粉碎)攻击：</strong>程序对接受的输入数据没有进行有效检测导致的错误，可能造成程序崩溃或者是执行攻击者的命令。<ul><li>一种扰乱程序的攻击方法</li><li>在堆栈上执行代码时出现程序指针紊乱<br></li></ul></li><li><strong>网络蠕虫攻击</strong>：利用操作系统和应用程序<strong>漏洞</strong>传播，通过网络的通信功能将自身从一个结点发送到另一个结点并启动运行的程序，可以造成网络服务遭到拒绝并发生死锁。<strong>蠕虫是一段独立的可执行程序，它可以通过计算机网络把自身的拷贝(复制品)传给其他的计算机。</strong><ul><li>方式之一是向守护程序发送新的代码</li><li>蠕虫向“读”缓冲区内注入大量的数据</li></ul></li></ul></li><li><strong>缓冲区溢出</strong><ul><li>这种攻击可以使一个匿名的Internet用户有机会获得一台主机的部分或全部的控制权。</li><li>攻击者向一个有限空间的缓冲区中复制过长的字符串，可能造成程序瘫痪或系统崩溃，或让攻击者运行恶意代码，执行任意指令，甚至获得管理员用户的权限。</li></ul></li><li><strong>网络蠕虫攻击</strong><ul><li>网络蠕虫攻击是一种通过某种网络媒介，无须计算机使用者干预即可运行的独立程序，通过主动寻找目标计算机，不停的获得网络中存在漏洞的计算机上的部分或全部控制权来将代码副本进行传播。</li><li>蠕虫攻击大量地消耗计算机时间和网络通信带宽，导致整个计算机系统及其网络的崩溃，成为拒绝服务攻击的工具。</li><li>蠕虫会搜集、扩散、暴露系统敏感信息(如用户信息等)，并在系统中留下后门。这些都会导致未来的安全隐患。</li></ul></li><li><strong>认证失效攻击</strong><ul><li><strong>认证机制的失效</strong>易导致服务器被攻击者欺骗，此攻击会使系统对访问者所采取的<strong>身份认证措施无效</strong>。</li></ul></li><li><strong>协议缺陷攻击</strong><ul><li>协议本身的缺陷导致攻击的发生<ul><li>TCP/IP协议、DNS和许多基于RPC的协议易遭到序列号攻击</li><li>IP协议易遭受地址欺骗攻击</li><li>HTTP协议、FTP协议等无安全考虑，易遭受攻击</li><li>802.11无线数据通信标准中的WEP协议也存在缺陷</li></ul></li><li>通过改进协议设计消除此缺陷，如我国的WAPI标准</li></ul></li><li><strong>信息泄漏攻击</strong><ul><li>信息泄露的方式包括利用协议缺陷攻破系统、获得信息，软硬件故障导致意外泄密，病毒侵袭，以及内部信息安全管理不善所导致。</li><li>信息泄露会使攻击者获得有价值的系统相关信息，并用之攻破系统</li></ul></li><li><strong>指数攻击</strong><ul><li>指数攻击通常指的是攻击者利用系统或网络的某个特性，以极快的速度增长攻击力度，使得防御措施难以跟上攻击的变化。</li></ul></li><li><strong>拒绝服务攻击(DOS攻击)</strong><ul><li>拒绝服务攻击(DoS)指攻击者利用系统缺陷，通过执行一些恶意的操作而使得合法的系统用户不能及时地得到应得的服务或系统资源。</li><li>分布式拒绝服务攻击(Distributed Denial of Service，DDoS)是一种基于DoS攻击、但形式特殊的拒绝服务攻击，采用一种分布、协作的大规模攻击方式。</li></ul></li><li><strong>SYN Flood(泛洪)攻击</strong><ul><li>SYNFlood攻击是一种常见的DoS攻击，通过发送大量的SYN请求来消耗服务器的资源，导致服务器无法处理正常的请求。</li></ul></li><li><strong>Smurf 攻击</strong><ul><li>Smurf攻击是一种拒绝服务攻击，攻击者发送大量的ICMP回显请求数据包到一个广播地址，使得网络上的所有主机都向被攻击的主机发送ICMP回显应答。</li></ul></li><li><strong>社会工程学攻击</strong><ul><li>社会工程学攻击是一种通过受害者心理弱点、本能反应、好奇心、信任、贪婪等心理陷阱进行欺骗、伤害等危害手段，取得自身利益的手法。</li><li>社会工程学是非传统的信息安全</li><li>常用的手段：环境渗透、引诱、伪装、恐吓、恭维、说服</li></ul></li></ol></li></ol><h3 id="osi模型与安全体系结构">OSI模型与安全体系结构</h3><ol type="1"><li><strong>ISO 7498-2标准</strong><ul><li>确定了OSI开放系统互连参考模型的信息安全体系结构。</li><li>充分体现信息安全层次性和结构性特点，是一个以防护为主的静态的安全体系结构。</li></ul></li><li><strong>OSI安全体系结构模型</strong><ul><li>包括安全服务、安全机制和安全攻击。</li><li><figure><img src="image-21.png" srcset="/img/loading/loading3.gif" lazyload alt="OSI"><figcaption aria-hidden="true">OSI</figcaption></figure></li></ul></li><li><strong>安全服务</strong><ul><li>分为认证服务、访问控制服务、数据机密性服务、数据完整性服务和非否认服务。</li></ul><ol type="1"><li><strong>认证服务</strong><ul><li><strong>定义：</strong>提供关于某个实体(人或事物)身份的保证，证实实体声明的身份。</li><li>认证服务是可控性服务的重要组成部分，通常使用在需要提交人或者事物的身份的这一类特殊的通信过程中。</li><li><strong>类型：</strong><ul><li><strong>对等实体认证(Peer Entity Authentication)：</strong>确认通信过程中远端用户的身份。</li><li><strong>数据起源认证(Data Origin Authentication)：</strong>确认数据发送者的身份，保证数据的真正起源。</li></ul></li></ul></li><li><strong>访问控制服务</strong><ul><li><strong>定义：</strong>实施授权的一种方法，防止对资源的未授权使用。</li><li><strong>作用：</strong><ul><li>保护资源以防止非授权访问和操纵。</li><li>保护敏感信息不经过有风险的环境传送。</li><li>限制实体的访问权限，通常是经过认证的合法实体。</li></ul></li></ul></li><li><strong>数据机密性服务</strong><ul><li><strong>定义：</strong> 保护信息不泄露或不暴露给未授权的实体。</li><li><strong>保密粒度：</strong>流(stream)、消息(message)、选择字段(field)</li><li><strong>内容：</strong><ul><li><strong>数据的机密性服务：</strong>使用加密手段保护数据不被未授权者推断出敏感信息。</li><li><strong>业务流机密性服务：</strong>防止攻击者从分析网络业务流中得到敏感信息。</li></ul></li></ul></li><li><strong>数据完整性服务</strong><ul><li><strong>定义：</strong>确保数据的价值和存在性没有改变，对抗数据篡改攻击。</li><li><strong>内容：</strong><ul><li><strong>单个数据单元或字段的完整性：</strong>保护数据单元不被非授权者修改。</li><li><strong>数据单元流或字段流的完整性：</strong>保护数据单元序列的完整性，防止数据单元的重放。</li></ul></li></ul></li><li><strong>非否认服务(不可抵赖性)</strong><ul><li><strong>定义：</strong>阻止参与某次通信交换的一方在事后否认曾经发生过本次交换的事实。</li><li><strong>类型：</strong><ul><li><strong>起源的否认：</strong>向数据接收者提供数据源的证据，防止发送者否认发送过数据。</li><li><strong>传递的否认：</strong>向数据发送者提供数据已交付给接收者的证据，防止接收者否认收到数据。</li></ul></li></ul></li></ol></li><li><strong>安全机制</strong><ul><li>安全服务与安全机制关系：<ul><li>安全服务体现了安全系统的功能；而安全机制则是安全服务的实现。</li><li>一个安全服务可以由多个安全机制实现；而一个安全机制也可以用于实现多个安全服务中。</li><li><figure><img src="image-22.png" srcset="/img/loading/loading3.gif" lazyload alt="安全服务与安全机制关系"><figcaption aria-hidden="true">安全服务与安全机制关系</figcaption></figure></li></ul></li></ul></li></ol><h3 id="网络安全模型">网络安全模型</h3><ol type="1"><li><strong>网络安全模型-网络通信</strong><ul><li>保护信息传输，需要提供<strong>安全机制和安全服务</strong>。<ul><li>一部分是对发送的信息进行与安全相关的转换。例如，消息的加密，使开放网络对加密的消息不可读；又如附加一些基于消息内容的码，用来验证发送者的身份。</li><li>另一部分是由两个主体共享的秘密信息，而对开放网络是保密的。例如，用以加密转换的密钥，用于发送前的加密和接收前的解密。</li></ul></li><li>需要可信的第三方</li><li>一种能被通信主体使用的协议，这种协议使用安全算法和秘密信息以便获得特定的安全服务。</li><li><figure><img src="image-23.png" srcset="/img/loading/loading3.gif" lazyload alt="网络通信"><figcaption aria-hidden="true">网络通信</figcaption></figure></li></ul></li><li><strong>网络安全模型-访问安全</strong><ul><li>考虑了黑客攻击、病毒与蠕虫等的非授权访问。</li><li>黑客攻击可以形成两类威胁：一类是<strong>信息访问威胁</strong>，即非授权用户截获或修改数据；另一类是<strong>服务威胁</strong>，即服务缺陷以禁止合法用户使用。</li><li>病毒和蠕虫是软件攻击的两个实例，这类攻击通常是通过移动存储介质引入系统，并隐藏在有用软件中；也可通过网络接入系统。</li><li>两个层次：<ul><li><strong>网闸或看门人功能</strong>，阻止非授权用户访问</li><li><strong>内部安全控制(监控)</strong>：监测有害入侵者的存在</li></ul></li><li><figure><img src="image-24.png" srcset="/img/loading/loading3.gif" lazyload alt="访问安全"><figcaption aria-hidden="true">访问安全</figcaption></figure></li></ul></li><li><strong>网络安全模型- P2DR-时间模型</strong><ul><li>P2DR模型是可量化的、可由数学证明的、基于时间的的安全模型，</li><li>包含安全策略(Policy)、防护(Protection)、检测(Detection)和响应(Response)。<ul><li>安全策略是P2DR安全模型的核心，所有的防护、检测、响应都是依据策略实施的；</li><li>防护主要是预防安全事件的发生，发现存在的系统脆弱性和防止意外威胁和恶意威胁；</li><li>检测是P2DR中一个非常重要的环节，是<strong>静态防护转化为动态防护的关键</strong>，动态响应和加强防护的依据，同时也是强制落实安全策略的工具；</li><li>响应在安全系统中占有重要的地位，是解决安全潜在威胁最有效的方法。</li></ul></li><li>基本思想：信息安全相关的所有活动，无论是攻击、防护、检测和响应行为，都要消耗时间，因此可以用<strong>时间尺度</strong>来衡量一个体系的能力和安全性。</li><li>理论：系统的检测时间与响应时间越长，或对系统的攻击时间越短，则系统的暴露时间越长，系统就越不安全；如果系统的暴露时间<span class="math inline"><em>E</em><sub><em>t</em></sub> &lt;  = 0</span>(即<span class="math inline"><em>D</em><sub><em>t</em></sub> + <em>R</em><sub><em>t</em></sub> &lt;  = <em>P</em><sub><em>t</em></sub></span>)，那么认为系统是安全的</li><li>安全的目标：尽可能地增大保护时间，尽量地减少检测时间和响应时间。</li></ul></li><li><strong>网络安全模型- PDRR</strong><ul><li>包括防护(Protection)、检测(Detection)、响应(Response)、恢复(Recovery)</li><li>这4个部分构成了一个<strong>动态的信息安全周期</strong></li><li><figure><img src="image-25.png" srcset="/img/loading/loading3.gif" lazyload alt="PDRR"><figcaption aria-hidden="true">PDRR</figcaption></figure></li></ul></li></ol><h2 id="第二节-网络安全防护技术">第二节 网络安全防护技术</h2><h3 id="防火墙">防火墙</h3><ol type="1"><li><strong>防火墙概述</strong><ul><li><strong>定义</strong>：防火墙是在两个网络之间执行访问控制策略的一个或一组安全系统。由软件和硬件组成的系统集合，是实现网络安全策略的有效工具之一，位于安全的网络和不安全的网络之间，属于<strong>边界防护设备</strong>。</li><li><strong>功能</strong>：<ul><li>通过设置访问控制规则，对进出网络边界的<strong>数据流进行过滤</strong>。</li><li>防火墙是建立在内外网络边界上的<strong>过滤封锁机制</strong>，是一种用于保护本地系统或者网络不受基于网络的安全威胁的有效方法。<ul><li><strong>内部网络</strong>(受信网络)被认为是安全和可信赖的，而<strong>外部网络</strong>(通常是Internet，非受信网络)被认为是不安全和不可信赖的。</li><li><strong>非军事化区(DMZ)</strong>：为了配置管理方便，内网中需要向外提供服务的服务器往往放在一个单独的网段，这个网段便是非军事化区。</li></ul></li></ul></li><li><figure><img src="image-26.png" srcset="/img/loading/loading3.gif" lazyload alt="防火墙概述"><figcaption aria-hidden="true">防火墙概述</figcaption></figure></li></ul></li><li><strong>防火墙的要求</strong><ul><li>所有进出网络数据流都必须经过防火墙。</li><li>只允许经授权的数据流通过防火墙。</li><li>防火墙自身对入侵免疫，即确保自身安全。</li></ul></li><li><strong>防火墙提供的四种控制机制</strong><ul><li><strong>服务控制</strong>：确定了可访问的Internet服务类型，这种控制是双向的，如防火墙可以<strong>以IP地址和TCP端口号为基础对流量进行过滤</strong>；可以提供委托代理软件对收到的每一个服务请求进行解释之后才允许通过。</li><li><strong>方向控制</strong>：确定特定的服务请求可以发起和通过的方向，即允许通过防火墙进入或离开。</li><li><strong>用户控制</strong>：控制特定用户对某些服务的访问权限。</li><li><strong>行为控制</strong>：控制特定服务的应用方式，如控制外部用户只能访问只能访问本地web服务器的部分信息。</li></ul></li><li><strong>防火墙的发展</strong><ul><li><figure><img src="image-37.png" srcset="/img/loading/loading3.gif" lazyload alt="防火墙发展"><figcaption aria-hidden="true">防火墙发展</figcaption></figure></li></ul></li><li><strong>防火墙分类及设计结构</strong><ul><li>防火墙分类<ul><li><figure><img src="image-27.png" srcset="/img/loading/loading3.gif" lazyload alt="防火墙分类"><figcaption aria-hidden="true">防火墙分类</figcaption></figure></li></ul></li><li>防火墙设计结构<ul><li><figure><img src="image-28.png" srcset="/img/loading/loading3.gif" lazyload alt="防火墙设计结构"><figcaption aria-hidden="true">防火墙设计结构</figcaption></figure></li></ul></li></ul></li><li><strong>OSI模型与防火墙类型的关系</strong><ul><li>防火墙工作于OSI模型的层次越高，能提供的安全保护等级就越高。</li><li><figure><img src="image-29.png" srcset="/img/loading/loading3.gif" lazyload alt="OSI"><figcaption aria-hidden="true">OSI</figcaption></figure></li><li>防火墙通常建立在<strong>TCP/IP模型</strong>基础上，OSI模型与TCP/IP模型之间<strong>并不存在一一对应</strong>的关系</li><li><figure><img src="image-30.png" srcset="/img/loading/loading3.gif" lazyload alt="OSI"><figcaption aria-hidden="true">OSI</figcaption></figure></li></ul></li><li><strong>防火墙能与不能</strong><ul><li><figure><img src="image-32.png" srcset="/img/loading/loading3.gif" lazyload alt="防火墙能与不能"><figcaption aria-hidden="true">防火墙能与不能</figcaption></figure></li></ul></li><li><strong>防火墙原理</strong><ol type="1"><li><strong>静态包过滤防火墙</strong>：<ul><li><strong>包过滤(PacketFiltering)技术</strong>是防火墙利用对数据包的分析能力，在<strong>网络层</strong>中根据数据包中包头信息有选择地实施允许通过或阻断。</li><li><figure><img src="image-33.png" srcset="/img/loading/loading3.gif" lazyload alt="静态包过滤"><figcaption aria-hidden="true">静态包过滤</figcaption></figure></li><li>作用过程：<ul><li>防火墙接收到从外部网络到达防火墙的数据包，对数据包过滤。</li><li>对数据包施加过滤规则，对数据包IP头和传输字段内容进行检查。</li><li>如果没有规则与数据包头信息匹配，则对数据包施加默认规则。</li></ul></li><li>判断依据(只考虑IP包)：<ul><li>数据包<strong>封装协议类型</strong>：TCP、UDP、ICMP、IGMP等</li><li><strong>源、目的IP地址</strong>，数据包的TCP/UDP源、目的端口</li><li><strong>服务类型(端口)</strong>：FTP(21)、HTTP(80)、DNS(53)等</li><li>IP选项：源路由、记录路由等</li><li>TCP选项：SYN、ACK、FIN、RST等</li><li>其它协议选项：ICMP ECHO、ICMP ECHO REPLY等</li><li><strong>数据包流向</strong>：in或out</li><li><strong>数据包流经网络接口</strong>：eth0、eth1</li></ul></li></ul></li><li><strong>动态包过滤防火墙</strong>：<ul><li>与普通包过滤防火墙相似，大部分工作于<strong>网络层</strong>。有些安全性高的动态包过滤防火墙，则工作于<strong>传输层</strong>。</li><li><strong>动态包过滤防火墙的不同点</strong>：<ul><li>对外出数据包进行<strong>身份记录</strong>，便于下次让具有相同连接的数据包通过。</li><li>动态包过滤防火墙需要<strong>对已建连接和规则表进行动态维护</strong>，因此是动态的和有状态的。</li></ul></li><li>两种实现方式：<ul><li>实时地改变普通包过滤器的规则集</li><li>采用类似电路级网关的方式转发数据包</li></ul></li></ul></li><li><strong>电路级网关防火墙</strong>：<ul><li>被称为线路级网关，工作在<strong>会话层</strong>，通常作为<strong>应用代理服务器</strong>的一部分，在应用代理类型的防火墙中实现，在<strong>两个主机首次建立TCP连接时创立一个电子屏障</strong>。</li><li>电路级网关不<strong>允许端到端TCP直接连接</strong>，相反，电路级网关充当中介，<strong>接收外来请求，转发请求</strong>。<ul><li>监视两主机建立连接时的握手信息，如通过在TCP3次握手建立连接的过程中，SYN、ACK等标志和序列号等是否合乎逻辑，判定该会话请求是否合法。</li><li><strong>一旦会话连接有效后网关在客户和服务器间中转数据</strong>。</li></ul></li><li>电路级网关的防火墙的安全性比较高，但它仍<strong>不能检查应用层的数据包</strong>以消除应用层攻击的威胁。</li><li><figure><img src="image-34.png" srcset="/img/loading/loading3.gif" lazyload alt="电路级网关"><figcaption aria-hidden="true">电路级网关</figcaption></figure></li></ul></li><li><strong>应用层网关防火墙</strong>：<ul><li>代理对整个数据包进行检查，因此能在<strong>应用层</strong>上对数据包进行过滤。</li><li>工作特点：<ul><li>必针对每个服务运行一个代理。</li><li>对数据包进行逐个检查和过滤。</li><li><strong>采用“强应用代理”</strong></li><li>在更高层上过滤信息自动创建必要的包过滤规则</li><li>当前最安全的防火墙结构之一。</li></ul></li><li><strong>应用代理与电路级网关两个重要区别</strong>：<ul><li>代理是针对应用的。</li><li>代理对整个数据包进行检查，因此能在OSI模型的应用层上对数据包进行过滤。</li></ul></li></ul></li><li><strong>状态检测包过滤防火墙</strong>：<ul><li>状态检测是一种相当于4.5层的过滤技术，建立状态连接表，并将进出网络的数据当成一个个的会话，利用状态表跟踪每一个会话状态。</li><li><figure><img src="image-35.png" srcset="/img/loading/loading3.gif" lazyload alt="状态检测"><figcaption aria-hidden="true">状态检测</figcaption></figure></li><li>优点：不限于包过滤防火墙的3/4层的过滤，又不需要应用层网关防火墙的5层过滤，既提供了比包过滤防火墙更高的安全性和更灵活的处理，也避免了应用层网关防火墙带来的速度降低的问题。</li><li>作用过程：<ul><li>要实现状态检测，最重要的是<strong>实现连接的跟踪功能，实现多个包的关联分析</strong>。能够进一步分析主连接中的内容信息，识别出所协商的子连接的端口而在防火墙上将其动态打开，连接结束时自动关闭。</li><li>通过<strong>建立一个出站的TCP连接目录</strong>加强了TCP数据流的监测规则，对网络通信的各层实施监测分析，提取相关的通信和状态信息，并在动态连接表中进行状态及上下文信息的存储和更新</li></ul></li></ul></li><li><strong>空气隙防火墙</strong><ul><li>物理隔离，通过断开网络连接来保护内部网络不受外部网络的威胁。</li><li><figure><img src="image-36.png" srcset="/img/loading/loading3.gif" lazyload alt="空气隙"><figcaption aria-hidden="true">空气隙</figcaption></figure></li></ul></li></ol></li></ol><h3 id="入侵检测系统">入侵检测系统</h3><ol type="1"><li><strong>入侵检测系统发展史</strong><ul><li><figure><img src="image-38.png" srcset="/img/loading/loading3.gif" lazyload alt="发展史"><figcaption aria-hidden="true">发展史</figcaption></figure></li></ul></li><li><strong>通用的入侵检测系统模型</strong><ul><li><figure><img src="image-39.png" srcset="/img/loading/loading3.gif" lazyload alt="系统模型"><figcaption aria-hidden="true">系统模型</figcaption></figure></li></ul></li><li><strong>功能任务</strong><ul><li><strong>入侵检测系统定义</strong><ul><li>入侵检测系统（IDS）是一种对网络传输进行即时监视，在发现可疑传输时发出警报或者采取主动反应措施的网络安全设备。</li></ul></li><li><strong>入侵检测定义</strong><ul><li>入侵检测(IDS : Intrusion DetectionSystem)是通过从计算机网络或系统中的若干关键点<strong>收集信息并对其进行分析</strong>，从中发现网络或系统中是否有违反安全策略的行为和遭到袭击迹象的一种机制，基本上<strong>不具有访问控制的能力</strong>，单独使用不能起到保护网络的作用，也<strong>不能独立地防止任何一种攻击</strong>。</li></ul></li><li>功能任务<ul><li>信息收集：用户在网络、系统、数据库及应用系统中活动的状态和行为。<ul><li>系统和网络的日志文件</li><li>目录和文件中的异常改变</li><li>程序执行中的异常行为</li><li>物理形式的入侵信息</li></ul></li><li>信息分析<ul><li>模式匹配</li><li>统计分析</li><li>完整性分析</li></ul></li><li>安全响应<ul><li>主动响应</li><li>被动响应</li></ul></li></ul></li></ul></li><li><strong>系统结构</strong><ul><li>事件提取：负责提取相关运行数据或记录，并对数据进行简单过滤。</li><li>入侵分析：找出入侵痕迹，发现异常行为，分析入侵行为并定位入侵者。</li><li>入侵响应：分析出入侵行为后被触发，根据入侵行为产生响应。</li><li>远程管理：在一台管理站上实现统一的管理监控。</li><li><figure><img src="image-40.png" srcset="/img/loading/loading3.gif" lazyload alt="系统结构"><figcaption aria-hidden="true">系统结构</figcaption></figure></li></ul></li><li><strong>分类</strong><ul><li><strong>按照数据来源分类</strong><ol type="1"><li><em>基于网络的IDS(NIDS)</em>：截获数据包，提取特征并与知识库中已知的攻击签名相比较。<ul><li>主要优点：<ul><li>拥有成本低。</li><li>攻击者转移证据困难。</li><li>实时检测和响应。</li><li>能够检测未成功的攻击企图。</li><li>操作系统独立。</li></ul></li><li>运作方式<ul><li>根据网络流量、网络数据包和协议来分析入侵检测。</li><li>通常利用一个运行在随机模式下的网络适配器来监视并分析通过网络的所有通信业务。</li></ul></li><li>常用技术<ul><li>攻击模式、表达式或字节匹配。</li><li>频率或穿越阈值。</li><li>低级事件的相关性。</li><li>统计学意义上的非常规现象检测。</li></ul></li><li><figure><img src="image-43.png" srcset="/img/loading/loading3.gif" lazyload alt="NIDS部署"><figcaption aria-hidden="true">NIDS部署</figcaption></figure></li></ul></li><li><em>基于主机的IDS(HIDS)</em>：通过对日志和审计记录的监控分析来发现攻击后的误操作。</li><li><em>分布式IDS(DIDS)</em>：同时分析来自主机系统审计日志和网络数据流。</li></ol></li><li><strong>按照检测策略分类</strong><ol type="1"><li><strong><em>误用检测</em>：将收集的信息与数据库作比较</strong></li></ol><ul><li><figure><img src="image-42.png" srcset="/img/loading/loading3.gif" lazyload alt="误用检测"><figcaption aria-hidden="true">误用检测</figcaption></figure></li><li>原理：误用检测技术又称为<strong>基于知识(或规则)的检测技术</strong>或者<strong>模式匹配检测技术</strong>，收集非正常操作的行为特征，建立相关的特征库，当监测的用户或系统行为与库中的记录相匹配时，系统就认为这种行为是入侵。<ul><li>假设所有的网络攻击行为和方法都具有一定的模式或特征。入侵模式说明了那些导致安全突破或其它误用的事件中的特征、条件、排列和关系。</li></ul></li><li>入侵检测方法：<ul><li>基于条件概率误用检测</li><li>基于专家系统误用检测</li><li>基于状态迁移误用检测</li><li>基于键盘监控误用检测</li><li>基于Petri网状态转换检测</li></ul></li></ul><ol start="2" type="1"><li><strong><em>异常检测</em>：测量属性的平均值，并用来与系统行为比较</strong></li></ol><ul><li><figure><img src="image-41.png" srcset="/img/loading/loading3.gif" lazyload alt="异常检测"><figcaption aria-hidden="true">异常检测</figcaption></figure></li><li>原理：异常检测技术又称为<strong>基于行为的入侵检测技术</strong>，用来识别主机和网络中的<strong>异常行为</strong>。该技术假设攻击与正常合法的活动有明显的差异，首先假设网络攻击行为是不常见的或是异常的，区别于所有的正常行为。<ul><li><strong>阈值检测</strong>：异常检测技术先<strong>定义一组系统正常活动的阈值</strong>，如CPU利用率、内存利用率、文件校验和等，然后将系统运行时的数值与所定义的“正常”情况比较，得出是否有被攻击的迹象。</li><li><strong>用户轮廓(Profile)</strong>:通常定义为各种行为参数及其阀值的集合，用于描述正常行为范围。</li></ul></li><li>入侵检测方法：<ul><li>统计异常检测方法</li><li>特征选择异常检测方法</li><li>基于贝叶斯推理异常检测方法</li><li>基于贝叶斯网络异常检测方法</li><li>基于模式预测异常检测方法</li></ul></li></ul><ol start="3" type="1"><li><strong><em>完整性分析</em>：关注是否被更改</strong></li></ol></li></ul></li><li><strong>网络诱骗系统</strong><ul><li>密罐技术(Honeypot)就是建立一个虚假的网络，诱惑黑客攻击这个虚假的网络，从而达到保护真正网络的目的。<ul><li>蜜罐系统是一个包含漏洞的诱骗系统，通过模拟一个或多个易攻击的主机，给攻击者提供一个容易攻击的目标</li><li>观测黑客如何探测并最终入侵系统</li><li>拖延攻击者对真正目标的攻击</li></ul></li><li>分类：<ul><li><figure><img src="image-44.png" srcset="/img/loading/loading3.gif" lazyload alt="Honeypot"><figcaption aria-hidden="true">Honeypot</figcaption></figure></li></ul></li></ul></li></ol><h3 id="虚拟专网vpn">虚拟专网VPN</h3><ol type="1"><li><strong>虚拟专网VPN概述</strong><ul><li><strong>定义</strong>：VPN(虚拟专网，Virtual PrivateNetwork)：将物理上分布在不同地点的网络通过公用网络连接而构成<strong>逻辑上的虚拟子网</strong>。</li><li><strong>原理</strong>：VPN基于Internet/Intranet等公用开放的传输媒体，通过<strong>加密和认证</strong>等安全机制建立虚拟的数据传输通道，以保障在公共网上传输私有数据信息不被窃取、篡改，是目前广泛应用于电子商务、电子政务等应用安全保护的安全技术。</li><li>三个基本安全功能<ul><li><strong>加密数据</strong>：以保证通过公网传输的信息即使被他人截获也不会泄露。</li><li><strong>信息认证和身份认证</strong>：保证信息的完整性、合法性，并能鉴别用户的身份。</li><li><strong>访问控制</strong>：不同的用户有不同的访问权限。</li></ul></li></ul></li><li><strong>VPN特点</strong><ul><li>费用低</li><li>安全保障</li><li>服务质量保证(QoS)</li><li>可扩充性和灵活性</li><li>可管理性</li></ul></li><li><strong>VPN分类</strong><ul><li><strong>远程访问VPN(Access VPN)，也称为VPDN(拨号VPN)</strong><ul><li>移动用户在任何地方、时间与公司总部、公司内联网的VPN设备建立起隧道或秘密信道，实现访问连接。</li></ul></li><li><strong>网关-网关VPN</strong>：<ul><li>组建内联网(Intranet VPN，企业内部虚拟专网)<ul><li>在公司远程分支机构的LAN和公司总部LAN之间的VPN</li></ul></li><li>组建外联网(Extranet VPN，扩展的企业内部虚拟专网)。<ul><li>在供应商、商业合作伙伴的LAN和公司的LAN之间的VPN</li></ul></li></ul></li><li><figure><img src="image-45.png" srcset="/img/loading/loading3.gif" lazyload alt="VPN分类"><figcaption aria-hidden="true">VPN分类</figcaption></figure></li></ul></li><li><strong>VPN关键技术</strong><ul><li>隧道技术</li><li>加/解密技术</li><li>密钥管理技术</li><li>身份认证技术</li><li>访问控制技术</li></ul></li><li><strong>IPSEC协议</strong><ol type="1"><li><strong>概述</strong><ul><li><strong>定义</strong>：IPSec是一种由IETF设计的端到端的<strong>确保IP层通信安全</strong>的机制，为保证在Internet上传送数据的安全保密性能的<strong>三层隧道加密协议</strong>，弥补IPv4设计时缺乏安全性考虑的不足，将安全服务集成到IP协议中(<strong>加强IP协议的安全</strong>)。</li><li><strong>IPSec对IPV4是可选的，对IPV6是必须的</strong></li><li><strong>地位</strong>：IPSec定义了一种标准的、健壮的以及包容广泛的机制，为IP以及上层协议（比如TCP或者UDP）提供安全保证。<br></li><li>IPSec由三种机制共同保障:<ul><li>认证</li><li>数据机密性</li><li>密钥管理</li></ul></li><li>IPSec实现两个基本目标：<ul><li>保护IP数据包安全</li><li>为抵御网络攻击提供防护措施。</li></ul></li><li>IpSec提供服务：<ul><li>机密性（加密）</li><li>数据完整性（接收方可以检验通过 Internet传输的数据是否没有以任何方式更改或篡改过）</li><li>身份验证（检验数据来源的身份）</li><li>反重播保护（能够检测并拒绝重播的数据包以防止被欺骗）</li></ul></li></ul></li><li><strong>体系结构</strong><ul><li>IPSec由两大部分，三类协议构成：<ul><li>AH(Authentication Header，认证头)<ul><li>AH提供认证和数据完整性</li></ul></li><li>ESP(Encapsulating Security Payload，封装安全载荷)<ul><li>ESP具有所有AH的功能，还可以利用加密技术实现通信保密</li></ul></li><li>IKE(Internet Key Exchange，密钥协商及交换协议)构成。<ul><li>IKE定义了通信实体间进行身份认证、创建安全关联SA、协商加密算法以及生成共享会话密钥的方法。</li></ul></li></ul></li><li><figure><img src="image-46.png" srcset="/img/loading/loading3.gif" lazyload alt="IPSec"><figcaption aria-hidden="true">IPSec</figcaption></figure></li><li>两种操作模式：<ul><li>传输模式(主机与主机的直接通信)</li><li>隧道模式(常用于关联到多台主机的网络访问连入设备间使用)</li></ul></li><li><strong>安全关联SA</strong>(SecurityAssociation)：是通信对等方对某些要素的一种协定</li><li><strong>两个重要数据库</strong>：安全策略数据库SPD，安全关联数据库SAD</li></ul></li><li><strong>工作模式</strong><ul><li><strong>传输模式</strong>：<ul><li><figure><img src="image-47.png" srcset="/img/loading/loading3.gif" lazyload alt="传输模式"><figcaption aria-hidden="true">传输模式</figcaption></figure></li><li>保护的是<strong>IP载荷</strong>，通常应用于<strong>两台主机之间，保护传输层协议头，实现端到端通信的安全性</strong>，该模式要求主机支持IPSec。</li><li>当数据包从传输层传送给网络层时，AH和ESP会进行拦截，在IP头与上层协议之间需插入一个IPSec头。当同时应用AH和ESP到传输模式时，应该先应用ESP，再应用AH。</li><li><figure><img src="image-49.png" srcset="/img/loading/loading3.gif" lazyload alt="传输模式"><figcaption aria-hidden="true">传输模式</figcaption></figure><ul><li>采用传输模式时，IPSec只对IP数据包的净荷进行加密或认证；</li><li>封装数据包继续使用原IP头部，只对部分域进行修改；</li><li>IPSec协议头部插入到原IP头部和传送层头部之间。</li></ul></li></ul></li><li><strong>隧道模式</strong>：<ul><li><figure><img src="image-48.png" srcset="/img/loading/loading3.gif" lazyload alt="隧道模式"><figcaption aria-hidden="true">隧道模式</figcaption></figure></li><li>保护的是<strong>整个IP包</strong>，应用于<strong>网关模式中</strong>，即在主机与网关(防火墙、路由器)或两个网关之间加载IPSec。</li><li>把一个包封装在另一个新包里面，整个源数据包作为新包的载荷部分，并在前面添加一个新的IP对。被封装的数据包在隧道的两个端点之间通过公共互联网络进行路由。</li><li>被封装的数据包在公共互联网络上传递时所经过的逻辑路径称为<strong>隧道</strong>。一旦到达网络终点，数据将被解包并转发到最终目的地。</li><li><figure><img src="image-50.png" srcset="/img/loading/loading3.gif" lazyload alt="隧道模式"><figcaption aria-hidden="true">隧道模式</figcaption></figure><ul><li>采用隧道模式时，IPSec对整个IP数据包进行加密或认证；</li><li>产生一个新的IP头，IPSec头被放在新IP头和原IP数据包之间，组成一新IP头。</li></ul></li></ul></li><li><figure><img src="image-51.png" srcset="/img/loading/loading3.gif" lazyload alt="工作模式"><figcaption aria-hidden="true">工作模式</figcaption></figure></li></ul></li></ol></li><li><strong>TLS协议概述</strong><ul><li><strong>定义</strong>： SSL VPN也称做传输层安全协议(TLS)VPN。</li><li>TLS：基于会话的<strong>加密和认证</strong>的Internet协议，为通信的两个实体提供了一个安全的通道。</li><li>TLS协议主要用于HTTPS协议中，TLS也可以作为构造VPN的技术。</li><li>TLS VPN最大优点是用户不需要安装和配置客户端软件。</li><li>由于TLS协议允许使用<strong>数字签名和证书</strong>，所以它可以提供强大的认证功能。</li></ul></li></ol><h3 id="计算机病毒防护技术">计算机病毒防护技术</h3><ol type="1"><li><strong>计算机病毒特征</strong><ul><li><strong>传染性</strong>：计算机病毒会通过各种渠道扩散到更多的计算机系统上。</li><li><strong>隐蔽性</strong>：病毒通常会采用隐藏进程、文件等手段延长自己的生命周期，隐藏自己的行迹，以防被发现、被删除。</li><li><strong>寄生性</strong>：病毒通常附着在其它正常程序之中，当调用程序时窃取到系统的控制权，先于正常程序执行。<strong>现在这个特性正在变化</strong></li><li><strong>潜伏性</strong>：大部分病毒感染系统之后不会马上发作，可长期隐藏在系统中，只有在满足其特定条件时才启动其表现（破坏）模块。</li><li><strong>破坏性</strong>：侵入系统后会对系统及应用程序产生不同程度的影响，如降低计算机工作效率，占用系统资源，导致系统崩溃。</li></ul></li><li><strong>计算机病毒传播方式</strong><ul><li>通过共享目录攻击</li><li>通过漏洞攻击</li><li>通过WEB方式攻击</li><li>通过FIP方式攻击</li><li>通过邮件攻击</li><li>通过光盘读写攻击</li><li>通过软盘读写攻击</li></ul></li><li><strong>计算机反病毒技术与发展历史</strong><ul><li>反病毒的核心思想：在病毒的存储、传播和执行等阶段，基于“发现”、“拦截”、“清除”等基本手段来对抗病毒</li><li>反病毒技术和形式经历了三个主要阶段：<ul><li>基于<strong>简单特征码</strong>查杀的单一专杀工具阶段</li><li>基于<strong>广谱特征码</strong>查杀、主动防御拦截的综合杀毒软件阶段</li><li>基于<strong>云、人工智能和大数据</strong>技术的互联网查杀阶段。</li></ul></li></ul></li><li><strong>计算机病毒分类</strong><ul><li>木马型病毒</li><li>感染性病毒</li><li>蠕虫型病毒</li><li>后门型病毒</li><li>恶意软件</li></ul></li><li><strong>计算机病毒主流检测技术</strong><ul><li>病毒检测原理<ul><li><strong>采样、匹配、基准</strong></li></ul></li><li>主流检测技术<ul><li>基于特征码的传统检测技术<ul><li>采样为固定位置、采用精准匹配方式技术简单、易于实现、查杀精准速度慢、无法查杀未知病毒</li></ul></li><li>基于行为的传统检测技术<ul><li>针对病毒动态行为进行检测，针对隐蔽性强的病毒有更好检测能力，具备查杀未知病毒能力</li></ul></li><li>基于云技术的云查杀技术<ul><li>将“匹配”和“基准”放在云端进行，反应速度快，终端资源使用大大减小<br></li></ul></li><li>基于大数据与人工智能的查杀技术<ul><li>将“匹配”和“基准”放在云端进行，可以根据模型匹配已知与未知病毒</li></ul></li></ul></li></ul></li></ol><h3 id="安全漏洞扫描技术">安全漏洞扫描技术</h3><ol type="1"><li><strong>漏洞概述</strong><ul><li><strong>定义</strong>：漏洞(Vulnerability)又叫脆弱性，是信息技术、信息产品、信息系统在设计、实现、配置、<strong>运行等过程中有意或无意产生的缺陷</strong>，一旦被恶意主体所利用，就会造成对信息系统的安全损害，从而影响构建于信息系统之上正常服务的运行，危害信息系统及信息的安全属性。</li><li><strong>特点</strong>：<ul><li>漏洞是信息系统<strong>自身的弱点和缺陷</strong>；</li><li>漏洞<strong>存在于一定的环境中</strong>，寄生在一定的客体上；</li><li>具有<strong>可利用性和违规性；本身的存在虽不会造成破坏，但是可以被攻击者利用</strong>，从而给信息系统安全带来威胁和损失</li></ul></li></ul></li><li><strong>漏洞扫描技术概述</strong><ul><li>漏洞扫描即针对通用漏洞的检测，需要依据通用漏洞的形成原理和其造成的外部表现来判断。由系统维护人员识别安全风险，依据结果对漏洞实施有针对性的防护或修补。</li><li>漏洞按照被公布时间的不同阶段，可分为<ul><li>1 Day 漏洞<ul><li>发现并公布的最新漏洞</li></ul></li><li>N Day 漏洞<ul><li>被公布的历史漏洞</li></ul></li><li>0 Day 漏洞<ul><li>未被公开的漏洞</li></ul></li></ul></li><li>各类漏洞管理标准<ul><li>国外：MITRE CVE、CWE、NIST NVD、Symantec BUGTRAQ等</li><li>国内：中国信息安全测评中心维护的CNNVD国家信息安全漏洞库，国家互联网应急中心CNCERT维护的CNCVE、CNVD国家信息安全漏洞共享平台等</li></ul></li></ul></li><li><strong>漏洞扫描技术分类</strong><ol type="1"><li>按照漏洞扫描的目标对象类型维度划分</li></ol><ul><li><strong>系统扫描</strong>：扫描目标是已规模化发布的系统、应用软件或者设备。<ul><li><figure><img src="image-52.png" srcset="/img/loading/loading3.gif" lazyload alt="系统扫描"><figcaption aria-hidden="true">系统扫描</figcaption></figure></li></ul></li><li><strong>应用扫描</strong>：扫描目标是各种应用，以Web应用居多。<ul><li><figure><img src="image-53.png" srcset="/img/loading/loading3.gif" lazyload alt="应用扫描"><figcaption aria-hidden="true">应用扫描</figcaption></figure></li></ul></li><li><figure><img src="image-54.png" srcset="/img/loading/loading3.gif" lazyload alt="按照漏洞扫描的目标对象类型维度划分"><figcaption aria-hidden="true">按照漏洞扫描的目标对象类型维度划分</figcaption></figure></li></ul><ol start="2" type="1"><li>按照漏洞扫描的技术执行形式的维度划分</li></ol><ul><li><figure><img src="image-55.png" srcset="/img/loading/loading3.gif" lazyload alt="漏洞扫描技术"><figcaption aria-hidden="true">漏洞扫描技术</figcaption></figure></li></ul></li><li><strong>漏洞扫描原理简介</strong><ul><li>漏洞扫描基本流程原理<ul><li>存活判断：探测目标系统是否存活。</li><li>端口扫描：对已经存活的主机，探测主机上开启了哪些端口。</li><li>系统和服务识别：采用黑盒测试方法，通过研究其对各种探测的响应形成识别指纹，进而识别目标主机运行的操作系统。</li><li>漏洞检测：扫描器根据识别的系统与服务信息调用内置或用户外挂的口令字典进行口令猜测，并同时启动远程非登陆漏洞扫描。</li></ul></li><li><figure><img src="image-56.png" srcset="/img/loading/loading3.gif" lazyload alt="漏洞扫描原理"><figcaption aria-hidden="true">漏洞扫描原理</figcaption></figure></li><li>原理检测和版本检测<ul><li>原理检测(POC检测)：对目标机的相关端口发送请求构造的特殊数据包，判断漏洞是否存在。<ul><li>POC全称“proof of concept”，中文意思是漏洞概念验证。</li><li>通常由一段漏洞验证代码或者漏洞检测数据。通过对检测目标发送此代码或数据后，通过被检测目标返回的信息特殊性，判断漏洞的实际存在与否。</li></ul></li><li>版本检测：依照漏洞库标准实施，在漏洞与系统版本之间存在关联关系。</li></ul></li></ul></li></ol><h2 id="第三节-网络安全工程与管理">第三节 网络安全工程与管理</h2><h3 id="网络安全等级保护">网络安全等级保护</h3><ol type="1"><li><strong>网络安全等级保护制度</strong><ul><li>《网络安全法》第二十一条规定，国家实行网络安全等级保护制度，核心是对网络实施等级保护和分等级监督。</li><li>网络分为<strong>五个安全保护等级</strong>，根据网络在国家安全、经济建设、社会生活中的重要程度，以及其一旦遭到破坏、丧失功能或者数据被篡改、泄露、丢失、损毁后，对国家安全、社会秩序、公共利益以及相关公民、法人和其他组织的合法权益的危害程度等因素。</li></ul></li><li><strong>网络安全等级保护相关政策</strong><ul><li>信息安全等级保护是党中央国务院决定在信息系统安全领域实施的基本国策。</li><li>信息安全等级保护是国家信息安全保障工作的基本制度。</li><li>信息安全等级保护是国家信息安全保障工作的基本方法。</li><li><figure><img src="image-57.png" srcset="/img/loading/loading3.gif" lazyload alt="网络安全等级保护"><figcaption aria-hidden="true">网络安全等级保护</figcaption></figure></li></ul></li><li><strong>安全等级划分</strong><ul><li>第一级 用户自主保护级<ul><li>一旦受到破坏会对相关公民、法人和其他组织的合法权益造成损害，但不危害国家安全、社会秩序和公共利益的一般网络</li></ul></li><li>第二级 系统审计保护级<ul><li>一旦受到破坏会对相关公民、法人和其他组织的合法权益造成严重损害，或者对社会秩序和公共利益造成危害，但不危害国家安全的一般网络</li></ul></li><li>第三级 安全标记保护级<ul><li>一旦受到破坏会对相关公民、法人和其他组织的合法权益造成特别严重损害，或者会对社会秩序和社会公共利益造成严重危害，或者对国家安全造成危害的重要网络</li></ul></li><li>第四级 结构化保护级<ul><li>一旦受到破坏会对社会秩序和公共利益造成特别严重危害，或者对国家安全造成严重危害的特别重要网络</li></ul></li><li>第五级 访问验证保护级<ul><li>一旦受到破坏后会对国家安全造成特别严重危害的极其重要网络</li></ul></li></ul></li><li><strong>安全等级设计要素</strong><ul><li><figure><img src="image-58.png" srcset="/img/loading/loading3.gif" lazyload alt="设计要素"><figcaption aria-hidden="true">设计要素</figcaption></figure></li></ul></li><li><strong>等级保护工作流程</strong><ul><li><figure><img src="image-59.png" srcset="/img/loading/loading3.gif" lazyload alt="工作流程"><figcaption aria-hidden="true">工作流程</figcaption></figure></li><li>安全定级流程<ul><li><figure><img src="image-60.png" srcset="/img/loading/loading3.gif" lazyload alt="安全定级流程"><figcaption aria-hidden="true">安全定级流程</figcaption></figure></li><li>业务信息安全保护等级</li><li><figure><img src="image-63.png" srcset="/img/loading/loading3.gif" lazyload alt="业务信息安全"><figcaption aria-hidden="true">业务信息安全</figcaption></figure></li><li>系统服务安全保护等级</li><li><figure><img src="image-64.png" srcset="/img/loading/loading3.gif" lazyload alt="系统服务安全"><figcaption aria-hidden="true">系统服务安全</figcaption></figure></li></ul></li></ul></li><li><strong>等级保护2.0标准体系</strong><ul><li><figure><img src="image-65.png" srcset="/img/loading/loading3.gif" lazyload alt="2.0"><figcaption aria-hidden="true">2.0</figcaption></figure></li></ul></li><li><strong>等级保护安全设计技术框架</strong><ul><li><figure><img src="image-66.png" srcset="/img/loading/loading3.gif" lazyload alt="技术框架"><figcaption aria-hidden="true">技术框架</figcaption></figure></li></ul></li></ol><h3 id="网络安全管理">网络安全管理</h3><ol type="1"><li><strong>网络安全管理</strong><ul><li>定义：网络安全管理是网络安全工作中的重要概念，包括技术控制措施和管理控制措施。</li><li>网络安全管理是指<strong>把分散的网络安全技术因素和人的因素，通过策略、规则协调整合为一体，服务于网络安全的目标。</strong></li><li>任务和目标：信息安全管理是以管理对象的安全为任务和目标的管理。<ul><li>任务：保证管理对象的安全。</li><li>目标：达到管理对象所需的安全级别，将风险控制在可以接受的程度。</li></ul></li></ul></li><li><strong>网络安全管理体系（ISMS）</strong><ul><li><strong>定义</strong>：<ul><li>信息安全管理体系（Information Security Management Systems,简称ISMS）是组织整体管理体系的一个部分，是基于风险评估建立、实施、运行、监视、评审、保持和持续改进信息安全等一系列的管理活动。<ol type="1"><li>基于<strong>风险管理思想</strong>，建立一个系统化、程序化和文件化的管理体系。</li><li>强调全过程和动态控制。</li><li><strong>控制费用与风险平衡的原则</strong>，保护关键信息资产，使得网络安全风险的发生概率和结果降低到可接受的水平。</li></ol></li></ul></li><li>国外网络安全管理相关标准<ul><li>目前，ISO/IEC2700X标准系列是国际主流，国家标准化组织（ISO）专门为ISMS预留了一批标准序号。该系列的<strong>两个核心、基础标准ISO/IEC27001和ISO/IEC27002</strong>已于2005年10月正式发布第一版，2013年10月正式发布第二版。</li></ul></li><li>我国网络安全管理相关标准<ul><li>我国早期主要采用与国际标准靠拢的方式，近年来加强网络安全管理标准的自主制定，已经开始向国际标准化组织提交国际标准提案。在全国信息安全标准化技术委员会内，第7工作组(WG7)的努力下，我国已经正式发布一系列网络安全管理标准。</li></ul></li><li>网络安全管理控制措施<ul><li>为了对组织所面临的的安全风险实施有效的控制，应针对具体地安全威胁和脆弱性，采取适当的控制措施。ISO/IEC27002标准提出了<strong>14个方面的管理控制措施</strong>，包括网络安全策略、网络安全组织、人力资源安全、资产管理、访问控制、密码、物理和环境安全、运行安全、通信安全、系统获取、开发和维护、供应商关系、网络安全事件管理、业务连续性管理和网络安全方面、符合性</li></ul></li><li>ISO 27000系列<ul><li><figure><img src="image-67.png" srcset="/img/loading/loading3.gif" lazyload alt="ISO27000"><figcaption aria-hidden="true">ISO27000</figcaption></figure></li></ul></li></ul></li><li><strong>网络安全风险管理</strong><ul><li>定义：一种<strong>在风险评估的基础上对风险进行处理的工程</strong>。网络安全风险管理实质是基于风险的网络安全管理。</li><li>信息安全风险评估</li><li>信息系统安全评估</li></ul></li><li><strong>风险评估</strong>：<ul><li>定义：对信息资产面临的威胁、存在的弱点、造成的影响，以及三者综合作用而带来的风险的可能性的评估。<strong>信息安全风险评估是建立信息安全保障机制中的一种科学方法。</strong></li><li>信息安全风险：<ul><li>人为或自然的威胁利用系统存在的脆弱性引发的安全事件，并由于受损信息资产的重要性而对机构造成的影响。</li></ul></li><li>信息安全风险评估涉及4个主要因素：<ul><li><strong>资产、威胁、脆弱性和风险</strong></li></ul></li><li>基本过程：<ul><li>风险评估准备过程</li><li>资产识别过程、威胁识别过程、脆弱性识别过程</li><li>风险分析过程</li></ul></li><li>主要任务：<ul><li>识别组织面临的各种风险</li><li>评估风险概率和可能带来的负面影响</li><li>确定组织承受风险的能力</li><li>确定风险消减和控制的优先等级</li><li>推荐风险消减对策</li></ul></li><li>关键问题：<ul><li>首先要确定保护的对象（或者资产）是什么？它的直接和间接价值如何？</li><li>其次，资产面临哪些潜在威胁？导致威胁的问题所在？威胁发生的可能性有多大？</li><li>资产中存在哪里弱点可能会被威胁所利用？利用的容易程度又如何？</li><li>一旦威胁事件发生，组织会遭受怎样的损失或者面临怎样的负面影响？</li><li>最后，组织应该采取怎样的安全措施才能将风险带来的损失降低到最低程度？</li></ul></li></ul></li><li><strong>信息系统安全评估</strong>：</li></ol><ul><li>或称为或简称为系统评估，是在具体的操作环境与任务下对一个系统的安全保护能力进行的评估。具体是指依据国家风险评估有关管理要求和技术标准，对信息系统及由其存储、处理和传输的信息的机密性、完整性和可用性等安全属性进行科学、公正的综合评价的过程。</li></ul><ol start="6" type="1"><li><strong>资产的有效保护</strong><ul><li>资产一旦受到威胁和破坏带来两类损失：<ul><li><strong>即时的损失</strong>，如由于系统被破坏，员工无法使用，因而降低了劳动生产率。</li><li><strong>长期的恢复所需花费</strong>，也就是从攻击或失效到恢复正常需要的花费。</li></ul></li><li>为了有效保护资产，应尽可能<strong>降低资产受危害的潜在代价</strong>。由于采取一些安全措施，也要付出安全的操作代价。网络安全最终是一个<strong>折中的方案</strong>，需要对危害和降低危害的代价进行权衡。</li><li><figure><img src="image-68.png" srcset="/img/loading/loading3.gif" lazyload alt="权衡"><figcaption aria-hidden="true">权衡</figcaption></figure></li></ul></li><li><strong>风险管理实施流程</strong><ul><li><figure><img src="image-69.png" srcset="/img/loading/loading3.gif" lazyload alt="实施流程"><figcaption aria-hidden="true">实施流程</figcaption></figure></li><li><figure><img src="image-70.png" srcset="/img/loading/loading3.gif" lazyload alt="原理"><figcaption aria-hidden="true">原理</figcaption></figure></li><li>风险管理的核心部分：<strong>风险分析</strong><ul><li>资产属性：资产价值</li><li>威胁属性：威胁主体、影响对象、出现频率、动机</li><li>脆弱性属性：资产弱点的严重程度</li></ul></li><li>风险识别：<ul><li>漏洞</li><li>威胁</li><li>已有的对策和预防措施</li></ul></li></ul></li><li><strong>风险分析</strong><ul><li>定性分析法<ul><li>定性分析法主要是根据操作者的经验知识、业界的一些标准和惯例等非量化方式对风险状况作出判断的过程</li><li>定性分析法<strong>操作起来相对简单</strong>，为风险管理诸要素（资产价值、威胁出现的概率、弱点被利用的容易度、现有控制措施的效力等）的<strong>大小或高低程度定性分级</strong></li><li>该方法具有<strong>很强的主观性</strong>，同时也会因为操作者的经验和直觉偏差导致分析结果发生偏差，从而出现多次评估结果不一致的情况。</li></ul></li><li>定量分析法<ul><li>是对构成风险的各个要素和潜在损失的水平赋予数值，当度量风险的所有要素（<strong>资产价值、威胁频率、弱点利用程度、安全措施的效率和成本等</strong>）都被赋值，风险评估的整个过程和结果就都可以被量化了。</li><li>定量分析就是试图从<strong>数字上</strong>对安全风险进行分析评估的一种方法，优点是评估结果<strong>用直观的数据来表示</strong>，看起来一目了然。</li><li>缺点是存在为了量化而把复杂事物简单化的问题，甚至有些风险要素因量化而被曲解</li></ul></li></ul></li><li><strong>风险控制</strong><ul><li>风险控制措施<ul><li><strong>风险降低</strong>：实施安全措施，把风险降低到一个可接受的级别</li><li><strong>风险承受</strong>：接受潜在的风险并继续运行网络和信息系统</li><li><strong>风险规避</strong>：通过消除风险的原因或后果，来规避风险，即不介入风险</li><li><strong>风险转移</strong>：通过使用其他措施来补偿损失，从而转移风险，如买保险</li></ul></li></ul></li></ol><h3 id="网络安全事件处置与恢复">网络安全事件处置与恢复</h3><ol type="1"><li><strong>网络安全事件分类与分级</strong><ul><li>网络安全事件<strong>分类</strong>：<ul><li>有害程序事件</li><li>网络攻击事件</li><li>信息破坏事件</li><li>信息内容安全事件</li><li>设备设施故障</li><li>灾难性事件</li><li>其他网络安全事件</li></ul></li><li>网络安全事件<strong>分级</strong>：<ul><li>特别重大事件（I级）</li><li>重大事件（II级）</li><li>较大事件（III级）</li><li>一般事件（IV级）</li></ul></li><li>网络安全事件分级主要考虑三个要素：<ul><li><strong>信息系统的重要程度</strong><ul><li>主要考虑信息系统所承载的业务对国家安全、经济建设、社会生活的重要性以及业务对信息系统的依赖程度划分为特别重要信息系统、重要信息系统和一般信息系统。</li></ul></li><li><strong>系统损失</strong><ul><li>由于信息安全事件对信息系统的软硬件、功能以及数据的破坏，导致系统业务中断，从而给事发组织所造成的损失，其大小主要考虑恢复系统正常运行和消除安全事件负面影响所需付出的代价，划分为特别严重的系统损失、严重的系统损失、较大的系统损失和较小的系统损失</li></ul></li><li><strong>社会影响</strong></li></ul></li></ul></li><li><strong>网络安全应急处理过程</strong><ul><li>准备阶段：主要工作包括建立合理的防御/控制措施、建立适当的策略和程序、获得必要的资源和组建相应队伍等。</li><li>检测阶段：目标是对网络安全事件做出初步的动作与响应，根据获得的初步材料和分析结果，预估事件的范围和影响程度，制定进一步的影响策略，并保留相关证据</li><li>抑制阶段：目标是限制攻击的范围，抑制潜在的或进一步的攻击和破坏。主要工作包括阻止入侵者访问被攻陷系统；限制入侵的程度；防止入侵者进一步破坏等。</li><li>根除阶段：目标是在事件被抑制之后，通过分析有关恶意代码或行为找出事件发生的根源，并予以彻底根除。</li><li>恢复阶段：目标是将网络安全事件所涉及的系统还原到正常状态。</li><li>总结阶段：目标是回顾网络安全事件处理的全过程，整理相关信息，尽可能把所有情况记录到文档中。</li></ul></li><li><strong>网络安全应急响应相关概念</strong><ul><li><strong>网络安全事件</strong>：引起网络系统的安全受到威胁和破坏的任何事件。<ul><li>威胁包括：丢失数据机密性，破坏数据和系统的完整性，破坏系统的可用性使之不能提供服务等等</li></ul></li><li><strong>网络安全应急响应能力</strong>：网络系统的整体的应急事件的处理能力，包括针对于安全事件的技术响应手段，流程管理，人员组织等多个方面。</li><li><strong>计算机安全应急响应团队（CSIRT）</strong>：负责日常情况下安全保障和紧急情况下应急响应任务的组织。</li><li><strong>事件响应和安全团队论坛（FIRST）</strong>：把政府，商业机构，和学术组织的安全应急响应团队联合起来，组成一个有机的整体。</li></ul></li><li><strong>国内安全应急响应组织</strong><ul><li>CCERT（1999年5月），中国教育科研网紧急响应组</li><li>NJCERT（1999年10月），中国教育网华东（北）地区网络-安全事件响应组</li><li>2000年8月，国家计算机病毒应急处理中心</li><li>中国电信ChinaNet安全小组</li><li>解放军，公安部</li><li>商业网络安全服务公司</li><li>中国计算机应急响应处理协调中心CNCERT/CC</li></ul></li><li><strong>信息系统灾难恢复</strong><ul><li>定义：将信息系统从灾难造成的故障或瘫痪状态恢复到可正常运行的状态，并将其支持的业务功能从灾难造成的不正常状态恢复到可接受状态的活动和流程。</li><li>内容：<ul><li>灾难恢复规划和灾难备份中心的日常运行</li><li>关键业务功能在灾难备份中心的恢复和重续运行</li><li>主系统的灾后重建和回退工作</li><li>突发事件发生后的应急响应</li></ul></li><li>关键过程：<ul><li><figure><img src="image-71.png" srcset="/img/loading/loading3.gif" lazyload alt="关键过程"><figcaption aria-hidden="true">关键过程</figcaption></figure></li></ul></li><li><strong>灾难恢复能力6个级别</strong><ol type="1"><li>基本支持</li><li>备用场地支持</li><li>电子传输和部分设备支持</li><li>电子传输及完整设备支持</li><li>实时数据传输及完整设备支持</li><li>数据零丢失和远程集群支持</li></ol></li></ul></li></ol><h3 id="新兴网络及安全技术">新兴网络及安全技术</h3><ol type="1"><li><strong>工业互联网</strong><ul><li>概念：本质是通过开放式的全球化工业级网络平台，紧密融合物理设备、生产线、工厂、运营商、产品和客户，通过自动化和智能化的生产方式降低成本、提高效率。</li><li>安全挑战：工业互联网含有大量CPS（Cyber-Physical Systems信息物理系统）设备，改进后的蠕虫、病毒和木马等传统攻击方式会严重威胁工业互联网安全，而且由于工业互联网集成多类不同系统，所以<strong>存在多种攻击发起点</strong>，攻击者可以从<strong>物理层、网络层和控制层</strong>分别发起攻击。因此，工业互联网遭受攻击会严重影响国家安全。</li><li><strong>工业互联网主要安全防护技术</strong><ul><li>安全人员培训</li><li>安全需求制定和实施计划</li><li>安全硬件和软件设计</li><li>安全方案部署</li><li>信息反馈测试和升级</li></ul></li></ul></li><li><strong>移动互联网安全防护</strong><ul><li>概念：利用互联网的技术、平台、应用以及商业模式与移动通信技术相结合并实践的活动统称。</li><li>组成部分：移动互联网终端设备、移动互联网通信网络、移动互联网应用和移动互联网相关技术。<ul><li><figure><img src="image-72.png" srcset="/img/loading/loading3.gif" lazyload alt="相关技术"><figcaption aria-hidden="true">相关技术</figcaption></figure></li></ul></li><li>安全架构：移动互联网终端安全、移动互联网网络安全和移动互联网应用安全。<ul><li><figure><img src="image-73.png" srcset="/img/loading/loading3.gif" lazyload alt="安全架构"><figcaption aria-hidden="true">安全架构</figcaption></figure></li></ul></li><li>安全挑战：十分严格地强调对用户隐私和用户行为的保护<ul><li>移动互联网涉及大量的用户个人信息（如位置信息、通信信息、日志信息、账户信息、支付信息、设备信息、文件信息等），给移动互联网安全监管和用户隐私保护带来极大的挑战</li><li>当前，移动通信终端智能化程度日益提高，处理的信息更加多样化。因此，终端成为攻击者的重要目标之一，<strong>恶意攻击行为逐步向强制推广、风险传播、越权收集等行为转变</strong>。终端被攻击，容易造成用户经济损失、信息泄漏、业务滥用等问题。</li></ul></li></ul></li><li><strong>物联网</strong><ul><li>定义：依托射频识别RFID技术和设备，按约定的通信协议与互联网相结合，使物品信息实现智能化识别和管理，实现物品信息互联而形成的网络</li><li>概念：物联网是指通过信息传感设备，按照约定的协议，把任何物品与互联网连接起来，进行信息交换和通讯，以实现智能化识别、定位、跟踪、监控和管理的一种网络。它是在互联网基础上延伸和扩展的网络。</li><li>组成架构<ul><li><figure><img src="image-74.png" srcset="/img/loading/loading3.gif" lazyload alt="组成架构"><figcaption aria-hidden="true">组成架构</figcaption></figure></li></ul></li><li>安全挑战：<ul><li><figure><img src="image-75.png" srcset="/img/loading/loading3.gif" lazyload alt="安全问题"><figcaption aria-hidden="true">安全问题</figcaption></figure></li><li>感知层：感知层节点：网关节点、普通法节点等容易被恶意控制、捕获，容易受到外部DOS攻击；接入物联网的超大量传感节点的标识、认证易被劫持。</li><li>网络层：异构的物联网应用协议无法被安全设备识别，被篡改和入侵后无法及时发现DOS攻击、假冒攻击、中间人攻击、跨异构网络攻击等</li><li>管理服务层：存在高智能自动化处理系统带来不确定性，人为的干预导致服务不可用，设备丢失来自于超大量终端的海量数据的识别和处理</li><li>应用层：许多应用层平台本身存在漏洞易导致未授权的访问、数据破坏和泄露、用户隐私保护；取证和销毁数据、保护知识产权</li></ul></li><li>安全防护技术<ul><li>安全和隐私保护方面，物联网应用的仍然是互联网或通信网中常规的安全防护技术。</li><li><figure><img src="image-76.png" srcset="/img/loading/loading3.gif" lazyload alt="安全防护技术"><figcaption aria-hidden="true">安全防护技术</figcaption></figure></li></ul></li></ul></li></ol><h1 id="第四章-系统安全基础">第四章 系统安全基础</h1><h2 id="系统安全思维">系统安全思维</h2><ol type="1"><li><strong>系统安全指导思想</strong><ul><li><strong>系统安全定义</strong>：<ul><li>是指在<strong>系统生命周期内</strong>应用<strong>系统安全工程</strong>和<strong>系统安全管理</strong>方法，辨识系统中的隐患，并采取有效的控制措施使其危险性最小，从而使系统在<strong>规定的性能、时间和成本范围内</strong>达到<strong>最佳</strong>的安全程度。</li></ul></li><li>网络空间系统安全：<ul><li>以系统思维应对安全问题；</li><li>应对系统所面临的安全问题，以整体的观点看待系统。</li></ul></li><li>指导思想：在系统思维的指引下，从<strong>系统建设、使用和全生命周期</strong>应对系统所面临的安全问题，正视系统的<strong>体系结构</strong>对系统安全的影响，以<strong>生态系统的视野</strong>全面审视安全对策。</li></ul></li><li><strong>系统安全的演进</strong><ul><li><figure><img src="image-77.png" srcset="/img/loading/loading3.gif" lazyload alt="系统安全的演进"><figcaption aria-hidden="true">系统安全的演进</figcaption></figure></li></ul></li><li><strong>系统与系统安全</strong><ul><li><strong>系统定义</strong>：<ul><li>一个系统（System）是由<strong>相互作用</strong>或<strong>相互依赖</strong>的<strong>元素或成份</strong>构成的某种类型的一个<strong>统一整体</strong>，其中的元素完整地关联在一起。</li><li>位于系统边界内部的元素属于系统的<strong>组成元素</strong></li><li>位于系统边界外部的元素属于系统的<strong>环境</strong></li></ul></li><li>观察系统的方法<ul><li>自外观察法：观察者位于系统之外对系统进行观察，通常是通过观察系统的输入和输出来分析系统的行为</li><li>自内观察法，观察者位于系统之内对系统进行观察，此时，观察者属于系统的一个组成部分，通常是通过观察系统的外部环境来分析系统的行为</li></ul></li><li>在<strong>网络空间中观察系统的环境</strong>：系统在风险的包围之中，必须具有一定的安全性，才能正常运转。</li><li><strong>系统的安全性需要以系统化的视野去观察</strong></li></ul></li><li><strong>整体论与还原论</strong><ul><li><strong>还原论</strong>：把大系统分解为小系统，然后通过对小系统的研究去推知大系统的行为。<ul><li>把系统分解成它的组成部分，通过对系统的组成部分的研究去了解原有系统的情况。</li><li><strong>局限性</strong>：某些宏观性质是无法通过其微观组成部分的性质反映出来</li></ul></li><li><strong>整体论</strong>：把一个系统看成一个完整的统一体，一个完整的被观察单位，而不是简单的微观组成元素的集合。<ul><li>整体特性：<ul><li>综合特性：可以分解为系统组成部分的特性</li><li>涌现性：不可还原（即不可分解）为系统组成部分的特性<ul><li><strong>安全性属于涌现性</strong></li></ul></li></ul></li><li>操作系统的分解：进程管理、内存管理、外设管理、文件管理、处理器管理。</li></ul></li></ul></li><li><strong>核心理念及概念</strong><ul><li>网络空间系统安全知识领域的核心理念：<ul><li>保护对象</li><li>思维方法（系统化思维方法）<ul><li><strong>系统化思维方法运用到网络空间安全之中称为系统安全思维</strong></li></ul></li></ul></li></ul></li><li><strong>系统工程及安全工程</strong><ul><li><strong>系统工程</strong>(Systems Engineering)：<ul><li>定义：涵盖系统生命周期的具有关联<strong>活动和任务</strong>的技术性和非技术性过程的<strong>集合</strong>。</li><li>技术性过程应用工程分析与设计原则去建设系统</li><li>非技术性过程通过工程管理去保障系统建设工程项目的顺利实现</li><li>目标：获得总体上可信赖的系统，核心是系统整体思想</li></ul></li><li><strong>系统安全工程</strong>(Systems Security Engineering)：<ul><li>定义：把安全性相关活动和任务融合到系统工程的过程之中，形成的一个系统工程专业分支。</li><li>力求从系统生命周期的全过程去保障系统的安全性</li><li>系统的安全性值得信赖等价于系统具有可信的安全性</li></ul></li></ul></li></ol><h2 id="系统安全原理">系统安全原理</h2><ol type="1"><li><strong>基本原则</strong><ul><li>在系统的设计与实现中应遵守的原则包括<strong>限制性原则、简单性原则、方法性原则</strong></li><li><figure><img src="image-78.png" srcset="/img/loading/loading3.gif" lazyload alt="基本原则"><figcaption aria-hidden="true">基本原则</figcaption></figure></li></ul></li><li><strong>威胁建模</strong><ul><li>威胁建模(Threat Modeling)：<ul><li><strong>定义</strong>：标识潜在安全威胁并审视风险缓解途径的过程。</li><li>威胁(Threat)：给某物造成伤害或损失的意图</li><li>风险(Risk)：某物遭受伤害或损失的可能性</li><li>安全(Security)：某物能避免或抵御他物带来的潜在伤害或损失</li></ul></li></ul></li><li><strong>威胁建模方法</strong><ul><li>威胁建模目标：<ul><li><strong>为防御者提供系统地分析应采取的控制或防御措施的机会</strong></li></ul></li><li>基本类型：<ul><li>以风险为中心</li><li>以资产为中心</li><li>以攻击者为中心</li><li>以软件为中心</li></ul></li><li>典型方法：<ul><li>STRIDE<ul><li>身份欺骗、数据篡改、抵赖、信息泄露、拒绝服务、特权提升的缩写</li><li>具体步骤：<ol type="1"><li>建立数据流图</li><li>标识系统实体、事件和边界</li><li>发现风险</li></ol></li></ul></li><li>PASTA</li><li>Trike</li><li>VAST等</li></ul></li></ul></li></ol><h2 id="系统安全控制及管理">系统安全控制及管理</h2><ol type="1"><li><strong>安全控制</strong><ul><li><strong>访问行为的形式化表示 (s, o, p)</strong><ul><li>s：主体</li><li>o：客体</li><li>p：操作</li><li>典型操作：read、copy、modify、execute</li></ul></li><li><strong>授权的矩阵表示</strong><ul><li>矩阵<span class="math inline"><em>M</em></span> <img src="image-79.png" srcset="/img/loading/loading3.gif" lazyload alt="授权的矩阵表示"></li><li>s：主体</li><li>o：客体</li><li>m：操作权限的集合，例如<code>m = {read, write}</code></li></ul></li><li><strong>微调的授权的矩阵表示</strong><ul><li>矩阵<span class="math inline"><em>M</em><sup><em>R</em></sup></span><img src="image-80.png" srcset="/img/loading/loading3.gif" lazyload alt="微调授权矩阵表示"></li><li>r：角色</li><li>o：客体</li><li>m：操作权限的集合</li></ul></li></ul></li><li><strong>访问控制策略</strong><ul><li>访问控制策略1<ul><li>构造访问控制矩阵 M ，给矩阵 M 中的元素赋值，对于任意 (s, o, p)访问请求，在 M 中找到 s 和 o 交叉位置上的元素 m，当 p∈m 时，允许 (s, o,p) 执行，否则，禁止 (s, o, p) 执行</li></ul></li><li>访问控制策略2<ul><li>构造访问控制矩阵 <span class="math inline"><em>M</em><sup><em>R</em></sup></span>，设计角色分配方案 <span class="math inline"><em>f</em><sub><em>R</em></sub></span> ，给矩阵<span class="math inline"><em>M</em><sup><em>R</em></sup></span>中的元素赋值，按方案 <span class="math inline"><em>f</em><sub><em>R</em></sub></span>给每个用户分配角色，对于任意 (u, o, p) 访问请求，u 表示用户，确定角色<span class="math inline"><em>r</em> = <em>f</em><sub><em>R</em></sub>(<em>u</em>)</span>，在 <span class="math inline"><em>M</em><sup><em>R</em></sup></span>中找到 r 和 o 交叉位置上的元素 m，当 p∈m 时，允许 (u, o, p)执行，否则，禁止 (u, o, p) 执行</li></ul></li><li>访问控制策略3<ul><li>制定主体等级分配方案 <span class="math inline"><em>f</em><sub><em>S</em></sub></span>和客体密级分配方案 <span class="math inline"><em>f</em><sub><em>O</em></sub></span>，设计主体等级与客体密级的对比方法cmp，设定任意操作x 应该满足的条件con(x)，给每个主体分配涉密等级，给每个客体分配保密级别，对于任意 (s, o,p) 访问请求，当 <span class="math inline"><em>c</em><em>m</em><em>p</em>(<em>f</em><sub><em>S</em></sub>(<em>s</em>), <em>f</em><sub><em>O</em></sub>(<em>o</em>))</span>满足条件 con(p) 时，允许(s, o, p) 执行，否则，禁止 (s, o, p) 执行</li></ul></li></ul></li><li><strong>安全控制-强制访问控制MAC模型</strong><ul><li>Bell-Lapadula安全模型<ul><li><figure><img src="image-81.png" srcset="/img/loading/loading3.gif" lazyload alt="bell-lapadula"><figcaption aria-hidden="true">bell-lapadula</figcaption></figure></li></ul></li><li>Biba安全模型<ul><li><figure><img src="image-82.png" srcset="/img/loading/loading3.gif" lazyload alt="biba"><figcaption aria-hidden="true">biba</figcaption></figure></li></ul></li></ul></li><li><strong>安全监测</strong><ul><li>系统完整性检查：从开机引导到应用运行，各个环节都进行检查，帮助发现系统中是否有重要组成部分受到篡改或破坏。</li><li>病毒查杀和恶意软件检测：对系统中的各种文件进行扫描，帮助发现或清除进入到系统之中的大多数病毒或恶意软件。</li><li>入侵检测：对恶意行为或违反安全策略的现象进行监测，一旦发现情况就及时报告，必要时发出告警。</li></ul></li><li><strong>安全管理</strong><ul><li>安全管理(Security Management)：<ul><li>定义：在安全策略的指导下进行的一系列管理活动。把一个组织的资产标识出来，并制定、说明和实施保护这些资产的策略和流程。</li><li>资产：系统、信息、机器、建筑物、人员</li><li>安全管理策略<ul><li>管理的任务、目标、对象、原则、程序和方法。</li></ul></li><li>安全管理活动<ul><li>制定计划、建立机构、落实措施、开展培训、检查效果和实施改进等。</li></ul></li></ul></li><li>把风险管理原则应用到安全威胁管理之中<ul><li>标识威胁</li><li>评估现有威胁控制措施的有效性</li><li>确定风险的后果</li><li>基于可能性和影响的评级排定风险优先级</li><li>划分风险类型并选择合适的风险策略或风险响应</li><li>它聚焦系统的日常管理，讨论如何把安全理念贯穿到系统安全管理工作的全过程中，帮助系统管理人员明确和落实系统管理工作中的安全责任以便从系统管理的角度提升系统的安全性。</li></ul></li></ul></li></ol><h2 id="系统安全结构">系统安全结构</h2><ol type="1"><li><strong>硬件系统安全</strong><ul><li>硬件安全关注于给软件提供什么样的安全支持，如何帮助软件实现想要的安全功能，以及硬件自身存在的安全隐患对系统安全的影响。</li><li>处理器硬件从可用指令集和可用内存区域两个方面出发，定义了处理器工作的两种状态：<ul><li>内核态：操作系统用，看到所有的指令和地址空间</li><li>用户态：其他程序用，看到其中部分的指令和地址空间</li><li>用户态程序不能干扰内核态的程序。</li></ul></li><li><strong>硬件安全涉及</strong>：硬件设计、访问控制、安全多方计算、安全密钥存储、密钥真实性保障等方面。</li></ul></li><li><strong>检查程序是否被篡改的基本方法</strong><ul><li>检查程序是否被篡改<ul><li>通过计算程序的摘要并与原始摘要对比来检查程序是否被篡改</li></ul></li><li>硬件防篡改方法：<ol type="1"><li>提供密码计算功能<ul><li>通用处理器提供密码运算指令</li><li>独立的安全密码处理器（密码加速器）<ul><li><strong>硬件安全模块</strong>（HSM）：用安全密码处理器芯片实现的硬件计算设备（密码处理+密钥管理和保护）</li></ul></li></ul></li><li>提供数字指纹（确定机器的身份）<ul><li>使用物理不可克隆函数（PUF）硬件器件实现</li></ul></li></ol></li></ul></li><li><strong>操作系统安全</strong><ul><li><strong>操作系统安全是系统安全的基础</strong>：<ul><li>各种应用软件均建立在操作系统提供的系统软件平台之上，上层的应用软件要想获得运行的高可靠性和信息的完整性、保密性，必须依赖于操作系统提供的系统软件基础</li></ul></li><li>操作系统的安全可信性分为不同的级别<ul><li><figure><img src="image-83.png" srcset="/img/loading/loading3.gif" lazyload alt="级别"><figcaption aria-hidden="true">级别</figcaption></figure></li></ul></li><li>操作系统建立<strong>可信交互路径</strong>，实现应用系统和加密功能的有效衔接<ul><li><figure><img src="image-84.png" srcset="/img/loading/loading3.gif" lazyload alt="可信交互路径"><figcaption aria-hidden="true">可信交互路径</figcaption></figure></li></ul></li><li>操作系统安全功能：<ul><li>用户管理与身份认证</li><li>自主访问控制<ul><li>文件的拥有者可以自主确定任何用户对该文件的访问权限</li><li>访问权限既可以授给用户，也可以授给用户组</li></ul></li><li>日志功能<ul><li>记录系统中发生的重要活动的详细信息</li></ul></li><li>强制访问控制<ul><li>实现多级安全策略（MLS）等。</li></ul></li></ul></li></ul></li><li><strong>数据库安全</strong><ul><li>数据库安全控制模型<ul><li><figure><img src="image-85.png" srcset="/img/loading/loading3.gif" lazyload alt="模型"><figcaption aria-hidden="true">模型</figcaption></figure></li></ul></li><li><strong>数据库系统</strong>：<ul><li>定义：提供通用数据管理功能的软件系统</li><li>构成：<ul><li>有数据库管理系统(DBMS)：为用户及应用程序提供数据访问，并具有对数据库进行管理、维护等多种功能</li><li>数据库应用：按一定的方式存取数据<br></li></ul></li></ul></li><li><strong>存取控制</strong>：<ul><li>防止非授权的数据库存取</li><li>防止非授权的对模式对象的存取</li><li>控制磁盘使用</li><li>控制系统资源使用</li><li>审计用户动作</li></ul></li><li><strong>数据库系统安全</strong>：<ul><li>系统运行安全（法律政策安全；物理控制安全；硬件运行安全；操作系统安全；灾害故障恢复；死锁的避免与解除；电磁信息泄露的防止）</li><li>信息安全（用户口令鉴别；用户存取权限控制；数据存取权限和方式控制；审计跟踪；数据加密）</li></ul></li><li><strong>数据库系统的主要威胁</strong>：<ul><li>非法访问数据库信息；</li><li>恶意破坏数据库或未经授权非法修改数据库；</li><li>用户网络访问数据库时受到各种攻击，如搭线窃听等；</li><li>对数据库不正确的访问导致数据库数据的错误等</li></ul></li><li><strong>数据库系统的安全需求</strong>：<ul><li>完整性、可靠性、有效性、保密性、可审计性及可存取控制与用户身份鉴别等。</li></ul></li><li>在一般的计算机系统中，安全措施是一级一级层层设置的</li></ul></li><li><strong>数据库访问控制</strong><ul><li>自主访问控制<ul><li>访问授权</li><li>撤销授权</li></ul></li><li>数据推理<ul><li>根据<strong>合法的非敏感数据</strong>推导出<strong>非法的敏感数据</strong></li></ul></li><li>对数据库数据进行非法间接访问</li><li>推理威胁源自统计数据库：利用合法的统计数据推导出不合法的敏感数据</li><li>强制访问控制/多级安全数据库<ul><li>根据数据的敏感程度，确定数据的敏感级别</li></ul></li><li>根据用户在工作中应该涉及的数据的敏感程度，为用户分配敏感等级</li><li>可以基于表、字段或记录建立敏感级别</li></ul></li><li><strong>数据库SQL注入攻击</strong><ul><li>SQL注入攻击是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。<ul><li>详细:SQL注入攻击是指Web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句结尾添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</li></ul></li><li>SQL注入一般存在于形如：http://xxx.xxx.xxx/abc.aspx?id=XX等带有参数的asp/aspx/php/jsp等动态网页中。</li><li><strong>应对SQL注入攻击的办法</strong></li><li>在应用系统的代码中添加对用户的输入进行严格检查的功能，禁止在输入中滥用转义字符</li></ul></li><li><strong>基于Web的应用安全——论坛</strong><ul><li>例如，论坛中的跨站脚本（XSS）攻击，用户在评论中嵌入脚本，导致其他用户的敏感信息被传输到攻击者指定的服务器中。</li><li>脚本<ul><li>定义：运行在网页服务器上的，使用一种特定的描述性语言，依据一定的格式编写的纯文本保存的程序，</li><li>例如：ASP、PHP、CGI、JSP等</li><li>一般都是要结合数据库如ACCESS、MSSQL、MYSQL、Oracle等来使用</li></ul></li><li>跨站脚本攻击(XSS):<ul><li>在脚本中加入一些破坏计算机系统的命令，这样当用户浏览网页时，一旦调用这类脚本，便会使用户的系统受到攻击。</li></ul></li><li>安全风险<ul><li>攻击者可以劫持用户会话</li><li>插入恶意内容</li><li>重定向用户</li><li>使用恶意软件劫持用户浏览器</li><li>繁殖XSS蠕虫</li><li>甚至破坏网站、修改路由器配置信息等</li></ul></li></ul></li><li><strong>cookie攻击</strong><ul><li><strong>Cookie</strong><ul><li>浏览器与服务器交互时，由Web服务器建立、发送，由(Web客户端)浏览器保存的一些<strong>赋值信息</strong>，在后续交互时，浏览器会把这些信息返还给服务器，使服务器了解浏览器的过往行为</li><li>简单的文本文件，约由255个字符组成，占4KB空间</li><li>有些WEB服务能够收集有关用户的特定状态信息，用来在以后的会话中使用</li><li>Cookie会帮把在该网站上所输入的文字信息或是一些选择和操作都纪录下来，并将<strong>信息保存在用户的硬盘上</strong>，这些信息将保存在用户的浏览器中，当<strong>下一次用户连接到这个服务器时，浏览器就可以将合适的状态发送给服务器使用</strong>，服务器依据Cookie里的内容来判断使用者，送出特定的网页内容，提高了浏览网页的效率</li></ul></li><li><strong>安全性问题</strong>在于它可能泄露用户的信息，欺骗（攻击者通过修改存放在客户端的cookie来达到欺骗服务器认证目的）等问题。<ul><li>Cookie包含的信息包括用户的IP地址、用户密码个人资料等重要信息，服务器对其检索不是在服务器上进行，而是在用户的硬盘上进行</li></ul></li></ul></li></ol><h2 id="安全生态系统">安全生态系统</h2><ol type="1"><li><strong>生态学系统/生态系统</strong><ul><li>物质循环和能量流动的相互影响以及来自亚系统的反馈共同构成一个自我调整的动态平衡</li><li>生态系统是个控制论系统，包括生态系统中的信息网络、物理和化学信息连接起来的组分等。</li></ul></li><li><strong>数字生态系统</strong><ul><li>数字生态系统是一个分布式的、适应性的、开放的<strong>社会-技术系统</strong>，受自然生态系统启发，具有自组织性、可伸缩性、和可持续性。数字生态系统模型受到了自然生态系统知识的启示，尤其是在形形色色的实体之间的竞争与合作的相关方面。</li></ul></li><li><strong>网络空间生态系统</strong><ul><li>像自然生态系统一样，由形形色色的、出于多种目的进行<strong>交互</strong>的各种<strong>成员</strong>构成，主要成员包括私营企业、非营利组织、政府、个人、过程和网络空间设备等，主要设备包括计算机、软件、通信技术等</li></ul></li><li>生态系统视角下的安全威胁模型<ul><li>问题应对<ul><li>理念方面：把系统的概念拓展到生态系统的范围，重新认识安全威胁，重新构建安全模型；</li></ul></li><li>技术方面：要有新的支撑技术</li><li>模型建立<ul><li>不但要考虑企业自身的安全因素；</li></ul></li><li>还必须考虑合作伙伴的安全因素。</li><li>关键支撑技术<ul><li>自动化Automation：让响应速度跟上攻击速度，而不是以人力的响应速度应对机器的攻击速度；</li></ul></li><li>互操作性Interoperability：由策略而不是技术约束定义网络空间共同体，允许网络空间生态系统成员在自动化的团体防御中无缝地、动态地协作；</li><li>认证Authentication：为在线决策建立基础，由人员认证扩展到包含设备认证，设备可以是计算机、软件、或信息等。</li></ul></li></ol><h1 id="第五章-内容安全基础">第五章 内容安全基础</h1><h2 id="信息内容安全威胁">信息内容安全威胁</h2><ol type="1"><li><strong>信息内容安全概述</strong><ul><li><strong>定义</strong>：信息内容安全(Content-based InformationSecurity)是研究利用计算机从<strong>海量信息且变化迅速</strong>的网络中<strong>自动获取、识别和分析特定安全主题相关信息</strong>的技术，借助人工智能与大数据技术管理网络信息传播，是网络安全系统的核心理论与关键组成部分，对提高网络使用效率、净化网络空间、保障社会稳定意义重大。</li><li><strong>信息内容安全分类</strong><ul><li>政治信息安全</li><li>军事信息安全</li><li>商业信息安全</li></ul></li><li>领域、内涵及关键技术<ul><li><figure><img src="image-86.png" srcset="/img/loading/loading3.gif" lazyload alt="领域、内涵及关键技术"><figcaption aria-hidden="true">领域、内涵及关键技术</figcaption></figure></li></ul></li></ul></li><li><strong>网络信息内容安全的重要性</strong><ul><li>提高网络用户及网站的使用效率。</li><li>净化网络空间，营造健康文明的网络文化环境。</li><li>提高国家信息安全保障水平，是保障国家安全的重要环节。</li></ul></li><li><strong>信息内容安全威胁</strong><ul><li>内容安全面临<strong>泄露（非授权访问）、欺骗、破坏和篡夺</strong>等威胁。<ul><li><figure><img src="image-87.png" srcset="/img/loading/loading3.gif" lazyload alt="威胁"><figcaption aria-hidden="true">威胁</figcaption></figure></li></ul></li><li>恶意用户产生传播的<strong>恶意内容</strong>也是网络空间面临的潜在安全威胁。</li></ul></li><li><strong>经典的信息内容安全挑战</strong><ul><li><strong>内容获取</strong><ul><li>动态网络社区信息的深入提取。</li><li>跨网络媒体内容的高性能提取。</li><li>混合网络身份内容获取。</li></ul></li><li><strong>内容分析</strong><ul><li>多源网络媒体信息的数据清洗。</li><li>海量非结构化信息的数据仓储与数据挖掘。</li><li>多媒体群体理解技术有待发展。</li></ul></li><li><strong>内容网络</strong><ul><li>内容中心网络命名攻击。</li><li>内容中心网络缓存污染。</li><li>内容中心网络路由攻击。</li></ul></li></ul></li><li><strong>典型的互联网恶意用户行为攻击</strong><ul><li><strong>Spam用户</strong>：向合法用户发布广告、色情、钓鱼等恶意信息，在开放式在下社交网络上将恶意内容快速而大规模传播。</li><li><strong>Sybil攻击（女巫攻击）</strong>：攻击者利用单个节点来伪造多个身份存在于P2P网络中，从而达到削弱网络的冗余性，降低网络健壮性，监视或干扰网络正常活动等目的。攻击者可以通过只部署一个实体，向网络中广播多个身份ID，来充当多个不同的节点（Sybil节点）。Sybil节点为攻击者争取了更多的网络控制权，一旦用户查询资源的路径经过这些Sybil节点，攻击者可以干扰查询、返回错误结果，甚至拒绝回复。</li><li><strong>水军用户</strong>：通过评论或转发参与热点话题，用大量有情感倾向的评论影响舆情态势，如网络推手、打手、刷粉等行为。</li></ul></li><li><strong>以内容为中心的未来互联网</strong><ul><li><strong>目标与意义</strong><ul><li>以内容为中心的未来互联网旨在<strong>将内容名称而不是IP地址</strong>作为传输内容的标识符，从而实现信息的路由。</li></ul></li><li>内容中心网络意义<ul><li>实施更多优化表示来增强网络性能</li><li>提高未来互联网的智能水平</li></ul></li><li>内容中心攻击分类<ul><li><strong>命名</strong>：攻击者可审查和过滤内容。</li><li><strong>路由</strong>：恶意攻击者能发布/订阅无效内容或路由。</li><li><strong>缓存</strong>：可能污染或破坏缓存系统、侵犯中心网络隐私。</li><li><strong>其他</strong>：传输过程中存在未经授权的访问/更改内容风险。</li></ul></li></ul></li></ol><h2 id="网络信息内容获取">网络信息内容获取</h2><ol type="1"><li><strong>网络信息内容获取技术</strong><ul><li>分类<ul><li>文本信息：始终是网络媒体信息中占比最大的信息类型。</li><li>图像信息</li><li>音频信息</li><li>视频信息</li></ul></li><li>获取范围<ul><li>与面向特定点的网络通讯信息获取不同，网络媒体信息获取理论上可覆盖整个国际互联网。</li></ul></li><li><strong>网络媒体信息获取流程</strong><ul><li>初始URL集合</li><li>信息获取</li><li>信息解析</li><li>信息判重</li><li><figure><img src="image-101.png" srcset="/img/loading/loading3.gif" lazyload alt="流程"><figcaption aria-hidden="true">流程</figcaption></figure></li><li><figure><img src="image-88.png" srcset="/img/loading/loading3.gif" lazyload alt="媒体信息获取流程"><figcaption aria-hidden="true">媒体信息获取流程</figcaption></figure></li></ul></li></ul></li><li><strong>基于Cookie机制实现身份认证</strong><ul><li><figure><img src="image-102.png" srcset="/img/loading/loading3.gif" lazyload alt="基于Cookie机制的HTTP信息交互过程"><figcaption aria-hidden="true">基于Cookie机制的HTTP信息交互过程</figcaption></figure></li><li><figure><img src="image-103.png" srcset="/img/loading/loading3.gif" lazyload alt="基于Cookie机制实现需身份认证才可访问信息请求"><figcaption aria-hidden="true">基于Cookie机制实现需身份认证才可访问信息请求</figcaption></figure></li></ul></li><li><strong>基于浏览器模拟的获取技术</strong><ul><li>利用JSSh客户端向内嵌JSSh服务器的网络浏览器发送JavaScript指令</li><li>指示网络浏览器进行网络身份认证交互，网页发布信息浏览等操作。</li><li><figure><img src="image-89.png" srcset="/img/loading/loading3.gif" lazyload alt="网络媒体信息获取"><figcaption aria-hidden="true">网络媒体信息获取</figcaption></figure></li></ul></li><li><strong>信息内容获取的典型工具 - 网络爬虫</strong><ul><li>定义：在互联网上的实施信息内容获取的主要工具，是按照一定的规则，自动的抓取互联网信息的<strong>程序或脚本</strong>。</li><li><strong>分类(选择性)</strong>：<ul><li>服务于搜索引擎等搜索类应用的网络爬虫</li><li>针对性进行信息收集的网络爬虫</li></ul></li><li><strong>分布式机制</strong>：网络爬虫需要采用多进程或者多线程，甚至分布式机制来保证信息获取的全面性和时效性。</li></ul></li><li><strong>信息内容特征抽取与选择</strong><ul><li>地位：信息内容的表示及其特征项的选取是<strong>数据挖掘、信息检索</strong>的一个基本问题，把从信息中抽取的<strong>特征词</strong>进行<strong>量化</strong>表示文本信息。</li></ul><ol type="1"><li><strong>文本信息</strong><ul><li>文本转化为可处理的结构化形式</li><li>文本特征选择以达到降维的目的，主要有字符串匹配、基于统计方法、基于理解方法</li><li>文本特征项的特点：<ol type="1"><li>特征项要能够确实标示文本内容;</li><li>特征项具有将目标文本与其他文本相区分的能力;</li><li>特征项的个数不能太多;</li><li>特征项分离要比较容易实现。</li></ol></li><li>特征抽取的主要功能：在不损伤文本核心信息的情况下尽量减少要处理的单词数，以此来降低向量空间维数，从而简化计算，提高文本处理的速度和效率。</li><li>特征选取方式<ul><li>采用向量空间模型来描述文本向量</li><li>通过特征选择来降维，找到代表性特征</li></ul></li><li>特征选择过程<ul><li>根据特征评估函数计算各个特征的评分值</li><li>按照评分值对这些特征进行排序</li><li>选取若干个评分值最高的作为特征词</li></ul></li><li><figure><img src="image-90.png" srcset="/img/loading/loading3.gif" lazyload alt="特征抽取与选择"><figcaption aria-hidden="true">特征抽取与选择</figcaption></figure></li></ul></li><li><strong>音频信息</strong><ul><li>提取音频的时域和频域特征</li><li>建立数据库，对音频数据进行特征提取并通过特征对数据聚类</li></ul></li><li><strong>图像信息</strong><ul><li>图像颜色特征提取</li><li>图像纹理特征提取</li><li>其他图像特征提取</li></ul></li></ol></li></ol><h2 id="网络信息内容分析与处理">网络信息内容分析与处理</h2><ol type="1"><li><strong>信息内容分析环节</strong><ul><li>海量信息内容分析基本处理环节可以归结为<strong>分类和过滤</strong>，其他更加复杂的处理问题则是上述简单处理问题的组合。</li><li>在信息检索和文本编辑等应用中，快速对用户定义的模式或者短语进行分类是最常见的需求。<strong>高效的分类和过滤算法</strong>能使信息处理变得迅速而准确，反之，则会使处理过程变得冗长而模糊。</li></ul></li><li><strong>信息内容分类方法</strong><ul><li><figure><img src="image-91.png" srcset="/img/loading/loading3.gif" lazyload alt="分类方法"><figcaption aria-hidden="true">分类方法</figcaption></figure></li></ul></li><li><strong>信息内容过滤</strong><ul><li><strong>定义</strong>：<ul><li>信息过滤是大规模内容处理的一种典型操作，对陆续到达的信息进行过滤，是满足用户信息需求的信息选择过程。</li><li>根据用户的信息需求，运用一定的标准和工具，从大量的动态网络信息流中选取相关的信息或剔除不相关信息的过程。</li></ul></li><li>说明：<ul><li>过滤系统是为无结构化和半结构化的数据而设计的信息系统；</li><li>信息过滤系统主要用来处理大量的动态的信息；</li><li>过滤是基于对个体或群组的信息偏好的描述，也称为用户取向；</li><li>过滤是从动态的数据流中收集或去掉某些文本信息</li></ul></li><li><figure><img src="image-95.png" srcset="/img/loading/loading3.gif" lazyload alt="通用信息过滤模型"><figcaption aria-hidden="true">通用信息过滤模型</figcaption></figure></li><li><strong>任务</strong>：<ul><li>信息过滤是提供信息的有效流动，消除或者减少信息过量、信息混乱、信息滥用造成的危害。<strong>为用户剔除不合适的信息</strong>是当前信息过滤的主要任务之一。</li></ul></li><li><strong>技术分类</strong><ul><li><strong>根据过滤方法</strong>：<ul><li>分为基于内容的过滤</li><li>基于用户兴趣的过滤</li><li>协作过滤</li></ul></li><li><strong>根据操作主动性</strong>：<ul><li>主动过滤</li><li>被动过滤</li></ul></li><li><strong>根据过滤位置</strong>：<ul><li>信息的源头过滤</li><li>服务器和客户端过滤</li></ul></li><li><strong>根据过滤的目的</strong><ul><li>用户过滤</li><li>安全过滤</li></ul></li></ul></li><li><strong>主要方法(统计方法)</strong><ul><li><strong>向量中心法</strong>：简单实用，应用广泛</li><li><strong>相关反馈法</strong>：实现较易，受训练集合影响较大</li><li><strong>K近邻法</strong>：原理简单，需要确定k值</li><li><strong>贝叶斯法</strong>：机器学习中应用广泛</li><li><strong>多元回归模型</strong>：运用线性最小平方匹配算法</li><li><strong>支持向量机</strong>：文本分类领域比较成功，训练过程效率不高</li><li><strong>概率模型</strong>：特征加权时融入概率因素</li></ul></li><li><strong>常见应用</strong><ul><li><strong>Internet搜索结果过滤</strong>：如搜索引擎对同一问题返回众多结果时，筛选出更符合用户需求的内容。</li><li><strong>用户电子邮件过滤</strong>：过滤垃圾邮件等。</li><li><strong>浏览器过滤</strong>：定制浏览器按用户偏好过滤内容。</li><li><strong>专为未成年人过滤</strong>：去除不适合未成年人的信息。</li><li><strong>为客户过滤</strong>：根据客户爱好、兴趣进行信息筛选。</li></ul></li></ul></li><li><strong>线性分类器</strong>：<ul><li>定义：通过寻找一个投影方向（线性变换，线性组合），将高维问题降低到一维问题来解决，并且要求变换后的一维数据具有如下性质：同类样本尽可能聚集在一起，不同类的样本尽可能地远。</li><li>X输入，<span class="math inline"><em>X</em><sub><em>i</em></sub></span>表示的是第i个输入；Y表示输出；W表示权向量；<span class="math inline"><em>ω</em><sub>0</sub></span>是阈值，f是一个判别函数。</li><li>基本思想：寻找合理决策超平面（确定投影方向和阈值<span class="math inline"><em>ω</em><sub>0</sub></span>），通过给定训练数据确定线性判别函数。设这个超平面为w，满足以下两式子，即通过给定的训练数据确定线性判别函数。<ul><li><span class="math inline"><em>w</em><sup><em>T</em></sup> * <em>x</em> &gt; 0, ∀<em>x</em> ∈ <em>ω</em><sub>1</sub></span></li><li><span class="math inline"><em>w</em><sup><em>T</em></sup> * <em>x</em> &lt; 0, ∀<em>x</em> ∈ <em>ω</em><sub>2</sub></span></li></ul></li><li><figure><img src="image-92.png" srcset="/img/loading/loading3.gif" lazyload alt="线性分类器"><figcaption aria-hidden="true">线性分类器</figcaption></figure></li></ul></li><li><strong>最近邻分类法（KNN）</strong><ul><li>定义：<ul><li>K最近邻(k-NearestNeighbor-KNN)分类算法属于监督学习算法，多用于图像分类和识别领域。</li></ul></li><li><strong>核心思想</strong>：<ul><li><strong>确定一个临近度的度量,相似性越高，相异性越低的数据样本，可以认为是同一个数据类别</strong>，即如果一个样本在特征空间中的K个最相近(特征空间中最邻近)的样本中的大多数属于某一个类别，则样本也属于这个类别。</li></ul></li><li><strong>核心步骤</strong>：<ul><li>数据清洗：数据规范化;</li><li>确定临近度的度量，并计算临近度;</li><li>按照临近度递增次序排序;</li><li>选取与当前点距离最小的k个点;</li><li>确定前k个点所在类别的出现频率;</li><li>返回前k个点出现频率最高的类别作为当前点的预测分类。</li></ul></li><li><figure><img src="image-93.png" srcset="/img/loading/loading3.gif" lazyload alt="KNN"><figcaption aria-hidden="true">KNN</figcaption></figure></li></ul></li><li><strong>支持向量机（SVM）</strong><ul><li>定义：<ul><li>SVM支持向量机（英文全称：support vectormachine）是一个分类算法，通过找到一个分类平面，将数据分隔在平面两侧，从而达到分类的目的。</li></ul></li><li><strong>分类基本思路</strong><ul><li><strong>找到最合适的分类平面</strong>，最直接的评估标准S是被分隔的两边数据距离平面间隔最大</li><li>换句话，SVM就是获取最大间隔的超平面。<span class="math inline"><em>w</em> * <em>x</em> + <em>b</em> = 0</span>确定的情况下，<span class="math inline">|<em>w</em><em>x</em> + <em>b</em>|</span>表示点距离超平面的距离，而超平面作为二分类器，如果<span class="math inline"><em>w</em><em>x</em> + <em>b</em> &gt; 0</span>，判断类别y为1,否则判定为-1。</li></ul></li><li><figure><img src="image-94.png" srcset="/img/loading/loading3.gif" lazyload alt="SVN"><figcaption aria-hidden="true">SVN</figcaption></figure></li></ul></li></ol><h2 id="舆情系统功能及内容分析">舆情系统功能及内容分析</h2><ol type="1"><li><strong>网络舆情系统概述</strong><ul><li><strong>定义</strong>：舆情指在一定的社会空间内，围绕中介性社会事项的发生、发展和变化，作为主体的民众对作为客体的国家管理者产生和持有的社会政治态度。如果把中间的一些定语省略掉，<strong>舆情就是民众的社会政治态度</strong>。</li><li><strong>网络舆情系统</strong>：<ul><li>对海量非结构化信息挖掘与分析；</li><li>实现对网络舆情的热点、焦点、演变等信息的掌握；</li><li>为网络舆情监测与引导部门的决策提供科学依据。</li></ul></li><li><strong>网络舆情特点</strong>：<ul><li>直接性：通过网络直接发表意见，传播迅速</li><li>随意性和多元化：网民可匿名发表观点，健康观点和灰色言论并存</li><li>突发性：网络快速传播的特性使关注焦点迅速成长为舆论热点</li><li>隐蔽性：虚拟网络空间中网民可以隐身发言</li><li>偏差性：网络舆情不等同于全民立场</li></ul></li></ul></li><li><strong>网络舆情分析系统框架</strong><ul><li><figure><img src="image-104.png" srcset="/img/loading/loading3.gif" lazyload alt="框架"><figcaption aria-hidden="true">框架</figcaption></figure></li><li><figure><img src="image-105.png" srcset="/img/loading/loading3.gif" lazyload alt="框架"><figcaption aria-hidden="true">框架</figcaption></figure></li></ul></li><li><strong>网络舆情监测技术的发展趋势</strong><ul><li><strong>针对信息源的深入信息采集</strong>：<ul><li>传统搜索引擎一般采用<strong>广度优先</strong>的策略遍历Web并下载文档。</li><li>不能完全满足实际需求，其主要不足体现在——<strong>互联网定点信息源信息的提取率过低</strong>。</li></ul></li><li><strong>异构信息融合分析</strong>：<ul><li>互联网信息在<strong>编码、数据格式以及结构组成</strong>方面存在巨大差异。</li><li>信息分析与提取的重要前提是对信息在<strong>同一表达或标准</strong>的前提下进行有机的结合</li></ul></li><li><strong>非结构信息的结构化表达</strong>：<ul><li>非结构化信息对于阅读者而言比较容易理解，但对于计算机信息处理系统却相当困难。</li><li>目前已有优秀的技术与方法可以对结构化数据进行分析。</li><li>说明：<ul><li>结构化数据是指按照预定义的模型结构化或以预定义的方式组织的数据，结构化数据通常存储在关系数据库管理系统(RDBMS)中。</li><li>非结构化数据指那些无法用固定结构来逻辑表达实现的数据，简单来说就是用户散落在论坛、微博、微信或其他渠道发表的关于产品的各种评价或吐槽。</li><li>非结构化数据主要包含三大块：第一是文本文字；第二是图像、图片等；第三是视频流、电视流，还有网页、元数据等。</li></ul></li></ul></li></ul></li><li><strong>网络舆情分析关键技术</strong><ul><li>信息采集技术</li><li>热点发现</li><li>热点评估</li><li>主题跟踪</li><li>分析处理</li></ul></li><li><strong>网络舆情系统的常用方法</strong><ul><li><strong>高仿真网络信息深度提取技术</strong>：<ul><li>是舆情监控系统信息获取模块的核心，重点研究<strong>原创网络互动式动态信息提取</strong>，形成高性能动态信息提取系统，组成舆情监控系统的信息获取模块。</li><li><figure><img src="image-96.png" srcset="/img/loading/loading3.gif" lazyload alt="高仿真网络信息深度提取"><figcaption aria-hidden="true">高仿真网络信息深度提取</figcaption></figure></li></ul></li><li><strong>基于语义的海量媒体内容特征快速提取与分类技术</strong>：<ul><li>实现信息特征提取和结构化转变功能，组成舆情监控系统信息分析模块。</li><li>为实现舆情的分析、监测与预警完成信息转化。</li><li><figure><img src="image-97.png" srcset="/img/loading/loading3.gif" lazyload alt="基于语义的海量文本特征快速提取与分类"><figcaption aria-hidden="true">基于语义的海量文本特征快速提取与分类</figcaption></figure></li></ul></li><li><strong>非结构信息自组织聚合表达技术</strong>：<ul><li>满足网络舆情监测预警基础设施与典型应用的实际需求，组成数据分类、仓储和挖掘引擎模块。</li><li><figure><img src="image-98.png" srcset="/img/loading/loading3.gif" lazyload alt="非结构信息自组织聚合表达"><figcaption aria-hidden="true">非结构信息自组织聚合表达</figcaption></figure></li></ul></li></ul></li><li><strong>典型运用——互联网舆情内容分析</strong><ul><li><strong>深度挖掘技术</strong>：利用定向搜索手段完成针对指定信息源的深入、全面的<strong>内容提取</strong>操作，以面向结构迥异、风格多样的数据发布源实施互联网媒体信息监控工作。</li><li>关键技术<ul><li>异构信息归一化</li><li>网络热点自动发现</li><li>协商与人际对话模拟</li><li>热点数据报告定制</li></ul></li></ul></li></ol><h2 id="内容中心网络及安全">内容中心网络及安全</h2><ol type="1"><li><strong>内容中心网络概述</strong><ul><li><strong>定义</strong>：<ul><li>内容中心网络(Content CentricNetwork,CCN)是2009年提出的新型下一代网络体系结构，是一个基于内容的网络。</li></ul></li><li><strong>核心思想</strong>：<ul><li><strong>对网络中的每个内容命名, 而不是使用主机和节点的 IP地址</strong>。当需要获取一个内容/服务时,网络节点将发送一个包含所需内容/服务名字的请求。该请求按照内容名字进行路由,而不是 IP 地址。</li></ul></li><li><strong>目标</strong>：<ul><li>替代现有的以 IP为核心的网络体系架构，“以数据为中心”将通信范式的重点从关注于<code>where</code>(地址、服务器、主机)转变到<code>what</code>（通信的内容）。以对数据命名的方式代替位置（IP地址），将数据转变成网络的第一要素。</li></ul></li></ul></li><li><strong>内容中心网络架构</strong><ul><li><strong>基本原理</strong>：摒弃IP地址为中心的传输架构，采用<strong>以内容名称为中心</strong>的架构，通过<strong>以内容为中心的订阅机制和语义主导的命名、路由和缓存策略</strong>，在解决当前基于IP地址进行联网的模式上体现出了巨大的潜力</li><li><strong>架构组成部分</strong><ul><li><strong>内容信息对象</strong>：存储在计算机中并可访问的各类对象，如网页、文档、电影、照片、音乐等。</li><li><strong>命名</strong>：是信息对象的标识，具有<strong>全局性和唯一性</strong>。其地位与TCP/IP架构的IP地址类似。<ul><li>分层命名方案</li><li>扁平命名方案</li></ul></li><li><strong>路由</strong>：<ul><li><figure><img src="image-99.png" srcset="/img/loading/loading3.gif" lazyload alt="路由"><figcaption aria-hidden="true">路由</figcaption></figure></li></ul></li><li><strong>缓存</strong>：每个CCN节点维护<strong>缓存表</strong>，用于缓存CCN路由器接收的内容消息对象，以便<strong>响应后继接收到的相同请求</strong>。</li><li><strong>应用程序编程接口</strong>：CCN应用程序编程接口根据<strong>请求和交付</strong>内容信息对象定义，用于内容信息对象的<strong>发布和获取</strong>操作。</li></ul></li></ul></li><li><strong>面向内容中心网络的攻击分类</strong><ul><li><strong>命名相关攻击</strong>：<ul><li>监视列表攻击</li><li>嗅探攻击</li></ul></li><li><strong>路由相关攻击</strong>：<ul><li>DDOS攻击</li><li>欺骗攻击</li></ul></li><li><strong>缓存相关攻击</strong>：<ul><li>驱逐流行内容攻击</li></ul></li><li><strong>其他攻击</strong>：<ul><li>假冒攻击</li><li>重放攻击</li></ul></li></ul></li><li><strong>基于雾计算的内容信息中心网络安全防护架构</strong><ul><li>基于雾计算的智能防火墙模型：<ul><li>利用<strong>雾计算范式</strong>在<strong>网络边缘</strong>实现了<strong>隔离防御</strong>系统；</li><li>基于已有的安全策略，该防火墙能够实现对<strong>兴趣包洪泛攻击</strong>的智能感知和动态防御。</li><li><figure><img src="image-100.png" srcset="/img/loading/loading3.gif" lazyload alt="雾计算"><figcaption aria-hidden="true">雾计算</figcaption></figure></li></ul></li></ul></li></ol><h1 id="第六章-应用安全基础">第六章 应用安全基础</h1><h2 id="应用安全概述">应用安全概述</h2><ol type="1"><li><strong>研究背景</strong><ul><li>信息技术、移动通信技术等的紧密结合与快速发展，以及智能终端软硬件的不断升级与换代，促进了移动互联网、云计算、大数据、物联网等应用的不断普及。</li><li>海量用户个人信息跨系统、跨生态圈乃至跨国境流转常态化<ul><li>住宿出行</li><li>移动社交媒体平台</li><li>移动支付</li></ul></li></ul></li><li><strong>研究范围</strong><ul><li><strong>定义</strong>：应用安全是指为保障各种应用系统在信息的获取，存储，传输和处理各个环节的安全所涉及的相关技术的总称。</li><li><figure><img src="image-106.png" srcset="/img/loading/loading3.gif" lazyload alt="研究范围"><figcaption aria-hidden="true">研究范围</figcaption></figure></li><li>e.g.<ol type="1"><li>云计算：<ul><li>云计算已成为当前普及的一种信息服务提供方式，为政府和企业提供了新信息系统构建方式和计算方式。</li><li>由于云计算造成了数据所有权和管理权的分离</li><li>在以下两方面开展持续研究：<ul><li>云计算基础设施的可信性</li><li>云数据安全保障</li></ul></li></ul></li><li>工业互联网：<ul><li>数据汇集到云端，要保证系统的可靠运行，需要保证数据的机密性、完整性、访问和流转的可控性以及系统软硬件的安全性</li></ul></li><li>大数据：<ul><li>大数据是一种规模大到在获取、存储、管理、分析方面大大超出了传统数据库软件工具能力范围的数据集合</li><li>大数据本质上是一种方法论，是组合分析多源异构的数据来进行更好的决策，获得的数据越多越能发现数据中蕴含的知识、价值和规律</li><li>实现大数据安全应用的关键：<ul><li>保证数据来源的真实</li><li>促进多源数据的共享</li><li>有效挖掘数据的价值</li><li>保障数据所有者的权益</li></ul></li></ul></li><li>人工智能：<ul><li>人工智能在图像识别、自然语言理解、知识发现与数据挖掘、博弈等方面取得了显著的成就</li><li>人工智能技术越来越多的应用在网络安全防护、密码设计与分析领域</li></ul></li><li>区块链：<ul><li>区块链是数字加密货币-比特币的基础支撑技术</li><li>区块链本身安全问题、隐私保护问题亟待解决，同时对于互联网信息服务、金融安全也带来相应的风险</li></ul></li></ol></li></ul></li></ol><h2 id="身份认证的主要方法">身份认证的主要方法</h2><ol type="1"><li><strong>身份认证定义</strong><ul><li><strong>认证(Authentication)是证实客户的真实身份与其所声称的身份是否相符的过程</strong>，是保证系统安全的重要措施之一。当服务器提供服务时，需要确认请求者的身份，请求者有时也需要确认服务提供者的身份。</li><li>实现身份认证的基本途径：<ul><li>所知：个人掌握的知识，如口令，秘密</li><li>所有：个人所具有的东西，如身份证、令牌、密钥等</li><li>个人特征：指纹、笔迹等</li></ul></li></ul></li><li><strong>身份认证的主要方法</strong><ul><li>用户名/口令认证(所知)<ul><li>优点：简单易用，不需要任何硬件设备</li><li>缺点：<ul><li>口令易泄露；</li><li>弱口令容易被猜测，</li><li>易受字典攻击和暴力攻击；</li><li>复杂的强安全口令难于记忆</li></ul></li></ul></li><li>动态口令/一次性口令OTP(所有)<ul><li>一次性口令是变化的密码，它来源于<strong>产生密码的运算因子是变化的</strong></li><li>一次性口令产生因子一般都采用ISO/IEC 9798-2-2008标准的双运算因子(TwoFactor)，其一是有效期较长的共享密钥，其二是<strong>随机因子</strong><ul><li>1)基于时间同步</li><li>2)基于事件同步</li><li>3)短信验证码</li></ul></li></ul></li><li>挑战应答认证(所有)<ul><li>通过一轮应答实现服务器对用户的认证，利用一次性随机数实现防重放攻击</li><li><figure><img src="image-107.png" srcset="/img/loading/loading3.gif" lazyload alt="基于单向密码函数和基于数字签名算法"><figcaption aria-hidden="true">基于单向密码函数和基于数字签名算法</figcaption></figure></li><li>基于单向密码函数</li><li>基于数字签名算法</li></ul></li><li>基于生物特征的认证(个人特征)<ul><li><strong>生物统计学</strong>(Biometrics)方法正在成为实现个人身份认证最简单而安全的方法</li><li>签名、指纹、人脸、虹膜、语音等</li><li>优点<ul><li>可信度高</li><li>个人特征因人而异，难以伪造</li><li>随时携带，不易丢失</li></ul></li><li>缺点<ul><li>不够稳定(辨别失败率高)</li><li>不能挂失</li></ul></li></ul></li><li>图灵测试<ul><li>验证登录信息系统的是人还是自动化执行的程序</li><li>采用的方式利用人能快速回答，而机器回答困难的问题</li><li>目的是防范利用计算机程序对系统进行暴力破解</li></ul></li><li>多因子认证<ul><li><strong>实际应用当中，多采取多种认证方式结合，构成多因子认证方式。</strong></li></ul></li></ul></li><li><strong>公钥基础设施PKI</strong><ul><li><strong>定义</strong>：<ul><li>PKI：公钥基础设施(<strong>P</strong>ublic <strong>K</strong>ey<strong>I</strong>nfrastructure)是一种遵循标准的利用公钥理论和技术建立的提供安全服务的<strong>基础设施</strong>。</li></ul></li><li>目的：<ul><li>解决网上<strong>身份认证、电子信息的完整性和不可抵赖性</strong>等安全问题，为网络应用提供可靠的安全服务。</li></ul></li><li>任务：<ul><li>确立可信任的数字身份。</li></ul></li><li><strong>数字证书</strong>：<ul><li>一个用户的<strong>身份</strong>与其所持有的<strong>公钥</strong>绑定，由一个可信任的权威机构CA对该用户身份及对应公钥相绑定的证书进行数字签名，以证明证书的有效性，从而证明用户的身份。</li></ul></li><li>信任体系：<ul><li>X.509标准采用树型的信任体系。根CA自签发证书，是整个信任体系的锚点</li><li>上级CA为下级CA或者用户颁发证书</li><li>Alice和Bob的证书沿着信任路径可以到达相同的证书节点，就可以建立信任关系</li><li><figure><img src="image-108.png" srcset="/img/loading/loading3.gif" lazyload alt="信任体系"><figcaption aria-hidden="true">信任体系</figcaption></figure></li></ul></li></ul></li><li>身份认证的主流标准<ol type="1"><li><strong>RADIUS</strong>：<ul><li><strong>远程认证拨入业务协议RADIUS</strong> (Remote AuthenticationDial-In User Serviceprotocol)是由Livingston公司发明的，用于接入认证和计费服务。RADIUS规范文本可以参看RFC2865和RFC2856。RAIUS在许多企业信息系统接入过程中得到应用。</li><li><figure><img src="image-109.png" srcset="/img/loading/loading3.gif" lazyload alt="RADIUS"><figcaption aria-hidden="true">RADIUS</figcaption></figure></li></ul></li><li><strong>FIDO</strong>：<ul><li><strong>在线快速身份认证</strong>(Fast IdentityOnline)使用<strong>生物特征识别技术代替口令</strong>对在线用户进行身份认证</li><li><strong>主要思想</strong><ul><li><strong>基于生物特征识别解锁设备上的加密密钥，使用公钥密码或者对称密码方案与服务器进行身份认证</strong>，从而可完全<strong>通过本地身份认证实现无口令的登录。</strong></li></ul></li><li>FIDO 联盟于 2012 年创立，主旨是制定无口令身份认证协议。</li><li>分类：<ul><li><strong>通用身份认证框架UAF</strong>(Universal AuthenticationFramework)</li><li><strong>通用第二因子认证协议U2F</strong>( Universal 2nd Factor)</li><li><figure><img src="image-110.png" srcset="/img/loading/loading3.gif" lazyload alt="UAF &amp; U2F"><figcaption aria-hidden="true">UAF &amp; U2F</figcaption></figure></li></ul></li><li>FIDO注册流程<ul><li><figure><img src="image-111.png" srcset="/img/loading/loading3.gif" lazyload alt="注册"><figcaption aria-hidden="true">注册</figcaption></figure></li></ul></li><li>FIDO认证流程<ul><li><figure><img src="image-112.png" srcset="/img/loading/loading3.gif" lazyload alt="认证"><figcaption aria-hidden="true">认证</figcaption></figure></li></ul></li></ul></li><li><strong>FIM</strong>：<ul><li><strong>联盟身份管理FIM</strong>(Federated IdentityManagement)可以使<strong>用户使用同一个身份在组成联盟的所有企业中访问相应的资源</strong>，支持用户身份跨安全域链接，用户可以在一个域中认证之后，不需要再进行独立的登录过程就可以访问另一个域的资源。</li><li><strong>Oauth</strong>(OpenAuthorization)是典型的FIM系统，定义了<strong>资源所有者、资源服务器、客户、授权服务器</strong>四个角色。任何服务提供商都可以实现自身的OAUTH认证服务，很多大的公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务。</li><li><strong>SSO单点登录</strong>是身份联盟的一个重要组件。SSO单点登陆是一种集中式访问控制技术，允许主体在系统上进行一次身份认证，并且不需要再次身份认证，就可以访问多个资源。公司的文件传输系统ipan就使用的单点登陆，学校的邮箱和网站，一套密码应用于所有身份认证系统</li><li>工作流程<ul><li><figure><img src="image-113.png" srcset="/img/loading/loading3.gif" lazyload alt="流程图"><figcaption aria-hidden="true">流程图</figcaption></figure></li><li>客户端(Client)向资源所有者(Resource Owner)请求授权。</li><li>客户端(Client)收到用户授权，这是代表资源所有者(ResourceOwner)授权的凭证(Authorization)。</li><li>客户端(Client)通过与授权服务器(AuthorizationServer)进行身份验证并提供授权许可来请求访问令牌(Access Token)。</li><li>授权服务器(AuthorizationServer)对客户端进行身份验证并验证授权许可，如果有效，则颁发访问令牌(AccessToken)。</li><li>客户端(Client)从资源服务器(ResourceServer)请求受保护的资源并通过提供访问令牌(AccessToken)进行身份验证。</li><li>资源服务器(Resource Server)验证访问令牌(AccessToken)，如果有效，则为请求提供服务。</li></ul></li></ul></li></ol></li></ol><h2 id="访问控制模型">访问控制模型</h2><ol type="1"><li><strong>访问控制的概念和目标</strong><ul><li><strong>概念</strong>：<ul><li>访问控制是通过某种途径<strong>显式地准许或限制访问能力及范围</strong>的一种方法，是针对越权使用资源的防御措施，通过限制对关键资源的访问，防止非法用户侵入或因为合法用户的不慎操作而造成的破坏，保证网络资源受控地，合法地使用。</li></ul></li><li><strong>基本目标</strong>：<ul><li>防止对任何资源(如计算资源、通信资源或信息资源)进行<strong>未授权的访问</strong>；</li><li>允许被授权的主体对某些客体的访问、拒绝向非授权的主体提供服务</li><li>未授权的访问包括：<ul><li><strong>非法用户进入系统</strong></li><li><strong>合法用户对系统资源的非法使用</strong></li></ul></li></ul></li></ul></li><li><strong>访问控制模型</strong><ul><li><strong>自主访问控制模型DAC</strong><ul><li>资源拥有者按照自己的意愿来决定是否将自己所拥有资源的访问权限授予其他用户，策略灵活但安全性较差</li></ul></li><li><strong>强制访问控制模型MAC</strong><ul><li>为用户和数据划分安全等级，实现了信息的单向流动，但权限管理效率偏低、缺少灵活性</li></ul></li><li><strong>基于角色的访问控制模型RBAC</strong><ul><li>通过角色对访问控制策略进行描述，系统中的用户和权限均对应于某些特定的角色。角色的引入实现了用户与权限之间的分离，简化了授权管理。</li><li><strong>核心思想</strong>：将访问权限与角色相联系<ul><li>给用户分配合适的角色</li><li>让用户与访问权限相关联</li><li>用户可以在角色间进行转换</li><li>系统可以添加、删除角色</li></ul></li><li><strong>特点</strong>：<ul><li>以角色作为访问控制的主体</li><li>角色继承</li><li>用户可以在角色间进行转换</li><li>最小特权</li></ul></li></ul></li></ul></li></ol><h2 id="零信任模型">零信任模型</h2><ol type="1"><li><strong>零信任模型(Zero Trust Model)</strong><ul><li>核心思想<ul><li><strong>网络边界内外的任何实体，在未验证之前都不予以信任</strong>，典型系统是谷BeyondCorp体系</li></ul></li><li>特点：<ul><li>内网应用程序和服务不再对公网可见</li><li>企业内网的边界消失</li><li>基于身份、设备、环境认证的精准访问控制</li><li>提供网络通信的端到端加密</li></ul></li></ul></li></ol><h2 id="典型应用及其安全">典型应用及其安全</h2><ol type="1"><li><strong>隐私保护</strong><ul><li>定义：<ul><li><strong>隐私保护是指在发布或者共享数据中不能识别出具体个人的数据</strong></li><li><strong>个人信息</strong>是指自然人的相关数据</li><li><strong>隐私</strong>是指<strong>个人敏感信息</strong><ul><li>包括身份证号码、电话号码、住址、住房类型、居住时间、过敏信息、疾病和药品使用状况、财务状况、信用记录、车辆识别码、品牌爱好、交通工具、出行地、出行时间、购买记录、指纹、掌纹、虹膜、社交账号、犯罪信息等</li></ul></li></ul></li><li>隐私保护方法：<ul><li><strong>基于数据扰乱方法</strong>：扰乱是指在数据发布前通过加入噪声、引入随机因子及对私有向量进行线型变换等手段对敏感数据进行扰乱(数据泛化、数据扭曲、数据清洗、数据屏蔽等)，以实现对原始数据改头换面的目标。这种处理方法可以快速地完成，但其安全性较差，且以降低数据的精确性为代价，从而影响数据分析结果，一般这种处理手段仅能得到近似的计算结果。</li><li><strong>基于密码的方法</strong>：主要是研究构造适用于隐私保护、与传统数据加解密不同的密钥管理机制、同态密码方案以及混淆方法、多方计算等。</li></ul></li></ul></li><li><strong>K-匿名性</strong><ul><li>仅在数据集中去掉名字不能起到匿名效果。数据集中存在一些准标识符，当与其他数据集中的信息组合在一起的时候可以重新标识身份。</li><li>1998年Sweeney 提出K-匿名。</li></ul></li><li><strong>L-多样性</strong><ul><li>同质性攻击(Homogeneity attack)</li><li>背景知识攻击(background knowledge attack)</li></ul></li><li><strong>t-邻近(t-closeness)</strong><ul><li>隐私是观测到的信息增益;看到发布的数据表之前，得到的敏感属性的先验信息；看到发布数据之后，得到后验信息；</li><li><strong>隐私是先验信息和后验信息的差额</strong></li></ul></li><li><strong>差分隐私(Differential Privacy)</strong><ul><li>定义：<ul><li>一个数据集进行统计查询计算时，<strong>不能通过多次不同的查询方式推断出数据集中是否包含一个特定个体的数据</strong>。</li><li>称一个算法A满足ϵ-差分隐私<span class="math inline">(<em>ϵ</em> − <em>D</em><em>P</em>)</span>，其中<span class="math inline"><em>ϵ</em> &gt; 0</span>，当且仅当对于任意的两个只相差一个元素的数据集D和D’，有以下条件满足：$∀𝑇 ⊆ Range(𝐴): Pr[𝐴(𝐷)∈𝑇] ≤ 𝑒^𝜀 Pr[𝐴(𝐷^′)∈𝑇] $</li></ul></li><li>实现方式：<ul><li>$ 𝑀(𝑓(𝐷)) = 𝑓(𝐷) + 𝑥 $，<ul><li>𝑓:查询函数</li><li>x:随机噪声</li></ul></li><li>拉普拉斯机制 $ Lap(𝑥│𝜇，𝑏) = e^{(−)} $</li></ul></li><li><figure><img src="image-114.png" srcset="/img/loading/loading3.gif" lazyload alt="DP"><figcaption aria-hidden="true">DP</figcaption></figure></li></ul></li><li><strong>隐私计算</strong><ul><li>定义：<ul><li><strong>隐私计算是面向隐私信息全生命周期保护的计算理论和方法</strong>，是隐私信息的所有权、管理权和使用权分离时隐私度量、隐私泄漏代价、隐私保护与隐私分析复杂性的可计算模型与公理化系统</li></ul></li><li>地位：<ul><li><strong>隐私计算是泛在网络空间隐私信息保护的重要理论基础</strong></li></ul></li><li>在处理视频、音频、图像、图形、文字、数值、泛在网络行为性信息流等信息时，对所涉及的隐私信息进行<strong>描述、度量、评价和融合</strong>等操作，形成一套符号化、公式化且具有量化评价标准的隐私计算理论、算法及应用技术，支持多系统融合的隐私信息保护</li></ul></li><li><strong>隐私保护的法律法规</strong><ul><li>HIPAA</li><li>Regulation P(Privacy of Consumer Financial Information)</li><li>FACT(Fair and Accurate Credit Transaction Act 2003)</li><li>GDPR(General Data Protection Reform)</li><li>网络安全法</li><li>个人信息保护法</li></ul></li><li><strong>云计算</strong><ul><li>定义：<ul><li>云计算是一种基于网络访问、以按需分配、共享使用的方式对物理计算资源进行供应和管理的模式</li></ul></li><li>云部署方式<ul><li><figure><img src="image-115.png" srcset="/img/loading/loading3.gif" lazyload alt="云部署方式"><figcaption aria-hidden="true">云部署方式</figcaption></figure></li></ul></li><li>云计算服务模型<ul><li>SaaS</li><li>PaaS</li><li>IaaS</li></ul></li><li><strong>云计算基础：虚拟化技术</strong><ul><li>裸金属架构<ul><li>VMware vSphere， Xen， Hyper-V， KVM</li></ul></li><li>寄居架构<ul><li>VMware Workstation， VirtualBox</li></ul></li><li>容器<ul><li>Docker</li></ul></li><li><figure><img src="image-116.png" srcset="/img/loading/loading3.gif" lazyload alt="虚拟化技术"><figcaption aria-hidden="true">虚拟化技术</figcaption></figure></li></ul></li></ul></li><li><strong>云计算安全</strong><ul><li>云基础设施安全<ol type="1"><li>虚拟机逃逸<ul><li>利用虚拟机管理软件或者虚拟机中<strong>运行软件的漏洞</strong>，控制虚拟机管理系统或者在<strong>宿主机上运行恶意软件</strong>，进而获得<strong>其他虚拟机的完全控制权限</strong></li></ul></li><li>边信道攻击<ul><li>攻击者<strong>控制的虚拟机与目标虚拟机使用相同的物理层硬件</strong>，二者交替执行。攻击者首先借助恶意虚拟机访问共享硬件和缓存，然后在交替执行的过程中通过边信道信息来推断出目标虚拟机的行为，识别相应的信息，最终导致目标虚拟机内的用户数据泄露。</li></ul></li><li>网络隔离<ul><li>云计算平台中，数据包在虚拟网络中移动，不用通过物理网络传输，在物理网络上的监控和过滤工具永远看不到这些流量，在多租户的公有云网络中引发的安全问题尤为显著</li></ul></li><li>镜像和快照的安全<ul><li>云计算平台往往通过特定的镜像来创建虚拟机或者服务实例；</li><li>攻击者通过入侵虚拟机管理系统并感染镜像，可以大幅提升攻击的效率和影响范围。若攻击者非法恢复了快照，历史数据将被清除，攻击行为将被彻底隐藏</li></ul></li></ol></li><li>云数据安全<ol type="1"><li>云存储数据安全<ul><li><strong>云加密数据库</strong><ul><li><figure><img src="image-120.png" srcset="/img/loading/loading3.gif" lazyload alt="alt text"><figcaption aria-hidden="true">alt text</figcaption></figure></li></ul></li><li><strong>密文搜索</strong><ul><li>可搜索加密技术是搜索技术和加密技术的结合。可搜索加密能够实现将用户的数据进行特殊的加密后上传到云服务器上，并且可以实现根据关键字进行检索的功能，在方便用户使用的过程中，也保护了文件的隐私安全。</li><li><figure><img src="image-118.png" srcset="/img/loading/loading3.gif" lazyload alt="密文搜索"><figcaption aria-hidden="true">密文搜索</figcaption></figure></li><li>当前可搜索加密机制分为：<ol type="1"><li>对称可搜索加密(Symmetric Searchable Encryption SSE)<ul><li>对称可搜索加密的构造通常基于伪随机函数，具有计算开销小、算法简单、速度快的特点。</li><li>除了加解密过程采用相同的密钥外，其陷门生成也需密钥的参与。</li><li>单用户模型的单用户特点使得对称可搜索加密非常适用于该类问题的解决：用户使用密钥加密个人文件并上传至服务器，检索时，用户通过密钥生成待检索关键词陷门，服务器根据陷门执行检索过程后返回目标密文。</li></ul></li><li>非对称可搜索加密(Asymmetric Searchable Encryption ASE)<ul><li>非对称可搜索加密使用两种密钥：公钥用于明文信息的加密和目标密文的检索，私钥用于解密密文信息和生成关键词陷门。</li><li>非对称可搜索加密算法通常较为复杂，加解密速度较慢，然而，其公私钥相互分离的特点，非常适用于多用户体制下可搜索加密问题的解决：发送者使用接收者的公钥加密文件和相关关键词，检索时，接收者使用私钥生成待检索关键词陷门，服务器根据陷门执行检索算法后返回目标密文。</li><li>该处理过程避免了在发送者与接收者之间建立安全通道，具有较高的实用性。</li></ul></li></ol><ul><li><figure><img src="image-117.png" srcset="/img/loading/loading3.gif" lazyload alt="SSE &amp; ASE"><figcaption aria-hidden="true">SSE &amp; ASE</figcaption></figure></li></ul></li></ul></li></ul></li><li>云计算数据安全<ul><li>保密计算旨在保护使用中的数据。<ul><li>通过加密数据，让云服务器在密文数据上进行计算。</li><li>相关技术：同态加密、特定计算安全外包、可验证外包计算</li><li><figure><img src="image-119.png" srcset="/img/loading/loading3.gif" lazyload alt="保密计算"><figcaption aria-hidden="true">保密计算</figcaption></figure></li></ul></li><li><strong>基于SGX的保密计算</strong><ul><li>SGX(Software Guard Extensions)，是 Intel CPU提供的可信执行环境，可以为云上数据代码的完整性和保密性提供芯片级的安全保障。<ol type="1"><li>在计算平台上提供一个可信的空间，保障用户关键代码和数据的机密性和完整性。</li><li>把应用程序分为两部分：安全应用程序和非安全应用程序；</li><li>将合法软件的安全操作封装在一个<code>飞地</code>(enclave)中；</li><li>当调用 enclave 函数时，只有 enclave内部的代码才能查看其数据，并始终拒绝外部访问；当调用结束时，enclave的数据会留在受保护的内存中。</li><li>注：一个 CPU中可以存在多个<code>飞地</code>，大家互不干扰，同时进行自己秘密的操作。</li></ol></li></ul></li></ul></li><li>云共享数据安全<ul><li>数据拥有者通常会将数据加密后上传到云端，给数据共享带来困难。<ul><li>大规模用户的数据共享需要大量密钥，生成、分发和保管这些密钥困难</li><li>如何制定灵活可控的访问策略，实施细粒度的访问控制，会成倍增加密钥数量</li><li>用户访问权限更新或撤销时，需要重新生成信的密钥，计算量大</li><li>相关技术：基于属性的加密技术(Attributed Based EncryptionABE)、访问策略表达技术、访问权限撤销技术、访问控制效率增强技术</li></ul></li><li><strong>CP—ABE(密文策略属性加密)</strong><ul><li>在ABE系统中，用户的密钥和密文被标记为描述性属性集，而特定密钥只有在密文的属性与用户密钥之间匹配的情况下才能解密特定的密文。<ul><li>以属性作为公钥对用户数据进行加密</li><li>用户的私钥也和属性相关，只有当用户私钥具备解密数据的基本属性时，用户才能够解密出数据明文，当密文和私钥之间至少K个属性重叠时，密码系统允许解密。</li></ul></li><li>CP-ABE：将访问控制策略嵌入到密文当中，只有当用户拥有满足访问控制策略的属性集合及其对应的私钥情况下才能解密密文。</li><li><figure><img src="image-121.png" srcset="/img/loading/loading3.gif" lazyload alt="CP-ABE"><figcaption aria-hidden="true">CP-ABE</figcaption></figure></li></ul></li></ul></li></ol></li></ul></li><li><strong>比特币与区块链</strong><ul><li>区块链<ul><li>2008年11月，中本聪(Satoshi Nakamoto)发表Bitcoin: A Peer-to-PeerElectronic Cash System，提出了无中心电子现金系统</li><li>区块链是比特币的底层技术</li><li>区块链是一个公开、透明的分布式账本</li><li>区块链是一条<strong>哈希链</strong>，<strong>用哈希串联信息</strong>，实现完整性，防止篡改，公开验证</li><li>区块链具有不可篡改性。<ul><li>区块链中存储的交易信息每一条都有相对应的 Hash 值，由每一条记录的Hash 值作为叶子节点生成二叉 Merkle 树。</li><li>Merkle 树的根节点（Hash值）保存在本区块的块头部分，区块头部除了当前区块的 Merkle树的根节点，还保存时间戳以及前一个区块的 Hash 形成一条链式结构。</li><li>因此，要想篡改区块链中的一条记录，不仅要修改本区块的Hash值，还要修改后续所有区块的Hash值，或者生成一条新的区块链结构，使得新的链比原来的链更长。</li><li>实际上，这是很难实现的。一般一个区块后面有6个新的区块生成时，即可认为该区块不可篡改，可以将该区块加入到区块链的结构中。</li></ul></li></ul></li><li>区块<ul><li>比特币网络中，<strong>数据以文件的形式被永久记录，称这些记录为区块</strong></li><li>新区块一旦被记录在区块链上，就不能被改变或者删除<ul><li><strong>时间戳</strong>记录特定的数据生成时间</li><li>默克尔树用来存储当前区块的所有交易信息</li><li>难度系数用于控制区块的生成速度，<strong>比特币每10分钟产生一个区块</strong></li></ul></li><li><figure><img src="image-122.png" srcset="/img/loading/loading3.gif" lazyload alt="比特币"><figcaption aria-hidden="true">比特币</figcaption></figure></li></ul></li><li>共识机制<ul><li>网络中各个参与节点需要<strong>确认交易的机制</strong>，使得在网络中存在故障或不可信节点的情况下，区块链网络中的交易能按照预期的正确方式执行，<strong>确保各个节点最终结果的一致性</strong>。</li><li>e.g.<ul><li>PoW(Proof of Work) 算力证明机制</li><li>PoS(Proof of Stake) 权益证明机制</li><li>DPoS(Delegated Proof of Stake) 股份授权证明机制</li><li>PBFT(Practical Byzantine Fault Tolerance)拜占庭容错算法</li></ul></li></ul></li><li>智能合约<ul><li>智能合约是<strong>运行在链上并可针对区块链数据库进行读写操作的代码</strong>，可以自动执行参与方指定的数字契约</li><li>特点:<ul><li>无须中介，满足合约条件即可自动执行与验证计算机协议</li><li>最小化意外或恶意情况的发生</li><li>最小化信任中介职能</li><li>降低仲裁以及强制执行的成本</li><li>降低违约带来的损失</li></ul></li><li><figure><img src="image-123.png" srcset="/img/loading/loading3.gif" lazyload alt="智能合约模型"><figcaption aria-hidden="true">智能合约模型</figcaption></figure></li></ul></li><li>区块链主要类型<ul><li><strong>公有链</strong><ul><li>自由加入和退出(比特币、以太坊等)</li></ul></li><li><strong>联盟链</strong><ul><li>通过授权加入和退出(Hyperledger、R3)</li></ul></li><li><strong>私有链</strong><ul><li>私有机构单中心网络</li></ul></li></ul></li><li>区块链的安全<ul><li><strong>51%算力攻击</strong>：当攻击者掌握了超过全网50%的算力，就很容易阻止其他节点确认交易，也可以逆转当前区块已经完成的交易，并在网络中双花电子货币。2018年，Zencash、Verge、EthereumClassic就受到了51%攻击</li><li><strong>攻击交易所</strong>：加密货币交易所拥有大量的加密货币，若安全防范措施不到位，成为黑客们关注的目标。当前对交易所的攻击频发，数字货币被窃时有发生</li><li><strong>软件漏洞</strong>：2018年钱包和去中心化APP的软件bug导致了超过2400万美元的损失。需要完备的代码审计、渗透测试和智能合约监控</li><li><strong>隐私泄露</strong>：公有链数据可以公开获取，通过大数据关联分析，可能对特定用户去标识化，从而泄露用户隐私信息。</li></ul></li><li>区块链的安全事件<!-- - 零时科技 联合多家媒体共同发布《2019年度区块链十大安全事件》：51%算力攻击  - 2019年3月29日，韩国知名数字货币交易所Bithumb疑似遭到黑客攻击，黑客窃取了价值1000万多美元的EOS和价值600万多美元的XRP；  - 2019年3月24日，新加坡DragonEx交易所遭到黑客入侵，被盗价值600余万元的数字货币，黑客使用含有0day的软件进行钓鱼攻击。  - 2019年5月7日，知名数字货币交易所发出公告称，黑客从币安热钱包中盗取了7000枚比特币，价值数千万美元。 --></li></ul></li><li><strong>人工智能</strong><ul><li>主要技术领域<ul><li>自然语言处理<ul><li>通过计算机对自然语言的分析，对词法、句法、语法和语义进行理解分析，实现人机信息交流</li></ul></li><li>计算机视觉<ul><li>让计算机具备理解图像表示内容、图像中物体存在的关系等能力。如文字识别、图像处理、图像识别</li></ul></li><li>数据挖掘<ul><li>从数据中提取出具有潜在价值的信息和知识。如用户精准画像，智能推荐等</li></ul></li><li>深度学习<ul><li>通过建立模拟人脑分析学习的神经网络对数据进行解释。常见的深度学习模型：卷积神经网络(CNN)、循环神经网络(RNN)、对抗生成网络(GAN)和强化学习(RL)等</li></ul></li></ul></li><li>安全问题<ul><li>对抗样本<ul><li>对待预测样本添加特定很小的扰动或者进行细微的修改，使模型对于该样本判断出错，“熊猫”图像添加少量噪声后就会被识别为长臂猿，且可信度为99.3%</li></ul></li><li>模型萃取<ul><li>通过构造请求向目标服务发起查询，取得目标模型参数或者构造出与目标模型功能相似可替代的模型</li></ul></li><li>投毒攻击<ul><li>在模型训练过程中修改训练数据集或者投放精心构造的恶意样例，来使训练数据中毒或者被污染，从而干扰机器学习模型的训练过程，降低最终得到模型的判断准确性</li></ul></li><li>训练数据窃取<ul><li>攻击模型训练集，获得训练数据集的具体样本及统计分布，或者判断某条数据是否在该训练数据集中</li></ul></li></ul></li><li>人工智能与网络空间安全的影响<ul><li>复杂性挑战：<ul><li>复杂的技术构成和应用场景势必会产生新的安全漏洞</li></ul></li><li>网络犯罪<ul><li>伪造语音、图片、视频，生成虚假内容，识别验证码</li></ul></li><li>隐私保护侵犯<ul><li>收集、识别个人隐私，精准画像</li></ul></li><li>不确定性风险<ul><li>人工智能不可控，产生意外损害</li></ul></li><li>智能网络攻防<ul><li>自动化的网络攻防</li></ul></li><li>人工智能伦理<ul><li>人工智能与人类的关系，是否会取代人类</li></ul></li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>网安法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Notes</title>
    <link href="/posts/Git-Notes/"/>
    <url>/posts/Git-Notes/</url>
    
    <content type="html"><![CDATA[<h1 id="git-notes">Git Notes</h1><p>为什么我会写这篇博客，自然是因为偶尔会想不起来某些Git命令，又不想每次都上网查。对于一个在进入大学前完全没接触过代码、直到大一结束才第一次接触Git和Linux的人，这看起来似乎情有可原。但是！为了以防今后某些不正确的操作将自己的仓库甚至整个项目搞得一团糟，还是把我容易搞混的Git命令记录下来吧！</p><h1 id="修改-添加到暂存区-提交-推送的状态转换">修改-添加到暂存区-提交-推送的状态转换</h1><h2 id="状态表示">状态表示</h2><ul><li>设状态0为初始状态</li><li>工作区文件修改后为状态1</li><li>执行add将工作区修改添加到暂存区后为状态2</li><li>执行commit将暂存区的修改提交到本地仓库后为状态3</li><li>执行push将本地仓库的修改推送到远程仓库后为状态4</li></ul><h2 id="状态转换">状态转换</h2><p>状态转换图如下： <img src="image.png" srcset="/img/loading/loading3.gif" lazyload alt="状态转换图"></p><h2 id="各状态转换指令">各状态转换指令</h2><ol type="1"><li><p><strong><code>1-&gt;0</code>（修改后回到初始状态，不保留修改）</strong></p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">checkout</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.</span></span></code></pre></div></div></figure>此命令会用最近一次提交的版本覆盖工作区的所有文件，从而丢弃工作区的修改，回到初始状态。<p></p></li><li><p><strong><code>2-&gt;0</code>（已 <code>add</code>后回到初始状态，不保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--hard</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD</span></span></code></pre></div></div></figure><code>git reset --hard</code> 会将暂存区和工作区都重置为<code>HEAD</code>指向的提交版本，即丢弃暂存区和工作区的修改，回到初始状态。<p></p></li><li><p><strong><code>3-&gt;0</code>（已 <code>commit</code>后回到初始状态，不保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--hard</span><span style="color: #ABB2BF"> [初始提交的哈希值]</span></span></code></pre></div></div></figure> 你需要先使用<code>git log</code> 命令找到初始提交的哈希值，然后使用<code>git reset --hard</code>命令将当前分支重置到该提交，丢弃所有后续的提交和修改。<p></p></li><li><p><strong><code>4-&gt;0</code>（已 <code>push</code>后回到初始状态，不保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 本地操作</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--hard</span><span style="color: #ABB2BF"> [初始提交的哈希值]</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 强制推送到远程仓库</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [分支名]</span></span></code></pre></div></div></figure> 先在本地使用<code>git reset --hard</code> 回到初始提交，然后使用<code>git push -f</code>强制将本地的修改推送到远程仓库，覆盖远程仓库的历史记录。<p></p></li><li><p><strong><code>2-&gt;1</code>（已 <code>add</code>后回到修改后状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.</span></span></code></pre></div></div></figure>该命令会将暂存区的所有文件撤回到工作区，保留工作区的修改。<p></p></li><li><p><strong><code>3-&gt;1</code>（已 <code>commit</code>后回到修改后状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--mixed</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span></code></pre></div></div></figure><code>git reset --mixed HEAD~1</code>会撤销上一次提交，将提交的内容放回暂存区，同时保留工作区的修改。<p></p></li><li><p><strong><code>4-&gt;1</code>（已 <code>push</code>后回到修改后状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 本地操作</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--mixed</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 撤销远程仓库的推送</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [分支名]</span></span></code></pre></div></div></figure> 先在本地使用<code>git reset --mixed HEAD~1</code>撤销上一次提交并将内容放回暂存区，然后使用 <code>git push -f</code>强制推送到远程仓库，撤销远程仓库的推送。<p></p></li><li><p><strong><code>3-&gt;2</code>（已 <code>commit</code> 后回到已<code>add</code> 状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--soft</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span></code></pre></div></div></figure> 同样使用<code>git reset --soft HEAD~1</code>撤销上一次提交，将提交的内容放回暂存区。<p></p></li><li><p><strong><code>4-&gt;2</code>（已 <code>push</code> 后回到已<code>add</code> 状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 本地操作</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--soft</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 撤销远程仓库的推送</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [分支名]</span></span></code></pre></div></div></figure> 与<code>4-&gt;1</code>类似，先在本地撤销提交并将内容放回暂存区，然后强制推送到远程仓库撤销推送。<p></p></li><li><p><strong><code>4-&gt;3</code>（已 <code>push</code> 后回到已<code>commit</code> 状态，保留修改）</strong> </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #7F848E; font-style: italic"># 本地回退到上一个提交</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">reset</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--hard</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~1</span></span><span class="line"><span style="color: #7F848E; font-style: italic"># 强制推送到远程仓库</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [分支名]</span></span></code></pre></div></div></figure> 先在本地使用<code>git reset --hard HEAD~1</code> 回退到上一个提交，然后使用<code>git push -f</code>强制推送到远程仓库，使远程仓库也回到上一个提交状态。<p></p></li></ol><h2 id="总结">总结</h2><table><thead><tr><th>状态转换</th><th>指令</th></tr></thead><tbody><tr><td>1-&gt;0</td><td><code>git checkout -- .</code></td></tr><tr><td>2-&gt;0</td><td><code>git reset --hard HEAD</code></td></tr><tr><td>3-&gt;0</td><td><code>git reset --hard [初始提交的哈希值]</code></td></tr><tr><td>4-&gt;0</td><td><code>git reset --hard [初始提交的哈希值]</code> &amp;&amp;<code>git push -f origin [分支名]</code></td></tr><tr><td>2-&gt;1</td><td><code>git reset HEAD .</code></td></tr><tr><td>3-&gt;1</td><td><code>git reset --mixed HEAD~1</code></td></tr><tr><td>4-&gt;1</td><td><code>git reset --mixed HEAD~1</code> AND<code>git push -f origin [分支名]</code></td></tr><tr><td>3-&gt;2</td><td><code>git reset --soft HEAD~1</code></td></tr><tr><td>4-&gt;2</td><td><code>git reset --soft HEAD~1</code> AND<code>git push -f origin [分支名]</code></td></tr><tr><td>4-&gt;3</td><td><code>git reset --hard HEAD~1</code> AND<code>git push -f origin [分支名]</code></td></tr></tbody></table><h1 id="取消跟踪">取消跟踪</h1><p>要停止跟踪已推送到远程仓库的文件，同时保留本地文件并从远程仓库删除它们，可以按照以下步骤操作：</p><ol type="1"><li><strong>确认 <code>.gitignore</code> 文件配置</strong><br>确保 <code>.gitignore</code>文件中已正确添加要忽略的文件或目录路径。例如： <figure class="shiki txt"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf"># .gitignore</span></span><span class="line"><span style="color: #abb2bf">ignore_file.txt</span></span><span class="line"><span style="color: #abb2bf">ignore_dir/</span></span></code></pre></div></div></figure></li><li><strong>停止本地仓库跟踪这些文件</strong><br>使用 <code>git rm --cached</code>命令删除文件的跟踪状态（保留本地文件）： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">rm</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--cached</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">ignore_file.txt</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">rm</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--cached</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-r</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">ignore_dir/</span><span style="color: #ABB2BF">  </span><span style="color: #7F848E; font-style: italic"># 递归删除目录</span></span></code></pre></div></div></figure></li><li><strong>提交更改</strong> 将修改后的 <code>.gitignore</code>和文件删除操作提交到本地仓库： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.gitignore</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">commit</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-m</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Stop tracking ignored files"</span></span></code></pre></div></div></figure></li><li><strong>推送到远程仓库</strong><br>将提交推送到远程仓库，同步删除操作： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [branch-name]</span></span></code></pre></div></div></figure></li></ol><h1 id="子模块">子模块</h1><p>子模块是 Git 中的一种机制，用于在一个 Git 仓库中嵌套另一个 Git仓库。它允许你将一个独立的 Git 仓库作为另一个仓库的子目录来管理。 1.子仓库的创建（正常创建） </p><figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #56B6C2">cd</span><span style="color: #ABB2BF"> [path_to_submodule]</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">init</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">remote</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [submodule-repository-url]</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-u</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">master</span></span></code></pre></div></div></figure> 2. 在主仓库中添加子模块<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">submodule</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> [repository-url] [path-to-submodule]</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">add</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">.gitmodules</span><span style="color: #ABB2BF"> [path-to-submodule]</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">commit</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-m</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"Add submodule"</span></span><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span></span></code></pre></div></div></figure><p></p><h1 id="修改commit信息">修改commit信息</h1><ol type="1"><li>要修改最近一次提交的 commit 信息，可以使用以下命令：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">commit</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">--amend</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-m</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">"New commit message"</span></span></code></pre></div></div></figure></li><li>如果需要修改更早的提交，可以使用 <code>rebase</code> 命令：<figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">rebase</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-i</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">HEAD~n</span></span></code></pre></div></div></figure> 在编辑器中，将需要修改的提交前的 <code>pick</code> 改为<code>reword</code>，然后保存并退出编辑器。接下来，Git会提示修改提交信息，修改后保存并退出编辑器即可。</li><li>如果需要修改远程仓库中的提交信息，可以使用 <code>push</code>命令强制推送： <figure class="shiki bash"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #61AFEF">git</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">push</span><span style="color: #ABB2BF"> </span><span style="color: #D19A66">-f</span><span style="color: #ABB2BF"> </span><span style="color: #98C379">origin</span><span style="color: #ABB2BF"> [branch-name]</span></span></code></pre></div></div></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>习近平新时代中国特色社会主义思想概论</title>
    <link href="/posts/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3%E6%A6%82%E8%AE%BA/"/>
    <url>/posts/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>魏旭老师</em> 2023-2024学年春季学期教学内容进行整理</p></blockquote><h1 id="导论-马克思主义中国化时代化新的飞跃">导论马克思主义中国化时代化新的飞跃</h1><h2 id="习近平新时代中国特色社会主义思想是如何创立的">※习近平新时代中国特色社会主义思想是如何创立的</h2><ol type="1"><li><strong>时代背景</strong>：“两个大局”同步交织、相互激荡<ul><li>“两个大局”：世界百年未有之大变局、实现中华民族伟大复兴战略全局</li><li>习近平新时代中国特色社会主义思想正是在中华民族伟大复兴进入关键时期创立并不断丰富发展的，正是在把握世界发展大势、应对全球共同挑战、维护人类共同利益的过程中创立并不断丰富发展的，正是在不断回答中国之问、世界之问、人民之问、时代之问的过程中创立并不断丰富发展的。</li></ul></li><li><strong>历史方位</strong>：中国特色社会主义进入新时代<ul><li>基本依据：社会主要矛盾变化——我国社会主要矛盾已经转化为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</li><li>中国特色社会主义进入新时代，这是一个需要理论而且一定能够产生理论的时代，是一个需要思想而且一定能够产生思想的时代。习近平新时代中国特色社会主义思想正是在这样的伟大时代中应运而生、顺势而成的。</li></ul></li><li>实践基础:历史性成就、历史性变革<ul><li>习近平新时代中国特色社会主义思想是在新时代的伟大实践中应运而生、顺势而成的。</li></ul></li><li>必由之路：“两个结合”<ul><li>坚持把马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合</li><li>习近平新时代中国特色社会主义思想正是在不断推进马克思主义中国化时代化，在坚持马克思主义基本原理同中国具体实际相结合、同中华优秀传统文化相结合中创立并不断丰富发展的。</li></ul></li></ol><h2 id="习近平新时代中国特色社会主义思想主要包含哪些内容">※习近平新时代中国特色社会主义思想主要包含哪些内容</h2><ol type="1"><li>重大时代课题<ul><li>讲的是方向性质问题：新时代坚持和发展什么样的中国特色社会主义、怎样坚持和发展中国特色社会主义</li><li>讲的是目标路径问题：建设什么样的社会主义现代化强国、怎样建设社会主义现代化强国</li><li>讲的是力量保证问题：建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党</li></ul></li><li>基本内容（科学体系：世界观和方法论）<ul><li>“十个明确”</li><li>“十四个坚持”</li><li>“十三个方面成就”</li><li>“六个必须坚持”</li></ul></li></ol><h2 id="如何理解习近平新时代中国特色社会主义思想的历史地位">※如何理解习近平新时代中国特色社会主义思想的历史地位</h2><ol type="1"><li>是当代中国马克思主义、二十一世纪马克思主义<ul><li>这一思想把坚持马克思主义和发展马克思主义统一起来，对马克思主义作出了许多原创性贡献，开辟了马克思主义中国化时代化新境界。</li></ul></li><li>是中华文化和中国精神的时代精华<ul><li>这一思想汲取中华优秀传统文化所蕴含的丰富哲学思想、人文精神、道德理念和政治智慧，有效激活了中华优秀传统文化的生命力，实现了中华优秀传统文化的创造性转化、创新性发展。</li></ul></li><li>是马克思主义中国化时代化新的飞跃<ul><li>这一思想深刻总结并充分运用党成立以来的历史经验，从新的实际出发，提出了一系列原创性的治国理政新理念新思想新战略，以全新的视野深化了对共产党执政规律、社会主义建设规律、人类社会发展规律的认识，实现了马克思主义中国化时代化新的飞跃。</li></ul></li></ol><h2 id="两个确立">两个确立</h2><ol type="1"><li>确立习近平同志党中央的核心、全党的核心地位</li><li>确立习近平新时代中国特色社会主义思想的指导地位</li></ol><p>“两个确立”是推动新时代党和国家事业取得历史性成就、发生历史性变革的根本原因，是实现新时代新征程各项目标任务的根本保证。</p><h2 id="如何学好用好习近平新时代中国特色社会主义思想">※如何学好用好习近平新时代中国特色社会主义思想</h2><ol type="1"><li>坚定理想信念<ul><li>学习习近平新时代中国特色社会主义思想，就是要深刻领会这一思想的真理力量和实践伟力，坚定对马克思主义的信仰、对中国特色社会主义的信念、对实现中华民族伟大复兴中国梦的信心。</li></ul></li><li>提高理论水平<ul><li>要把学习本课程与坚持读原著、学原文、悟原理结合起来，同学习马克思主义基本原理贯通起来，同学习党史、新中国史、改革开放史、社会主义发展史、中华民族发展史结合起来。</li></ul></li><li>增强实践能力<ul><li>要密切联系思想实际和学习实际，做到学以致用、学用结合、有的放矢。</li></ul></li></ol><h1 id="第一章-新时代坚持和发展中国特色社会主义">第一章新时代坚持和发展中国特色社会主义</h1><h2 id="中国特色社会主义如何一路走来">中国特色社会主义如何一路走来</h2><ol type="1"><li>道路决定命运<ul><li>走自己的路，是党的全部理论和实践立足点，更是党百年奋斗得出的历史结论。</li></ul></li><li>近代以来中国社会发展的必然选择<ul><li>中国共产党在革命、建设、改革各个历史时期，都探索并形成了符合中国实际的道路。</li></ul></li></ol><h2 id="如何理解中国特色社会主义是社会主义而不是其他什么主义">如何理解中国特色社会主义是社会主义而不是其他什么主义</h2><ol type="1"><li>坚持了科学社会主义基本原则<ul><li>科学社会主义基本原则为中国特色社会主义奠定了思想前提和理论基础</li></ul></li><li>赋予科学社会主义鲜明中国特色<ul><li>中国特色社会主义写出了科学社会主义的“中国特色”</li></ul></li></ol><h2 id="为什么说中国特色社会主义进入了新时代">※为什么说中国特色社会主义进入了新时代</h2><ol type="1"><li><strong>基本依据</strong>：社会主要矛盾的转化<ul><li>人类社会是在矛盾运动中不断向前发展的。社会主要矛盾是各种社会矛盾的主要根源和集中反映，在社会矛盾运动中居于主导地位。</li></ul></li><li>社会主要矛盾变化是关系全局的历史性变化<ul><li>主要矛盾的变化，反映了社会发展的客观实际——需求侧和供给侧的问题</li></ul></li><li>社会主要矛盾变化没有改变我国社会主义初级阶段的基本国情<ul><li>我国社会主要矛盾的变化，是在社会主义初级阶段中发生的变化，没有改变我们对我国社会主义所处历史阶段的判断。</li><li>“一个变”和“两个没有变”：社会主要矛盾变化，我国仍处于并将长期处于社会主义初级阶段的基本国情没有变，我国是世界上最大发展中国家的地位没有变。</li></ul></li></ol><h2 id="新时代坚持和发展中国特色社会主义如何一以贯之">新时代坚持和发展中国特色社会主义如何一以贯之</h2><ol type="1"><li>更加自觉地坚定“四个自信”<ul><li>改革开放以来，我们取得一切成绩和进步的根本原因，归结起来就是：开辟了中国特色社会主义道路，形成了中国特色社会主义理论，确立了中国特色社会主义制度，发展了中国特色社会主义文化。</li></ul></li><li>全面贯彻党的基本理论、基本路线、基本方略</li><li>统筹推进“五位一体”总体布局和协调推进“四个全面”战略布局<ul><li>经济建设是中心；政治建设是保障；文化建设是灵魂；社会建设是条件；生态文明建设是基础</li><li>党的十八届三中、四中、五中、六中全会相继提出全面深化改革、全面依法治国、全面建成小康社会、全面从严治党。决胜全面建成小康社会后，提出全面建设社会主义现代化国家。</li></ul></li></ol><h1 id="第二章-以中国式现代化全面推进中华民族伟大复兴">第二章以中国式现代化全面推进中华民族伟大复兴</h1><h2 id="为什么说实现中华民族伟大复兴进入了不可逆转的历史进程">为什么说实现中华民族伟大复兴进入了不可逆转的历史进程</h2><ol type="1"><li>实现中华民族伟大复兴是中华民族近代以来最伟大的梦想<ul><li>中国梦的本质是<strong>国家富强、民族振兴、人民幸福</strong>。</li></ul></li><li>实现中华民族伟大复兴是党百年奋斗的主题</li><li>中华民族伟大复兴展现出前所未有的光明前景<ul><li>1921-1949实现了中国从几千年封建专制政治向人民民主的伟大飞跃，中国人民从此站起来了</li><li>1949-1978实现了一穷二白、人口众多的东方大国大步迈进社会主义社会的伟大飞跃</li><li>1978-2012推进了中华民族从站起来到富起来的伟大飞跃，中国大踏步赶上了时代</li><li>2012— 中华民族迎来了从站起来、富起来到强起来的伟大飞跃</li></ul></li><li>实现中华民族伟大复兴的艰巨性、复杂性和长期性<ul><li>形势环境变化之快；改革发展稳定任务之重；矛盾风险挑战之多；治国理政考验之大</li></ul></li></ol><h2 id="如何擘画全面建成社会主义现代化强国的宏伟蓝图">如何擘画全面建成社会主义现代化强国的宏伟蓝图</h2><ol type="1"><li>全面建成小康社会<ul><li>全面建成小康社会是实现中华民族伟大复兴中国梦的关键一步。</li><li>为了实现中国梦，我们确立了“两个一百年”奋斗目标，就是到2020年实现国内生产总值和城乡居民人均收入比2010年翻一番，全面建成小康社会；到本世纪中叶建成富强民主文明和谐美丽的社会主义现代化国家，实现中华民族伟大复兴。</li></ul></li><li>全面建成社会主义现代化强国<ul><li>建成社会主义现代化强国的战略安排（党的二十大）：<ul><li>第一步 从2020年到2035年基本实现社会主义现代化；</li><li>第二步从2035年到本世纪中叶把我国建成富强民主文明和谐美丽的社会主义现代化国家。</li></ul></li></ul></li><li>中国式现代化是强国建设、民族复兴的康庄大道</li></ol><h2 id="中国式现代化是一种什么样的现代化">※中国式现代化是一种什么样的现代化</h2><ol type="1"><li>中国式现代化的中国特色<ul><li>中国式现代化，是中国共产党领导的社会主义现代化，既有各国现代化的共同特征，更有基于自己国情的中国特色。</li><li><strong>人口规模巨大的现代化</strong>：是中国式现代化的显著特征。</li><li><strong>全体人民共同富裕的现代化</strong>：是中国式现代化的本质特征，也是区别于西方现代化的显著标志。</li><li><strong>物质文明和精神文明相协调的现代化</strong>：</li><li><strong>人与自然和谐共生的现代化</strong>：是中国式现代化的鲜明特点</li><li><strong>走和平发展道路的现代化</strong>：是中国式现代化的突出特征。</li></ul></li><li><strong>中国式现代化的本质要求</strong><ul><li>坚持中国共产党领导，坚持中国特色社会主义，实现高质量发展，发展全过程人民民主，丰富人民精神世界，实现全体人民共同富裕，促进人与自然和谐共生，推动构建人类命运共同体，创造人类文明新形态。</li><li>中国式现代化是中国共产党领导的社会主义现代化。这是对中国式现代化定性的话，是管总、管根本的。</li></ul></li><li>中国式现代化创造了人类文明新形态<ul><li>中国式现代化，打破了“现代化=西方化”的迷思，展现了不同于西方现代化的新图景。中国式现代化，提供了一种全新的现代化模式，为广大发展中国家提供了全新选择。</li></ul></li><li>推进中国式现代化需要把握的重大原则<ul><li>坚持和加强党的全面领导</li><li>坚持中国特色社会主义道路</li><li>坚持以人民为中心的发展思想</li><li>坚持深化改革开放</li><li>坚持发扬斗争精神</li></ul></li></ol><h1 id="第三章-坚持党的领导">第三章 坚持党的领导</h1><h2 id="为什么要坚持党的领导">※为什么要坚持党的领导</h2><ol type="1"><li>中国共产党是最高政治领导力量<ul><li>这是由我国国家性质和政治制度体系决定的，是由国家宪法所确立的，是经过中国革命、建设、改革伟大实践所检验的。</li><li>党是最高政治领导力量，主要体现在引领政治方向、统领政治体系、决断重大事项、领导社会治理等方面。</li></ul></li><li>中国共产党领导是中国特色社会主义最本质的特征<ul><li><strong>中国特色社会主义最本质的特征是中国共产党领导</strong></li></ul></li><li><strong>中国共产党领导是中国特色社会主义制度的最大优势</strong><ul><li>中国共产党领导是充分发挥中国特色社会主义制度优势的根本保障</li><li>中国共产党的自身优势是中国特色社会主义制度优势的主要来源</li><li>中国共产党能够集中全党全国力量、凝聚全民族共同意志，在各项事业中发挥总总揽全局、协调各方的作用，确保中国特色社会主义制度的显著优势充分彰显。</li></ul></li></ol><h2 id="怎样理解党的领导是全面的系统的整体的">怎样理解党的领导是全面的、系统的、整体的</h2><ol type="1"><li>党的领导是全面的<ul><li>领导对象要全面覆盖；领导内容要全面；领导过程要全面；领导方法要全面</li></ul></li><li>党的领导是系统的<ul><li>党的领导制度是我国的根本领导制度，居于统领地位。</li></ul></li><li>党的领导是整体的<ul><li>从党的中央组织到地方组织再到基层组织，都要按照党章的规定发挥应有作用，党的领导作用要体现到治国理政的全过程，领导功能的发挥要完整。</li></ul></li></ol><h2 id="怎样实现党的全面领导">怎样实现党的全面领导</h2><ol type="1"><li>自觉在思想上政治上行动上同党中央保持高度一致<ul><li>从思想上正本清源、固本培元，不断提高政治判断力、政治领悟力、政治执行力，增强“四个意识”、坚定“四个自信”、做到“两个维护”，始终在思想上政治上行动上同党中央保持高度一致征。</li><li>“<strong>四个意识</strong>”：政治意识、大局意识、核心意识、看齐意识</li><li>“<strong>两个维护</strong>”：<ul><li>坚决维护习近平总书记党中央的核心、全党的核心地位；</li><li>坚决维护党中央权威和集中统一领导（这是党的领导的最高原则）。</li></ul></li></ul></li><li>健全和完善党的领导制度体系<ul><li>健全党中央对重大工作的领导体制</li><li>健全党的全面领导制度</li></ul></li></ol><h1 id="第四章-坚持以人民为中心">第四章 坚持以人民为中心</h1><h2 id="为什么必须坚持以人民为中心">为什么必须坚持以人民为中心</h2><ol type="1"><li>人民是创造历史的动力<ul><li>人民是历史的创造者，是真正的影响</li><li>党的历史伟业是人民创造的</li></ul></li><li>江山就是人民、人民就是江山<ul><li>我国的政权是人民的政权</li></ul></li><li>党依靠人民创造历史伟业<ul><li>党依靠人民夺取新民主主义革命伟大胜利</li><li>党依靠人民完成社会主义革命和推进社会主义建设</li><li>党依靠人民进行改革开放和社会主义现代化建设</li><li>党依靠人民开创中国特色社会主义新时代</li></ul></li><li>人民是党的工作的最高裁决者和最终评判者</li></ol><h2 id="如何理解不断实现人民对美好生活的向往">如何理解不断实现人民对美好生活的向往</h2><ol type="1"><li>人民立场是中国共产党的根本政治立场<ul><li>人民立场是马克思主义政党区别于资产阶级政党的显著标志</li><li>全心全意为人民服务是党的根本宗旨</li><li>党性和人民性是高度一致的</li></ul></li><li>为中国人民谋幸福是中国共产党的初心<ul><li>为中华民族谋复兴（使命）、为中国人民谋幸福（初心），是中国共产党的初心使命</li></ul></li><li>人民对美好生活的向往就是党的奋斗目标<ul><li>人民对美好生活的新期待：进入新时代，人民美好生活需要日益广泛，不仅对物质文化生活提出了更高要求，而且在民主、法治、公平、正义、安全、环境等方面的要求日益增长。</li></ul></li></ol><h2 id="怎样实现人的全面发展全体人民共同富裕">※怎样实现人的全面发展、全体人民共同富裕</h2><ol type="1"><li>坚持和贯彻党的群众路线<ul><li>党的群众路线：坚持一切为了群众，一切依靠群众，从群众中来，到群众中去</li><li>群众路线始终是党的生命线和根本工作路线</li><li>调查研究是贯彻群众路线的有效途径</li></ul></li><li>把为人民造福的事情真正办好办实<ul><li>为人民造福，要落实到新时代中国特色社会主义的各项事业、全部工作之中</li><li>为人民造福，要着力解决好人民群众最关心最直接最现实的利益问题</li><li>为人民造福，要一件事情接着一件事办，一年接着一年干。</li></ul></li><li>推动全体人民共同富裕取得更为明显的实质性进展<ul><li>共同富裕是社会主义的本质要求，是中国式现代化的重要特征。我们说的共同富裕是全体人民共同富裕，是人民群众物质生活和精神生活都富裕，不是少数人的富裕，也不是整齐划一的平均主义。要处理好先富和共富的关系，允许一部分人先富起来，同时积极推动先富带后富。</li><li>扎实推动共同富裕的总体思路:坚持以人民为中心的发展思想，在高质量发展中促进共同富裕，正确处理效率和公平的关系，构建初次分配、再分配、三次分配协调配套的基础性制度安排，加大税收、社保、转移支付等调节力度并提高精准性，扩大中等收入群体比重，增加低收入群体收入，合理调节高收入，取缔非法收入，形成中间大、两头小的橄榄型分配结构，促进社会公平正义，促进人的全面发展，使全体人民朝着共同富裕目标扎实迈进。</li><li>扎实推进共同富裕的基本原则：鼓励勤劳创新致富；坚持基本经济制度；尽力而为量力而行；坚持循序渐进</li></ul></li></ol><h1 id="第五章-全面深化改革开放">第五章 全面深化改革开放</h1><h2 id="为什么要全面深化改革开放">为什么要全面深化改革开放</h2><ol type="1"><li>改革开放是我们前进的重要法宝<ul><li>中国共产党作出实行改革开放的历史性决策，是基于对党和国家前途命运的深刻把握、基于对社会主义革命和建设实践的深刻总结、基于对时代潮流的深刻洞察、基于对人民群众期盼和需要的深刻体悟。</li></ul></li><li>改革进入攻坚期和深水区<ul><li>必须勇于破除一切不合时宜的思维定势和固有观念</li><li>必须勇于打破部门利益、行业利益、本位思想</li><li>必须勇于跳出条条框框限制，破除深层次体制机制障碍和顽瘴痼疾</li><li>必须勇于破解我国开放型经济体制建设中的突出问题，积极适应经济全球化新趋势、世界格局新变化和我国发展新要求</li></ul></li></ol><h2 id="怎样推进全面深化改革开放">※怎样推进全面深化改革开放</h2><ol type="1"><li>坚持全面深化改革总目标<ul><li><strong>完善和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化</strong><ul><li>前者规定了改革的方向，后者明确了改革的鲜明指向和时代要求</li></ul></li><li>全面深化改革分目标：“六个紧紧围绕着”，规定了各领域各方面改革的主要任务</li></ul></li><li>推进国家治理体系和治理能力现代化<ul><li>新时代全面深化改革开放，就是要使中国特色社会主义制度更加成熟更加定型，推进国家治理体系和治理能力现代化。</li><li>国家治理体系和治理能力是一个国家制度和制度执行能力的集中体现；</li><li>推进国家治理体系和治理能力现代化，必须坚定中国特色社会主义制度自信；</li><li>推进国家治理体系和治理能力现代化，必须把中国特色社会主义制度优势转化为治理效能</li></ul></li><li>全面深化改革开放要坚持正确方法论<ul><li>增强全面深化改革的系统性、整体性、协同性</li><li>加强顶层设计和摸着石头过河相结合</li><li>统筹改革发展稳定。改革是经济社会发展的强大动力；发展是解决一切经济社会问题的关键；稳定是改革发展的前提</li><li>胆子要大，步子要稳。</li><li>坚持重大改革于法有据。（改革和法治如鸟之两翼、车之两轮、相辅相成）</li></ul></li></ol><h2 id="如何将改革开放进行到底">如何将改革开放进行到底</h2><ol type="1"><li>改革开放永无止境<ul><li>生产力发展是永无止境的，调整生产关系、完善上层建筑的改革开放的改革也是永无止境的</li><li>改革开放永无止境是总结世界社会主义实践经验得出的重要结论</li><li>改革开放永无止境是推进党和人民事业发展的必然要求</li></ul></li><li>坚定不移把全面深化改革引向深入<ul><li>围绕中心任务；把准改革方向；围绕目标</li><li>要聚焦全面建设社会主义现代化国家中的重大问题，抓好重大改革任务攻坚克难</li></ul></li><li>坚定不移扩大高水平对外开放<ul><li>开放合作仍然是历史潮流</li><li>继续扩大对外开放，构建更高水平开放型经济新体制</li></ul></li></ol><h1 id="第六章-推动高质量发展">第六章 推动高质量发展</h1><h2 id="如何完整准确全面贯彻新发展理念">※如何完整、准确、全面贯彻新发展理念</h2><ol type="1"><li>进入新发展阶段是中华民族伟大复兴历史进程的大跨越<ul><li><strong>新发展阶段就是全面建设社会主义现代化国家、向第二个百年奋斗目标进军的阶段。</strong></li><li>我国进入新发展阶段的基本依据：<ul><li>理论依据：马克思主义是远大理想和现实目标相结合、历史必然性和发展阶段性相统一的统一论者，我们坚信人类社会必然走向共产主义，但实现这一崇高目标必然经历若干历史阶段。</li><li>历史依据：新发展阶段是我们党带领人民迎来从站起来、富起来到强起来历史性跨越的新阶段。</li><li>现实依据：我们已经拥有开启新征程、实现新的更高目标的雄厚物质基础。</li></ul></li><li><strong>新发展阶段，是社会主义初级阶段中的一个阶段，是全面建设社会主义现代化国家的阶段</strong></li></ul></li><li>贯彻新发展理念是关系我国发展全局的一场深刻变革<ul><li>新发展理念是新时代我国经济发展的指导原则，回答了关于发展的目的、动力、方式、路径等一系列理论和实践问题，阐明了我们党关于发展的政治立场、价值导向、发展模式、发展道路等重大政治问题。</li><li>创新注重解决发展动力问题；协调注重解决发展不平衡问题；绿色注重解决人与自然和谐共生问题；开放注重解决发展内外联动问题；共享注重解决社会公平正义问题</li><li>为人民谋幸福、为民族谋复兴，这既是我们党领导现代化建设的出发点和落脚点，也是新发展理念的“根”和“魂”。</li></ul></li><li>以新发展理念引领高质量发展<ul><li>高质量发展：是从“有没有”转向“好不好”；是能够很好满足人民日益增长的美好生活需要的发展；是体现新发展理念的发展。</li><li>高质量发展是全面建设社会主义现代化国家的首要任务</li><li>推动高质量发展的必要性：推动高质量发展是保持经济持续健康发展的必然要求；推动高质量发展是适应我国社会主要矛盾变化的必然要求；推动高质量发展是遵循经济发展规律的必然要求</li></ul></li></ol><h2 id="如何坚持和完善社会主义基本经济制度">如何坚持和完善社会主义基本经济制度</h2><ol type="1"><li>坚持和完善社会主义基本经济制度是实现高质量发展的保障</li><li>坚持“两个毫不动摇”<ul><li>毫不动摇巩固和发展公有制经济；毫不动摇鼓励、支持、引导非公有制经济发展</li></ul></li><li>坚持按劳分配为主体、多种分配方式并存<ul><li>按劳分配为主体、多种分配方式并存，构建初次分配、再分配、第三次分配协调配套的制度体系</li></ul></li><li>构建高水平社会主义市场经济体制<ul><li>关键是要处理好政府和市场的关系</li><li>正确认识和把握资本的特性和行为规律</li></ul></li></ol><h2 id="如何加快构建新发展格局">※如何加快构建新发展格局</h2><ol type="1"><li>把握未来发展主动权的战略性布局<ul><li>加快构建以国内大循环为主体、国内国际双循环相互促进的新发展格局</li><li>构建新发展格局的本质特征：实现高水平的自立自强</li></ul></li><li>以国内大循环为主体、国内国际双循环相互促进<ul><li>构建新发展格局涉及我国经济发展的各个方面、各个领域，要准确把握基本要求，加强整体协调和系统布局，推动国内循环和国际循环相互促进、良性互动。</li><li>加快构建新发展格局，要从两个维度来研究和布局：一是更有针对性地加快补上我国产业链供应链短板弱项，确保国民经济循环畅通；二是提升国内大循环内生动力和可靠性，提高国际竞争力，增强对国际循环的吸引力、推动力。</li></ul></li><li>大力推动构建新发展格局<ul><li>增强供给侧结构对需求变化的适应性、灵活性（供给侧重在解决结构性问题；需求侧重在解决总量性问题）</li><li>把握扩大内需战略基点：加快培育完整内需体系</li></ul></li></ol><h1 id="第七章-社会主义现代化建设的教育科技人才战略">第七章社会主义现代化建设的教育、科技、人才战略</h1><h2 id="为什么要坚持教育科技人才一体推进">为什么要坚持教育、科技、人才一体推进</h2><ol type="1"><li>高度重视教育、科技、人才是历史的经验</li><li>实施科教兴国战略、人才强国战略、创新驱动发展战略是时代的需要</li><li>坚持教育优先发展、科技自立自强、人才引领驱动是中国式现代化的必然选择<ul><li>教育是全面建设社会主义现代化国家的坚实基础；科技是全面建设社会主义现代化国家的强大动力；人才是全面建设社会主义现代化国家的有力支撑</li></ul></li></ol><h2 id="怎样加快建设教育强国">怎样加快建设教育强国</h2><ol type="1"><li>推进教育现代化</li><li>落实立德树人根本任务</li><li>办好人民满意的教育<ul><li>大力促进教育公平</li><li>必须建设高质量教育体系</li><li>提升教育服务经济社会发展能力</li><li>坚持深化教育改革创新</li><li>坚持把教师队伍建设作为基础工作</li></ul></li></ol><h2 id="怎样加快建设科技强国">※怎样加快建设科技强国</h2><ol type="1"><li>科技强则国家强<ul><li>要大力发展科学技术，加快实现高水平科技自立自强，努力成为世界主要科学中心和创新高地。<br></li></ul></li><li>打赢关键核心技术攻坚战<ul><li>原因：只有把关键核心技术掌握在自己手中，才能从根本上保障国家经济安全、国防安全和其他安全，才能真正掌握竞争和发展的主动权。</li><li>打赢关键核心技术攻坚战，<strong>首要任务是加快实现“卡脖子”关键核心技术突破</strong></li></ul></li><li>增强自主创新能力<ul><li>增强自主创新能力，着力推进基础研究、应用研究、前沿研究</li></ul></li></ol><h2 id="如何深入实施新时代人才强国战略">如何深入实施新时代人才强国战略</h2><ol type="1"><li>人才是国家和民族长远发展大计<ul><li>人才是创新的根基是创新的核心要素</li></ul></li><li>坚持党管人才<ul><li>坚持党对人才工作的全面领导；深化人才发展体制机制改革；全方位培养用好人才</li></ul></li><li>加快建设世界人才中心和创新高地<ul><li>做好顶层设计和战略谋划；走好人才自主培养之路；抓好国家战略人才力量</li></ul></li></ol><h1 id="第八章-发展全过程人民民主">第八章 发展全过程人民民主</h1><h2 id="什么是全过程人民民主">※什么是全过程人民民主</h2><ol type="1"><li><strong>全过程人民民主是社会主义民主政治的本质属性</strong><ul><li>人民当家作主是社会主义民主政治的本质和核心，是发展全过程人民民主的根本出发点和归宿。</li><li>全过程人民民主展现出的过程民主和成果民主、程序民主和实质民主、直接民主和间接民主、人民民主和国家意志相统一的鲜明特征，充分体现了社会主义民主政治的本质属性。</li></ul></li><li>全过程人民民主是全链条、全方位、全覆盖的民主<ul><li>全过程人民民主是民主选举、民主协商、民主决策、民主管理、民主监督各个环节紧密联系、相互贯通、相辅相成的全链条民主；</li><li>全过程人民民主是贯通国家政治生活和社会生活各层面各维度的全方位民主；</li><li>全过程人民民主是涵盖国家各项事业各项工作的全覆盖民主。</li></ul></li></ol><h2 id="全过程人民民主好在哪里">※全过程人民民主好在哪里</h2><ol type="1"><li>全过程人民民主是最广泛的民主<ul><li>全过程人民民主是全体人民共同持续参与，各个民族共同平等享有，不同地域、不同领域、不同层级、不同群体均实现全面覆盖的民主体系，是最广泛的民主。</li></ul></li><li>全过程人民民主是最真实的民主<ul><li>全过程人民民主是真真切切落实到国家政治生活和社会生活各方面、为全体人民真真切切感知和认同的民主体系，是最真实的民主。</li></ul></li><li>全过程人民民主是最管用的民主<ul><li>全过程人民民主体现了社会主义民主的优势，具有显著的实践优越性，是最管用的民主。</li></ul></li></ol><h2 id="如何践行全过程人民民主">如何践行全过程人民民主</h2><ol type="1"><li>坚定不移走中国特色社会主义政治发展道路<ul><li>必须坚持党的领导、人民当家作主、依法治国有机统一；必须积极稳妥推进政治体制改革；必须始终保持政治定力</li></ul></li><li>加强人民当家作主制度保障</li><li>全面发展协商民主</li><li>积极发展基层民主</li><li>巩固和发展新时代爱国统一战线</li></ol><h1 id="第九章-全面依法治国">第九章 全面依法治国</h1><h2 id="为什么要全面推进依法治国">※为什么要全面推进依法治国</h2><ol type="1"><li>法治是社会文明进步的重要标志</li><li>全面依法治国是国家治理现代化的必然要求　<ul><li>全面依法治国是坚持和发展中国特色社会主义制度、推进国家治理体系和治理能力现代化的重要方面。</li><li>全面依法治国是社会主义法治建设的“全面升级版”，是国家治理的一场深刻革命。</li><li>全面依法治国是解决党和国家事业发展面临的重大问题、促进社会公平正义、确保党和国家长治久安的根本要求。</li><li>全面依法治国，既是立足于解决事关我国发展大局的现实考量，也是着眼于长远的战略谋划。</li></ul></li><li>在法治轨道上全面建设社会主义现代化国家<ul><li>要深入贯彻习近平法治思想，坚持党的领导、人民当家作主、依法治国有机统一，更好发挥法治固根本、稳预期、利长远的保障作用，为全面建设社会主义现代化国家保驾护航。</li></ul></li></ol><h2 id="为什么要走中国特色社会主义法治道路">※为什么要走中国特色社会主义法治道路</h2><ol type="1"><li>全面依法治国必须走对路<ul><li>中国特色社会主义法治道路，从根本上保证了我国社会主义法治建设的正确方向，是全面依法治国的唯一正确道路</li></ul></li><li>中国特色社会主义法治道路的核心要义<ul><li>坚持党的领导，坚持中国特色社会主义制度，贯彻中国特色社会主义法治理论</li></ul></li><li>走中国特色社会主义法治道路必须坚持的基本原则<ul><li>坚持党的领导是中国特色社会主义法治之魂；坚持人民主体地位；坚持法律面前人人平等；坚持依法治国和以德治国相结合；坚持从中国实际出发</li></ul></li><li>统筹处理全面依法治国的重大关系<ul><li>正确处理政治和法治的关系；正确处理改革和法治的关系；正确处理依法治国和以德治国的关系；正确处理依法治国和依规治党的关系。</li></ul></li></ol><h2 id="如何理解全面依法治国的总目标">如何理解全面依法治国的总目标</h2><ol type="1"><li>全面依法治国的总抓手<ul><li>全面推进依法治国涉及很多方面，在实际工作中必须有一个总揽全局、牵引各方的总抓手，这个总抓手就是建设中国特色社会主义法治体系。依法治国各项工作都要围绕这个总抓手来谋划、来推进。</li></ul></li><li>中国特色社会主义法治体系的基本框架<ul><li>加快形成完备的法律规范体系；加快形成高效的法治实施体系；加快形成严密的法治监督体系；加快形成有力的法治保障体系；加快形成完善的党内法规体系</li></ul></li><li>全面依法治国的总体目标<ul><li>实现法律规范完备统一，执法司法公正高效权威，权力运行收到有效制约监督，人民合法权益得到充分尊重保障，法治信仰普遍确立，法治国家、法治政府、法治社会全面建成。</li></ul></li></ol><h2 id="如何加快建设法治中国1">如何加快建设法治中国1</h2><ol type="1"><li>完善以宪法为核心的中国特色社会主义法律体系</li><li>扎实推进依法行政</li><li>严格公正司法</li><li>加快建设法治社会</li><li>加强法治工作队伍建设</li></ol><h1 id="第十章-建设社会主义文化强国">第十章 建设社会主义文化强国</h1><h2 id="为什么建设中国特色社会主义文化1">为什么建设中国特色社会主义文化1</h2><ol type="1"><li>文化是一个国家、一个民族的灵魂</li><li>没有文化繁荣兴盛就没有中华民族伟大复兴<ul><li>文化繁荣兴盛是实现中华民族伟大复兴的精神支柱；是建设社会主义现代化国家的应有之义；是满足人民日益增长的美好生活需要的内在要求；是在世界文化激荡中站稳脚跟的前提基础。</li></ul></li><li>文化自信是一个国家、一个民族发展中最基本、最深沉、最持久的力量<ul><li>中华优秀传统文化是坚定文化自信的深厚基础；党带领人民在伟大斗争中孕育的革命文化和社会主义先进文化是坚定文化自信的坚强基石；中国特色社会主义伟大实践是坚定文化自信的现实基础。</li></ul></li></ol><h2 id="为什么要坚持马克思主义在意识形态领域指导地位的根本制度">为什么要坚持马克思主义在意识形态领域指导地位的根本制度</h2><ol type="1"><li>意识形态工作是党的一项极端重要的工作</li><li>巩固马克思主义在意识形态领域的指导地位</li><li>不断增强意识形态领域主导权和话语权</li><li>互联网是意识形态斗争的主阵地、主战场、最前沿</li></ol><h2 id="为什么要用社会主义核心价值观凝心聚力">※为什么要用社会主义核心价值观凝心聚力</h2><ol type="1"><li>文化的影响力首先是价值观念的影响力<ul><li>一个国家的文化软实力，从根本上说，取决于其核心价值观的生命力、凝聚力、感召力。世界上各种文化之争，本质上是价值观念之争，也是人心之争、意识形态之争。</li><li>核心价值观，承载着一个民族、一个国家的精神追求，体现着一个社会评判是非曲直的价值标准。</li></ul></li><li>广泛践行社会主义核心价值观<ul><li>社会主义核心价值观集中体现着全体人民共同的价值追求，是凝聚人心、汇聚敏力的强大力量。内容：富强、民主、文明、和谐（国家层面）；自由、平等、公正、法治（社会层面）；爱国、敬业、诚信、友善（个人层面）</li><li>社会主义核心价值观只有成为广泛的社会共识，内化为人们的精神追求，外化为人们的自觉行动，才能真正在社会生活中发挥作用。</li><li>社会主义核心价值观建设，要注重区分层次、突出重点，抓好重点人群。</li></ul></li></ol><h2 id="如何铸就社会主义文化新辉煌">如何铸就社会主义文化新辉煌</h2><ol type="1"><li>推动中华优秀传统文化创造性转化、创新性发展</li><li>用中国特色社会主义文化培根铸魂</li><li>繁荣发展文化事业和文化产业</li><li>不断提升国家文化软实力和中华文化影响力</li></ol><h1 id="第十一章-以保障和改善民生为重点加强社会建设">第十一章以保障和改善民生为重点加强社会建设</h1><h2 id="为什么说悠悠万事民生为大">为什么说“悠悠万事，民生为大”</h2><ol type="1"><li>民生是最大的政治<ul><li>民生事关人民幸福生活；民生事关社会和谐稳定。</li><li>增进民生福祉是马克思主义政党的本质要求；增进民生福祉是社会主义生产的根本目的；增进民生福祉是全面建设社会主义现代化国家的应有之义</li></ul></li><li>人民获得感幸福感安全感更加充实、更有保障、更可持续</li><li>坚持在发展中增进民生福祉<ul><li>正确把握民生和发展的关系：既要发展经济为持续改善民生奠定坚实物质基础，又要持续不断改善民生，为经济发展创造更多有效需求</li><li>坚守底线、突出重点、完善制度、引导预期</li><li>解决人民群众最关心最直接最现实的利益问题</li><li>尽力而为、量力而行</li><li>劳动创造幸福</li></ul></li></ol><h2 id="提高人民生活品质着重从哪些方面入手">提高人民生活品质着重从哪些方面入手</h2><ol type="1"><li>完善分配制度</li><li>实施就业优先战略</li><li>健全社会保障体系</li><li>推进健康中国建设</li></ol><h2 id="怎样推进社会治理现代化">※怎样推进社会治理现代化</h2><ol type="1"><li>加强和创新社会治理<ul><li>社会治理是国家治理的重要领域，推进社会治理现代化是推进国家治理体系和治理能力现代化的重要内容。</li><li>新时代加强社会治理，要坚持<strong>系统治理、综合治理、依法治理、源头治理</strong>。</li></ul></li><li>完善社会治理体系<ul><li>社会治理体系是进行社会治理的基础。</li><li>理念是完善社会治理体系的先导，必须坚持共建共治共享的社会治理理念。<ul><li>共建是共同参与社会建设，突出制度和体系建设在社会治理格局中的基础性、战略性地位，是社会治理的基础；</li><li>共治是共同参与社会治理，要求树立大社会观、大治理观，打造全民参与的开放治理体系，是社会治理的关键；</li><li>共享是共同享有社会治理成果，要求社会治理的成效更多更公平惠及全体人民，是社会治理的目标。</li></ul></li><li>制度是完善社会治理体系的保障</li><li>方式方法是完善社会治理体系的重要内容</li></ul></li><li>加强城乡社区治理<ul><li>健全党组织领导的城乡基层治理体系，实现政府治理和社会调节、居民自洽良性互动</li><li>坚持和发展新时代“枫桥经验”“浦江经验”</li><li>加快推进市域社会治理现代化，提高市域社会治理能力</li></ul></li></ol><h1 id="第十二章-建设社会主义生态文明">第十二章建设社会主义生态文明</h1><h2 id="新时代为什么突出强调生态文明建设">新时代为什么突出强调生态文明建设</h2><ol type="1"><li>顺应人类文明进程<ul><li>人类经历了原始文明、农业文明、工业文明，生态文明是工业文明发展到一定阶段的产物，是实现人与自然和谐发展的新要求。</li></ul></li><li>破解我国经济社会发展短板问题<ul><li>我国资源保障能力较弱制约经济社会可持续发展；环境污染制约人民生活质量和幸福感；我国生态系统依然脆弱制约其服务经济社会发展能力</li></ul></li><li>满足人民日益增长的优美生态环境需要<ul><li>进入新时代，生态环境在群众生活幸福指数中的地位不断凸显，人民对优美生态环境的需要愈益普遍、愈发强烈</li></ul></li><li>应对全球生态环境领域挑战<ul><li>生态环境恶化是当代人类面临的严重全球性问题，需要国际社会共同担当和应对。积极参与气候变化等全球环境治理，不仅能推动国际社会共同构建人与自然命运共同体，展现我国作为负责任发展中大国的担当和影响力，而且可化解全球生态环境问题给中华民族永续发展带来的风险。</li></ul></li></ol><h2 id="建设什么样的生态文明">※建设什么样的生态文明</h2><ol type="1"><li>人与自然和谐共生的现代化<ul><li>人与自然是生命共同体；实现人与自然和谐共生的现代化</li></ul></li><li>绿水青山就是金山银山<ul><li>绿水青山就是金山银山理念，阐明了经济发展与生态环境保护之间的关系。经济发展不能对资源和生态环境竭泽而渔，生态环境保护也不是舍弃经济发展而缘木求鱼，而是在高质量发展中保护、在高水平保护中发展，实现发展和保护的协同共生。</li><li>习近平“两山论”的突出贡献：马克思主义生产力观的新成果</li></ul></li><li>新时代生态文明建设的辉煌成就<ul><li>四个重大转变：方式方法由重点整治到系统治理；观念和责任由被动应对到主动作为；思想和理论由实践探索到科学理论指导；胸怀与格局由全球环境治理参与者到引领者。</li><li>生态文明建设战略地位更加凸显</li><li>生态文明制度体系更加健全</li><li>污染防治和生态保护更加有力</li></ul></li></ol><h2 id="怎样建设美丽中国">※怎样建设美丽中国</h2><ol type="1"><li>加快发展方式绿色转型<ul><li>推动经济社会发展绿色化、低碳化是实现高质量发展的关键环节。</li><li>推动形成绿色低碳的生产方式和生活方式；积极稳妥推进碳达峰碳中和；注重处理好五对关系、落实六项举措；把建设美丽中国转化为全体人民的自觉行动</li></ul></li><li>坚持山水林田湖草沙一体化保护和系统治理<ul><li>深入实施山水林田湖草一体化生态保护和修复，开展大规模国土绿化行动，加快水土流失和荒漠化石漠化综合治理。</li></ul></li><li>用最严格制度最严密法治保护生态环境<ul><li>保护生态环境必须依靠最严格制度最严密法治；生态环境治理的体系化、法治化和效能化；健全落地见效的生态环境监管考核体制</li></ul></li></ol><h2 id="怎样共谋全球生态文明建设之路">怎样共谋全球生态文明建设之路</h2><ol type="1"><li>保护人类共同家园</li><li>共建清洁美丽的世界</li><li>积极推动全球可持续发展</li></ol><h1 id="第十三十五章-实现中华民族伟大复兴的重要保障">第十三~十五章实现中华民族伟大复兴的重要保障</h1><h2 id="构建统筹各领域安全的新安全格局">※构建统筹各领域安全的新安全格局</h2><ol type="1"><li>统筹发展和安全<ul><li>统筹发展和安全，是党和国家的一项基础性工作，是我们党治国理政的一个重大原则。加快构建新安全格局，是以习近平同志为核心的党中央统筹发展和安全、把握国家安全主动权的重大战略部署。</li><li>发展和安全，是一个国家、一个民族生存与进步必须处理好的首要问题。发展解决的是动力问题，是推动国家和民族赓续绵延的根本支撑。安全解决的是保障问题，是确保国家和民族行稳致远的坚强柱石。</li><li>以新安全格局保障新发展格局</li></ul></li><li>把维护政治安全放在首要位置<ul><li>政治安全是国家安全的根本。政治安全涉及国家主权、政权、制度和意识形态的稳固，是一个国家最根本的需求，是一切国家生存和发展的基础条件。维护政治安全，要毫不动摇坚持和巩固党的领导和长期执政地位；毫不动摇坚持和完善中国特色社会主义制度；毫不动摇坚持和巩固马克思主义在意识形态领域的指导地位，不断巩固全党全国人民团结奋斗的共同思想基础。</li></ul></li><li>统筹推进各重点领域国家安全工作<ul><li>维护国土安全——国土安全是立国之基</li><li>维护经济安全——国家安全的基础</li><li>维护社会安全——社会安全与人民群众切身利益关系最密切，是社会安定的风向标。</li><li>维护网络、人工智能、数据安全——成为我国面临的最复杂、最现实、最严峻的非传统安全问题之一</li><li>维护生物安全和公共卫生安全——事关国家安全和发展、事关社会大局稳定的重大风险挑战。</li><li>维护外部安全——任何一个国家的安全问题积累到一定程度，都可能外溢成为区域性甚至全球性安全问题。</li></ul></li></ol><h2 id="实现党在新时代的强军目标">※实现党在新时代的强军目标</h2><ol type="1"><li>建设强大军队是接续奋斗的伟大事业<ul><li>“两个差距很大”和“两个能力不够”</li></ul></li><li>强军目标 的科学内涵<ul><li><strong>党在新时代的强军目标是建设一支听党指挥、能打胜仗、作风优良的人民军队，把人民军队建设成为世界一流军队</strong>。</li><li><strong>听党指挥是灵魂，能打胜战是核心，作风优良是保证</strong>，三者统一于建设强大人民军队的实践。体现了我们党一以贯之的建军治军指导思想和方针原则，体现了革命化现代化正规化建设相统一的全面建设思想，明确了加强军队建设的聚焦点和着力点。</li></ul></li><li>全面推进国防和军队现代化的战略安排<ul><li>2027年：实现建军一百年奋斗目标</li><li>2035年：基本实现国防和军队现代化</li><li>本世纪中叶：把人民军队全面建成世界一流军队</li></ul></li></ol><h2 id="推进祖国完全统一">※推进祖国完全统一</h2><ol type="1"><li>实现祖国完全统一是中华民族伟大复兴的必然要求<ul><li>实现祖国完全统一是由中华民族伟大复兴的时和势决定的，是不可阻挡的历史潮流。台湾的前途在于国家统一，台湾同胞福祉系于民族复兴。两岸关系和平发展是维护两岸和平、促进两岸共同发展、造福两岸同胞的正确道路。</li></ul></li><li>坚决贯彻新时代党解决台湾问题的总体方略</li><li>坚定不移推进祖国统一大业<ul><li>“和平统一、一国两制”方针是实现两岸统一的最佳方式</li><li>促进两岸经济文化交流合作，深化两岸各领域融合发展</li><li>坚持以最大诚意、尽最大努力争取和平统一的前景</li></ul></li></ol><h1 id="第十六章-中国特色大国外交和推动构建人类命运共同体">第十六章中国特色大国外交和推动构建人类命运共同体</h1><h2 id="世界怎么了">世界怎么了</h2><ol type="1"><li>世界进入新的动荡变革期</li><li>国际力量对比发生深刻变化</li><li>经济全球化遭遇逆流</li><li>国际体系和国际秩序深度调整</li></ol><h2 id="人类向何处去">※人类向何处去</h2><ol type="1"><li>构建人类命运共同体是世界各国人民前途所在<ul><li>人类是一个整体，地球是一个家园构建人类命运共同体是中国共产党审视当今世界发展趋势、针对当今世界发展的重大问题提出的重要理念。</li></ul></li><li>人类命运共同体的提出与内涵<ul><li>内涵：每个民族、每个国家的前途命运都紧紧联系在一起，应该风雨同舟，荣辱与共，努力把我们生于斯、长于斯的这个星球建成一个和睦的大家庭，把世界各国人民对美好生活的向往变成现实。<ul><li>坚持对话协商，建设持久和平的世界；</li><li>坚持共建共享，建设普遍安全的世界；</li><li>坚持合作共赢，建设共同繁荣的世界；</li><li>坚持交流互鉴，建设开放包容的世界；</li><li>坚持绿色低碳，建设清洁美丽的世界</li></ul></li></ul></li><li>弘扬全人类共同价值——人类命运共同体的价值基础<ul><li>和平、发展、公平、正义、民主、自由的全人类共同价值</li></ul></li><li>高质量共建“一带一路” ——人类命运共同体的生动实践</li></ol><h2 id="中国怎么办">中国怎么办</h2><ol type="1"><li>坚持走和平发展道路</li><li>推动建设新型国际关系</li><li>坚决维护国家主权、安全、发展利益</li><li>积极参与全球治理体系改革和建设</li></ol><h1 id="第十七章-中国特色大国外交和推动构建人类命运共同体">第十七章中国特色大国外交和推动构建人类命运共同体</h1><h2 id="为什么要全面从严治党">为什么要全面从严治党</h2><ol type="1"><li>从严治党是马克思主义政党的政治优势</li><li>全面从严治党是实现民族复兴的根本保证</li><li>全面从严治党是决定党兴衰成败的关键因素</li><li>坚定不移全面从严治党</li></ol><h2 id="为什么十八大以来管党治党宽松软状况得到根本扭转">为什么十八大以来管党治党宽松软状况得到根本扭转</h2><ol type="1"><li>把党的政治建设摆在首位</li><li>思想建设是党的基础性建设</li><li>贯彻新时代党的组织路线</li><li>始终绷紧作风建设这根弦</li><li>把纪律的螺丝拧得紧而又紧</li><li>把制度建设贯穿到党的各项建设之中</li><li>坚定不移推进反腐败斗争</li></ol><h2 id="如何理解全面从严治党这场伟大自我革命">※如何理解全面从严治党这场伟大自我革命</h2><ol type="1"><li><strong>党的自我革命是跳出历史周期率的第二个答案</strong></li><li>时刻保持解决大党独有难题的清醒和坚定<ul><li>如何始终不忘初心、牢记使命；如何始终统一思想、统一意志、统一行动；如何始终具备强大的执政能力和领导水平；如何始终保持干事创业精神状态；如何始终能够及时发现和解决自身存在的问题；如何始终保持风清气正的政治生态</li></ul></li><li>以伟大自我革命引领伟大社会革命<ul><li>党的自我革命是伟大社会革命的基础和先导；<strong>伟大社会革命是党的自我革命的根本目的</strong>；党的自我革命和伟大社会革命统一于新时代中国特色社会主义的伟大实践中</li><li><strong>以中央八项规定为切入口的作风建设成为新时代党的自我革命伟大实践的重要标志</strong>，推动管党治党发生格局性变化。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>习近平新时代中国特色社会主义思想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中国近现代史纲要</title>
    <link href="/posts/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/"/>
    <url>/posts/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>马楠老师</em> 2023-2024学年秋季学期教学内容进行整理</p></blockquote><h1 id="导言">导言</h1><h2 id="近代史现代史的定义">近代史、现代史的定义</h2><ul><li><strong>中国近现代史</strong>：1840年以来的中国历史</li><li><strong>中国近代史</strong>：从1840年<strong>鸦片战争爆发</strong>到1949年<strong>中华人民共和国成立前夕</strong>的历史<ul><li><strong>中国近代史</strong>以鸦片战争为起点</li><li>1842 年8 月29日，清政府与英国签订中国近代史上第一个不平等条约——南京条约。鸦片战争后，由于西方列强入侵和封建统治腐败，中国逐步成为半殖民地半封建社会，从那时起，中国社会发生两个根本变化：<ul><li>一是独立的中国逐步变成半殖民地的中国</li><li>二是封建的中国逐步变成半封建的中国</li></ul></li></ul></li><li><strong>中国现代史</strong>：1949年中华人民共和国成立以来的历史</li></ul><h2 id="中国人民必须完成的两大历史任务">中国人民必须完成的两大历史任务</h2><p>争得民族独立、人民解放，实现国家富强、人民幸福。</p><h2 id="近代中国社会的主要矛盾">近代中国社会的主要矛盾</h2><p>主要矛盾是帝国主义和中华民族的矛盾、封建主义和人民大众的矛盾。</p><h1 id="第一章-进入近代后中华民族的磨难与抗争">第一章进入近代后中华民族的磨难与抗争</h1><h2 id="鸦片战争后签订的一系列不平等条约">鸦片战争后签订的一系列不平等条约</h2><ul><li>1842.8.29 中英《南京条约》——中国近代史上第一个不平等条约</li><li>1843.10 中英《虎门条约》</li><li>1844.7 中美《望厦条约》</li><li>1844.10 中法《黄埔条约》</li></ul><p>随着外国资本主义的入侵，中国的封建社会逐渐变成了半殖民地半封建社会。中国人民逐渐开始了反帝反封建的资产阶级民主革命。鸦片战争成为中国近代史起点。</p><h2 id="中国封建社会的性质">中国封建社会的性质</h2><ul><li><strong>近代中国社会的性质（1840-1949）</strong>：半殖民地半封建性质</li><li><strong>关键词</strong>：<ul><li>独立——半殖民地：主权受破坏，一定程度上被殖民地化，丧失完整主权但仍维持独立国家和政府的名义</li><li>封建——半封建：卷入世界资本主义经济体系和世界市场，自给自足的自然经济的基础受破坏，中国资本主义的产生有了某些客观条件</li></ul></li><li><strong>基本特征</strong>：<ol type="1"><li>资本—帝国主义侵略势力逐步操纵中国财政、经济、政治，日益成为支配中国的决定性力量</li><li>自然经济受破坏但仍存在严重阻碍</li><li>封建势力勾结帝国主义</li><li>新兴民族资本主义产生但力量软弱</li></ol></li></ul>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-4a63de2c" role="button" aria-expanded="false" aria-controls="collapse-4a63de2c">        <div class="fold-arrow">▶</div>半殖民地半封建性质辨析      </div>      <div class="fold-collapse collapse" id="collapse-4a63de2c">        <div class="fold-content">          <p>鸦片战争以后，资本–帝国主义列强通过发动侵略战争，强迫中国签订一系列不平等条约，破坏中国的领土主权、领海主权、关税主权、司法主权等，并一步一步地控制中国的政治、经济、外交和军事。中国已经丧失了完全独立的地位，在相当程度上被殖民地化了。近代中国尽管在实际上已经丧失拥有完整主权的独立国的地位，但是仍然维持着独立国家和政府的名义，还有一定的主权。由于它与连名义上的独立也没有而由殖民主义宗主国直接统治的殖民地尚有区别，因此被称作半殖民地。</p><p>外国资本–帝国主义列强用武力打开中国的门户，把中国卷入世界资本主义经济体系和世界市场之中。随着外国资本主义的入侵，洋纱、洋布等商品在中国大量倾销，逐渐使中国的农业与家庭手工业分离，一方面，破坏了中国自给自足的自然经济的基础，破坏了城市的手工业和农民的家庭手工业；另一方面，则促进了中国城乡商品经济的发展，给中国资本主义的产生造成了某些客观条件。破产的农民和手工业者成了产业工人的后备军。一批官僚、买办、地主、商人投资兴办新式工业。中国出现了资本主义生产关系。中国已经不是完全的封建社会了，因此被称作半封建社会。</p>        </div>      </div>    </div><h2 id="近代中国的社会主要矛盾">近代中国的社会主要矛盾</h2><p>近代中国半殖民地半封建社会的矛盾，呈现出错综复杂的状况</p><ul><li><strong>主要矛盾</strong>：这两对主要矛盾及其斗争贯穿整个中国半殖民地半封建社会的始终，并对中国近代社会的发展变化起着<strong>决定性的作用</strong><ol type="1"><li>帝国主义和中华民族的矛盾<ul><li><strong>最主要的矛盾</strong></li></ul></li><li>封建主义和人民大众的矛盾</li></ol></li></ul><h2 id="近代中国的两大历史任务">近代中国的两大历史任务</h2><ol type="1"><li>争得民族独立和人民解放</li><li>实现国家富强和人民幸福</li></ol><h2 id="帝国主义对中国的侵略">帝国主义对中国的侵略</h2><h3 id="军事侵略">军事侵略</h3><p>资本–帝国主义列强对中国的侵略，<strong>首先和主要</strong>的是进行<strong>军事侵略</strong></p><ol type="1"><li>发动侵略战争，屠杀中国人民</li><li>侵占中国领土，划分势力范围</li><li>勒索赔款，抢掠财富</li></ol><h3 id="政治控制">政治控制</h3><ol type="1"><li>控制中国的内政、外交</li><li>镇压中国人民的反抗</li><li>扶植、收买代理人</li></ol><h3 id="经济掠夺">经济掠夺</h3><ol type="1"><li>强迫中国支付巨额的战争赔款</li><li>控制中国的通商口岸</li><li>剥夺中国的关税门主权</li><li>实行商品倾销和资本输出</li><li>操纵中国的经济命脉</li></ol><h3 id="文化渗透">文化渗透</h3><ol type="1"><li>披着宗教外衣，进行侵略活动</li><li>为侵略中国制造舆论</li></ol><h2 id="抵御外来侵略的斗争历程">抵御外来侵略的斗争历程</h2><ul><li><strong>人民群众的反侵略斗争</strong>：三元里人民抗英；太平天国；台湾人民高山族；香港造船工人罢工；台北人民反对割台；义和团</li><li>三元里人民的抗英斗争，是中国近代史上中国人民<strong>第一次大规模的反侵略武装斗争</strong></li></ul><h2 id="帝国主义侵略中国的最终目的">帝国主义侵略中国的最终目的</h2><p><strong>瓜分中国</strong>、<strong>灭亡中国</strong></p><h2 id="列强瓜分中国图谋的破产原因何在">列强瓜分中国图谋的破产原因何在</h2><p><strong>关键词</strong>：</p><ol type="1"><li>帝国主义列强之间的<strong>矛盾</strong>与相互<strong>制约</strong>，在争吵与协商后认定暂缓瓜分中国，实行“以华治华”</li><li><strong>根本原因</strong>：中华民族不屈不挠的反侵略斗争：如义和团；中国人民不畏强暴、敢与敌人血战到底的英雄气概，中华民族为反抗侵略所进行的前赴后继视死如归的战斗</li></ol><h2 id="反侵略战争的失败及其原因">反侵略战争的失败及其原因</h2><ol type="1"><li>社会制度的腐败<ul><li>最<strong>根本原因</strong></li><li>社会制度的腐败，使得经济技术落后的状况长期得不到改变</li></ul></li><li>经济技术的落后</li></ol><ul><li>中法战争后期，1885.3，爱国将领冯子材指挥清军在中越边境前线大败法军，清政府主权者力主避战求和签订《中法新约》——“中国不败而败，法国不胜而胜”</li></ul><h2 id="早期维新思想">早期维新思想</h2><ul><li><p><strong>林则徐</strong>是近代中国<strong>睁眼看世界的第一人</strong></p></li><li><p><strong>魏源</strong>在1843年1月编成《<strong>海国图志</strong>》</p><ul><li>提出“<strong>师夷长技以制夷</strong>”：主张学习外国先进的军事和科学技术，以期富国强兵，抵御外国侵略</li></ul></li><li><p><strong>郑观应</strong>《<strong>盛世危言</strong>》：具有重要的<strong>思想启蒙</strong>的意义</p><ul><li>出大力<strong>发展民族工商业</strong></li><li>同西方国家进行“商战”</li><li>设立议院，实行“君民共主”制度</li></ul></li><li><p><strong>严复</strong>翻译《<strong>天演论</strong>》</p><ul><li>“<strong>物竞天择</strong>”“<strong>适者生存</strong>”的社会进化论思想</li><li>为这种危机意识和民族意识提供了<strong>理论根据</strong></li></ul></li></ul><h1 id="第二章-不同社会力量对国家出路的早期探索">第二章不同社会力量对国家出路的早期探索</h1><h2 id="太平天国">太平天国</h2><ul><li>历史沿革<ul><li>1843年，<strong>洪秀全</strong>从<strong>农民斗争</strong>的需要出发，加以改造，创立<strong>拜上帝教</strong>，并利用它发动和组织群众</li><li><strong>金田起义</strong>：1851年1月，洪秀全率拜上帝教教众在广西省桂平县金田村发动起义，建号<strong>太平天国</strong></li></ul></li><li>性质<ul><li><strong>反对清政府腐朽统治</strong>和<strong>地主阶级压迫、剥削</strong></li><li><strong>正义战争</strong></li></ul></li></ul><h3 id="天朝田亩制度和资政新篇">《天朝田亩制度》和《资政新篇》</h3><ul><li>《天朝田亩制度》：<ul><li>最能体现太平天国社会理想和这次农民起义特色的纲领性文件</li><li>内容与局限性：农民要求平分土地的强烈愿望，不切实际的空想性质</li><li>先进性：否定了封建社会的基础即封建土地所有制</li></ul></li><li>《资政新篇》：<ul><li>太平天国后期发布的社会发展方案</li><li>作者：洪仁轩（资本主义色彩，受限于历史条件未能实施）</li><li>特点：具有<strong>资本主义色彩</strong>的方案，中国近代历史上第一个<strong>比较系统的发展资本主义</strong>的方案</li><li>反映通过向外国学习来寻求出路的一种努力，在中国近代“向西方学习”、追求近代化的进程中有比较重要的意义</li></ul></li></ul><h3 id="太平天国农民起义失败的原因">太平天国农民起义失败的原因</h3><ol type="1"><li>无法克服小生产者所固有的阶级局限性，缺乏科学思想理论的指导，没有先进阶级的领导无法从根本上提出完整、正确的政治纲领和社会改革方案；</li><li>后期无法制止和克服领导集团自身腐败现象的产生，领导集团部分人追求享乐争权夺利，削弱向心力和战斗力；</li><li>军事战略失误：未能与捻军结成同盟；天京被围时拒绝“让城别走”；</li><li>以宗教发动组织群众，拜上帝教教义无法正确指导斗争反而带来危害；</li><li>未能正确对待儒学；</li><li>无法将西方国家侵略者和人民群众区别开来，缺乏对西方资本主义侵略者的理性认识；</li></ol><h3 id="太平天国的历史意义">太平天国的历史意义</h3><ol type="1"><li><strong>沉重打击了封建统治阶级</strong>，强烈撼动了清政府的统治根基</li><li>是中国<strong>旧式农民战争</strong>的最高峰</li><li>在一定程度上削弱了封建统治的精神支柱</li><li>有力地<strong>打击</strong>了<strong>外国侵略势力</strong>，冲击了西方殖民主义者在亚洲的统治</li></ol><h3 id="太平天国失败的历史意义">太平天国失败的历史意义</h3><ol type="1"><li>农民具有伟大的<strong>革命潜力</strong></li><li>但它<strong>自身不能担负</strong>起领导反帝反封建斗争取得胜利的重任</li><li><strong>单纯的农民战争</strong>不可能完成争取民族独立和人民解放的历史任务</li></ol><h2 id="洋务运动">洋务运动</h2><h3 id="洋务运动指导思想中学为体西学为用">洋务运动指导思想：“中学为体，西学为用”</h3><ul><li>以中国封建伦理纲常所维护的<strong>统治秩序为主体</strong></li><li>用西方的近代工业和技术为<strong>辅助</strong></li><li>并以前者来支配后者</li></ul><h3 id="洋务运动的事业内容">洋务运动的事业内容</h3><ol type="1"><li>兴办近代企业<ul><li>官办<strong>军用工业</strong><ul><li><strong>最早</strong>：1861<strong>安庆军械所</strong></li><li>最大兵工厂：<strong>上海江南制造总局</strong></li></ul></li><li>民用企业<ul><li>采取<strong>官督商办</strong></li></ul></li></ul></li><li>建立新式海陆军</li><li>创办<strong>新式学堂</strong>，派遣留学生</li></ol><h3 id="洋务运动的失败及其原因">洋务运动的失败及其原因</h3><ol type="1"><li>洋务运动具有封建性：企图吸收西方近代生产技术以维护巩固中国封建统治，然而新的生产力是同封建主义的生产关系及其上层建筑不相容的；</li><li>洋务运动对列强具有依赖性：企图依赖外国来达到自强求富的目的；</li><li>洋务企业的管理具有腐朽性：本质是封建衙门式的，内部腐败</li></ol><h2 id="维新运动">维新运动</h2><ul><li>背景与原因：甲午战败与马关条约的签订</li><li>资产阶级维新派：康有为、梁启超、谭嗣同、严复等</li></ul><h3 id="维新派与守旧派的论战">维新派与守旧派的论战</h3><ul><li><strong>※重要：戊戌维新运动</strong>：维新派与守旧派的这场论战，实质上是资产阶级思想和封建主义思想在中国的第一次正面交锋</li></ul><h3 id="戊戌维新运动的意义">戊戌维新运动的意义：</h3><ol type="1"><li>是一次爱国救亡运动：高举救亡图存旗帜要求通过变法发展资本主义走上富强道路，推动中华民族的觉醒；</li><li>是一场资产阶级性质的政治改良运动：在政治、经济等领域一定程度上冲击了封建制度；</li><li>是一场思想启蒙运动：利于民主思想在中国传播，有利于人们思想解放，推动近代教育发展</li></ol><h3 id="维新运动失败的原因">维新运动失败的原因</h3><ol type="1"><li>维新派自身的局限<ol type="1"><li>不敢否定封建主义<ol type="1"><li>政治上：不敢根本否定封建君主制度</li><li>经济上：虽然要求发展民族资本主义，却<strong>未触及封建主义的经济基础</strong>——封建土地所有制</li><li>思想上：仍要打着孔子的旗号，借古代圣贤之名“托古改制”</li></ol></li><li>对帝国主义抱有幻想，虽然大声疾呼救亡图存，却又幻想西方列强能帮助自己变法维新</li><li>惧怕人民群众，活动基本上局限于官僚士大夫和知识分子的小圈子</li></ol></li><li>以慈禧太后为首的强大的守旧势力的反对</li></ol><h3 id="维新运动失败的意义">维新运动失败的意义</h3><p>使人们认识到：在半殖民地半封建的旧中国</p><ul><li><strong>自上而下的改良道路行不通</strong></li><li>必须用革命的手段，推翻帝国主义、封建主义联合统治的半殖民地半封建的社会制度</li></ul><h1 id="第三章-辛亥革命与君主专制制度的终结">第三章辛亥革命与君主专制制度的终结</h1><h2 id="孙中山与资产阶级民主革命的开始">孙中山与资产阶级民主革命的开始</h2><ul><li><strong>1894年</strong>，<strong>孙中山</strong>组建了第一个革命团体<strong>兴中会</strong><ul><li>目标：驱除勒虏，恢复中国，创立合众政府</li><li>性质：革命组织，并非政党</li></ul></li><li><strong>1905年8月20日</strong>，<strong>孙中山和黄兴、宋教仁</strong>等人在日本东京成立<strong>中国同盟会</strong><ul><li>性质及意义：近代中国<strong>第一个</strong>领导<strong>资产阶级革命</strong>的全国性<strong>政党</strong></li></ul></li></ul><h2 id="民主革命思想广泛传播">民主革命思想广泛传播</h2><ul><li>资产阶级革命派的宣传与组织工作：<ul><li>章炳麟《驳康有为论革命书》</li><li>邹容《革命军》——“革命军中马前卒”</li><li>陈天华《警世钟》《猛回头》</li></ul></li></ul><h2 id="三民主义">三民主义</h2><ul><li>1905年11月<strong>孙中山</strong>在《<strong>民报</strong>》中将同盟会的纲领概括为<strong>三民主义</strong><ol type="1"><li>民族主义（<em>推翻清政府，建立独立国家</em>）<ul><li>驱除勒虏，恢复中华</li></ul></li><li>民权主义（<em>政治革命</em>）<ul><li>“<strong>创立民国</strong>”</li><li>即<strong>推翻封建君主专制制度</strong>，建立<strong>资产阶级民主共和国</strong></li></ul></li><li>民生主义（<em>社会革命</em>）<ul><li>当时为<strong>平均地权</strong></li></ul></li></ol></li><li><strong>同盟会政治纲领</strong>：“驱除鞑虏，回复中华，创立民国，平均地权”</li><li><strong>孙中山的三民主义学说意义</strong>：初步描绘出中国还不曾有过的资产阶级共和国方案，是一个比较完整和明确的资产阶级民主革命纲领，它的提出对推动革命的发展产生了重大而积极的影响。</li></ul><h2 id="辛亥革命与中华民国的建立">辛亥革命与中华民国的建立</h2><ul><li>1911.10.10晚，驻武昌的新军工程第八营的革命党人打响起义第一枪，大肆镇压革命的军官，冲向楚望台军械所夺取弹药，一举占领楚望台，随即向湖广总督衙门发起攻击。</li><li>1912.2.12，清帝退位，延续了两千多年的封建君主专制制度终于覆灭。</li><li>1912.1.1，孙中山在南京宣誓就职，改国号为中华民国，定1912年为民国元年，并成立中华民国临时政府</li><li><strong>《中华民国临时约法</strong>》：1912.3，临时参议院颁布《中华民国临时约法》，这是中国历史上第一部有资产阶级共和国宪法性质的法典</li><li>1912.3，袁世凯派人刺杀宋教仁，孙中山领导国民党发动<strong>二次革命</strong></li><li>1912.8，宋教仁在征得孙中山、黄兴的同意后，以同盟会为基础联合其他几个政党，组成国民党</li><li>1919.10，孙中山将中华革命党改组为中国国民党</li></ul><h3 id="辛亥革命的历史意义">辛亥革命的历史意义</h3><p>辛亥革命是<strong>资产阶级领导</strong>的以<strong>反对封建君主专制制度</strong>、<strong>建立资产阶级共和国</strong>为目的的革命，是一次比较完全意义上的<strong>资产阶级民主革命</strong>，它使中国发生了历史性的巨变，具有伟大的历史意义。</p><ol type="1"><li>辛亥革命推翻了<strong>封建势力</strong>的政治代表、<strong>帝国主义</strong>在中国的代理人<strong>清王朝</strong>的统治，沉重打击了<strong>中外反动势力</strong></li><li>辛亥革命<strong>结束</strong>了中国延续两千多年的<strong>封建君主专制制度</strong>，建立了中国历史上<strong>第一个资产阶级共和政府</strong>，使<strong>民主共和</strong>的观念开始<strong>深入人心</strong></li><li>辛亥革命推动了中国人民的<strong>思想解放</strong></li><li>辛亥革命推动了中国的<strong>社会变革</strong>，促使中国的社会经济、思想习惯和社会风俗等方面发生了新的积极变化</li><li>辛亥革命不仅在一定程度上<strong>打击</strong>了<strong>帝国主义</strong>的侵略势力，而且<strong>推动</strong>了亚洲各国<strong>民族解放运动</strong>的高涨</li></ol><h3 id="辛亥革命失败的原因">辛亥革命失败的原因</h3><ul><li>客观方面<ol type="1"><li><strong>根本</strong>：在<strong>帝国主义时代</strong>，在<strong>半殖民地半封建的中国</strong>，<strong>资本主义</strong>的建国方案是<strong>行不通</strong>的</li><li>帝国主义决不容许中国建立一个独立、富强的资产阶级共和国</li><li>帝国主义与以<strong>袁世凯</strong>为代表的<strong>大地主大买办</strong>势力以及旧官僚、立宪派一起勾结起来，从外部和内部绞杀了这场革命</li></ol></li><li>主观方面：领导者资产阶级革命派本身存在着许多弱点和错误<ol type="1"><li>没有提出<strong>彻底的反帝反封建</strong>的革命<strong>纲领</strong></li><li>不能充分发动和依靠<strong>人民群众</strong></li><li>不能建立坚强的革命政党</li><li><strong>根源</strong>：中国民族资产阶级的<strong>软弱性</strong>和<strong>妥协性</strong></li></ol></li></ul><h1 id="第四章-中国共产党成立和中国革命新局面">第四章中国共产党成立和中国革命新局面</h1><h2 id="新文化运动">新文化运动</h2><ul><li><strong>科学狭义指自然科学，广义指社会科学</strong></li><li><strong>新文化运动基本口号</strong>：拥护“德先生”和“赛先生”，即提倡民主和科学<ul><li><strong>民主，既是指资产阶级民主主义制度，也是指资产阶级民主主义思想。科学狭义指自然科学，广义指社会科学</strong></li></ul></li><li><strong>十月革命对中国先进分子的影响</strong>：1917年俄国十月社会主义革命是一个具有划时代意义的世界性历史事件</li><li><strong>李大钊率先在中国举起马克思主义旗帜</strong></li></ul><h2 id="五四运动">五四运动</h2><ul><li><strong>五四运动的历史特点和意义</strong>：五四运动是一场以先进青年知识分子为先锋、广大人民群众参加的彻底反帝反封建的伟大爱国革命运动，是一场中国人民为拯救民族危亡、捍卫民族尊严、凝聚民族力量而掀起的伟大社会革命运动，是一场传播新思想新文化新知识的伟大思想启蒙运动和新文化运动</li><li><strong>意义</strong>：<ol type="1"><li>旧民主向新民主主义革命转变的转折点，里程碑意义，彻底的反帝反封建革命性</li><li>促进马克思主义在中国的传播，为中国共产党成立做了思想上干部上的准备，新民主主义革命的开端</li><li>激发追求真理和进步的伟大觉醒</li><li>以全民族的搏击培育了永久奋斗的伟大传统（五四运动以全民族的力量高举起爱国主义的伟大旗帜，孕育了以爱国主义为核心的、以爱国、进步、民主、科学为主要内容的伟大五四精神）</li></ol></li></ul><h2 id="早期信仰马克思主义的三类人物">早期信仰马克思主义的三类人物</h2><ol type="1"><li>新文化运动精神领袖：李大钊、陈独秀</li><li>五四运动左翼骨干：毛泽东</li><li>原中国同盟会会员、辛亥革命时期的活动家：董必武</li></ol><h2 id="中国共产党成立的历史条件">中国共产党成立的历史条件</h2><p><strong>中国先进分子选择了马克思主义，这是具有伟大历史意义的事件</strong></p><p><strong>中国共产党早期组织的活动</strong>：</p><ol type="1"><li>研究宣传马克思主义、研究中国实际问题</li><li>到工人中去进行宣传和组织工作</li><li>进行关于建党问题的讨论和实际组织工作</li></ol><h2 id="中国共产党成立">中国共产党成立</h2><ul><li><strong>中国共产党第一次全国代表大会</strong>：1921.7.23，上海法租界望志路106号</li><li>成果：<ul><li>确定党的名称为“<strong>中国共产党</strong>”</li><li>设立<strong>中央局</strong>作为中央的临时领导机构，选举产生了以<strong>陈独秀</strong>为书记的中央局</li><li>宣告<strong>中国共产党正式成立</strong></li></ul></li><li><strong>中国共产党的成立，深刻改变了</strong><ul><li>近代以后中华民族发展的方向和进程</li><li>中国人民和中华民族的前途和命运</li><li>世界发展的趋势和格局</li></ul></li></ul><h2 id="民主革命纲领的制定">民主革命纲领的制定</h2><ul><li><strong>中共二大</strong>：1922年7月，上海，中国共产党第二次全国代表大会</li><li><strong>中共二大</strong>提出了<strong>反帝反封建的民主革命纲领</strong></li><li>意义<ul><li>为中国人民指出了明确的<strong>斗争目标</strong></li></ul></li><li>内容<ul><li>党的最高纲领：实现社会主义、共产主义</li><li>党在现阶段的纲领，即<strong>最低纲领</strong>是<ul><li><strong>打倒军阀</strong></li><li>推翻<strong>国际帝国主义</strong>的压迫</li><li>统一中国为真正<strong>民主共和国</strong></li></ul></li></ul></li></ul><h2 id="国共合作的形成">国共合作的形成</h2><ul><li>中共三大后，国共合作步伐大大加快。</li><li>1924.1，中国国民党第一次全国代表大会由孙中山主持在广州举行。大会审议通过的《中国国民党第一次全国代表大会宣言》，对三民主义作出新的解释，即”新三民主义”。<ul><li>民族主义突出</li><li>反对帝国主义；民权主义强调民主权利应“为一般平民所共有”</li><li>民生主义概括为“平均地权、节制资本”和补充“耕者有其田”</li></ul></li><li>国共合作的政治基础：新三民主义纲领同中国共产党在民主革命阶段的纲领基本一致</li></ul><h2 id="中国人民为什么选择了马克思主义">※中国人民为什么选择了马克思主义</h2><p>中国人民选择了马克思主义，是因为马克思主义理论符合中国社会需要。近代中国向西方寻找救国真理屡遭失败，俄国十月革命给探寻国家出路的中国人民指明了前进方向，提供了全新选择。早期马克思主义者推动了马克思主义在中国的传播。中国人民选择马克思主义有力推动了中国人民争取民族独立、人民解放的反帝反封建的革命运动。中国人在精神上就由被动转为主动。马克思主义在中国的早期传播，就开始与中国工人运动相结合，从而产生了中国共产党，使得中国人民反帝反封建斗争有了坚强的领导核心。</p><h1 id="第五章-中国革命的新道路">第五章 中国革命的新道路</h1><h2 id="武装反抗国民党反动统治的斗争">武装反抗国民党反动统治的斗争</h2><ul><li><strong>八七会议</strong>：1927.8，中共中央在汉口秘密召开紧急会议，会议确定了土地革命和武装起义的方针，给正在处于思想混乱和组织涣散中的中国共产党指明了新的出路，这是<strong>由大革命失败到土地革命战争兴起的历史性转变</strong>。</li></ul><h2 id="武装起义">武装起义</h2><ul><li><strong>1927.8.1</strong>八一<strong>南昌起义</strong>，武装反抗国民党反动派的第一枪</li><li><strong>1927.9.9</strong>九九<strong>秋收起义</strong>，毛泽东等领导的湘赣边界秋收起义爆发</li><li><strong>1927.10.7</strong><strong>井冈山</strong>农村革命<strong>根据地创立</strong></li><li>1927.12.11 广州起义</li></ul><h2 id="对中国革命新道路的探索">对中国革命新道路的探索</h2><p>毛泽东率领起义军到井冈山后全力进行湘赣边界党、军队和政权的建设。</p><ul><li>1927.11 成立边界第一个红色政权——茶陵县工农兵政府</li><li>1928.10-11 毛泽东——《中国的红色政权为很么能够存在》《井冈山的斗争》<ul><li>提出了工农武装割据的思想</li></ul></li><li>1920.1 毛泽东——《星星之火可以燎原》</li><li>1920.5 毛泽东——《反对本本主义》<ul><li>“没有调查没有发言权”</li><li>“中国革命斗争的胜利要靠中国同志了解中国情况”</li><li>表现毛泽东开辟新道路、创造新理论的革命首创精神</li></ul></li></ul><h2 id="农村革命根据地的建设">农村革命根据地的建设</h2><p>1931.11,中华苏维埃第一期全国代表大会在江西瑞金召开</p><ul><li>成果<ul><li>通过《中华苏维埃共和国宪法大纲》及土地法令、劳动法</li><li>选举产生了中华苏维埃共和国中央执行委员会，</li><li>成立了<strong>中华苏维埃共和国临时中央政府</strong></li><li>毛泽东当选为<strong>主席</strong></li></ul></li><li>意义<ul><li>中华苏维埃共和国是中国历史上<strong>第一个全国性的工农民主政权</strong></li></ul></li></ul><h2 id="遵义会议与长征">遵义会议与长征</h2><ul><li><strong>1934年10月</strong>，红军开始<strong>长征</strong><ul><li>意义<ul><li>是中国共产党和红军在极端困难的条件下进行的一次伟大的战略转移</li><li>是中国革命史上具有伟大历史意义的事件</li><li>使红军保存了有生力量，保存了革命火种，为中国革命的胜利创造了条件</li><li>是一次理想信念的伟大远征，是一次检验真理的伟大远征，是一次唤醒群众的伟大远征，是一次开创新局的伟大远征</li></ul></li></ul></li><li><strong>1935年1月15-17日，遵义会议</strong><ul><li>背景<ul><li>第五次反围剿失败中的“左”倾错误领导</li><li><strong>强渡湘江</strong>，中央红军从长征出发时的8.6万人锐减到3万多人</li></ul></li><li>成果<ul><li>由张闻天代替博古负总的责任，毛泽东为周恩来在军事指挥上的帮助者</li><li>成立由<strong>毛泽东、周恩来、王稼祥</strong>组成的三人小组，<strong>负责全军的军事行动</strong></li></ul></li><li>意义<ul><li>党的历史上一个生死攸关的<strong>转折点</strong></li><li>确立了<strong>毛泽东</strong>在<strong>党中央和红军的领导地位</strong></li><li>开始确立以毛泽东为主要代表的<strong>马克思主义正确路线</strong>在<strong>党中央</strong>的领导地位</li><li>开始形成以毛泽东同志为核心的<strong>第一代中央领导集体</strong></li><li>在最危急关头<strong>挽救</strong>了党、挽救了红军、挽救了中国革命</li></ul></li></ul></li></ul><h1 id="第六章-中华民族的抗日战争">第六章 中华民族的抗日战争</h1><h2 id="九一八事变与七七事变">九一八事变与七七事变</h2><ul><li><strong>1931年9月18日 九一八事变</strong><ul><li>日本变中国为其<strong>独占殖民地</strong>的<strong>侵略战争</strong>由此<strong>开始</strong></li></ul></li><li><strong>1937年7月7日 卢沟桥事变（七七事变）</strong><ul><li>日本<strong>全面侵华战争</strong>由此开始</li></ul></li></ul><h2 id="西安事变及其和平解决">西安事变及其和平解决</h2><p>1936.12，西安事变的和平解决成为时局转换的枢纽，十年内战局面基本结束，<strong>国内和平初步实现</strong></p><h2 id="国共第二次合作">国共第二次合作</h2><ul><li>国民党中央通讯社发表中共中央的宣言《<strong>中共中央为公布国共合作宣言</strong>》</li><li>蒋介石承认共产党合法地位</li><li>意义<ul><li>以<strong>国共两党第二次合作</strong>为基础的<strong>抗日民族统一战线</strong>正式形成</li></ul></li></ul><h2 id="抗日战争各阶段">抗日战争各阶段</h2><ul><li>战略防御 1937.7.7 - 1938.10</li><li>战略相持 1938.10 - 1943.7</li><li>战略反攻 1943.7 - 1945.9</li></ul><h2 id="论持久战">论持久战</h2><p>1938.5-6，毛泽东发表《论持久战》，批驳了“亡国论”、“速胜论”等错误观点，系统阐明持久战方针。</p><h2 id="统一战线中的独立自主原则">统一战线中的独立自主原则</h2><p>由于国共两党代表不同阶级利益，参战目的不尽相同，实行抗战路线不同，统一战线内部存在矛盾和斗争。全民族抗战伊始，中共中央就提出必须在统一战线中坚持独立自主原则。</p><p>1944.9，中共参政员林伯渠在国民参政会上正式提出立即结束国民党一党统治，建立各抗日党派民主联合政府的主张</p><h2 id="新民主主义理论的系统阐明">新民主主义理论的系统阐明</h2><p>1939、1940年之交，毛泽东撰写《《共产党人》发刊词》、《中国革命和中国共产党》、《新民主主义论》等一批重要理论著作</p><h2 id="中共七大前的准备工作">中共七大前的准备工作</h2><ul><li>《关于若干历史问题的决议》：1944.5-1945.4，中共扩大的六届七中全会在延安召开，通过《决议》，为中共七大胜利召开创造充分条件</li><li><strong>中共七大和毛泽东思想指导地位的确立</strong>：1945.4-6，延安</li></ul><h2 id="抗日战争的胜利">抗日战争的胜利</h2><p>中国人民抗日战争的胜利，是近代以来中国人民反抗外敌入侵第一次取得完全胜利的民族解放斗争。</p><ul><li>抗日战争胜利的原因：<ol type="1"><li>爱国主义为核心的民族精神——决定性因素</li><li>中国共产党的中流砥柱作用——关键</li><li>全民族抗战——重要法宝</li><li>世界所有爱好和平和正义的国家、人民、国际组织以及各种反法西斯力量的同情和支持</li></ol></li><li>抗日战争胜利的意义：中华民族从近代以来陷入深重危机<strong>走向伟大复兴的历史转折点</strong><ol type="1"><li>彻底粉碎了日本军国主义殖民奴役中国的图谋，有力<strong>捍卫了国家主权和领土完整</strong>，彻底<strong>洗刷</strong>了近代以来抗击外来侵略屡战屡败的<strong>民族耻辱</strong></li><li>促进了中华民族的大团结，形成了<strong>伟大的抗战精神</strong></li><li>对世界各国夺取反法西斯战争的胜利，维护世界和平产生了巨大影响中国人民赢得了世界爱好和平人民的尊敬，中华民族赢得了崇高的民族声誉</li><li>坚定了中国人民追求民族独立、自由、解放的意志，开启了古老中国凤凰涅槃、浴火重生的历史新征程</li></ol></li></ul><h1 id="第七章-为建立新中国而奋斗">第七章 为建立新中国而奋斗</h1><h2 id="重庆谈判和政治协商会议">重庆谈判和政治协商会议</h2><ul><li>1945年8月28日<strong>重庆谈判</strong>，毛泽东、周恩来、王若飞赴重庆与国民党当局进行谈判</li><li>成果<ul><li>双方签署 <strong>双十协定</strong>：《政府与中共代表会谈纪要》</li><li>确认<strong>和平建国的基本方针</strong></li><li>同意“长期合作，坚决避免内战”</li></ul></li></ul><h2 id="国共全面内战">国共全面内战</h2><p>1946年6月，国民党挑起全面内战</p><h2 id="解放战争">解放战争</h2><ul><li>解放战争的阶段<ul><li>1947.6前 <strong>战略防御</strong></li><li>1947.6后 <strong>战略反攻</strong><ul><li>刘伯承、邓小平 千里跃进<strong>大别山</strong></li><li>陈毅、粟裕 挺进<strong>苏鲁豫皖</strong>地区</li><li>陈赓、谢富治 挺进<strong>豫西</strong></li></ul></li><li>1948秋 <strong>战略决战</strong><ul><li>1948.9-12 <strong>辽沈战役</strong></li><li>1948.11-1949.1 <strong>淮海战役</strong></li><li>1949.1-4 <strong>平津战役</strong></li><li>1949.4-6 <strong>渡江战役</strong></li></ul></li></ul></li><li>1947.10.10，中国人民解放军总部发表宣言：口号：“打倒蒋介石，解救全中国”极大鼓舞了解放军全体指战员和全国人民的斗志</li><li>配合人民解放战争的第二条战线：以学生运动为先导的人民民主运动（在国民党统治区）</li></ul><h2 id="土地改革运动">土地改革运动</h2><ul><li>1946年5月4日，中共中央发布《<strong>关于土地问题的指示</strong>》（<strong>五四指示</strong>）</li><li>1947年7月至9月，<strong>西柏坡</strong>，中国共产党召开<strong>全国土地会议</strong><ul><li>成果<ul><li>制定和通过了《<strong>中国土地法大纲</strong>》</li><li><strong>废除封建性</strong>及半封建性剥削的<strong>土地制度</strong></li><li>实行<strong>耕者有其田的土地制度</strong></li></ul></li><li>意义<ul><li>彻底反封建的土地革命纲领</li></ul></li></ul></li></ul><h1 id="第八章-中华人民共和国的成立与中国社会主义建设道路的探索">第八章中华人民共和国的成立与中国社会主义建设道路的探索</h1><h2 id="探索">探索</h2><ul><li>医疗卫生方面：党和政府提出卫生工作要“面向工农兵”、“预防为主”、“团结中西医”方针</li><li>三反运动：1951-1952，反贪污、反浪费、反官僚主义（新中国成立后党高度重视执政条件下党组织的自身建设）</li></ul><h2 id="党在过渡时期的总路线">党在过渡时期的总路线</h2><p>1953年正式提出<strong>党在过渡时期的总路线</strong>：<strong>一化三改</strong></p><ul><li>逐步实现国家的<strong>社会主义工业化</strong></li><li>逐步实现国家对<strong>农业</strong>、对<strong>手工业</strong>和对<strong>资本主义工商业</strong>的<strong>社会主义改造</strong></li></ul><p>又称“一体两翼”：“一化”是主体，“三改”是两翼</p><h2 id="社会主义改造的基本完成">社会主义改造的基本完成</h2><ul><li>1954.9，全国一大讨论通过《中华人民共和国宪法》（五四宪法）<ul><li>社会主义类型的宪法，提现人民民主原则、社会主义原则</li></ul></li><li>1956年社会主义改造的基本完成，标志着社会主义基本制度的确立。</li><li>中国走社会主义道路具有历史必然性：<ul><li>因为社会主义是马克思主义的社会理想。</li><li>社会主义是中国共产党自创立时就确定的奋斗目标。</li><li>新民主主义的前途必然是社会主义。</li><li>实现社会主义工业化，必须走社会主义道路。</li><li>当时的国际环境也促使中国选择社会主义。</li></ul></li></ul><h2 id="社会主义基本制度确立的伟大意义">社会主义基本制度确立的伟大意义</h2><ol type="1"><li>极大提高工人阶级和广大劳动人民的积极性、创造性，为社会生产力大力发展开辟广阔道路</li><li>为当代中国一切发展进步提供根本政治保障</li></ol><h1 id="第九章-改革开放与中国特色社会主义的开创和发展">第九章改革开放与中国特色社会主义的开创和发展</h1><ul><li>1981.6，党的十一届六中全会通过《关于建国以来的党的若干历史问题的决议》</li><li>1982.9，中国共产党第十二次全国代表大会在北京举行。邓小平在开幕词中响亮提出“把马克思主义的普遍真理同我国的具体实际结合起来，走自己的道路，建设有中国特色的社会主义”。</li><li>1992，下半年中共十四大召开之前，邓小平南方谈话提出“社会主义市场经济体制”</li><li>1992.10.12-18，中共十四大：确定我国经济体制改革的目标是建立社会主义市场经济体制</li><li>2017.10，中共十九大北京召开，通过《中国共产党章程（修正案）》，把习近平新时代中国特色社会主义思想同马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观一道确立为党的行动指南，充分体现了党的十八大以后党的理论创新、实践创新、制度创新成果，充分体现了党的十九大报告确立的重大理论观点和重大战略思想。</li></ul><h1 id="第十章-中国特色社会主义进入新时代">第十章中国特色社会主义进入新时代</h1><p>党的二十大强调，新时代新征程中国共产党的中心任务就是</p><ul><li>团结带领全国各族人民<strong>全面建成社会主义现代化强国</strong></li><li><strong>实现第二个百年奋斗目标</strong></li><li><strong>以中国式现代化全面推进中华民族伟大复兴</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>中国近现代史纲要</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>军事理论</title>
    <link href="/posts/%E5%86%9B%E4%BA%8B%E7%90%86%E8%AE%BA/"/>
    <url>/posts/%E5%86%9B%E4%BA%8B%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本笔记基于上海交通大学 <em>闫成老师</em> 2023-2024学年秋季学期教学内容进行整理</p></blockquote><h1 id="第一章-中国国防">第一章 中国国防</h1><h2 id="国防概述">国防概述</h2><ul><li>国防的含义：国家为抵御外来侵略与颠覆，捍卫国家主权、领土完整，维护国家安全、统一和发展，而进行的军事及与军事有关的政治、经济、科技、文化、教育、外交等方面的活动。</li><li>国防的目的：<ul><li><strong>捍卫国家主权</strong>（首要）</li><li>保卫国家的统一、领土完整</li><li>维护国家安全与稳定</li></ul></li><li>现代国防的基本类型<ul><li>扩张型（美国）</li><li>自卫型（中国）</li><li>联盟型（美日、北约）</li><li>中立型（瑞士）。</li></ul></li><li>中国国防历史<ul><li>兵役制度的发展（奴隶制民军制度–封建社会相适应的兵役制度）。</li><li>新时代<strong>防御型</strong>国防政策：国防和军队建设战略目标（三步走，2020年基本实现机械化、2035年基本实现现代化、本世纪中叶全面建成世界一流军队）、服务构建人类命运共同体（一支强大的中国军队，是维护世界和平稳定、服务构建人类命运共同体的坚定力量）。</li></ul></li></ul><h2 id="国防建设">国防建设</h2><ul><li>国防建设的领导体制（五级领导体制）<ul><li>中共中央</li><li>全国人民代表大会及其常务委员会</li><li>国家主席</li><li>国务院</li><li>中央军事委员会在国防方面的职权</li></ul></li><li>国防建设发展<ul><li>1964年10月16日，我国第一颗原子弹爆炸成功。</li><li>第六阶段新要求：<ul><li>坚持以国家核心安全需求为导向，统筹经济建设和国防建设，实现富国和强军的统一。</li><li>确立新时代强军目标。</li><li>重新调整军队规模结构和力量编成。</li><li>确立军民深度融合发展战略。</li></ul></li></ul></li><li>国防建设取得的新成就<ul><li>有效履行新的历史使命（圆满完成非战争军事行动任务属于国防成就）。</li><li>军队信息化建设迈上新台阶。</li><li>形成<strong>军委——军种——部队</strong>的领导管理体系。</li><li>构建军队院校教育、部队训练实践、军事职业教育“三位一体”的新型军事人才培养体系。</li><li>国防科技和武器装备跨越发展。</li><li>国防科技工业军民融合蓬勃发展。</li></ul></li></ul><h2 id="武装力量">武装力量</h2><ul><li>组成：<ul><li>中国人民解放军现役部队和预备役部队</li><li>中国人民武装警察部队</li><li>民兵</li></ul></li><li>组织：<ul><li><strong>领导管</strong>理上实行军委——军种——部队体系</li><li><strong>联合作战指挥</strong>上实行军委——战区——部队体系</li></ul></li><li>军种：<ul><li>陆军</li><li>海军</li><li>空军</li><li>火箭军</li><li>战略支援部队</li><li>联勤保障部队</li></ul></li><li>战区：是本战略方向的唯一最高联合作战指挥机构<ul><li>东部战区</li><li>南部战区</li><li>西部战区</li><li>北部战区</li><li>中部战区</li></ul></li><li>陆军以原18个集团军为基础，调整组建<strong>13</strong>个集团军。</li><li>2012年9月，辽宁号航空母舰列装海军服役（第一艘国产航母为山东号，电磁弹射航母为福建号）。</li><li>火箭军、海军潜地战略导弹部队和空军战略轰炸机部队构成我国三位一体的<strong>战略核力量</strong>。</li><li>战略支援部队是维护国家安全的新型作战力量，是我军新质作战能力的<strong>重要增长点</strong>；是由战略性基础性支撑性都很强的各类保障力量进行功能整合后组建而成的，其主要目的是优化军事力量、提高综合保障能力，为联合作战提供有效支撑。</li><li>武装警察部队由党中央、中央军委集中统一领导，实行中央军委——武警部队——部队领导指挥体制。</li></ul><h2 id="国防动员">国防动员</h2><ul><li>国防动员的含义：国家或政治集团由平时状态转入战时状态，统一调动人力、物力、财力为战争服务的措施。</li><li>国民<strong>经济</strong>动员是战争动员的<strong>基础</strong>。</li></ul><h2 id="国防法规">国防法规</h2><ul><li>《兵役法》规定：我国实行<strong>以志愿兵役为主体</strong>的<strong>志愿兵役与义务兵役相结合</strong>的兵役制度。</li><li>《国防教育法》规定：每年9月第三个星期六为全民国防教育日。</li></ul><h1 id="第二章-国家安全">第二章 国家安全</h1><h2 id="国家安全概述">国家安全概述</h2><ul><li>总体国家安全观<ul><li><strong>以人民安全为宗旨，以政治安全为根本，以经济安全为基础，以军事、文化、社会安全为保障，以促进国际安全为依托</strong>（2014年，习近平提出）。<ul><li>政治安全在国家安全体系中居<strong>核心地位</strong>和<strong>最高层次</strong>，具有根本性战略意义。<br></li><li>生态安全指生态系统完整性和健康的整体水平，尤其是生存与发展的不良风险最小及不受威胁的状态。<br></li><li>生物安全一般指现代生物技术开发和应用对生态环境和人体健康造成的潜在威胁及预防控制措施（与生态安全区分）。</li></ul></li></ul></li></ul><h2 id="国家安全形势">国家安全形势</h2><ul><li>地缘环境基本概况：东部有960万平方公里陆地疆土（世界第三），-2万多公里陆地边界线，与14个国家接壤；300多万平方公里大陆架及专属经济区海洋面积，海岸疆线总长-2万公里（大陆海岸线约-8万公里+岛屿海岸线约-4万公里）。<br></li><li>边界领土争端仍存在，解决难度大，我国与<strong>印度</strong>和<strong>不丹</strong>的陆地边界尚未正式划定。<br></li><li>南海问题涉及“六国七方”权益争端，我国主张“<strong>主权归我，搁置争议</strong>”。<br></li><li>新兴领域国家安全：太空安全、深海安全、极地安全、<strong>网络安全</strong>。</li></ul><h2 id="国际战略局势">国际战略局势</h2><ul><li>美国武装力量特点：文官控制军队，行政领导与作战指挥分离。<br></li><li>美国现行军事战略：新版《印太战略》，以遏制中国崛起为目的。</li></ul><h2 id="中国倡导的新安全观">中国倡导的新安全观</h2><ul><li>共同安全、综合安全、合作安全、可持续安全。</li></ul><h1 id="第三章-军事思想">第三章 军事思想</h1><h2 id="军事思想概述">军事思想概述</h2><ul><li>军事思想含义<ul><li>军事思想是关于战争、军队和国防基本问题的理性认识，属社会意识形态范畴。<br></li></ul></li><li>军事思想基本特征<ul><li>鲜明的阶级性</li><li>强烈的时代性</li><li>明显的继承性</li><li>显著的实践性</li></ul></li></ul><h2 id="外国军事思想">外国军事思想</h2><ul><li>资产阶级军事思想的著名代表人物及其主要观点<br></li><li>拿破仑：重视武力和思想双重作用，重视军队改革和建设。<br></li><li>克劳塞维茨：战争为政治服务，进攻和防御是战争的两种基本作战形式。<br></li><li>若米尼：战略是进行战争的科学，战术是进行战斗的科学。<br></li><li>毛奇：重视铁路、电报等新技术在军事上的运用。<br></li><li>马汉：“海军制胜论”。<br></li><li>杜黑：制空权理论，空中战争论。<br></li><li>富勒：机械化战争。</li></ul><h2 id="中国古代军事思想">中国古代军事思想</h2><ul><li>《尉缭子》：“故兵者，所以诛暴乱，禁不义也”，认为战争作用是镇压暴乱、制止不义行为。<br></li><li>《孙子兵法》：<ul><li>“凡战者，以正合，以奇胜。故善出奇者，无穷如天地，不竭如江河”——奇正互变。<br></li><li>“兵之情主速，乘人之不及”“久暴师则国用不足”“久则钝兵挫锐”“故兵贵胜，不贵久”——速战速决。<br></li><li>“夫用兵之法，全国为上，破国次之；全军为上，破军次之……不战而屈人之兵，善之善者也”——以全征胜，不战而屈人之兵的战略思想。<br></li><li>“善战者，致人而不致于人”——争取战争主动权。</li></ul></li></ul><h2 id="中国当代军事思想">中国当代军事思想</h2><ul><li>毛泽东军事思想：<ul><li><strong>三湾改编</strong>为毛泽东建设人民军队的思想开始形成奠定基础。<br></li><li>十大军事原则、“<strong>两弹一星</strong>”（核弹、导弹和人造卫星）。<br></li><li>人民军队三大任务：战斗队、工作队、生产队。<br></li><li>人民军队三大民主：政治民主、经济民主、军事民主。<br></li><li>政治工作三大原则：官兵一致、军民一致、瓦解敌军。<br></li><li>三大纪律：一切行动听指挥、不拿群众一针一线、一切缴获要归公。</li><li>人民战争属性：群众性、正义性、组织性。</li><li>人是战争胜负的<strong>决定因素</strong>，武器是战争的<strong>重要因素</strong>。</li><li><strong>歼灭战</strong>是基本作战方针。</li><li>三种作战形式（运动战、阵地战、游击战）密切配合并实时转换。</li></ul></li><li>邓小平新时期军队建设思想：建设一支革命化、现代化、正规化的革命军队（三化建设）。</li><li>江泽民国防和军队建设思想：<ul><li>党对军队的绝对领导是我军永远不变的<strong>军魂</strong>。</li><li>围绕“打得赢、不变质”两个历史性课题推进军队建设。</li></ul></li><li>习近平强军思想：<ul><li>强军目标：建设听党指挥、能打胜仗、作风优良的人民军队（<strong>听党指挥是灵魂，能打胜仗是核心，作风优良是保证</strong>）。</li><li>强调依法治军是党建军治军的基本方式。</li></ul></li></ul><h1 id="第四章-现代战争">第四章 现代战争</h1><h2 id="现代战争概述">现代战争概述</h2><ul><li>战争的本质<ul><li>战争是政治的继续，战争形态演变但本质不变。</li></ul></li></ul><h2 id="新军事革命">新军事革命</h2><ul><li>信息化军事革命<ul><li>催生信息化战争（信息时代基本战争形态）。</li></ul></li><li>新军事革命<ul><li>酝酿准备时期为20世纪80年代末，1991年海湾战争有昭示作用。<br></li></ul></li><li>作战样式新类型<ul><li>非对称作战和非接触作战。</li></ul></li></ul><h2 id="机械化战争">机械化战争</h2><ul><li>如苏德战争中的莫斯科战役、斯大林格勒战役胜利。</li></ul><h2 id="信息化战争">信息化战争</h2><ul><li>信息时代<ul><li>信息成为部队战斗力核心要素，<strong>制信息权</strong>是未来战场之“魂”。</li></ul></li><li>数字化部队特点<ul><li>指挥控制灵活、消息传递实时、部队行动快速、武器反应迅速。</li></ul></li><li>信息化战争基本特征<ul><li>战场空间多维化、作战要素一体化。</li></ul></li></ul><h1 id="第五章-信息化装备">第五章 信息化装备</h1><h2 id="信息化装备概述">信息化装备概述</h2><ul><li>信息化装备对现代战争的影响<ul><li>侦察立体化、反应快速化、打击精确化、防护综合化、控制智能化。<br></li></ul></li><li>信息化作战平台发展趋势<ul><li>隐形化、多功能化、无人化。</li></ul></li><li>信息化弹药发展趋势<ul><li>灵巧型、智能性。</li></ul></li></ul><h2 id="信息化作战平台">信息化作战平台</h2><ul><li>坦克<ul><li>具有强大直射火力、高度越野机动性和装甲防护力的履带式装甲战斗车辆（如美国M-1“阿布拉姆斯”、俄罗斯T-90、中国99式）。</li></ul></li><li>海上作战平台<ul><li>在海洋范围活动的舰艇，如航空母舰、潜艇。</li></ul></li><li>信息化空中作战平台<ul><li>战斗机、轰炸机、预警机、空中加油机、直升机、军用运输机。</li></ul></li></ul><h2 id="综合电子信息系统">综合电子信息系统</h2><ul><li>情报侦察系统<ul><li>组成：<ul><li>战略、战役、战术情报侦察系统</li><li>谍报人员和人民群众情报侦察系统</li><li>电子战情报侦察系统</li></ul></li><li>分类：航天、航空、海上及水下、地面侦察系统。</li></ul></li><li>卫星导航系统<ul><li>美国GPS、俄罗斯GLONASS、欧洲伽利略、中国北斗。</li></ul></li></ul><h2 id="信息化杀伤武器">信息化杀伤武器</h2><ul><li>精准制导武器<ul><li>采用精确制导技术，直接命中率50%以上的武器</li></ul></li><li><strong>精准制导方式</strong>：<ul><li>自主制导（惯性、地形匹配、数字景象匹配、卫星定位）</li><li>寻的制导（主动、半主动、被动）、遥控制导（指令、波束）</li><li>复合制导</li></ul></li><li>精确制导弹药：<ul><li>末制导弹药</li><li>末敏弹药</li></ul></li><li>精确制导特点：<ul><li>命中精度高、作战效能高、远程突防能力强、作战效费比高。</li></ul></li><li>核武器<ul><li>原子弹（裂变）、氢弹（聚变）、中子弹（利用聚变效应）。</li></ul></li><li>新概念武器<ul><li>激光武器：烧蚀效应、激波效应、辐射效应。</li><li>粒子束武器、微波武器、动能武器、气象武器、非致命武器、基因武器、纳米武器。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>SJTU Notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SJTU</tag>
      
      <tag>军事理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
