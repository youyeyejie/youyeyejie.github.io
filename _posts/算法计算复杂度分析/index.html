

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><!-- hexo injector head_begin start --><meta name="msvalidate.01" content="DF9F232801BA9D0CABB002E4774A3228"/><meta name="google-site-verification" content="vOm5Zs9tuUlEh-wVBlpvs_spnOou-q2CoTiFQ1ZV1h4"/><script defer src="https://cloud.umami.is/script.js" data-website-id="0369421f-4354-4d7b-99c7-ae077c591b4f"></script><!-- hexo injector head_begin end -->
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar/avatar2.webp">
  <link rel="icon" href="/img/avatar/avatar2.webp">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="youyeyejie">
  <meta name="keywords" content="yyyj,YYYJ,youyeyejie,有野野芥">
  
    <meta name="description" content="NIS3355 算法计算复杂度分析 笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="算法计算复杂度分析">
<meta property="og:url" content="https://youyeyejie.github.io/_posts/%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="有野野芥的博客">
<meta property="og:description" content="NIS3355 算法计算复杂度分析 笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youyeyejie.github.io/img/cover/nis3355.webp">
<meta property="article:published_time" content="2026-01-11T05:41:02.000Z">
<meta property="article:modified_time" content="2026-02-08T13:25:14.916Z">
<meta property="article:author" content="youyeyejie">
<meta property="article:tag" content="SJTU">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://youyeyejie.github.io/img/cover/nis3355.webp">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>算法计算复杂度分析 - 有野野芥的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">
<link rel="stylesheet" href="//lib.baomitu.com/font-awesome/6.1.2/css/all.min.css">


<link  rel="stylesheet" href="/css/main.css" />




  
<link rel="stylesheet" href="/css/Background.css">
<link rel="stylesheet" href="/css/CodeBlock.css">
<link rel="stylesheet" href="/css/CodeInLine.css">
<link rel="stylesheet" href="/css/Crypto.css">
<link rel="stylesheet" href="/css/Gallery.css">
<link rel="stylesheet" href="/css/IndexImgHover.css">
<link rel="stylesheet" href="/css/LinkCard.css">
<link rel="stylesheet" href="/css/ScrollAnimation.css">
<link rel="stylesheet" href="/css/ScrollBar.css">
<link rel="stylesheet" href="/css/StrongInDark.css">
<link rel="stylesheet" href="/css/TitleGradient.css">
<link rel="stylesheet" href="/css/Tooltip.css">
<link rel="stylesheet" href="/css/UnifyImgWidth.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"youyeyejie.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":false,"default":"TEXT"},"copy_btn":false,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading/loading3.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style>
    <style>
    .code-expand-btn:not(.expand-done) ~ div.codeblock,
    .code-expand-btn:not(.expand-done) ~ * div.codeblock {
      overflow: hidden;
      height: 360px;
    }
    </style>
  <!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><div id="tooltip" class="tooltip"></div><!-- hexo injector body_begin end -->
  <div id="loader-container"> 
    <div id="loader" class="loader"></div>
    <div class="loader-inner">
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
    </div>
</div>

<script src="/js/RainbowLoading.js" type="text/javascript"></script>
<link href="/css/RainbowLoading.css" type="text/css" rel="stylesheet"/><div id="rightmenu-wrapper">
  <ul class="list-v rightmenu" id="rightmenu-content">
	    <li class="navigation menuNavigation-Content">
            <a class="nav icon-only fix-cursor-default" aria-label="back" onclick="history.back()"><i class="fa-solid fa-chevron-left"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="forward" onclick="history.forward()"><i class="fa-solid fa-chevron-right"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="reload" onclick="window.location.reload()"><i class="fa-solid fa-rotate-right"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="top" onclick="scrollToTopSmooth();"><i class="fa-solid fa-chevron-up"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="bottom" onclick="scrollToBottomSmooth();"><i class="fa-solid fa-chevron-down"></i></a>
	    </li>

        <hr class="menuLoad-Content" style="display: block;" id="top-line">

        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="copyLink();">
                <span>
                    <i class="fa-solid fa-link"></i>
                    复制链接
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="copy-selected-text" hidden>
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="copySelectedText();">
                <span>
                    <i class="fa-solid fa-copy"></i>
                    &nbsp;复制选中
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="search-selected-text-BING" hidden>
            <a class="vlts-menu fix-cursor-default" target="_blank" onclick="searchSelectedTextBing();">
                <span>
                    <i class="fa-solid fa-magnifying-glass-arrow-right"></i>
                    &nbsp;必应搜索
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="go-to-link" hidden>
            <a class="vlts-menu fix-cursor-default" target="_blank">
                <span>
                    <i class="fa-solid fa-arrow-up-right-from-square" style="margin-right: 1px;"></i>
                    &nbsp;打开链接
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="download-image" hidden>
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="downloadImage();">
                <span>
                    <i class="fa-solid fa-image"></i>
                    &nbsp;下载图片
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="copy-image-link" hidden>
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="copyImageLink();">
                <span>
                    <i class="fa-solid fa-link"></i>
                    复制图片链接
                </span>
            </a>
        </li>

		<hr class="menuLoad-Content" style="display: block;">

        <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" onclick="RandomGo()">
		        <span>
			        <i class="fa-solid fa-paper-plane"></i>
                    &nbsp;随便看看
		        </span>
		    </a>
	    </li>
	    <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
		        <span>
			        <i class="fa-solid fa-magnifying-glass"></i>
                    &nbsp;站内搜索
		        </span>
		    </a>
	    </li>
        <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" href="/categories/">
		        <span>
			        <i class="iconfont icon-category-fill"></i>
                    &nbsp;博客分类
		        </span>
		    </a>
	    </li>
        <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" href="/tags/">
		        <span>
			        <i class="fa-solid fa-tags"></i>
                    &nbsp;文章标签
		        </span>
		    </a>
	    </li>
        
	    <hr class="menuLoad-Content" style="display: block;">

        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="toggle-color-mode" target="_self" onclick="toggleColorMode();">
                <span>
                    <i id="toggle-color-mode-icon" class="fa-solid fa-circle-half-stroke"></i>
                    &nbsp;切换昼夜
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="random-change-background" target="_self" onclick="randomChangeBackground();">
                <span style="margin-left: 1px;">
                    <i id="random-change-background-icon" class="fa-solid fa-image"></i>
                    &nbsp;切换背景
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="toggle-background-mode" target="_self" onclick="toggleBackgroundMode();">
                <span>
                    <i id="toggle-background-mode-icon" class="fa-solid fa-toggle-on" style="margin-right: -1px;"></i>
                    &nbsp;全屏背景
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="toggle-reading-mode" target="_self" onclick="toggleReadingMode();">
                <span>
                    <i id="toggle-reading-mode-icon" class="fa-solid fa-toggle-off" style="margin-right: -1px;"></i>
                    &nbsp;阅读模式
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="toggle-tab-display" target="_self" onclick="toggleTabDisplay();">
                <span>
                    <i id="toggle-tab-display-icon" class="fa-solid fa-toggle-on" style="margin-right: -1px;"></i>
                    &nbsp;自定义标签
                </span>
            </a>
        </li>
    </ul>
</div>


<script src="/js/RightMenu.js" type="text/javascript"></script>
<link href="/css/RightMenu.css" type="text/css" rel="stylesheet"/>

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <!-- <strong>YYYJ&#39;s Blog</strong> -->
       <strong class="navbar-title">YYYJ&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://www.travellings.cn/go-by-clouds.html" target="_self">
                <i class="fas fa-train-subway"></i>
                <span>开往</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="fa-solid fa-folder-open"></i>
                <span>更多</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/" target="_self">
                    <i class="iconfont icon-archive-fill"></i>
                    <span>归档</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/" target="_self">
                    <i class="fa-solid fa-tags"></i>
                    <span>标签</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/links/" target="_self">
                    <i class="iconfont icon-link-fill"></i>
                    <span>友链</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/DayDream-Gallery/" target="_self">
                    <i class="fas fa-images"></i>
                    <span>图集</span>
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner/random.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="算法计算复杂度分析"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        youyeyejie
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2026-01-11 13:41" pubdate>
          2026年1月11日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          217 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="SJTU Notes"
        id="heading-23fc8849f7fe9b9a570be52f7807b4ac" role="tab" data-toggle="collapse" href="#collapse-23fc8849f7fe9b9a570be52f7807b4ac"
        aria-expanded="true"
      >
        SJTU Notes
        <span class="list-group-count">(24)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-23fc8849f7fe9b9a570be52f7807b4ac"
           role="tabpanel" aria-labelledby="heading-23fc8849f7fe9b9a570be52f7807b4ac">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="信安"
        id="heading-cffe32285a0c065bb2a100ac3411f2b7" role="tab" data-toggle="collapse" href="#collapse-cffe32285a0c065bb2a100ac3411f2b7"
        aria-expanded="false"
      >
        信安
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-cffe32285a0c065bb2a100ac3411f2b7"
           role="tabpanel" aria-labelledby="heading-cffe32285a0c065bb2a100ac3411f2b7">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/" title="网络空间安全导论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">网络空间安全导论</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/" title="抽象代数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">抽象代数</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/" title="现代密码学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">现代密码学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" title="系统安全"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">系统安全</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="其他"
        id="heading-0d98c74797e49d00bcc4c17c9d557a2b" role="tab" data-toggle="collapse" href="#collapse-0d98c74797e49d00bcc4c17c9d557a2b"
        aria-expanded="false"
      >
        其他
        <span class="list-group-count">(3)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-0d98c74797e49d00bcc4c17c9d557a2b"
           role="tabpanel" aria-labelledby="heading-0d98c74797e49d00bcc4c17c9d557a2b">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E5%86%9B%E4%BA%8B%E7%90%86%E8%AE%BA/" title="军事理论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">军事理论</span>
        </a>
      
    
      
      
        <a href="/_posts/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/" title="量子力学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">量子力学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%95%B0%E5%AD%A6%E5%8F%B2/" title="数学史"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数学史</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="数学"
        id="heading-6e65831863dbf272b7a65cd8df1a440d" role="tab" data-toggle="collapse" href="#collapse-6e65831863dbf272b7a65cd8df1a440d"
        aria-expanded="false"
      >
        数学
        <span class="list-group-count">(5)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-6e65831863dbf272b7a65cd8df1a440d"
           role="tabpanel" aria-labelledby="heading-6e65831863dbf272b7a65cd8df1a440d">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="线性代数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">线性代数</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/" title="概率统计"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">概率统计</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">离散数学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="信息论基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">信息论基础</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/" title="抽象代数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">抽象代数</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="红课"
        id="heading-d8a06b9d7f3a9a1c8566414f651abd41" role="tab" data-toggle="collapse" href="#collapse-d8a06b9d7f3a9a1c8566414f651abd41"
        aria-expanded="false"
      >
        红课
        <span class="list-group-count">(5)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-d8a06b9d7f3a9a1c8566414f651abd41"
           role="tabpanel" aria-labelledby="heading-d8a06b9d7f3a9a1c8566414f651abd41">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/" title="中国近现代史纲要"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">中国近现代史纲要</span>
        </a>
      
    
      
      
        <a href="/_posts/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3%E6%A6%82%E8%AE%BA/" title="习近平新时代中国特色社会主义思想概论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">习近平新时代中国特色社会主义思想概论</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/" title="思想道德与法治"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">思想道德与法治</span>
        </a>
      
    
      
      
        <a href="/_posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="马克思主义基本原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">马克思主义基本原理</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E6%80%9D%E6%83%B3%E5%92%8C%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB%E6%A6%82%E8%AE%BA/" title="毛泽东思想和中国特色社会主义理论体系概论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">毛泽东思想和中国特色社会主义理论体系概论</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="计科"
        id="heading-d693442450db119d90f9261fa53eb2f7" role="tab" data-toggle="collapse" href="#collapse-d693442450db119d90f9261fa53eb2f7"
        aria-expanded="true"
      >
        计科
        <span class="list-group-count">(10)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-d693442450db119d90f9261fa53eb2f7"
           role="tabpanel" aria-labelledby="heading-d693442450db119d90f9261fa53eb2f7">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数据结构</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">离散数学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" title="计算机组成与系统结构"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">计算机组成与系统结构</span>
        </a>
      
    
      
      
        <a href="/_posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="信息论基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">信息论基础</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">编译原理</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="操作系统原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统原理</span>
        </a>
      
    
      
      
        <a href="/_posts/%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E5%8F%8A%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/" title="安全模型开发及安全编程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">安全模型开发及安全编程</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E5%85%A8/" title="数据库原理及安全"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数据库原理及安全</span>
        </a>
      
    
      
      
        <a href="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C/" title="计算机通信网络"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">计算机通信网络</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/" title="算法计算复杂度分析"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">算法计算复杂度分析</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">算法计算复杂度分析</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>本笔记基于上海交通大学 <em>刘盛云老师</em> 2025-2026
学年秋季学期教学内容及课件进行整理，部分图片来源于网络，如有侵权请联系删除。</p>
</blockquote>
<h1 id="算法计算复杂度分析概论">算法（计算）复杂度分析概论</h1>
<h2 id="基本概念">基本概念</h2>
<h3 id="算法定义">算法定义</h3>
<ul>
<li>An algorithm is any well-defined computational
<strong>procedure</strong> that takes some value, or set of values, as
input and produces some value, or set of values, as output in a finite
amount of
time（算法是指任何明确定义的计算过程，该过程在有限时间内将某个值或一组值作为输入，并产生某个值或一组值作为输出）</li>
<li>An algorithm is a sequence of computational steps that transform the
input into the output（算法是将输入转化为输出的一系列计算步骤）</li>
</ul>
<h3 id="算法正确性">算法正确性</h3>
<ul>
<li>An algorithm for a computational problem is correct if,
<ul>
<li>for every problem instance provided as input, it halts – finishes
its computing in finite time
(liveness)（对于每个作为输入提供的问题实例，算法都能在有限时间内停止计算——完成其计算）</li>
<li>and outputs the correct solution to the problem instance
(safety)（并输出问题实例的正确解决方案）</li>
</ul></li>
</ul>
<h3 id="算法效率">算法效率</h3>
<ul>
<li>Complexity analysis: determines the amount of resources required to
execute an algorithm（决定了执行算法所需的资源量）
<ul>
<li>Computational time</li>
<li>Memory</li>
<li>Communication bandwidth （communication complexity）</li>
<li>Energy consumption</li>
</ul></li>
<li>Goal: finding the “best” solution among a group of candidates</li>
</ul>
<h2 id="算法分类">算法分类</h2>
<h3 id="顺序算法-sequential-algorithms">顺序算法 (Sequential
Algorithms)</h3>
<ul>
<li>An algorithm that is executed sequentially - once through, from
start to finish, without other
processing（顺序执行的算法——从开始到结束一次性执行，没有其他处理）</li>
<li>No concurrency（无并发）</li>
<li>Techniques
<ul>
<li>Divide-and-Conquer（分治法）</li>
<li>Dynamic Programming（动态规划）</li>
<li>Greedy Algorithms（贪心算法）</li>
</ul></li>
<li>Algorithms
<ul>
<li>Graph Algorithms（图算法）
<ul>
<li>Minimum Spanning Trees（最小生成树）</li>
<li>(Single-source) Shortest Paths（单源最短路径）</li>
</ul></li>
</ul></li>
<li>NP-Completeness problems（NP 完全性问题）
<ul>
<li>Traveling-salesperson problem（旅行商问题）</li>
</ul></li>
</ul>
<h3 id="分布式算法-distributed-algorithms">分布式算法 (Distributed
Algorithms)</h3>
<ul>
<li>Algorithms used in distributed systems（分布式系统中使用的算法）
<ul>
<li>In contrast to sequential algorithms for centralized
systems（与集中式系统的顺序算法相对）</li>
<li>distributed system: a set of processes/nodes seeking to achieve some
common goal by communicating with each
other（分布式系统：一组进程/节点通过相互通信寻求实现某个共同目标）</li>
</ul></li>
<li>常见分布式系统类型
<ul>
<li>Client - server interactions（客户端-服务器交互）</li>
<li>Peer-to-peer systems（点对点系统）</li>
<li>Cloud computing systems（云计算系统）</li>
</ul></li>
<li>Basic abstractions
<ul>
<li>Timing assumption（时序假设）
<ul>
<li>Synchronous systems（同步系统）</li>
<li>Asynchronous systems（异步系统）</li>
</ul></li>
<li>Fault detection（故障检测）</li>
<li>Leader election（领导者选举）</li>
</ul></li>
<li>Broadcast
<ul>
<li>Reliable broadcast（可靠广播）</li>
<li>Causal-order broadcast（因果顺序广播）</li>
</ul></li>
<li>Consensus（共识）
<ul>
<li>Paxos</li>
</ul></li>
</ul>
<h2 id="算法复杂度分析-complexity-analysis">算法复杂度分析 (Complexity
Analysis)</h2>
<h3 id="增长量级-order-of-growth">增长量级 (Order of growth)</h3>
<ul>
<li>To ease the analysis of any algorithm, consider <strong>only the
leading term</strong> of a
formula（为了简化对算法的分析，仅考虑公式的最高阶项）</li>
<li>Ignore the leading term’s constant
coefficient（忽略最高阶项的常数系数）</li>
<li>Consider one algorithm to be more efficient than another if its
worst-case running time has a lower order of
growth（如果一个算法的最坏情况运行时间具有较低的增长量级，则认为它比另一个算法更高效）</li>
</ul>
<h3 id="渐进符号-asymptotic-notations">渐进符号 (Asymptotic
Notations)</h3>
<p><img src="image.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h4 id="上界-upper-bound">上界 (Upper Bound)</h4>
<ul>
<li><span class="math inline">\(O\)</span> notation: characterizes an
<strong>upper bound</strong> on the asymptotic behavior of a
function（描述函数渐近行为的上界）
<ul>
<li>a function grows no faster than a certain
rate（函数的增长速度不超过某个速率）</li>
</ul></li>
<li>符号表示: <span class="math display">\[
  f (n) = O (g (n))
  \]</span></li>
<li>定义： <span class="math display">\[
  \exists c &gt; 0, n_0 &gt; 0, \forall n \geq n_0,~ 0 \leq f(n) \leq
cg(n)
  \]</span></li>
</ul>
<h4 id="下界-lower-bound">下界 (Lower Bound)</h4>
<ul>
<li><span class="math inline">\(\Omega\)</span> notation: characterizes
a <strong>lower bound</strong> on the asymptotic behavior of a
function（描述函数渐近行为的下界）
<ul>
<li>a function grows at least as fast as a certain
rate（函数的增长速度至少与某个速率一样快）</li>
</ul></li>
<li>符号表示: <span class="math display">\[
  f(n) = \Omega (g(n))
  \]</span></li>
<li>定义： <span class="math display">\[
  \exists c &gt; 0, n_0 &gt; 0, \forall n \geq n_{0}, ~0 \leq cg(n) \leq
f(n)
  \]</span></li>
</ul>
<h4 id="紧确界-tight-bound">紧确界 (Tight Bound)</h4>
<ul>
<li><span class="math inline">\(\Theta\)</span> notation: characterizes
a <strong>tight bound</strong> on the asymptotic behavior of a
function（描述函数渐近行为的紧确界）
<ul>
<li>a function grows precisely at a certain rate on the highest-order
term（函数在最高阶项上以某个速率精确增长）</li>
</ul></li>
<li>符号表示: <span class="math display">\[
  f(n) = \Theta (g(n))
  \]</span></li>
<li>定义： <span class="math display">\[
  \exists c_{1} &gt; 0, c_{2} &gt; 0, n_0 &gt; 0, \forall n \geq n_{0},
~0 \leq c_{1}g(n) \leq f(n) \leq c_{2}g(n)
  \]</span></li>
<li>For any two functions <span class="math inline">\(f(n)\)</span> and
<span class="math inline">\(g(n)\)</span>, we have <span class="math display">\[
  f (n) = \Theta (g (n)) \Leftrightarrow
  \begin{cases}
  f (n) = O (g (n))\\
  f (n) = \Omega (g (n))
  \end{cases}
  \]</span></li>
</ul>
<h2 id="npc-问题np-complete-problems">NPC 问题（NP-Complete
Problems）</h2>
<h3 id="定义">定义</h3>
<ul>
<li><p><strong>P</strong>: The class P consists of those problems that
are <strong>solvable</strong> in polynomial
time（多项式时间内可解的问题类）</p></li>
<li><p><strong>NP</strong>: The class NP consists of those problems that
are <strong>verifiable</strong> in polynomial
time（多项式时间内可验证的问题类）</p>
<ul>
<li>Given a certificate, verify that the certificate is correct in
polynomial time（给定一个解答，在多项式时间内验证该解答是否正确）</li>
<li>Any problem in P also belongs to NP：<span class="math inline">\(P
\subseteq NP\)</span>（P 类中的任何问题也属于 NP 类）</li>
</ul></li>
<li><p><strong>NP-hard</strong>: A problem belongs to NP-hard if it is
at least as hard as any problem in NP（可以不是 NP 问题，至少和 NP
问题中最难的问题一样难）</p>
<ul>
<li>Intractable problems（难解问题）</li>
</ul></li>
<li><p><strong>NP-complete</strong>: A problem belongs to NP-complete
(NPC) if it belongs to NP and is NP-hard（属于 NP 且是 NP-hard
的问题：NP 类问题中最难的问题）</p></li>
<li><p>关系</p>
<ul>
<li>If any problem in NP is <strong>not polynomial-time
solvable</strong>, then no NP-complete problem is polynomial-time
solvable（如果 NP 中存在问题不是多项式时间可解的，那么没有 NPC
问题是多项式时间可解的）</li>
<li>If any NP-complete problem is <strong>polynomial-time
solvable</strong>, then every problem in NP has a polynomial-time
algorithm, i.e., <span class="math inline">\(P = NP\)</span>（如果任何
NPC 问题是多项式时间可解的，那么 NP
中的每个问题都有一个多项式时间算法，即 P = NP）</li>
</ul>
<p><span class="math display">\[
  \begin{cases}
  \exists~p \in \mathrm{NP}, p \notin \mathrm{P} &amp;\Rightarrow
\forall q \in \mathrm{NPC}, q \notin \mathrm{P} \\
  \exists~q \in \mathrm{NPC}, q \in \mathrm{P} &amp;\Rightarrow \forall
p \in \mathrm{NP}, p \in \mathrm{P} \quad \Rightarrow \mathrm{P} =
\mathrm{NP}
  \end{cases}
  \]</span></p>
<p><img src="image-84.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>The relationship most theoretical computer scientists believe:
<span class="math inline">\(P \neq
NP\)</span>（大多数理论计算机科学家相信的关系：<span class="math inline">\(P \neq NP\)</span>） <img src="image-67.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
</ul>
<h3 id="规约-reductions">规约 (Reductions)</h3>
<ul>
<li><strong>Reductions</strong>（归约）
<ul>
<li>Reduction is a procedure transforms <strong>any</strong> instance
<span class="math inline">\(\alpha\)</span> of <span class="math inline">\(A\)</span> into <strong>some</strong> instance
<span class="math inline">\(\beta\)</span> of <span class="math inline">\(B\)</span>（一个过程将 <span class="math inline">\(A\)</span> 的任何实例 <span class="math inline">\(\alpha\)</span> 转换为 <span class="math inline">\(B\)</span> 的某个实例 <span class="math inline">\(\beta\)</span>）
<ul>
<li>The transformation takes <strong>polynomial</strong>
time（转换需要多项式时间）</li>
<li>The answers are the <strong>same</strong>（答案是相同的）</li>
</ul></li>
<li>If such a reduction exists, we say that <span class="math inline">\(A\)</span> is polynomial-time reducible to <span class="math inline">\(B\)</span>, denoted by <span class="math inline">\(A \leq_{\mathrm{P}}
B\)</span>（如果存在这样的归约，我们说 <span class="math inline">\(A\)</span> 在多项式时间内可归约为 <span class="math inline">\(B\)</span>，记为 <span class="math inline">\(A
\leq_{\mathrm{P}} B\)</span>）
<ul>
<li>B is at least as hard as A（B 至少和 A 一样难）</li>
</ul></li>
</ul></li>
<li>Using reductions to solve problems（使用归约来解决问题）
<ol type="1">
<li>Given an instance <span class="math inline">\(\alpha\)</span> of
problem <span class="math inline">\(A\)</span>, use a polynomial-time
reduction algorithm to transform it to an instance <span class="math inline">\(\beta\)</span> of problem <span class="math inline">\(B\)</span>（给定问题 <span class="math inline">\(A\)</span> 的实例 <span class="math inline">\(\alpha\)</span>，使用多项式时间归约算法将其转换为问题
<span class="math inline">\(B\)</span> 的实例 <span class="math inline">\(\beta\)</span>）</li>
<li>Run the polynomial-time decision algorithm for <span class="math inline">\(B\)</span> on the instance <span class="math inline">\(\beta\)</span>（在实例 <span class="math inline">\(\beta\)</span> 上运行问题 <span class="math inline">\(B\)</span> 的多项式时间决策算法）</li>
<li>Use the answer for <span class="math inline">\(\beta\)</span> as the
answer for <span class="math inline">\(\alpha\)</span>（将 <span class="math inline">\(\beta\)</span> 的答案用作 <span class="math inline">\(\alpha\)</span> 的答案）
<ul>
<li>if we have a polynomial-time algorithm for <span class="math inline">\(B\)</span>, we can solve <span class="math inline">\(A\)</span> in polynomial time
too（如果我们有一个多项式时间算法用于 <span class="math inline">\(B\)</span>，我们也可以在多项式时间内解决 <span class="math inline">\(A\)</span>）</li>
</ul></li>
</ol>
<img src="image-85.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h3 id="证明-npc">证明 NPC</h3>
<ul>
<li>Decision problems vs.&nbsp;optimization problems（决策问题 vs.&nbsp;优化问题）
<ul>
<li><strong>Decision</strong> problems: the answer is simply yes or
no（决策问题：答案仅为是或否）
<ul>
<li>PATH (Decision problem): Given an undirected graph <span class="math inline">\(G\)</span>, vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, and an integer <span class="math inline">\(k\)</span>, does a path exist from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span> consisting of at most <span class="math inline">\(k\)</span> edges?（无向图中是否存在从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的最多由 <span class="math inline">\(k\)</span> 条边组成的路径？）</li>
</ul></li>
<li><strong>Optimization</strong> problems: the answer is some optimal
value（优化问题：答案是某个最优值）
<ul>
<li>SHORTEST-PATH (Optimization problem): Given an undirected graph
<span class="math inline">\(G\)</span>, vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, what is the length of the shortest
path from <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>?（无向图中从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的最短路径长度是多少？）</li>
</ul></li>
<li>If a decision problem is hard, its related optimization problem is
hard</li>
<li>We usually use reductions to transform a decision problem <span class="math inline">\(A\)</span> to an optimization problem <span class="math inline">\(B\)</span>（我们通常使用归约将决策问题 <span class="math inline">\(A\)</span> 转换为优化问题 <span class="math inline">\(B\)</span>）</li>
</ul></li>
<li>Using polynomial-time reductions in the <strong>opposite</strong>
way to show that a problem <span class="math inline">\(B\)</span> is
NP-complete（以相反的方式使用多项式时间归约来证明问题 <span class="math inline">\(B\)</span> 是 NPC 的）
<ol type="1">
<li>Show that <span class="math inline">\(B\)</span> belongs to NP（证明
<span class="math inline">\(B\)</span> 属于 NP）</li>
<li>Select a known NP-complete problem <span class="math inline">\(A\)</span>（选择一个已知的 NP-complete 问题 <span class="math inline">\(A\)</span>）</li>
<li>Show that <span class="math inline">\(A \leq_{\mathrm{P}}
B\)</span>（证明 <span class="math inline">\(A \leq_{\mathrm{P}}
B\)</span>）</li>
<li>Conclude that <span class="math inline">\(B\)</span> is
NP-complete（得出结论 <span class="math inline">\(B\)</span> 是 NPC
的）</li>
</ol></li>
</ul>
<h3 id="示例">示例</h3>
<ul>
<li>哈密顿回路与旅行商问题
<ul>
<li>哈密顿回路 (Hamiltonian cycles)
<ul>
<li>A hamiltonian cycle of an undirected graph <span class="math inline">\(G = (V, E)\)</span> is a cycle that visits each
vertex exactly
once（一个无向图的哈密顿回路是一个恰好访问每个顶点一次的回路） <span class="math display">\[\langle v_{1},v_{2},\ldots,v_{|V|}\rangle \quad
\forall i, (v_{i},v_{i+1})\in E, (v_{|V|},v_{1})\in E\]</span></li>
<li>Decision problem: whether a hamiltonian cycle exists in a given
graph（决策问题：给定图中是否存在哈密顿回路）</li>
</ul></li>
<li>旅行商问题 (The traveling salesman problem, TSP)
<ul>
<li>Given a set of cities and the distances between each pair of cities,
what is the shortest possible route that visits each city exactly once
and returns to the origin
city?（给定一组城市以及每对城市之间的距离，访问每个城市恰好一次并返回原始城市的最短可能路线是什么？）</li>
<li>Optimization problem: find the shortest hamiltonian
cycle（优化问题：找到最短的哈密顿回路）</li>
</ul></li>
<li>Reduction: HAM-CYCLE <span class="math inline">\(\leq_{\mathrm{P}}\)</span> TSP</li>
</ul></li>
<li>电路可满足性问题 (The circuit-satisfiability problem)
<ul>
<li>Given a boolean circuit <span class="math inline">\(C\)</span> with
<span class="math inline">\(n\)</span> inputs and one output, is there
an assignment of the inputs such that the output is 1?（给定一个具有
<span class="math inline">\(n\)</span> 个输入和一个输出的布尔电路 <span class="math inline">\(C\)</span>，是否存在输入的赋值使得输出为
1？）</li>
<li>The first NP-complete problem</li>
<li>Cook-Levin Theorem: any problem in NP can be reduced in polynomial
time to the circuit-satisfiability problem（Cook-Levin 定理：NP
中的任何问题都可以在多项式时间内归约为电路可满足性问题）</li>
</ul></li>
<li>团问题与顶点覆盖问题
<ul>
<li>团问题 (The clique problem)
<ul>
<li>Clique: a subset of vertices of an undirected graph <span class="math inline">\(G = (V, E)\)</span> such that every two distinct
vertices are adjacent.（团：无向图 <span class="math inline">\(G = (V,
E)\)</span> 的一个顶点子集，其中每两个不同的顶点都是相邻的。）</li>
<li>Optimization problem: find a clique of maximum
size（优化问题：找到最大规模的团）</li>
<li>Decision problem: whether a clique of a given size <span class="math inline">\(k\)</span> exists（决策问题：是否存在给定大小
<span class="math inline">\(k\)</span> 的团）</li>
<li>Naive solution: lists all <span class="math inline">\(k\)</span>
-subsets of <span class="math inline">\(V\)</span> and checks each one
to see whether it forms a clique（暴力解法：列出 <span class="math inline">\(V\)</span> 的所有 <span class="math inline">\(k\)</span> 子集，并检查每个子集是否形成一个团）
<ul>
<li>Time complexity: <span class="math inline">\(O\left(\binom{|V|}{k}
\cdot k^{2}\right)\)</span></li>
</ul></li>
</ul></li>
<li>顶点覆盖问题 (The vertex-cover problem)
<ul>
<li>A vertex cover of an undirected graph <span class="math inline">\(G
= (V, E)\)</span> is a subset <span class="math inline">\(V^\prime
\subseteq V\)</span> such that if <span class="math inline">\((u,v)\in
E\)</span>, then <span class="math inline">\(u\in V^{\prime}\)</span> or
<span class="math inline">\(v\in V^{\prime}\)</span> (or both)（无向图
<span class="math inline">\(G = (V, E)\)</span> 的顶点覆盖是一个满足如果
<span class="math inline">\((u,v)\in E\)</span>，则 <span class="math inline">\(u\in V^{\prime}\)</span> 或 <span class="math inline">\(v\in V^{\prime}\)</span> 或两者皆是的顶点子集
<span class="math inline">\(V^\prime \subseteq V\)</span>）</li>
<li>Optimization problem: find a vertex cover of minimum
size（优化问题：找到最小规模的顶点覆盖）</li>
<li>Decision problem: whether a graph has a vertex cover of a given size
<span class="math inline">\(k\)</span>（决策问题：图是否具有给定大小
<span class="math inline">\(k\)</span> 的顶点覆盖）</li>
</ul></li>
<li>CLIQUE <span class="math inline">\(\leq_{\mathrm{P}}\)</span>
VERTEX-COVER
<ul>
<li>Assume CLIQUE is an NP-hard problem</li>
<li>Given an undirected graph <span class="math inline">\(G = (V,
E)\)</span>, the complement of <span class="math inline">\(G\)</span> is
a graph <span class="math inline">\(\bar{G} = (V, \bar{E})\)</span>,
where（给定无向图 <span class="math inline">\(G = (V, E)\)</span>，<span class="math inline">\(G\)</span> 的补图是图 <span class="math inline">\(\bar{G} = (V, \bar{E})\)</span>，其中） <span class="math display">\[
  \bar {E} = \{(u, v) \colon u, v \in V, u \neq v, (u, v) \notin E \}
  \]</span> <img src="image-86.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>The graph <span class="math inline">\(G\)</span> contains a clique
of size <span class="math inline">\(k\)</span> <strong>if and only
if</strong> the graph <span class="math inline">\(\bar{G}\)</span> has a
vertex cover of size <span class="math inline">\(|V| - k\)</span>（图
<span class="math inline">\(G\)</span> 包含大小为 <span class="math inline">\(k\)</span> 的团当且仅当图 <span class="math inline">\(\bar{G}\)</span> 具有大小为 <span class="math inline">\(|V| - k\)</span> 的顶点覆盖）
<ul>
<li>Assume <span class="math inline">\(G\)</span> contains a clique
<span class="math inline">\(V^\prime\)</span> of size <span class="math inline">\(|V^\prime| = k\)</span>, we try to show that <span class="math inline">\(V - V^\prime\)</span> is a vertex cover of size
<span class="math inline">\(|V| - k\)</span> in <span class="math inline">\(\bar{G}\)</span></li>
<li><span class="math inline">\(\forall (v, w) \in \bar{E}\)</span>, we
have <span class="math inline">\((v, w) \notin E\)</span></li>
<li>Since <span class="math inline">\(V^\prime\)</span> is a clique in
<span class="math inline">\(G\)</span>, at least one of <span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span> is not in <span class="math inline">\(V^\prime\)</span></li>
<li>That means, at least one of <span class="math inline">\(v\)</span>
and <span class="math inline">\(w\)</span> is in <span class="math inline">\(V - V^{\prime}\)</span></li>
<li><span class="math inline">\(V - V^{\prime}\)</span> is a vertex
cover</li>
</ul></li>
<li>Conversely,
<ul>
<li>Assume that <span class="math inline">\(\bar{G}\)</span> has a
vertex cover <span class="math inline">\(V^\prime \subseteq V\)</span>
of size <span class="math inline">\(|V^\prime| = k\)</span>, we try to
show that <span class="math inline">\(V - V^\prime\)</span> is a clique
of size <span class="math inline">\(|V| - k\)</span> in <span class="math inline">\(G\)</span></li>
<li><span class="math inline">\(\forall (v, w) \in
\overline{E}\)</span>, we have <span class="math inline">\((v, w) \notin
E\)</span></li>
<li>Since <span class="math inline">\(V^\prime\)</span> is a vertex
cover in <span class="math inline">\(\bar{G}\)</span>, at least one of
<span class="math inline">\(v\)</span> and <span class="math inline">\(w\)</span> is in <span class="math inline">\(V^\prime\)</span></li>
<li>That means, at most one of <span class="math inline">\(v\)</span>
and <span class="math inline">\(w\)</span> is in <span class="math inline">\(V - V^{\prime}\)</span></li>
<li><span class="math inline">\(V - V^{\prime}\)</span> is a clique</li>
</ul></li>
<li>The reduction can be done in polynomial time by constructing the
complement graph <span class="math inline">\(\bar{G}\)</span>（通过构造补图 <span class="math inline">\(\bar{G}\)</span> 可以在多项式时间内完成归约）</li>
</ul></li>
</ul></li>
<li>More NP-complete problems <img src="image-87.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h1 id="顺序算法">顺序算法</h1>
<h2 id="分治法-divide-and-conquer">分治法 (Divide and Conquer)</h2>
<h3 id="分治法概述">分治法概述</h3>
<ul>
<li><strong>Divide</strong> the problem into one or more subproblems
that are smaller instances of the same
problem（将问题划分为一个或多个更小的同类子问题）</li>
<li><strong>Conquer</strong> the subproblems by solving them
recursively（通过递归地解决子问题来解决它们）</li>
<li><strong>Combine</strong> the subproblem solutions to form a solution
to the original
problem（将子问题的解决方案组合成原始问题的解决方案）</li>
</ul>
<h3 id="归并排序-merge-sort">归并排序 (Merge sort)</h3>
<h4 id="基本思想">基本思想</h4>
<ul>
<li><strong>Divide</strong> the subarray <span class="math inline">\(A[p, r]\)</span> to be sorted into two adjacent
subarrays, each of half the size（将要排序的子数组 <span class="math inline">\(A[p, r]\)</span>
分成两个相邻的子数组，每个子数组大小为一半）
<ul>
<li>Compute the midpoint <span class="math inline">\(q\)</span> of <span class="math inline">\(A[p, r]\)</span>（计算 <span class="math inline">\(A[p, r]\)</span> 的中点 <span class="math inline">\(q\)</span> ）</li>
<li>Divide <span class="math inline">\(A[p,r]\)</span> into subarrays
<span class="math inline">\(A[p,q]\)</span> and <span class="math inline">\(A[q + 1,r]\)</span>（将 <span class="math inline">\(A[p,r]\)</span> 分成子数组 <span class="math inline">\(A[p,q]\)</span> 和 <span class="math inline">\(A[q
+ 1,r]\)</span>）</li>
</ul></li>
<li><strong>Conquer</strong> by sorting each of the two subarrays <span class="math inline">\(A[p, q]\)</span> and <span class="math inline">\(A[q + 1, r]\)</span> recursively using merge
sort（通过使用归并排序递归地排序两个子数组 <span class="math inline">\(A[p, q]\)</span> 和 <span class="math inline">\(A[q + 1, r]\)</span> 来解决）</li>
<li><strong>Combine</strong> by merging the two sorted subarrays <span class="math inline">\(A[p, q]\)</span> and <span class="math inline">\(A[q + 1, r]\)</span> back into <span class="math inline">\(A[p, q]\)</span>, producing the sorted
answer（通过将两个已排序的子数组 <span class="math inline">\(A[p,
q]\)</span> 和 <span class="math inline">\(A[q + 1, r]\)</span> 合并回
<span class="math inline">\(A[p, q]\)</span>
来组合，生成排序后的答案）</li>
</ul>
<h4 id="算法伪代码">算法伪代码</h4>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">MERGE-SORT(A, p, r)</span></span>
<span class="line"><span style="color: #abb2bf">    if p &lt; r then                   // 当前子数组至少有两个元素时</span></span>
<span class="line"><span style="color: #abb2bf">        q = ⌊(p + r) / 2⌋            // 中点</span></span>
<span class="line"><span style="color: #abb2bf">        MERGE-SORT(A, p, q)         // 递归排序左半部分</span></span>
<span class="line"><span style="color: #abb2bf">        MERGE-SORT(A, q + 1, r)     // 递归排序右半部分</span></span>
<span class="line"><span style="color: #abb2bf">        MERGE(A, p, q, r)           // 合并两个已排序的子数组</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">MERGE(A, p, q, r)</span></span>
<span class="line"><span style="color: #abb2bf">    nL = q - p + 1                  // 左子数组的大小</span></span>
<span class="line"><span style="color: #abb2bf">    nR = r - q                      // 右子数组的大小</span></span>
<span class="line"><span style="color: #abb2bf">    let L[0:nL - 1] and R[0:nR - 1] be new arrays</span></span>
<span class="line"><span style="color: #abb2bf">    for i = 0 to nL - 1</span></span>
<span class="line"><span style="color: #abb2bf">        L[i] = A[p + i]</span></span>
<span class="line"><span style="color: #abb2bf">    for j = 0 to nR - 1</span></span>
<span class="line"><span style="color: #abb2bf">        R[j] = A[q + 1 + j]</span></span>
<span class="line"><span style="color: #abb2bf">    i = 0                           // i 为 L 中最小未处理元素的索引</span></span>
<span class="line"><span style="color: #abb2bf">    j = 0                           // j 为 R 中最小未处理元素的索引</span></span>
<span class="line"><span style="color: #abb2bf">    k = p                           // k 为 A 中待填充位置的索引</span></span>
<span class="line"><span style="color: #abb2bf">    while i &lt; nL and j &lt; nR         // 合并 L 和 R 到 A 中</span></span>
<span class="line"><span style="color: #abb2bf">        if L[i] ≤ R[j]</span></span>
<span class="line"><span style="color: #abb2bf">            A[k] = L[i]</span></span>
<span class="line"><span style="color: #abb2bf">            i = i + 1</span></span>
<span class="line"><span style="color: #abb2bf">        else</span></span>
<span class="line"><span style="color: #abb2bf">            A[k] = R[j]</span></span>
<span class="line"><span style="color: #abb2bf">            j = j + 1</span></span>
<span class="line"><span style="color: #abb2bf">        k = k + 1</span></span>
<span class="line"><span style="color: #abb2bf">    while i &lt; nL</span></span>
<span class="line"><span style="color: #abb2bf">        A[k] = L[i]</span></span>
<span class="line"><span style="color: #abb2bf">        i = i + 1</span></span>
<span class="line"><span style="color: #abb2bf">        k = k + 1</span></span>
<span class="line"><span style="color: #abb2bf">    while j &lt; nR</span></span>
<span class="line"><span style="color: #abb2bf">        A[k] = R[j]</span></span>
<span class="line"><span style="color: #abb2bf">        j = j + 1</span></span>
<span class="line"><span style="color: #abb2bf">        k = k + 1</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T (n) = 2 T\left(\frac{n}{2}\right) + \Theta (n)
\]</span></p>
<ul>
<li>示例： <img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>复杂度分析
<ul>
<li>Recurrence equation（递归方程）
<ul>
<li>For simplicity, we assume <span class="math inline">\(n =
2^m\)</span> for some integer <span class="math inline">\(m \geq
0\)</span> <span class="math display">\[
  \quad T (n) =
  \left\{ \begin{array}{c}
  c_{1}, &amp;~n = 1 \\
  2T \left(\frac {n}{2}\right) + c_{2} n, &amp;~n &gt; 1
  \end{array} \right.
  \]</span></li>
</ul></li>
<li>Recurrence tree: <span class="math inline">\(T(n) = 2
T\left(\frac{n}{2}\right) + c_{2} n\)</span> <img src="image-4.webp" srcset="/img/loading/loading3.gif" lazyload alt="Recurrence tree"> <span class="math display">\[
  T(n) = c_{2} n \log n + c_{1} n = \Theta (n \log n)
  \]</span></li>
</ul></li>
</ul>
<h3 id="复杂度分析方法">复杂度分析方法</h3>
<ul>
<li>分析分治算法的时间复杂度通常涉及解决递归关系（recurrence
relations）</li>
<li>三种常用的方法:
<ol type="1">
<li>代入法 (The substitution method)</li>
<li>递归树法 (The recursion-tree method)</li>
<li>公式法 (The master method)</li>
</ol></li>
</ul>
<h4 id="代入法-the-substitution-method">代入法 (The substitution
method)</h4>
<ul>
<li>步骤:
<ol type="1">
<li>Guess the form of the solution using symbolic
constants（使用符号常数猜测解决方案的形式）</li>
<li>Use <strong>mathematical induction</strong> to show that the
solution works, and find the
constants（使用数学归纳法证明解决方案有效，并找到常数）</li>
</ol></li>
<li>示例： <img src="image-5.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>Avoiding pitfalls（避免陷阱）
<ul>
<li>We must prove <span class="math inline">\(T(n) \leq f(n)\)</span>
for some <span class="math inline">\(f(n)\)</span>, but not <span class="math inline">\(T(n) \leq O(n)\)</span>,（我们必须证明 <span class="math inline">\(T(n) \leq f(n)\)</span> 对于某些 <span class="math inline">\(f(n)\)</span> ，而不是 <span class="math inline">\(T(n) \leq O(n)\)</span> ）</li>
<li>E.g., if we intend to prove <span class="math inline">\(T(n) \leq
O(n)\)</span>, then we must assume <span class="math inline">\(T(n) \leq
cn\)</span> for some <span class="math inline">\(c\)</span> and all
<span class="math inline">\(n \geq n_0\)</span>, and prove it by
induction（例如，如果我们打算证明 <span class="math inline">\(T(n) \leq
O(n)\)</span> ，那么我们必须假设 <span class="math inline">\(T(n) \leq
cn\)</span> 对于某些 <span class="math inline">\(c\)</span> 和所有 <span class="math inline">\(n \geq n_0\)</span> ，并通过归纳法证明它）</li>
</ul></li>
</ul>
<h4 id="递归树法-the-recursion-tree-method">递归树法 (The recursion-tree
method)</h4>
<ul>
<li>步骤:
<ol type="1">
<li>Visualize the recurrence as a tree（将递归可视化为一棵树）</li>
<li>Compute the total cost by summing the costs at each level of the
tree（通过对树的每一层的成本求和来计算总成本）</li>
</ol></li>
<li>示例：
<ul>
<li><p><strong>Example 1</strong>: <span class="math inline">\(T(n) =
3T\left(\frac{n}{4}\right) + \Theta (n^{2})= 3T \left(\frac{n}{4}\right)
+ c_{2} n^{2}\)</span> <img src="image-6.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<p><span class="math display">\[
  \begin{aligned}
  &amp;c_{2} n^{2} + \frac{3}{16} c_{2} n^{2} +
\left(\frac{3}{16}\right)^{2} c_{2} n^{2} + \dots
\left(\frac{3}{16}\right)^{\log_{4} n} c_{2} n^{2} \\
  =&amp; \sum_{i=0}^{\log_{4} n} \left(\frac{3}{16}\right)^{i} c_{2}
n^{2} &lt;   \sum_{i=0}^{\infty} \left(\frac{3}{16}\right)^{i} c_{2}
n^{2}\\
  =&amp; \frac{1}{1 - \frac{3}{16}} c_{2} n^{2} = \frac{16}{13} c_{2}
n^{2} \\\\
  \therefore &amp;\sum_{i=0}^{\log_{4} n} \left(\frac{3}{16}\right)^{i}
c_{2} n^{2} + \Theta \big (n^{\log_{4} 3} \big) = O (n^{2})
  \end{aligned}
  \]</span></p></li>
<li><p><strong>Example 2:</strong> <span class="math inline">\(T(n) = 8
T\left(\frac{n}{2}\right) + c_{2} n\)</span> <img src="image-7.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<p><span class="math display">\[
  \begin{aligned}
  &amp;c_{2} n + 4 c_{2} n + 4^{2} c_{2} n + \dots 4^{\log_{2} n} c_{2}
n \\
  =&amp; \sum_{i=0}^{\log_{2} n} 4^{i} c_{2} n \\
  =&amp; \frac{4^{(\log_{2} n) + 1} - 1}{4 - 1} c_{2} n \\
  =&amp; \frac{4 n^{\log_{2} 4} - 1}{3} c_{2} n \\
  =&amp; \Theta (n^{3}) \\\\
  \therefore &amp;\sum_{i=0}^{\log_{2} n} 4^{i} c_{2} n + \Theta (n^{3})
= \Theta (n^{3})
  \end{aligned}\]</span></p></li>
</ul></li>
</ul>
<h4 id="公式法-the-master-method">公式法 (The master method)</h4>
<ul>
<li>Solving algorithmic recurrences of the
form（解决以下形式的算法递归） <span class="math display">\[
  T(n) = aT \left(\frac{n}{b}\right) + f (n),\quad a &gt; 0, b &gt; 1
  \]</span>
<ul>
<li><span class="math inline">\(f(n)\)</span> is a driving function, the
costs for dividing and combining（<span class="math inline">\(f(n)\)</span>
是驱动函数，表示划分和合并的成本）</li>
<li><span class="math inline">\(a\)</span> is the number of
subproblems（<span class="math inline">\(a\)</span>
是子问题的数量）</li>
<li><span class="math inline">\(n/b\)</span> is the size of each
subproblem（<span class="math inline">\(n/b\)</span>
是每个子问题的大小）</li>
</ul></li>
</ul>
<h5 id="case-i">Case I</h5>
<ul>
<li>If there exists a constant <span class="math inline">\(\epsilon &gt;
0\)</span> such that <span class="math display">\[f(n) = O(n^{\log_{b} a
- \epsilon})\]</span> Then <span class="math display">\[T(n) = \Theta
(n^{\log_b a})\]</span>
<ul>
<li><span class="math inline">\(n^{\log_b a}\)</span> is the watershed
function （<span class="math inline">\(n^{\log_b a}\)</span>
是分水岭函数）</li>
<li>The watershed function grows polynomially faster than the driving
function by a factor of <span class="math inline">\(\Theta
(n^{\epsilon})\)</span>（分水岭函数的增长速度比驱动函数快 <span class="math inline">\(\Theta (n^{\epsilon})\)</span> 倍）</li>
</ul></li>
<li>示例：<span class="math inline">\(T(n) = 8T\left(\frac{n}{2}\right)
+ c_2 n = \Theta (n^{3})\)</span> <img src="image-8.webp" srcset="/img/loading/loading3.gif" lazyload alt="Example 2"></li>
</ul>
<h5 id="case-ii">Case II</h5>
<ul>
<li>If there exists a constant <span class="math inline">\(K \geq
0\)</span> such that <span class="math display">\[f (n) = \Theta \left(n
^ {\log_ {b} a} (\log n) ^ {K}\right)\]</span> Then <span class="math display">\[T(n) = \Theta (n^{\log_b a}(\log n)^{K +
1})\]</span></li>
<li>The driving function grows faster than the watershed function only
by a factor of <span class="math inline">\((\log n)^{K}\)</span>（案例
II：驱动函数的增长速度仅比分水岭函数快 <span class="math inline">\((\log
n)^{K}\)</span> 倍）</li>
<li>示例：<span class="math inline">\(T(n) = 2T\left(\frac{n}{2}\right)
+ c_2 n = \Theta (n \log n)\)</span> <img src="image-9.webp" srcset="/img/loading/loading3.gif" lazyload alt="Merge sort"></li>
</ul>
<h5 id="case-iii">Case III</h5>
<ul>
<li>If there exists a constant <span class="math inline">\(\epsilon &gt;
0\)</span> such that <span class="math display">\[f (n) = \Omega (n ^
{\log_ {b} a + \epsilon})\]</span> And <span class="math display">\[\exists c &lt; 1, \forall n \geq n_0, a
f\left(\frac{n}{b}\right) \leq c f(n)\]</span> Then <span class="math display">\[T(n) = \Theta (f(n))\]</span></li>
<li>The driving function grows polynomially faster than the watershed
function by a factor of <span class="math inline">\(\Theta
(n^{\epsilon})\)</span>（驱动函数的增长速度比分水岭函数快 <span class="math inline">\(\Theta (n^{\epsilon})\)</span> 倍）</li>
<li>示例：<span class="math inline">\(T(n) = 3T\left(\frac{n}{4}\right)
+ c_2 n^{2} = \Theta (n^{2})\)</span> <img src="image-10.webp" srcset="/img/loading/loading3.gif" lazyload alt="Example 1"></li>
</ul>
<h2 id="动态规划-dynamic-programming">动态规划 (Dynamic
Programming)</h2>
<h3 id="动态规划概述">动态规划概述</h3>
<ul>
<li>DP typically applies to <strong>optimization</strong> problems（DP
通常应用于优化问题）
<ul>
<li>Find a solution with the optimal
value（找到具有最佳值的解决方案）</li>
</ul></li>
<li>动态规划与分治法的异同
<ul>
<li>相同：Solves problems by combining the solutions to
subproblems（通过组合子问题的解决方案来解决问题）</li>
<li>不同：
<ul>
<li>The subproblems overlap（子问题重叠）</li>
<li>Subproblems share subproblems（子问题共享子问题）</li>
<li>Solves each subproblem only once and saves the result for future
reference（每个子问题只解决一次，并保存结果以供将来参考）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="主要步骤">主要步骤</h4>
<ol type="1">
<li>Characterize the structure of an optimal
solution（描述最优解的结构）</li>
<li>Recursively define the value of an optimal
solution（递归定义最优解的值）</li>
<li>Compute the value of an optimal solution, typically in a bottom-up
fashion（通常以自底向上的方式计算最优解的值）</li>
<li>(Optional) Construct an optimal solution from computed
information（从计算得出的信息中构造最优解）</li>
</ol>
<h4 id="实现方法">实现方法</h4>
<ol type="1">
<li><strong>Top-down with memoization</strong>（自顶向下的备忘录法）
<ul>
<li>Write the procedure recursively（递归编写过程）</li>
<li>Store the results of each subproblem in a
table（将每个子问题的结果存储在表中）</li>
<li>Before solving a subproblem, check whether its result is already in
the table（在解决子问题之前，检查其结果是否已在表中）</li>
</ul></li>
<li><strong>Bottom-up</strong>（自底向上）
<ul>
<li>Sort the subproblems in some order such that when we are about to
solve a subproblem, we have already solved all of its
subproblems（以某种顺序对子问题进行排序，以便在我们即将解决子问题时，我们已经解决了它的所有子问题）
<ul>
<li>Typically implemented using iteration（通常使用迭代实现）</li>
</ul></li>
</ul></li>
</ol>
<h4 id="基本要点">基本要点</h4>
<ul>
<li><strong>Optimal substructure</strong>（最优子结构）
<ul>
<li>An optimal solution to the problem contains within it optimal
solutions to subproblems（问题的最优解包含其子问题的最优解）
<ul>
<li>a solution to the problem consists of making a
choice（解决问题的方案包括做出选择）</li>
<li>the solutions to the subproblems must be
optimal（子问题的解决方案必须是最优的）</li>
</ul></li>
<li>Often uses optimal substructure in a bottom-up
fashion（通常以自底向上的方式使用最优子结构）</li>
</ul></li>
<li><strong>Overlapping subproblems</strong>（重叠子问题）
<ul>
<li>The space of subproblems must be small（子问题的空间必须很小）
<ul>
<li>the total number of distinct subproblems is a
polynomial（不同子问题的总数是多项式）</li>
<li>solve each subproblem <strong>only
once</strong>（每个子问题只解决一次）</li>
<li>store the solutions in a table for future
reference（将解决方案存储在表中以供将来参考）</li>
</ul></li>
<li>Saving subproblem solutions comes with a cost: the additional memory
needed to store
solutions（保存子问题解决方案是有代价的：存储解决方案所需的额外内存）
<ul>
<li>a time-memory trade-off（时间-内存权衡）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="杆切割问题-rod-cutting">杆切割问题 (Rod cutting)</h3>
<h4 id="问题描述">问题描述</h4>
<table>
<thead>
<tr>
<th>length <span class="math inline">\(i\)</span></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>price</strong> <span class="math inline">\(p_i\)</span></td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>17</td>
<td>17</td>
<td>20</td>
<td>24</td>
<td>30</td>
</tr>
</tbody>
</table>
<p><img src="image-11.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>Given a rod of length <span class="math inline">\(n\)</span> and a
table of prices <span class="math inline">\(p_{i}\)</span> for <span class="math inline">\(i = 1, 2, \ldots, n\)</span>, determine the
maximum revenue <span class="math inline">\(r_{n}\)</span> obtainable by
cutting up the rod and selling the pieces（给定长度为 <span class="math inline">\(n\)</span> 的杆和价格表 <span class="math inline">\(p_{i}\)</span> ，其中 <span class="math inline">\(i = 1, 2, \ldots, n\)</span>
，确定通过切割杆并出售零件可以获得的最大收入 <span class="math inline">\(r_{n}\)</span>）</li>
<li>An optimal solution cuts the rod into <span class="math inline">\(k\)</span> pieces: <span class="math inline">\(i_1, i_2, \ldots, i_k\)</span>, where <span class="math inline">\(1 \leq k \leq n\)</span> and <span class="math inline">\(\sum_{j=1}^{k} i_j = n\)</span>, obtaining revenue
<span class="math inline">\(r_n = \sum_{j=1}^{k} p_{i_j}\)</span>
（最优解将杆切成 <span class="math inline">\(k\)</span> 个部分： <span class="math inline">\(i_1, i_2, \ldots, i_k\)</span> ，其中 <span class="math inline">\(1 \leq k \leq n\)</span> 且 <span class="math inline">\(\sum_{j=1}^{k} i_j = n\)</span> ，获得收入 <span class="math inline">\(r_n = \sum_{j=1}^{k} p_{i_j}\)</span>）</li>
</ul>
<h4 id="最优子结构">最优子结构</h4>
<ul>
<li>Let <span class="math inline">\(r_n\)</span> be the optimal revenue
for a rod of length <span class="math inline">\(n\)</span>. Suppose that
in an optimal solution the first piece cut from the rod has length <span class="math inline">\(i\)</span>, where <span class="math inline">\(1
\leq i \leq n\)</span>. Then the revenue <span class="math inline">\(r_n\)</span> is given by（设 <span class="math inline">\(r_n\)</span> 为长度为 <span class="math inline">\(n\)</span>
的杆的最佳收入。假设在最优解中，从杆上切下的第一块的长度为 <span class="math inline">\(i\)</span> ，其中 <span class="math inline">\(1
\leq i \leq n\)</span> 。则收入 <span class="math inline">\(r_n\)</span>
由下式给出） <span class="math display">\[
  r_n = p_i + r_{n - i}
  \]</span></li>
<li><span class="math inline">\(r_n = \max \{p_n, r_1 + r_{n-1}, r_2 +
r_{n-2}, \ldots, r_{\left\lfloor \frac{n}{2} \right\rfloor} +
r_{\left\lceil \frac{n}{2} \right\rceil}\} = \max \{p_i + r_{n - i} : 1
\leq i \leq n\}\)</span></li>
<li>recursive formula for optimal revenue <span class="math inline">\(r_n\)</span> : <span class="math display">\[
  r_n = \left\{ \begin{array}{ll}
  0 &amp; n = 0 \\
  \max_{1 \leq i \leq n} (p_i + r_{n - i}) &amp; n \geq 1
  \end{array} \right.
  \]</span></li>
</ul>
<h4 id="递归解法-recursive-solution">递归解法 (recursive solution)</h4>
<ul>
<li>Trivial solution: try to cut up a rod of length <span class="math inline">\(n\)</span> in <span class="math inline">\(2^{n -
1}\)</span> different ways（简单解法：尝试以 <span class="math inline">\(2^{n - 1}\)</span> 种不同方式切割长度为 <span class="math inline">\(n\)</span> 的杆）
<ul>
<li>Less than <span class="math inline">\(2^{n - 1}\)</span> if in order
of monotonically increasing size（如果按单调递增的顺序，则少于 <span class="math inline">\(2^{n - 1}\)</span> ）</li>
</ul></li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">CUT_ROD(p, n) // p: 价格表, n: 杆长度</span></span>
<span class="line"><span style="color: #abb2bf">    if n == 0</span></span>
<span class="line"><span style="color: #abb2bf">        return 0</span></span>
<span class="line"><span style="color: #abb2bf">    q = -∞</span></span>
<span class="line"><span style="color: #abb2bf">    for i = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">        q = max(q, p[i] + CUT_ROD(p, n - i))</span></span>
<span class="line"><span style="color: #abb2bf">    return q</span></span></code></pre></div></div></figure>
<ul>
<li><span class="math inline">\(T(n)\)</span> : The total number of
calls made to CUT-ROD（<span class="math inline">\(T(n)\)</span> 为对
CUT-ROD 进行的总调用次数） <span class="math display">\[
  T(n) = 1 + \sum_{j = 0}^{n - 1} T(j) = 2^{n}
  \]</span></li>
<li>存在大量重叠子问题 <img src="image-12.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h4 id="动态规划-dynamic-programming-1">动态规划 (dynamic
programming)</h4>
<ul>
<li>Often uses optimal substructure in a bottom-up
fashion（通常以自底向上的方式使用最优子结构）
<ol type="1">
<li>The subproblems of determining optimal ways to cut up rods of length
<span class="math inline">\(i\)</span> for <span class="math inline">\(i
\in \{0, 1, \ldots, n-1\}\)</span>（确定切割长度为 <span class="math inline">\(i\)</span> 的杆的最佳方法的子问题，其中 <span class="math inline">\(i \in \{0, 1, \ldots, n-1\}\)</span>）</li>
<li>Determine which of these subproblems yielded an optimal solution for
a rod of length <span class="math inline">\(n\)</span>（确定这些子问题中哪些为长度为 <span class="math inline">\(n\)</span> 的杆产生了最优解）
<ul>
<li>making a choice among subproblems（在子问题之间做出选择）</li>
</ul></li>
</ol></li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">BOTTOM_UP_CUT_ROD(p, n)         // p: 价格表, n: 杆长度</span></span>
<span class="line"><span style="color: #abb2bf">    let r[0:n] be a new array   // r[j]存储长度为j的杆的最大收益</span></span>
<span class="line"><span style="color: #abb2bf">    r[0] = 0</span></span>
<span class="line"><span style="color: #abb2bf">    for j = 1 to n              // j 为当前杆长度</span></span>
<span class="line"><span style="color: #abb2bf">        q = -∞</span></span>
<span class="line"><span style="color: #abb2bf">        for i = 1 to j          // i 为当前切割长度</span></span>
<span class="line"><span style="color: #abb2bf">            q = max(q, p[i] + r[j - i])</span></span>
<span class="line"><span style="color: #abb2bf">        r[j] = q</span></span>
<span class="line"><span style="color: #abb2bf">    return r[n]</span></span></code></pre></div></div></figure>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">EXTENDED_BOTTOM_UP_CUT_ROD(p, n)</span></span>
<span class="line"><span style="color: #abb2bf">    let r[0:n] and s[0:n] be new arrays // r[j]: 最大收益, s[j]: 第一次切割位置</span></span>
<span class="line"><span style="color: #abb2bf">    r[0] = 0</span></span>
<span class="line"><span style="color: #abb2bf">    for j = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">        q = -∞</span></span>
<span class="line"><span style="color: #abb2bf">        for i = 1 to j</span></span>
<span class="line"><span style="color: #abb2bf">            if q &lt; p[i] + r[j - i]</span></span>
<span class="line"><span style="color: #abb2bf">                q = p[i] + r[j - i]</span></span>
<span class="line"><span style="color: #abb2bf">                s[j] = i</span></span>
<span class="line"><span style="color: #abb2bf">        r[j] = q</span></span>
<span class="line"><span style="color: #abb2bf">    return r, s</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">PRINT_CUT_ROD_SOLUTION(p, n)</span></span>
<span class="line"><span style="color: #abb2bf">    r, s = EXTENDED_BOTTOM_UP_CUT_ROD(p, n)</span></span>
<span class="line"><span style="color: #abb2bf">    while n &gt; 0:</span></span>
<span class="line"><span style="color: #abb2bf">        print(s[n]) // first cut location</span></span>
<span class="line"><span style="color: #abb2bf">        n = n - s[n] // remaining length</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T(n) = \Theta (n^{2})
\]</span></p>
<ul>
<li>示例：
<ul>
<li><p>Input：</p>
<table>
<thead>
<tr>
<th>length <span class="math inline">\(i\)</span></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>price</strong> <span class="math inline">\(p_i\)</span></td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>9</td>
<td>10</td>
<td>17</td>
<td>17</td>
<td>20</td>
<td>24</td>
<td>30</td>
</tr>
</tbody>
</table></li>
<li><p>Output：</p>
<table>
<thead>
<tr>
<th><strong>length</strong> <span class="math inline">\(i\)</span></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>r[i]</strong></td>
<td>0</td>
<td>1</td>
<td>5</td>
<td>8</td>
<td>10</td>
<td>13</td>
<td>17</td>
<td>18</td>
<td>22</td>
<td>25</td>
<td>30</td>
</tr>
<tr>
<td><strong>s[i]</strong></td>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>6</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>10</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<h3 id="最长公共子序列-lcs-longest-common-subsequence">最长公共子序列
(LCS-Longest Common Subsequence)</h3>
<h4 id="问题描述-1">问题描述</h4>
<figure>
<img src="image-13.webp" srcset="/img/loading/loading3.gif" lazyload alt="LCS">
<figcaption aria-hidden="true">LCS</figcaption>
</figure>
<ul>
<li>Given two sequences <span class="math inline">\(X =\langle x_{1},
x_{2}, \ldots, x_{m}\rangle\)</span> and <span class="math inline">\(Y =
\langle y_{1}, y_{2}, \ldots, y_{n} \rangle\)</span>, find a longest
common subsequence of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>（给定两个序列 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span>，找到他们的最长公共子序列）</li>
<li>A subsequence of a sequence is a new sequence formed from the
original sequence by deleting some (can be none) of the elements without
disturbing the relative positions of the remaining
elements（序列的子序列是从原始序列中删除某些元素而不干扰剩余元素的相对位置而形成的新序列）</li>
</ul>
<h4 id="最优子结构-1">最优子结构</h4>
<ul>
<li>Let <span class="math inline">\(X =\langle x_{1~~}, x_{2}, \ldots,
x_{m}\rangle\)</span> and <span class="math inline">\(Y = \langle y_{1},
y_{2}, \ldots, y_{n} \rangle\)</span> be sequences, and let <span class="math inline">\(Z = \langle z_{1}, z_{2}, \ldots, z_{k}
\rangle\)</span> be any LCS of <span class="math inline">\(X\)</span>
and <span class="math inline">\(Y\)</span>
<ol type="1">
<li>If <span class="math inline">\(x_{m} = y_{n}\)</span>, then <span class="math inline">\(z_{k} = x_{m} = y_{n}\)</span> and <span class="math inline">\(Z_{k-1}\)</span> is an LCS of <span class="math inline">\(X_{m-1}\)</span> and <span class="math inline">\(Y_{n-1}\)</span></li>
<li>If <span class="math inline">\(x_{m} \neq y_{n}\)</span> and <span class="math inline">\(z_{k} \neq x_{m}\)</span>, then <span class="math inline">\(Z\)</span> is an LCS of <span class="math inline">\(X_{m-1}\)</span> and <span class="math inline">\(Y\)</span></li>
<li>If <span class="math inline">\(x_{m} \neq y_{n}\)</span> and <span class="math inline">\(z_{k} \neq y_{n}\)</span>, then <span class="math inline">\(Z\)</span> is an LCS of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y_{n-1}\)</span></li>
</ol></li>
<li>recursive formula of LCS length <span class="math inline">\(c[i,
j]\)</span> <span class="math display">\[
  c[i,j] = \left\{ \begin{array}{ll}
  0 &amp;  i = 0 ~or~ j = 0 \\
  c[i-1,j-1] + 1 &amp; i, j &gt; 0 ~and~ x_{i} = y_{j}\\
  \max \{c[i,j-1], c[i-1,j] \} &amp; i, j &gt; 0 ~and~ x_{i} \neq
y_{j}\end{array} \right.
  \]</span></li>
</ul>
<h4 id="算法伪代码-1">算法伪代码</h4>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">LCS_LENGTH(X, Y, m, n)</span></span>
<span class="line"><span style="color: #abb2bf">    let b[1:m, 1:n] and c[0:m, 0:n] be new tables   // b: 方向表, c: 长度表</span></span>
<span class="line"><span style="color: #abb2bf">    for i = 0 to m</span></span>
<span class="line"><span style="color: #abb2bf">        c[i][0] = 0</span></span>
<span class="line"><span style="color: #abb2bf">    for j = 0 to n</span></span>
<span class="line"><span style="color: #abb2bf">        c[0][j] = 0</span></span>
<span class="line"><span style="color: #abb2bf">    for i = 1 to m</span></span>
<span class="line"><span style="color: #abb2bf">        for j = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">            if x[i] == y[j]</span></span>
<span class="line"><span style="color: #abb2bf">                c[i][j] = c[i-1][j-1] + 1</span></span>
<span class="line"><span style="color: #abb2bf">                b[i][j] = "↖"      // diagonal</span></span>
<span class="line"><span style="color: #abb2bf">            else if c[i-1][j] &gt;= c[i][j-1]</span></span>
<span class="line"><span style="color: #abb2bf">                c[i][j] = c[i-1][j]</span></span>
<span class="line"><span style="color: #abb2bf">                b[i][j] = "↑"      // up</span></span>
<span class="line"><span style="color: #abb2bf">            else</span></span>
<span class="line"><span style="color: #abb2bf">                c[i][j] = c[i][j-1]</span></span>
<span class="line"><span style="color: #abb2bf">                b[i][j] = "←"      // left</span></span>
<span class="line"><span style="color: #abb2bf">    return b, c</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T (m, n) = \Theta (m n)
\]</span></p>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">PRINT_LCS(b, X, i, j)</span></span>
<span class="line"><span style="color: #abb2bf">    if i == 0 or j == 0</span></span>
<span class="line"><span style="color: #abb2bf">        return</span></span>
<span class="line"><span style="color: #abb2bf">    if b[i][j] == "↖"</span></span>
<span class="line"><span style="color: #abb2bf">        PRINT_LCS(b, X, i - 1, j - 1)</span></span>
<span class="line"><span style="color: #abb2bf">        print(X[i - 1])</span></span>
<span class="line"><span style="color: #abb2bf">    elif b[i][j] == "↑"</span></span>
<span class="line"><span style="color: #abb2bf">        PRINT_LCS(b, X, i - 1, j)</span></span>
<span class="line"><span style="color: #abb2bf">    else:</span></span>
<span class="line"><span style="color: #abb2bf">        PRINT_LCS(b, X, i, j - 1)</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T (m, n) = \Theta (m + n)
\]</span></p>
<ul>
<li>示例： <img src="image-14.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h3 id="最优二叉搜索树-optimal-binary-search-trees">最优二叉搜索树
(Optimal binary search trees)</h3>
<h4 id="问题描述-2">问题描述</h4>
<p><img src="image-15.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li><p>Given a sequence of <span class="math inline">\(n\)</span> keys
<span class="math inline">\(k_{1} &lt; k_{2} &lt; \ldots &lt;
k_{n}\)</span>, with associated search probabilities <span class="math inline">\(p_{1}, p_{2}, \ldots, p_{n}\)</span>, build a
binary search tree of all <span class="math inline">\(n\)</span> keys
that minimizes the expected search cost（给定一系列 <span class="math inline">\(n\)</span> 个键 <span class="math inline">\(k_i\)</span> 以及相关的搜索概率 <span class="math inline">\(p_i\)</span>，构建包含所有 <span class="math inline">\(n\)</span>
个键的二叉搜索树，以最小化预期搜索成本）</p></li>
<li><p>Additionally, there are <span class="math inline">\(n +
1\)</span> dummy keys <span class="math inline">\(d_{0}, d_{1}, \ldots,
d_{n}\)</span>, with associated search probabilities <span class="math inline">\(q_{0}, q_{1}, \ldots, q_{n}\)</span>, representing
values not in the tree（此外，还有 <span class="math inline">\(n +
1\)</span> 个虚拟键 <span class="math inline">\(d_i\)</span>
，表示树中不存在的值）</p>
<ul>
<li>each dummy key <span class="math inline">\(d_{i}\)</span>
corresponds to the interval <span class="math inline">\((k_{i-1},
k_{i})\)</span> （每个虚拟键 <span class="math inline">\(d_{i}\)</span>
对应于区间 <span class="math inline">\((k_{i-1}, k_{i})\)</span> ）</li>
</ul></li>
<li><p>The probabilities satisfy（这些概率满足） <span class="math display">\[\sum_{i=1}^{n} p_{i} + \sum_{i=0}^{n} q_{i} =
1\]</span></p></li>
<li><p>The expected cost of a search is <span class="math display">\[
  \operatorname{E}(\text{search cost in } T) = \sum_{i=1}^{n}
(\operatorname{depth}_T(k_i) + 1) \times p_i + \sum_{i=0}^{n}
(\operatorname{depth}_T(d_i) + 1) \times q_i
  \]</span></p></li>
<li><p>示例 <img src="image-16.webp" srcset="/img/loading/loading3.gif" lazyload alt="非最优解"> <img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload alt="最优解"> <img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload alt="Cut-and-paste"></p></li>
</ul>
<h4 id="最优子结构-2">最优子结构</h4>
<ul>
<li>Let <span class="math inline">\(e(i,j)\)</span> denote the expected
cost of searching an optimal binary search tree containing the keys
<span class="math inline">\(k_{i},\ldots,k_{j}\)</span>（令 <span class="math inline">\(e(i,j)\)</span> 表示包含键 <span class="math inline">\(k_{i},\ldots,k_{j}\)</span>
的最优二叉搜索树的预期搜索成本）</li>
<li>Let <span class="math inline">\(w(i, j)\)</span> denote the sum of
the probabilities between <span class="math inline">\(k_{i}\)</span> and
<span class="math inline">\(k_{j}\)</span>（令 <span class="math inline">\(w(i, j)\)</span> 表示 <span class="math inline">\(k_{i}\)</span> 到 <span class="math inline">\(k_{j}\)</span> 之间的概率和） <span class="math display">\[
  w(i, j) = \sum_ {l = i} ^ {j} p _ {l} + \sum_ {l = i - 1} ^ {j} q _
{l} = \left\{ \begin{array} {ll}
  q _ {i - 1} &amp; j = i - 1 \\
  w(i, j - 1) + p _ {j} + q _ {j} &amp; i \leq j
  \end{array} \right.
  \]</span>
<ul>
<li>示例 <img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li>Let <span class="math inline">\(k_{r}\)</span> be the root of an
optimal binary search tree containing the keys <span class="math inline">\(k_{i}, \ldots, k_{j}\)</span>, where <span class="math inline">\(i \leq r \leq j\)</span>（令 <span class="math inline">\(k_{r}\)</span> 为包含键 <span class="math inline">\(k_{i}, \ldots, k_{j}\)</span>
的最优二叉搜索树的根，其中 <span class="math inline">\(i \leq r \leq
j\)</span>） <span class="math display">\[
  e(i, j) = e(i, r - 1) + e(r + 1, j) + w(i, j)
  \]</span></li>
<li>We thus have the following recursive formulation: <span class="math display">\[
  e(i, j) = \left\{ \begin{array}{ll}
  q_{i - 1} &amp; ~j = i - 1 \\
  \min \{e(i, r - 1) + e(r + 1, j) + w(i, j) \colon i \leq r \leq j \}
&amp; ~i \leq j
  \end{array} \right.
  \]</span></li>
<li>Our goal: compute <span class="math inline">\(e(1, n)\)</span></li>
</ul>
<h4 id="算法伪代码-2">算法伪代码</h4>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">OPTIMAL_BST(p, q, n)</span></span>
<span class="line"><span style="color: #abb2bf">    let e[1:n+1, 0:n], w[1:n+1, 0:n], root[1:n, 1:n] be new tables                // e: 期望搜索成本表, w: 概率和表, root: 根表</span></span>
<span class="line"><span style="color: #abb2bf">    for i = 1 to n + 1</span></span>
<span class="line"><span style="color: #abb2bf">        e[i][i - 1] = q[i - 1]</span></span>
<span class="line"><span style="color: #abb2bf">        w[i][i - 1] = q[i - 1]</span></span>
<span class="line"><span style="color: #abb2bf">    for l = 1 to n                          // l: 子问题长度</span></span>
<span class="line"><span style="color: #abb2bf">        for i = 1 to n - l + 1              // i: 子问题起始位置</span></span>
<span class="line"><span style="color: #abb2bf">            j = i + l - 1                   // j: 子问题结束位置</span></span>
<span class="line"><span style="color: #abb2bf">            e[i][j] = ∞</span></span>
<span class="line"><span style="color: #abb2bf">            w[i][j] = w[i][j - 1] + p[j] + q[j]</span></span>
<span class="line"><span style="color: #abb2bf">            for r = i to j                  // r: 根位置</span></span>
<span class="line"><span style="color: #abb2bf">                t = e[i][r - 1] + e[r + 1][j] + w[i][j]</span></span>
<span class="line"><span style="color: #abb2bf">                if t &lt; e[i][j]</span></span>
<span class="line"><span style="color: #abb2bf">                    e[i][j] = t</span></span>
<span class="line"><span style="color: #abb2bf">                    root[i][j] = r</span></span>
<span class="line"><span style="color: #abb2bf">    return w, e, root</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T(n) = \Theta (n^{3})
\]</span></p>
<ul>
<li>示例 <img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>根据 <span class="math inline">\(e\)</span> 和 <span class="math inline">\(w\)</span> 表格反推最优二叉搜索树（以上图为例）
<ul>
<li>根：<span class="math inline">\(e[1,5] - w[1,5] = 1.75 = e[1,1] +
e[3,5] \Rightarrow k_{2}\)</span>
<ul>
<li>左子树：<span class="math inline">\(k_{1}\)</span>
<ul>
<li>左子树：<span class="math inline">\(d_{0}\)</span></li>
<li>右子树：<span class="math inline">\(d_{1}\)</span></li>
</ul></li>
<li>右子树：<span class="math inline">\(e[3,5] - w[3,5] = 0.7 = e[3,4] +
e[6,5] \Rightarrow k_{5}\)</span>
<ul>
<li>左子树：<span class="math inline">\(e[3,4] - w[3,4] = 0.3 = e[3,3] +
e[5,4] \Rightarrow k_{4}\)</span>
<ul>
<li>左子树：<span class="math inline">\(k_{3}\)</span>
<ul>
<li>左子树：<span class="math inline">\(d_{2}\)</span></li>
<li>右子树：<span class="math inline">\(d_{3}\)</span></li>
</ul></li>
<li>右子树：<span class="math inline">\(d_{4}\)</span></li>
</ul></li>
<li>右子树：<span class="math inline">\(d_{5}\)</span></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="贪心算法-greedy-algorithms">贪心算法 (Greedy Algorithms)</h2>
<h3 id="贪心算法概述">贪心算法概述</h3>
<ul>
<li>A greedy algorithm always makes the choice that looks <strong>best
at the moment</strong>（贪心算法总是做出在当前时刻看起来最好的选择）
<ul>
<li>A locally optimal choice <span class="math inline">\(\rightarrow\)</span> a globally optimal
solution</li>
</ul></li>
<li>应用：
<ul>
<li>Minimum-spanning-tree algorithms</li>
<li>Dijkstra’s algorithm for shortest paths</li>
</ul></li>
</ul>
<h4 id="基本要点-1">基本要点</h4>
<ul>
<li>A <strong>top-down</strong> approach: make a sequence of
choices（自顶向下的方法：做出一系列选择）</li>
<li>At each decision point, the algorithm makes the choice that seems
<strong>best at the
moment</strong>（在每个决策点，算法做出当时看起来最好的选择）</li>
<li>Two ingredients（两个要素）
<ol type="1">
<li>greedy-choice property（贪心选择属性）
<ul>
<li>Assemble a globally optimal solution by making locally optimal
(greedy) choices（通过做出局部最优选择来组装全局最优解）
<ul>
<li><strong>Without</strong> considering results from
subproblems（不考虑子问题的结果）</li>
<li>Make the first choice before solving any
subproblems（在解决任何子问题之前做出第一个选择）</li>
</ul></li>
</ul></li>
<li>optimal substructure（最优子结构）
<ul>
<li>An optimal solution to the problem contains within it optimal
solutions to subproblems（问题的最优解包含其子问题的最优解）</li>
<li>For greedy algorithms, an optimal solution to the subproblem,
combined with the greedy choice already made, yields an optimal solution
to the original
problem（对于贪心算法，子问题的最优解与已经做出的贪心选择相结合，产生原始问题的最优解）</li>
</ul></li>
</ol></li>
</ul>
<h4 id="贪心-vs-dp">贪心 vs DP</h4>
<ul>
<li>贪心算法与动态规划的区别
<ul>
<li>Greedy: make a choice and then solve a
subproblem（做出选择然后解决子问题）</li>
<li>DP: solving all subproblems before making a
choice（在做出选择之前解决所有子问题）</li>
</ul></li>
<li>背包问题 (The Knapsack Problem)
<ul>
<li>问题描述
<ul>
<li>take the most valuable load with at most <span class="math inline">\(W\)</span> pounds（以不超过 <span class="math inline">\(W\)</span> 磅的重量携带最有价值的负载）</li>
<li>the <span class="math inline">\(i\)</span> th item is worth <span class="math inline">\(v_{i}\)</span> dollars and weighs <span class="math inline">\(w_{i}\)</span> pounds（第 <span class="math inline">\(i\)</span> 件物品价值 <span class="math inline">\(v_{i}\)</span> 美元，重量为 <span class="math inline">\(w_{i}\)</span> 磅）</li>
</ul></li>
<li>两种变体
<ul>
<li>The 0-1 knapsack problem
<ul>
<li>can only take whole items（只能取完整的物品）</li>
<li><strong>DP</strong></li>
</ul></li>
<li>The fractional knapsack problem
<ul>
<li>can take fractions of items（可以取物品的部分）</li>
<li><strong>Greedy</strong></li>
</ul></li>
</ul></li>
<li>示例 <img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
</ul>
<h3 id="活动选择问题-activity-selection-problem">活动选择问题 (Activity
Selection Problem)</h3>
<h4 id="问题描述-3">问题描述</h4>
<ul>
<li><p>Schedule several competing activities <span class="math inline">\(S = \{a_{1}, a_{2}, \ldots, a_{n}\}\)</span> that
require exclusive use of a common
resource（安排几个需要独占使用公共资源的竞争活动）</p></li>
<li><p>Each activity <span class="math inline">\(a_i\)</span> has a
start time <span class="math inline">\(s_i\)</span> and a finish time
<span class="math inline">\(f_i\)</span> <span class="math display">\[
  s_{i} &lt; f_{i}
  \]</span></p></li>
<li><p>Activities <span class="math inline">\(a_{i}\)</span> and <span class="math inline">\(a_{j}\)</span> are compatible if the intervals
<span class="math inline">\([s_{i}, f_{i})\)</span> and <span class="math inline">\([s_{j}, f_{j})\)</span> do not overlap（如果区间
<span class="math inline">\([s_{i}, f_{i})\)</span> 和 <span class="math inline">\([s_{j}, f_{j})\)</span> 不重叠，则活动 <span class="math inline">\(a_{i}\)</span> 和 <span class="math inline">\(a_{j}\)</span> 是兼容的） <span class="math display">\[
  s _ {i} \geq f _ {j} ~or~ s _ {j} \geq f _ {i}
  \]</span></p></li>
<li><p>Goal: to select a maximum-size subset of mutually compatible
activities（目标：选择一个最大规模的相互兼容的活动子集）</p></li>
<li><p>Assume <span class="math inline">\(f_{1} \leq f_{2} \leq \dots
\leq f_{n}\)</span></p>
<table>
<thead>
<tr>
<th>i</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(s_i\)</span></td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>5</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>2</td>
<td>12</td>
</tr>
<tr>
<td><span class="math inline">\(f_i\)</span></td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>9</td>
<td>9</td>
<td>10</td>
<td>11</td>
<td>12</td>
<td>14</td>
<td>16</td>
</tr>
</tbody>
</table>
<ul>
<li><span class="math inline">\(\{a_{1}, a_{4}, a_{8}, a_{11}\}\)</span>
is an optimal solution</li>
</ul></li>
</ul>
<h4 id="dp-solution">DP solution</h4>
<ul>
<li>定义：
<ul>
<li><span class="math inline">\(S_{ij}\)</span>: The set of activities
that start after activity <span class="math inline">\(a_i\)</span>
finishes and that finish before activity <span class="math inline">\(a_j\)</span> starts（在活动 <span class="math inline">\(a_i\)</span> 结束后开始并在活动 <span class="math inline">\(a_j\)</span> 开始前结束的活动集合）
<ul>
<li><span class="math inline">\(S_{ij} = \{a_k\in S\colon f_i\leq s_k
&lt; f_k\leq s_j\}\)</span></li>
<li>Activities that are compatible with <span class="math inline">\(a_i\)</span> and <span class="math inline">\(a_j\)</span>（与活动 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_j\)</span> 兼容的活动）</li>
</ul></li>
<li><span class="math inline">\(A_{ij}\)</span> : The corresponding
maximum-size set（相应的最大规模集合）</li>
<li><span class="math inline">\(c[i,j] = \left|A_{ij}\right|\)</span> :
the number of activities in <span class="math inline">\(A_{ij}\)</span>（ <span class="math inline">\(A_{ij}\)</span> 中的活动数量）</li>
</ul></li>
<li>The recurrence: <span class="math display">\[
  c[i,j] = \left\{ \begin{array}{ll}
  0 &amp; S_{ij} = \emptyset \\
  \max \{c[i,k] + c[k,j] + 1\colon a_k\in S_{ij}\} &amp; S_{ij}\neq
\emptyset \end{array} \right.
  \]</span></li>
<li>A bottom-up approach</li>
</ul>
<h4 id="greedy-solution">Greedy solution</h4>
<ul>
<li>Intuition: we maximize the number of compatible
activities（直觉：我们最大化兼容活动的数量）
<ul>
<li>choose an activity that leaves the resource available for as many
other activities as
possible（选择一项活动，使剩余资源可用于尽可能多的其他活动）</li>
</ul></li>
<li>Choose the activity with the earliest finish
time（选择最早完成时间的活动）
<ul>
<li>Once you make the greedy choice, you have only one remaining
subproblem to
solve（一旦你做出了贪心选择，你就只有一个剩下的子问题要解决）</li>
<li>Let <span class="math inline">\(S_{k} = \{a_{i} \in S : s_{i} \geq
f_{k}\}\)</span> be the set of activities that start after activity
<span class="math inline">\(a_{k}\)</span> finishes（让 <span class="math inline">\(S_{k}\)</span> 是在活动 <span class="math inline">\(a_{k}\)</span> 结束后开始的活动集合）
<ul>
<li>If we select <span class="math inline">\(a_1\)</span>, then <span class="math inline">\(S_1\)</span> remains as the only subproblem to
solve（如果我们选择 <span class="math inline">\(a_1\)</span> ，那么
<span class="math inline">\(S_1\)</span> 就是唯一需要解决的子问题）</li>
</ul></li>
</ul></li>
<li>Consider any nonempty subproblem <span class="math inline">\(S_{k}\)</span>, and let <span class="math inline">\(a_{m}\)</span> be an activity in <span class="math inline">\(S_{k}\)</span> with the earliest finish time. Then
<span class="math inline">\(a_{m}\)</span> is included in some
maximum-size subset of mutually compatible activities of <span class="math inline">\(S_{k}\)</span>,（考虑任何非空子问题 <span class="math inline">\(S_{k}\)</span> ，并让 <span class="math inline">\(a_{m}\)</span> 是 <span class="math inline">\(S_{k}\)</span> 中具有最早完成时间的活动。然后
<span class="math inline">\(a_{m}\)</span> 被包含在 <span class="math inline">\(S_{k}\)</span>
的某个最大规模的相互兼容活动子集中。）</li>
<li>A top-down approach</li>
</ul>
<h5 id="基本思想-1">基本思想</h5>
<ol type="1">
<li>Choose the activity <span class="math inline">\(a_{m}\)</span> that
finishes first（选择最先完成的活动 <span class="math inline">\(a_{m}\)</span> ）</li>
<li>Keep only the activities compatible with <span class="math inline">\(a_{m}\)</span>（只保留与 <span class="math inline">\(a_{m}\)</span> 兼容的活动）</li>
<li>Repeat until no activities remain（重复直到没有活动剩下）</li>
</ol>
<h5 id="算法伪代码-3">算法伪代码</h5>
<ul>
<li>Assume that the input activities are ordered by monotonically
increasing finish time（假设输入活动按完成时间单调递增排序）</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">GREEDY_ACTIVITY_SELECTOR(s, f, n)</span></span>
<span class="line"><span style="color: #abb2bf">    A = {a_1}                   // 选择第一个活动</span></span>
<span class="line"><span style="color: #abb2bf">    k = 1</span></span>
<span class="line"><span style="color: #abb2bf">    for m = 2 to n do</span></span>
<span class="line"><span style="color: #abb2bf">        if s_m &gt;= f_k then      // 如果活动 a_m 与 a_k 兼容</span></span>
<span class="line"><span style="color: #abb2bf">            A = A ∪ {a_m}       // 将活动 a_m 添加到选择的活动集合 A 中</span></span>
<span class="line"><span style="color: #abb2bf">            k = m               // 更新最后选择的活动索引 k 为 m</span></span>
<span class="line"><span style="color: #abb2bf">    return A</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T(n) = \Theta(n)
\]</span></p>
<ul>
<li>示例 <img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h3 id="缓存置换问题-the-cache-replacement-problem">缓存置换问题 (The
Cache Replacement Problem)</h3>
<h4 id="问题描述-4">问题描述</h4>
<ul>
<li>There are a sequence of <span class="math inline">\(n\)</span>
memory requests to data in blocks <span class="math inline">\(b_{1},
b_{2}, \ldots, b_{n}\)</span>（有一系列对块 <span class="math inline">\(b_i\)</span> 中数据的内存请求）</li>
<li>The cache starts out empty, and can hold up to some fixed number
<span class="math inline">\(k\)</span> of cache
blocks（缓存初始为空，最多可以容纳 <span class="math inline">\(k\)</span> 个缓存块）</li>
<li>Each request causes at most one block to enter the cache and at most
one block to be evicted from the
cache（每个请求最多导致一个块进入缓存，最多一个块从缓存中被驱逐）
<ol type="1">
<li>Block <span class="math inline">\(b_{i}\)</span> is already in the
cache (cache hit)（块 <span class="math inline">\(b_{i}\)</span>
已经在缓存中（缓存命中））</li>
<li>Block <span class="math inline">\(b_{i}\)</span> is not in the cache
at that time, but the cache contains fewer than <span class="math inline">\(k\)</span> blocks (cache misses)（块 <span class="math inline">\(b_{i}\)</span> 当时不在缓存中，但缓存中包含少于
<span class="math inline">\(k\)</span> 个块（缓存未命中））</li>
<li>Block <span class="math inline">\(b_{i}\)</span> is not in the cache
at that time and the cache is full (cache misses)（块 <span class="math inline">\(b_{i}\)</span>
当时不在缓存中，且缓存已满（缓存未命中））</li>
</ol></li>
<li>Goal: minimize the number of cache
misses（目标：最小化缓存未命中的次数）</li>
<li><strong>Offline version</strong>: the entire request sequence is
known in advance（离线版本：整个请求序列事先已知）</li>
</ul>
<h4 id="贪心策略">贪心策略</h4>
<ul>
<li>The solution is simple:
<strong>furthest-in-future</strong>（未来最远）
<ul>
<li>Evict the block in the cache whose next access in the request
sequence comes furthest in the
future（驱逐缓存中下一个访问请求序列中最远的块）</li>
</ul></li>
<li>示例：<span class="math inline">\(k = 3\)</span> and the request
sequence is：s, q, s, p, r, s, q, p, r, q <img src="image-23.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h4 id="最优子结构-3">最优子结构</h4>
<ul>
<li>Subproblem <span class="math inline">\((C, i)\)</span> : processing
requests for blocks <span class="math inline">\(b_{i}, b_{i+1}, \ldots,
b_{n}\)</span> with cache configuration <span class="math inline">\(C\)</span>（子问题 <span class="math inline">\((C,
i)\)</span>：请求序列 <span class="math inline">\(b_{i}, b_{i+1},
\ldots, b_{n}\)</span>，缓存状态 <span class="math inline">\(C\)</span>）</li>
<li>A solution to subproblem <span class="math inline">\((C, i)\)</span>
is a sequence of decisions that specifies which blocks to evict（子问题
<span class="math inline">\((C, i)\)</span>
的解决方案是一系列决策，指定要驱逐哪些块）
<ul>
<li>An optimal solution <span class="math inline">\(S\)</span> minimizes
the number of cache misses（最优解使得缓存未命中的次数最少）</li>
</ul></li>
<li>Consider an optimal solution <span class="math inline">\(S\)</span>
to subproblem <span class="math inline">\((C, i)\)</span>（考虑子问题
<span class="math inline">\((C, i)\)</span> 的最优解 <span class="math inline">\(S\)</span> ）
<ul>
<li>let <span class="math inline">\(C^\prime\)</span> be the contents of
the cache after processing the request for block <span class="math inline">\(b_i\)</span>（让 <span class="math inline">\(C^\prime\)</span> 是处理块 <span class="math inline">\(b_i\)</span> 请求后的缓存内容）</li>
<li>Let <span class="math inline">\(S^\prime\)</span> be the
sub-solution of <span class="math inline">\(S\)</span> for the resulting
subproblem <span class="math inline">\((C^\prime, i + 1)\)</span>（让
<span class="math inline">\(S^\prime\)</span> 是子问题 <span class="math inline">\((C^\prime, i + 1)\)</span> 的 <span class="math inline">\(S\)</span> 的子解）</li>
</ul></li>
<li>分情况讨论
<ul>
<li>Case I: cache hit
<ul>
<li>the cache remains unchanged, <span class="math inline">\(C =
C^{\prime}\)</span></li>
</ul></li>
<li>Case II: cache miss
<ul>
<li><span class="math inline">\(C \neq C^{\prime}\)</span></li>
<li><span class="math inline">\(S^\prime\)</span> is an optimal solution
to subproblem <span class="math inline">\((C^\prime, i +
1)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h4 id="贪心选择性质">贪心选择性质</h4>
<ul>
<li><p>Consider a subproblem <span class="math inline">\((C, i)\)</span>
when the cache <span class="math inline">\(C\)</span> contains <span class="math inline">\(k\)</span> blocks (it is full) and a cache miss
occurs（考虑子问题 <span class="math inline">\((C, i)\)</span> ，当缓存
<span class="math inline">\(C\)</span> 包含 <span class="math inline">\(k\)</span>
个块（已满）并且发生缓存未命中时）</p></li>
<li><p>When block <span class="math inline">\(b_{i}\)</span> is
requested, let <span class="math inline">\(z = b_{m}\)</span> be the
block in <span class="math inline">\(C\)</span> whose next access is
furthest in the future（当请求块 <span class="math inline">\(b_{i}\)</span> 时，让 <span class="math inline">\(z = b_{m}\)</span> 是位于 <span class="math inline">\(C\)</span> 中的下一个访问最远的块） <img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>Theorem: Evicting block <span class="math inline">\(z\)</span>
upon a request for block <span class="math inline">\(b_{i}\)</span> is
included in some optimal solution for the subproblem <span class="math inline">\((C, i)\)</span>（在请求块 <span class="math inline">\(b_{i}\)</span> 时驱逐块 <span class="math inline">\(z\)</span> 包含在子问题 <span class="math inline">\((C, i)\)</span> 的某个最优解中）</p></li>
<li><p>Let <span class="math inline">\(S\)</span> be an optimal solution
to subproblem <span class="math inline">\((C, i)\)</span> <img src="image-25.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>基本思想 <img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ol type="1">
<li>Before <span class="math inline">\(z\)</span>:
<ul>
<li>the configurations of <span class="math inline">\(S\)</span> and
<span class="math inline">\(S^{\prime}\)</span> differ by at most one
block（ <span class="math inline">\(S\)</span> 和 <span class="math inline">\(S^{\prime}\)</span> 的配置最多相差一个块）</li>
<li>The number of cache misses in <span class="math inline">\(S^{\prime}\)</span> is at most the number of cache
misses in <span class="math inline">\(S\)</span>（ <span class="math inline">\(S^{\prime}\)</span> 中的缓存未命中次数最多为 <span class="math inline">\(S\)</span> 中的缓存未命中次数）</li>
</ul></li>
<li>after <span class="math inline">\(z\)</span>:
<ul>
<li><span class="math inline">\(S\)</span> and <span class="math inline">\(S^{\prime}\)</span> have the same configuration（
<span class="math inline">\(S\)</span> 和 <span class="math inline">\(S^{\prime}\)</span> 具有相同的配置）</li>
</ul></li>
</ol></li>
</ul>
<h1 id="顺序算法图算法">顺序算法──图算法</h1>
<h2 id="最小生成树-minimum-spanning-trees">最小生成树 (Minimum Spanning
Trees)</h2>
<h3 id="最小生成树概述">最小生成树概述</h3>
<ul>
<li>应用
<ul>
<li>Telecommunications networks（电信网络）</li>
<li>Computer networks（计算机网络）</li>
<li>Electronic circuit designs（电子电路设计）</li>
<li>Others</li>
</ul></li>
</ul>
<h4 id="基本定义">基本定义</h4>
<ul>
<li>A connected, undirected graph <span class="math inline">\(G(V,E)\)</span>, where <span class="math inline">\(V\)</span> is the set of nodes and <span class="math inline">\(E\)</span> is the set of possible interconnections
between pairs of nodes（一个连通的无向图 <span class="math inline">\(G(V,E)\)</span>，<span class="math inline">\(V\)</span> 是节点集合，<span class="math inline">\(E\)</span> 是节点对之间可能的连接集合）
<ul>
<li><span class="math inline">\(E\)</span> can be an adjacency list or
an adjacency matrix（ <span class="math inline">\(E\)</span>
可以是邻接表或邻接矩阵）</li>
</ul></li>
<li>For each edge <span class="math inline">\((u, v) \in E\)</span>, a
weight <span class="math inline">\(w(u, v)\)</span> specifies the cost
to connect <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> (distance, amount of wires,
etc.)（对于每条边 <span class="math inline">\((u, v) \in E\)</span>,
权重 <span class="math inline">\(w(u, v)\)</span> 指定连接 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 的成本）</li>
<li>Goal: Find an acyclic subset <span class="math inline">\(T \subseteq
E\)</span> that connects all of the vertices and whose total weight
<span class="math inline">\(w(T)\)</span> is minimized（寻找一个无环子集
<span class="math inline">\(T \subseteq E\)</span>
，连接所有顶点且总权重最小） <span class="math display">\[
  w (T) = \sum_ {(u, v) \in T} w (u, v)
  \]</span></li>
<li><span class="math inline">\(T\)</span> is acyclic and connects all
of the vertices（<span class="math inline">\(T\)</span>
无环且连接所有顶点）
<ul>
<li><span class="math inline">\(T\)</span> must form a tree (a spanning
tree)（<span class="math inline">\(T\)</span>
必须形成一棵树（生成树））</li>
<li><span class="math inline">\(T\)</span> has <span class="math inline">\(|V|-1\)</span> edges（<span class="math inline">\(T\)</span> 有 <span class="math inline">\(|V|-1\)</span> 条边）</li>
</ul></li>
<li>示例： <img src="image-26.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h4 id="最小生成树通用算法-mst-generic-method">最小生成树通用算法 (MST
Generic Method)</h4>
<ul>
<li><strong>Greedy</strong>
<ul>
<li>Intuition: grows the minimum spanning tree one edge at a
time（直觉：每次增长最小生成树的一条边）</li>
<li>select edges based on their weights and handle
cycles（根据权重选择边并处理环）</li>
</ul></li>
<li>通用算法： <figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">GENERIC-MST(G, w)</span></span>
<span class="line"><span style="color: #abb2bf">    A = ∅  # 初始化边集A为空</span></span>
<span class="line"><span style="color: #abb2bf">    while A does not form a spanning tree</span></span>
<span class="line"><span style="color: #abb2bf">        find an edge (u, v) that is safe for A</span></span>
<span class="line"><span style="color: #abb2bf">        A = A ∪ {(u, v)}</span></span>
<span class="line"><span style="color: #abb2bf">    return A</span></span></code></pre></div></div></figure></li>
<li>How do you find a safe edge?
<ul>
<li>An edge <span class="math inline">\((u, v)\)</span> is safe for a
set <span class="math inline">\(A\)</span> of edges if <span class="math inline">\(A \cup \{(u, v)\}\)</span> is also a subset of
some minimum spanning tree（如果 <span class="math inline">\(A \cup
\{(u, v)\}\)</span> 也是某个最小生成树的子集，则边 <span class="math inline">\((u, v)\)</span> 对于边集 <span class="math inline">\(A\)</span> 是安全的）</li>
<li>To find a safe edge, we use the cut property of minimum spanning
trees（为了找到一条安全边，我们使用最小生成树的割属性）</li>
</ul></li>
</ul>
<h4 id="安全边定理">安全边定理</h4>
<p><img src="image-31.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>基本定义
<ul>
<li>A cut <span class="math inline">\((S, V - S)\)</span> of an
undirected graph <span class="math inline">\(G(V, E)\)</span> is a
<strong>partition</strong> of <span class="math inline">\(V\)</span>（无向图 <span class="math inline">\(G(V, E)\)</span> 的割 <span class="math inline">\((S, V - S)\)</span> 是 <span class="math inline">\(V\)</span> 的一个划分）</li>
<li>An edge <span class="math inline">\((u, v) \in E\)</span>
<strong>crosses</strong> the cut <span class="math inline">\((S, V -
S)\)</span> if one of its endpoints belongs to <span class="math inline">\(S\)</span> and the other belongs to <span class="math inline">\(V - S\)</span>（如果边 <span class="math inline">\((u, v) \in E\)</span> 的两个端点分别属于 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(V -
S\)</span> ，则该边跨越割 <span class="math inline">\((S, V -
S)\)</span>）</li>
<li>A cut <strong>respects</strong> a set <span class="math inline">\(A\)</span> of edges if no edge in <span class="math inline">\(A\)</span> crosses the cut（如果 <span class="math inline">\(A\)</span> 中没有边跨越该割，则称该割尊重边集
<span class="math inline">\(A\)</span> ）</li>
<li>An edge is a <strong>light edge</strong> crossing a cut if its
weight is the minimum of any edge crossing the
cut（如果一条边的权重是跨越该割的任何边的最小值，则该边是跨越该割的轻边）</li>
</ul></li>
<li><strong>安全边定理</strong>：Edge <span class="math inline">\((u,v)\)</span> is safe for <span class="math inline">\(A\)</span> if,
<ol type="1">
<li>Let <span class="math inline">\(G(V, E)\)</span> be a connected,
undirected graph with a real-valued weight function <span class="math inline">\(w\)</span> defined on <span class="math inline">\(E\)</span> ;（设 <span class="math inline">\(G(V,
E)\)</span> 是一个连通的无向图，实值权重函数 <span class="math inline">\(w\)</span> 定义在 <span class="math inline">\(E\)</span> 上）</li>
<li>let <span class="math inline">\(A\)</span> be a subset of <span class="math inline">\(E\)</span> that is included in some minimum
spanning tree for <span class="math inline">\(G\)</span> ;（设 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(E\)</span> 的一个子集，包含在 <span class="math inline">\(G\)</span> 的某个最小生成树中）</li>
<li>let <span class="math inline">\((S,V - S)\)</span> be any cut of
<span class="math inline">\(G\)</span> that respects <span class="math inline">\(A\)</span> ;（设 <span class="math inline">\((S,V
- S)\)</span> 是 <span class="math inline">\(G\)</span> 的任意尊重 <span class="math inline">\(A\)</span> 的割）</li>
<li>let <span class="math inline">\((u, v)\)</span> be a light edge
crossing <span class="math inline">\((S, V - S)\)</span>,（令 <span class="math inline">\((u, v)\)</span> 是跨越 <span class="math inline">\((S, V - S)\)</span> 的轻边）</li>
</ol></li>
<li>证明：
<ul>
<li>Assume <span class="math inline">\(T\)</span> is a minimum spanning
tree (MST) that includes <span class="math inline">\(A\)</span> and
<span class="math inline">\((u, v) \notin T\)</span>,（假设 <span class="math inline">\(T\)</span> 是包含 <span class="math inline">\(A\)</span> 的最小生成树，且 <span class="math inline">\((u, v) \notin T\)</span>。）</li>
<li>We now construct another MST <span class="math inline">\(T^\prime\)</span> that includes <span class="math inline">\(A \cup \{(u, v)\}\)</span>（我们现在构造另一个包含
<span class="math inline">\(A \cup \{(u, v)\}\)</span> 的最小生成树
<span class="math inline">\(T^\prime\)</span>。）</li>
<li>At least one edge <span class="math inline">\((x, y)\)</span> in
<span class="math inline">\(T\)</span> in the path <span class="math inline">\(p\)</span> crosses the cut <span class="math inline">\((S, V - S)\)</span>（在路径 <span class="math inline">\(p\)</span> 中，<span class="math inline">\(T\)</span> 中至少有一条边 <span class="math inline">\((x, y)\)</span> 跨越割 <span class="math inline">\((S, V - S)\)</span>）</li>
<li><span class="math inline">\(T^{\prime} = (T - \{(x,y)\})\cup
\{(u,v)\}\)</span>
<ul>
<li>Since <span class="math inline">\(w(u,v)\leq w(x,y)\)</span>, we
have <span class="math inline">\(w(T^{\prime}) \leq w(T)\)</span>（由于
<span class="math inline">\(w(u,v)\leq w(x,y)\)</span> ，我们有 <span class="math inline">\(w(T^{\prime}) \leq w(T)\)</span> ）</li>
<li>Since <span class="math inline">\(T\)</span> is a minimum spanning
tree, we have <span class="math inline">\(w(T^{\prime}) =
w(T)\)</span>（由于 <span class="math inline">\(T\)</span>
是最小生成树，我们有 <span class="math inline">\(w(T^{\prime}) =
w(T)\)</span> ）</li>
<li>Thus, <span class="math inline">\(T^{\prime}\)</span> is also a
minimum spanning tree that contains <span class="math inline">\(A \cup
\{(u, v)\}\)</span>（因此，<span class="math inline">\(T^{\prime}\)</span> 也是最小生成树，且包含 <span class="math inline">\(A \cup \{(u, v)\}\)</span>）</li>
</ul></li>
</ul>
<img src="image-32.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h3 id="prim-算法">Prim 算法</h3>
<h4 id="概述">概述</h4>
<ul>
<li>概述：
<ul>
<li>The edges in the set <span class="math inline">\(A\)</span> always
form a single tree（边集 <span class="math inline">\(A\)</span>
总是形成一棵单一的树）</li>
<li>The tree starts from an arbitrary root vertex <span class="math inline">\(r\)</span> and grows until it spans all the
vertices in <span class="math inline">\(V\)</span>（树从任意根节点 <span class="math inline">\(r\)</span> 开始生长，直到覆盖 <span class="math inline">\(V\)</span> 中的所有顶点）</li>
<li>Each step adds to the tree <span class="math inline">\(A\)</span> an
edge that connects <span class="math inline">\(A\)</span> to an
<strong>isolated</strong> vertex with the minimum weight（每一步向树
<span class="math inline">\(A\)</span> 添加一条具有最小权重的边，将
<span class="math inline">\(A\)</span> 连接到孤立顶点）
<ul>
<li>This rule adds only edges that are safe for <span class="math inline">\(A\)</span> （该规则仅添加对 <span class="math inline">\(A\)</span> 安全的边）</li>
</ul></li>
</ul></li>
<li>A <strong>greedy</strong> algorithm</li>
<li>示例： <img src="image-27.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>Maintain a min-priority queue <span class="math inline">\(Q\)</span>
of all vertices that are not in the
tree（维护一个包含所有不在树中的顶点的最小优先队列 <span class="math inline">\(Q\)</span> ）
<ul>
<li>The minimum weight of any edge connecting <span class="math inline">\(v\)</span> to a vertex in the tree（连接 <span class="math inline">\(v\)</span> 到树中顶点的任何边的最小权重）</li>
</ul></li>
</ul>
<h4 id="算法伪代码-4">算法伪代码</h4>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">MST_PRIM(G, w, r)                           // Prim 最小生成树算法</span></span>
<span class="line"><span style="color: #abb2bf">    for each u in G.V                       // 初始化所有顶点</span></span>
<span class="line"><span style="color: #abb2bf">        u.key = ∞</span></span>
<span class="line"><span style="color: #abb2bf">        u.parent = NIL</span></span>
<span class="line"><span style="color: #abb2bf">    r.key = 0</span></span>
<span class="line"><span style="color: #abb2bf">    Q = ∅</span></span>
<span class="line"><span style="color: #abb2bf">    for each u in G.V</span></span>
<span class="line"><span style="color: #abb2bf">        INSERT(Q, u)</span></span>
<span class="line"><span style="color: #abb2bf">    while Q is not empty</span></span>
<span class="line"><span style="color: #abb2bf">        u = EXTRACT-MIN(Q)                  // 从优先队列中提取最小 key 的顶点 u</span></span>
<span class="line"><span style="color: #abb2bf">        for each v in G.Adj[u]              // 遍历 u 的所有邻接顶点 v</span></span>
<span class="line"><span style="color: #abb2bf">            if v in Q and w(u, v) &lt; v.key   // 如果 v 在队列中且边 (u, v) 的权重小于 v 的当前 key</span></span>
<span class="line"><span style="color: #abb2bf">                v.parent = u                // 更新 v 的父节点为 u</span></span>
<span class="line"><span style="color: #abb2bf">                v.key = w(u, v)             // 更新 v 的 key 为边 (u, v) 的权重</span></span>
<span class="line"><span style="color: #abb2bf">                DECREASE-KEY(Q, v, v.key)   // 按 key 下降更新优先队列 Q 中顶点 v 的位置</span></span></code></pre></div></div></figure>
<h4 id="最小最大优先队列-minmax-priority-queue">最小/最大优先队列
(Min/Max-Priority Queue)</h4>
<h5 id="定义-1">定义</h5>
<p><img src="image-28.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>(Binary) heap: a nearly complete binary
tree（二叉堆：一个近似完全二叉树）</li>
<li>The value of a node is at most (at least) the value of its
parent（节点的值小于等于（大于等于）其父节点的值）</li>
</ul>
<h5 id="算法伪代码-5">算法伪代码</h5>
<h6 id="basic-heap-operations">Basic Heap Operations</h6>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">PARENT(i)</span></span>
<span class="line"><span style="color: #abb2bf">    return floor(i / 2)                 // 返回节点 i 的父节点索引</span></span>
<span class="line"><span style="color: #abb2bf">LEFT(i)</span></span>
<span class="line"><span style="color: #abb2bf">    return 2 * i                        // 返回节点 i 的左子节点索引</span></span>
<span class="line"><span style="color: #abb2bf">RIGHT(i)</span></span>
<span class="line"><span style="color: #abb2bf">    return 2 * i + 1                    // 返回节点 i 的右子节点索引</span></span></code></pre></div></div></figure>
<h6 id="max-heap-operations">Max-Heap Operations</h6>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">MAX-HEAP-MAXIMUM(A)                     // 返回堆中的最大元素</span></span>
<span class="line"><span style="color: #abb2bf">    if A.heap_size &lt; 1</span></span>
<span class="line"><span style="color: #abb2bf">        error "heap underflow"</span></span>
<span class="line"><span style="color: #abb2bf">    return A[1]                         // 堆顶元素即为最大值</span></span></code></pre></div></div></figure>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">MAX-HEAPIFY(A, i)                       // 维护最大堆性质</span></span>
<span class="line"><span style="color: #abb2bf">    l = LEFT(i)                         // 获取左子节点索引</span></span>
<span class="line"><span style="color: #abb2bf">    r = RIGHT(i)                        // 获取右子节点索引</span></span>
<span class="line"><span style="color: #abb2bf">    if l &lt;= A.heap_size and A[l] &gt; A[i]</span></span>
<span class="line"><span style="color: #abb2bf">        largest = l                     // 左子节点较大</span></span>
<span class="line"><span style="color: #abb2bf">    else</span></span>
<span class="line"><span style="color: #abb2bf">        largest = i                     // 当前节点较大</span></span>
<span class="line"><span style="color: #abb2bf">    if r &lt;= A.heap_size and A[r] &gt; A[largest]</span></span>
<span class="line"><span style="color: #abb2bf">        largest = r                     // 右子节点较大</span></span>
<span class="line"><span style="color: #abb2bf">    if largest != i</span></span>
<span class="line"><span style="color: #abb2bf">        exchange A[i] with A[largest]   // 交换当前节点与较大子节点</span></span>
<span class="line"><span style="color: #abb2bf">        MAX-HEAPIFY(A, largest)         // 递归调整子树</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T(n) = O(\log n)
\]</span></p>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">MAX-HEAP-EXTRACT-MAX(A)                 // 从堆中提取并返回最大元素</span></span>
<span class="line"><span style="color: #abb2bf">    max = MAX-HEAP-MAXIMUM(A)           // 获取堆中的最大元素</span></span>
<span class="line"><span style="color: #abb2bf">    A[1] = A[A.heap_size]               // 用堆的最后一个元素替换堆顶</span></span>
<span class="line"><span style="color: #abb2bf">    A.heap_size = A.heap_size - 1       // 减小堆的大小</span></span>
<span class="line"><span style="color: #abb2bf">    MAX-HEAPIFY(A, 1)                   // 从堆顶开始调整堆</span></span>
<span class="line"><span style="color: #abb2bf">    return max                          // 返回最大值</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T(n) = O(\log n)
\]</span></p>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">MAX-HEAP-INCREASE-KEY(A, x, k)          // 把堆中元素 x 的值增加到 k</span></span>
<span class="line"><span style="color: #abb2bf">    if k &lt; A[x].key</span></span>
<span class="line"><span style="color: #abb2bf">        error "new key is smaller than current key"</span></span>
<span class="line"><span style="color: #abb2bf">    A[x].key = k                        // 更新元素 x 的值为 k</span></span>
<span class="line"><span style="color: #abb2bf">    while x &gt; 1 and A[PARENT(x)].key &lt; A[x].key // 向上调整堆</span></span>
<span class="line"><span style="color: #abb2bf">        exchange A[x] with A[PARENT(x)] // 交换当前节点与其父节点</span></span>
<span class="line"><span style="color: #abb2bf">        x = PARENT(x)                   // 移动到父节点位置</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T(n) = O(\log n)
\]</span></p>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">MAX-HEAP-INSERT(A, key)                // 向堆中插入新元素 key</span></span>
<span class="line"><span style="color: #abb2bf">    A.heap_size = A.heap_size + 1       // 增加堆的大小</span></span>
<span class="line"><span style="color: #abb2bf">    A[A.heap_size] = -∞                 // 在堆的末尾插入一个极小值</span></span>
<span class="line"><span style="color: #abb2bf">    MAX-HEAP-INCREASE-KEY(A, A.heap_size, key) // 将新元素的值增加到 key</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T(n) = O(\log n)
\]</span></p>
<p><img src="image-30.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h4 id="时间复杂度">时间复杂度</h4>
<ul>
<li>The total time for Prim’s algorithm is <span class="math inline">\(O(E \log V)\)</span>
<ul>
<li>Initialization for all vertices: <span class="math inline">\(O(V)\)</span></li>
<li><code>EXTRACT-MIN</code> operations: <span class="math inline">\(|V|\)</span> times, <span class="math inline">\(O(V \log V)\)</span></li>
<li>Update keys: <span class="math inline">\(O(E)\)</span> times, <span class="math inline">\(O(E \log V)\)</span></li>
</ul></li>
</ul>
<h3 id="kruskal-算法">Kruskal 算法</h3>
<h4 id="概述-1">概述</h4>
<ul>
<li>概述
<ol type="1">
<li>Initially, <span class="math inline">\(|V|\)</span> trees in the
forest（最初，森林中有 <span class="math inline">\(|V|\)</span>
棵树）</li>
<li>Find a <strong>safe</strong> edge to add by finding, of all the
edges that <strong>connect any two trees</strong> in the forest, an edge
<span class="math inline">\((u, v)\)</span> with the minimum
weight（通过在森林中连接任意两棵树的所有边中找到权重最小的边 <span class="math inline">\((u, v)\)</span> 来找到一条安全边进行添加）</li>
<li>Repeat until there is only one tree（重复直到只有一棵树）</li>
</ol></li>
<li>A <strong>greedy</strong> algorithm</li>
<li>示例 <img src="image-33.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h4 id="算法伪代码-6">算法伪代码</h4>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">MST_KRUSKAL(G, w)                               // Kruskal 最小生成树算法</span></span>
<span class="line"><span style="color: #abb2bf">    A = ∅                                      // 初始化边集 A 为空</span></span>
<span class="line"><span style="color: #abb2bf">    for each vertex v in G.V                    // 初始化每个顶点为单独的集合</span></span>
<span class="line"><span style="color: #abb2bf">        MAKE-SET(v)</span></span>
<span class="line"><span style="color: #abb2bf">    edges = all edges in G.E sorted by weight   // 按权重排序所有边</span></span>
<span class="line"><span style="color: #abb2bf">    for each edge (u, v) in edges               // 遍历排序后的边</span></span>
<span class="line"><span style="color: #abb2bf">        if FIND-SET(u) ≠ FIND-SET(v)            // 如果边 (u, v) 的两个端点属于不同集合</span></span>
<span class="line"><span style="color: #abb2bf">            A = A ∪ {(u, v)}                   // 将边 (u, v) 添加到边集 A 中</span></span>
<span class="line"><span style="color: #abb2bf">            UNION(u, v)                         // 合并两个集合</span></span>
<span class="line"><span style="color: #abb2bf">    return A                                    // 返回最小生成树的边集 A</span></span></code></pre></div></div></figure>
<h4 id="不相交集数据结构-disjoint-set-data-structure">不相交集数据结构
(Disjoint-set data structure)</h4>
<ul>
<li>Group <span class="math inline">\(n\)</span> distinct elements into
a collection of disjoint sets（将 <span class="math inline">\(n\)</span>
个不同的元素分组为不相交的集合）
<ul>
<li>with no elements in common（没有共同元素）</li>
</ul></li>
<li>A collection of <span class="math inline">\(S = \{S_1, S_2, \ldots,
S_n\}\)</span> of disjoint <strong>dynamic</strong>
sets（不相交动态集合的集合 <span class="math inline">\(S = \{S_1, S_2,
\ldots, S_n\}\)</span> ）</li>
<li>To identify each set, choose a representative, which is some member
of the set（为了识别每个集合，选择一个代表，它是集合中的某个成员）
<ul>
<li>E.g., choosing the smallest member in the
set（例如，选择集合中最小的成员）</li>
</ul></li>
<li>Three operations:
<ol type="1">
<li><code>MAKE-SET(x)</code>: creates a new set whose only member is
<span class="math inline">\(x\)</span>（创建一个新集合，其唯一成员是
<span class="math inline">\(x\)</span> ）
<ul>
<li>Also the representative（也是集合的代表）</li>
</ul></li>
<li><code>UNION(x, y)</code>: unites two disjoint, dynamic sets that
contain <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> into a new set that is the union of
these two sets（联合包含 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>
的两个不相交的动态集合，形成一个新的集合，该集合是这两个集合的并集）</li>
<li><code>FIND-SET(x)</code>: returns a pointer to the representative of
the unique set containing <span class="math inline">\(x\)</span>
（返回指向包含 <span class="math inline">\(x\)</span>
的唯一集合的代表的指针）</li>
</ol></li>
<li>There are <span class="math inline">\(n\)</span>
<code>MAKE-SET</code> operations and at most <span class="math inline">\(n - 1\)</span> <code>UNION</code> operations（有
<span class="math inline">\(n\)</span> 个 MAKE-SET 操作和最多 <span class="math inline">\(n - 1\)</span> 个 UNION 操作）</li>
</ul>
<h5 id="不相交集森林-disjoint-set-forests">不相交集森林 (Disjoint-set
forests)</h5>
<ul>
<li>A fast implementation of disjoint sets represents sets by
trees（不相交集的快速实现：通过树来表示集合）
<ul>
<li><strong>Each tree represents one
set</strong>（每棵树代表一个集合）</li>
<li>Each member points only to its parent（每个成员只指向其父节点）</li>
<li>The root contains the representative（根节点包含代表）</li>
</ul></li>
<li>Heuristic #1: union by rank（启发式方法＃1：按秩联合）
<ul>
<li>Rank: an upper bound on the height of the
node（秩：节点高度的上限）</li>
<li>The root with smaller rank points to the root with larger
rank（较小秩的根指向较大秩的根）</li>
</ul></li>
<li>Heuristic #2: path compression（启发式方法＃2：路径压缩）
<ul>
<li>The <code>FIND-SET</code> procedure updates each node to point
directly to the root（FIND-SET 过程更新每个节点以直接指向根节点）</li>
</ul></li>
</ul>
<h5 id="算法伪代码-7">算法伪代码</h5>
<h6 id="union-by-rank">Union by Rank</h6>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">UNION(x, y)                         // 合并包含 x 和 y 的两个集合</span></span>
<span class="line"><span style="color: #abb2bf">    LINK(FIND-SET(x), FIND-SET(y))</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">LINK(x, y)                          // 按秩联合两个集合的根节点 x 和 y</span></span>
<span class="line"><span style="color: #abb2bf">    if x.rank &gt; y.rank              // 如果 x 的秩大于 y 的秩</span></span>
<span class="line"><span style="color: #abb2bf">        y.p = x                     // y 指向 x</span></span>
<span class="line"><span style="color: #abb2bf">    else:</span></span>
<span class="line"><span style="color: #abb2bf">        x.p = y                     // 反之 x 指向 y，并更新秩</span></span>
<span class="line"><span style="color: #abb2bf">        if x.rank == y.rank</span></span>
<span class="line"><span style="color: #abb2bf">            y.rank = y.rank + 1</span></span></code></pre></div></div></figure>
<ul>
<li><code>UNION(c, f)</code> <img src="image-35.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h6 id="path-compression">Path Compression</h6>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">MAKE-SET(x)                     // 创建一个新集合，包含唯一成员 x</span></span>
<span class="line"><span style="color: #abb2bf">    x.p = x</span></span>
<span class="line"><span style="color: #abb2bf">    x.rank = 0                  // 初始化秩为 0</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">FIND-SET(x)</span></span>
<span class="line"><span style="color: #abb2bf">    if x != x.p                 // 如果 x 不是根节点</span></span>
<span class="line"><span style="color: #abb2bf">        x.p = FIND-SET(x.p)     // 更新父节点为树的根节点</span></span>
<span class="line"><span style="color: #abb2bf">    return x.p                  // 返回集合的代表：根节点</span></span></code></pre></div></div></figure>
<ul>
<li><code>FIND-SET(a)</code> <img src="image-34.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h5 id="时间复杂度-1">时间复杂度</h5>
<ul>
<li>The worst-case running time of the disjoint-set-forest: <span class="math inline">\(O(m\alpha(n))\)</span>
<ul>
<li><span class="math inline">\(n\)</span> is the number of
elements（元素数量）</li>
<li><span class="math inline">\(m\)</span> is the total number of
operations（操作总数）</li>
<li><span class="math inline">\(\alpha (n)\)</span> is a very slowly
growing function（增长极慢的反阿克曼函数）</li>
<li><span class="math inline">\(\alpha (n)\leq 4\)</span> for all
practical purposes（在所有实际应用中，<span class="math inline">\(\alpha
(n)\)</span> 不超过 4）</li>
</ul></li>
</ul>
<h4 id="时间复杂度-2">时间复杂度</h4>
<ul>
<li>The running time of Kruskal’s algorithm: <span class="math inline">\(O(E \log V)\)</span>
<ul>
<li><code>MAKE-SET</code> operations: <span class="math inline">\(O(V)\)</span></li>
<li>Sorting: <span class="math inline">\(O(E \log E) = O(E \log
V)\)</span></li>
<li><code>FIND-SET</code> operations: <span class="math inline">\(O(E)\)</span></li>
<li><code>UNION</code> operations: <span class="math inline">\(O(V)\)</span></li>
<li>The worst-case running time of the disjoint-set-forest: <span class="math inline">\(O\big ((E + V) \alpha (V) \big)\)</span></li>
</ul></li>
</ul>
<h2 id="最短路径-shortest-paths">最短路径 (Shortest Paths)</h2>
<h3 id="最短路径概述">最短路径概述</h3>
<ul>
<li>应用
<ul>
<li>Road networks（道路网络）</li>
<li>Logistics（物流）</li>
<li>Communications（通信）</li>
<li>Others</li>
</ul></li>
<li>分类
<ul>
<li><strong>Single-source shortest-paths
problem</strong>（单源最短路径问题）</li>
<li>Single-destination shortest-paths problem（单目的地最短路径问题）
<ul>
<li>reversing the direction of each edge in the
graph（通过反转图中每条边的方向，将其转换为单源最短路径问题）</li>
</ul></li>
<li>Single-pair shortest-path problem（单对最短路径问题）
<ul>
<li>a part of the single-source shortest-paths
problem（单源最短路径问题的一部分）</li>
</ul></li>
<li>All-pairs shortest-paths problem（全源最短路径问题）</li>
</ul></li>
</ul>
<h4 id="基本定义-1">基本定义</h4>
<ul>
<li>A weighted, directed graph <span class="math inline">\(G(V,E)\)</span>（加权有向图）</li>
<li>For each edge <span class="math inline">\((u, v) \in E\)</span>, a
weight <span class="math inline">\(w(u, v)\)</span> specifies the cost
to connect <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>
<ul>
<li><span class="math inline">\(w \colon E \to \mathbb{R}\)</span>
mapping edges to real-valued weights（将边映射到实值权重）</li>
</ul></li>
<li>The weight <span class="math inline">\(w(p)\)</span> of path <span class="math inline">\(p = \langle v_0, v_1, \dots, v_k \rangle\)</span>
is the sum of the weights of its constituent
edges（路径的权重是其组成边的权重之和） <span class="math display">\[
  w (p) = \sum_{1}^{k} w(v_{i - 1}, v_{i})
  \]</span></li>
<li>The shortest-path weight from <span class="math inline">\(u\)</span>
to <span class="math inline">\(v\)</span> is（从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的最短路径权重是） <span class="math display">\[
  \delta (u, v) = \left\{ \begin{array}{ll}
  \min  \{w (p) \colon u \xrightarrow {p} v \} &amp; \exists~p: u
\xrightarrow {p} v \\
  \infty &amp; \text{otherwise}
  \end{array} \right.
  \]</span></li>
<li>A shortest path from vertex <span class="math inline">\(u\)</span>
to vertex <span class="math inline">\(v\)</span> is then defined as any
path <span class="math inline">\(p\)</span> with weight <span class="math inline">\(w(p) = \delta(u, v)\)</span>(从顶点 <span class="math inline">\(u\)</span> 到顶点 <span class="math inline">\(v\)</span> 的最短路径被定义为权重为 <span class="math inline">\(w(p) = \delta(u, v)\)</span> 的任何路径 <span class="math inline">\(p\)</span> )</li>
</ul>
<h4 id="负权边与负权环-negative-weight-edges-and-cycles">负权边与负权环
(Negative-weight edges and cycles)</h4>
<ul>
<li>A graph is well-defined if no negative-weight cycle reachable from
the source <span class="math inline">\(s\)</span> exists（如果不存在从源
<span class="math inline">\(s\)</span> 可达的负权环，则图是良定义的）
<ul>
<li>Not well-defined <span class="math inline">\(\rightarrow \delta
(u,v) = -\infty\)</span></li>
</ul></li>
<li>Any shortest path contains at most <span class="math inline">\(|V| -
1\)</span> edges（任何最短路径最多包含 <span class="math inline">\(|V| -
1\)</span> 条边）
<ul>
<li>No positive-weight cycle</li>
</ul></li>
</ul>
<h3 id="dijkstra-算法">Dijkstra 算法</h3>
<ul>
<li>Solves the <strong>single-source shortest-paths problem</strong> for
a graph with nonnegative edge
weights（解决具有非负边权的图的单源最短路径问题）</li>
<li>a Greedy algorithm（贪心算法）</li>
</ul>
<h4 id="最优子结构-4">最优子结构</h4>
<ul>
<li>Let <span class="math inline">\(p = \langle v_0, v_1, \dots, v_k
\rangle\)</span> be a shortest path from vertex <span class="math inline">\(v_0\)</span> to vertex <span class="math inline">\(v_k\)</span>,（设 <span class="math inline">\(p\)</span> 是从顶点 <span class="math inline">\(v_0\)</span> 到顶点 <span class="math inline">\(v_k\)</span> 的最短路径）</li>
<li>For any <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> such that <span class="math inline">\(0
\leq i \leq j \leq k\)</span>, let <span class="math inline">\(p_{ij} =
\left\langle v_i, v_{i+1}, \ldots, v_j \right\rangle\)</span> be the
subpath of <span class="math inline">\(p\)</span> from vertex <span class="math inline">\(v_i\)</span> to vertex <span class="math inline">\(v_j\)</span>（对于 <span class="math inline">\(0
\leq i \leq j \leq k\)</span> 的任何 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> ，设 <span class="math inline">\(p_{ij}\)</span> 是从顶点 <span class="math inline">\(v_i\)</span> 到顶点 <span class="math inline">\(v_j\)</span> 的子路径）</li>
<li>Then <span class="math inline">\(p_{ij}\)</span> is a shortest path
from <span class="math inline">\(v_i\)</span> to <span class="math inline">\(v_j\)</span>,（则 <span class="math inline">\(p_{ij}\)</span> 是从 <span class="math inline">\(v_i\)</span> 到 <span class="math inline">\(v_j\)</span> 的最短路径）</li>
</ul>
<h4 id="松弛-relaxation">松弛 (Relaxation)</h4>
<ul>
<li>Relaxation is the process of continually decreasing the
shortest-path estimates by finding better
paths（松弛是通过寻找更好的路径不断降低最短路径估计值的过程）</li>
<li>Attribute <span class="math inline">\(v.d\)</span> : a shortest-path
estimate（属性 <span class="math inline">\(v.d\)</span>
：最短路径估计值）
<ul>
<li>An upper bound on the weight of a shortest path to <span class="math inline">\(v\)</span>（到 <span class="math inline">\(v\)</span> 的最短路径权重的上限）</li>
</ul></li>
<li>Attribute <span class="math inline">\(v.\pi\)</span>: a
predecessor（属性 <span class="math inline">\(v.\pi\)</span> ：前驱）
<ul>
<li>The chain of predecessors runs backward along a shortest
path（前驱链沿着最短路径向后运行）</li>
</ul></li>
<li>The process of relaxing an edge <span class="math inline">\((u,
v)\)</span> consists of testing whether going through vertex <span class="math inline">\(u\)</span> improves the shortest path to vertex
<span class="math inline">\(v\)</span>（松弛边 <span class="math inline">\((u, v)\)</span> 的过程包括测试通过顶点 <span class="math inline">\(u\)</span> 是否改善了到顶点 <span class="math inline">\(v\)</span> 的最短路径）</li>
<li>算法伪代码: <figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">INITIALIZE-SINGLE-SOURCE(G, s)  // 单源初始化</span></span>
<span class="line"><span style="color: #abb2bf">    for each vertex v in G.V</span></span>
<span class="line"><span style="color: #abb2bf">        v.d = ∞</span></span>
<span class="line"><span style="color: #abb2bf">        v.pi = NIL</span></span>
<span class="line"><span style="color: #abb2bf">    s.d = 0</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">RELAX(u, v, w)                  // 松弛操作，u 是起点，v 是终点，w 是权重函数</span></span>
<span class="line"><span style="color: #abb2bf">    if v.d &gt; u.d + w(u, v)</span></span>
<span class="line"><span style="color: #abb2bf">        v.d = u.d + w(u, v)</span></span>
<span class="line"><span style="color: #abb2bf">        v.pi = u</span></span></code></pre></div></div></figure> <img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h4 id="基本思路">基本思路</h4>
<ul>
<li>Assume nonnegative weights on all edges（假设所有边的权重均为非负）
<span class="math display">\[
  \forall (u,v) \in E, w(u,v) \geq 0
  \]</span></li>
<li>Generalizing breadth-first search (<strong>BFS</strong>) to weighted
graphs（将 BFS 泛化为加权图）</li>
<li>The algorithm maintains a set of vertices <span class="math inline">\(S\)</span>, whose final shortest-path weights have
already been determined（该算法维护一个顶点集 <span class="math inline">\(S\)</span> ，其最终最短路径权重已确定）</li>
<li>主要步骤
<ol type="1">
<li>Selects the vertex <span class="math inline">\(u \in V - S\)</span>
with the minimum shortest-path estimate（从 <span class="math inline">\(V - S\)</span> 中选择具有最小最短路径估计值的顶点
<span class="math inline">\(u\)</span>）
<ul>
<li>Using a min-priority queue <span class="math inline">\(Q\)</span>
instead of a FIFO queue（使用最小优先队列 <span class="math inline">\(Q\)</span> 代替 FIFO 队列）</li>
<li>The key of each vertex <span class="math inline">\(v\)</span> in
<span class="math inline">\(Q\)</span> is the shortest-path estimate
<span class="math inline">\(v.d\)</span> （队列中每个顶点 <span class="math inline">\(v\)</span> 的键是最短路径估计值 <span class="math inline">\(v.d\)</span> ）</li>
</ul></li>
<li>Relaxes all edges leaving <span class="math inline">\(u\)</span>（松弛 <span class="math inline">\(u\)</span> 的所有出边）</li>
<li>Repeat the above procedure <span class="math inline">\(|V|\)</span>
times（重复上述过程 <span class="math inline">\(|V|\)</span> 次）</li>
</ol></li>
</ul>
<h4 id="算法伪代码-8">算法伪代码</h4>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">DIJKSTRA(G, w, s)                       // G 是图，w 是权重函数，s 是源顶点</span></span>
<span class="line"><span style="color: #abb2bf">    INITIALIZE-SINGLE-SOURCE(G, s)</span></span>
<span class="line"><span style="color: #abb2bf">    S = ∅                               // 已确定最短路径权重的顶点集</span></span>
<span class="line"><span style="color: #abb2bf">    Q = ∅                               // 最小优先队列</span></span>
<span class="line"><span style="color: #abb2bf">    for each vertex v in G.V            // 将所有顶点插入最小优先队列 Q</span></span>
<span class="line"><span style="color: #abb2bf">        INSERT(Q, v)</span></span>
<span class="line"><span style="color: #abb2bf">    while Q ≠ ∅</span></span>
<span class="line"><span style="color: #abb2bf">        u = EXTRACT-MIN(Q)              // 从 Q 中提取具有最小 d 值的顶点 u</span></span>
<span class="line"><span style="color: #abb2bf">        S = S ∪ {u}                     // 将 u 添加到 S 中</span></span>
<span class="line"><span style="color: #abb2bf">        for each vertex v in Adj[u]     // 松弛 u 的所有出边</span></span>
<span class="line"><span style="color: #abb2bf">            RELAX(u, v, w)</span></span>
<span class="line"><span style="color: #abb2bf">    return</span></span></code></pre></div></div></figure>
<p><img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h4 id="正确性">正确性</h4>
<ul>
<li>每次从未确定最短路径的顶点集合中选出 <span class="math inline">\(d\)</span> 最小的顶点 <span class="math inline">\(u\)</span>，而一旦 <span class="math inline">\(u\)</span> 被取出，就认为 <span class="math inline">\(u.d\)</span> 已经是最短距离，不再更新。</li>
<li>我们要证明：这个“一旦取出就确定”的做法是正确的。</li>
</ul>
<p><img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h5 id="收敛性质">收敛性质</h5>
<ul>
<li>Convergence property: if <span class="math inline">\(s
\xrightarrow{p} x \to y\)</span> is a shortest path for some <span class="math inline">\(x, y \in V\)</span>, and if <span class="math inline">\(x.d = \delta(s, x)\)</span> at any time prior to
relaxing edge <span class="math inline">\((x, y)\)</span>, then <span class="math inline">\(y.d = \delta(s, y)\)</span> at all times
afterward（收敛性质：如果 <span class="math inline">\(s \xrightarrow{p}
x \to y\)</span> 是某些 <span class="math inline">\(x, y \in V\)</span>
的最短路径，并且如果在松弛边 <span class="math inline">\((x, y)\)</span>
之前的任何时间 <span class="math inline">\(x.d = \delta(s, x)\)</span>
，那么在之后的所有时间 <span class="math inline">\(y.d = \delta(s,
y)\)</span> ）
<ul>
<li>after relaxing edge <span class="math inline">\((x, y)\)</span>, we
have <span class="math inline">\(y.d \leq x.d + w(x,y) = \delta(s,x) +
w(x,y) = \delta(s,y)\)</span>
<ul>
<li>Optimal substructure: <span class="math inline">\(\delta(s,x) +
w(x,y) = \delta(s,y)\)</span></li>
</ul></li>
<li>and <span class="math inline">\(y.d \geq \delta(s,y)\)</span></li>
<li>Thus, <span class="math inline">\(y.d = \delta(s,y)\)</span></li>
</ul></li>
</ul>
<h5 id="边权重均为正的情况">边权重均为正的情况</h5>
<p><span class="math display">\[
\forall (u,v) \in E, w(u,v) &gt; 0
\]</span></p>
<ul>
<li>我们需要证明在每次迭代开始时，对于所有 <span class="math inline">\(v\in S\)</span>，都有 <span class="math inline">\(v.d = \delta(s,v)\)</span>（数学归纳法）
<ul>
<li>对于初始状态，<span class="math inline">\(S = \{s\}\)</span>，<span class="math inline">\(s.d = 0 = \delta(s,s)\)</span>，显然成立</li>
<li>假设第&nbsp;<span class="math inline">\(k\)</span>&nbsp;次迭代开始前，对于所有
<span class="math inline">\(v\in S\)</span>，都有 <span class="math inline">\(v.d = \delta(s,v)\)</span> 成立</li>
<li>在第&nbsp;<span class="math inline">\(k\)</span>&nbsp;次迭代开始前，算法将
<span class="math inline">\(u\)</span> 添加到 <span class="math inline">\(S\)</span>，我们需要证明 <span class="math inline">\(u.d = \delta (s,u)\)</span>（反证法）
<ul>
<li>假设 <span class="math inline">\(u.d \neq \delta (s,u)\)</span>，则
<span class="math inline">\(u.d &gt; \delta (s,u)\)</span>，则存在一条从
<span class="math inline">\(s\)</span> 到 <span class="math inline">\(u\)</span> 的最短路径 <span class="math inline">\(s \xrightarrow{p} u\)</span>，且 <span class="math inline">\(w(p) = \delta (s,u)\)</span></li>
<li>设 <span class="math inline">\(y\)</span> 是从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(u\)</span> 的最短路径 <span class="math inline">\(p\)</span> 上第一个不在 <span class="math inline">\(S\)</span> 中的顶点，即<span class="math inline">\(s \xrightarrow{p} x \to y\)</span>，若 <span class="math inline">\(y \neq u\)</span>
<ol type="1">
<li><span class="math inline">\(y\)</span> 在 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(u\)</span> 的最短路径上，有 <span class="math inline">\(\delta (s,y) &lt; \delta (s,u)\)</span></li>
<li>在这轮迭代中我们选择了 <span class="math inline">\(u\)</span>，则
<span class="math inline">\(u.d \leq y.d\)</span></li>
<li>此前当 <span class="math inline">\(x\)</span> 被添加时，边 <span class="math inline">\((x, y)\)</span> 被松弛，根据收敛性质， <span class="math inline">\(y.d = \delta (s,y)\)</span></li>
</ol></li>
<li>综上，<span class="math inline">\(\delta (s,y) &lt; \delta (s,u)
&lt; u.d \leq y.d = \delta (s,y)\)</span>，矛盾，故 <span class="math inline">\(u.d = \delta (s,u)\)</span></li>
</ul></li>
</ul></li>
</ul>
<h5 id="边权重均为非负的情况">边权重均为非负的情况</h5>
<p><span class="math display">\[
\forall (u,v) \in E, w(u,v) \geq 0
\]</span></p>
<ul>
<li>We prove that at the start of each iteration <span class="math inline">\(v.d = \delta(s,v)\)</span> for all <span class="math inline">\(v\in
S\)</span>（我们证明在每次迭代开始时，对于所有 <span class="math inline">\(v\in S\)</span> ，都有 <span class="math inline">\(v.d = \delta(s,v)\)</span> ）
<ul>
<li>Proof by induction</li>
</ul></li>
<li>In each iteration, the algorithm adds <span class="math inline">\(u\)</span> into <span class="math inline">\(S\)</span>（在每次迭代中，算法将 <span class="math inline">\(u\)</span> 添加到 <span class="math inline">\(S\)</span> ）
<ul>
<li>we prove that <span class="math inline">\(u.d =
\delta(s,u)\)</span>（我们证明 <span class="math inline">\(u.d =
\delta(s,u)\)</span> ）</li>
</ul></li>
<li>Let <span class="math inline">\(y\)</span> be the first vertex on a
shortest path from <span class="math inline">\(s\)</span> to <span class="math inline">\(u\)</span> that is not in <span class="math inline">\(S\)</span>（设 <span class="math inline">\(y\)</span> 是从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(u\)</span> 的最短路径上第一个不在 <span class="math inline">\(S\)</span> 中的顶点）
<ul>
<li>Thus, <span class="math inline">\(\delta (s,y)\leq \delta
(s,u)\)</span></li>
</ul></li>
<li>Also, <span class="math inline">\(\delta (s,u)\leq u.d\)</span> and
<span class="math inline">\(u.d\leq y.d\)</span>
<ul>
<li>because we add <span class="math inline">\(u\)</span></li>
</ul></li>
<li><span class="math inline">\(\delta (s,y)\leq \delta (s,u)\leq
u.d\leq y.d\)</span></li>
<li>Edge <span class="math inline">\((x, y)\)</span> was relaxed when
<span class="math inline">\(x\)</span> was added（当 <span class="math inline">\(x\)</span> 被添加时，边 <span class="math inline">\((x, y)\)</span> 被松弛）</li>
<li>Convergence property: if <span class="math inline">\(s
\xrightarrow{p} x \to y\)</span> is a shortest path for some <span class="math inline">\(x, y \in V\)</span>, and if <span class="math inline">\(x.d = \delta(s, x)\)</span> at any time prior to
relaxing edge <span class="math inline">\((x, y)\)</span>, then <span class="math inline">\(y.d = \delta(s, y)\)</span> at all times afterward
<ul>
<li>Proof: <span class="math inline">\(y.d \leq x.d + w(x,y) =
\delta(s,x) + w(x,y) = \delta(s,y)\)</span></li>
<li>Optimal substructure</li>
</ul></li>
<li>Since <span class="math inline">\(\delta (s,y)\leq \delta (s,u)\leq
u.d\leq y.d\)</span> and <span class="math inline">\(y.d \leq \delta
(s,y)\)</span>
<ul>
<li><span class="math inline">\(\delta (s,y) = \delta (s,u) = u.d =
y.d\)</span></li>
</ul></li>
</ul>
<h4 id="时间复杂度-3">时间复杂度</h4>
<ul>
<li>The algorithm calls both <code>INSERT</code> and
<code>EXTRACT-MIN</code> once per vertex（算法对每个顶点调用 INSERT 和
EXTRACT-MIN）
<ul>
<li><code>INSERT</code> and <code>EXTRACT-MIN</code> operations: <span class="math inline">\(|V|\)</span> times</li>
</ul></li>
<li>Each edge in the adjacency list <span class="math inline">\(Adj[u]\)</span> is examined and relaxed once.
Thus, the algorithm calls <code>RELAX</code> <span class="math inline">\(|E|\)</span> times, which may lead to calls to
<code>DECREASE-KEY</code>（邻接表 <span class="math inline">\(Adj[u]\)</span>
中的每条边都被检查和松弛一次。因此，算法调用 RELAX <span class="math inline">\(|E|\)</span> 次，这可能会导致调用 DECREASE-KEY）
<ul>
<li><code>DECREASE-KEY</code>: <span class="math inline">\(O(|E|)\)</span> times</li>
</ul></li>
<li>Simple implementation of min-priority queue <span class="math inline">\(Q\)</span>（最小优先队列 <span class="math inline">\(Q\)</span> 的简单实现）
<ul>
<li>Store <span class="math inline">\(v.d\)</span> in the <span class="math inline">\(v\)</span> th entry of an array（将 <span class="math inline">\(v.d\)</span> 存储在数组的第 <span class="math inline">\(v\)</span> 个条目中）</li>
<li><span class="math inline">\(T(n) = O(V^{2})\)</span>
<ul>
<li><span class="math inline">\(O(1)\)</span> time for each
<code>INSERT</code> and <code>DECREASE-KEY</code> operation: <span class="math inline">\(O(|V|+|E|)\)</span></li>
<li><span class="math inline">\(O(V)\)</span> time for each
<code>EXTRACT-MIN</code> operation: <span class="math inline">\(O(V^{2})\)</span></li>
</ul></li>
</ul></li>
<li>Binary min-heap implementation of min-priority
queue（最小优先队列的二进制最小堆实现）
<ul>
<li><span class="math inline">\(O(\log V)\)</span> time for each
<code>INSERT</code>, <code>EXTRACT-MIN</code> and
<code>DECREASE-KEY</code> operation: <span class="math inline">\(O((|V|+|E|)\log V)\)</span></li>
</ul></li>
</ul>
<h3 id="floyd-warshall-算法">Floyd-Warshall 算法</h3>
<ul>
<li>Can we solve an all-pairs shortest-paths problem by running
Dijkstra’s algorithm <span class="math inline">\(|V|\)</span>
times?（我们能否通过运行 Dijkstra 算法 <span class="math inline">\(|V|\)</span> 次来解决全源最短路径问题？）
<ul>
<li>Yes</li>
<li><span class="math inline">\(O(V^3)\)</span> if implementing the
min-priority queue with a linear
array（使用线性数组实现最小优先队列的时间复杂度）</li>
<li><span class="math inline">\(O(V^2 \log V + VE \log V)\)</span> if
implementing the min-priority queue with a binary
min-heap（使用二进制最小堆实现最小优先队列的时间复杂度）</li>
</ul></li>
<li>Use Floyd-Warshall algorithm to solve the <strong>all-pairs
shortest-paths problem</strong>（使用 Floyd-Warshall
算法解决全源最短路径问题）
<ul>
<li>Negative-weight edges may be present（允许负权边）</li>
<li>But no negative-weight cycle exists（不允许负权环）</li>
</ul></li>
<li>a Dynamic programming algorithm（动态规划算法）</li>
</ul>
<h4 id="基本思路-1">基本思路</h4>
<ul>
<li>Dynamic programming: the algorithm considers shortest paths from
<span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span> with all intermediate vertices in the
set <span class="math inline">\(\{1,2,\ldots,k\}\)</span>（动态规划：该算法考虑从
<span class="math inline">\(i\)</span> 到 <span class="math inline">\(j\)</span> 的所有中间顶点在集合 <span class="math inline">\(\{1,2,\ldots,k\}\)</span> 中的最短路径）
<ul>
<li>If <span class="math inline">\(k\)</span> is not an intermediate
vertex, then all intermediate vertices belong to the set <span class="math inline">\(\{1,2,\ldots,k-1\}\)</span>（如果 <span class="math inline">\(k\)</span> 不是中间顶点，则所有中间顶点属于集合
<span class="math inline">\(\{1,2,\ldots,k-1\}\)</span> ）</li>
<li>If <span class="math inline">\(k\)</span> is an intermediate vertex,
then decompose the path into <span class="math inline">\(i
\xrightarrow{p_1} k \xrightarrow{p_2} j\)</span>（如果 <span class="math inline">\(k\)</span> 是中间顶点，则将路径分解为 <span class="math inline">\(i \xrightarrow{p_1} k \xrightarrow{p_2} j\)</span>
）
<ul>
<li><span class="math inline">\(p_1\)</span> is a shortest path from
<span class="math inline">\(i\)</span> to <span class="math inline">\(k\)</span></li>
<li><span class="math inline">\(p_2\)</span> is a shortest path from
<span class="math inline">\(k\)</span> to <span class="math inline">\(j\)</span></li>
</ul></li>
</ul></li>
</ul>
<p><img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h4 id="最优子结构-5">最优子结构</h4>
<ul>
<li><span class="math inline">\(d_{ij}^{(k)}\)</span> : the weight of a
shortest path from vertex <span class="math inline">\(i\)</span> to
vertex <span class="math inline">\(j\)</span> for which all intermediate
vertices belong to the set <span class="math inline">\(\{1,2,\ldots,k\}\)</span>（从顶点 <span class="math inline">\(i\)</span> 到顶点 <span class="math inline">\(j\)</span>
的最短路径的权重，其中所有中间顶点属于集合 <span class="math inline">\(\{1,2,\ldots,k\}\)</span> ） <span class="math display">\[
d_{ij}^{(k)} = \left\{ \begin{array}{ll}
w_{ij} &amp; k = 0 \\
\min \{d_{ij}^{(k - 1)},d_{ik}^{(k - 1)} + d_{kj}^{(k - 1)}\} &amp;
k\geq 1
\end{array} \right.
\]</span></li>
<li>Final answer: <span class="math inline">\(D^{(n)} =
(d_{ij}^{(n)})\)</span></li>
</ul>
<h4 id="算法伪代码-9">算法伪代码</h4>
<ul>
<li>The <strong>bottom-up</strong> procedure（自底向上过程）</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">FLOYD-WARSHALL(W, n)                    // W 是权重矩阵，n 是顶点数</span></span>
<span class="line"><span style="color: #abb2bf">    let D^(0) = W                       // 初始化 D^(0)</span></span>
<span class="line"><span style="color: #abb2bf">    for k = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">        let D^(k) be a new n x n matrix</span></span>
<span class="line"><span style="color: #abb2bf">        for i = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">            for j = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">                D_ij^(k) = min{D_ij^(k - 1), D_ik^(k - 1) + D_kj^(k - 1)}</span></span>
<span class="line"><span style="color: #abb2bf">    return D^(n)                        // 返回最终结果</span></span></code></pre></div></div></figure>
<p><span class="math display">\[
T(n) = \Theta (n^3)
\]</span></p>
<p><img src="image-41.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h4 id="构造最短路径">构造最短路径</h4>
<ul>
<li><p>Construct the <strong>predecessor matrix</strong> <span class="math inline">\(\Pi\)</span>（构造前驱矩阵 <span class="math inline">\(\Pi\)</span> ）</p>
<ul>
<li><span class="math inline">\(\pi_{ij}^{(k)}\)</span> : the
predecessor of vertex <span class="math inline">\(j\)</span> on a
shortest path from vertex <span class="math inline">\(i\)</span> to
vertex <span class="math inline">\(j\)</span> for which all intermediate
vertices belong to the set <span class="math inline">\(\{1,2,\ldots,k\}\)</span>（从顶点 <span class="math inline">\(i\)</span> 到顶点 <span class="math inline">\(j\)</span> 的最短路径上顶点 <span class="math inline">\(j\)</span> 的前驱，其中所有中间顶点属于集合 <span class="math inline">\(\{1,2,\ldots,k\}\)</span> ）</li>
</ul></li>
<li><p><span class="math inline">\(k=0\)</span> <span class="math display">\[
  \pi_{ij}^{(0)} = \left\{ \begin{array}{ll}
  \mathrm{NIL} &amp; i = j~or~w_{ij} = \infty \\
  i &amp; i\neq j~and~w_{ij} &lt; \infty
  \end{array} \right.
  \]</span></p></li>
<li><p>For <span class="math inline">\(k\geq 1\)</span> <span class="math display">\[
  \pi_{ij}^{(k)} = \left\{ \begin{array}{ll}
  \pi_{kj}^{(k - 1)} &amp; \text{k~is~an~intermediate~vertex} \\
  \pi_{ij}^{(k - 1)} &amp; \text{k~is~not~an~intermediate~vertex}
  \end{array} \right.
  \]</span></p></li>
<li><p>The <strong>modified</strong> Floyd-Warshall algorithm（修改后的
Floyd-Warshall 算法） </p><figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">FLOYD-WARSHALL-MODIFIED(W, n)          // W 是权重矩阵，n 是顶点数</span></span>
<span class="line"><span style="color: #abb2bf">    let D^(0) = W                      // 初始化 D^(0)</span></span>
<span class="line"><span style="color: #abb2bf">    let Π^(0) = n x n matrix           // 初始化前驱矩阵 Π^(0)</span></span>
<span class="line"><span style="color: #abb2bf">    for i = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">        for j = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">            if i = j or w_ij = ∞</span></span>
<span class="line"><span style="color: #abb2bf">                π_ij^(0) = NIL</span></span>
<span class="line"><span style="color: #abb2bf">            else</span></span>
<span class="line"><span style="color: #abb2bf">                π_ij^(0) = i</span></span>
<span class="line"><span style="color: #abb2bf">    for k = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">        let D^(k) be a new n x n matrix</span></span>
<span class="line"><span style="color: #abb2bf">        let Π^(k) be a new n x n matrix</span></span>
<span class="line"><span style="color: #abb2bf">        for i = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">            for j = 1 to n</span></span>
<span class="line"><span style="color: #abb2bf">                if D_ij^(k - 1) ≤ D_ik^(k - 1) + D_kj^(k - 1)</span></span>
<span class="line"><span style="color: #abb2bf">                    D_ij^(k) = D_ij^(k - 1)</span></span>
<span class="line"><span style="color: #abb2bf">                    π_ij^(k) = π_ij^(k - 1)</span></span>
<span class="line"><span style="color: #abb2bf">                else</span></span>
<span class="line"><span style="color: #abb2bf">                    D_ij^(k) = D_ik^(k - 1) + D_kj^(k - 1)</span></span>
<span class="line"><span style="color: #abb2bf">                    π_ij^(k) = π_kj^(k - 1)</span></span>
<span class="line"><span style="color: #abb2bf">    return D^(n), Π^(n)                 // 返回最终结果</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">PRINT-PATH(Π, i, j)                     // 打印从 i 到 j 的最短路径</span></span>
<span class="line"><span style="color: #abb2bf">    if i == j</span></span>
<span class="line"><span style="color: #abb2bf">        print i</span></span>
<span class="line"><span style="color: #abb2bf">    else if π_ij == NIL</span></span>
<span class="line"><span style="color: #abb2bf">        print "no path from" i "to" j "exists"</span></span>
<span class="line"><span style="color: #abb2bf">    else</span></span>
<span class="line"><span style="color: #abb2bf">        PRINT-PATH(Π, i, π_ij)</span></span>
<span class="line"><span style="color: #abb2bf">        print j</span></span></code></pre></div></div></figure><p></p></li>
</ul>
<h1 id="分布式算法">分布式算法</h1>
<h2 id="分布式计算-distributed-computation">分布式计算 (Distributed
Computation)</h2>
<h3 id="进程-processes">进程 (Processes)</h3>
<ul>
<li>Abstract clusters, physical/virtual machines, processors, cores,
threads, etc. as
processes（将集群、物理/虚拟机、处理器、内核、线程等抽象为进程）</li>
<li>We assume (unless stated otherwise):
<ul>
<li>Finite set of processes（有限的进程集）
<ul>
<li>the set of processes in the system is denoted by <span class="math inline">\(\Pi\)</span>, where <span class="math inline">\(N
= |\Pi|\)</span>（系统中的进程集表示为 <span class="math inline">\(\Pi\)</span> ，其中 <span class="math inline">\(N
= |\Pi|\)</span> ）</li>
<li>each process is modeled as a state
machine（每个进程都被建模为一个状态机）</li>
<li>covers most scenarios (except permissionless settings such as
Bitcoin)（涵盖大多数场景（除比特币等无权限设置外））</li>
</ul></li>
<li>Processes have unique identities and know each
other（进程具有唯一标识符并相互了解）</li>
<li>(Message passing) bidirectional point-to-point
links（（消息传递）双向点对点链接）
<ul>
<li>Pairs of processes are connected by a link (or channel)through which
the processes exchange
messages（进程对通过链接（或通道）连接，通过该链接（或通道）交换消息）</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img src="image-42.webp" srcset="/img/loading/loading3.gif" lazyload alt="Processes and communication">
<figcaption aria-hidden="true">Processes and communication</figcaption>
</figure>
<h3 id="本地步骤-local-steps">本地步骤 (Local steps)</h3>
<ul>
<li>Process <span class="math inline">\(p_i\)</span> computation
proceeds in steps（进程 <span class="math inline">\(p_i\)</span>
的计算按步骤进行）
<ol type="1">
<li>Send event: put a message in <span class="math inline">\(\mathrm{outbuf}_i[j]\)</span>, for every neighbor
<span class="math inline">\(p_j\)</span>（发送事件：将消息放入 <span class="math inline">\(\mathrm{outbuf}_i[j]\)</span>，对于每个邻居 <span class="math inline">\(p_j\)</span> ）</li>
<li>Receive event: get messages m from <span class="math inline">\(\mathrm{inbuf}_i[*]\)</span>（接收事件：从 <span class="math inline">\(\mathrm{inbuf}_i[*]\)</span> 中获取消息 m）</li>
<li>Computation event: Perform local computation <span class="math inline">\(\rightarrow\)</span> Change
state（计算事件：执行本地计算 <span class="math inline">\(\rightarrow\)</span> 更改状态）
<ul>
<li>Local state changes from current state S to new state <span class="math inline">\(S^{\prime}\)</span> as <span class="math inline">\(S^{\prime} = f(S, m)\)</span>（本地状态从当前状态
S 更改为新状态 <span class="math inline">\(S^{\prime} = f(S, m)\)</span>
） <img src="image-43.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
</ol></li>
</ul>
<h3 id="消息传递-message-passing">消息传递 (Message passing)</h3>
<ul>
<li><span class="math inline">\(\mathrm{Inbuf}_i[j]\)</span>
<ul>
<li>Holds messages sent by <span class="math inline">\(p_j\)</span>
delivered to (but not processed by) <span class="math inline">\(p_i\)</span>（保存由 <span class="math inline">\(p_j\)</span> 发送并交付给 <span class="math inline">\(p_i\)</span>，且 <span class="math inline">\(p_i\)</span> 未处理的消息）</li>
</ul></li>
<li><span class="math inline">\(\mathrm{Outbuf}_i[j]\)</span>
<ul>
<li>Holds messages sent by <span class="math inline">\(p_i\)</span> not
delivered to <span class="math inline">\(p_j\)</span>（保存由 <span class="math inline">\(p_i\)</span> 发送但尚未未交付给 <span class="math inline">\(p_j\)</span> 的消息）</li>
</ul></li>
<li>Message <span class="math inline">\(m\)</span> sent by <span class="math inline">\(p_i\)</span> to <span class="math inline">\(p_j\)</span>:
<ol type="1">
<li>First in <span class="math inline">\(\mathrm{Outbuf}_i[j]\)</span></li>
<li>Upon delivery, in <span class="math inline">\(\mathrm{Inbuf}_j[i]\)</span></li>
</ol></li>
</ul>
<h3 id="执行和配置-executions-and-configurations">执行和配置 (Executions
and configurations)</h3>
<ul>
<li>The execution of a distributed algorithm is represented by a
sequence of steps executed by the
processes.（分布式算法的执行由进程执行的一系列步骤表示。）</li>
<li>Configuration <span class="math inline">\(C\)</span> is a vector of
individual process states（配置 <span class="math inline">\(C\)</span>
是各个进程状态的向量） <span class="math display">\[
  C = \left(S^{1}, S^{2}, \dots S^{n}\right)
\]</span></li>
<li>The execution captures the evolution of the global
state（执行捕获全局状态的演变） <span class="math display">\[
  C_0 \xrightarrow{s_1} C_1 \xrightarrow{s_2} C_2 \xrightarrow{s_3} C_3
\cdots
  \]</span>
<ul>
<li><span class="math inline">\(s_k\)</span> is a step taken by some
process（其中 <span class="math inline">\(s_k\)</span>
是某个进程采取的步骤）</li>
</ul></li>
<li>A configuration is a global state（配置是全局状态）
<ul>
<li>Not accessible to processes!（进程无法访问！）</li>
<li>We need it for reasoning about
algorithms（我们需要它来推理算法）</li>
</ul></li>
</ul>
<h3 id="进程的步骤和分层-step-of-a-process-and-layering">进程的步骤和分层
(Step of a process and layering)</h3>
<p><img src="image-44.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h3 id="分布式算法栈-distributed-algorithm-stack">分布式算法栈
(Distributed Algorithm Stack)</h3>
<p><img src="image-93.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h2 id="任务处理器-job-handlers">任务处理器 (Job Handlers)</h2>
<h3 id="规范">规范</h3>
<ul>
<li>Name: JobHandler, instance <span class="math inline">\(jh\)</span>.</li>
<li>Request: <code>&lt;jh, Submit | job&gt;</code>: Requests a job to be
processed.（请求处理作业）</li>
<li>Indication: <code>&lt;jh, Confirm | job&gt;</code>: Confirms that
the given job has been (or will be)
processed.（确认给定的作业已被（或将被）处理）
<ul>
<li>Think of indication as a <strong>callback</strong>
function（可以将指示视为回调函数）</li>
</ul></li>
<li>Properties:
<ul>
<li>JH1. <strong>Guaranteed response</strong>: Every submitted job is
eventually confirmed.（保证响应：每个提交的作业最终都会得到确认。）</li>
</ul></li>
</ul>
<h3 id="算法同步作业处理程序-synchronous-jobhandler">算法：同步作业处理程序
(Synchronous JobHandler)</h3>
<ul>
<li>Implements: JobHandler, instance <span class="math inline">\(jh\)</span>.</li>
<li>Get familiar with the event-driven style（熟悉事件驱动风格）</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">upon event &lt;jh, Submit | job&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    process (job);</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;jh, Confirm | job&gt;;</span></span></code></pre></div></div></figure>
<h3 id="算法异步作业处理程序-asynchronous-jobhandler">算法：异步作业处理程序
(Asynchronous JobHandler)</h3>
<ul>
<li>Implements: JobHandler, instance <span class="math inline">\(jh\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">upon event &lt;jh, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    buffer := ∅;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;jh, Submit | job&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    buffer := buffer ∪ {job};</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;jh, Confirm | job&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">upon buffer ≠ ∅ do</span></span>
<span class="line"><span style="color: #abb2bf">    job := select job(buffer);</span></span>
<span class="line"><span style="color: #abb2bf">    process (job);</span></span>
<span class="line"><span style="color: #abb2bf">    buffer := buffer \ {job};</span></span></code></pre></div></div></figure>
<h2 id="故障-failures">故障 (Failures)</h2>
<h3 id="进程故障-process-failures">进程故障 (Process Failures)</h3>
<ul>
<li>A failure occurs when a process does not behave according to the
algorithm（当进程未按照算法运行时，就会发生故障）
<ul>
<li>A process that does not fail is called
correct（未发生故障的进程称为正确进程）</li>
<li>A process that fails is called
faulty（发生故障的进程称为故障进程）</li>
</ul></li>
<li>Faulty processes:
<ul>
<li><strong>Crash</strong> (crash-stop)（崩溃）
<ul>
<li>Process stops execution of the algorithm:
crashes（进程停止算法的执行：崩溃）</li>
<li>Process may crash in the middle of a step. Notably, of a send
event（进程可能在步骤中间崩溃。特别是发送事件）</li>
</ul></li>
<li>Crash-recovery（崩溃恢复）
<ul>
<li>Process might temporarily crash, but then recover its state and
proceed taking
steps（进程可能会暂时崩溃，但随后恢复其状态并继续采取步骤）</li>
<li>Process may crash and recover for an infinite number of
times（进程可能会无限次崩溃并恢复）</li>
</ul></li>
<li>Omission（遗漏）
<ul>
<li>The process omits to send/receive messages it is supposed to
send/receive（进程省略了它应该发送/接收的消息）</li>
<li>Due to, e.g., buffer overflows or network
congestion（例如，由于缓冲区溢出或网络拥塞）</li>
</ul></li>
<li>Byzantine（拜占庭故障）
<ul>
<li>Unrestricted, arbitrary（不受限制的，任意的）</li>
<li>Malicious behavior allowed, models intrusions, bugs,
etc.（允许恶意行为，模拟入侵、错误等。）</li>
<li>Special case: Authenticated Byzantine
fault（特殊情况：经过身份验证的拜占庭故障）
<ul>
<li>Faulty process cannot subvert cryptographic primitives (e.g.,
digital signatures)（故障进程无法颠覆加密原语（例如数字签名））</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="过程故障层次结构-process-failures-hierarchy">过程故障层次结构
(Process failures hierarchy)</h3>
<p><img src="image-45.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h2 id="通信-communication">通信 (Communication)</h2>
<h3 id="链路故障-link-failures">链路故障 (Link failures)</h3>
<ul>
<li>It is possible for messages to be lost（消息可能会丢失）
<ul>
<li>Due to, e.g., best-effort delivery at the Internet
layer（例如，由于互联网层的尽力交付）</li>
</ul></li>
<li>But, the probability for a message to reach its destination is
nonzero（但是，消息到达其目的地的概率非零）</li>
<li>Keep on retransmitting messages until they reach their
destinations（继续重传消息，直到它们到达目的地）
<ul>
<li>At a higher layer, end-to-end
argument（在更高的层次上，端到端论证）</li>
</ul></li>
</ul>
<h3 id="公平丢弃链路-fair-loss-links">公平丢弃链路 (Fair-loss
links)</h3>
<h4 id="规范-1">规范</h4>
<ul>
<li>Name: FairLossPointToPointLinks, instance <span class="math inline">\(fll\)</span>.</li>
<li>Request: <code>&lt;fll, Send | q, m &gt;</code>: Requests to send
message <span class="math inline">\(m\)</span> to process <span class="math inline">\(q\)</span>.（请求将消息 <span class="math inline">\(m\)</span> 发送到进程 <span class="math inline">\(q\)</span>）</li>
<li>Indication: <code>&lt;fll, Deliver | p, m &gt;</code>: Delivers
message <span class="math inline">\(m\)</span> sent by process <span class="math inline">\(p\)</span>.（交付由进程 <span class="math inline">\(p\)</span> 发送的消息 <span class="math inline">\(m\)</span>）</li>
<li>Properties:
<ul>
<li>FLL1. <strong>Fair-loss</strong>: If a correct process <span class="math inline">\(p\)</span> infinitely often sends a message <span class="math inline">\(m\)</span> to a correct process <span class="math inline">\(q\)</span>, then <span class="math inline">\(q\)</span> delivers <span class="math inline">\(m\)</span> an infinite number of
times.（公平丢弃：如果正确进程 <span class="math inline">\(p\)</span>
无限次地将消息 <span class="math inline">\(m\)</span> 发送到正确进程
<span class="math inline">\(q\)</span> ，则 <span class="math inline">\(q\)</span> 无限次地交付 <span class="math inline">\(m\)</span> 。）</li>
<li>FLL2. <strong>Finite duplication</strong>: If a correct process
<span class="math inline">\(p\)</span> sends a message <span class="math inline">\(m\)</span> a finite number of times to process
<span class="math inline">\(q\)</span>, then <span class="math inline">\(m\)</span> cannot be delivered an infinite number
of times by <span class="math inline">\(q\)</span>,（有限重复：如果正确进程 <span class="math inline">\(p\)</span> 将消息 <span class="math inline">\(m\)</span> 有限次地发送到进程 <span class="math inline">\(q\)</span> ，则 <span class="math inline">\(m\)</span> 不能被 <span class="math inline">\(q\)</span> 无限次地交付。）</li>
<li>FLL3. <strong>No creation</strong>: If some process <span class="math inline">\(q\)</span> delivers a message <span class="math inline">\(m\)</span> with sender <span class="math inline">\(p\)</span> then <span class="math inline">\(m\)</span> was previously sent to <span class="math inline">\(q\)</span> by process <span class="math inline">\(p\)</span>.（无创建：如果某个进程 <span class="math inline">\(q\)</span> 交付了带有发送者 <span class="math inline">\(p\)</span> 的消息 <span class="math inline">\(m\)</span> ，则该消息 <span class="math inline">\(m\)</span> 先前已由进程 <span class="math inline">\(p\)</span> 发送给 <span class="math inline">\(q\)</span> 。）</li>
</ul></li>
<li>Correspond to <strong>UDP</strong>（对应于 UDP）</li>
</ul>
<h3 id="顽固链路-stubborn-links">顽固链路 (Stubborn links)</h3>
<h4 id="规范-2">规范</h4>
<ul>
<li>Name: StubbornPointToPointLinks, instance <span class="math inline">\(sl\)</span>.</li>
<li>Request: <code>&lt;sl, Send | q, m&gt;</code>: Requests to send
message <span class="math inline">\(m\)</span> to process <span class="math inline">\(q\)</span>.（请求将消息 <span class="math inline">\(m\)</span> 发送到进程 <span class="math inline">\(q\)</span>）</li>
<li>Indication: <code>&lt;sl, Deliver | p, m&gt;</code>: Delivers
message <span class="math inline">\(m\)</span> sent by process <span class="math inline">\(p\)</span>.（交付由进程 <span class="math inline">\(p\)</span> 发送的消息 <span class="math inline">\(m\)</span>）</li>
<li>Properties:
<ul>
<li>SL1. <strong>Stubborn delivery</strong>: If a correct process <span class="math inline">\(p\)</span> sends a message <span class="math inline">\(m\)</span> once to a correct process <span class="math inline">\(q\)</span>, then <span class="math inline">\(q\)</span> delivers <span class="math inline">\(m\)</span> an infinite number of
times.（顽固交付：如果正确进程 <span class="math inline">\(p\)</span>
向正确进程 <span class="math inline">\(q\)</span> 发送一次消息 <span class="math inline">\(m\)</span> ，则 <span class="math inline">\(q\)</span> 无限次地交付 <span class="math inline">\(m\)</span>。）</li>
<li>SL2. <strong>No creation</strong>: If some process <span class="math inline">\(q\)</span> delivers a message <span class="math inline">\(m\)</span> with sender <span class="math inline">\(p\)</span>, then <span class="math inline">\(m\)</span> was previously sent to <span class="math inline">\(q\)</span> by process <span class="math inline">\(p\)</span>.（无创建：如果某个进程 <span class="math inline">\(q\)</span> 交付了 <span class="math inline">\(p\)</span> 发送的消息 <span class="math inline">\(m\)</span>，则该消息 <span class="math inline">\(m\)</span> 先前已由进程 <span class="math inline">\(p\)</span> 发送给 <span class="math inline">\(q\)</span>。）</li>
</ul></li>
<li>I.e., retransmission mechanism（即，重传机制）</li>
</ul>
<h4 id="算法无限重传-retransmit-forever">算法：无限重传 (Retransmit
Forever)</h4>
<ul>
<li>Implemented: StubbornLink, instance <span class="math inline">\(sl\)</span>.</li>
<li>Uses: FairLossLink, instance <span class="math inline">\(fll\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 sl，sent 保存已发送但可能未被接收的消息（以备重传），设置定时器 △</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;sl, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    sent := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    starttimer(△);</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 定时器到期时，重传所有已发送的消息</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;Timeout&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    forall (q, m) ∈ sent do</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;fll, Send | q, m&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">    starttimer(△);</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 发送消息时，使用下层 fll 发送，并将消息加入 sent 集合以备重传</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;sl, Send | q, m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;fll, Send | q, m&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">    sent := sent ∪ {(q, m)};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当下层 fll 交付消息时，sl 也直接交付该消息</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;fll, Deliver | p, m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;sl, Deliver | p, m&gt;;</span></span></code></pre></div></div></figure>
<h3 id="可靠链路-perfectreliable-links">可靠链路 (Perfect/Reliable
links)</h3>
<h4 id="规范-3">规范</h4>
<ul>
<li>Name: PerfectPointToPointLinks, instance <span class="math inline">\(pl\)</span>.</li>
<li>Request: <code>&lt;pl, Send | q, m&gt;</code>: Requests to send
message <span class="math inline">\(m\)</span> to process <span class="math inline">\(q\)</span>.（请求将消息 <span class="math inline">\(m\)</span> 发送到进程 <span class="math inline">\(q\)</span>）</li>
<li>Indication: <code>&lt;pl, Deliver | p, m&gt;</code>: Delivers
message <span class="math inline">\(m\)</span> sent by process <span class="math inline">\(p\)</span>.（交付由进程 <span class="math inline">\(p\)</span> 发送的消息 <span class="math inline">\(m\)</span>）</li>
<li>Properties:
<ul>
<li>PL1. <strong>Reliable delivery</strong>: If a correct process <span class="math inline">\(p\)</span> sends a message <span class="math inline">\(m\)</span> to a correct process <span class="math inline">\(q\)</span>, then <span class="math inline">\(q\)</span> eventually delivers <span class="math inline">\(m\)</span>.（可靠交付：如果正确进程 <span class="math inline">\(p\)</span> 向正确进程 <span class="math inline">\(q\)</span> 发送消息 <span class="math inline">\(m\)</span>，则 <span class="math inline">\(q\)</span> 最终会交付 <span class="math inline">\(m\)</span> 。）</li>
<li>PL2. <strong>No duplication</strong>: No message is delivered by a
process more than once.（无重复：进程不会多次交付同一条消息。）</li>
<li>PL3. <strong>No creation</strong>: If some process <span class="math inline">\(q\)</span> delivers a message <span class="math inline">\(m\)</span> with sender <span class="math inline">\(p\)</span>, then <span class="math inline">\(m\)</span> was previously sent to <span class="math inline">\(q\)</span> by process <span class="math inline">\(p\)</span>.（无创建：如果某个进程 <span class="math inline">\(q\)</span> 交付了 <span class="math inline">\(p\)</span> 发送的消息 <span class="math inline">\(m\)</span>，则该消息 <span class="math inline">\(m\)</span> 先前已由进程 <span class="math inline">\(p\)</span> 发送给 <span class="math inline">\(q\)</span> 。）</li>
</ul></li>
<li>Correspond to <strong>TCP</strong>（对应于 TCP）</li>
</ul>
<h4 id="算法消除重复-eliminate-duplicates">算法：消除重复 (Eliminate
Duplicates)</h4>
<ul>
<li>Implemented: PerfectPointToPointLinks, instance <span class="math inline">\(pl\)</span>.</li>
<li>Uses: StubbornPointToPointLinks, instance <span class="math inline">\(sl\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 pl，delivered 保存已交付的消息</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;pl, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := ∅;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 发送消息时，直接使用下层 sl 发送</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;pl, Send | q, m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;sl, Send | q, m&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当下层 sl 交付消息时，检查消息是否已交付，若未交付则记录并交付</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;sl, Deliver | p, m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    if m ∉ delivered then</span></span>
<span class="line"><span style="color: #abb2bf">        delivered := delivered ∪ {m};</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;pl, Deliver | p, m&gt;;</span></span></code></pre></div></div></figure>
<blockquote>
<ul>
<li>本课程中默认可靠链路
<ul>
<li>Asynchronous message passing:（异步消息传递）
<ul>
<li>Perfect links + Fully connected network（完美链接 +
全连接网络）</li>
<li>Unless stated otherwise（除非另有说明）</li>
</ul></li>
<li>Perfect links
<ul>
<li>Roughly, guarantee that a message sent between two correct processes
will not be
lost（大致上，保证在两个正确进程之间发送的消息不会丢失）</li>
<li>i.e., eventual delivery is guaranteed（即，保证最终交付）</li>
</ul></li>
<li>NB: Perfect links <span class="math inline">\(\neq\)</span>
FIFO（注意：完美链接 <span class="math inline">\(\neq\)</span> FIFO）
<ul>
<li>Messages may be delivered out of order（消息可能会乱序交付）</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h2 id="时序假设-timing-assumptions">时序假设 (Timing Assumptions)</h2>
<ul>
<li>Whether or not we can make any assumption about time bounds
on（我们是否可以对以下内容做出任何时间界限的假设）
<ul>
<li>communication delays（通信延迟）</li>
<li>process speeds（进程速度）</li>
<li>clock drifts（时钟漂移）</li>
</ul></li>
</ul>
<h3 id="同步消息传递-synchronous-message-passing">同步消息传递
(Synchronous message passing)</h3>
<ul>
<li>Stronger model, makes timing assumptions（更强的模型，做出时间假设）
<ul>
<li><strong>Propagation delays</strong>（传播延迟）
<ul>
<li>there is a known upper bound limit <span class="math inline">\(\Delta_{delay}\)</span> on the time it takes for a
message to be delivered（消息交付所需时间有一个已知的上限）</li>
</ul></li>
<li><strong>Process speed</strong>（进程速度）
<ul>
<li>the time it takes to execute a step is bounded and known, say <span class="math inline">\(\Delta_{proc}\)</span>（执行一个步骤所需的时间是有界且已知的）</li>
</ul></li>
<li><strong>Clocks</strong>（时钟）
<ul>
<li>the drift <span class="math inline">\(\Delta_{drift}\)</span>
between a local clock and the global real time clock is bounded and
known（本地时钟与全球实时时钟之间的漂移是有界且已知的）</li>
<li>the global real time clock is a fictional
device（全球实时时钟是一个虚构的设备）</li>
</ul></li>
</ul></li>
<li>Simplifies communication model（简化通信模型）
<ul>
<li>Rounds: <span class="math inline">\(\Delta_{delay} + \Delta_{proc} +
\Delta_{drift}\)</span> per round</li>
<li>In every round, every process executes one step (send, receive,
compute)（在每一轮中，每个进程执行一个步骤（发送、接收、计算）） <img src="image-46.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
</ul>
<h3 id="异步消息传递-asynchronous-message-passing">异步消息传递
(Asynchronous message passing)</h3>
<ul>
<li>Much simpler, no timing assumptions（进一步简化，无时间假设）
<ul>
<li>messages can be delayed arbitrarily
long（消息可以被任意长时间延迟）</li>
<li>processes can be arbitrarily slow or fast（进程可以任意慢或快）</li>
<li>clocks can drift arbitrarily（时钟可以任意漂移）</li>
</ul></li>
</ul>
<h3 id="最终同步消息传递-eventually-synchronous-message-passing">最终同步消息传递
(Eventually synchronous message passing)</h3>
<ul>
<li><strong>Eventually synchronous</strong>: models “in
between”（最终同步： 模型“介于两者之间”）</li>
<li>In practice, distributed systems are synchronous most of the
time（在实践中，分布式系统大部分时间是同步的）
<ul>
<li>Formally, propagation delay <span class="math inline">\((\Delta_{delay})\)</span> and process speed <span class="math inline">\((\Delta_{proc})\)</span> are bounded after some
<strong>unknown</strong>
time（正式地说，在某个未知时间之后，传播延迟和进程速度是有界的）</li>
<li><span class="math inline">\(\Delta = \Delta_{delay} +
\Delta_{proc}\)</span></li>
<li>Or, <span class="math inline">\(\Delta\)</span> is not known a
priori（或者 <span class="math inline">\(\Delta\)</span> 事先未知）</li>
</ul>
<img src="image-47.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h2 id="故障检测器-failure-detectors-fds">故障检测器 (Failure detectors,
FDs)</h2>
<ul>
<li>When a process in a distributed system fails (say crashes), how can
we tell?（当分布式系统中的进程发生故障（例如崩溃）时，我们如何判断？）
<ul>
<li>Asynchronous message passing（异步消息传递）
<ul>
<li>detecting a process failure (with the help of timing assumptions) is
unreliable!（在异步消息传递中，借助时间假设检测进程故障是不可靠的！）
<img src="image-48.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li>Synchronous message passing（同步消息传递）
<ul>
<li>detecting a process failure is reliable（检测进程故障是可靠的）</li>
</ul></li>
</ul></li>
<li>Failure detectors (FDs)（故障检测器）
<ul>
<li>Provide processes with information about crashed
processes（为进程提供有关崩溃进程的信息）</li>
<li>Implemented using (or encapsulating) timing
assumptions（使用（或封装）时间假设实现）</li>
<li>Depending on the timing assumptions, the output of a FD can be
accurate or not（根据时间假设，FD 的输出可以是准确的也可以是不准确的）
<ul>
<li>FDs often give “hints” about failures rather than reliable
information（FDs 通常提供有关故障的“提示”，而不是可靠的信息）</li>
<li>Unreliable FDs（不可靠的 FD）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="故障检测器-failure-detector">故障检测器 (Failure detector)</h3>
<ul>
<li>Indication: <code>&lt;P, Crash | p&gt;</code>: Detects that process
<span class="math inline">\(p\)</span> has crashed.（检测进程 <span class="math inline">\(p\)</span> 已崩溃）</li>
<li>Properties:
<ul>
<li>Completeness（完备性）</li>
<li>Accuracy（准确性）</li>
</ul></li>
</ul>
<h3 id="完美故障检测器-perfect-failure-detector">完美故障检测器 (Perfect
failure detector)</h3>
<h4 id="规范-4">规范</h4>
<ul>
<li>Name: PerfectFailureDetector, instance <span class="math inline">\(P\)</span>.</li>
<li>Indication: <code>&lt;P, Crash | p&gt;</code>: Detects that process
<span class="math inline">\(p\)</span> has crashed.（检测进程 <span class="math inline">\(p\)</span> 已崩溃）</li>
<li>Properties:
<ul>
<li>PFD1. <strong>Strong completeness</strong>: Eventually, every
process that crashes is permanently detected by every correct
process.（强完备性：最终，每个崩溃的进程都会被每个正确进程永久检测到。）</li>
<li>PFD2. <strong>Strong accuracy</strong>: If a process <span class="math inline">\(p\)</span> is detected by any process, then <span class="math inline">\(p\)</span> has crashed.（强准确性：如果进程 <span class="math inline">\(p\)</span> 被任何进程检测到，则 <span class="math inline">\(p\)</span> 已崩溃。）</li>
</ul></li>
</ul>
<h4 id="算法超时排除-exclude-on-timeout">算法：超时排除 (Exclude on
Timeout)</h4>
<ul>
<li>Implements: PerfectFailureDetector, instance <span class="math inline">\(P\)</span>.</li>
<li>Uses: PerfectPointToPointLinks, instance <span class="math inline">\(pl\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 P，alive 保存被认为存活的进程集合</span></span>
<span class="line"><span style="color: #abb2bf">// detected 保存已检测到崩溃的进程集合，设置定时器 2Δ</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;P, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    alive := Π;</span></span>
<span class="line"><span style="color: #abb2bf">    detected := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    starttimer(2Δ);</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 定时器到期时，检查所有进程并发送心跳请求</span></span>
<span class="line"><span style="color: #abb2bf">// 若某个进程未存活且未检测到，则标记为已检测崩溃并触发崩溃事件</span></span>
<span class="line"><span style="color: #abb2bf">// 最后清空 alive 集合并重置定时器</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;Timeout&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    forall p ∈ Π do</span></span>
<span class="line"><span style="color: #abb2bf">        if (p ∉ alive) ∧ (p ∉ detected) then</span></span>
<span class="line"><span style="color: #abb2bf">            detected := detected ∪ {p};</span></span>
<span class="line"><span style="color: #abb2bf">            trigger &lt;P, Crash | p&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;pl, Send | p, [HEARTBEAT_REQUEST]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">    alive := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    starttimer(2Δ);</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到心跳请求时，回复心跳应答</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;pl, Deliver | q, [HEARTBEAT_REQUEST]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;pl, Send | q, [HEARTBEAT_REPLY]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到心跳应答时，将发送者添加到 alive 集合</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;pl, Deliver | p, [HEARTBEAT_REPLY]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    alive := alive ∪ {p};</span></span></code></pre></div></div></figure>
<ul>
<li>Example <img src="image-49.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h3 id="最终完美故障检测器-eventually-perfect-failure-detector">最终完美故障检测器
(Eventually perfect failure detector)</h3>
<h4 id="规范-5">规范</h4>
<ul>
<li>Name: Eventually Perfect Failure Detector, instance <span class="math inline">\(\diamondsuit P\)</span>,</li>
<li>Indication:
<ul>
<li><code>&lt;◇P, Suspect | p&gt;</code> : Notifies that process <span class="math inline">\(p\)</span> is suspected to have crashed.（通知进程
<span class="math inline">\(p\)</span> 被怀疑已崩溃）</li>
<li><code>&lt;◇P, Restore | p&gt;</code> : Notifies that process <span class="math inline">\(p\)</span> is not suspected anymore.（通知进程
<span class="math inline">\(p\)</span> 不再被怀疑）</li>
</ul></li>
<li>Properties:
<ul>
<li>EPFD1. <strong>Strong completeness</strong>: Eventually, every
process that crashes is permanently suspected by every correct
process.（强完备性：最终，每个崩溃的进程都会被每个正确进程永久怀疑。）</li>
<li>EPFD2. <strong>Eventual strong accuracy</strong>: Eventually, no
correct process is suspected by any correct
process.（最终强准确性：最终，没有正确进程被任何正确进程怀疑。）</li>
</ul></li>
</ul>
<h4 id="基本思想通用故障检测器实现-generic-fd-implementation-sketch">基本思想：通用故障检测器实现
(Generic FD implementation (sketch))</h4>
<ol type="1">
<li>Processes periodically exchange heartbeat
messages（进程定期交换心跳消息）</li>
<li>A process sets a timeout based on worst case round trip of a message
exchange (<span class="math inline">\(2\Delta\)</span>
time)（进程根据消息交换的最坏情况往返时间（<span class="math inline">\(2\Delta\)</span> 时间）设置超时）</li>
<li>A process suspects another process if it timeouts that
process（进程如果超时未收到另一个进程的响应，则怀疑该进程）</li>
<li>A process that delivers a message from a suspected process revises
its suspicion and increases its
timeout（进程收到被怀疑的进程交付消息，会修改其怀疑并增加其超时）</li>
</ol>
<h4 id="算法增加超时-increasing-timeout">算法：增加超时 (Increasing
Timeout)</h4>
<ul>
<li>Implements: EventuallyPerfectFailureDetector, instance <span class="math inline">\(\diamondsuit P\)</span>.</li>
<li>Uses: PerfectPointToPointLinks, instance pl.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 ◇P，alive 保存被认为存活的进程集合</span></span>
<span class="line"><span style="color: #abb2bf">// suspected 保存被怀疑崩溃的进程集合，设置初始延迟为 2Δ' 并启动定时器</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;◇P, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    alive := Π;</span></span>
<span class="line"><span style="color: #abb2bf">    suspected := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    delay := 2Δ';</span></span>
<span class="line"><span style="color: #abb2bf">    starttimer(delay);</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 定时器到期时，若有存活进程被怀疑，则延迟增加 2Δ'</span></span>
<span class="line"><span style="color: #abb2bf">// 接着检查所有进程，若某个进程未被认为存活且未被怀疑，则将其加入怀疑集合并触发怀疑事件</span></span>
<span class="line"><span style="color: #abb2bf">// 反之若某个进程被认为存活且被怀疑，则将其从怀疑集合中移除并触发恢复事件</span></span>
<span class="line"><span style="color: #abb2bf">// 最后清空 alive 集合并重置定时器</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;Timeout&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    if alive ∩ suspected ≠ ∅ then</span></span>
<span class="line"><span style="color: #abb2bf">        delay := delay + 2Δ';</span></span>
<span class="line"><span style="color: #abb2bf">    forall p ∈ Π do</span></span>
<span class="line"><span style="color: #abb2bf">        if (p ∉ alive) ∧ (p ∉ suspected) then</span></span>
<span class="line"><span style="color: #abb2bf">            suspected := suspected ∪ {p};</span></span>
<span class="line"><span style="color: #abb2bf">            trigger &lt;◇P, Suspect | p&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">        else if (p ∈ alive) ∧ (p ∈ suspected) then</span></span>
<span class="line"><span style="color: #abb2bf">            suspected := suspected \ {p};</span></span>
<span class="line"><span style="color: #abb2bf">            trigger &lt;◇P, Restore | p&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">    alive := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    starttimer(delay);</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到心跳请求时，回复心跳应答</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;pl, Deliver | q, [HEARTBEAT_REQUEST]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;pl, Send | q, [HEARTBEATReply]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到心跳应答时，将发送者添加到 alive 集合</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;pl, Deliver | p, [HEARTBEAT_REPLY]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    alive := alive ∪ {p};</span></span></code></pre></div></div></figure>
<ul>
<li><p><span class="math inline">\(\Delta\)</span> is not known a
priori! Eventually, delay <span class="math inline">\(&gt;2\Delta\)</span>.</p></li>
<li><p>Example <img src="image-50.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>在第一轮中，<span class="math inline">\(p_2\)</span>
未能在超时时间内回复心跳请求，因此被 <span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_3\)</span> 怀疑崩溃。</li>
<li>在第二轮中，<span class="math inline">\(p_2\)</span>
成功回复了心跳请求，<span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_3\)</span> 将其加入 alive 集合。</li>
<li>在第二轮结束时，<span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_3\)</span> 发现 <span class="math inline">\(p_2\)</span> 既在 alive 集合中又在 suspected
集合中，因此将延迟增加了 <span class="math inline">\(2\Delta^\prime\)</span>（从第三轮开始，延迟为
<span class="math inline">\(4\Delta^\prime\)</span>）；然后 <span class="math inline">\(p_2\)</span> 被从怀疑集合中移除。</li>
</ul></li>
</ul>
<h2 id="领导者-leaders">领导者 (Leaders)</h2>
<ul>
<li>Identifies one process that has not
failed（识别一个未发生故障的进程）
<ul>
<li>Each process eventually elects itself as the leader or a follower,
such that there is exactly one
leader（每个进程最终选举自己为领导者或追随者，以确保只有一个领导者）</li>
</ul></li>
<li>优点
<ul>
<li>Synchronization/coordination tasks become much
simpler（同步/协调任务变得简单得多）</li>
<li>We can use the leader to “centralize” the
algorithm（我们可以使用领导者来“集中”算法）
<ul>
<li>Data processing, Resource allocation,
Scheduling（数据处理、资源分配、调度）</li>
<li>Coordinating consensus（协调共识）</li>
</ul></li>
</ul></li>
<li>缺点
<ul>
<li>Stability?: Leader fails <span class="math inline">\(\rightarrow\)</span> must reelect
one（稳定性：领导者失败则必须重新选举一个）</li>
<li>Bottleneck（瓶颈）</li>
</ul></li>
</ul>
<h3 id="领导者选举-leader-election">领导者选举 (Leader election)</h3>
<h4 id="规范-6">规范</h4>
<ul>
<li>Name: LeaderElection, instance <span class="math inline">\(le\)</span>.</li>
<li>Indication: <code>&lt;le, Leader | p&gt;</code>: indicates that
process <span class="math inline">\(p\)</span> is elected as
leader.（表示进程 <span class="math inline">\(p\)</span>
被选为领导者）</li>
<li>Properties:
<ul>
<li>LE1. <strong>Eventual detection</strong>: either there is no correct
process, or some correct process is eventually elected as the
leader.（最终检测：要么没有正确进程，要么某个正确进程最终被选为领导者。）</li>
<li>LE2. <strong>Accuracy</strong>: If a process is leader, then all
previously elected leaders have
crashed.（准确性：如果一个进程是领导者，则所有先前选举的领导者都已崩溃。）</li>
</ul></li>
</ul>
<h4 id="算法君主制领导选举-monarchical-leader-election">算法：君主制领导选举
(Monarchical Leader Election)</h4>
<ul>
<li>Implements: LeaderElection, instance <span class="math inline">\(le\)</span>.</li>
<li>Uses: PerfectFailureDetector, instance <span class="math inline">\(P\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 le，suspected 保存被怀疑崩溃的进程集合，leader 保存当前领导者</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;le, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    suspected := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    leader := ⊥;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到进程 p 崩溃的事件时，将其加入怀疑集合</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;P, Crash | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    suspected := suspected ∪ {p};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 如果当前领导者不等于未被怀疑崩溃的进程中排名最高的进程，则更新领导者，并触发换主事件</span></span>
<span class="line"><span style="color: #abb2bf">upon leader ≠ maxrank(Π \ suspected) do</span></span>
<span class="line"><span style="color: #abb2bf">    leader := maxrank(Π \ suspected);</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;le, Leader | leader &gt;;</span></span></code></pre></div></div></figure>
<ul>
<li>Example <img src="image-51.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h3 id="最终领导者检测器-eventual-leader-detector">最终领导者检测器
(Eventual Leader Detector)</h3>
<h4 id="规范-7">规范</h4>
<ul>
<li>Name: EventualLeaderDetector, instance <span class="math inline">\(\Omega\)</span></li>
<li>Indication: <code>&lt;Ω, Trust | p&gt;</code>: Indicates that
process <span class="math inline">\(p\)</span> is trusted to be
leader.（表示进程 <span class="math inline">\(p\)</span>
被信任为领导者）</li>
<li>Properties:
<ul>
<li>ELD1. <strong>Eventual accuracy</strong>: There is a time after
which every correct process trusts some correct
process.（最终准确性：在某个时间之后，每个正确进程都信任某个正确进程。）</li>
<li>ELD2. <strong>Eventual agreement</strong>: There is a time after
which no two correct processes trust different correct
processes.（最终一致性：在某个时间之后，没有两个正确进程信任不同的正确进程。）</li>
</ul></li>
</ul>
<h4 id="算法君主制最终领导者检测-monarchical-eventual-leader-detection">算法：君主制最终领导者检测
(Monarchical Eventual Leader Detection)</h4>
<ul>
<li>Implemented: EventualLeaderDetector, instance <span class="math inline">\(\Omega\)</span>,</li>
<li>Uses: Eventually Perfect Failure Detector, instance <span class="math inline">\(\diamondsuit P\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 Ω，suspected 保存被怀疑崩溃的进程集合，leader 保存当前领导者</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;Ω, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    suspected := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    leader := ⊥;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到怀疑进程 p 崩溃的事件时，将其加入怀疑集合</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;◇P, Suspect | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    suspected := suspected ∪ {p};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到恢复进程 p 的事件时，将其从怀疑集合中移除</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;◇P, Restore | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    suspected := suspected \ {p};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 如果当前领导者不等于未被怀疑崩溃的进程中排名最高的进程，则更新领导者，并触发信任事件</span></span>
<span class="line"><span style="color: #abb2bf">upon leader ≠ maxrank(Π \ suspected) do</span></span>
<span class="line"><span style="color: #abb2bf">    leader := maxrank(Π \ suspected);</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;Ω, Trust | leader&gt;;</span></span></code></pre></div></div></figure>
<ul>
<li>Example <img src="image-52.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h2 id="广播-broadcast">广播 (Broadcast)</h2>
<ul>
<li>Broadcast: an information dissemination method（信息传播方法）
<ul>
<li>When more than two processes need to operate in a coordinated
manner（当两个以上的进程需要协调工作时）</li>
<li>E.g., shared register, consensus, multi-party computation</li>
</ul></li>
<li>A process sends a message within a group of processes <span class="math inline">\(\Pi\)</span>, such that processes in <span class="math inline">\(\Pi\)</span> agree on the messages they
deliver（一个进程在一组进程 <span class="math inline">\(\Pi\)</span>
中发送消息，使得 <span class="math inline">\(\Pi\)</span>
中的进程对它们交付的消息达成一致） <img src="image-53.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>This course: Best-effort broadcast <span class="math inline">\(\to\)</span> regular broadcast <span class="math inline">\(\to\)</span> uniform broadcast（本课程：尽力广播
<span class="math inline">\(\to\)</span> 常规广播 <span class="math inline">\(\to\)</span> 统一广播）</li>
</ul>
<h3 id="尽力广播-best-effort-broadcast">尽力广播 (Best-effort
broadcast)</h3>
<h4 id="规范-8">规范</h4>
<ul>
<li><p>Name: BestEffortBroadcast, instance <span class="math inline">\(beb\)</span>.</p></li>
<li><p>Request: <code>&lt;beb, Broadcast | m&gt;</code>: Broadcasts a
message <span class="math inline">\(m\)</span> to all
processes.（广播消息 <span class="math inline">\(m\)</span>
给所有进程）</p></li>
<li><p>Indication: <code>&lt;beb, Deliver | p, m&gt;</code>: Delivers a
message <span class="math inline">\(m\)</span> broadcast by process
<span class="math inline">\(p\)</span>.（交付由进程 <span class="math inline">\(p\)</span> 广播的消息 <span class="math inline">\(m\)</span>）</p></li>
<li><p>Properties:</p>
<ul>
<li>BEB1. <strong>Validity</strong>: If a <strong>correct</strong>
process broadcasts a message <span class="math inline">\(m\)</span>,
then every correct process eventually delivers <span class="math inline">\(m\)</span>.（有效性：如果一个正确的进程广播消息
<span class="math inline">\(m\)</span>，那么每个正确的进程最终都会交付
<span class="math inline">\(m\)</span>。）</li>
<li>BEB2. <strong>No duplication</strong>: No message is delivered more
than once.（无重复：没有消息会被交付多次。）</li>
<li>BEB3. <strong>No creation</strong>: If a process delivers a message
<span class="math inline">\(m\)</span> with sender <span class="math inline">\(s\)</span>, then <span class="math inline">\(m\)</span> was previously broadcast by process
<span class="math inline">\(s\)</span>.（无创建：如果一个进程交付了一个由发送者
<span class="math inline">\(s\)</span> 发送的消息 <span class="math inline">\(m\)</span>，那么 <span class="math inline">\(m\)</span> 之前是由进程 <span class="math inline">\(s\)</span> 广播的。）</li>
</ul></li>
<li><p>bebBroadcast <img src="image-54.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li><span class="math inline">\(p_1\)</span> 广播 <span class="math inline">\(m\)</span>
给所有进程，此时一切正常，所有进程最终都会收到 <span class="math inline">\(m\)</span>，符合有效性</li>
<li><span class="math inline">\(p_1\)</span> 广播 <span class="math inline">\(m_1\)</span> 时崩溃，此时只有部分进程收到 <span class="math inline">\(m_1\)</span>，没有正确完成广播，因此不违反有效性</li>
</ul></li>
</ul>
<h4 id="算法基础广播-basic-broadcast">算法：基础广播 (Basic
broadcast)</h4>
<ul>
<li>Implemented: BestEffortBroadcast, instance <span class="math inline">\(beb\)</span>.</li>
<li>Uses: PerfectPointToPointLinks, instance <span class="math inline">\(pl\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 使用 beb 进行广播时，用 pl 向所有进程发送消息 m</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Broadcast | m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    forall p in Π do</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;pl, Send | p, m&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当 pl 交付消息 m 时，触发 beb 的交付事件</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;pl, Deliver | p, m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;beb, Deliver | p, m&gt;;</span></span></code></pre></div></div></figure>
<ul>
<li>Correctness
<ul>
<li>The no creation and no duplication properties follow directly from
the corresponding properties of perfect
links.（无创建和无重复属性直接来自完美链接的相应属性。）</li>
<li>Validity is derived from the reliable delivery property and the fact
that the sender sends the message to every other
process.（有效性源自可靠交付属性以及发送者向每个其他进程发送消息的事实。）</li>
</ul></li>
<li>Complexity
<ul>
<li>A single communication step, <span class="math inline">\(O(N)\)</span> messages.（单个通信步骤，<span class="math inline">\(O(N)\)</span> 消息。）</li>
</ul></li>
</ul>
<h3 id="常规可靠广播-regular-reliable-broadcast">常规可靠广播 (Regular
Reliable Broadcast)</h3>
<h4 id="规范-9">规范</h4>
<ul>
<li><p>Name: ReliableBroadcast, instance <span class="math inline">\(rb\)</span>.</p></li>
<li><p>Request: <code>&lt;rb, Broadcast | m&gt;</code>: Broadcasts a
message <span class="math inline">\(m\)</span> to all
processes.（广播消息 <span class="math inline">\(m\)</span>
给所有进程）</p></li>
<li><p>Indication: <code>&lt;rb, Deliver | p, m&gt;</code>: Delivers a
message <span class="math inline">\(m\)</span> broadcast by process
<span class="math inline">\(p\)</span>.（交付由进程 <span class="math inline">\(p\)</span> 广播的消息 <span class="math inline">\(m\)</span>）</p></li>
<li><p>Properties:</p>
<ul>
<li>RB1 - RB3: Same as properties BEB1 - BEB3 in best-effort
broadcast.</li>
<li>RB1. Validity: If a correct process broadcasts a message <span class="math inline">\(m\)</span>, then every correct process eventually
delivers <span class="math inline">\(m\)</span>.（有效性：如果一个正确的进程广播消息
<span class="math inline">\(m\)</span>，那么每个正确的进程最终都会交付
<span class="math inline">\(m\)</span>。）</li>
<li>RB2. No duplication: No message is delivered more than
once.（无重复：没有消息会被交付多次。）</li>
<li>RB3. No creation: If a process delivers a message <span class="math inline">\(m\)</span> with sender <span class="math inline">\(s\)</span>, then <span class="math inline">\(m\)</span> was previously broadcast by process
<span class="math inline">\(s\)</span>.（无创建：如果一个进程交付了由发送者
<span class="math inline">\(s\)</span> 发送的消息 <span class="math inline">\(m\)</span>，那么 <span class="math inline">\(m\)</span> 之前是由进程 <span class="math inline">\(s\)</span> 广播的。）</li>
<li>RB4. <strong>Agreement</strong>: If a message <span class="math inline">\(m\)</span> is delivered by some
<strong>correct</strong> process, then <span class="math inline">\(m\)</span> is eventually delivered by
<strong>every correct
process</strong>.（一致性：如果某个正确的进程交付了消息 <span class="math inline">\(m\)</span>，那么每个正确的进程最终都会交付 <span class="math inline">\(m\)</span>。）</li>
</ul></li>
<li><p>rbBroadcast <img src="image-24.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>左一/右：<span class="math inline">\(p_1\)</span> 广播 <span class="math inline">\(m_1\)</span> 后崩溃，只有 <span class="math inline">\(p_2\)</span> 收到并交付，于是 <span class="math inline">\(p_2\)</span> 继续广播 <span class="math inline">\(m_1\)</span>，<span class="math inline">\(p_3\)</span> 最终也交付 <span class="math inline">\(m_1\)</span>，符合一致性</li>
<li>左二：<span class="math inline">\(p_1\)</span> 广播 <span class="math inline">\(m_1\)</span> 后崩溃，所有进程都没有收到 <span class="math inline">\(m_1\)</span>，所以都没有交付，符合一致性</li>
<li>左三：<span class="math inline">\(p_1\)</span> 广播 <span class="math inline">\(m_1\)</span> 后崩溃，只有 <span class="math inline">\(p_2\)</span> 收到并交付，但 <span class="math inline">\(p_2\)</span> 也崩溃了，<span class="math inline">\(p_3\)</span> 没有收到 <span class="math inline">\(m_1\)</span>，此时没有正确进程交付 <span class="math inline">\(m_1\)</span>，符合一致性</li>
</ul></li>
</ul>
<h4 id="算法懒惰可靠广播-lazy-reliable-broadcast">算法：懒惰可靠广播
(Lazy Reliable Broadcast)</h4>
<ul>
<li>Implemented: ReliableBroadcast, instance <span class="math inline">\(rb\)</span>.</li>
<li>Uses:
<ul>
<li>BestEffortBroadcast, instance <span class="math inline">\(beb\)</span></li>
<li>PerfectFailureDetector, instance <span class="math inline">\(P\)</span></li>
</ul></li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 rb，设置正确进程集合 correct 为所有进程集合 Π</span></span>
<span class="line"><span style="color: #abb2bf">// 设置已交付消息集合 delivered 为空，设置所有进程 p 的消息来源集合 from[p] 为空</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;rb, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    correct := Π;</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    forall p in Π do</span></span>
<span class="line"><span style="color: #abb2bf">        from[p] := ∅;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 使用 rb 进行广播时，用 beb 广播消息 m，附加消息来源 self 为自己</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;rb, Broadcast | m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;beb, Broadcast | [DATA, self, m]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当 beb 交付消息 [DATA, s, m] 时，检查消息 m 是否已交付</span></span>
<span class="line"><span style="color: #abb2bf">// 如果未交付，则将 m 加入已交付集合 delivered，触发 rb 的交付事件，并记录消息来源 s 和 m 到 from[p] 中</span></span>
<span class="line"><span style="color: #abb2bf">// 如果进程 p 不在正确进程集合 correct 中（p 已崩溃），则重新用 beb 广播消息 [DATA, s, m]</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Deliver | p, [DATA, s, m]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    if m ∉ delivered then</span></span>
<span class="line"><span style="color: #abb2bf">        delivered := delivered ∪ {m};</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;rb, Deliver | s, m&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">        from[p] := from[p] ∪ {(s, m)};</span></span>
<span class="line"><span style="color: #abb2bf">        if p ∉ correct then</span></span>
<span class="line"><span style="color: #abb2bf">            trigger &lt;beb, Broadcast | [DATA, s, m]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当检测到进程 p 崩溃时，从正确进程集合 correct 中移除 p</span></span>
<span class="line"><span style="color: #abb2bf">// 然后对 from[p] 中的所有消息 (s, m) 重新用 beb 广播消息 [DATA, s, m]</span></span>
<span class="line"><span style="color: #abb2bf">//（这是因为 p 崩溃了，可能有消息未被其他正确进程接收）</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;P, Crash | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    correct := correct \ {p};</span></span>
<span class="line"><span style="color: #abb2bf">    forall (s, m) in from[p] do</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;beb, Broadcast | [DATA, s, m]&gt;;</span></span></code></pre></div></div></figure>
<ul>
<li>Complexity
<ul>
<li>Best case: if the initial sender does not
crash（最佳情况：初始发送者没有崩溃）
<ul>
<li>a single communication step and <span class="math inline">\(O(N)\)</span> messages（单个通信步骤和 <span class="math inline">\(O(N)\)</span> 消息）</li>
</ul></li>
<li>Worst case: if the processes crash in
sequence（最坏情况：进程按顺序崩溃）
<ul>
<li><span class="math inline">\(O(N)\)</span> steps and <span class="math inline">\(O(N^{2})\)</span> messages（<span class="math inline">\(O(N)\)</span> 步骤和 <span class="math inline">\(O(N^{2})\)</span> 消息）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="算法积极可靠广播-eager-reliable-broadcast">算法：积极可靠广播
(Eager Reliable Broadcast)</h4>
<ul>
<li>Implemented: ReliableBroadcast, instance <span class="math inline">\(rb\)</span>.</li>
<li>Uses: BestEffortBroadcast, instance <span class="math inline">\(beb\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 rb，设置已交付消息集合 delivered 为空</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;rb, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := ∅;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 使用 rb 进行广播时，用 beb 广播消息 m，附加消息来源 self 为自己</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;rb, Broadcast | m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;beb, Broadcast | [DATA, self, m]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当 beb 交付消息 [DATA, s, m] 时，检查消息 m 是否已交付</span></span>
<span class="line"><span style="color: #abb2bf">// 如果未交付，则将 m 加入已交付集合 delivered，触发 rb 的交付事件</span></span>
<span class="line"><span style="color: #abb2bf">// 然后用 beb 广播消息 [DATA, s, m]</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Deliver | p, [DATA, s, m]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    if m ∉ delivered then</span></span>
<span class="line"><span style="color: #abb2bf">        delivered := delivered ∪ {m};</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;rb, Deliver | s, m&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;beb, Broadcast | [DATA, s, m]&gt;;</span></span></code></pre></div></div></figure>
<ul>
<li>Complexity
<ul>
<li>Best case: no process crashes（没有进程崩溃）
<ul>
<li>A single communication step and <span class="math inline">\(O(N^{2})\)</span> messages（单个通信步骤和 <span class="math inline">\(O(N^{2})\)</span> 消息）</li>
</ul></li>
<li>Worst case: the processes crash in sequence（进程按顺序崩溃）
<ul>
<li><span class="math inline">\(O(N)\)</span> steps and <span class="math inline">\(O(N^{2})\)</span> messages（<span class="math inline">\(O(N)\)</span> 步骤和 <span class="math inline">\(O(N^{2})\)</span> 消息）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="统一可靠广播-uniform-reliable-broadcast">统一可靠广播 (Uniform
reliable broadcast)</h3>
<h4 id="规范-10">规范</h4>
<ul>
<li><p>Name: UniformReliableBroadcast, instance <span class="math inline">\(urb\)</span>.</p></li>
<li><p>Request: <code>&lt;urb, Broadcast | m&gt;</code>: Broadcasts a
message <span class="math inline">\(m\)</span> to all
processes.（广播消息 <span class="math inline">\(m\)</span>
给所有进程）</p></li>
<li><p>Indication: <code>&lt;urb, Deliver | p, m&gt;</code>: Delivers a
message <span class="math inline">\(m\)</span> broadcast by process
<span class="math inline">\(p\)</span>.（交付由进程 <span class="math inline">\(p\)</span> 广播的消息 <span class="math inline">\(m\)</span>）</p></li>
<li><p>Properties:</p>
<ul>
<li>URB1 - URB3: Same as properties RB1 - RB3 in (regular) reliable
broadcast.</li>
<li>URB1. Validity: If a correct process broadcasts a message <span class="math inline">\(m\)</span>, then every correct process eventually
delivers <span class="math inline">\(m\)</span>.（有效性：如果一个正确的进程广播消息
<span class="math inline">\(m\)</span>，那么每个正确的进程最终都会交付
<span class="math inline">\(m\)</span>。）</li>
<li>URB2. No duplication: No message is delivered more than
once.（无重复：没有消息会被交付多次。）</li>
<li>URB3. No creation: If a process delivers a message <span class="math inline">\(m\)</span> with sender <span class="math inline">\(s\)</span>, then <span class="math inline">\(m\)</span> was previously broadcast by process
<span class="math inline">\(s\)</span>.（无创建：如果一个进程交付了由发送者
<span class="math inline">\(s\)</span> 发送的消息 <span class="math inline">\(m\)</span>，那么 <span class="math inline">\(m\)</span> 之前是由进程 <span class="math inline">\(s\)</span> 广播的。）</li>
<li>URB4: <strong>Uniform agreement</strong>: If a message <span class="math inline">\(m\)</span> is delivered by some process
(<strong>whether correct or faulty</strong>), then <span class="math inline">\(m\)</span> is eventually delivered by every
correct
process.（统一一致性：如果某个进程（无论是正确的还是错误的）交付了消息
<span class="math inline">\(m\)</span>，那么每个正确的进程最终都会交付
<span class="math inline">\(m\)</span>。）</li>
</ul></li>
<li><p>urbBroadcast <img src="image-57.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li><span class="math inline">\(p_1\)</span> 广播 <span class="math inline">\(m_1\)</span> 后崩溃，<span class="math inline">\(p_2\)</span> 收到并交付 <span class="math inline">\(m_1\)</span>，如果此时 <span class="math inline">\(p_2\)</span> 也崩溃了，为满足统一一致性，<span class="math inline">\(p_3\)</span> 最终也必须交付 <span class="math inline">\(m_1\)</span></li>
</ul></li>
</ul>
<h4 id="算法全确认统一可靠广播-all-ack-uniform-reliable-broadcast">算法：全确认统一可靠广播
(All-Ack Uniform Reliable Broadcast)</h4>
<ul>
<li>Implemented: UniformReliableBroadcast, instance <span class="math inline">\(urb\)</span>.</li>
<li>Uses:
<ul>
<li>BestEffortBroadcast, instance <span class="math inline">\(beb\)</span></li>
<li>PerfectFailureDetector, instance <span class="math inline">\(P\)</span></li>
</ul></li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 urb，设置已交付消息集合 delivered 为空，待交付消息集合 pending 为空</span></span>
<span class="line"><span style="color: #abb2bf">// 设置正确进程集合 correct 为所有进程集合 Π，并为每个消息 m 初始化确认集合 ack[m] 为空</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;urb, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    pending := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    correct := Π;</span></span>
<span class="line"><span style="color: #abb2bf">    forall m do</span></span>
<span class="line"><span style="color: #abb2bf">        ack[m] := ∅;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 使用 urb 进行广播时，将消息 (self, m) 加入待交付集合 pending</span></span>
<span class="line"><span style="color: #abb2bf">// 然后用 beb 广播消息 [DATA, self, m]</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;urb, Broadcast | m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    pending := pending ∪ {(self, m)};</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;beb, Broadcast | [DATA, self, m]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当 beb 交付消息 [DATA, s, m] 时，将发送者 p 加入消息 m 的确认集合 ack[m]</span></span>
<span class="line"><span style="color: #abb2bf">// 如果消息 (s, m) 不在待交付集合 pending 中，则将其加入 pending，并用 beb 广播</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Deliver | p, [DATA, s, m]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    ack[m] := ack[m] ∪ {p};</span></span>
<span class="line"><span style="color: #abb2bf">    if (s, m) ∉ pending then</span></span>
<span class="line"><span style="color: #abb2bf">        pending := pending ∪ {(s, m)};</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;beb, Broadcast | [DATA, s, m]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当检测到进程 p 崩溃时，从正确进程集合 correct 中移除 p</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;P, Crash | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    correct := correct \ {p};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 检查消息 m 是否可以交付（即确认集合 ack[m] 包含所有正确进程）</span></span>
<span class="line"><span style="color: #abb2bf">function candeliver(m) returns Boolean is</span></span>
<span class="line"><span style="color: #abb2bf">    return (correct ⊆ ack[m]);</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 对于待交付集合 pending 中的每个消息 (s, m)，如果可以交付且未交付过</span></span>
<span class="line"><span style="color: #abb2bf">// 则将 m 加入已交付集合 delivered，并触发 urb 的交付事件</span></span>
<span class="line"><span style="color: #abb2bf">upon exists (s, m) ∈ pending such that candeliver(m) ∧ m ∉ delivered do</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := delivered ∪ {m};</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;urb, Deliver | s, m&gt;;</span></span></code></pre></div></div></figure>
<ul>
<li><p>All-Ack Uniform Reliable Broadcast <img src="image-55.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>上图：<span class="math inline">\(p_1\)</span> 广播 <span class="math inline">\(m\)</span>，<span class="math inline">\(p_2\)</span> 和 <span class="math inline">\(p_3\)</span>
收到后广播确认，当每个节点各自收到所有节点的确认后交付消息 <span class="math inline">\(m\)</span>，满足统一一致性</li>
<li>下图：<span class="math inline">\(p_1\)</span> 广播 <span class="math inline">\(m\)</span>，<span class="math inline">\(p_2\)</span> 收到后崩溃，未进行确认，<span class="math inline">\(p_3\)</span> 收到后广播确认，但由于 <span class="math inline">\(p_2\)</span> 未确认，<span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_3\)</span> 都无法交付消息 <span class="math inline">\(m\)</span>，直到故障检测器检测到 <span class="math inline">\(p_2\)</span> 崩溃并将其移除，此时 <span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_3\)</span> 收到所有正确进程的确认后交付消息
<span class="math inline">\(m\)</span>，满足统一一致性</li>
</ul></li>
<li><p>Complexity</p>
<ul>
<li>Best case
<ul>
<li>two communication steps and <span class="math inline">\(O(N^{2})\)</span> messages（两个通信步骤和 <span class="math inline">\(O(N^{2})\)</span> 消息）</li>
</ul></li>
<li>Worst case
<ul>
<li><span class="math inline">\(O(N)\)</span> steps and <span class="math inline">\(O(N^{2})\)</span> messages（<span class="math inline">\(O(N)\)</span> 步骤和 <span class="math inline">\(O(N^{2})\)</span> 消息）</li>
</ul></li>
</ul></li>
</ul>
<h4 id="算法多数确认的统一可靠广播-majority-ack-uniform-reliable-broadcast">算法：多数确认的统一可靠广播
(Majority-Ack Uniform Reliable Broadcast)</h4>
<ul>
<li>Based on <strong><a href="#法定人数-quorum">Quorum</a></strong>
(基于法定人数的思想)</li>
<li>Implemented: UniformReliableBroadcast, instance <span class="math inline">\(urb\)</span>.</li>
<li>Uses: BestEffortBroadcast, instance <span class="math inline">\(beb\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">upon event &lt;urb, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    pending := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    forall m do</span></span>
<span class="line"><span style="color: #abb2bf">        ack[m] := ∅;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;urb, Broadcast | m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    pending := pending ∪ {(self, m)};</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;beb, Broadcast | [DATA, self, m]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Deliver | p, [DATA, s, m]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    ack[m] := ack[m] ∪ {p};</span></span>
<span class="line"><span style="color: #abb2bf">    if (s, m) ∉ pending then</span></span>
<span class="line"><span style="color: #abb2bf">        pending := pending ∪ {(s, m)};</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;beb, Broadcast | [DATA, s, m]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 检查消息 m 是否可以交付（即确认集合 ack[m] 的大小超过 N/2，达到法定人数要求的“多数”）</span></span>
<span class="line"><span style="color: #abb2bf">function candeliver(m) returns Boolean is</span></span>
<span class="line"><span style="color: #abb2bf">    return #(ack[m]) &gt; N / 2;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">upon exists (s, m) ∈ pending such that candeliver(m) ∧ m ∉ delivered do</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := delivered ∪ {m};</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;urb, Deliver | s, m&gt;;</span></span></code></pre></div></div></figure>
<ul>
<li><p>Majority-Ack Uniform Reliable Broadcast <img src="image-62.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li><span class="math inline">\(N = 3\)</span> 时，<span class="math inline">\(p_1\)</span> 广播 <span class="math inline">\(m\)</span>，<span class="math inline">\(p_2\)</span> 收到后广播确认，此时他收到 <span class="math inline">\(p_1\)</span> 和自己的确认，达到法定人数，交付消息
<span class="math inline">\(m\)</span></li>
<li><span class="math inline">\(p_1\)</span> 收到 <span class="math inline">\(p_2\)</span> 的确认时，也达到法定人数，交付消息
<span class="math inline">\(m\)</span></li>
<li><span class="math inline">\(p_3\)</span> 收到 <span class="math inline">\(p_2\)</span> 的确认时，广播确认，此时他收到 <span class="math inline">\(p_2\)</span> 和自己的确认，达到法定人数，交付消息
<span class="math inline">\(m\)</span></li>
</ul></li>
<li><p>Correctness</p>
<ul>
<li><strong>Validity</strong>: if the sender is
<strong>correct</strong>, then（有效性）
<ul>
<li>Every correct process receives a DATA
message（每个正确的进程都会接收到一个 DATA 消息）</li>
<li>Every correct process broadcasts a DATA
message（每个正确的进程都会广播一个 DATA 消息）</li>
<li>Every correct process receives more than N/2 DATA
messages（每个正确的进程都会接收到超过 N/2 个 DATA 消息）
<ul>
<li>Since a majority of processes are
correct（因为大多数进程是正确的）</li>
</ul></li>
<li>Every correct process eventually delivers <span class="math inline">\(m\)</span>（每个正确的进程最终都会交付消息 <span class="math inline">\(m\)</span>）</li>
</ul></li>
<li><strong>No duplication</strong>, <strong>no
creation</strong>（无重复，无创建）
<ul>
<li>Straightforward from the properties of best-effort
broadcast（直接来自尽力广播的属性）</li>
</ul></li>
<li><strong>Uniform agreement</strong>（统一一致性）
<ul>
<li>Assume <span class="math inline">\(N = 2f + 1\)</span>（假设共有
<span class="math inline">\(N = 2f + 1\)</span> 个进程）</li>
<li>Suppose a process <span class="math inline">\(p_1\)</span>
urb-delivers <span class="math inline">\(m\)</span>, that means <span class="math inline">\(p_1\)</span> has received at least <span class="math inline">\(f + 1\)</span> DATA messages for <span class="math inline">\(m\)</span>（假设一个进程 <span class="math inline">\(p_1\)</span> 用 urb 交付了消息 <span class="math inline">\(m\)</span>，这意味着 <span class="math inline">\(p_1\)</span> 至少收到了 <span class="math inline">\(f + 1\)</span> 个关于消息 <span class="math inline">\(m\)</span> 的 DATA 消息）</li>
<li>Since there are at most <span class="math inline">\(f\)</span>
faulty processes, at least one of these messages is from a correct
process <span class="math inline">\(p_2\)</span>（由于最多有 <span class="math inline">\(f\)</span>
个故障进程，这些消息中至少有一个来自正确的进程 <span class="math inline">\(p_2\)</span>）</li>
<li>So all correct processes will receive the DATA message from <span class="math inline">\(p_2\)</span> and broadcast
it（因此所有正确的进程都会收到来自 <span class="math inline">\(p_2\)</span> 的 DATA 消息并进行广播）</li>
<li>Thus, every correct process will receive at least <span class="math inline">\(f + 1\)</span> DATA messages for <span class="math inline">\(m\)</span> and urb-deliver <span class="math inline">\(m\)</span>（因此，每个正确的进程都会收到至少 <span class="math inline">\(f + 1\)</span> 个关于消息 <span class="math inline">\(m\)</span> 的 DATA 消息并用 urb 交付消息 <span class="math inline">\(m\)</span>）</li>
</ul></li>
</ul></li>
<li><p>Complexity</p>
<ul>
<li>Best case
<ul>
<li>two communication steps and <span class="math inline">\(O(N^{2})\)</span> messages（两个通信步骤和 <span class="math inline">\(O(N^{2})\)</span> 消息）</li>
</ul></li>
<li>Worst case
<ul>
<li><span class="math inline">\(O(N)\)</span> steps and <span class="math inline">\(O(N^{2})\)</span> messages（<span class="math inline">\(O(N)\)</span> 步骤和 <span class="math inline">\(O(N^{2})\)</span> 消息）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="全序广播-total-order-broadcast">全序广播 (Total Order
Broadcast)</h3>
<h4 id="规范-11">规范</h4>
<ul>
<li>Name: TotalOrderBroadcast, instance <span class="math inline">\(tob\)</span>.</li>
<li>Request: <code>&lt;tob, Broadcast | m&gt;</code>: Broadcasts a
message <span class="math inline">\(m\)</span> to all processes.（将消息
<span class="math inline">\(m\)</span> 广播给所有进程）</li>
<li>Indication: <code>&lt;tob, Deliver | p, m&gt;</code>: Delivers a
message <span class="math inline">\(m\)</span> broadcast by process
<span class="math inline">\(p\)</span>.（交付由进程 <span class="math inline">\(p\)</span> 广播的消息 <span class="math inline">\(m\)</span>）</li>
<li>Properties:
<ul>
<li>TOB1. <strong>Validity</strong>: If a correct process <span class="math inline">\(p\)</span> broadcasts a message <span class="math inline">\(m\)</span>, then <span class="math inline">\(p\)</span> eventually delivers <span class="math inline">\(m\)</span>.（有效性：如果一个正确的进程 <span class="math inline">\(p\)</span> 广播了一条消息 <span class="math inline">\(m\)</span>，那么 <span class="math inline">\(p\)</span> 最终会交付 <span class="math inline">\(m\)</span>。）</li>
<li>TOB2. <strong>No duplication</strong>: No message is delivered more
than once.（无重复：没有消息会被交付多次。）</li>
<li>TOB3. <strong>No creation</strong>: If a process delivers a message
<span class="math inline">\(m\)</span> with sender <span class="math inline">\(s\)</span>, then <span class="math inline">\(m\)</span> was previously broadcast by process
<span class="math inline">\(s\)</span>.（无创建：如果一个进程交付了一条由发送者
<span class="math inline">\(s\)</span> 发送的消息 <span class="math inline">\(m\)</span>，那么 <span class="math inline">\(m\)</span> 之前是由进程 <span class="math inline">\(s\)</span> 广播的。）</li>
<li>TOB4. <strong>(Uniform) agreement</strong>: If a message <span class="math inline">\(m\)</span> is delivered by some (correct) process,
then <span class="math inline">\(m\)</span> is eventually delivered by
every correct
process.（（统一）一致性：如果某个（正确的）进程交付了一条消息 <span class="math inline">\(m\)</span>，那么每个正确的进程最终都会交付 <span class="math inline">\(m\)</span>。）</li>
<li>TOB5. <strong>Total order</strong>: Let <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> be any two messages and suppose <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are any two (correct) processes that
deliver <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span>. If <span class="math inline">\(p\)</span> delivers <span class="math inline">\(m_1\)</span> before <span class="math inline">\(m_2\)</span>, then <span class="math inline">\(q\)</span> delivers <span class="math inline">\(m_1\)</span> before <span class="math inline">\(m_2\)</span>.（全序：对于任意两条消息 <span class="math inline">\(m_1\)</span>、<span class="math inline">\(m_2\)</span> 和交付它们的任意两个（正确的）进程
<span class="math inline">\(p\)</span>、<span class="math inline">\(q\)</span>，如果 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(m_2\)</span> 之前交付了 <span class="math inline">\(m_1\)</span>，那么 <span class="math inline">\(q\)</span> 也会在 <span class="math inline">\(m_2\)</span> 之前交付 <span class="math inline">\(m_1\)</span>，即<strong>交付顺序一致。</strong>）</li>
</ul></li>
<li>TOB VS RB
<ul>
<li>Reliable broadcast: the processes are free to deliver messages in
any order they wish（进程可以自由地以它们希望的任何顺序交付消息） <img src="image-71.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>Total order broadcast: The processes must deliver all messages
according to the same order（进程必须按照相同的顺序交付所有消息） <img src="image-72.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
</ul>
<h4 id="算法基于共识的全序广播-consensus-based-total-order-broadcast">算法：基于共识的全序广播
(Consensus-Based Total-Order Broadcast)</h4>
<ul>
<li>Based on <strong><a href="#共识-consensus">Consensus</a></strong>
(基于共识的思想)</li>
<li>Implemented: TotalOrderBroadcast, instance <span class="math inline">\(tob\)</span>.</li>
<li>Uses:
<ul>
<li>ReliableBroadcast, instance <span class="math inline">\(rb\)</span></li>
<li>Consensus, multiple instances <span class="math inline">\(c.r\)</span> for round <span class="math inline">\(r\)</span>（注意：这里的 round 与共识中的 round
不同）</li>
</ul></li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 tob，设置未排序消息集合为空，已交付消息集合为空，当前共识实例编号为 1，等待标志为 FALSE</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;tob, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    unordered := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    round := 1;</span></span>
<span class="line"><span style="color: #abb2bf">    wait := FALSE;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 使用 tob 广播消息 m 时，用 rb 广播该消息</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;tob, Broadcast | m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;rb, Broadcast | m&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当 rb 交付消息 m 时，如果 m 未被交付过，则将 (p, m) 加入未排序消息集合</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;rb, Deliver | p, m&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    if (p, m) ∉ delivered then</span></span>
<span class="line"><span style="color: #abb2bf">        unordered := unordered ∪ {(p, m)};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 如果未排序消息集合非空且不在等待状态，则标记进入等待状态</span></span>
<span class="line"><span style="color: #abb2bf">// 然后初始化一个新的共识实例 c.round，并触发该实例的提案事件，提案内容为未排序消息集合</span></span>
<span class="line"><span style="color: #abb2bf">upon unordered ≠ ∅ ∧ wait = FALSE do</span></span>
<span class="line"><span style="color: #abb2bf">    wait := TRUE;</span></span>
<span class="line"><span style="color: #abb2bf">    Initialize a new instance c.round of consensus;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;c.round, Propose | unordered&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当共识实例 c.round 做出决定时，对决定的消息集合进行排序，然后按顺序触发 tob 的交付事件</span></span>
<span class="line"><span style="color: #abb2bf">// 然后将已决定的消息加入已交付集合，从未排序集合中移除，共识实例编号加 1，退出等待状态</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;c.r, Decide | decided&gt; such that r = round do</span></span>
<span class="line"><span style="color: #abb2bf">    forall (s, m) ∈ sort(decided) do</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;tob, Deliver | s, m&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := delivered ∪ decided;</span></span>
<span class="line"><span style="color: #abb2bf">    unordered := unordered \ decided;</span></span>
<span class="line"><span style="color: #abb2bf">    round := round + 1;</span></span>
<span class="line"><span style="color: #abb2bf">    wait := FALSE;</span></span></code></pre></div></div></figure>
<h4 id="状态机复制-state-machine-replication-smr">状态机复制 (State
Machine Replication, SMR)</h4>
<ul>
<li>SMR method mimics a reliable central server by replicating client
requests to a group of processes, in such a way that（SMR
方法通过将客户端请求复制到一组进程来模拟可靠的中央服务器，以确保）
<ul>
<li><strong>safety</strong>: all correct processes execute the same
requests in the same
order（安全性：所有正确的进程以相同的顺序执行相同的请求）</li>
<li><strong>liveness</strong>: eventually every request is
executed（活跃性：最终每个请求都会被执行）</li>
</ul></li>
<li>From Consensus to SMR (or Blockchain) <img src="image-66.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>Industry deployment
<ul>
<li>Meta-data (configuration) management（元数据（配置）管理）</li>
<li>Large-scale database systems（大规模数据库系统）</li>
<li>Blockchain systems（区块链系统）</li>
</ul></li>
</ul>
<h2 id="法定人数-quorum">法定人数 (Quorum)</h2>
<ul>
<li>Quorum works in distributed computing only if we know <span class="math inline">\(\Pi\)</span> a priori（法定人数仅在我们事先知道
<span class="math inline">\(\Pi\)</span>
的情况下在分布式计算中工作）</li>
</ul>
<h3 id="法定人数系统在分布式计算中的应用">法定人数系统在分布式计算中的应用</h3>
<ul>
<li>Quorums: a collection of subsets of
processes（法定人数：一组进程的子集集合） <span class="math display">\[
  QS = \{Q_{1}, Q_{2}, \cdots \}\quad \forall Q \in QS: Q \subseteq \Pi
  \]</span></li>
<li>Each pair of quorums have a non-empty
intersection（每对法定人数都有一个非空交集） <span class="math display">\[
  \forall Q_{1}, Q_{2} \in QS: Q_{1} \cap Q_{2} \neq \emptyset
  \]</span></li>
<li>For simplicity, we only consider <strong>symmetric</strong> case,
i.e.,（为了简单起见，我们只考虑对称情况，即） <span class="math display">\[
  \forall Q_{1}, Q_{2} \in QS: | Q_{1} | = | Q_{2} |
  \]</span>
<ul>
<li>Asymmetric case: Google Megastore*, write-all, read-one</li>
</ul></li>
<li>E.g., when <span class="math inline">\(N = 3\)</span> and <span class="math inline">\(\Pi = \{p_1, p_2, p_3\}\)</span>, <span class="math inline">\(QS = \{\{p_1, p_2\}, \{p_1, p_3\}, \{p_2,
p_3\}\}\)</span>,
<ul>
<li><span class="math inline">\(\{p_2,p_3\} \cap \{p_1,p_2\} =
\{p_2\}\)</span></li>
<li><span class="math inline">\(\{p_2,p_3\} \cap \{p_1,p_3\} =
\{p_3\}\)</span></li>
<li><span class="math inline">\(\{p_1,p_2\} \cap \{p_1,p_3\} =
\{p_1\}\)</span></li>
</ul></li>
</ul>
<h3 id="对称法定人数系统-symmetric-quorum-system">对称法定人数系统
(Symmetric quorum system)</h3>
<ul>
<li>Quorum is a key abstraction for ensuring consistency
(safety)（法定人数是确保一致性（安全性）的关键抽象）</li>
<li>Any quorum can make progress despite failures of other
processes（任何法定人数都可以在其他进程失败的情况下取得进展）</li>
</ul>
<p><img src="image-60.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h3 id="安全性与活性-safety-and-liveness">安全性与活性 (Safety and
liveness)</h3>
<ul>
<li><strong>Safety</strong>: a quorum must be any
<strong>majority</strong> of
processes（安全性：法定人数必须是任何大多数进程）
<ul>
<li>Otherwise, split-brain problem may
occur（否则，可能会发生脑裂问题）</li>
<li><img src="image-61.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><strong>Liveness</strong>: even if a minority of processes fail,
there is always a quorum that contains only correct
processes（活性：即使少数进程失败，总有一个法定人数只包含正确进程）
<ul>
<li>Thus can proceed, i.e., ensuring
liveness（因此可以继续，即确保活性）</li>
</ul></li>
<li>Assume there are <span class="math inline">\(f\)</span> crash faults
<ul>
<li>Safety: any two quorums intersect in one correct
process（安全性：任何两个法定人数在一个正确的进程中相交）</li>
<li>Liveness: <span class="math inline">\(N - f\)</span> processes can
make progress (quorum size)（活性：<span class="math inline">\(N -
f\)</span> 进程可以取得进展，即满足法定人数大小）</li>
<li>Therefore, we have <span class="math display">\[
  \begin{aligned}
  &amp;2(N - f) &gt; N \\
  \therefore~ &amp; N &gt; 2f \\
  \therefore~ &amp; N \geq 2f + 1
  \end{aligned}
  \]</span></li>
</ul></li>
</ul>
<h2 id="共识-consensus">共识 (Consensus)</h2>
<ul>
<li>(One of) the most fundamental problem(s) in distributed
computing（分布式计算中最基础的问题之一）</li>
<li>Key to solving many other problems in distributed
computing（解决分布式计算中许多其他问题的关键）
<ul>
<li>total order broadcast（<a href="#全序广播-total-order-broadcast">全序广播</a>）, (state machine)
replication（<a href="#状态机复制-state-machine-replication-smr">状态机复制
SMR</a>）</li>
<li>atomic commit（原子提交）</li>
<li>terminating reliable broadcast（终止可靠广播）</li>
</ul></li>
<li>In the consensus problem, the processes propose values and have to
agree on one among these
values（在共识问题中，进程提出值并必须就这些值中的一个达成一致）</li>
</ul>
<h3 id="基本概念-1">基本概念</h3>
<ul>
<li>A group of <span class="math inline">\(N\)</span> processes, among
which some (usually <span class="math inline">\(f\)</span>) may crash
(Crash fault)（一组个进程，其中一些可能会崩溃）</li>
<li>The problem is for correct processes to agree on a
value（问题是让正确的进程就一个值达成一致）</li>
<li>Every process can propose, finally every correct process
decides（每个进程都可以提出，最后每个正确的进程都决定）</li>
<li>二元共识 (binary consensus/agreement)
<ul>
<li>Request: propose(v1)</li>
<li>Indication: decide(v2)</li>
</ul>
<img src="image-63.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h3 id="共识-consensus-1">共识 (Consensus)</h3>
<h4 id="规范-12">规范</h4>
<ul>
<li>Name: Consensus, instance <span class="math inline">\(c\)</span>.</li>
<li>Request: <code>&lt;c, Propose | v&gt;</code>: Proposes value <span class="math inline">\(v\)</span> for consensus.（提出值 <span class="math inline">\(v\)</span> 以达成共识）</li>
<li>Indication: <code>&lt;c, Decide | v&gt;</code>: Outputs a decided
value <span class="math inline">\(v\)</span> of
consensus.（输出共识的决定值 <span class="math inline">\(v\)</span>）</li>
<li>Properties:
<ul>
<li>C1. <strong>Termination</strong>: Every correct process eventually
decides some value.（终止性：每个正确的进程最终决定某个值。）</li>
<li>C2. <strong>Validity</strong>: If a process decides <span class="math inline">\(v\)</span>, then <span class="math inline">\(v\)</span> was proposed by some
process.（有效性：如果一个进程决定了 <span class="math inline">\(v\)</span>，那么 <span class="math inline">\(v\)</span> 是由某个进程提出的。）</li>
<li>C3. <strong>Integrity</strong>: No process decides
twice.（完整性：没有进程会决定两次。）</li>
<li>C4. <strong>Agreement</strong>: No two <strong>correct</strong>
processes decide
differently.（一致性：没有两个正确的进程会做出不同的决定。）</li>
</ul></li>
<li>Consensus <img src="image-64.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h4 id="算法分层共识-hierarchical-consensus">算法：分层共识
(Hierarchical Consensus)</h4>
<h5 id="基本思想-2">基本思想</h5>
<ul>
<li>The processes go through rounds incrementally (<span class="math inline">\(1 \to N\)</span>): in each round, the process with
the id corresponding to that round is the leader of the
round（进程按顺序经历轮次，在每一轮中，id
与该轮对应的进程是该轮的领导者）
<ul>
<li>The leader of a round <strong>decides</strong> its current proposal
and broadcasts it to
all（一轮的领导者决定其当前提议并将其广播给所有人）</li>
</ul></li>
<li>A process that is not leader in a round
waits（不是一轮领导者的进程等待）
<ol type="1">
<li>to deliver the proposal of the leader in that round to adopt it,
or（交付该轮领导者的提案以采用它，或者）</li>
<li>to suspect the leader（怀疑领导者）</li>
</ol></li>
<li>Hierarchical Consensus（分层共识）
<ul>
<li>The process with the smallest id among correct processes decides
first（正确进程中 id 最小的进程首先做出决定）</li>
<li>Its proposal is adopted by all other correct
processes（它的提案被所有其他正确的进程采用）</li>
<li>Then, the process with the second smallest id decides, and so
on（然后，id 第二小的进程决定，依此类推）</li>
</ul></li>
</ul>
<h5 id="算法伪代码-10">算法伪代码</h5>
<ul>
<li>Implemented: Consensus, instance <span class="math inline">\(c\)</span>.</li>
<li>Uses:
<ul>
<li>BestEffortBroadcast, instance <span class="math inline">\(beb\)</span></li>
<li>PerfectFailureDetector, instance <span class="math inline">\(P\)</span></li>
</ul></li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 c，设置检测到崩溃的序号集合为空，当前轮次为 1，当前提案为空，提案者为 0</span></span>
<span class="line"><span style="color: #abb2bf">// 设置 N 个进程的已交付状态为 FALSE，广播状态为 FALSE</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;c, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    detectedranks := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    round := 1;</span></span>
<span class="line"><span style="color: #abb2bf">    proposal := ⊥;</span></span>
<span class="line"><span style="color: #abb2bf">    proposer := 0;</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := [FALSE]N;</span></span>
<span class="line"><span style="color: #abb2bf">    broadcast := FALSE;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当检测到进程 p 崩溃时，将其序号加入崩溃序号集合</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;P, Crash | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    detectedranks := detectedranks ∪ {rank(p)};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到提案 v 且当前提案为空时，设置当前提案为 v</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;c, Propose | v&gt; such that proposal = ⊥ do</span></span>
<span class="line"><span style="color: #abb2bf">    proposal := v;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 如果当前轮次自己是领导者，当前提案不为空且未广播，则广播通知决定当前提案，并触发自身决定事件</span></span>
<span class="line"><span style="color: #abb2bf">upon round = rank(self) ∧ proposal ≠ ⊥ ∧ broadcast = FALSE do</span></span>
<span class="line"><span style="color: #abb2bf">    broadcast := TRUE;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;beb, Broadcast | [DECIDED, proposal]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;c, Decide | proposal&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到来自进程 p 的已决定提案 v 时，比较 p 的序号与自己的序号和当前提案者的序号</span></span>
<span class="line"><span style="color: #abb2bf">// 如果小于自己的序号且大于当前提案者的序号（还没轮到自己领导，且提案者是比自己早的进程）</span></span>
<span class="line"><span style="color: #abb2bf">// 则更新当前提案和提案者，并标记 p 的广播已交付</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Deliver | p, [DECIDED, v]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    r := rank(p);</span></span>
<span class="line"><span style="color: #abb2bf">    if r &lt; rank(self) ∧ r &gt; proposer then</span></span>
<span class="line"><span style="color: #abb2bf">        proposal := v;</span></span>
<span class="line"><span style="color: #abb2bf">        proposer := r;</span></span>
<span class="line"><span style="color: #abb2bf">    delivered[r] := TRUE;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 如果当前轮次的领导者在崩溃序号集合中，或当前轮次领导者的广播已交付，则进入下一轮</span></span>
<span class="line"><span style="color: #abb2bf">upon round ∈ detectedranks ∨ delivered[round] = TRUE do</span></span>
<span class="line"><span style="color: #abb2bf">    round := round + 1;</span></span></code></pre></div></div></figure>
<h5 id="示例-1">示例</h5>
<p><img src="image-56.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>上图：三个进程均无故障
<ul>
<li>轮次 1：进程 <span class="math inline">\(p_1\)</span>
作为领导者决定其提案 0 并广播该决定</li>
<li>轮次 2：进程 <span class="math inline">\(p_2\)</span>
作为领导者，由于上一轮中 <span class="math inline">\(p_1\)</span> 决定了
0 并广播，该值被 <span class="math inline">\(p_2\)</span> 采用，所以决定
0 并广播该决定</li>
<li>轮次 3：进程 <span class="math inline">\(p_3\)</span> 与 <span class="math inline">\(p_2\)</span> 类似，决定 0 并广播该决定</li>
</ul></li>
<li>下图：进程 <span class="math inline">\(p_1\)</span> 在轮次 2 崩溃
<ul>
<li>轮次 1：进程 <span class="math inline">\(p_1\)</span>
作为领导者决定其提案 0，但在广播时崩溃，只有 <span class="math inline">\(p_3\)</span> 收到该决定</li>
<li>轮次 2：进程 <span class="math inline">\(p_2\)</span>
作为领导者，由于没有收到 <span class="math inline">\(p_1\)</span>
的决定，且检测到 <span class="math inline">\(p_1\)</span> 崩溃，<span class="math inline">\(p_2\)</span> 决定其提案 1 并广播该决定</li>
<li>轮次 3：进程 <span class="math inline">\(p_3\)</span>
作为领导者，由于上一轮中 <span class="math inline">\(p_2\)</span> 决定了
1 并广播，该值被 <span class="math inline">\(p_3\)</span> 采用，所以决定
1 并广播该决定</li>
</ul></li>
</ul>
<h5 id="正确性论证一致性">正确性论证：一致性</h5>
<ul>
<li>Let <span class="math inline">\(p_i\)</span> be the correct process
with the smallest rank in an execution <span class="math inline">\(ex\)</span>（让 <span class="math inline">\(p_i\)</span> 成为执行 <span class="math inline">\(ex\)</span> 中排名最小的正确进程）</li>
<li>Assume <span class="math inline">\(p_i\)</span> decides <span class="math inline">\(v\)</span>, so we have（假设 <span class="math inline">\(p_i\)</span> 决定了 <span class="math inline">\(v\)</span>）
<ul>
<li><span class="math inline">\(i = N\)</span> : <span class="math inline">\(p_n\)</span> is the only correct process（<span class="math inline">\(p_n\)</span> 是唯一正确的进程）</li>
<li><span class="math inline">\(i &lt; N\)</span> : in round <span class="math inline">\(i\)</span>, all correct processes receive <span class="math inline">\(v\)</span> and will not decide anything different
from <span class="math inline">\(v\)</span>（在第 <span class="math inline">\(i\)</span> 轮中，所有正确的进程都接收到了 <span class="math inline">\(v\)</span>，并且不会决定与 <span class="math inline">\(v\)</span> 不同的任何东西）</li>
</ul></li>
</ul>
<h4 id="算法基于全序广播的共识-tob-based-consensus">算法：基于全序广播的共识
(TOB-Based Consensus)</h4>
<ul>
<li>Implemented: Consensus, instance <span class="math inline">\(c\)</span>.</li>
<li>Uses: TotalOrderBroadcast, instance <span class="math inline">\(tob\)</span>.</li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 c，设置当前提案为空，决定标志为 FALSE</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;c, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    proposal := ⊥;</span></span>
<span class="line"><span style="color: #abb2bf">    decided := FALSE;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到提案 v 且当前提案为空时，设置当前提案为 v，并使用 tob 广播该提案</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;c, Propose | v&gt; such that proposal = ⊥ do</span></span>
<span class="line"><span style="color: #abb2bf">    proposal := v;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;tob, Broadcast | proposal&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当 tob 交付来自进程 p 的提案 v 时，如果尚未决定，则设置当前提案为 v，标记决定为 TRUE，并触发 c 的决定事件</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;tob, Deliver | p, v&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    if decided = FALSE then</span></span>
<span class="line"><span style="color: #abb2bf">        proposal := v;</span></span>
<span class="line"><span style="color: #abb2bf">        decided := TRUE;</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;c, Decide | proposal&gt;;</span></span></code></pre></div></div></figure>
<h3 id="统一共识-uniform-consensus">统一共识 (Uniform consensus)</h3>
<h4 id="规范-13">规范</h4>
<ul>
<li>Name: UniformConsensus, instance <span class="math inline">\(uc\)</span>.</li>
<li>Request: <code>&lt;uc, Propose | v&gt;</code>: Proposes value <span class="math inline">\(v\)</span> for consensus.（提出值 <span class="math inline">\(v\)</span> 以达成共识）</li>
<li>Indication: <code>&lt;uc, Decide | v&gt;</code>: Outputs a decided
value <span class="math inline">\(v\)</span> of
consensus.（输出共识的决定值 <span class="math inline">\(v\)</span>）</li>
<li>Properties:
<ul>
<li>UC1 - UC3: Same as properties C1 - C3 in consensus.</li>
<li>UC1. <strong>Termination</strong>: Every correct process eventually
decides some value.（终止性：每个正确的进程最终决定某个值。）</li>
<li>UC2. <strong>Validity</strong>: If a process decides <span class="math inline">\(v\)</span>, then <span class="math inline">\(v\)</span> was proposed by some
process.（有效性：如果一个进程决定了 <span class="math inline">\(v\)</span>，那么 <span class="math inline">\(v\)</span> 是由某个进程提出的。）</li>
<li>UC3. <strong>Integrity</strong>: No process decides
twice.（完整性：没有进程会决定两次。）</li>
<li>UC4. <strong>Uniform Agreement</strong>: No two processes decide
differently.（一致协议：没有两个进程会做出不同的决定，<strong>不管它们是否正确</strong>。）</li>
</ul></li>
<li>Uniform consensus <img src="image-65.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h4 id="算法基于-p-的统一共识-p-based-uniform-consensus">算法：基于 P
的统一共识 (P-Based Uniform Consensus)</h4>
<h5 id="基本思想-3">基本思想</h5>
<ul>
<li>Idea
<ul>
<li>The processes exchange and update proposals in
rounds（进程在轮次中交换和更新提案）</li>
<li>After <span class="math inline">\(N\)</span> rounds decide on the
current proposal value（在 <span class="math inline">\(N\)</span>
轮后决定当前的提案值）</li>
</ul></li>
<li>The processes go through rounds incrementally (<span class="math inline">\(1 \to N\)</span>): in each round <span class="math inline">\(i\)</span>, process <span class="math inline">\(p_i\)</span> sends its proposal to
all（进程按顺序经历轮次，在每一轮 <span class="math inline">\(i\)</span>
中，进程 <span class="math inline">\(p_i\)</span>
将其提案发送给所有人）</li>
<li>A process adopts any proposal it receives if the proposal is sent in
previous round and more recent than its current
proposal（如果收到的提案是在自己轮数之前发送的并且比当前保存的提案更新，则进程采用该提案）</li>
<li>Process decide on their proposal <strong>at the end of
round</strong> <span class="math inline">\(N\)</span>（进程在第 <span class="math inline">\(N\)</span> 轮结束时决定其提案）</li>
</ul>
<h5 id="算法伪代码-11">算法伪代码</h5>
<ul>
<li>Implemented: UniformConsensus, instance <span class="math inline">\(uc\)</span>.</li>
<li>Uses:
<ul>
<li>BestEffortBroadcast, instance <span class="math inline">\(beb\)</span></li>
<li>PerfectFailureDetector, instance <span class="math inline">\(P\)</span></li>
</ul></li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">upon event &lt;uc, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    detectedranks := ∅;</span></span>
<span class="line"><span style="color: #abb2bf">    round := 1;</span></span>
<span class="line"><span style="color: #abb2bf">    proposal := ⊥;</span></span>
<span class="line"><span style="color: #abb2bf">    proposer := 0;</span></span>
<span class="line"><span style="color: #abb2bf">    delivered := [FALSE]N;</span></span>
<span class="line"><span style="color: #abb2bf">    broadcast := FALSE;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;P, Crash | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    detectedranks := detectedranks ∪ {rank(p)};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;uc, Propose | v&gt; such that proposal = ⊥ do</span></span>
<span class="line"><span style="color: #abb2bf">    proposal := v;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 如果当前轮次自己是领导者，当前提案不为空且未广播，则广播当前提案</span></span>
<span class="line"><span style="color: #abb2bf">// 与前面的分层共识算法的区别在于：不立刻决定当前提案</span></span>
<span class="line"><span style="color: #abb2bf">upon round = rank(self) ∧ proposal ≠ ⊥ ∧ broadcast = FALSE do</span></span>
<span class="line"><span style="color: #abb2bf">    broadcast := TRUE;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;beb, Broadcast | [PROPOSAL, proposal]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Deliver | p, [PROPOSAL, v]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    r := rank(p);</span></span>
<span class="line"><span style="color: #abb2bf">    if r &lt; rank(self) ∧ r &gt; proposer then</span></span>
<span class="line"><span style="color: #abb2bf">        proposal := v;</span></span>
<span class="line"><span style="color: #abb2bf">        proposer := r;</span></span>
<span class="line"><span style="color: #abb2bf">    delivered[r] := TRUE;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 如果当前轮次的领导者在崩溃序号集合中，或当前轮次领导者的广播已交付，则检查是否为最后一轮</span></span>
<span class="line"><span style="color: #abb2bf">// 如果是最后一轮则决定当前提案，否则进入下一轮</span></span>
<span class="line"><span style="color: #abb2bf">upon round ∈ detectedranks ∨ delivered[round] = TRUE do</span></span>
<span class="line"><span style="color: #abb2bf">    if round = N then</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;c, Decide | proposal&gt;;</span></span>
<span class="line"><span style="color: #abb2bf">    else</span></span>
<span class="line"><span style="color: #abb2bf">        round := round + 1;</span></span></code></pre></div></div></figure>
<h5 id="示例-2">示例</h5>
<p><img src="image-58.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>上图：三个进程均无故障
<ul>
<li>轮次 1：进程 <span class="math inline">\(p_1\)</span>
作为领导者广播其提案 0，其他进程采用该提案</li>
<li>轮次 2：进程 <span class="math inline">\(p_2\)</span>
作为领导者，由于采用了 <span class="math inline">\(p_1\)</span> 的提案
0，因此广播该提案</li>
<li>轮次 3：进程 <span class="math inline">\(p_3\)</span>
作为领导者，与上一轮类似，广播提案 0</li>
<li>在第 3 轮结束时，所有进程决定提案 0</li>
</ul></li>
<li>下图：进程 <span class="math inline">\(p_1\)</span> 在轮次 2 崩溃
<ul>
<li>轮次 1：进程 <span class="math inline">\(p_1\)</span>
作为领导者广播其提案 0，但在广播时崩溃，只有 <span class="math inline">\(p_3\)</span> 收到该提案并采用它</li>
<li>轮次 2：进程 <span class="math inline">\(p_2\)</span>
作为领导者，由于没有收到 <span class="math inline">\(p_1\)</span>
的广播，且检测到 <span class="math inline">\(p_1\)</span> 崩溃，<span class="math inline">\(p_2\)</span> 广播其提案 1，此时 <span class="math inline">\(p_3\)</span> 采用该提案代替之前的提案 0</li>
<li>轮次 3：进程 <span class="math inline">\(p_3\)</span>
作为领导者，由于采用了 <span class="math inline">\(p_2\)</span> 的提案
1，因此广播该提案</li>
<li>在第 3 轮结束时，存活的进程 <span class="math inline">\(p_2\)</span>
和 <span class="math inline">\(p_3\)</span> 决定提案 1</li>
</ul></li>
</ul>
<h5 id="正确性论证统一一致性">正确性论证：统一一致性</h5>
<ul>
<li>Consider the process with the lowest id which decides, say <span class="math inline">\(p_i\)</span>（考虑做出决定的 id 最小的进程，假设为
<span class="math inline">\(p_i\)</span>）
<ul>
<li>Hence, <span class="math inline">\(p_i\)</span> completes round
<span class="math inline">\(N\)</span>（因此，<span class="math inline">\(p_i\)</span> 完成了第 <span class="math inline">\(N\)</span> 轮）</li>
</ul></li>
<li>In round <span class="math inline">\(i\)</span>, every <span class="math inline">\(p_j\)</span> with <span class="math inline">\(j
&gt; i\)</span> receives the proposal of <span class="math inline">\(p_i\)</span> and adopts it（在第 <span class="math inline">\(i\)</span> 轮中，每个 <span class="math inline">\(p_j\)</span>（<span class="math inline">\(j &gt;
i\)</span>）都接收到了 <span class="math inline">\(p_i\)</span>
的提案并采用了它）</li>
<li>Hence, every process which sends a message after round <span class="math inline">\(i\)</span> has the same proposal at the end of
round <span class="math inline">\(i\)</span>,（因此，在第 <span class="math inline">\(i\)</span> 轮结束时，在第 <span class="math inline">\(i\)</span>
轮之后发送消息的每个进程都有相同的提案。）</li>
</ul>
<h4 id="算法基于-p-和法定人数的统一共识-p-quorum-based-uniform-consensus">算法：基于
♢P 和法定人数的统一共识 (♢P &amp; Quorum-Based Uniform Consensus)</h4>
<ul>
<li>Uniform consensus using
<ul>
<li>Correct majority (<strong>Quorum</strong>)</li>
<li>Eventually perfect Failure Detector (<span class="math inline">\(\diamondsuit P\)</span>)</li>
</ul></li>
<li>Idea: processes alternate in the role of a leader (coordinator)
until one of them succeeds in imposing a
decision（想法：进程轮流担任领导者（协调者）的角色，直到其中一个成功地强加了一个决定）</li>
<li>Prioritize safety (agreement) rather than liveness
(termination)（优先考虑安全性（一致性）而不是活跃性（终止性））</li>
<li><span class="math inline">\(\diamondsuit P\)</span> do make a
difference?
<ul>
<li>Correct processes might be falsely suspected finitely many
times（正确的进程可能会被错误地怀疑有限次）</li>
<li>False suspicion of a correct process by <span class="math inline">\(\diamondsuit P\)</span> makes algorithms I and II
break（<span class="math inline">\(\diamondsuit P\)</span>
对正确进程的错误怀疑使算法 I 和 II 失败）
<ul>
<li><p>Alg. I: Agreement violation with <span class="math inline">\(\diamondsuit P\)</span> <img src="image-74.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>轮次 1：<span class="math inline">\(p_1\)</span> 决定值 0
并广播，但被 <span class="math inline">\(p_2\)</span> 和 <span class="math inline">\(p_3\)</span> 的 <span class="math inline">\(\diamondsuit P\)</span> 错误怀疑为崩溃</li>
<li>轮次 2：<span class="math inline">\(p_2\)</span> 决定新的值 1
并广播，此时 <span class="math inline">\(p_1\)</span> 与 <span class="math inline">\(p_2\)</span> 决定不同的值，导致一致性被破坏</li>
</ul></li>
<li><p>Alg. II: Agreement violation with <span class="math inline">\(\diamondsuit P\)</span> <img src="image-73.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>轮次 1：<span class="math inline">\(p_1\)</span> 提出值 0
并广播，但被 <span class="math inline">\(p_2\)</span> 和 <span class="math inline">\(p_3\)</span> 的 <span class="math inline">\(\diamondsuit P\)</span> 错误怀疑为崩溃</li>
<li>轮次 2：<span class="math inline">\(p_2\)</span> 提出新的值 1
并广播，<span class="math inline">\(p_3\)</span> 接收该值并采用它，而
<span class="math inline">\(p_1\)</span> 的 <span class="math inline">\(\diamondsuit P\)</span> 误判 <span class="math inline">\(p_2\)</span> 崩溃</li>
<li>轮次 3：<span class="math inline">\(p_3\)</span> 使用其采用的值 1
作为提案并广播，而 <span class="math inline">\(p_1\)</span> 的 <span class="math inline">\(\diamondsuit P\)</span> 误判 <span class="math inline">\(p_3\)</span> 崩溃</li>
<li>最终，<span class="math inline">\(p_1\)</span> 决定值 0，而 <span class="math inline">\(p_2\)</span> 和 <span class="math inline">\(p_3\)</span> 决定值 1，导致一致性被破坏</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h5 id="基本思想-4">基本思想</h5>
<ul>
<li><p>The processes go through rounds incrementally: in each round
<span class="math inline">\(k\)</span>, such that <span class="math inline">\(k \bmod N = i\)</span>, <span class="math inline">\(p_i\)</span> is the
leader（进程按顺序经历轮次：在每一轮 <span class="math inline">\(k\)</span> 中，如果 <span class="math inline">\(k
\bmod N = i\)</span>，则 <span class="math inline">\(p_i\)</span>
是领导者）</p></li>
<li><p>In such a round <span class="math inline">\(k\)</span>, <span class="math inline">\(p_i\)</span> tries to
<strong>decide</strong>（在这样的第 <span class="math inline">\(k\)</span> 轮中，<span class="math inline">\(p_i\)</span> 试图做出决定）</p>
<ul>
<li><span class="math inline">\(p_i\)</span> succeeds if it is not
suspected（如果 <span class="math inline">\(p_i\)</span> 没有被怀疑，则
<span class="math inline">\(p_i\)</span> 成功）</li>
<li>Otherwise, processes that suspect <span class="math inline">\(p_i\)</span> inform all processes including <span class="math inline">\(p_i\)</span> and move to the next
round（否则，怀疑 <span class="math inline">\(p_i\)</span>
的进程通知包括 <span class="math inline">\(p_i\)</span>
在内的所有进程进入下一轮）</li>
</ul></li>
<li><p>To decide, <span class="math inline">\(p_i\)</span> does the
following（为了做出决定，<span class="math inline">\(p_i\)</span>
执行以下操作）</p>
<ol type="1">
<li><span class="math inline">\(p_i\)</span> <strong>reads</strong> the
proposals of a majority of processes and <strong>selects</strong> the
latest adopted value (latest with respect to the round in which the
value is adopted - see step 2)（<span class="math inline">\(p_i\)</span>
读取大多数进程的提案并选择最新采用的值（根据采用该值的轮次 - 见步骤
2））
<ul>
<li>if no value was adopted by any process in a given majority, <span class="math inline">\(p_i\)</span> imposes its own initial (proposal)
value in step 2（如果在给定多数中没有任何进程采用任何值，则 <span class="math inline">\(p_i\)</span> 在步骤 2
中强加其自己的初始（提议）值）</li>
</ul></li>
<li><span class="math inline">\(p_i\)</span> <strong>imposes</strong>
that value at a majority: any process in that majority adopts that value
- <span class="math inline">\(p_i\)</span> fails if it is
suspected（<span class="math inline">\(p_i\)</span>
在多数中强加该值：该多数中的任何进程都采用该值 - 如果 <span class="math inline">\(p_i\)</span> 被怀疑则失败）</li>
<li><span class="math inline">\(p_i\)</span> <strong>decides</strong>
and <strong>broadcasts</strong> the decision to all （<span class="math inline">\(p_i\)</span> 做出决定并将决定广播给所有人）</li>
</ol></li>
<li><p><span class="math inline">\(\diamondsuit P\)</span> and
Quorum-based Uniform Consensus <img src="image-59.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>上、中两图是下图中一个 round 内的三个步骤</li>
<li>上图：
<ul>
<li>Step 1 - Read/Gather：<span class="math inline">\(p_1\)</span>
作为领导者，向 <span class="math inline">\(p_2\)</span> 和 <span class="math inline">\(p_3\)</span> 发送 READ
请求以收集它们的提案，发现没有进程采用任何值，因此选择自己的提案 0</li>
<li>Step 2 - Impose/Ack：<span class="math inline">\(p_1\)</span> 向
<span class="math inline">\(p_2\)</span> 和 <span class="math inline">\(p_3\)</span> 发送 IMPOSE 请求以强加值 0，<span class="math inline">\(p_2\)</span> 和 <span class="math inline">\(p_3\)</span> 采用该值并发送 ACK 确认</li>
<li>Step 3 - Decide：<span class="math inline">\(p_1\)</span> 收到足够的
ACK 后决定值 0 并广播该决定，<span class="math inline">\(p_2\)</span> 和
<span class="math inline">\(p_3\)</span> 接收该决定并也决定值 0</li>
</ul></li>
<li>中图：如果 <span class="math inline">\(p_1\)</span> 崩溃，则 <span class="math inline">\(p_2\)</span> 和 <span class="math inline">\(p_3\)</span> 发送 nack 并进入下一轮</li>
</ul></li>
</ul>
<h5 id="算法伪代码-12">算法伪代码</h5>
<ul>
<li>Implemented: UniformConsensus, instance <span class="math inline">\(uc\)</span>.</li>
<li>Uses:
<ul>
<li>BestEffortBroadcast, instance <span class="math inline">\(beb\)</span></li>
<li>EventuallyPerfectFailureDetector, instance <span class="math inline">\(\diamondsuit P\)</span></li>
<li>PerfectPointToPointLinks, instance <span class="math inline">\(pl\)</span></li>
<li>ReliableBroadcast, instance <span class="math inline">\(rb\)</span></li>
</ul></li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 uc，设置怀疑进程集合为空，nacked 集合为空，当前轮次为 1，已提案标志为 FALSE</span></span>
<span class="line"><span style="color: #abb2bf">// 设置当前提案为空，潜在共识值为 nil，潜在共识轮次为 0，N 个进程的状态为 [nil, 0]，确认计数为 0</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;uc, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    suspected := Ø;</span></span>
<span class="line"><span style="color: #abb2bf">    nacked := Ø;</span></span>
<span class="line"><span style="color: #abb2bf">    round := 1;</span></span>
<span class="line"><span style="color: #abb2bf">    proposed := false;</span></span>
<span class="line"><span style="color: #abb2bf">    proposal := ⊥;</span></span>
<span class="line"><span style="color: #abb2bf">    estimate := nil;</span></span>
<span class="line"><span style="color: #abb2bf">    estround := 0;</span></span>
<span class="line"><span style="color: #abb2bf">    states := [nil, 0]N;</span></span>
<span class="line"><span style="color: #abb2bf">    acks := 0;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到 ◇P 对进程 p 的怀疑时，将 p 加入怀疑进程集合</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;◇P, Suspect | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    suspected := suspected ∪ {p};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到 ◇P 对进程 p 的恢复通知时，将 p 从怀疑进程集合中移除</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;◇P, Restore | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    suspected := suspected \ {p};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到提案 v 且当前提案为空时，设置当前提案为 v</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;uc, Propose | v&gt; such that proposal = ⊥ do</span></span>
<span class="line"><span style="color: #abb2bf">    proposal := v;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 如果当前轮次自己是领导者，且未提出过提案，且当前提案不为空，则开始提出提案</span></span>
<span class="line"><span style="color: #abb2bf">// 标记已提出提案，重置状态数组和确认计数，然后广播 READ 请求以收集进程状态</span></span>
<span class="line"><span style="color: #abb2bf">upon rank(self) = round and proposed = false and proposal ≠ ⊥ do</span></span>
<span class="line"><span style="color: #abb2bf">    proposed := true;</span></span>
<span class="line"><span style="color: #abb2bf">    states := [nil, 0]N;</span></span>
<span class="line"><span style="color: #abb2bf">    acks := 0;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;beb, Broadcast | [READ, round]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到来自当前轮次领导者进程 p 的 READ 请求时，回复 GATHER 响应</span></span>
<span class="line"><span style="color: #abb2bf">// 响应内容包含当前轮次、潜在共识值和潜在共识轮次</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Deliver | p, [READ, round]&gt; and rank(p) = round do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;pl, Send | p, [GATHER, round, estimate, estround]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到来自进程 p 的 GATHER 响应时，更新状态数组，记录 p 的潜在共识值和潜在共识轮次</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;pl, Deliver | p, [GATHER, round, est, estrnd]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    states[p] := [est, estrnd];</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当状态数组中有来自多数进程的状态时，从中选择最新的潜在共识值作为提案（如果全空就用自己原有的）</span></span>
<span class="line"><span style="color: #abb2bf">// 然后重置状态数组，广播 IMPOSE 请求以强加该值</span></span>
<span class="line"><span style="color: #abb2bf">upon #states ≥ majority do</span></span>
<span class="line"><span style="color: #abb2bf">    if ∃ states[p] ≠ [nil, 0] then</span></span>
<span class="line"><span style="color: #abb2bf">        select states[p]=[est, estrnd] with highest estrnd</span></span>
<span class="line"><span style="color: #abb2bf">        proposal := est;</span></span>
<span class="line"><span style="color: #abb2bf">    states := [nil, 0]N;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;beb, Broadcast | [IMPOSE, round, proposal]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到来自当前轮次领导者进程 p 的 IMPOSE 请求时，更新估计值和估计轮次，然后回复 ACK 确认</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Deliver | p, [IMPOSE, round, v]&gt; and rank(p) = round do</span></span>
<span class="line"><span style="color: #abb2bf">    estimate := v;</span></span>
<span class="line"><span style="color: #abb2bf">    estround := round;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;pl, Send | p, [ACK, round]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到来自进程 p 的 ACK 确认时，增加确认计数</span></span>
<span class="line"><span style="color: #abb2bf">// 当确认计数达到多数时，广播 DECIDE 决定消息</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;pl, Deliver | p, [ACK, round]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    acks := acks + 1;</span></span>
<span class="line"><span style="color: #abb2bf">    if acks ≥ majority then</span></span>
<span class="line"><span style="color: #abb2bf">        trigger &lt;beb, Broadcast | [DECIDE, proposal]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到来自进程 p 的 DECIDE 决定消息时，触发 uc 的决定事件</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;beb, Deliver | p, [DECIDE, v]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;uc, Decide | v&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 若当前轮次的领导者被怀疑时，发送 NACK 消息以进行换主</span></span>
<span class="line"><span style="color: #abb2bf">upon rank(p) = round and p ∈ suspected do</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;rb, Broadcast | [NACK, round]&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当收到来自进程 p 的 NACK 消息时，将该轮次加入 nacked 集合</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;rb, Deliver | p, [NACK, rnd]&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    nacked := nacked ∪ {rnd};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 若当前轮次在 nacked 集合中，重置已提出提案标志，进入下一轮</span></span>
<span class="line"><span style="color: #abb2bf">upon round ∈ nacked do</span></span>
<span class="line"><span style="color: #abb2bf">    proposed := false;</span></span>
<span class="line"><span style="color: #abb2bf">    round := round + 1;</span></span></code></pre></div></div></figure>
<p><img src="image-78.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h5 id="示例-3">示例</h5>
<ul>
<li><p>无故障 <img src="image-79.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>完成共识后故障，未触发换主 <img src="image-80.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>完成共识后故障，触发换主，由于满足法定人数，可以通过 READ
读取潜在的共识值，最终仍能达成一致 <img src="image-81.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>故障且未完成共识，触发换主，此时第一个提案被放弃，新的领导者提出自己的提案并达成一致
<img src="image-82.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>如果 <span class="math inline">\(p_1\)</span>
只是被错误怀疑崩溃，且在 <span class="math inline">\(p_5\)</span> 与
<span class="math inline">\(p_3\)</span>、<span class="math inline">\(p_4\)</span> 达成共识后恢复，则在下一轮中 <span class="math inline">\(p_1\)</span> 的 READ
请求会读取到新的潜在共识值（计算利息），由于比自己的（转账）更新，因此
<span class="math inline">\(p_1\)</span> 会采用该值并最终达成一致</li>
</ul></li>
</ul>
<h5 id="正确性论证终止性和一致性">正确性论证：终止性和一致性</h5>
<ul>
<li>We skip validity and integrity</li>
<li><strong>Termination</strong>（终止性）
<ul>
<li>if a correct process decides, it broadcasts the decision to all:
every correct process
decides（如果一个正确的进程做出决定，它会将决定广播给所有人：每个正确的进程都会做出决定）</li>
<li>Assume by contradiction that some process is correct and no correct
process decides. We argue that this is
impossible.（反证法：假设某个正确进程没有做出决定，证明这是不可能的。）
<ul>
<li>By
<ul>
<li>correct majority assumption（正确进程的多数假设）</li>
<li>Strong completeness property of <span class="math inline">\(\diamondsuit P\)</span>（<span class="math inline">\(\diamondsuit P\)</span>
的强完整性：最终所有崩溃的进程都会被所有正确进程永久怀疑）</li>
<li>no correct process remains blocked forever in some
round（没有正确的进程会永远阻塞在某一轮中）</li>
</ul></li>
<li>By the eventual accuracy property of <span class="math inline">\(\diamondsuit P\)</span>（<span class="math inline">\(\diamondsuit P\)</span>
的最终准确性：最终，没有正确的进程会被任何进程怀疑）
<ul>
<li>some correct process p reaches a round where it is the leader and it
is not suspected（在某一轮，某个正确的进程 p 成为领导者且不被怀疑）</li>
<li>p reaches a decision in that round: a contradiction（p
在那一轮必然能做出决定：与假设矛盾！）</li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Agreement</strong>（一致性）
<ul>
<li>Let <span class="math inline">\(k\)</span> be the first round in
which some process <span class="math inline">\(p_i\)</span> decides some
value <span class="math inline">\(v\)</span>, <span class="math inline">\(p_i\)</span> is the leader of round <span class="math inline">\(k\)</span> and <span class="math inline">\(p_i\)</span> decides <span class="math inline">\(v\)</span> in <span class="math inline">\(k\)</span>（设 <span class="math inline">\(k\)</span> 是某个进程 <span class="math inline">\(p_i\)</span> 决定某个值 <span class="math inline">\(v\)</span> 的第一轮，即 <span class="math inline">\(p_i\)</span> 是第 <span class="math inline">\(k\)</span> 轮的领导者并且 <span class="math inline">\(p_i\)</span> 在第 <span class="math inline">\(k\)</span> 轮中决定了 <span class="math inline">\(v\)</span>）
<ul>
<li>This means that, in round <span class="math inline">\(k\)</span>, a
majority of processes adopt <span class="math inline">\(v\)</span>（这意味着，在第 <span class="math inline">\(k\)</span> 轮中，大多数进程采用了 <span class="math inline">\(v\)</span>）</li>
<li>The algorithm guarantees that no value other than <span class="math inline">\(v\)</span> will be imposed (and hence decided) by
any process in a round higher than <span class="math inline">\(k\)</span> (Quorum)（该算法保证，在高于 <span class="math inline">\(k\)</span>
的轮次中，任何进程都不会强加（因此决定）除 <span class="math inline">\(v\)</span> 之外的任何值（法定人数）） <img src="image-83.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li>Agreement does not depend on FD（一致性不依赖于 FD）
<ul>
<li>Consider a bogus FD (provides no guarantees)（考虑一个错误的
FD（不提供任何保证））
<ul>
<li>may always suspect everybody（可能总是怀疑每个人）</li>
<li>may never suspect anybody（可能从不怀疑任何人）</li>
</ul></li>
<li>Agreement is never violated（一致性从未被违反）
<ul>
<li>Can use the same correctness argument as
before（可以使用与之前相同的正确性论证）</li>
<li><strong>Agreement depends on majority assumption
(Quorum)</strong>（一致性取决于多数假设（法定人数））</li>
</ul></li>
<li>However, Termination not ensured（但是，终止性无法保证）
<ul>
<li>everybody may be suspected infinitely
often（每个人可能会被无限期怀疑）</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h5 id="复杂度分析">复杂度分析</h5>
<ul>
<li>Best case: if the leader does not crash and <span class="math inline">\(\diamondsuit P\)</span> is
accurate（最佳情况：如果领导者没有崩溃并且 <span class="math inline">\(\diamondsuit P\)</span> 是准确的）
<ul>
<li>Four communication steps and <span class="math inline">\(O(N)\)</span> messages（四个通信步骤和 <span class="math inline">\(O(N)\)</span> 条消息）</li>
<li>Two communication steps and <span class="math inline">\(O(N)\)</span> messages if we skip READ
phase（如果我们跳过 READ 阶段，则为两个通信步骤和 <span class="math inline">\(O(N)\)</span> 条消息）</li>
</ul></li>
<li>Worst case:
<ul>
<li>if <span class="math inline">\(\diamondsuit P\)</span> is accurate,
<span class="math inline">\(O(Nf) = O(N^2)\)</span> messages for 2
phases and <span class="math inline">\(O(fN^2) = O(N^3)\)</span> for
NACK（如果 <span class="math inline">\(\diamondsuit P\)</span>
是准确的，2 个阶段需要 <span class="math inline">\(O(N^2)\)</span>
条消息，NACK 需要 <span class="math inline">\(O(N^3)\)</span> 条消息）
<ul>
<li><span class="math inline">\(f\)</span>: number of faulty
processes（故障进程数）</li>
</ul></li>
<li>Otherwise, infinite steps（否则，无限步骤）</li>
</ul></li>
</ul>
<h3 id="flp-不可能性定理-flp-impossibility-result">FLP 不可能性定理 (FLP
impossibility result)</h3>
<ul>
<li>Asynchronous deterministic consensus with <span class="math inline">\(N \geqslant 2\)</span> processes is impossible
even with one (crash) faulty process（即使只有一个（崩溃）故障进程，具有
<span class="math inline">\(N \geqslant 2\)</span>
个进程的异步确定性共识也是不可能的）
<ul>
<li>无法同时完美地满足共识的三个基本属性：
<ul>
<li>一致性 (Agreement)：所有正确进程决定的值必须相同。</li>
<li>有效性 (Validity)：决定的值必须是由某个进程提出的。</li>
<li>终止性 (Termination/Liveness)：所有正确进程最终都能做出决定。</li>
</ul></li>
<li>原因：异步 vs 崩溃
<ul>
<li>在异步模型中，消息延迟、进程执行速度以及时钟漂移都没有上限，这使得进程无法区分其他进程是崩溃了还是只是延迟了消息。</li>
<li>FLP
证明了在某些特定的调度序列下，系统可能会永远处于一种“非决定性状态”，每一轮操作都无法产生最终结论，导致系统永远无法达成终止性。</li>
</ul></li>
</ul></li>
<li>Even simplify the problem, FLP still holds（即使简化问题，FLP
仍然成立）
<ul>
<li>To strengthen the lower bound, assume binary
consensus（为了加强下界，假设二进制共识）
<ul>
<li>Proposals and decisions are from {0, 1}（提案和决定来自 {0,
1}）</li>
</ul></li>
<li>Even this is impossible in an asynchronous system with one faulty
process（即使在有一个故障进程的异步系统中也是不可能的）</li>
</ul></li>
<li>How to circumvent FLP（如何规避 FLP）
<ul>
<li>Timing assumptions (failure detectors,
synchrony)（引入时序假设（故障检测器，同步性））</li>
<li>No possible failures（没有可能的故障）</li>
<li>Randomization（随机化）</li>
</ul></li>
</ul>
<h3 id="paxos">Paxos</h3>
<ul>
<li>通过多个共识实例（Consensus Instances）来实现状态机复制（State
Machine Replication, SMR）或全序广播（Total-Order Broadcast）的协议
<ul>
<li>Paxos is invented as a SMR protocol, i.e., total-order
Broadcast（Paxos 被发明为一种 SMR 协议，即全序广播）</li>
<li>Clients and Servers（客户端和服务器）
<ul>
<li>Clients initiate requests（客户端发起请求）</li>
<li>Servers (processes) run consensus（服务器（进程）运行共识）</li>
</ul></li>
<li>Multiple instances of consensus (Synod)（共识的多个实例）
<ul>
<li>Synod instance 25 to agree on the 25th request（Synod 实例 25
以同意第 25 个请求）</li>
</ul></li>
<li>Unreliable estimates of the current round and
leader（当前轮次和领导者的不可靠估计）
<ul>
<li>Both clients and processes have the (unreliable) estimate of the
current round and leader (some
process)（客户端和进程都有当前轮次和领导者（某个进程）的（不可靠）估计）</li>
</ul></li>
<li>交互流程
<ul>
<li>Clients send requests to the leader（客户端将请求发送给领导者）</li>
<li>The leader replies to the client（领导者回复客户端）</li>
</ul></li>
</ul></li>
</ul>
<h2 id="组成员资格group-membership">组成员资格（Group Membership）</h2>
<ul>
<li>In some distributed applications, processes need to know which
processes are participating in the computation and which are
not（在某些分布式应用程序中，进程需要知道哪些进程正在参与计算，哪些没有）
<ul>
<li>E.g., ZooKeeper, etcd</li>
</ul></li>
<li>Failure detectors?
<ul>
<li>provide such information（提供此类信息）</li>
<li>however, that information is not coordinated even if the failure
detector is
perfect（但是，即使故障检测器是完美的，该信息也没有协调）</li>
</ul></li>
<li>Group membership <img src="image-88.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>Fault Tolerance focus（容错重点）
<ul>
<li>Group membership abstraction to <strong>coordinate</strong> the
information about crashes（组成员资格抽象以协调有关崩溃的信息）</li>
<li>More generally, a group membership abstraction can also typically be
used to coordinate the processes joining and leaving
<strong>explicitly</strong> the set of processes (i.e., without
crashes)（更一般地，组成员资格抽象通常也可以用于协调进程显式地加入和离开进程集（即没有崩溃））</li>
</ul></li>
<li>Like with a failure detector（与故障检测器一样）
<ul>
<li>the processes are informed about failures（进程被告知故障情况）</li>
<li>we say that the processes install views（我们说进程安装视图）</li>
</ul></li>
<li>Like with a perfect failure detector P（与完美故障检测器 P 一样）
<ul>
<li>the processes have accurate knowledge about
failures（进程对故障有准确的了解）</li>
</ul></li>
<li>Unlike with a perfect failure detector P（与完美故障检测器 P 不同）
<ul>
<li>the information about failures are
coordinated（有关故障的信息是协调的）</li>
<li>the processes install the same sequence of
views（进程安装相同的视图序列）</li>
</ul></li>
</ul>
<h3 id="规范-14">规范</h3>
<ul>
<li>Name: GroupMembership, instance <span class="math inline">\(gm\)</span>.</li>
<li>Indication: <code>&lt;gm, View | V&gt;</code>: Installs a new view V
= (id, M) with view identifier id (0, 1, 2,,..) and membership
M.（安装一个新的视图 V = (id, M)，其中视图标识符为 id，成员资格为
M）</li>
<li>Properties:
<ul>
<li>GM1. <strong>Monotonicity</strong>: If a process <span class="math inline">\(p\)</span> installs a view <span class="math inline">\(V = (id, M)\)</span> and subsequently installs
another view <span class="math inline">\(V^\prime= (id^\prime,
M^\prime)\)</span>, then <span class="math inline">\(id &lt;
id^\prime\)</span> and <span class="math inline">\(M^\prime \subsetneq
M\)</span>,（单调性：如果进程 <span class="math inline">\(p\)</span>
安装视图 <span class="math inline">\(V = (id,
M)\)</span>，然后安装另一个视图 <span class="math inline">\(V^\prime =
(id^\prime, M^\prime)\)</span>，则 <span class="math inline">\(id &lt;
id^\prime\)</span> 且 <span class="math inline">\(M^\prime \subsetneq
M\)</span>。）</li>
<li>GM2. <strong>Uniform Agreement</strong>: If some process installs a
view <span class="math inline">\(V = (id, M)\)</span> and another
process installs some view <span class="math inline">\(V^\prime = (id,
M^\prime)\)</span>, then <span class="math inline">\(M =
M^\prime\)</span>,（统一一致性：如果某个进程安装视图 <span class="math inline">\(V = (id, M)\)</span>，另一个进程安装某个视图 <span class="math inline">\(V^\prime = (id, M^\prime)\)</span>，则 <span class="math inline">\(M = M^\prime\)</span>。）</li>
<li>GM3. <strong>Completeness</strong>: If a process <span class="math inline">\(p\)</span> crashes, then eventually every correct
process installs a view (id, M) such that <span class="math inline">\(p
\notin M\)</span>,（完整性：如果进程 <span class="math inline">\(p\)</span> 崩溃，则最终每个正确的进程都会安装视图
(id, M)，使得 <span class="math inline">\(p \notin M\)</span>。）</li>
<li>GM4. <strong>Accuracy</strong>: If some process installs a view (id,
M) with <span class="math inline">\(q \notin M\)</span> for some process
<span class="math inline">\(q \in \Pi\)</span>, then <span class="math inline">\(q\)</span> has
crashed.（准确性：如果某个进程安装视图 (id, M)，其中对于某个进程 <span class="math inline">\(q \in \Pi\)</span> 有 <span class="math inline">\(q \notin M\)</span>，则 <span class="math inline">\(q\)</span> 已崩溃。）</li>
</ul></li>
</ul>
<h3 id="算法基于共识的组成员资格consensus-based-group-membership">算法：基于共识的组成员资格（Consensus-Based
Group Membership）</h3>
<ul>
<li>Implemented: GroupMembership, instance <span class="math inline">\(gm\)</span>.</li>
<li>Uses:
<ul>
<li>UniformConsensus, multiple instances <span class="math inline">\(uc.i\)</span> for view <span class="math inline">\(i\)</span></li>
<li>PerfectFailureDetector, instance <span class="math inline">\(P\)</span></li>
</ul></li>
</ul>
<figure class="shiki"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf">// 初始化 gm，设置当前视图编号为 0，成员集为所有进程，</span></span>
<span class="line"><span style="color: #abb2bf">// 设置正确进程集为所有进程，等待标志为 FALSE，然后安装初始视图</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;gm, Init&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    (id, M) := (0, Π);</span></span>
<span class="line"><span style="color: #abb2bf">    correct := Π;</span></span>
<span class="line"><span style="color: #abb2bf">    wait := FALSE;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;gm, View | (id, M)&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当 P 检测到进程 p 崩溃时，从正确进程集中移除 p</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;P, Crash | p&gt; do</span></span>
<span class="line"><span style="color: #abb2bf">    correct := correct \ {p};</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当正确进程集是当前成员集的真子集且不在等待时，启动一个新的共识实例以提出新的成员集</span></span>
<span class="line"><span style="color: #abb2bf">upon correct ⊊ M ∧ wait = FALSE do</span></span>
<span class="line"><span style="color: #abb2bf">    id := id + 1;</span></span>
<span class="line"><span style="color: #abb2bf">    wait := TRUE;</span></span>
<span class="line"><span style="color: #abb2bf">    Initialize a new instance uc.id;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;uc.id, Propose | correct&gt;;</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf">// 当共识实例 id 决定了成员集 M' 时，更新当前成员集为 M'，将等待标志设为 FALSE，并安装新视图</span></span>
<span class="line"><span style="color: #abb2bf">upon event &lt;uc.i, Decide | M'&gt; such that i = id do</span></span>
<span class="line"><span style="color: #abb2bf">    M := M';</span></span>
<span class="line"><span style="color: #abb2bf">    wait := FALSE;</span></span>
<span class="line"><span style="color: #abb2bf">    trigger &lt;gm, View | (id, M)&gt;;</span></span></code></pre></div></div></figure>
<h3 id="示例-4">示例</h3>
<p><img src="image-89.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h3 id="正确性论证">正确性论证</h3>
<ul>
<li>Monotonicity（单调性）
<ul>
<li><span class="math inline">\(id &lt; id^\prime\)</span>
<ul>
<li>By construction（通过构造）</li>
<li>Each new view is proposed in a new consensus instance with
increasing id（每个新视图都在一个新的具有递增 id 的共识实例中提出）</li>
<li>With the <code>WAIT</code> flag, a process will not propose to
instance <span class="math inline">\(id\)</span> before all
lower-numbered instances have decided（通过 <code>WAIT</code>
标志，进程不会在所有较低编号的实例决定之前向实例 <span class="math inline">\(id\)</span> 提出建议）</li>
</ul></li>
<li><span class="math inline">\(M^\prime \subsetneq M\)</span>
<ul>
<li>By uniform consensus Validity（通过统一共识的有效性）</li>
<li>Since a consensus is triggered only when <span class="math inline">\(\mathrm{correct} \subsetneq M\)</span>（因为仅当
<span class="math inline">\(\mathrm{correct} \subsetneq M\)</span>
时才会触发共识）</li>
</ul></li>
</ul></li>
<li>Agreement（一致性）
<ul>
<li>By uniform consensus Uniform Agreement（通过统一共识的一致性）</li>
</ul></li>
<li>Completeness（完整性）
<ul>
<li>By strong completeness of <span class="math inline">\(P\)</span> all
correct processes suspect <span class="math inline">\(p\)</span>
eventually（通过 <span class="math inline">\(P\)</span>
的强完整性，所有正确的进程最终都会怀疑 <span class="math inline">\(p\)</span>）</li>
<li>Once all correct processes suspect <span class="math inline">\(p\)</span>, a member set without <span class="math inline">\(p\)</span> will be proposed by
all（一旦所有正确的进程怀疑 <span class="math inline">\(p\)</span>，所有进程都会提出一个不包含 <span class="math inline">\(p\)</span> 的成员集）</li>
<li>By uniform consensus Validity，a view without <span class="math inline">\(p\)</span> is
installed（通过统一共识有效性安装了没有 <span class="math inline">\(p\)</span> 的视图）</li>
</ul></li>
<li>Accuracy（准确性）
<ul>
<li>By Strong Accuracy of <span class="math inline">\(P\)</span>（通过
<span class="math inline">\(P\)</span> 的强准确性）</li>
</ul></li>
</ul>
<h2 id="应用">应用</h2>
<h3 id="顺序算法与分布式算法sequential-algorithms-vs.-distributed-algorithms">顺序算法与分布式算法（Sequential
Algorithms vs.&nbsp;Distributed Algorithms）</h3>
<p><img src="image-90.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h3 id="分布式存储系统distributed-storage-systems">分布式存储系统（Distributed
storage systems）</h3>
<ul>
<li>Google File System, Apache HDFS, Ceph,,.. <img src="image-91.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>Configuration management module（配置管理模块）
<ul>
<li>Full-fledged SMR (group membership, consensus)（完善的
SMR（组成员资格，共识））</li>
<li><span class="math inline">\(N = 5\)</span>, typically</li>
</ul></li>
<li>Metadata store（元数据存储）
<ul>
<li>Another level of indirection（另一层间接性）</li>
<li>E.g., Ceph</li>
</ul></li>
<li>Data store（数据存储）
<ul>
<li>3-way replication, <span class="math inline">\(N = 3\)</span>,
usually a single writer（3 路复制，通常是单个写入器）</li>
<li>Rack Awareness（机架感知）</li>
</ul></li>
</ul>
<h3 id="大型数据库系统large-scale-database-systems">大型数据库系统（Large-scale
database systems）</h3>
<ul>
<li>Google Spanner, PingCAP TiDB, WeChat PaxosStore…
<ul>
<li>Span over multiple continents（跨越多个大陆）</li>
<li>Use Paxos or Raft as a building block（使用 Paxos 或 Raft
作为构建模块）</li>
</ul></li>
</ul>
<p><img src="image-92.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>Scalability, availability and high
performance（可扩展性，可用性和高性能）</li>
<li>Each tablet is managed by a Paxos group（每个平板由一个 Paxos
组管理）
<ul>
<li>Tablet: a bag of (key:string, timestamp:int64) <span class="math inline">\(\rightarrow\)</span> string</li>
<li>3 to 5 replicas（3 到 5 个副本）</li>
<li>Data placement can be specified（可以指定数据放置）
<ul>
<li>May across continents（可能跨越多个大陆）</li>
</ul></li>
</ul></li>
<li>Among tablets, using two-phase commit for
ACID（在平板之间，使用两阶段提交实现 ACID）
<ul>
<li>Atomicity, Consistency, Isolation and
Durability（原子性，一致性，隔离性和持久性）</li>
</ul></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/SJTU-Notes/" class="category-chain-item">SJTU Notes</a>
  
  
    <span>></span>
    
  <a href="/categories/SJTU-Notes/%E8%AE%A1%E7%A7%91/" class="category-chain-item">计科</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/SJTU/" class="print-no-link">#SJTU</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>算法计算复杂度分析</div>
      <div>https://youyeyejie.github.io/_posts/算法计算复杂度分析/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>youyeyejie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2026年1月11日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2026年2月8日</div>
        </div>
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/_posts/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%9A%90%E7%A7%81%E6%94%BB%E5%87%BB%E4%B9%8B%E6%88%90%E5%91%98%E6%8E%A8%E7%90%86%E6%94%BB%E5%87%BB%E5%88%9D%E6%8E%A2/" title="大模型隐私攻击之成员推理攻击初探">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">大模型隐私攻击之成员推理攻击初探</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/_posts/Fluid%E6%96%B0%E5%A2%9E%E5%8F%B3%E9%94%AE%E5%8A%9F%E8%83%BD/" title="Fluid新增右键功能">
                        <span class="hidden-mobile">Fluid新增右键功能</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"youyeyejie/youyeyejie.github.io","repo-id":"R_kgDOO-Uo1g","category":"General","category-id":"DIC_kwDOO-Uo1s4Crz5J","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>







  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>
<div class="footer-inner">
    <div class="powered-by">
        <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
        <i class="iconfont icon-love"></i>
        <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
        <i class="iconfont icon-love"></i>
        <a href="https://cloud.umami.is/share/1fs3cnD9TAP8JzML" target="_blank" rel="nofollow noopener"><span>Umami</span></a>
    </div>
    <div class="hitokoto">
        <i class="fas fa-quote-left"></i>
        <a target="_blank" rel="noopener" href="https://developer.hitokoto.cn/" id="hitokoto_text"><span id="hitokoto">且以群词 注解我这座荒山</span></a>
        <script src="/js/Hitokoto.js" defer></script>
    </div>
    <div class="data">
        <span class="total-word-container">
            <i class="fas fa-chart-bar"></i>
            <span id="g-total-word-id"></span>
            字汇长河
        </span>
        &nbsp;
        <span id="total-posts-container">
            <i class="fas fa-file-alt"></i>
            <span id="g-total-posts-id"></span>
            文舟靠岸
        </span>
        &nbsp;
        <span id="busuanzi_container_site_pv">
            <i class="fas fa-eye"></i>
            <span id="busuanzi_value_site_pv">1314</span>
            目光所及
        </span>
        &nbsp;
        <span id="busuanzi_container_site_uv">
            <i class="fas fa-user-friends"></i>
            <span id="busuanzi_value_site_uv">520</span>
            访客驻足
        </span>
    </div>
    <div class="duration">
        <i class="fas fa-calendar"></i>
        <span id="duration-container">人生缓缓&nbsp;自有答案</span>
        <script src="/js/Duration.js"></script>
    </div>
</div>

<link href="/css/Footer.css" type="text/css" rel="stylesheet"/>
<script>
    document.querySelectorAll("[id^='busuanzi_value_']").forEach(element => {
        element.id = element.id.replace("busuanzi_value_", "vercount_value_");
    });
</script>
<script defer src="https://events.vercount.one/js"></script>
<!-- <script src="https://npm.elemecdn.com/penndu@1.0.0/bsz.js" defer></script> -->
<!-- <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script> -->
<!-- <script async src="https://busuanzi.icodeq.com/busuanzi.pure.mini.js"></script> -->
<!-- <script async src="https://busuanzi.sukap.cn/busuanzi.pure.mini.js"></script> -->
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/busuanzi.pure.mini.js" ></script>




  
<script src="/js/Crypto.js"></script>
<script src="/js/LinkCard.js"></script>
<script src="/js/RandomBanner.js"></script>
<script src="/js/Background.js"></script>
<script src="/js/ScrollAnimation.js"></script>
<script src="/js/TabDisplay.js"></script>
<script src="/js/Tooltip.js"></script>
<script src="/js/Umami.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  <script type="text/javascript">
  document.getElementById("g-total-word-id").innerHTML = "692k";
  document.getElementById('g-total-posts-id').textContent ="71";
</script>

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start -->
<script src="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.js"></script>

  <script>
  const CODE_CONFIG = {
    beautify: true,
    highlightCopy: true,
    highlightLang: true,
    highlightHeightLimit: 360,
    isHighlightShrink: false,
    copy: {
      success: 'Copy Success',
      error: 'Copy Error',
      noSupport: 'Browser Not Support',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body>
</html>
