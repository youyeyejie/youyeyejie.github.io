

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><!-- hexo injector head_begin start --><meta name="msvalidate.01" content="DF9F232801BA9D0CABB002E4774A3228" />
<meta name="google-site-verification" content="vOm5Zs9tuUlEh-wVBlpvs_spnOou-q2CoTiFQ1ZV1h4" />
<script defer src="https://cloud.umami.is/script.js" data-website-id="0369421f-4354-4d7b-99c7-ae077c591b4f"></script>
<!-- hexo injector head_begin end -->
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar/avatar2.webp">
  <link rel="icon" href="/img/avatar/avatar2.webp">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="youyeyejie">
  <meta name="keywords" content="yyyj,YYYJ,youyeyejie,有野野芥">
  
    <meta name="description" content="NIS2337 信息论基础 笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="信息论基础">
<meta property="og:url" content="https://youyeyejie.github.io/_posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="有野野芥的博客">
<meta property="og:description" content="NIS2337 信息论基础 笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youyeyejie.github.io/img/cover/nis2337.webp">
<meta property="article:published_time" content="2025-04-22T17:36:32.000Z">
<meta property="article:modified_time" content="2025-06-20T12:10:36.000Z">
<meta property="article:author" content="youyeyejie">
<meta property="article:tag" content="SJTU">
<meta property="article:tag" content="信息论">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://youyeyejie.github.io/img/cover/nis2337.webp">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>信息论基础 - 有野野芥的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">
<link rel="stylesheet" href="//lib.baomitu.com/font-awesome/6.1.2/css/all.min.css">


<link  rel="stylesheet" href="/css/main.css" />




  
<link rel="stylesheet" href="/css/Background.css">
<link rel="stylesheet" href="/css/CodeBlock.css">
<link rel="stylesheet" href="/css/CodeInLine.css">
<link rel="stylesheet" href="/css/FrostedGlassBg.css">
<link rel="stylesheet" href="/css/Gallery.css">
<link rel="stylesheet" href="/css/IndexImgHover.css">
<link rel="stylesheet" href="/css/LinkCard.css">
<link rel="stylesheet" href="/css/ScrollAnimation.css">
<link rel="stylesheet" href="/css/ScrollBar.css">
<link rel="stylesheet" href="/css/Sidebar.css">
<link rel="stylesheet" href="/css/StrongInDark.css">
<link rel="stylesheet" href="/css/TitleGradient.css">
<link rel="stylesheet" href="/css/UnifyImgWidth.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"youyeyejie.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":false,"default":"TEXT"},"copy_btn":false,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading/loading3.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style>
    <style>
    .code-expand-btn:not(.expand-done) ~ div.codeblock,
    .code-expand-btn:not(.expand-done) ~ * div.codeblock {
      overflow: hidden;
      height: 360px;
    }
    </style>
  <!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><!-- hexo injector body_begin end -->
  <div id="loader-container"> 
    <div id="loader" class="loader"></div>
    <div class="loader-inner">
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
    </div>
</div>

<script src="/js/RainbowLoading.js" type="text/javascript"></script>
<link href="/css/RainbowLoading.css" type="text/css" rel="stylesheet"/><div id="tooltip-rightmenu" class="tooltip-rightmenu">如需原始右键菜单请按下 <strong>Ctrl+右键</strong></div>
<div id="tooltip-rightmenu-return" class="tooltip-rightmenu"></div>

<div id="rightmenu-wrapper">
  <ul class="list-v rightmenu" id="rightmenu-content">
	    <li class="navigation menuNavigation-Content">
            <a class="nav icon-only fix-cursor-default" aria-label="back" onclick="history.back()"><i class="fa-solid fa-chevron-left"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="forward" onclick="history.forward()"><i class="fa-solid fa-chevron-right"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="reload" onclick="window.location.reload()"><i class="fa-solid fa-rotate-right"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="top" onclick="scrollToTopSmooth();"><i class="fa-solid fa-chevron-up"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="bottom" onclick="scrollToBottomSmooth();"><i class="fa-solid fa-chevron-down"></i></a>
	    </li>

        <hr class="menuLoad-Content" style="display: block;" id="top-line" hidden>

        <li class="menuLoad-Content" style="display: block;" id="copy-selected-text" hidden>
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="copySelectedText();">
                <span>
                    <i class="fa-solid fa-copy"></i>
                    &nbsp;复制选中
                </span>
            </a>
        </li>

        <li class="menuLoad-Content" style="display: block;" id="search-selected-text-BING" hidden>
            <a class="vlts-menu fix-cursor-default" target="_blank" onclick="searchSelectedTextBing();">
                <span>
                    <i class="fa-solid fa-magnifying-glass-arrow-right"></i>
                    &nbsp;必应搜索
                </span>
            </a>
        </li>

        <li class="menuLoad-Content" style="display: block;" id="go-to-link" hidden>
            <a class="vlts-menu fix-cursor-default" target="_blank">
                <span>
                    <i class="fa-solid fa-arrow-up-right-from-square"></i>
                    &nbsp;转到链接
                </span>
            </a>
        </li>

        <li class="menuLoad-Content" style="display: block;" id="download-image" hidden>
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="downloadImage();">
                <span>
                    <i class="fa-solid fa-image"></i>
                    &nbsp;下载图片
                </span>
            </a>
        </li>

        <li class="menuLoad-Content" style="display: block;" id="copy-image-link" hidden>
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="copyImageLink();">
                <span>
                    <i class="fa-solid fa-link"></i>
                    复制图片链接
                </span>
            </a>
        </li>

		<hr class="menuLoad-Content" style="display: block;">

        <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" onclick="RandomGo()">
		        <span>
			        <i class="fa-solid fa-paper-plane"></i>
                    &nbsp;随便看看
		        </span>
		    </a>
	    </li>
	    <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
		        <span>
			        <i class="fa-solid fa-magnifying-glass"></i>
                    &nbsp;站内搜索
		        </span>
		    </a>
	    </li>
        <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" href="/categories/">
		        <span>
			        <i class="iconfont icon-category-fill"></i>
                    &nbsp;博客分类
		        </span>
		    </a>
	    </li>
        <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" href="/tags/">
		        <span>
			        <i class="fa-solid fa-tags"></i>
                    &nbsp;文章标签
		        </span>
		    </a>
	    </li>
        
	    <hr class="menuLoad-Content" style="display: block;">

        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="copyLink();">
                <span>
                    <i class="fa-solid fa-copy"></i>
                    &nbsp;复制链接
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="toggleDarkNightMode();">
            <span>
                <i id="toggle-dark-night-icon" class="fa-solid fa-moon"></i>
                &nbsp;切换昼夜
            </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="toggleDynamicLine();">
            <span>
                <i id="toggle-dynamic-line-icon" class="fa-solid fa-toggle-off"></i>
                &nbsp;线条动画
            </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="toggleBackgroundScript();">
            <span>
                <i id="toggle-background-script-icon" class="fa-solid fa-toggle-on"></i>
                &nbsp;全屏背景
            </span>
            </a>
        </li>
    </ul>
</div>


<script src="/js/RightMenu.js" type="text/javascript"></script>
<link href="/css/RightMenu.css" type="text/css" rel="stylesheet"/>

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <!-- <strong>YYYJ&#39;s Blog</strong> -->
       <strong class="navbar-title">YYYJ&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://www.travellings.cn/go-by-clouds.html" target="_self">
                <i class="fas fa-train-subway"></i>
                <span>开往</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="fa-solid fa-folder-open"></i>
                <span>更多</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/" target="_self">
                    <i class="iconfont icon-archive-fill"></i>
                    <span>归档</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/" target="_self">
                    <i class="fa-solid fa-tags"></i>
                    <span>标签</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/links/" target="_self">
                    <i class="iconfont icon-link-fill"></i>
                    <span>友链</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/DayDream-Gallery/" target="_self">
                    <i class="fas fa-images"></i>
                    <span>图集</span>
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner/random.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="信息论基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        youyeyejie
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-04-23 01:36" pubdate>
          2025年4月23日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          51k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          424 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="SJTU Notes"
        id="heading-23fc8849f7fe9b9a570be52f7807b4ac" role="tab" data-toggle="collapse" href="#collapse-23fc8849f7fe9b9a570be52f7807b4ac"
        aria-expanded="true"
      >
        SJTU Notes
        <span class="list-group-count">(20)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-23fc8849f7fe9b9a570be52f7807b4ac"
           role="tabpanel" aria-labelledby="heading-23fc8849f7fe9b9a570be52f7807b4ac">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="信安"
        id="heading-cffe32285a0c065bb2a100ac3411f2b7" role="tab" data-toggle="collapse" href="#collapse-cffe32285a0c065bb2a100ac3411f2b7"
        aria-expanded="false"
      >
        信安
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-cffe32285a0c065bb2a100ac3411f2b7"
           role="tabpanel" aria-labelledby="heading-cffe32285a0c065bb2a100ac3411f2b7">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/" title="抽象代数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">抽象代数</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/" title="现代密码学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">现代密码学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" title="系统安全"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">系统安全</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/" title="网络空间安全导论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">网络空间安全导论</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="其他"
        id="heading-0d98c74797e49d00bcc4c17c9d557a2b" role="tab" data-toggle="collapse" href="#collapse-0d98c74797e49d00bcc4c17c9d557a2b"
        aria-expanded="false"
      >
        其他
        <span class="list-group-count">(3)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-0d98c74797e49d00bcc4c17c9d557a2b"
           role="tabpanel" aria-labelledby="heading-0d98c74797e49d00bcc4c17c9d557a2b">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E5%86%9B%E4%BA%8B%E7%90%86%E8%AE%BA/" title="军事理论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">军事理论</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%95%B0%E5%AD%A6%E5%8F%B2/" title="数学史"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数学史</span>
        </a>
      
    
      
      
        <a href="/_posts/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/" title="量子力学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">量子力学</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="数学"
        id="heading-6e65831863dbf272b7a65cd8df1a440d" role="tab" data-toggle="collapse" href="#collapse-6e65831863dbf272b7a65cd8df1a440d"
        aria-expanded="true"
      >
        数学
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-6e65831863dbf272b7a65cd8df1a440d"
           role="tabpanel" aria-labelledby="heading-6e65831863dbf272b7a65cd8df1a440d">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="信息论基础"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">信息论基础</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/" title="抽象代数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">抽象代数</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/" title="概率统计"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">概率统计</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">离散数学</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="红课"
        id="heading-d8a06b9d7f3a9a1c8566414f651abd41" role="tab" data-toggle="collapse" href="#collapse-d8a06b9d7f3a9a1c8566414f651abd41"
        aria-expanded="false"
      >
        红课
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-d8a06b9d7f3a9a1c8566414f651abd41"
           role="tabpanel" aria-labelledby="heading-d8a06b9d7f3a9a1c8566414f651abd41">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/" title="中国近现代史纲要"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">中国近现代史纲要</span>
        </a>
      
    
      
      
        <a href="/_posts/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3%E6%A6%82%E8%AE%BA/" title="习近平新时代中国特色社会主义思想概论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">习近平新时代中国特色社会主义思想概论</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/" title="思想道德与法治"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">思想道德与法治</span>
        </a>
      
    
      
      
        <a href="/_posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="马克思主义基本原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">马克思主义基本原理</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="计科"
        id="heading-d693442450db119d90f9261fa53eb2f7" role="tab" data-toggle="collapse" href="#collapse-d693442450db119d90f9261fa53eb2f7"
        aria-expanded="true"
      >
        计科
        <span class="list-group-count">(8)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-d693442450db119d90f9261fa53eb2f7"
           role="tabpanel" aria-labelledby="heading-d693442450db119d90f9261fa53eb2f7">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="信息论基础"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">信息论基础</span>
        </a>
      
    
      
      
        <a href="/_posts/%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E5%8F%8A%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/" title="安全模型开发及安全编程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">安全模型开发及安全编程</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="操作系统原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统原理</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E5%85%A8/" title="数据库原理及安全"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数据库原理及安全</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数据结构</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">离散数学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">编译原理</span>
        </a>
      
    
      
      
        <a href="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" title="计算机组成与系统结构"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">计算机组成与系统结构</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">信息论基础</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>本笔记基于上海交通大学 <em>唐俊华老师</em> 2024-2025
学年春季学期教学内容进行整理，部分图片来自唐老师的笔记，若有侵权请联系删除。</p>
</blockquote>
<h1 id="第一章-绪论">第一章 绪论</h1>
<h2 id="信息理论研究内容">信息理论研究内容</h2>
<ul>
<li>狭义信息论：香农信息论</li>
<li>一般信息论：香农+维纳</li>
<li>广义信息论</li>
</ul>
<h2 id="信息消息信号">信息、消息、信号</h2>
<ul>
<li><strong>信息</strong>：指各个事物运动的状态及状态变化的方式。信息是抽象的意识或知识，它是看不见、摸不到的。当由人脑的思维活动产生的一种想法仍被存储在脑子里时，它就是一种信息。
<ul>
<li>特征：
<ol type="1">
<li>接收者在收到信息之前，对其内容是未知的，所以信息是新知识、新内容；</li>
<li>信息是能使认识主体对某一事物的未知性或不确定性减少的有用知识；</li>
<li>信息可以产生，也可以消失，同时信息可以被携带、存储及处理；</li>
<li>信息是可以量度的，信息量有多少的差别。</li>
</ol></li>
</ul></li>
<li><strong>消息</strong>：指包含信息的语言、文字和图像等。在通信中，消息是指担负着传送信息任务的单个符号或符号序列。这些符号包括字母、文字、数字和语言等。</li>
<li><strong>信号</strong>：消息的物理体现，为了在信道上传输消息，就必须把消息加载（调制）到具有某种物理特征的信号上去。信号是信息的载荷子或载体，是物理性的，如电信号、光信号等。</li>
</ul>
<h2 id="通信系统模型">通信系统模型</h2>
<figure>
<img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="通信系统模型">
<figcaption aria-hidden="true">通信系统模型</figcaption>
</figure>
<h1 id="第二章-信源与信息熵">第二章 信源与信息熵</h1>
<h2 id="信源的分类及数学模型">2.1 信源的分类及数学模型</h2>
<figure>
<img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="信源分类">
<figcaption aria-hidden="true">信源分类</figcaption>
</figure>
<h3 id="无记忆的单符号">无记忆的单符号</h3>
<ul>
<li><strong>离散</strong>
<ul>
<li><p>信源输出单个符号的消息，出现的消息数是有限的，且只可能是符号集中的一种</p></li>
<li><p>各符号出现的概率与信源相互确定</p></li>
<li><p><strong>数学表示</strong>： <span class="math display">\[
  \begin{bmatrix} X \\ P \end{bmatrix} =
  \begin{bmatrix} a_1 &amp; a_2 &amp; \cdots &amp; a_n \\ p(a_1) &amp;
p(a_2) &amp; \cdots &amp; p(a_n) \end{bmatrix}
  \]</span></p>
<p>其中符号集 <span class="math inline">\(A = \{a_1, a_2, \cdots,
a_n\}\)</span>，<span class="math inline">\(X \in A\)</span>。显然有
<span class="math inline">\(p(a_i) \geq 0\)</span>，<span class="math inline">\(\sum_{i = 1}^{n} p(a_i) = 1\)</span>。</p></li>
</ul></li>
<li><strong>连续</strong>
<ul>
<li><p>信源输出单个符号的消息，出现的消息数是无限的</p></li>
<li><p><strong>数学表示</strong>： <span class="math display">\[
  \begin{bmatrix} X \\ P \end{bmatrix} =
  \begin{bmatrix} (a,b) \\ p_X(x) \end{bmatrix}
  或
  \begin{bmatrix} R \\p_X(x) \end{bmatrix}
  \]</span></p>
<p>显然应满足 <span class="math inline">\(p_X(x) \geq 0\)</span>，<span class="math inline">\(\int_{a}^{b} p_X(x) \mathrm{d}x = 1\)</span> 或
<span class="math inline">\(\int_{R} p_X(x) \mathrm{d}x =
1\)</span>。</p></li>
</ul></li>
</ul>
<h3 id="无记忆的符号序列">无记忆的符号序列</h3>
<ul>
<li><p>每次发出一组含2个以上符号的符号序列来代表一个消息</p></li>
<li><p>需要用随机序列（或随机矢量）<span class="math inline">\(\mathbf{X}=(X_1,X_2,\cdots,X_l,\cdots,X_L)\)</span>来描述信源输出的消息，用联合概率分布来表示信源特性。</p></li>
<li><p>最简单的符号序列信源是<span class="math inline">\(L\)</span>为2的情况，此时信源<span class="math inline">\(\mathbf{X}=(X_1,X_2)\)</span>，其信源的概率空间为：
<span class="math display">\[
  \begin{bmatrix} \mathbf{X} \\ P \end{bmatrix} =
  \begin{bmatrix} a_1,a_1 &amp; a_1,a_2 &amp; \cdots &amp; a_n,a_n \\
p(a_1,a_1) &amp; p(a_1,a_2) &amp; \cdots &amp; p(a_n,a_n) \end{bmatrix}
\quad
  \]</span></p>
<p>显然有 <span class="math inline">\(p(a_i,a_j)\geq0\)</span>，<span class="math inline">\(\sum_{i,j = 1}^{n} p(a_i,a_j) =
1\)</span>。</p></li>
<li><p><strong><em>无记忆</em></strong></p>
<ul>
<li>符号序列的各维相独立（<strong>有放回取球</strong>）</li>
<li><span class="math inline">\(p(X_1,X_2,\cdots,X_l,\cdots,X_L) =
p(X_1)p(X_2)\cdots p(X_l)\cdots p(X_L)\)</span></li>
</ul></li>
<li><p><strong><em>平稳</em></strong></p>
<ul>
<li>信源发出的序列的统计性质与时间的推移无关，是平稳的随机序列。</li>
<li>强：信源输出序列的各维概率分布都不随时间推移而发生变化</li>
<li>弱：信源输出序列的均值与起始时刻无关、协方差函数也与起始时刻无关而仅与时间间隔有关</li>
</ul></li>
<li><p><strong><em>独立同分布(i.i.d.)</em></strong></p>
<ul>
<li>离散、平稳、无记忆、具有相同概率空间</li>
<li><span class="math inline">\(p(X_1)=p(X_2)=\cdots =p(X_l)=\cdots
=p(X_L)\)</span></li>
<li><span class="math inline">\(p(X_1,X_2,\cdots,X_L)=\prod_{l =
1}^{L}p(X_l)=[p(X)]^L\)</span></li>
<li>其中 <span class="math inline">\(X \in A = \{a_1, a_2, \cdots,
a_n\}\)</span>，<span class="math inline">\(\mathbf{X}\)</span>有<span class="math inline">\(n^L\)</span>种可能性，<span class="math inline">\(\sum_{i = 1}^{n^L} p(\mathbf{X}=\mathbf{X_i}) =
1\)</span>。</li>
</ul></li>
</ul>
<h3 id="有记忆的符号序列">有记忆的符号序列</h3>
<ul>
<li>信源在不同时刻发出的符号之间是相互依赖的。（<strong>不放回取球</strong>）
<span class="math display">\[
  \begin{align*}
  p(x_1,x_2,x_3,\cdots,x_L)&amp;=p(x_L\mid x_1,x_2,x_3,\cdots,x_{L -
1})p(x_1,x_2,x_3,\cdots,x_{L - 1})\\
  &amp;=\cdots\\
  &amp;=p(x_1)p(x_2|x_1)p(x_3|x_2,x_1)\cdots p(x_L|x_{L-1},\cdots, x_1)
  \end{align*}
  \]</span></li>
<li>表述的复杂度将随着序列长度的增加而增加。</li>
</ul>
<h4 id="马尔可夫信源">马尔可夫信源</h4>
<ul>
<li><strong>m阶马尔可夫信源</strong>
<ul>
<li>当信源的记忆长度为<span class="math inline">\(m+1\)</span>时，该时刻发出的符号与前m个符号有关联性，而与更前面的符号无关
<span class="math display">\[
  \begin{align*}
  p(x_1,x_2,x_3,\cdots,x_L)&amp;=p(x_L\mid x_1,x_2,x_3,\cdots,x_{L -
1})p(x_1,x_2,x_3,\cdots,x_{L - 1})\\
  &amp;=p(x_L\mid x_{L - m},\cdots,x_{L - 1})p(x_1,x_2,x_3,\cdots,x_{L -
1})\\
  &amp;=p(x_L\mid x_{L - m},\cdots,x_{L - 1})p(x_{L - 1}\mid x_{L - m -
1},\cdots,x_{L - 2})p(x_1,x_2,x_3,\cdots,x_{L - 2})\\
  &amp;=\cdots
  \end{align*}
  \]</span></li>
<li>若<span class="math inline">\(m=1\)</span>，则称为<strong>一阶马尔可夫信源</strong>，有：
<span class="math display">\[
  p(x_1,x_2,x_3,\cdots,x_L)=p(x_L\mid x_{L - 1})p(x_{L - 1}\mid x_{L -
2})\cdots p(x_2\mid x_1)p(x_1)
  \]</span></li>
<li><strong>齐次马尔可夫信源</strong>：条件概率与时间起点无关</li>
</ul></li>
<li><strong>状态<span class="math inline">\(s_i\)</span></strong>
<ul>
<li>对于 <span class="math inline">\(m\)</span>
阶马尔可夫信源，将该时刻以前出现的 <span class="math inline">\(m\)</span> 个符号组成的序列定义为状态 <span class="math inline">\(s_i\)</span></li>
<li><span class="math inline">\(s_i=(x_{i_1},x_{i_2},\cdots,x_{i_m})\quad
x_{i_1},x_{i_2},\cdots,x_{i_m}\in A=(a_1,a_2,\cdots,a_n)\)</span></li>
<li><span class="math inline">\(s_i\)</span> 共有 <span class="math inline">\(Q = n^m\)</span> 种可能取值，即状态集 <span class="math inline">\(S = \{s_1,s_2,\cdots,s_Q\}\)</span></li>
<li>则有： <span class="math display">\[p(x_j\mid x_{j - m},\cdots,x_{j
- 1}) = p(x_j\mid s_i)\quad i = 1,2,\cdots,Q, j =
1,2,\cdots,n\]</span></li>
</ul></li>
<li><strong>状态转移概率</strong>
<ul>
<li>在时刻 <span class="math inline">\(m\)</span> 系统处于状态 <span class="math inline">\(s_i\)</span>（即 <span class="math inline">\(S_m=s_i\)</span>）的条件下，经 <span class="math inline">\(n - m\)</span> 步后转移到状态 <span class="math inline">\(s_j\)</span> （即 <span class="math inline">\(S_n=s_j\)</span>）的概率用状态转移概率 <span class="math inline">\(p_{ij}(m,n)\)</span> 表示：</li>
<li><span class="math display">\[
  p_{ij}(m,n)=P\{S_n = s_j\mid S_m = s_i\}=P\{s_j\mid s_i\}\quad
s_i,s_j\in S
  \]</span></li>
<li>性质：
<ol type="1">
<li><span class="math inline">\(p_{ij}(m,n)\geq0\)</span>，<span class="math inline">\(i,j\in S\)</span></li>
<li><span class="math inline">\(\sum_{j\in
S}p_{ij}(m,n)=1\)</span>，<span class="math inline">\(i\in
S\)</span></li>
</ol></li>
</ul></li>
<li><strong>状态转移矩阵</strong>
<ul>
<li>一步转移矩阵<span class="math inline">\(\mathbf{P}=\{p_{ij},i,j\in
S\}\)</span> <span class="math display">\[
  \mathbf{P}=
  \begin{bmatrix}
  p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1Q} \\
  p_{21} &amp; p_{22} &amp; \cdots &amp; p_{2Q} \\
  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
  p_{Q1} &amp; p_{Q2} &amp; \cdots &amp; p_{QQ}
  \end{bmatrix}
  \]</span></li>
<li>k步转移矩阵<span class="math inline">\(\mathbf{P}=\{p_{ij}^{(k)}(m),i,j\in
S\}\)</span></li>
</ul></li>
<li><strong>状态图</strong>
<ul>
<li>状态转移图/马尔科夫状态图/香农线图</li>
<li>元素
<ul>
<li>圆圈：状态<span class="math inline">\(S_i\)</span></li>
<li>箭头：转移</li>
<li>箭头旁标数字：转移概率</li>
</ul></li>
</ul></li>
<li><strong>一步转移概率</strong>
<ul>
<li><span class="math inline">\(n - m = 1\)</span>时，即 <span class="math inline">\(p_{ij}(t,t + 1)\)</span>，记为 <span class="math inline">\(p_{ij}(t)\)</span>，<span class="math inline">\(t\geq0\)</span>，并称为基本转移概率，也可称为一步转移概率。</li>
<li><span class="math display">\[
  p_{ij}(t)=p_{ij}(t,t + 1)=P\{S_{t + 1}=j\mid S_t =
i\}\overset{齐次}{=}p_{ij}\quad i,j\in S
  \]</span></li>
<li>性质：
<ol type="1">
<li><span class="math inline">\(p_{ij}\geq0\)</span>，<span class="math inline">\(i,j\in S\)</span></li>
<li><span class="math inline">\(\sum_{j\in S}p_{ij}=1\)</span>，<span class="math inline">\(i\in S\)</span></li>
</ol></li>
</ul></li>
<li><strong>k步转移概率</strong>
<ul>
<li><p><span class="math display">\[
  p_{ij}^{(k)}(t)=p_{ij}(t,t + k)=P\{S_{t + k}=j\mid S_t =
i\}\overset{齐次}{=}p_{ij}^{(k)}\quad i,j\in S
  \]</span></p></li>
<li><p>切普曼 - 柯尔莫戈洛夫方程： <span class="math display">\[
  p_{ij}^{(k)}=\sum_{r}p_{ir}^{(l)}p_{rj}^{(k - l)} \quad l &lt; k
  \]</span></p>
<p>特别地，当 <span class="math inline">\(l = 1\)</span> 时，有 <span class="math display">\[
  p_{ij}^{(k)}=\sum_{r}p_{ir}p_{rj}^{(k - 1)}=\sum_{r}p_{ir}^{(k -
1)}p_{rj}=p_{ij}^{k}
  \]</span></p></li>
<li><p>若用矩阵表示，则 <span class="math display">\[
  \mathbf{P}^{(k)}=\mathbf{P}\mathbf{P}^{(k -
1)}=\mathbf{P}\mathbf{P}\mathbf{P}^{(k - 2)}=\cdots=\mathbf{P}^{k}
  \]</span></p>
<p>其中 <span class="math inline">\(\mathbf{P}^{(k)}=\{p_{ij}^{(k)}\}\)</span>为k步转移概率矩阵，<span class="math inline">\(\mathbf{P}^{k}\)</span>
为一步转移矩阵的k次方。</p></li>
<li><p>对于齐次马尔可夫链，一步转移概率完全决定了k步转移概率，引入初始概率<span class="math inline">\(p_{0i}=P(S_{0}=s_{i})\)</span> <span class="math display">\[
  \begin{align*}
  P(S_{k}=s_{j})&amp;=\sum_{i}P(S_{k}=s_{j},S_{0}=s_{i})\\
  &amp;=\sum_{i}P(S_{0}=s_{i})P(S_{k}=s_{j}\mid S_{0}=s_{i})\\
  &amp;=\sum_{i}p_{0i}p_{ij}^{(k)}
  \end{align*}
  \]</span></p></li>
</ul></li>
<li><strong>马尔可夫链的稳定(稳态分布)</strong>
<ul>
<li><p><strong>定义</strong>：<span class="math inline">\(\lim_{k \to
\infty}p_{ij}^{(k)} = W_j =
P(S_k=s_j)\)</span>，信源达到稳定状态，所有变量<span class="math inline">\(x_k\)</span>的概率分布不变</p></li>
<li><p><strong>求取</strong>： <span class="math display">\[
  \left\{
  \begin{array}{l}
  \mathbb{W}\mathbf{P}=\mathbb{W}\\
  \sum_{i}W_j = 1
  \end{array}
  \right.
  \]</span></p>
<p>其中<span class="math inline">\(\mathbb{W}=\begin{bmatrix} W_1 &amp;
W_2 &amp; \cdots &amp; W_Q \end{bmatrix}\)</span>，<span class="math inline">\(W_j = \lim_{k \to \infty}p_{ij}^{(k)} =
P(S_k=s_j)\)</span></p></li>
<li><p><strong>条件</strong></p>
<ul>
<li>必要不充分：上式有唯一解，则<span class="math inline">\(\lim_{k \to
\infty}p_{ij}^{(k)}\)</span> 存在</li>
<li><strong>不可约性</strong>
<ul>
<li>对任意一对 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>，都存在至少一个 <span class="math inline">\(k\)</span>，使 <span class="math inline">\(p_{ij}^{(k)}&gt;0\)</span>，这就是说从 <span class="math inline">\(s_i\)</span> 开始，总有可能到达 <span class="math inline">\(s_j\)</span></li>
<li>反之若对所有 <span class="math inline">\(k\)</span>，<span class="math inline">\(p_{ij}^{(k)} = 0\)</span>，就意味着一旦出现 <span class="math inline">\(s_i\)</span> 以后不可能到达 <span class="math inline">\(s_j\)</span>，也就是不能各态遍历
<ul>
<li>此时状态中把 <span class="math inline">\(s_j\)</span>
取消就成为可约的了</li>
</ul></li>
</ul></li>
<li><strong>非周期性</strong>
<ul>
<li>在所有 <span class="math inline">\(p_{ii}^{(n)}&gt;0\)</span> 的
<span class="math inline">\(n\)</span> 中没有比 1 大的公因子，即从<span class="math inline">\(s_i\)</span>出发回到<span class="math inline">\(s_i\)</span>的步数没有大于 1 的公因子</li>
</ul></li>
</ul></li>
<li><p><strong>例题</strong>：</p>
<ul>
<li><figure>
<img src="image-104.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题">
<figcaption aria-hidden="true">例题</figcaption>
</figure></li>
<li><figure>
<img src="image-105.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题">
<figcaption aria-hidden="true">例题</figcaption>
</figure></li>
<li><figure>
<img src="image-106.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题">
<figcaption aria-hidden="true">例题</figcaption>
</figure></li>
</ul></li>
</ul></li>
</ul>
<h3 id="时间连续幅度连续的模拟信号随机波形信源">时间连续、幅度连续的模拟信号（随机波形信源）</h3>
<ul>
<li>例如语音、图像，可看作随机过程<span class="math inline">\(x(t)\)</span> 。</li>
<li>通过采样、量化，可将其转换为时间离散、幅度离散的符号序列。</li>
<li>假设<span class="math inline">\(x(t)\)</span>频带受限，<span class="math inline">\(f_m\)</span>为最高频率，根据采样定理，<strong>不失真采样频率</strong><span class="math inline">\(f_s\geq2f_m\)</span> 。若时间受限为<span class="math inline">\(t_B\)</span> ，则<strong>采样点数</strong>为<span class="math inline">\(2f_mt_B = L\)</span>（形成长度为<span class="math inline">\(L\)</span>的符号序列）。</li>
<li>一般情况下，<span class="math inline">\(L =
2f_mt_B\)</span>维连续型随机序列是有记忆的。</li>
</ul>
<h2 id="离散信源熵和互信息">2.2 离散信源熵和互信息</h2>
<h3 id="自信息量">自信息量</h3>
<ul>
<li><p>信源 <span class="math inline">\(X\)</span>，概率空间 <span class="math display">\[\begin{bmatrix} X \\ p \end{bmatrix}=
\begin{bmatrix} x_1 &amp; x_2 &amp; \cdots &amp; x_n \\ p(x_1) &amp;
p(x_2) &amp; \cdots &amp; p(x_n) \end{bmatrix}\]</span></p></li>
<li><p>定义具有概率 <span class="math inline">\(p(x_i)\)</span> 的符号
<span class="math inline">\(x_i\)</span> 的自信息量为 <span class="math display">\[I(x_i)=-\log
p(x_i)=\log\frac{1}{p(x_i)}\]</span></p>
<ul>
<li>底数为 <span class="math inline">\(2\)</span>，信息量单位比特（bit）</li>
<li>底数为自然常数 <span class="math inline">\(e\)</span>，单位为奈特（nat）</li>
<li>底数为 <span class="math inline">\(10\)</span>，单位为笛特（det）
<ul>
<li><span class="math inline">\(1\text{nat}=\log_2 e\approx
1.433\text{bit}\)</span></li>
<li><span class="math inline">\(1\text{det}=\log_2 10\approx
3.322\text{bit}\)</span></li>
</ul></li>
<li>性质：
<ol type="1">
<li><span class="math inline">\(p(x_i)=1\)</span>，<span class="math inline">\(I(x_i)=0\)</span></li>
<li><span class="math inline">\(p(x_i)=0\)</span>，<span class="math inline">\(I(x_i)=\infty\)</span></li>
<li>非负性：<span class="math inline">\(I(x_i)\geq0\)</span></li>
<li>单调递减性：若 <span class="math inline">\(p(x_2)&gt;p(x_1)\)</span>
则 <span class="math inline">\(I(x_2) &lt; I(x_1)\)</span></li>
<li>可加性：
<ul>
<li>两符号 <span class="math inline">\(x_i,y_j\)</span> 同时出现，<span class="math inline">\(I(x_i,y_j)=-\log p(x_i,y_j)\)</span></li>
<li><span class="math inline">\(x_i,y_j\)</span> 相互独立，<span class="math inline">\(p(x_i,y_j)=p(x_i)p(y_j)\)</span>
<ul>
<li><span class="math inline">\(I(x_i,y_j)=-\log
p(x_i)p(y_j)=I(x_i)+I(y_j)\)</span></li>
</ul></li>
<li><span class="math inline">\(x_i,y_j\)</span>
不独立，定义<strong>条件自信息量</strong> <span class="math inline">\(I(x_i|y_j)=-\log p(x_i|y_j)\)</span>
<ul>
<li><span class="math inline">\(p(x_i,y_j)=p(x_i)p(y_j|x_i)=p(y_j)p(x_i|y_j)\)</span></li>
<li><span class="math inline">\(I(x_i,y_j)=I(x_i)+I(y_j|x_i)=I(y_j)+I(x_i|y_j)\)</span></li>
</ul></li>
</ul></li>
</ol></li>
<li>单位：bit</li>
</ul></li>
<li><p>示例：<img src="image-107.webp" srcset="/img/loading/loading3.gif" lazyload alt="示例"></p></li>
<li><p><strong>自信息量与信源符号不确定度</strong></p>
<ul>
<li>自信息量：符号出现后，提供给收信者的信息量，<strong>是接收者获得的</strong>。</li>
<li>信源符号不确定度：具有某种概率的信源符号在发出之前，存在不确定度，不确定度表征了该符号的特性，<strong>是信源本身固有的</strong>。</li>
<li><strong>二者在数量上相等</strong></li>
</ul></li>
</ul>
<h3 id="离散信源熵---熵的定义">离散信源熵 - 熵的定义</h3>
<ul>
<li><p>给定概率空间 <span class="math inline">\(\begin{bmatrix} X \\ p
\end{bmatrix}=
\begin{bmatrix} x_1 &amp; x_2 &amp; \cdots &amp; x_n \\ p(x_1) &amp;
p(x_2) &amp; \cdots &amp; p(x_n) \end{bmatrix}\)</span>，自信息量<span class="math inline">\(I(x_i)=-\log
p(x_i)=\log\frac{1}{p(x_i)}\)</span></p></li>
<li><p><strong>信源 <span class="math inline">\(X\)</span> 的熵 <span class="math inline">\(H(X)\)</span> 定义为</strong>： <span class="math display">\[H(X)\overset{数量}{=}E[I(X)]=\sum_{i}
p(x_i)I(x_i)=-\sum_{i} p(x_i)\log p(x_i)\]</span> 信源 <span class="math inline">\(X\)</span>
的熵也被称为平均自信息量、总体平均不确定度。</p></li>
<li><p>性质：</p>
<ul>
<li><span class="math inline">\(H(X)\)</span> 非负，因为 <span class="math inline">\(0\leq p(x_i)\leq1\)</span>，<span class="math inline">\(\log p(x_i)\leq0\)</span>，所以 <span class="math inline">\(H(X)\geq0\)</span>。</li>
<li>若 <span class="math inline">\(p(x_i)=0\)</span>，规定 <span class="math inline">\(p(x_i)\log p(x_i)\)</span> 为 <span class="math inline">\(0\)</span>。</li>
<li>若 <span class="math inline">\(p(x_i)=1\)</span>，<span class="math inline">\(H(X) = 0\)</span>，即确定信源熵为 <span class="math inline">\(0\)</span>。</li>
</ul></li>
<li><p>单位：bit/符号</p></li>
<li><p>例题：<img src="image-109.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h4 id="二元信源">二元信源</h4>
<ul>
<li>二元信源概率空间 <span class="math inline">\(\begin{bmatrix} X \\ p
\end{bmatrix}=
\begin{bmatrix} 0 &amp; 1 \\ p &amp; q \end{bmatrix}\)</span>，其中
<span class="math inline">\(p + q=1\)</span></li>
<li>则 <span class="math inline">\(H(X)= -p\log p - q\log q=-p\log p -(1
- p)\log(1 - p)=H_2(p)=H(p)\)</span></li>
<li><figure>
<img src="image-108.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
<li>性质：
<ul>
<li>当 <span class="math inline">\(p = 1\)</span> 或 <span class="math inline">\(q = 1\)</span>（<span class="math inline">\(p =
0\)</span>）时，该信源不提供任何信息，即H(0)=0。</li>
<li>当 <span class="math inline">\(p=q=\frac{1}{2}\)</span>
时，符号等概率发生，熵最大，为 <span class="math inline">\(H(\frac{1}{2})=1\text{bit}/\text{符号}\)</span>。</li>
</ul></li>
</ul>
<h3 id="条件熵">条件熵</h3>
<ul>
<li><p>给定 <span class="math inline">\(y_j\)</span> 的条件下，<span class="math inline">\(x_i\)</span> 的<strong>条件自信息量</strong>为
<span class="math inline">\(I(x_i|y_j)=-\log
p(x_i|y_j)\)</span>，<strong><span class="math inline">\(X\)</span>
集合的条件熵 <span class="math inline">\(H(X|y_j)\)</span>定义为</strong>： <span class="math display">\[H(X|y_j)=\sum_{i}p(x_i|y_j)I(x_i|y_j)\]</span></p></li>
<li><p>给定 <span class="math inline">\(Y\)</span>（即各个 <span class="math inline">\(y_j\)</span>）条件下，<strong><span class="math inline">\(X\)</span> 集合的条件熵 <span class="math inline">\(H(X|Y)\)</span> 定义为</strong>： <span class="math display">\[H(X|Y)=-\sum_{ij}p(x_i,y_j)\log
p(x_i|y_j)\]</span> 即条件熵是联合符号集合 <span class="math inline">\((X,Y)\)</span>
上的条件自信息量的<strong>联合概率加权统计平均值</strong>。条件熵 <span class="math inline">\(H(X|Y)\)</span> 表示已知 <span class="math inline">\(Y\)</span> 后，<span class="math inline">\(X\)</span> 的不确定度。</p></li>
<li><p>推导： <span class="math display">\[
  \begin{align*}
  H(X|Y)&amp;=\sum_{j}p(y_j)H(X|y_j)\\
  &amp;=\sum_{j}p(y_j)\sum_{i}p(x_i|y_j)I(x_i|y_j)\\
  &amp;=\sum_{i}\sum_{j}p(y_j)p(x_i|y_j)I(x_i|y_j)\\
  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)I(x_i|y_j)\\
  &amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log p(x_i|y_j)
  \end{align*}
  \]</span></p></li>
<li><p><strong>同理</strong>，<span class="math display">\[H(Y|X)=\sum_{i}\sum_{j}p(x_i,y_j)I(y_j|x_i)=-\sum_{i}\sum_{j}p(x_i,y_j)\log
p(y_j|x_i)\]</span></p></li>
</ul>
<h3 id="联合熵">联合熵</h3>
<ul>
<li>联合熵是联合符号集合 <span class="math inline">\((X,Y)\)</span>
上的每个元素对 <span class="math inline">\((x_i,y_j)\)</span>
的自信息量的<strong>概率加权统计平均值</strong>，定义为：</li>
</ul>
<p><span class="math display">\[H(X,Y)=\sum_{i,j}p(x_i,y_j)I(x_i,y_j)=-\sum_{i,j}p(x_i,y_j)\log
p(x_i,y_j) \]</span></p>
<ul>
<li>联合熵 <span class="math inline">\(H(X,Y)\)</span> 表示 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 同时发生的不确定度。</li>
<li>联合熵 <span class="math inline">\(H(X,Y)\)</span> 与熵 <span class="math inline">\(H(X)\)</span> 及条件熵 <span class="math inline">\(H(Y|X)\)</span>
之间存在下列<strong>关系</strong>： <span class="math display">\[H(X,Y)=H(X)+H(Y|X)=H(Y)+H(X|Y)\]</span>
<ul>
<li>推导： <span class="math display">\[
  \begin{align*}
  H(X,Y)&amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log p(x_i,y_j)\\
  &amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log [p(x_i)p(y_j|x_i)]\\
  &amp;=-\sum_{i}\sum_{j}p(x_i,y_j)\log
p(x_i)-\sum_{i}\sum_{j}p(x_i,y_j)\log p(y_j|x_i)\\
  &amp;=-\sum_{i}p(x_i)\log p(x_i)+H(Y|X)\\
  &amp;=H(X)+H(Y|X)
  \end{align*}
  \]</span></li>
<li>同理可得 <span class="math inline">\(H(X,Y)=H(Y)+H(X|Y)\)</span></li>
</ul></li>
<li>例题：<img src="image-110.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul>
<h3 id="互信息">互信息</h3>
<ul>
<li><p>未收到消息时，信源 <span class="math inline">\(X\)</span>
的不确定度为 <span class="math inline">\(H(X)\)</span>，收到消息 <span class="math inline">\(Y\)</span> 后关于 <span class="math inline">\(x_i\)</span> 的不确定度为 <span class="math inline">\(H(X|Y)\)</span>。<img src="image-111.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"></p></li>
<li><p><strong>定义</strong>：</p>
<ul>
<li><span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span>
的互信息为接收者通过通信信道接收到的信源 <span class="math inline">\(X\)</span> 的信息量</li>
<li><strong>平均互信息</strong>：<span class="math display">\[I(X;Y)=H(X)-H(X|Y)=\sum_{ij}p(x_i,y_j)\log\frac{p(x_i,y_j)}{p(x_i)p(y_j)}\]</span></li>
</ul></li>
<li><p><strong>平均互信息的推导</strong></p>
<ul>
<li><p><strong>定义单符号之间的互信息</strong> <span class="math inline">\(I(x_i;y_j)\)</span> 为 <span class="math display">\[
  \begin{align*}
  I(x_i;y_j)&amp;=I(x_i)-I(x_i|y_j)\\
  &amp;=\log\frac{1}{p(x_i)}-\log\frac{1}{p(x_i|y_j)}\\
  &amp;=\log\frac{p(x_i|y_j)}{p(x_i)}=\log\frac{\text{后验概率}}{\text{先验概率}}
  \end{align*}
  \]</span></p></li>
<li><p>在 <span class="math inline">\(X\)</span>
集合上<strong>统计平均值，即平均条件互信息量</strong> <span class="math inline">\(I(X;y_j)\)</span> 为 <span class="math display">\[
  I(X;y_j)=\sum_{i}p(x_i|y_j)I(x_i;y_j)=\sum_{i}p(x_i|y_j)\log\frac{p(x_i|y_j)}{p(x_i)}
  \]</span></p></li>
<li><p><span class="math inline">\(I(X;y_j)\)</span> 在 <span class="math inline">\(Y\)</span>
集合的<strong>概率加权统计平均值，即平均互信息</strong> <span class="math inline">\(I(X;Y)\)</span> 为 <span class="math display">\[
  \begin{align*}
  I(X;Y)&amp;=\sum_{j}p(y_j)I(X;y_j)=\sum_{j}p(y_j)\sum_{i}p(x_i|y_j)\log\frac{p(x_i|y_j)}{p(x_i)}\\
  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i|y_j)}{p(x_i)}\\
  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log
p(x_i|y_j)-\sum_{i}\sum_{j}p(x_i,y_j)\log p(x_i)\\
  &amp;=H(X)-H(X|Y)\\
  I(X;Y)&amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i|y_j)}{p(x_i)}\\
  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i|y_j)p(y_j)}{p(x_i)p(y_j)}\\
  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(x_i,y_j)}{p(x_i)p(y_j)}\\
  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{p(y_j)}\\
  &amp;=I(Y;X)\\
  \therefore I(X;Y)&amp;=H(Y)-H(Y|X)=I(Y;X)=H(X)+H(Y)-H(X,Y)
  \end{align*}
  \]</span></p></li>
</ul></li>
<li><p><strong>例题</strong>：<img src="image-112.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
<li><p><strong>性质</strong>：</p>
<ul>
<li><span class="math inline">\(I(X;Y)=I(Y;X)=H(X)+H(Y)-H(X,Y)\)</span>
<ul>
<li><figure>
<img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload alt="H(X，Y)">
<figcaption aria-hidden="true">H(X，Y)</figcaption>
</figure></li>
</ul></li>
<li><span class="math inline">\(0 \leq I(X;Y) \leq
H(X)\)</span>（非负性证明见<a href="#互信息的非负性">互信息的非负性</a>）</li>
<li><strong>若<span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span>相互独立时</strong>
<ul>
<li><span class="math inline">\(H(X|Y)=H(X)\)</span></li>
<li><span class="math inline">\(I(X;Y)=H(X)-H(X|Y)=0\)</span>
，对应<strong>全损离散信道</strong></li>
</ul></li>
<li><strong>若<span class="math inline">\(Y\)</span>是由<span class="math inline">\(X\)</span>确定的一一对应函数</strong>，即<span class="math inline">\(p(y_j|x_i)= 0 \text{或} 1\)</span>
<ul>
<li><span class="math inline">\(H(X|Y)=H(Y|X)=0\)</span></li>
<li><span class="math inline">\(I(X;Y)=H(X)=H(Y)\)</span>
，对应<strong>无损信道</strong></li>
</ul></li>
<li><strong>一般情况下</strong>，<span class="math inline">\(X\)</span>与<span class="math inline">\(Y\)</span>既非相互独立，也不是一一对应 <span class="math display">\[
  \begin{align*}
  I(X;Y)&amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{p(y_j)}\\
  &amp;=\sum_{i}\sum_{j}p(x_i)p(y_j|x_i)\log\frac{p(y_j|x_i)}{p(y_j)}\\
  p(y_j)&amp;=\sum_{i}p(x_i)p(y_j|x_i)\\
  I(X;Y)&amp;=f\left[p(x_i),p(y_j|x_i)\right]
  \end{align*}
  \]</span>
<ul>
<li><strong>结论</strong>：（证明见<a href="#互信息的凹凸性">互信息的凹凸性</a>）
<ol type="1">
<li><span class="math inline">\(p(x_i)\)</span> 一定时，<span class="math inline">\(I(X;Y)\)</span>是 <span class="math inline">\(p(y_j|x_i)\)</span> 的<span class="math inline">\(\cup\)</span>型凸函数，存在极小值。</li>
<li><span class="math inline">\(p(y_j|x_i)\)</span> 一定时，<span class="math inline">\(I(X;Y)\)</span>是关于 <span class="math inline">\(p(x_i)\)</span> 的<span class="math inline">\(\cap\)</span>型凸函数，存在极大值。</li>
</ol></li>
</ul></li>
</ul></li>
<li><p><strong>收发两端的熵关系</strong></p>
<ul>
<li>条件熵 <span class="math inline">\(H(X|Y)\)</span>
又可以看作由于信道上的干扰和噪声，使接收端获得 <span class="math inline">\(Y\)</span> 后还剩余的对信源符号 <span class="math inline">\(X\)</span>
的平均不确定度，故又称为<strong>疑义度</strong>。</li>
<li>条件熵 <span class="math inline">\(H(Y|X)\)</span>
可看作唯一地确定信道噪声所需要的平均信量，故又称<strong>噪声熵或散布度</strong>。</li>
<li><figure>
<img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload alt="收发两端熵关系">
<figcaption aria-hidden="true">收发两端熵关系</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="相对熵">相对熵</h3>
<ul>
<li><span class="math inline">\(p,q\)</span>为同一信源两个不同的概率分布，<strong>相对熵<span class="math inline">\(D(p||q)\)</span>是两个随机分布之间距离的度量</strong>，<strong><span class="math inline">\(p\)</span>相对于<span class="math inline">\(q\)</span>的相对熵定义</strong>为： <span class="math display">\[D(p||q)=\sum_{i}
p(x_{i})\log\frac{p(x_{i})}{q(x_{i})}\]</span></li>
<li>约定 <span class="math inline">\(0\log\frac{0}{0} =
0\)</span>，<span class="math inline">\(0\log\frac{0}{q}=0\)</span>，<span class="math inline">\(p\log\frac{p}{0} = \infty\)</span></li>
<li><strong>性质</strong>：
<ul>
<li><p><span class="math inline">\(D(p||q)\neq D(q||p)\)</span></p></li>
<li><p>互信息可定义为联合分布<span class="math inline">\(p(x,y)\)</span>与乘积分布<span class="math inline">\(p(x)p(y)\)</span>之间的相对熵 <span class="math display">\[I(X;Y)=\sum_{i,j}
p(x_{i},y_{j})\log\frac{p(x_{i}|y_{j})}{p(x_{i})}=\sum_{i,j}
p(x_{i},y_{j})\log\frac{p(x_{i},y_{j})}{p(x_{i})p(y_{j})}=D(p(x,y)||p(x)p(y))\]</span></p></li>
<li><p><span class="math inline">\(D(p||q)\geq0\)</span>（证明见<a href="#信息不等式相对熵的非负性">信息不等式/相对熵的非负性</a>）</p></li>
<li><p>信源符号 <span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>
概率分布 <span class="math inline">\(p_1,p_2,\cdots,p_n\)</span>
编码方案1：<span class="math inline">\(-\log p_1,-\log p_2,\cdots,-\log
p_n\)</span> （按照码长 <span class="math inline">\(I(x_{i}) = -\log
p_{i}\)</span> 进行编码） 编码方案2：<span class="math inline">\(-\log
q_1,-\log q_2,\cdots,-\log q_n\)</span></p>
<p>编码1平均码长 <span class="math inline">\(K_p = -\sum_{i} p_{i}\log
p_{i}\)</span> 编码2平均码长 <span class="math inline">\(K_q = -\sum_{i}
p_{i}\log q_{i}\)</span> <span class="math display">\[K_q - K_p=\sum_{i}
p_{i}\log\frac{p_{i}}{q_{i}}=D(p||q)\geq0\]</span></p>
<ul>
<li><strong>结论</strong>：按概率分布编码最短</li>
</ul></li>
</ul></li>
</ul>
<h3 id="熵相对熵与互信息的链式法则">熵、相对熵与互信息的链式法则</h3>
<h4 id="熵的链式法则">熵的链式法则</h4>
<ul>
<li><p><strong>熵的链式法则</strong>：</p>
<ul>
<li>设随机变量 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>
服从 <span class="math inline">\(p(x_1,x_2,\cdots,x_n)\)</span>，则
<span class="math display">\[H(X_1,X_2,\cdots,X_n)=\sum_{i =
1}^{n}H(X_i|X_{i - 1},\cdots,X_1)\]</span></li>
</ul></li>
<li><p><strong>证明</strong>：重复利用两个随机变量情形时熵的展开法则，有
<span class="math display">\[
  H(X_1,X_2)=H(X_1)+H(X_2|X_1)
  \]</span><span class="math display">\[
  \begin{align*}
  H(X_1,X_2,X_3)&amp;=H(X_1)+H(X_2,X_3|X_1)\\
  &amp;=H(X_1)+H(X_2|X_1)+H(X_3|X_2,X_1)
  \end{align*}
  \]</span><span class="math display">\[
  \begin{align*}
  H(X_1,X_2,\cdots,X_n)&amp;=H(X_1)+H(X_2|X_1)+\cdots +H(X_n|X_{n -
1},\cdots,X_1)\\
  &amp;=\sum_{i = 1}^{n}H(X_i|X_{i - 1},\cdots,X_1)
  \end{align*}
  \]</span></p></li>
<li><p><strong>另一证明</strong>：由 <span class="math inline">\(p(x_1,x_2,\cdots,x_n)=\prod_{i = 1}^{n}p(x_i|x_{i
- 1},\cdots,x_1)\)</span>，可得 <span class="math display">\[
  \begin{align*}
  &amp;H(X_1,X_2,\cdots,X_n)\\
  =&amp;-\sum_{x_1,x_2,\cdots,x_n}p(x_1,x_2,\cdots,x_n)\log
p(x_1,x_2,\cdots,x_n)\\
  =&amp;-\sum_{x_1,x_2,\cdots,x_n}p(x_1,x_2,\cdots,x_n)\log\prod_{i =
1}^{n}p(x_i|x_{i - 1},\cdots,x_1)\\
  =&amp;-\sum_{x_1,x_2,\cdots,x_n}\sum_{i =
1}^{n}p(x_1,x_2,\cdots,x_n)\log p(x_i|x_{i - 1},\cdots,x_1)\\
  =&amp;-\sum_{i =
1}^{n}\sum_{x_1,x_2,\cdots,x_n}p(x_1,x_2,\cdots,x_n)\log p(x_i|x_{i -
1},\cdots,x_1)\\
  =&amp;\sum_{i = 1}^{n}H(X_i|X_{i - 1},\cdots,X_1)\\
  \end{align*}
  \]</span></p></li>
</ul>
<h4 id="互信息的链式法则">互信息的链式法则</h4>
<ul>
<li><p><strong>条件互信息定义</strong>：</p>
<ul>
<li>随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 在给定随机变量 <span class="math inline">\(Z\)</span> 时的条件互信息（conditional mutual
information）定义为 <span class="math display">\[
  \begin{align*}
  I(X;Y|Z)&amp;=H(X|Z)-H(X|Y,Z)\\
  &amp;=E_{p(x,y,z)}\log\frac{p(X,Y|Z)}{p(X|Z)p(Y|Z)}\\
  &amp;=\sum_{i}\sum_{j}\sum_{k}p(x_i,y_j,z_k)\log\frac{p(x_i,y_j|z_k)}{p(x_i|z_k)p(y_j|z_k)}\\
  &amp;=\sum_{i}\sum_{j}\sum_{k}p(x_i,y_j,z_k)\log\frac{p(x_i,y_j,z_k)p(z_k)}{p(x_i,z_k)p(y_j,z_k)}
  \end{align*}
  \]</span></li>
</ul></li>
<li><p><strong>互信息的链式法则</strong> <span class="math display">\[I(X_1,X_2,\cdots,X_n;Y)=\sum_{i =
1}^{n}I(X_i;Y|X_{i - 1},X_{i - 2},\cdots,X_1)\]</span></p></li>
<li><p><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  &amp;I(X_1,X_2,\cdots,X_n;Y)\\
  =&amp;H(X_1,X_2,\cdots,X_n)-H(X_1,X_2,\cdots,X_n|Y)\\
  =&amp;\sum_{i = 1}^{n}H(X_i|X_{i - 1},\cdots,X_1)-\sum_{i =
1}^{n}H(X_i|X_{i - 1},\cdots,X_1,Y)\\
  =&amp;\sum_{i = 1}^{n}I(X_i;Y|X_1,X_2,\cdots,X_{i - 1})
  \end{align*}
  \]</span></p></li>
</ul>
<h4 id="相对熵的链式法则">相对熵的链式法则</h4>
<ul>
<li><p><strong>条件相对熵定义</strong>：</p>
<ul>
<li>对于联合概率密度函数 <span class="math inline">\(p(x,y)\)</span> 和
<span class="math inline">\(q(x,y)\)</span>，条件相对熵（conditional
relative entropy <span class="math inline">\(D(p(y|x)\|q(y|x))\)</span>）定义为条件概率密度函数
<span class="math inline">\(p(y|x)\)</span> 和 <span class="math inline">\(q(y|x)\)</span>
之间的平均相对熵，其中取平均是关于概率密度函数 <span class="math inline">\(p(x)\)</span> 而言的。 <span class="math display">\[
  \begin{align*}
  D(p(y|x)\|q(y|x))&amp;=\sum_{x}p(x)\sum_{y}p(y|x)\log\frac{p(y|x)}{q(y|x)}\\
  &amp;=E_{p(x,y)}\log\frac{p(Y|X)}{q(Y|X)}\\
  &amp;=\sum_{i}\sum_{j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{q(y_j|x_i)}
  \end{align*}
  \]</span></li>
</ul></li>
<li><p><strong>相对熵的链式法则</strong> <span class="math display">\[D(p(x,y)\|q(x,y)) =
D(p(x)\|q(x))+D(p(y|x)\|q(y|x))\]</span></p></li>
<li><p><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  &amp;D(p(x,y)\|q(x,y))\\
  =&amp;\sum_{x}\sum_{y}p(x,y)\log\frac{p(x,y)}{q(x,y)}\\
  =&amp;\sum_{x}\sum_{y}p(x,y)\log\frac{p(x)p(y|x)}{q(x)q(y|x)}\\
  =&amp;\sum_{x}\sum_{y}p(x,y)\log\frac{p(x)}{q(x)}+\sum_{x}\sum_{y}p(x,y)\log\frac{p(y|x)}{q(y|x)}\\
  =&amp;\sum_{x}p(x)\log\frac{p(x)}{q(x)}+\sum_{x}\sum_{y}p(x,y)\log\frac{p(y|x)}{q(y|x)}\\
  =&amp;D(p(x)\|q(x))+D(p(y|x)\|q(y|x))
  \end{align*}
  \]</span></p></li>
</ul>
<h3 id="jensen不等式">Jensen不等式</h3>
<h4 id="凸函数与凹函数">凸函数与凹函数</h4>
<ul>
<li><strong>凸函数(Convex)定义</strong>
<ul>
<li>若对于任意的 <span class="math inline">\(x_1,x_2\in(a,b)\)</span> 及
<span class="math inline">\(0\leq\lambda\leq1\)</span>，满足 <span class="math display">\[f(\lambda x_1+(1 - \lambda)x_2)\leq\lambda
f(x_1)+(1 - \lambda)f(x_2)\]</span></li>
</ul>
则称函数 <span class="math inline">\(f(x)\)</span> 在区间 <span class="math inline">\((a,b)\)</span> 上是凸的（convex）。
<ul>
<li>如果仅当 <span class="math inline">\(\lambda = 0\)</span> 或 <span class="math inline">\(\lambda = 1\)</span>，上式等号成立，则称函数 <span class="math inline">\(f\)</span> 是严格凸的（strictly convex）</li>
<li>如果函数总是位于任何一条弦的下面，则该函数是凸的</li>
<li><figure>
<img src="image-7.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
</ul></li>
<li><strong>凹函数(Concave)定义</strong>
<ul>
<li>如果 <span class="math inline">\(-f\)</span> 为凸函数，则称函数
<span class="math inline">\(f\)</span> 是凹的</li>
<li>如果函数总是位于任何一条弦的上面，则该函数是凹的</li>
<li><figure>
<img src="image-113.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
</ul></li>
<li><strong>定理</strong>：如果函数 <span class="math inline">\(f\)</span>
在某个区间上存在非负（正）的二阶导数，则 <span class="math inline">\(f\)</span> 为该区间的凸函数（严格凸函数）。
<ul>
<li><strong>证明</strong>： 根据泰勒公式，<span class="math inline">\(f(x)=f(x_0)+f^{\prime}(x_0)(x -
x_0)+\frac{f^{\prime\prime}(x^*)}{2}(x - x_0)^2\)</span> ，其中 <span class="math inline">\(x \leq x^* \leq x_0\)</span>。根据假设 <span class="math inline">\(f^{\prime\prime}(x^*)\geq0\)</span>，上式末项非负。
设 <span class="math inline">\(x_0 = \lambda x_1+(1 -
\lambda)x_2\)</span> ，
<ul>
<li>取 <span class="math inline">\(x = x_1\)</span>，可得 <span class="math inline">\(f(x_1)\geq f(x_0)+f^{\prime}(x_0)((1 -
\lambda)(x_1 - x_2))\)</span> ①；</li>
<li>取 <span class="math inline">\(x = x_2\)</span>，可得 <span class="math inline">\(f(x_2)\geq f(x_0)+f^{\prime}(x_0)(\lambda(x_2 -
x_1))\)</span> ②。</li>
</ul>
①<span class="math inline">\(\times\lambda+\)</span>②<span class="math inline">\(\times(1 - \lambda)\)</span> ： <span class="math display">\[
  \begin{align*}
  \lambda f(x_1)+(1 - \lambda)f(x_2)&amp;\geq\lambda f(x_0)+\lambda
f^{\prime}(x_0)((1 - \lambda)(x_1 - x_2))\\
  &amp;+(1 - \lambda)f(x_0)+(1 - \lambda)f^{\prime}(x_0)\lambda(x_2 -
x_1)\\
  &amp;=f(x_0)\\
  &amp;=f(\lambda x_1+(1 - \lambda)x_2)
  \end{align*}
  \]</span></li>
</ul></li>
</ul>
<h4 id="jensen不等式-1">Jensen不等式</h4>
<ul>
<li><p><strong>Jensen不等式</strong>：若给定凸函数 <span class="math inline">\(f\)</span> 和一个随机变量 <span class="math inline">\(X\)</span>，则 <span class="math display">\[E(f(X))\geq f(E(X))\]</span></p></li>
<li><p>若 <span class="math inline">\(f\)</span>
是严格凸的，上式等号成立时 <span class="math inline">\(X =
E(X)\)</span>，即 <span class="math inline">\(X\)</span> 是个常量。</p>
<ul>
<li><strong>证明</strong>： 对于两点分布 <span class="math inline">\(\begin{bmatrix}x_1&amp;x_2\\p_1&amp;p_2\end{bmatrix}\)</span>，<span class="math inline">\(f\)</span> 是凸函数，因此有<span class="math inline">\(p_1f(x_1)+p_2f(x_2)\geq f(p_1x_1 +
p_2x_2)\)</span>，即满足 <span class="math inline">\(E(f(X))\geq
f(E(X))\)</span> 假定当分布点数为 <span class="math inline">\(k -
1\)</span> 时，定理成立，此时记 <span class="math inline">\(p_i^{\prime}=\frac{p_i}{1 - p_k}\)</span> <span class="math inline">\((i = 1,2,\cdots,k - 1)\)</span> <span class="math display">\[
  \begin{align*}
  \sum_{i = 1}^{k}p_if(x_i)&amp;=p_kf(x_k)+(1 - p_k)\sum_{i = 1}^{k -
1}p_i^{\prime}f(x_i)\\
  &amp;\geq p_kf(x_k)+(1 - p_k)f(\sum_{i = 1}^{k - 1}p_i^{\prime}x_i)\\
  &amp;\geq f(p_kx_k+(1 - p_k)\sum_{i = 1}^{k - 1}p_i^{\prime}x_i)\\
  &amp;=f(\sum_{i = 1}^{k}p_ix_i)
  \end{align*}
  \]</span>
<ul>
<li>其中，“分布点数为 <span class="math inline">\(k - 1\)</span>
时定理成立”用于推导第二步；“<span class="math inline">\(f\)</span>
的下凸性”用于推导第三步</li>
</ul></li>
</ul></li>
<li><p><strong>对凹函数</strong>：</p>
<ul>
<li>若 <span class="math inline">\(f(x)\)</span> 是凹函数，则有 <span class="math inline">\(E(f(X))\leq f(E(X))\)</span></li>
<li>取 <span class="math inline">\(f(x)=\log(x)\)</span> ，有 <span class="math inline">\(E[\log(X)]\leq\log(E(X))\)</span></li>
</ul></li>
</ul>
<h4 id="信息不等式相对熵的非负性">信息不等式/相对熵的非负性</h4>
<ul>
<li><strong><a href="#相对熵">信息不等式</a></strong>：设 <span class="math inline">\(p(x)\)</span>、<span class="math inline">\(q(x)\)</span>（<span class="math inline">\(x\in
X\)</span>）为两个概率密度函数，则 <span class="math display">\[D(p||q)\geq0\]</span> 当且仅当对任意 <span class="math inline">\(x\)</span>，<span class="math inline">\(p(x) =
q(x)\)</span>，等号成立。
<ul>
<li><strong>证明</strong>： 设 <span class="math inline">\(A = \{x:
p(x)&gt;0\}\)</span> 为 <span class="math inline">\(p(x)\)</span>
的支撑集，则 <span class="math display">\[
  \begin{align*}
  -D(p||q)&amp;=-\sum_{x\in A}p(x)\log\frac{p(x)}{q(x)}=\sum_{x\in
A}p(x)\log\frac{q(x)}{p(x)}\\
  &amp;\leq\log\sum_{x\in A}p(x)\frac{q(x)}{p(x)}（由Jensen不等式）\\
  &amp;=\log\sum_{x\in A}q(x)\\
  &amp;\leq\log\sum_{x\in X}q(x)\\
  &amp;=\log1 = 0
  \end{align*}
  \]</span> <span class="math inline">\(\therefore D(p||q)\geq0\)</span>
，当 <span class="math inline">\(p(x)=q(x)\)</span> 时，等号成立。</li>
</ul></li>
</ul>
<h4 id="互信息的非负性">互信息的非负性</h4>
<ul>
<li><strong><a href="#互信息">互信息的非负性</a></strong>：任意两个随机变量 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span>， <span class="math display">\[I(X;Y)\geq0\]</span> 当且仅当 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span>
相互独立，等号成立。
<ul>
<li><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  I(X;Y)&amp;=\sum_{x,y}p(x,y)\log\frac{p(x|y)}{p(x)}\\
  &amp;=\sum_{x,y}p(x,y)\log\frac{p(x|y)p(y)}{p(x)p(y)}\\
  &amp;=\sum_{x,y}p(x,y)\log\frac{p(x,y)}{p(x)p(y)}\\
  &amp;=D(p(x,y)\|p(x)p(y))\\
  &amp;\geq0
  \end{align*}
  \]</span></li>
</ul></li>
<li><strong>推论</strong>：
<ul>
<li><span class="math inline">\(D(p(y|x)\|q(y|x))\geq0\)</span>
，当且仅当对任意的 <span class="math inline">\(y\)</span> 以及满足 <span class="math inline">\(p(x)&gt;0\)</span> 的 <span class="math inline">\(x\)</span>，有 <span class="math inline">\(p(y|x)=q(y|x)\)</span>，等号成立。</li>
<li><span class="math inline">\(I(X;Y|Z)\geq0\)</span> ，当且仅当 <span class="math inline">\(p(x,y|z)=p(x|z)p(y|z)\)</span> 时，等号成立。</li>
</ul></li>
</ul>
<h3 id="熵的性质">熵的性质</h3>
<ol type="1">
<li><strong>非负性</strong>
<ul>
<li><span class="math display">\[H(X)=\sum_{i}p(x_i)\log\frac{1}{p(x_i)}\geq0\]</span></li>
</ul></li>
<li><strong>确定性</strong>
<ul>
<li><span class="math display">\[H(0,1)=H(1,0,\cdots,0)=0\]</span></li>
<li>只要有一个事件概率为1，熵就为0。</li>
</ul></li>
<li><strong>对称性</strong>
<ul>
<li><span class="math display">\[H(p_1,p_2,\cdots,p_n)=H(p_2,p_1,\cdots,p_n)\]</span></li>
</ul></li>
<li><strong>香农辅助定理</strong>
<ul>
<li>任意n维概率矢量 <span class="math inline">\(P =
(p_1,p_2,\cdots,p_n)\)</span> ，<span class="math inline">\(Q=(q_1,q_2,\cdots,q_n)\)</span></li>
<li><span class="math display">\[H(p_1,p_2,\cdots,p_n)=\sum_{i =
1}^{n}p_i\log\frac{1}{p_i}\leq\sum_{i =
1}^{n}p_i\log\frac{1}{q_i}\]</span></li>
<li><strong>证明</strong>：<span class="math inline">\(D(P\|Q)=\sum_{i}p_i\log\frac{p_i}{q_i}\geq0\)</span></li>
</ul></li>
<li><strong>最大熵定理</strong>
<ul>
<li><span class="math display">\[H(X)\leq
H(\frac{1}{M},\frac{1}{M},\cdots,\frac{1}{M}) = \log M\]</span></li>
<li><span class="math inline">\(M\)</span>：信源符号个数</li>
<li>符号等概率出现时，熵最大。</li>
<li><strong>证明</strong>：<span class="math inline">\(X\)</span>
的两种概率分布 <span class="math inline">\(P\)</span>、<span class="math inline">\(u\)</span>，<span class="math inline">\(u(x)=\frac{1}{M}\)</span> <span class="math display">\[
  \begin{align*}
  D(P\|u)&amp;=\sum p(x)\log\frac{p(x)}{u(x)}\\
  &amp;=\sum p(x)\log p(x)+\sum p(x)\log M\\
  &amp;=-H(X)+\log M\\
  &amp;\geq0\\
  &amp;\therefore H(X)\leq\log M
  \end{align*}
  \]</span></li>
</ul></li>
<li><strong>条件熵小于无条件熵</strong>
<ul>
<li><span class="math display">\[H(X|Y)\leq H(X)\]</span></li>
<li><strong>证明</strong>：<span class="math inline">\(I(X;Y)=H(X)-H(X|Y)\geq0\)</span> ，<span class="math inline">\(H(X)\geq H(X|Y)\)</span> 。</li>
</ul></li>
<li><strong>扩展性</strong>
<ul>
<li><span class="math display">\[\lim_{\varepsilon \to 0}H_{n +
1}(p_1,p_2,\cdots,p_n-\varepsilon,\varepsilon)=H_n(p_1,p_2,\cdots,p_n)\]</span></li>
<li><span class="math display">\[\lim_{\varepsilon \to
0}\varepsilon\log\varepsilon = 0\]</span></li>
<li>信源取值增多时，若这些取值概率很小(<span class="math inline">\(\varepsilon\to0\)</span>)，信源熵不变。</li>
</ul></li>
<li><strong>可加性</strong>
<ul>
<li><span class="math display">\[H(X,Y)=H(X)+H(Y|X)\]</span></li>
<li>当 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span> 相互独立时，<span class="math inline">\(H(X,Y)=H(X)+H(Y)\)</span> 。</li>
<li><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  H(X,Y)&amp;=\sum p(x,y)\log p(x,y)=\sum p(x,y)\log (p(x)p(y|x))\\
  &amp;=\sum p(x,y)\log p(x)+\sum p(x,y)\log p(y|x)\\
  &amp;=H(X)+H(Y|X)
  \end{align*}
  \]</span></li>
</ul></li>
<li><strong>递增性</strong>
<ul>
<li><span class="math display">\[
H_{n + m - 1}(p_1,p_2,\cdots,p_{n - 1},q_1,q_2,\cdots,q_m)\\
=
H_n(p_1,p_2,\cdots,p_n)+p_nH_m\left(\frac{q_1}{p_n},\frac{q_2}{p_n},\cdots,\frac{q_m}{p_n}\right)
\]</span></li>
<li>其中<span class="math inline">\(\sum_{i = 1}^{n}p_i =
1\)</span>，<span class="math inline">\(\sum_{j = 1}^{m}q_j =
p_n\)</span></li>
<li>利用上式： <span class="math display">\[
  \begin{align*}
  H_n(p_1,p_2,\cdots,p_n)&amp;=H_{n - 1}(p_1,p_2,\cdots,p_{n -
1}+p_n)+\\
  \quad &amp;(p_{n - 1}+p_n)H_2\left(\frac{p_{n - 1}}{p_{n -
1}+p_n},\frac{p_n}{p_{n - 1}+p_n}\right)
  \end{align*}
  \]</span></li>
</ul></li>
</ol>
<h3 id="对数和不等式及其应用">对数和不等式及其应用</h3>
<h4 id="对数和不等式">对数和不等式</h4>
<ul>
<li>非负数 <span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>，和
<span class="math inline">\(b_1,b_2,\cdots,b_n\)</span> ，约定 <span class="math inline">\(0\log 0 = 0\)</span>，<span class="math inline">\(a\log\frac{a}{0}=\infty\)</span>，<span class="math inline">\(0\log\frac{0}{b}=0\)</span> <span class="math display">\[
  \sum_{i = 1}^{n}a_i\log\frac{a_i}{b_i}\geq\left(\sum_{i =
1}^{n}a_i\right)\log\frac{\sum_{i = 1}^{n}a_i}{\sum_{i = 1}^{n}b_i}
  \]</span> 当且仅当 <span class="math inline">\(\frac{a_i}{b_i}
=\)</span> 常数时，等号成立。
<ul>
<li><strong>证明</strong>： 假定 <span class="math inline">\(a_i&gt;0\)</span>，<span class="math inline">\(b_i&gt;0\)</span> ，<span class="math inline">\(f(t)=t\log t\)</span> 是严格下凸，因为 <span class="math inline">\(f^{\prime\prime}(t)=\frac{1}{t}\log
e&gt;0\)</span>。 因此，由Jensen不等式，有 <span class="math inline">\(\sum\alpha_if(t_i)\geq
f(\sum\alpha_it_i)\)</span>，其中 <span class="math inline">\(\alpha_i\geq0\)</span>，<span class="math inline">\(\sum\alpha_i = 1\)</span>。 令 <span class="math inline">\(\alpha_i=\frac{b_i}{\sum_{j = 1}^{n}b_j}\)</span>
，<span class="math inline">\(t_i=\frac{a_i}{b_i}\)</span> ，可得 <span class="math display">\[
  \begin{align*}
  \sum\frac{b_i}{\sum_{j =
1}^{n}b_j}\cdot\frac{a_i}{b_i}\log\frac{a_i}{b_i}&amp;\geq\left(\sum\alpha_it_i\right)\log\left(\sum\alpha_it_i\right)\\
  &amp;=\sum\left(\frac{b_i}{\sum_{j =
1}^{n}b_j}\cdot\frac{a_i}{b_i}\right)\log\left(\sum\frac{b_i}{\sum_{j =
1}^{n}b_j}\cdot\frac{a_i}{b_i}\right)\\
  \sum_{i}a_i\log\frac{a_i}{b_i}&amp;\geq\left(\sum_{i}a_i\right)\log\left(\sum_{i}\frac{a_i}{\sum_{j
= 1}^{n}b_j}\right)\\
  \sum_{i}a_i\log\frac{a_i}{b_i}&amp;\geq\left(\sum_{i}a_i\right)\log\frac{\sum_{i
= 1}^{n}a_i}{\sum_{i = 1}^{n}b_j}
  \end{align*}
  \]</span></li>
</ul></li>
</ul>
<h4 id="相对熵的下凸性">相对熵的下凸性</h4>
<ul>
<li><span class="math inline">\(D(p||q)\)</span> 关于 <span class="math inline">\((p,q)\)</span> 是下凸的</li>
<li>即如果 <span class="math inline">\((p_1,q_1)\)</span>，<span class="math inline">\((p_2,q_2)\)</span> 为两对概率密度函数，则对所有的
<span class="math inline">\(0\leq\lambda\leq1\)</span>，有 <span class="math display">\[D(\lambda p_1+(1 - \lambda)p_2\|\lambda q_1+(1 -
\lambda)q_2)\leq\lambda D(p_1\|q_1)+(1 - \lambda)D(p_2\|q_2)\]</span>
<ul>
<li><strong>证明</strong>： 已知 <span class="math inline">\(\sum_{i =
1}^{n}a_i\log\frac{a_i}{b_i}\geq\left(\sum_{i =
1}^{n}a_i\right)\log\frac{\sum_{i = 1}^{n}a_i}{\sum_{i =
1}^{n}b_i}\)</span> 令 <span class="math inline">\(a_1 = \lambda
p_1(x)\)</span> ，<span class="math inline">\(b_1 = \lambda
q_1(x)\)</span> <span class="math inline">\(a_2=(1 -
\lambda)p_2(x)\)</span> ，<span class="math inline">\(b_2=(1 -
\lambda)q_2(x)\)</span> <span class="math display">\[
  \begin{align*}
  &amp;\quad \lambda p_1(x)\log\frac{\lambda p_1(x)}{\lambda q_1(x)}+(1
- \lambda)p_2(x)\log\frac{(1 - \lambda)p_2(x)}{(1 - \lambda)q_2(x)}\\
  &amp;\geq(\lambda p_1(x)+(1 - \lambda)p_2(x))\log\frac{\lambda
p_1(x)+(1 - \lambda)p_2(x)}{\lambda q_1(x)+(1 - \lambda)q_2(x)}\\
  &amp;\quad \sum_{x}\left[\lambda p_1(x)\log\frac{p_1(x)}{q_1(x)}+(1 -
\lambda)p_2(x)\log\frac{p_2(x)}{q_2(x)}\right]\\
  &amp;\geq\sum_{x}(\lambda p_1(x)+(1 - \lambda)p_2(x))\log\frac{\lambda
p_1(x)+(1 - \lambda)p_2(x)}{\lambda q_1(x)+(1 - \lambda)q_2(x)}\\
  &amp;\quad \lambda D(p_1\|q_1)+(1 - \lambda)D(p_2\|q_2)\\
  &amp;\geq D(\lambda p_1+(1 - \lambda)p_2\|\lambda q_1+(1 -
\lambda)q_2)
  \end{align*}
  \]</span></li>
</ul></li>
</ul>
<h4 id="熵的凹性">熵的凹性</h4>
<ul>
<li><span class="math inline">\(H(p)\)</span> 是关于 <span class="math inline">\(p\)</span> 的凹函数。
<ul>
<li><strong>证明</strong>： 均匀分布 <span class="math inline">\(u(x_i)=\frac{1}{M}\)</span> <span class="math display">\[
  \begin{align*}
  D(p\|u)&amp;=\sum_{i}p(x_i)\log\frac{p(x_i)}{u(x_i)}\\
  &amp;=\sum_{i}p(x_i)\log p(x_i)-\sum_{i}p(x_i)\log u(x_i)\\
  &amp;=-H(p)+\log M
  \end{align*}
  \]</span> <span class="math inline">\(\therefore H(p)=\log M -
D(p\|u)\)</span>，因为 <span class="math inline">\(D(p\|u)\)</span>
是凸函数，所以 <span class="math inline">\(H(p)\)</span> 是凹函数。</li>
</ul></li>
</ul>
<h4 id="互信息的凹凸性">互信息的凹凸性</h4>
<ul>
<li><strong><a href="#互信息">互信息的凹凸性</a></strong>
<ul>
<li>设 <span class="math inline">\((X,Y)\sim
p(x,y)=p(x)p(y|x)\)</span>。</li>
<li>如果固定 <span class="math inline">\(p(y|x)\)</span>，则互信息 <span class="math inline">\(I(X;Y)\)</span> 是关于 <span class="math inline">\(p(x)\)</span> 的凹函数；</li>
<li>如果固定 <span class="math inline">\(p(x)\)</span>，则互信息 <span class="math inline">\(I(X;Y)\)</span> 是关于 <span class="math inline">\(p(y|x)\)</span> 的凸函数。</li>
</ul></li>
<li><strong>证明</strong>：
<ol type="1">
<li><p><strong>证明第一部分</strong> <span class="math display">\[I(X;Y)=H(Y)-H(Y|X)=H(Y)-\sum_{x}p(x)H(Y|X =
x)\]</span> 如果固定 <span class="math inline">\(p(y|x)\)</span>，<span class="math inline">\(p(y)=\sum_{x}p(x,y)=\sum_{x}p(x)p(y|x)\)</span> 是
<span class="math inline">\(p(x)\)</span> 的线性函数。 <span class="math inline">\(H(Y)\)</span> 是关于 <span class="math inline">\(p(y)\)</span> 的凹函数，因而也是关于 <span class="math inline">\(p(x)\)</span> 的凹函数。上式第二项是关于 <span class="math inline">\(p(x)\)</span> 的线性函数，因此它们的差仍是关于
<span class="math inline">\(p(x)\)</span> 的凹函数。</p></li>
<li><p><strong>证明第二部分</strong></p>
<ul>
<li><p><strong>方法1</strong>： 固定 <span class="math inline">\(p(x)\)</span>，考虑两个不同的条件分布 <span class="math inline">\(p_1(y|x)\)</span> 和 <span class="math inline">\(p_2(y|x)\)</span>。相应的联合分布分别为 <span class="math inline">\(p_1(x,y)=p(x)p_1(y|x)\)</span> 和 <span class="math inline">\(p_2(x,y)=p(x)p_2(y|x)\)</span>，且各自的边际分布为
<span class="math inline">\(p(x),p_1(y)\)</span> 和 <span class="math inline">\(p(x),p_2(y)\)</span>。 考虑条件分布 <span class="math display">\[p_{\lambda}(y|x)=\lambda p_1(y|x)+(1 -
\lambda)p_2(y|x)\]</span> 它是 <span class="math inline">\(p_1(y|x)\)</span> 和 <span class="math inline">\(p_2(y|x)\)</span> 的组合，其中 <span class="math inline">\(0\leq\lambda\leq1\)</span>。
相应的联合分布也是对应的两个联合分布的线性组合 <span class="math display">\[p_{\lambda}(x,y)=\lambda p_1(x,y)+(1 -
\lambda)p_2(x,y)\]</span> <span class="math inline">\(Y\)</span>
的分布也是一个组合 <span class="math display">\[p_{\lambda}(y)=\lambda
p_1(y)+(1 - \lambda)p_2(y)\]</span> 因此，如果设 <span class="math inline">\(q_{\lambda}(x,y)=p(x)p_{\lambda}(y)\)</span>
为边际分布的乘积，则有 <span class="math display">\[q_{\lambda}(x,y)=\lambda q_1(x,y)+(1 -
\lambda)q_2(x,y)\]</span> 由于互信息是联合分布和边际分布乘积的相对熵，有
<span class="math display">\[I(X;Y)=D(p_{\lambda}(x,y)\|q_{\lambda}(x,y))\]</span>
因为相对熵 <span class="math inline">\(D(p\|q)\)</span> 是关于 <span class="math inline">\((p,q)\)</span> 的凸函数，因此 <span class="math inline">\(I(X;Y)\)</span> 是 <span class="math inline">\((p_{\lambda},q_{\lambda})\)</span> 的凸函数，由于
<span class="math inline">\(p_{\lambda},q_{\lambda}\)</span> 都是 <span class="math inline">\(p(y|x)\)</span> 的线性组合，所以 <span class="math inline">\(I(X;Y)\)</span> 是条件分布 <span class="math inline">\(p(y|x)\)</span> 的凸函数。</p></li>
<li><p><strong>方法2</strong>： 设 <span class="math inline">\(p(x)\)</span> 为固定信源分布，令 <span class="math inline">\(p_1(y|x)\)</span> 和 <span class="math inline">\(p_2(y|x)\)</span>
为两条不同信道，相应的互信息分别记为 <span class="math inline">\(I[p_1(y|x)]\)</span> 和 <span class="math inline">\(I[p_2(y|x)]\)</span>。 令 <span class="math inline">\(p(y|x)=\lambda p_1(y|x)+(1 -
\lambda)p_2(y|x)\)</span>，<span class="math inline">\(0\leq\lambda\leq1\)</span>，相应的互信息为 <span class="math inline">\(I[p(y|x)]\)</span> <span class="math display">\[
\begin{align*}
①\ &amp;I[p(y|x)]-\lambda I[p_1(y|x)]-(1 - \lambda)I[p_2(y|x)]\\
&amp;=\sum_{x,y}p(x,y)\log\frac{p(y|x)}{p(y)}-\sum_{x,y}\lambda
p_1(x,y)\log\frac{p_1(y|x)}{p_1(y)}-\\&amp;\quad \sum_{x,y}(1 -
\lambda)p_2(x,y)\log\frac{p_2(y|x)}{p_2(y)}\\
&amp;=\sum_{x,y}[\lambda p_1(x,y)+(1 -
\lambda)p_2(x,y)]\log\frac{p(y|x)}{p(x)}-\\&amp;\quad\sum_{x,y}\lambda
p_1(x,y)\log\frac{p_1(y|x)}{p(x)}-\sum_{x,y}(1 -
\lambda)p_2(x,y)\log\frac{p_2(y|x)}{p(x)}\\
&amp;=\lambda\underbrace{\sum_{x,y}p_1(x,y)\log\frac{p(x|y)}{p_1(x|y)}}_{
(②)}+(1 -
\lambda)\underbrace{\sum_{x,y}p_2(x,y)\log\frac{p(x|y)}{p_2(x|y)}}_{(③)}
\end{align*}
\]</span> 应用Jensen不等式 <span class="math display">\[
\begin{align*}
②\
\lambda\sum_{x,y}p_1(x,y)\log\frac{p(x|y)}{p_1(x|y)}&amp;\leq\lambda\log\left[\sum_{x,y}p_1(x,y)\frac{p(x|y)}{p_1(x|y)}\right]\\
&amp;=\lambda\log\left[\sum_{y}p_1(y)\sum_{x}p(x|y)\right]\\
&amp;=\lambda\log\left[\sum_{y}p_1(y)\sum_{x}\frac{p(x)p(y|x)}{p(y)}\right]\\
&amp;=\lambda\log1 = 0
\end{align*}
\]</span> 同理 <span class="math inline">\(③ = 0\)</span>，则 <span class="math inline">\(① \leq 0\)</span> <span class="math display">\[I(\lambda p_1(y|x)+(1 -
\lambda)p_2(y|x))\leq\lambda I[p_1(y|x)]+(1 -
\lambda)I[p_2(y|x)]\]</span></p></li>
</ul></li>
</ol>
<ul>
<li>由此可知，互信息 <span class="math inline">\(I(X;Y)\)</span> 关于
<span class="math inline">\(p(y|x)\)</span> 下凸。</li>
</ul></li>
</ul>
<h2 id="数据处理不等式">2.3 数据处理不等式</h2>
<h3 id="三变量互信息">三变量互信息</h3>
<ul>
<li><strong>定义</strong>：
<ol type="1">
<li><strong><span class="math inline">\(x_i\)</span>与符号对<span class="math inline">\((y_j,z_k)\)</span>间的互信息量</strong>
<ul>
<li><span class="math inline">\(I(x_i;y_j,z_k)=\log\frac{p(x_i|y_j,z_k)}{p(x_i)}\)</span></li>
</ul></li>
<li><strong>条件互信息量</strong>
<ul>
<li><span class="math display">\[
\begin{align*}
I(x_i;y_j|z_k)&amp;=\log\frac{p(x_i|y_j,z_k)}{p(x_i|z_k)}=\log(\frac{p(x_i|y_j,z_k)}{p(x_i)}\frac{p(x_i)}{p(x_i|z_k)})\\
&amp;=\log\frac{p(x_i|y_j,z_k)}{p(x_i)}-\log\frac{p(x_i|z_k)}{p(x_i)}\\
&amp;=I(x_i;y_j,z_k)-I(x_i;z_k)
\end{align*}
\]</span></li>
<li><span class="math inline">\(I(x_i;y_j,z_k)=I(x_i;z_k)+I(x_i;y_j|z_k)\)</span></li>
<li>对其求平均可得
<ul>
<li><span class="math inline">\(I(X;Y,Z)=I(X;Z)+I(X;Y|Z)\)</span></li>
<li><span class="math inline">\(I(X;Y,Z)=I(X;Z,Y)=I(X;Y)+I(X;Z|Y)\)</span> ①</li>
</ul></li>
</ul></li>
<li><strong><span class="math inline">\(x_i，y_j\)</span>与符号对<span class="math inline">\((z_k)\)</span>间的互信息量</strong>
<ul>
<li><span class="math display">\[
\begin{align*}
I(x_i,y_j;z_k)&amp;=\log\frac{p(x_iy_j|z_k)}{p(x_iy_j)}=\log\frac{p(x_i|z_k)p(y_j|x_iz_k)}{p(x_i)p(y_j|x_i)}\\
&amp;=\log\frac{p(x_i|z_k)}{p(x_i)}+\log\frac{p(y_j|x_iz_k)}{p(y_j|x_i)}\\
&amp;=I(x_i;z_k)+I(y_j;z_k|x_i)
\end{align*}
\]</span></li>
<li>对其求平均可得
<ul>
<li><span class="math inline">\(I(X,Y;Z)=I(X;Z)+I(Y;Z|X)\)</span></li>
<li><span class="math inline">\(I(X,Y;Z)=I(Y,X;Z)=I(Y;Z)+I(X;Z|Y)\)</span> ②</li>
</ul></li>
</ul></li>
</ol></li>
<li><strong>互信息操作</strong>：
<ul>
<li>由①、②：
<ul>
<li><span class="math inline">\(I(X;Z|Y)=I(X;Y,Z)-I(X;Y)\)</span>
<ul>
<li>把条件<span class="math inline">\(Y\)</span>移到分号后面，然后减去该条件与分号前面的变量之间的互信息</li>
<li><span class="math inline">\(Y\)</span>的条件下<span class="math inline">\(X和Z\)</span>+ <span class="math inline">\(X和Y\)</span> = <span class="math inline">\(X和(Y,Z)\)</span></li>
</ul></li>
<li><span class="math inline">\(I(X;Z|Y)=I(X,Y;Z)-I(Y;Z)\)</span>
<ul>
<li>把条件<span class="math inline">\(Y\)</span>移到分号前面，然后减去该条件与分号后面的变量之间的互信息</li>
</ul></li>
</ul></li>
<li><span class="math inline">\(I(X;Z|Y,W)=I(X;Z,Y|W)-I(X;Y|W)=I(X,Y;Z|W)-I(Y;Z|W)\)</span></li>
<li><span class="math display">\[
\begin{align*}
I(X;Y|Z)&amp;=\sum_{i,j,k}
p(x_i,y_j,z_k)\log\frac{p(x_i|y_j,z_k)}{p(x_i|z_k)}\\
&amp;=\sum_{i,j,k} p(x_i,y_j,z_k)\log p(x_i|y_j,z_k)-\sum_{i,j,k}
p(x_i,y_j,z_k)\log p(x_i|z_k)\\
&amp;=H(X|Z)-H(X|Y,Z)\\
&amp;=H(Y|Z)-H(Y|X,Z)\\
&amp;=I(Y;X|Z)
\end{align*}
\]</span></li>
</ul></li>
<li><strong>三变量通用信息图</strong>：
<ul>
<li>信息图表示：
<ul>
<li>$H/I $区域</li>
<li><span class="math inline">\(, \Longleftrightarrow
\bigcup\)</span>(并集)</li>
<li><span class="math inline">\(; \Longleftrightarrow
\bigcap\)</span>(交集)</li>
<li><span class="math inline">\(| \Longleftrightarrow -\)</span>
(减)</li>
</ul></li>
<li><figure>
<img src="image-4.webp" srcset="/img/loading/loading3.gif" lazyload alt="三变量通用信息图">
<figcaption aria-hidden="true">三变量通用信息图</figcaption>
</figure></li>
<li>不相变的7个区域分别表示
<ul>
<li><span class="math inline">\(a_1:H(Y|X,Z)\)</span></li>
<li><span class="math inline">\(a_2:H(X|Y,Z)\)</span></li>
<li><span class="math inline">\(a_3:H(Z|X,Y)\)</span></li>
<li><span class="math inline">\(a_4:I(X;Y|Z)\)</span><br>
</li>
<li><span class="math inline">\(a_5:I(Y;Z|X)\)</span></li>
<li><span class="math inline">\(a_6:I(X;Z|Y)\)</span></li>
<li><span class="math inline">\(a_7:I(X;Y;Z)=I(X;Y)-I(X;Y|Z)\)</span></li>
</ul></li>
<li>一般情况下，<span class="math inline">\(a_7\)</span>可能为负，即<span class="math inline">\(I(X;Y;Z)\)</span>可能小于 0 。</li>
</ul></li>
<li>示例：<img src="image-114.webp" srcset="/img/loading/loading3.gif" lazyload alt="示例"></li>
</ul>
<h3 id="一阶马尔可夫链">一阶马尔可夫链</h3>
<h4 id="定义">定义</h4>
<ol type="1">
<li><strong>定义（两变量独立）</strong>
<ul>
<li>两个随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 独立，记为 <span class="math inline">\(X\perp Y\)</span>，有 <span class="math display">\[p(x,y)=p(x)p(y)\]</span></li>
</ul></li>
<li><strong>定义（相互独立）</strong>
<ul>
<li>设 <span class="math inline">\(n\geq3\)</span>，随机变量 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span> 相互独立，有 <span class="math display">\[p(x_1,x_2,\cdots,x_n)=p(x_1)p(x_2)\cdots
p(x_n)\]</span></li>
</ul></li>
<li><strong>定义（条件独立）</strong>
<ul>
<li>随机变量 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span> 和 <span class="math inline">\(Z\)</span>，若 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Z\)</span> 关于 <span class="math inline">\(Y\)</span> 条件独立，记为 <span class="math inline">\(X\perp Z|Y\)</span></li>
<li>有 <span class="math inline">\(p(x,y,z)p(y)=p(x,y)p(y,z)\)</span> 或
<span class="math inline">\(p(x,z|y)=p(x|y)p(z|y)\)</span></li>
<li>等价地 <span class="math display">\[p(x,y,z)=p(x)p(y|x)p(z|y)\]</span></li>
</ul></li>
<li><strong>定义（马尔可夫链）</strong>
<ul>
<li>随机变量 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>（<span class="math inline">\(n\geq3\)</span>）构成一个马尔可夫链，记作 <span class="math inline">\(X_1 \to X_2 \to \cdots \to X_n\)</span>，则有
<span class="math display">\[p(X_1,X_2,\cdots,X_n)p(X_2)p(X_3)\cdots
p(X_{n - 1}) = p(X_1,X_2)p(X_2,X_3)\cdots p(X_{n - 1},X_n)\]</span></li>
<li>或等价地 <span class="math display">\[p(X_1,X_2,\cdots,X_n)=p(X_1)p(X_2|X_1)p(X_3|X_2)\cdots
p(X_n|X_{n - 1})\]</span></li>
<li>即系统在时刻<span class="math inline">\(n\)</span>
的状态只取决于时刻<span class="math inline">\(n-1\)</span>
的状态，而与时刻<span class="math inline">\(n-1\)</span>
之前的状态无关</li>
<li>可见：<span class="math inline">\(X \to Y \to Z\)</span> 等价于
<span class="math inline">\(X\perp Z|Y\)</span></li>
</ul></li>
</ol>
<h4 id="结论">结论</h4>
<ol type="1">
<li><span class="math inline">\(X_1 \to X_2 \to \cdots \to X_n\)</span>
构成一个马尔可夫链，则有 <span class="math inline">\(X_n \to X_{n - 1}
\to \cdots \to X_1\)</span>
也构成一个马尔可夫链。（可由马尔可夫链定义的对称性直接得到）。</li>
<li><span class="math inline">\(X_1 \to X_2 \to \cdots \to X_n\)</span>
构成一个马尔可夫链，则有 <span class="math display">\[
\begin{align*}
&amp;X_1 \to X_2 \to X_3\\
&amp;(X_1,X_2) \to X_3 \to X_4\\
&amp;\vdots\\
&amp;(X_1,X_2,\cdots,X_{n - 2}) \to X_{n - 1} \to X_n
\end{align*}
\]</span> 构成马尔可夫链。
<ul>
<li><p><strong>证明</strong>：</p>
<p><span class="math display">\[
  \begin{align*}
  &amp;若X_1 \to X_2 \to X_3 \to X_4构成马尔可夫链，则有\\
  &amp;p(x_1,x_2,x_3,x_4)p(x_2)p(x_3) =
p(x_1,x_2)p(x_2,x_3)p(x_3,x_4)\quad ①\\
  &amp;\therefore \sum_{x_4} p(x_1,x_2,x_3,x_4)p(x_2)p(x_3) = \sum_{x_4}
p(x_1,x_2)p(x_2,x_3)p(x_3,x_4)\\
  &amp;\therefore p(x_1,x_2,x_3)p(x_2)p(x_3) =
p(x_1,x_2)p(x_2,x_3)p(x_3)\\
  &amp;\therefore p(x_1,x_2,x_3)p(x_2) = p(x_1,x_2)p(x_2,x_3)\quad ②\\
  &amp;\Rightarrow X_1 \to X_2 \to X_3 构成马尔可夫链\\
  &amp;把②代入①得 p(x_1,x_2,x_3,x_4)p(x_2)p(x_3) =
p(x_1,x_2,x_3)p(x_2)p(x_3,x_4)\\
  &amp;\therefore p(x_1,x_2,x_3,x_4)p(x_3) = p(x_1,x_2,x_3)p(x_3,x_4)\\
  &amp;\Rightarrow (X_1,X_2) \to X_3 \to X_4 构成马尔可夫链
  \end{align*}
  \]</span></p></li>
<li><p>例题：<img src="image-115.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul></li>
<li><span class="math inline">\(X \to Y \to Z \to
W\)</span>构成马尔可夫链，则有
<ul>
<li><span class="math inline">\(H(X|Y)= H(X|YZ) = H(X|YZW)\)</span>
<ul>
<li><strong>证明</strong>： 由马尔可夫链性质： <span class="math display">\[
  \begin{align*}
  &amp;p(x,y,z)p(y) = p(x,y)p(y,z)\\
  &amp;\Rightarrow \frac{p(x,y,z)}{p(y,z)} = \frac{p(x,y)}{p(y)}\\
  &amp;\Rightarrow p(x|yz) = p(x|y)\\
  &amp;\Rightarrow \underset{x,y}{\mathbb{E}}
p(x|yz)=\underset{x,y}{\mathbb{E}} p(x|y)\\
  &amp;即 H(X|YZ) = H(X|Y)
  \end{align*}
  \]</span> 类似地： <span class="math display">\[
  \begin{align*}
  &amp;p(x,y,z,w)p(y)p(z) = p(x,y)p(y,z)p(z,w)\\
  &amp;\Rightarrow p(x,y,z,w) = \frac{p(x,y)}{p(y)} \cdot
\frac{p(y,z)p(z,w)}{p(z)} = p(x|y) p(y,z,w)\\
  &amp;\Rightarrow p(x|yzw) = p(x|y)\\
  &amp;即 H(X|Y) = H(X|YZW)
  \end{align*}
  \]</span></li>
<li>注：<span class="math inline">\(\frac{p(y,z)p(z,w)}{p(z)} =
p(y,z,w)\)</span> 由 <span class="math inline">\(Y \to Z \to
W\)</span>得到</li>
</ul></li>
<li><span class="math inline">\(I(X;Z|Y) = H(X|Y)- H(X|YZ) =
0\)</span></li>
<li><span class="math inline">\(I(Y;W|Z) = 0\)</span></li>
<li><span class="math inline">\(I(Y;Z) = I(XY;Z) = I(Y;ZW) =
I(XY;ZW)\)</span>
<ul>
<li><strong>证明</strong>： <span class="math inline">\(I(XY;Z) = I(Y;Z)
+ I(X;Z|Y) = I(Y;Z)\\
  I(Y;ZW) = I(Y;Z) + I(Y;W|Z) = I(Y;Z)\)</span></li>
</ul></li>
<li><span class="math inline">\(I(XY;Z|W) - I(X;Z|W) = I(Y;Z|XW) \geq
0\\
  \Rightarrow I(XY;Z|W) \geq I(X;Z|W)\)</span></li>
</ul></li>
</ol>
<h3 id="数据处理不等式-1">数据处理不等式</h3>
<ul>
<li><strong>定理</strong>：若 <span class="math inline">\(X \to Y \to
Z\)</span> 构成马尔可夫链，则有 <span class="math inline">\(I(X;Y) \geq
I(X;Z)\)</span>。
<ul>
<li><strong>证明</strong>：<span class="math display">\[
  \begin{align*}
  &amp;\because I(X;YZ) = I(X;Y) + I(X;Z|Y)= I(X;Z) + I(X;Y|Z)\\
  &amp;\therefore I(X;Y)= I(X;Z) + I(X;Y|Z) - I(X;Z|Y)\\
  &amp;又\because 马尔可夫链 X \to Y \to Z 中，I(X;Z|Y) = 0 且 I(X;Y|Z)
\geq 0\\
  &amp;\therefore I(X;Y) \geq I(X;Z)，同理 I(Y;Z) \geq I(X;Z)
  \end{align*}    
  \]</span></li>
</ul></li>
<li><strong>三变量马尔可夫链的信息图</strong>
<ul>
<li>对于马尔可夫链 <span class="math inline">\(X \to Y \to Z\)</span>
，其信息图及相关性质如下：
<ul>
<li><figure>
<img src="image-5.webp" srcset="/img/loading/loading3.gif" lazyload alt="三变量马尔可夫链的信息图">
<figcaption aria-hidden="true">三变量马尔可夫链的信息图</figcaption>
</figure></li>
</ul></li>
<li><strong>相关等式与性质</strong>：
<ul>
<li><span class="math inline">\(a_1\)</span> ：条件熵 <span class="math inline">\(H(X|Y) = H(X|Y, Z)\)</span> 。</li>
<li><span class="math inline">\(a_2\)</span> ：条件互信息 <span class="math inline">\(I(X;Y|Z)\)</span> 。</li>
<li><span class="math inline">\(a_3\)</span> ：互信息<span class="math inline">\(I(X;Z) = I(X;Y;Z)= I(X;Y)- I(X;Y|Z) \geq
0\)</span> 。</li>
<li><span class="math inline">\(a_4\)</span> ：条件熵 <span class="math inline">\(H(Y|X, Z)\)</span> 。</li>
<li><span class="math inline">\(a_5\)</span> ：条件互信息 <span class="math inline">\(I(Y;Z|X)\)</span> 。</li>
<li><span class="math inline">\(a_6\)</span> ：条件熵 <span class="math inline">\(H(Z|Y)= H(Z|Y, X)\)</span> 。</li>
</ul></li>
<li>由此可见，在马尔可夫链的信息图中，每个不相交的区域值都大于等于 0
。</li>
</ul></li>
<li>例题：<img src="image-116.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul>
<h3 id="费诺不等式">费诺不等式</h3>
<h4 id="定义-1">定义</h4>
<ul>
<li><figure>
<img src="image-6.webp" srcset="/img/loading/loading3.gif" lazyload alt="定义">
<figcaption aria-hidden="true">定义</figcaption>
</figure>
<ul>
<li>信源发出<span class="math inline">\(X\)</span>，信宿收到<span class="math inline">\(Y\)</span>，作出判决：认为<span class="math inline">\(X\)</span>传出的是<span class="math inline">\(\hat{X}\)</span></li>
<li>已知 <span class="math inline">\(p(X, Y)\)</span>，<span class="math inline">\(\hat{X}\)</span> 是 <span class="math inline">\(Y\)</span> 的函数 <span class="math display">\[
  \begin{align*}
  \hat{X}(y)&amp;=\arg\underset{x_{i}}{\max} p(x_{i}|y)\\
  &amp;=\arg\underset{x_{i}}{\max} \frac{p(x_{i}|y)p(y)}{p(y)}\\
  &amp;=\arg\underset{x_{i}}{\max} p(x_{i}, y)
  \end{align*}
  \]</span></li>
<li>设 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(\hat{X}\)</span> 取值空间同为 <span class="math inline">\(\mathcal{X}\)</span>，<span class="math inline">\(|\mathcal{X}|\)</span> 表示取值个数。</li>
</ul></li>
<li><strong>定义错误概率</strong> <span class="math inline">\(P_e =
\Pr\{X \neq \hat{X}\}\)</span>。
<ul>
<li>若 <span class="math inline">\(P_e = 0\)</span>，即 <span class="math inline">\(X = \hat{X}\)</span> 以概率 1 成立，<span class="math inline">\(H(X|\hat{X}) = 0\)</span>。</li>
<li>这里讨论 <span class="math inline">\(P_e \neq 0\)</span> 时，<span class="math inline">\(P_e\)</span> 和 <span class="math inline">\(H(X|\hat{X})\)</span> 之间的关系。</li>
</ul></li>
<li><strong>例题</strong>： <img src="image-117.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul>
<h4 id="费诺不等式-1">费诺不等式</h4>
<ul>
<li>设 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(\hat{X}\)</span> 取值空间同为 <span class="math inline">\(\mathcal{X}\)</span> 的随机变量，则有 <span class="math display">\[H(X|\hat{X}) \leq H(P_e)+ P_e
\log(|\mathcal{X}|-1)\]</span> 其中 <span class="math inline">\(H(P_e)=H(P_e, 1 - P_e)\)</span>
为二元熵函数，<span class="math inline">\(|\mathcal{X}|\)</span> 为
<span class="math inline">\(X\)</span> 和 <span class="math inline">\(\hat{X}\)</span> 的取值数量。</li>
<li><strong>证明1</strong>: 定义随机变量 <span class="math inline">\(Z =
\begin{cases}0, &amp; 若 X = \hat{X} \\ 1, &amp; 若 X \neq \hat{X}
\end{cases}\)</span> ，则 <span class="math inline">\(P_r(Z) =
\begin{cases}1 - P_e, &amp; 若 Z = 0 \\ P_e, &amp; 若 Z = 1
\end{cases}\)</span>，则<span class="math inline">\(H(Z)=H(P_e, 1 -
P_e)=H(P_e)\)</span> 由于 <span class="math inline">\(Z\)</span> 是
<span class="math inline">\(X\)</span> 和 <span class="math inline">\(\hat{X}\)</span> 的函数，有 <span class="math inline">\(H(Z|X\hat{X}) = 0\)</span> ，则 <span class="math display">\[
  \begin{align*}
  H(X|\hat{X})&amp;=H(X|\hat{X})+H(Z|X\hat{X})\\
  &amp;=H(XZ|\hat{X})\\
  &amp;=H(Z|\hat{X})+H(X|Z\hat{X})\\
  &amp;\leq H(Z)+H(X|\hat{X}Z)\\
  &amp;=H(Z)+\Pr(Z = 0)H(X|\hat{X}, Z = 0)+\Pr(Z = 1)H(X|\hat{X}, Z =
1)\\
  &amp;=H(Z)+\Pr(Z = 1)H(X|\hat{X}, Z = 1)\\
  &amp;\leq H(P_e)+P_e\log(|\mathcal{X}|-1) （其中H(X|\hat{X}, Z = 1)
\leq \log(|\mathcal{X}|-1)）
  \end{align*}
  \]</span> 因为 <span class="math inline">\(X \to Y \to
\hat{X}\)</span> 构成马尔可夫链， 所以 <span class="math inline">\(I(X;Y) \geq I(X;\hat{X})\)</span>， 进而 <span class="math inline">\(H(X)-H(X|Y) \geq H(X)-H(X|\hat{X})\)</span>， 即
<span class="math inline">\(H(X|Y) \leq H(X|\hat{X})\)</span>。</li>
<li><strong>证明2</strong>（不等式放缩）：见<a href="./Ch6sup_信道编码定理.md/#译码错误与信道条件的关系">译码错误与信道条件的关系</a>，其中令
<span class="math inline">\(Y = \hat{X}\)</span>，<span class="math inline">\(n = |\mathcal{X}|\)</span></li>
</ul>
<h4 id="费诺不等式一般形式">费诺不等式（一般形式）</h4>
<ul>
<li><p>对于任何满足 <span class="math inline">\(X \to Y \to
\hat{X}\)</span> 的估计量 <span class="math inline">\(\hat{X}\)</span>，设 <span class="math inline">\(P_e = \Pr(X \neq \hat{X})\)</span>，有： <span class="math display">\[H(X|Y) \leq H(X|\hat{X}) \leq H(P_e)+ P_e
\log(|\mathcal{X}|-1)\]</span> 其中 <span class="math inline">\(\mathcal{X}\)</span> 为 <span class="math inline">\(X\)</span> 的取值空间。</p></li>
<li><p>上述不等式可以减弱为： <span class="math display">\[H(X|Y) \leq 1
+ P_e \log|\mathcal{X}|\]</span> 或者 <span class="math display">\[P_e
\geq \frac{H(X|Y) - 1}{\log|\mathcal{X}|}\]</span></p></li>
<li><p><strong>推论</strong>：对于任意两个随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span>，设 <span class="math inline">\(p =
\Pr(X \neq Y)\)</span>，有 <span class="math display">\[H(X|Y) \leq
H(p)+ p \log|\mathcal{X}|\]</span> 在费诺不等式中令 <span class="math inline">\(\hat{X} = Y\)</span>，即可得到上式。</p></li>
</ul>
<h4 id="其他不等式">其他不等式</h4>
<ul>
<li><p>设 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(X'\)</span> 为两个相互独立的随机变量，且 <span class="math inline">\(X \sim p(x)\)</span>，<span class="math inline">\(X' \sim r(x)\)</span>，那么 <span class="math inline">\(X = X'\)</span> 的概率为 <span class="math inline">\(\Pr(X = X')=\sum_{x}
p(x)r(x)\)</span>，有如下不等式：</p>
<ol type="1">
<li>如果 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(X'\)</span> 独立同分布，具有相同的熵 <span class="math inline">\(H(X)\)</span>，则 <span class="math inline">\(X =
X'\)</span> 的概率为 <span class="math inline">\(\Pr(X =
X')=\sum_{x} p^2(x)\)</span>，且有 <span class="math display">\[\Pr(X = X') \geq 2^{-H(X)}\]</span> 当且仅当
<span class="math inline">\(X\)</span> 服从均匀分布，等号成立。
<ul>
<li><strong>证明</strong>： 假定 <span class="math inline">\(X \sim
p(x)\)</span>，由Jensen不等式，令 <span class="math inline">\(f(y) =
2^y\)</span> 为下凸函数。 则 <span class="math inline">\(f(E(Y)) \leq
E(f(Y))\)</span> ，令 <span class="math inline">\(y=\log
p(x)\)</span>，则有： <span class="math display">\[
  \begin{align*}
  2^{-H(X)}&amp;=2^{\sum_{x} p(x)\log p(x)}\\
  &amp;\leq \sum_{x} p(x)2^{\log p(x)}\\
  &amp;=\sum_{x} p(x)p(x)\\
  &amp;=\sum_{x} p^2(x)\\
  &amp;=\Pr(X = X')
  \end{align*}
  \]</span> 所以 <span class="math inline">\(2^{-H(X)} \leq \Pr(X =
X')\)</span> ，当且仅当 <span class="math inline">\(X\)</span>
服从均匀分布时，Jensen不等式取等，上式等号成立。</li>
</ul></li>
<li>设 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(X'\)</span> 相互独立，且 <span class="math inline">\(X \sim p(x)\)</span>，<span class="math inline">\(X' \sim r(x)\)</span>，<span class="math inline">\(x,x' \in \mathcal{X}\)</span>，则 <span class="math display">\[
\Pr(X = X') \geq 2^{-H(p)-D(p||r)}\\
\Pr(X = X') \geq 2^{-H(r)-D(r||p)}
\]</span>
<ul>
<li><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  2^{-H(p)-D(p||r)}&amp;=2^{\sum p(x)\log p(x)+\sum p(x)\log
\frac{r(x)}{p(x)}}\\
  &amp;=2^{\sum p(x)\log r(x)}\\
  &amp;\leq \sum p(x)2^{\log r(x)}\\
  &amp;=\sum p(x)r(x)\\
  &amp;=\Pr(X = X')
  \end{align*}
  \]</span></li>
</ul></li>
</ol></li>
<li><p><strong>例题</strong>：<img src="image-118.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h2 id="离散序列信源的熵">2.4 离散序列信源的熵</h2>
<h3 id="离散无记忆信源的序列熵">离散无记忆信源的序列熵</h3>
<ul>
<li><p>随机序列<span class="math inline">\(\vec{X_{}}=(X_1, X_2, \cdots,
X_L)\)</span>，其中<span class="math inline">\(X_l \in \{x_1, x_2,
\cdots, x_n\}\)</span>，<span class="math inline">\(l = 1, 2, \cdots,
L\)</span></p></li>
<li><p><span class="math inline">\(p(\vec{X_{}}=\vec{x_{i}}) = p(X_1 =
x_{i1}, X_2 = x_{i2}, \cdots, X_L = x_{iL})\)</span>，这里<span class="math inline">\(i = 1, 2, \cdots, n^L\)</span>，<span class="math inline">\(i_l = 1, 2, \cdots, n\)</span></p></li>
<li><p><strong>定义信息熵<span class="math inline">\(H(\vec{X_{}})\)</span>为</strong>： <span class="math display">\[
  \begin{align*}
  H(\vec{X_{}}) &amp;= -\sum_{i = 1}^{n^L}p(\vec{x_{i}})\log
p(\vec{x_{i}})\\
  &amp;=-\sum_{i_1 = 1}^{n}\sum_{i_2 = 1}^{n}\cdots\sum_{i_L =
1}^{n}p(x_{i1}, x_{i2}, \cdots, x_{iL})\log p(x_{i1}, x_{i2}, \cdots,
x_{iL})
  \end{align*}
  \]</span></p></li>
<li><p><span class="math display">\[
\begin{align*}
p(\vec{X_{}}=\vec{x_{i}})&amp;=p(x_{i1}, x_{i2}, \cdots, x_{iL})\\
&amp;=p(x_{i1})p(x_{i2}|x_{i1})p(x_{i3}|x_{i1}x_{i2})\cdots
p(x_{iL}|x_{i1}x_{i2}\cdots x_{iL - 1})\\
&amp;\overset{无记忆}{=}p(x_{i1})p(x_{i2})\cdots p(x_{iL})
\end{align*}
\]</span> 则 <span class="math display">\[
\begin{align*}
H(\vec{X_{}})&amp;=-\sum_{i_1 = 1}^{n}\sum_{i_2 = 1}^{n}\cdots\sum_{i_L
= 1}^{n}p(x_{i1})p(x_{i2})\cdots p(x_{iL})[\log p(x_{i1})+\log
p(x_{i2})\\
&amp;\quad +\cdots+\log p(x_{iL})]\\
&amp;=-\sum_{i_1 = 1}^{n}p(x_{i1})\sum_{i_2 =
1}^{n}p(x_{i2})\cdots\sum_{i_L = 1}^{n}p(x_{iL})\log p(x_{i1}) \quad
\leftarrow H(X_1)\\
&amp;\quad -\sum_{i_1 = 1}^{n}p(x_{i1})\sum_{i_2 =
1}^{n}p(x_{i2})\cdots\sum_{i_L = 1}^{n}p(x_{iL})\log p(x_{i2}) \quad
\leftarrow H(X_2)\\
&amp;\quad -\cdots\\
&amp;=H(X_1)+H(X_2)+\cdots+H(X_L)\\
&amp;=\sum_{l = 1}^{L}H(X_l)
\end{align*}
\]</span></p></li>
<li><p>若信源是平稳的，即<span class="math inline">\(H(X_1)=H(X_2)=\cdots=H(X_L)=H(X)\)</span>，则<span class="math display">\[H(\vec{X_{}}) = L H(X)\]</span> <strong>用 <span class="math inline">\(H_L(\vec{X_{}})\)</span> 表示长度为 <span class="math inline">\(L\)</span> 的序列平均每个符号的熵</strong>，则
<span class="math display">\[H_L(\vec{X_{}})=\frac{1}{L}H(\vec{X_{}}) =
H(X)\]</span></p></li>
<li><p>例题：<img src="image-119.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h3 id="离散有记忆信源的序列熵">离散有记忆信源的序列熵</h3>
<ul>
<li>长度为 <span class="math inline">\(L\)</span> 的符号序列 <span class="math inline">\(\vec{X_{}}=(X_1,X_2,\cdots,X_L)\)</span> <span class="math display">\[
  \begin{align*}
  H(\vec{X_{}})&amp;=H(X_1,X_2,X_3,\cdots,X_L)\\
  &amp;=H(X_1)+H(X_2|X_1)+H(X_3|X_1X_2)+\cdots+H(X_L|X_1X_2,\cdots,X_{L
- 1})
  \end{align*}
  \]</span></li>
<li>记作 <span class="math display">\[H(\vec{X_{}}) = H(X^L)=\sum_{l =
1}^{L}H(X_l|X^{l - 1})\]</span></li>
<li>平均每个符号的熵 <span class="math display">\[H_L(\vec{X_{}})=\frac{1}{L}H(X^L)\]</span></li>
<li>例题：<img src="image-120.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul>
<h3 id="离散平稳信源序列熵">离散平稳信源序列熵</h3>
<h4 id="定义-2">定义</h4>
<ul>
<li><strong>离散平稳信源</strong>：联合概率具有时间推移不变性。 <span class="math display">\[
  p\{X_{i1}=x_1,X_{i2}=x_2,\cdots,X_{iL}=x_L\} = p\{X_{i1 + k}=x_1,X_{i2
+ k}=x_2,\cdots,X_{iL + kh}=x_L\}
  \]</span></li>
</ul>
<h4 id="结论-1">结论</h4>
<ol type="1">
<li><span class="math inline">\(H(X_L|X^{L - 1})\)</span> 是 <span class="math inline">\(L\)</span> 的单调非增函数
<ul>
<li>依据：条件多的熵小于等于条件少的熵，平稳信源联合/条件概率时间推移不变</li>
<li><strong>证明</strong>：<span class="math display">\[
  \begin{align*}
  H(X_L|X_1X_2\cdots X_{L - 1})&amp;\leq H(X_L|X_2X_3\cdots X_{L - 1})\\
  &amp;= H(X_{L - 1}|X_1X_2\cdots X_{L - 2}) \text{（平稳性）}\\
  &amp;\leq H(X_{L - 1}|X_2\cdots X_{L - 2})\\
  &amp;= H(X_{L - 2}|X_1\cdots X_{L - 3})\\
  &amp;\vdots\\
  &amp;\leq H(X_2|X_1)
  \end{align*}
  \]</span></li>
</ul></li>
<li><span class="math inline">\(H_L(\vec{X_{}}) \geq H(X_L|X^{L -
1})\)</span>
<ul>
<li><strong>证明</strong>：<span class="math display">\[
  \begin{align*}
  H_L(\vec{X_{}})&amp;=\frac{1}{L}H(X_1,X_2,\cdots,X_L)\\
  &amp;=\frac{1}{L}\sum_{l = 1}^{L}H(X_l|X^{l - 1})\\
  &amp;=\frac{1}{L}(H(X_1)+H(X_2|X_1)+H(X_3|X_1,X_2)+\cdots+H(X_L|X_1X_2,\cdots,X_{L
- 1}))\\
  &amp;\geq\frac{1}{L}\cdot L\cdot H(X_L|X_1,X_2,\cdots,X_{L - 1})\\
  &amp;= H(X_L|X_1,X_2,\cdots,X_{L - 1})
  \end{align*}
  \]</span></li>
</ul></li>
<li><span class="math inline">\(H_L(\vec{X_{}})\)</span> 是 <span class="math inline">\(L\)</span> 的单调非增函数
<ul>
<li><strong>证明</strong>：<span class="math display">\[
  \begin{align*}
  L H_L(\vec{X_{}})&amp;=H(X_1,X_2,\cdots,X_L)\\
  &amp;=H(X_1,X_2,\cdots,X_{L - 1})+H(X_L|X_1,X_2,\cdots,X_{L - 1})\\
  &amp;=(L - 1)H_{L - 1}(\vec{X_{}})+H(X_L|X_1,X_2,\cdots,X_{L - 1})\\
  &amp;\leq (L - 1)H_{L - 1}(\vec{X_{}})+H_L(\vec{X_{}})\\
  \therefore (L - 1)H_L(\vec{X_{}})&amp;\leq (L - 1)H_{L -
1}(\vec{X_{}})\\
  H_L(\vec{X_{}})&amp;\leq H_{L - 1}(\vec{X_{}})
  \end{align*}
  \]</span></li>
</ul></li>
<li>当 <span class="math inline">\(L \to \infty\)</span> 时，定义<span class="math inline">\(H_{\infty}(\vec{X_{}})\)</span>为<strong>极限熵</strong>，有
<span class="math display">\[
H_{\infty}(\vec{X_{}}) \triangleq \lim_{L \to \infty}
H_{L}(\vec{X_{}})=\lim_{L \to \infty} H(X_L|X_1,X_2,\cdots,X_{L - 1})
\]</span>
<ul>
<li><p><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  H_{L + k}(\vec{X_{}})&amp;=\frac{1}{L + k}[H(X_1,X_2,\cdots,X_{L -
1})+H(X_L|X_1X_2\cdots X_{L - 1})+\\
  &amp;\quad \cdots + H(X_{L + k}|X_1X_2\cdots X_{L + k - 1})]\\
  &amp;\leq\frac{1}{L + k}[H(X_1,X_2,\cdots,X_{L -
1})+H(X_L|X_1X_2\cdots X_{L - 1})+\\
  &amp;\quad H(X_L|X_1X_2,\cdots,X_{L - 1})+\cdots + H(X_L|X_1\cdots
X_{L - 1})]\\
  &amp;=\frac{1}{L + k}H(X_1,X_2,\cdots,X_{L - 1})+\frac{k + 1}{L +
k}H(X_L|X_1,X_2,\cdots,X_{L - 1})
  \end{align*}
  \]</span> 当 <span class="math inline">\(k \to \infty\)</span>
时，<span class="math inline">\(\lim_{k \to \infty} H_{L +
k}(\vec{X_{}}) \leq H(X_L|X_1,X_2,\cdots,X_{L - 1}) \leq
H_{L}(\vec{X_{}})\)</span> 当 <span class="math inline">\(L \to
\infty\)</span> 时，<span class="math inline">\(H_{L}(\vec{X_{}}) = H_{L
+ k}(\vec{X_{}})\)</span>，得到 <span class="math display">\[
  \lim_{L \to \infty} H_{L}(\vec{X_{}})=\lim_{L \to \infty}
H(X_L|X_1,X_2,\cdots,X_{L - 1})
  \]</span></p>
<p>若<span class="math inline">\(H_0(X)\)</span>
为等概率无记忆信源单个符号熵，有 <span class="math display">\[
  H_0(X) \geq H_1(X) \geq H_2(\vec{X_{}}) \geq H_3(\vec{X_{}}) \cdots
\geq H_{\infty}(\vec{X_{}})
  \]</span></p>
<p><strong>只有极限熵最真实地反映信源的实际情况。</strong></p></li>
</ul></li>
</ol>
<h3 id="马尔可夫信源的极限熵">马尔可夫信源的极限熵</h3>
<ul>
<li><p><strong>定义</strong>： <span class="math display">\[
  H_{\infty}(\vec{X_{}})=\lim_{L \to \infty} H_{L}(\vec{X_{}}) = \lim_{L
\to \infty} H(X_L|X_1,X_2,\cdots,X_{L - 1})
  \]</span></p></li>
<li><p>实际常取有限长度 <span class="math inline">\(L\)</span>
下的条件熵 <span class="math inline">\(H(X_L|X^{L - 1})\)</span> 作为
<span class="math inline">\(H_{\infty}(\vec{X_{}})\)</span>
的近似值。</p></li>
<li><p><strong>m阶马尔可夫信源（齐次）的推导</strong> <span class="math display">\[
  p(X_t|X_1,X_2,\cdots,X_{t - 1}) = p(X_t|X_{t - m},\cdots,X_{t - 1})
  \]</span> <span class="math display">\[
  \begin{align*}
  H_{\infty}(\vec{X_{}})&amp;=\lim_{L \to \infty}
H(X_L|X_1,X_2,\cdots,X_{L - 1}) \\
  &amp;= \lim_{L \to \infty} H(X_L|X_{L - m},\cdots,X_{L - 1})\\
  &amp;=H(X_{m + 1}|X_1,X_2,\cdots,X_m)
  \end{align*}
  \]</span></p>
<p>对于齐次、稳定马尔可夫链，其状态 <span class="math inline">\(s_i\)</span> 由 <span class="math inline">\((x_{i1},x_{i2},\cdots,x_{im})\)</span>
唯一确定，所以 <span class="math display">\[
  p(x_{i_{m + 1}}|x_{i1},x_{i2},\cdots,x_{im}) = p(x_{i_{m + 1}}|s_i)
  \]</span></p>
<p>上式两边同时取对数，并对 <span class="math inline">\(x_{i1},\cdots,x_{im},x_{i_{m + 1}}\)</span> 和
<span class="math inline">\(s_i\)</span> 取统计平均，再取负，得到：</p>
<p><span class="math display">\[
  \begin{align*}
  \mathbf{Left}&amp;=-\sum_{i_1,\cdots,i_{m + 1}}
p(x_{i1},x_{i2},\cdots,x_{im},x_{i_{m + 1}},s_i) \log p(x_{i_{m +
1}}|x_{i1},x_{i2},\cdots,x_{im})\\
  &amp;=-\sum_{i_1,\cdots,i_{m + 1}} p(x_{i1},\cdots,x_{i_{m + 1}}) \log
p(x_{i_{m + 1}}|x_{i1},\cdots,x_{im})\\
  &amp;=H(X_{m + 1}|X_1,X_2,\cdots,X_m)\\
  &amp;=H_{\infty}(\vec{X_{}})\\
  \mathbf{Right}&amp;=-\sum_{i_1,\cdots,i_{m + 1};i}
p(x_{i1},x_{i2},\cdots,x_{i_{m + 1}},s_i) \log p(x_{i_{m + 1}}|s_i)\\
  &amp;=-\sum_{i_1,\cdots,i_{m + 1};i}
p(x_{i1},x_{i2},\cdots,x_{im},s_i) p(x_{i_{m +
1}}|x_{i1},x_{i2},\cdots,x_{im},s_i) \log p(x_{i_{m + 1}}|s_i)\\
  &amp;=-\sum_{i_{m + 1}} \sum_{i} p(s_i) p(x_{i_{m + 1}}|s_i) \log
p(x_{i_{m + 1}}|s_i)\\
  &amp;=\sum_{i} p(s_i) \sum_{i_{m + 1}} p(x_{i_{m + 1}}|s_i) \log
\frac{1}{p(x_{i_{m + 1}}|s_i)}\\
  &amp;=\sum_{i} p(s_i) H(X|s_i)
  \end{align*}
  \]</span></p>
<p><span class="math display">\[
  \begin{align*}
  \therefore H_{\infty}(\vec{X_{}}) &amp;= \sum_{i} p(s_i) H(X|s_i)\\
  H(X|s_i)&amp;=-\sum_{j} p(x_j|s_i)\log p(x_j|s_i) \\
  &amp;= -\sum_{j} p(s_j|s_i)\log p(s_j|s_i)
  \end{align*}
  \]</span></p></li>
<li><p>例题： <img src="image-10.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h2 id="连续信源的熵和互信息">2.5 连续信源的熵和互信息</h2>
<h3 id="微分熵连续信源熵">微分熵（连续信源熵）</h3>
<ul>
<li>详见 <strong><a href="Ch2sup_微分熵.md">第二章补充微分熵</a></strong></li>
<li>微分熵即连续信源熵，记作 <span class="math inline">\(h(X)\)</span>
或 <span class="math inline">\(H_c(X)\)</span> 。</li>
</ul>
<h3 id="幅度连续的单符号信源">幅度连续的单符号信源</h3>
<h4 id="连续信源熵">连续信源熵</h4>
<ul>
<li><strong>定义</strong>：
<ul>
<li>用n个离散变量逼近连续变量，概率密度函数为 <span class="math inline">\(P_X(x)\)</span>
<ul>
<li><figure>
<img src="image-8.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
</ul></li>
<li>设 <span class="math inline">\(p(x_i)=\int_{a+(i - 1)\Delta x}^{a +
i\Delta x}P_X(x)dx=P_X(x_i)\Delta x\)</span></li>
<li>离散熵 <span class="math display">\[H_n(X)=-\sum_{i =
1}^{n}p(x_i)\log p(x_i)=-\sum_{i = 1}^{n}P_X(x_i)\Delta x\log
(P_X(x_i)\Delta x)\]</span></li>
<li>当 <span class="math inline">\(n\to\infty\)</span>，<span class="math inline">\(\Delta x\to0\)</span> 时： <span class="math display">\[
  H(X)=\lim_{n\to\infty}H_n(X)=-\int_{a}^{b}P_X(x)\log
P_X(x)dx-\lim_{\Delta x\to0}\log\Delta x\int_{a}^{b}P_X(x)dx
  \]</span> 其中 <span class="math inline">\(\int_{a}^{b}P_X(x)dx =
1\)</span> ，后一项趋于无穷大。</li>
<li><strong>定义连续信源熵为</strong> <span class="math display">\[H_c(X)=-\int_{-\infty}^{\infty}P_X(x)\log
P_X(x)dx\]</span></li>
</ul></li>
<li><strong>性质</strong>：
<ul>
<li>连续信源不确定度为无穷大，熵为无穷大，需要无限多位二进制数表示。</li>
<li>连续信源的熵具有相对性（只有相对意义），在取两熵之差时才具有信息的所有特征。</li>
</ul></li>
</ul>
<h4 id="联合熵条件熵和互信息">联合熵、条件熵和互信息</h4>
<ul>
<li><strong>联合熵</strong>： <span class="math display">\[H_c(X,Y)=-\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}P_{X,Y}(x,y)\log
P_{X,Y}(x,y)dxdy\]</span></li>
<li><strong>条件熵</strong>： <span class="math display">\[H_c(Y|X)=-\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}P_{X,Y}(x,y)\log
P_Y(y|x)dxdy\]</span> <span class="math display">\[H_c(X,Y)=H_c(X)+H_c(Y|X)=H_c(Y)+H_c(X|Y)\]</span></li>
<li><strong>互信息</strong>： <span class="math display">\[
  \begin{align*}
  I(X;Y)=I(Y;X)&amp;=H_c(X)-H_c(X|Y)\\
  &amp;=H_c(Y)-H_c(Y|X)\\
  &amp;=H_c(X)+H_c(Y)-H_c(X,Y)
  \end{align*}
  \]</span></li>
</ul>
<h3 id="波形信源的熵">波形信源的熵</h3>
<ul>
<li>平稳随机过程通过采样变换可得到平稳随机序列，例如：
<ul>
<li>随机过程 <span class="math inline">\(x(t)\)</span> 变换为 <span class="math inline">\(\vec{X_{}}(X_1, X_2, \cdots, X_L)\)</span> 。</li>
<li>随机过程 <span class="math inline">\(y(t)\)</span> 变换为 <span class="math inline">\(\vec{Y_{}}(Y_1, Y_2, \cdots, Y_L)\)</span> 。</li>
</ul></li>
<li><figure>
<img src="image-9.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
<li>相关熵的计算公式如下：
<ul>
<li><span class="math inline">\(H_c(\vec{X_{}}) = H_c(X_1, X_2, \cdots,
X_L)=-\int_{\vec{R_{}}} P_{\vec{X_{}}}(\vec{x_{}})\log
P_{\vec{X_{}}}(\vec{x_{}})d\vec{x_{}}\)</span></li>
<li><span class="math inline">\(H_c(\vec{Y_{}}|\vec{X_{}}) = H_c(Y_1,
Y_2, \cdots, Y_L|X_1, X_2, \cdots,
X_L)=-\int_{\vec{R_{}}}\int_{\vec{R_{}}}
P_{\vec{X_{}}\vec{Y_{}}}(\vec{x_{}}, \vec{y_{}})\log
P_{\vec{Y_{}}}(\vec{y_{}}|\vec{x_{}})d\vec{x_{}}d\vec{y_{}}\)</span></li>
</ul></li>
<li>波形信源熵由上述各项的极限表达式（<span class="math inline">\(L \to
\infty\)</span> ）给出：
<ul>
<li><span class="math inline">\(H_c(x(t)) \triangleq \lim_{L \to \infty}
H_c(\vec{X_{}})\)</span></li>
<li><span class="math inline">\(H_c(y(t)|x(t)) \triangleq \lim_{L \to
\infty} H_c(\vec{Y_{}}|\vec{X_{}})\)</span></li>
</ul></li>
<li>对于<strong>限频 <span class="math inline">\(f_m\)</span>，限时
<span class="math inline">\(t_B\)</span></strong> 的平稳随机过程，可用
<span class="math inline">\(L = 2f_mt_B\)</span> 随机矢量表示，且有：
<span class="math display">\[
  \begin{align*}
  H_c(\vec{X_{}}) =&amp; H_c(X_1, X_2, \cdots, X_L)\\
  =&amp;H_c(X_1)+H_c(X_2|X_1)+H_c(X_3|X_1X_2)+\\
  &amp;\cdots+H_c(X_L|X_1,X_2,\cdots,X_{L - 1})\\
  \leq&amp; H_c(X_1)+H_c(X_2)+\cdots + H_c(X_L)
  \end{align*}
  \]</span></li>
</ul>
<h3 id="最大熵定理连续信源">最大熵定理(连续信源)</h3>
<ol type="1">
<li><strong>无限制条件时</strong>：<strong>最大熵为无穷大</strong>。</li>
<li><strong>限峰功率最大熵定理</strong>
<ul>
<li><strong>对于定义域为有限的随机变量 <span class="math inline">\(X\)</span>，当它是均匀分布时，具有最大熵。</strong></li>
<li><span class="math inline">\(X\)</span> 幅度取值限制在 <span class="math inline">\([a, b]\)</span>，有 <span class="math inline">\(\int_{a}^{b}P_X(x)dx = 1\)</span> 。</li>
<li>当 <span class="math inline">\(P_X(x)=\begin{cases}\frac{1}{b -
a},&amp;a\leq x\leq b\\0,&amp;其他\end{cases}\)</span> 时，信息熵最大，
<span class="math display">\[H_c(X)=-\int_{a}^{b}\frac{1}{b -
a}\log\frac{1}{b - a}dx=\log(b - a)\]</span></li>
</ul></li>
<li><strong>限平均功率最大熵定理</strong>
<ul>
<li><p><strong>对于相关矩阵一定的随机变量 <span class="math inline">\(X\)</span>，当它是正态分布时具有最大熵。</strong></p></li>
<li><p>概率密度函数 <span class="math inline">\(P_X(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x -
\mu)^2}{2\sigma^2}}\)</span></p>
<ul>
<li>其中 <span class="math inline">\(\mu\)</span> 为均值，<span class="math inline">\(\sigma^2\)</span> 为方差，<span class="math inline">\(\sigma^2=\int (x-\mu)^2P_X(x)dx\)</span> 。</li>
</ul></li>
<li><p>信息熵 <span class="math inline">\(H_c(X)\)</span>
的计算过程如下： <span class="math display">\[
\begin{align*}
H_c(X)&amp;=-\int_{-\infty}^{+\infty}P_X(x)\log P_X(x)dx\\
&amp;=E[-\log P_X(x)]\\
&amp;=E\left[-\log\frac{1}{\sqrt{2\pi\sigma^2}}-\log e^{-\frac{(x -
m)^2}{2\sigma^2}}\right]\\
&amp;=E\left[\frac{1}{2}\log(2\pi\sigma^2)+\frac{(x -
m)^2}{2\sigma^2}\log e\right]\\
&amp;=\frac{1}{2}\log(2\pi\sigma^2)+\frac{\log e}{2}\\
&amp;=\frac{1}{2}\log(2\pi e\sigma^2)
\end{align*}
\]</span></p></li>
<li><p><strong>证明</strong>： 设 <span class="math inline">\(\varphi(x)\sim N(0,\sigma^2)\)</span>，<span class="math inline">\(g(x)\)</span> 满足 <span class="math inline">\(\int x^2g(x)dx=\sigma^2\)</span> ，因为 <span class="math inline">\(D(g(x)\| \varphi(x))\geq0\)</span>，即： <span class="math display">\[
  \begin{align*}
  D(g(x)\|
\varphi(x))&amp;=\int_{-\infty}^{+\infty}g(x)\log\frac{g(x)}{\varphi(x)}dx\\
  &amp;=\int_{-\infty}^{+\infty}g(x)\log
g(x)dx-\int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx\\
  &amp;=-H_c(g(x))-\int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx\\
  &amp;\geq0\\
  \therefore \quad
H_c(g(x))&amp;\leq-\int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx
  \end{align*}
  \]</span></p>
<p>又因为</p>
<p><span class="math display">\[
  \begin{align*}
  \int_{-\infty}^{+\infty}g(x)\log\varphi(x)dx &amp;=
\int_{-\infty}^{+\infty}g(x)\log\left(\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}\right)dx\\
  &amp;=\int_{-\infty}^{+\infty}g(x)\left[-\frac{1}{2}\log(2\pi\sigma^2)-\frac{x^2}{2\sigma^2}\log
e\right]dx\\
  &amp;=-\frac{1}{2}\log(2\pi\sigma^2)\int_{-\infty}^{+\infty}g(x)dx-\frac{\log
e}{2\sigma^2}\int_{-\infty}^{+\infty}x^2g(x)dx\\
  &amp;=-\frac{1}{2}\log(2\pi e\sigma^2)
  \end{align*}
  \]</span></p>
<p>所以 <span class="math inline">\(H_c(g(x))\leq\frac{1}{2}\log(2\pi
e\sigma^2)=H_c(\varphi(x))\)</span>，当且仅当 <span class="math inline">\(g(x) =
\varphi(x)\)</span>，为正态分布时等号成立。</p></li>
</ul></li>
</ol>
<h2 id="信源的冗余度">2.6 信源的冗余度</h2>
<ul>
<li><p>冗余度也称多余度或剩余度，表示给定信源在实际发出消息时所包含的多余信息。</p></li>
<li><p><strong>例子</strong>：
英文字母26个，加上空格共27个符号，则<strong>单符号最大熵</strong>为
<span class="math display">\[H_0(X)=\log_2{27} \approx 4.76 \text{
bit/符号}\]</span></p>
<p>对英文书中各符号出现的概率加以统计，可得一组数值。若字母间无记忆，有
<span class="math display">\[H_1(X)= - \sum_{i = 1}^{n}p_i\log p_i =
4.03 \text{ bit/符号}\]</span></p>
<p>若考虑2阶、3阶直至高阶平稳信源，有 <span class="math display">\[
  \begin{align*}
  &amp;H_2(X)= 3.32 \text{ bit/符号}\\
  &amp;H_3(X)= 3.1 \text{ bit/符号}\\
  &amp;\cdots\\
  &amp;H_{\infty}(X)=1.4 \text{ bit/符号}\\
  \end{align*}
  \]</span></p>
<p>且满足 <span class="math inline">\(H_{\infty} &lt; \cdots &lt; H_3(X)
&lt; H_2(X) &lt; H_1(X) &lt; H_0(X)\)</span></p>
<p>若发送消息时用 <span class="math inline">\(H_0(X) = 4.76 \text{
bit}\)</span> 表示一个信源符号，则信源效率为 <span class="math display">\[\eta =
\frac{H_{\infty}(X)}{H_0(X)}=\frac{1.4}{4.76}\approx0.29\]</span></p>
<p>冗余度<span class="math display">\[\gamma = 1 - \eta =
0.71\]</span></p>
<p>这是因为符号间的相关性、分布不均匀性</p></li>
<li><p><strong>信源编码</strong>：压缩冗余，提高传输效率</p></li>
<li><p><strong>信道编码</strong>：加入特殊的冗余，抗干扰，提高可靠性</p></li>
</ul>
<h1 id="第二章补充-微分熵">第二章补充 微分熵</h1>
<h2 id="微分熵预备知识">微分熵预备知识</h2>
<h3 id="定义-3">定义</h3>
<ol type="1">
<li><strong>随机变量 <span class="math inline">\(X\)</span> 的均值 <span class="math inline">\(\mu\)</span></strong>：
<ul>
<li>定义为 <span class="math display">\[\mu = E(X)=\int xf(x)dx\]</span>
其中 <span class="math inline">\(f(x)\)</span> 为 <span class="math inline">\(X\)</span> 的概率密度函数。</li>
</ul></li>
<li><strong>随机变量 <span class="math inline">\(X\)</span>
的方差</strong>：
<ul>
<li>定义为 <span class="math display">\[
  \begin{align*}
  Var(X)&amp;=E(X - EX)^2 \\
  &amp;= E(X - \mu)^2\\
  &amp;=E(X^{2}-2X\mu+\mu^{2})\\
  &amp;=E(X^{2})-\mu^{2}
  \end{align*}
  \]</span></li>
</ul></li>
<li><strong>两个随机变量 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 之间的协方差</strong>：
<ul>
<li>定义为 <span class="math display">\[Cov(X,Y)=E(X - EX)(Y -
EY)=E(XY)-\mu_X\mu_Y\]</span></li>
</ul></li>
<li><strong>对于随机变量 <span class="math inline">\(\vec{X_{}}=[X_1,X_2,\cdots,X_n]^T\)</span>（列向量）</strong>：
<ul>
<li>其<strong>协方差矩阵</strong>定义为 <span class="math display">\[K_{\vec{X_{}}}=E(\vec{X_{}}-E\vec{X_{}})(\vec{X_{}}-E\vec{X_{}})^T
= [Cov(X_i,X_j)]\]</span></li>
<li>其<strong>相关矩阵</strong>定义为 <span class="math display">\[\widetilde{K}_{\vec{X_{}}}=E(\vec{X_{}}\vec{X_{}}^T)=[E(X_iX_j)]\]</span></li>
<li>若 <span class="math inline">\(E(\vec{X_{}})=\vec{\mu_{}}=\vec{0_{}}\)</span>，则
<span class="math inline">\(K_{\vec{X_{}}}=\widetilde{K}_{\vec{X_{}}}\)</span></li>
</ul></li>
<li><strong>高斯分布</strong></li>
</ol>
<ul>
<li><p>令 <span class="math inline">\(N(\mu,\sigma^{2})\)</span>
表示均值为 <span class="math inline">\(\mu\)</span>，方差为 <span class="math inline">\(\sigma^{2}\)</span>
的<strong>高斯（正态）分布</strong>，即它的概率密度函数为 <span class="math display">\[f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{(x
- \mu)^{2}}{2\sigma^{2}}}\]</span></p></li>
<li><p>令 <span class="math inline">\(N(\vec{\mu_{}},K)\)</span>
表示均值为 <span class="math inline">\(\vec{\mu_{}}\)</span>，协方差矩阵为 <span class="math inline">\(K\)</span>
的<strong>多元高斯分布</strong>，即对所有的 <span class="math inline">\(\vec{x_{}}\in R^n\)</span>，其联合概率密度函数为
<span class="math display">\[f(\vec{x_{}})=\frac{1}{(\sqrt{2\pi})^n|K|^{\frac{1}{2}}}e^{-\frac{1}{2}(\vec{x_{}}-\vec{\mu_{}})^TK^{-1}(\vec{x_{}}-\vec{\mu_{}})}\]</span></p>
<p>其中 <span class="math inline">\(|K|\)</span> 表示 <span class="math inline">\(K\)</span> 的行列式值，<span class="math inline">\(K\)</span> 是正定对称矩阵。</p></li>
</ul>
<h3 id="基本结论">基本结论</h3>
<ul>
<li>以下是关于矩阵和随机变量的线性变换的基本结论。所有的量和相关矩阵都假定为实值</li>
</ul>
<h4 id="定义-4">定义</h4>
<ul>
<li><strong>定义（对称矩阵）</strong>：如果 <span class="math inline">\(K^T = K\)</span>，则称矩阵 <span class="math inline">\(K\)</span> 是对称的。</li>
<li><strong>定义（正定矩阵）</strong>：
<ul>
<li>一个 <span class="math inline">\(n\times n\)</span> 矩阵 <span class="math inline">\(K\)</span>，如果对所有非零 <span class="math inline">\(n\)</span> 维列向量 <span class="math inline">\(\vec{x_{}}\)</span>，<span class="math inline">\(\vec{x_{}}^TK\vec{x_{}}&gt;0\)</span>
成立，则称矩阵 <span class="math inline">\(K\)</span> 为正定的；</li>
<li>如果对所有 <span class="math inline">\(n\)</span> 维列向量 <span class="math inline">\(\vec{x_{}}\)</span>，<span class="math inline">\(\vec{x_{}}^TK\vec{x_{}}\geq0\)</span>
成立，则称矩阵 <span class="math inline">\(K\)</span> 为半正定的。</li>
</ul></li>
</ul>
<h4 id="命题">命题</h4>
<ol type="1">
<li><strong>命题1</strong>：
<ul>
<li><strong>协方差（相关）矩阵是对称且半正定的。</strong></li>
<li>如果矩阵 <span class="math inline">\(K\)</span>
是对称的，则它可以对角化为 <span class="math inline">\(K = Q\Lambda
Q^T\)</span>。 其中，<span class="math inline">\(\Lambda\)</span>
是对角矩阵，<span class="math inline">\(Q\)</span> 和 <span class="math inline">\(Q^T\)</span> 是正交矩阵，即 <span class="math inline">\(Q^{-1}=Q^T\)</span>，<span class="math inline">\(\vert Q\vert=\vert Q^T\vert = 1\)</span>，<span class="math inline">\(QQ^T = I\)</span>。 <span class="math display">\[KQ=(Q\Lambda Q^T)Q =
Q\Lambda(Q^TQ)=Q\Lambda\]</span> 令 <span class="math inline">\(\lambda_i\)</span> 表示 <span class="math inline">\(\Lambda\)</span> 的第 <span class="math inline">\(i\)</span> 个对角元素，<span class="math inline">\(\vec{q_{i}}\)</span> 表示 <span class="math inline">\(Q\)</span> 的第 <span class="math inline">\(i\)</span> 列，则： <span class="math display">\[
\begin{align*}
&amp;K[\vec{q_{1}},\vec{q_{2}},\cdots,\vec{q_{n}}]=[\vec{q_{1}},\vec{q_{2}},\cdots,\vec{q_{n}}]\begin{bmatrix}\lambda_1&amp;
&amp; \\ &amp;\ddots&amp; \\ &amp; &amp;\lambda_n\end{bmatrix}\\
&amp;K\vec{q_{i}}=\lambda_i\vec{q_{i}}
\end{align*}
\]</span> 即 <span class="math inline">\(\vec{q_{i}}\)</span> 是矩阵
<span class="math inline">\(K\)</span> 对应于特征值 <span class="math inline">\(\lambda_i\)</span> 的特征向量。</li>
</ul></li>
<li><strong>命题2</strong>：
<ul>
<li><p><strong>半正定矩阵的特征值是非负的</strong>。</p></li>
<li><p><strong>证明</strong>： 令 <span class="math inline">\(K\)</span>
表示一个半正定矩阵，<span class="math inline">\(\vec{u_{}}\)</span>
是矩阵 <span class="math inline">\(K\)</span> 对应于特征值 <span class="math inline">\(\lambda\)</span> 的特征向量，即 <span class="math display">\[K\vec{u_{}}=\lambda\vec{u_{}}\]</span></p>
<p>由于 <span class="math inline">\(K\)</span> 是半正定的，有 <span class="math display">\[\vec{u_{}}^TK\vec{u_{}}=\vec{u_{}}^T\lambda\vec{u_{}}=\lambda\vec{u_{}}^T\vec{u_{}}\geq0\]</span></p>
<p>又因为 <span class="math inline">\(\vec{u_{}}^T\vec{u_{}}&gt;0\)</span>，所以有 <span class="math inline">\(\lambda\geq0\)</span>。</p></li>
</ul></li>
<li><strong>命题3</strong>：
<ul>
<li>令 <span class="math inline">\(\vec{Y_{}} =
A\vec{X_{}}\)</span>，其中 <span class="math inline">\(\vec{X_{}}\)</span> 和 <span class="math inline">\(\vec{Y_{}}\)</span>
均为由几个随机变量构成的列向量，<span class="math inline">\(A\)</span>
是 <span class="math inline">\(m\times n\)</span> 矩阵，则 <span class="math display">\[K_{\vec{Y_{}}} = AK_{\vec{X_{}}}A^T\]</span> 且
<span class="math display">\[\widetilde{K}_{\vec{Y_{}}} =
A\widetilde{K}_{\vec{X_{}}}A^T\]</span></li>
<li><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  K_{\vec{Y_{}}}&amp;=E(\vec{Y_{}}-E\vec{Y_{}})(\vec{Y_{}}-E\vec{Y_{}})^T\\
  &amp;=E[A(\vec{X_{}}-E\vec{X_{}})][A(\vec{X_{}}-E\vec{X_{}})]^T\\
  &amp;=E[A(\vec{X_{}}-E\vec{X_{}})(\vec{X_{}}-E\vec{X_{}})^TA^T]\\
  &amp;=A[E(\vec{X_{}}-E\vec{X_{}})(\vec{X_{}}-E\vec{X_{}})^T]A^T\\
  &amp;=AK_{\vec{X_{}}}A^T
  \end{align*}
  \]</span></li>
</ul></li>
<li><strong>命题4</strong>
<ul>
<li><p>设<span class="math inline">\(\vec{X_{}}\)</span>和<span class="math inline">\(\vec{Y_{}}\)</span>均为由<span class="math inline">\(n\)</span>个随机变量构成的列向量，且满足<span class="math display">\[\vec{Y_{}} = Q^T\vec{X_{}}\]</span> 其中<span class="math inline">\(Q\Lambda Q^T\)</span>是<span class="math inline">\(K_{\vec{X_{}}}\)</span>（<span class="math inline">\(\vec{X_{}}\)</span>的协方差矩阵）的一个对角化。则有<span class="math display">\[K_{\vec{Y_{}}}=\Lambda\]</span> 即<span class="math inline">\(\vec{Y_{}}\)</span>中的随机变量是不相关的，且<span class="math inline">\(Var(Y_i)=\lambda_i\)</span>，<span class="math inline">\(\lambda_i\)</span>是<span class="math inline">\(\Lambda\)</span>的第<span class="math inline">\(i\)</span>个对角元素。</p></li>
<li><p><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  K_{\vec{Y_{}}}&amp;=Q^TK_{\vec{X_{}}}Q\\
  &amp;=Q^T(Q\Lambda Q^T)Q\\
  &amp;=(Q^TQ)\Lambda(Q^TQ)\\
  &amp;=\Lambda
  \end{align*}
  \]</span></p></li>
<li><p><strong>推论</strong>：设<span class="math inline">\(\vec{X_{}}\)</span>是由<span class="math inline">\(n\)</span>个随机变量构成的列向量，且<span class="math inline">\(Q\Lambda Q^T\)</span>是<span class="math inline">\(K_{\vec{X_{}}}\)</span>的一个对角化，则<span class="math display">\[\vec{X_{}}=Q\vec{Y_{}}\]</span> 其中<span class="math inline">\(\vec{Y_{}}=Q^T\vec{X_{}}\)</span>是由<span class="math inline">\(n\)</span>个不相关的随机变量构成的列向量。</p>
<ul>
<li>证明： <span class="math display">\[\vec{X_{}}=QQ^T\vec{X_{}}=Q(Q^T\vec{X_{}})=Q\vec{Y_{}}\]</span></li>
</ul></li>
</ul></li>
<li><strong>命题5</strong>
<ul>
<li>设<span class="math inline">\(\vec{X_{}}\)</span>，<span class="math inline">\(\vec{Y_{}}\)</span>和<span class="math inline">\(\vec{Z_{}}\)</span>是由<span class="math inline">\(n\)</span>个随机变量构成的列向量，<span class="math inline">\(\vec{X_{}}\)</span>和<span class="math inline">\(\vec{Z_{}}\)</span>相互独立，且<span class="math inline">\(\vec{Y_{}}=\vec{X_{}}+\vec{Z_{}}\)</span>，则<span class="math display">\[K_{\vec{Y_{}}} = K_{\vec{X_{}}} +
K_{\vec{Z_{}}}\]</span></li>
</ul></li>
<li><strong>命题6</strong>
<ul>
<li>设<span class="math inline">\(\vec{Y_{}}=Q\vec{X_{}}\)</span>，其中<span class="math inline">\(\vec{X_{}}\)</span>和<span class="math inline">\(\vec{Y_{}}\)</span>是由<span class="math inline">\(n\)</span>个随机变量构成的列向量，<span class="math inline">\(Q\)</span>是一个正交矩阵，则<span class="math display">\[E(\sum_{i = 1}^{n}Y_{i}^{2}) = E(\sum_{i =
1}^{n}X_{i}^{2})\]</span> 即随机变量的总能量在正交变换下不变</li>
<li><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  \sum_{i = 1}^{n}Y_{i}^{2}&amp;=\vec{Y_{}}^T\vec{Y_{}}\\
  &amp;=(Q\vec{X_{}})^T(Q\vec{X_{}})\\
  &amp;=\vec{X_{}}^TQ^TQ\vec{X_{}}\\
  &amp;=\vec{X_{}}^T\vec{X_{}}\\
  &amp;=\sum_{i = 1}^{n}X_{i}^{2}
  \end{align*}
  \]</span> 上式两边取期望，得证。</li>
</ul></li>
</ol>
<h2 id="微分熵">微分熵</h2>
<h3 id="微分熵-1">微分熵</h3>
<ol type="1">
<li><p><strong>定义</strong> 一个概率密度函数为 <span class="math inline">\(f(x)\)</span> 的连续随机变量 <span class="math inline">\(X\)</span> 的微分熵 <span class="math inline">\(h(X)\)</span> 定义为 <span class="math display">\[h(X)=-\int_{S} f(x)\log f(x)dx=-E\log
f(x)\]</span></p>
<p>其中 <span class="math inline">\(S\)</span> 为 <span class="math inline">\(X\)</span> 的支撑集，即（<span class="math inline">\(f(x)&gt;0\)</span>，<span class="math inline">\(x\in S\)</span>），<span class="math inline">\(h(x)\)</span>单位为<span class="math inline">\(bit\)</span>。</p></li>
<li><p><strong>均匀分布</strong> 设 <span class="math inline">\(X\sim
U(a,b)\)</span>, 即<span class="math inline">\(X\)</span> 服从 <span class="math inline">\([a,b]\)</span> 上的均匀分布，则 <span class="math display">\[h(X)=-\int_{a}^{b}\frac{1}{b-a}\log\frac{1}{b-a}dx
= \log (b-a)\]</span></p>
<p>若 <span class="math inline">\(b - a &lt; 1\)</span>，则 <span class="math inline">\(h(X)&lt;0\)</span>，因此微分熵可以为负。</p></li>
<li><p><strong>正态分布/高斯分布</strong> 设 <span class="math inline">\(X\sim N(\mu,\sigma^{2})\)</span>，<span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{(x-\mu)^{2}}{2\sigma^{2}}}\)</span>
。 <span class="math display">\[
\begin{align*}
h(X)&amp;=-\int f(x)\log f(x)dx\\
&amp;=-\int
f(x)\left(-\log\sqrt{2\pi\sigma^{2}}-\frac{x^{2}}{2\sigma^{2}}\log
e\right)dx\\
&amp;=\frac{1}{2}\log(2\pi\sigma^{2})\int f(x)dx+\frac{\log
e}{2\sigma^{2}}\int x^{2}f(x)dx\\
&amp;=\frac{1}{2}\log(2\pi\sigma^{2})+\frac{1}{2}\log e\\
&amp;=\frac{1}{2}\log(2\pi e\sigma^{2})
\end{align*}
\]</span></p>
<p>其中 <span class="math display">\[\sigma^{2} = Var(X)=E(X -
E(X))^{2}=\int (x-\mu)^{2}f(x)dx\]</span></p>
<p>若<span class="math inline">\(X\sim N(0,\sigma^{2})\)</span>，<span class="math inline">\(f(x)=\frac{1}{\sqrt{2\pi\sigma^{2}}}e^{-\frac{x^{2}}{2\sigma^{2}}}\)</span>
，则有 <span class="math inline">\(h(X)=\frac{1}{2}\log(2\pi
e\sigma^{2})\)</span> 其中 <span class="math display">\[\sigma^{2} =
Var(X) = \int x^{2}f(x)dx\]</span></p></li>
<li><p><strong>平移性质</strong> <span class="math display">\[h(X +
c)=h(X)\]</span></p>
<ul>
<li><figure>
<img src="image-11.webp" srcset="/img/loading/loading3.gif" lazyload alt="图示">
<figcaption aria-hidden="true">图示</figcaption>
</figure></li>
<li><strong>证明</strong>： 令 <span class="math inline">\(Y = X +
c\)</span>，则 <span class="math inline">\(f_Y(y)=f_X(y - c)\)</span>
，且 <span class="math inline">\(S_Y=\{x + c:x\in S_X\}\)</span> 将
<span class="math inline">\(x = y - c\)</span> 代入下式： <span class="math display">\[
  \begin{align*}
  h(X)&amp;=-\int_{S_X}f_X(x)\log f_X(x)dx\\
  &amp;=-\int_{S_Y}f_X(y - c)\log f_X(y - c)dy\\
  &amp;=-\int_{S_Y}f_Y(y)\log f_Y(y)dy\\
  &amp;=h(Y)\\
  &amp;=h(X + c)
  \end{align*}
  \]</span></li>
</ul></li>
<li><p><strong>缩放性质</strong> <span class="math display">\[对
a\neq0，有h(aX)=h(X)+\log|a|\]</span></p>
<ul>
<li><figure>
<img src="image-12.webp" srcset="/img/loading/loading3.gif" lazyload alt="图示">
<figcaption aria-hidden="true">图示</figcaption>
</figure></li>
<li><strong>证明</strong>： 令 <span class="math inline">\(Y =
aX\)</span>，则 <span class="math inline">\(f_Y(y)=\frac{1}{|a|}f_X(\frac{y}{a})\)</span>，且
<span class="math inline">\(S_Y = \{ax:x\in S_X\}\)</span>。 将 <span class="math inline">\(x = \frac{y}{a}\)</span> 代入 <span class="math inline">\(h(X)\)</span> 的表达式： <span class="math display">\[
  \begin{align*}
  h(X)&amp;=-\int_{S_X}f_X(x)\log f_X(x)dx\\
  &amp;=-\int_{S_Y}f_X(\frac{y}{a})\log f_X(\frac{y}{a})\frac{dy}{|a|}\\
  &amp;=-\int_{S_Y}|a|f_Y(y)\log (f_Y(y)|a|)\frac{1}{|a|}dy\\
  &amp;=-\int_{S_Y}f_Y(y)(\log f_Y(y)+\log|a|)dy\\
  &amp;=-\int_{S_Y}f_Y(y)\log f_Y(y)dy-\log|a|\int_{S_Y}f_Y(y)dy\\
  &amp;=h(Y)-\log|a|\\
  &amp;=h(aX)-\log|a|
  \end{align*}
  \]</span> 移项可得 <span class="math inline">\(h(aX)=h(X)+\log|a|\)</span></li>
<li>示例：<img src="image-103.webp" srcset="/img/loading/loading3.gif" lazyload alt="示例"></li>
</ul></li>
</ol>
<h3 id="联合微分熵条件微分熵及互信息">联合微分熵，条件微分熵及互信息</h3>
<ol type="1">
<li><p><strong>定义（联合微分熵）</strong> 联合概率密度函数为 <span class="math inline">\(f(\vec{x_{}})\)</span> 的随机向量 <span class="math inline">\(\vec{x_{}}\)</span> 的联合微分熵 <span class="math inline">\(h(\vec{x_{}})\)</span> 定义为 <span class="math display">\[h(\vec{x_{}})=-\int_{S}f(\vec{x_{}})\log
f(\vec{x_{}})d\vec{x_{}}=-E\log f(\vec{x_{}})\]</span></p>
<p>如果 <span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>
相互独立，则有 <span class="math display">\[h(\vec{x_{}})=\sum_{i =
1}^{n}h(X_i)\]</span></p></li>
<li><p><strong>平移</strong> 令 <span class="math inline">\(\vec{c_{}}\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span>（<span class="math inline">\(n\)</span> 维实数空间）中的一个列向量，则 <span class="math display">\[h(\vec{x_{}}+\vec{c_{}}) =
h(\vec{x_{}})\]</span></p></li>
<li><p><strong>缩放</strong> 令 <span class="math inline">\(A\)</span>
是一个 <span class="math inline">\(n\times n\)</span> 的非奇异矩阵，则
<span class="math display">\[h(A\vec{x_{}})=h(\vec{x_{}})+\log|\det(A)|\]</span></p></li>
<li><p><strong>多元高斯分布</strong> 设 <span class="math inline">\(\vec{X_{}} \sim N(\vec{\mu_{}},K)\)</span> 。 令
<span class="math inline">\(N(\vec{\mu_{}},K)\)</span> 表示均值为 <span class="math inline">\(\vec{\mu_{}}\)</span>，协方差矩阵为 <span class="math inline">\(K\)</span> 的多元高斯分布，即对于所有 <span class="math inline">\(\vec{x_{}} \in \mathbb{R}^n\)</span>
，其联合概率密度函数为： <span class="math display">\[f(\vec{x_{}}) =
\frac{1}{(\sqrt{2\pi})^n|K|^{\frac{1}{2}}}
e^{-\frac{1}{2}(\vec{x_{}}-\vec{\mu_{}})^T
K^{-1}(\vec{x_{}}-\vec{\mu_{}})}\]</span></p>
<p>其中 <span class="math inline">\(K\)</span> 是正定对称矩阵，<span class="math inline">\(|K|\)</span> 表示 <span class="math inline">\(K\)</span> 的行列式值，<span class="math inline">\(\vec{x_{}},\vec{\mu_{}}\)</span> 为列向量。</p>
<p>其微分熵 <span class="math inline">\(h(\vec{X_{}})\)</span> 为：
<span class="math display">\[h(\vec{X_{}}) = \frac{1}{2} \log[(2\pi
e)^n|K|]\]</span></p>
<p>这里 <span class="math inline">\(|K|\)</span> 为 <span class="math inline">\(K\)</span> 的行列式值。</p>
<ul>
<li><strong>证明</strong>： 设 <span class="math inline">\(K\)</span>
可以对角化为 <span class="math inline">\(Q\Lambda Q^T\)</span> ，记
<span class="math inline">\(\vec{X_{}} = Q\vec{Y_{}}\)</span> ，其中
<span class="math inline">\(\vec{Y_{}}\)</span> 中的随机变量不相关，且有
<span class="math inline">\(Var(Y_i)=\lambda_i\)</span> ，为 <span class="math inline">\(\Lambda\)</span> 中第 <span class="math inline">\(i\)</span> 个对角元素。由于 <span class="math inline">\(\vec{X_{}}\)</span> 是高斯的，所以 <span class="math inline">\(\vec{Y_{}}\)</span> 也是高斯的。又由于 <span class="math inline">\(\vec{Y_{}}\)</span>
中的随机变量是不相关的，可知它们相互独立。 <span class="math display">\[
  \begin{align*}
  h(\vec{X_{}})&amp;=h(Q\vec{Y_{}})\\
  &amp;=h(\vec{Y_{}})+\log|\det(Q)|\\
  &amp;=h(\vec{Y_{}}) + 0\\
  &amp;=\sum_{i = 1}^{n}h(Y_i)\\
  &amp;=\sum_{i = 1}^{n}\frac{1}{2}\log(2\pi e\lambda_i)\\
  &amp;=\frac{1}{2}\log[(2\pi e)^n\prod_{i = 1}^{n}\lambda_i]\\
  &amp;=\frac{1}{2}\log[(2\pi e)^n|\Lambda|]\\
  &amp;=\frac{1}{2}\log[(2\pi e)^n|K|]
  \end{align*}
  \]</span></li>
</ul></li>
<li><p><strong>定义（条件微分熵）</strong> 如果 <span class="math inline">\(X\)</span>，<span class="math inline">\(Y\)</span>
的联合密度函数为 <span class="math inline">\(f(x,y)\)</span>，定义条件微分熵 <span class="math inline">\(h(X|Y)\)</span> 为： <span class="math display">\[h(X|Y)=-\int f(x,y)\log f(x|y)dxdy\]</span></p>
<p>由于 <span class="math inline">\(f(x|y)=f(x,y)/f(y)\)</span>，所以有： <span class="math display">\[h(X|Y)=h(X,Y)-h(Y)\]</span></p></li>
<li><p><strong>定义（相对熵）</strong> 两个密度函数 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 之间的相对熵 <span class="math inline">\(D(f||g)\)</span> 定义为： <span class="math display">\[D(f||g)=\int f\log\frac{f}{g}\]</span></p></li>
<li><p><strong>定义（互信息）</strong> 联合概率密度函数为 <span class="math inline">\(f(x,y)\)</span> 的两个随机变量间的互信息 <span class="math inline">\(I(X;Y)\)</span> 定义为： <span class="math display">\[I(X;Y)=\int
f(x,y)\log\frac{f(x,y)}{f(x)f(y)}dxdy\]</span></p>
<p>显然有：<span class="math display">\[
\begin{align*}
I(X;Y)&amp;=h(X)-h(X|Y)=h(Y)-h(Y|X)\\
&amp;=h(X)+h(Y)-h(X,Y)
\end{align*}
\]</span></p>
<p>以及：<span class="math display">\[I(X;Y)=D(f(x,y)||f(x)f(y))\]</span></p></li>
<li><p><strong>定理：相对熵的非负性</strong> <span class="math display">\[D(f||g) \geq 0\]</span></p>
<ul>
<li><strong>证明</strong>： 设 <span class="math inline">\(f\)</span>
的支撑集是 <span class="math inline">\(S\)</span> <span class="math display">\[
  \begin{align*}
  -D(f||g)&amp;=\int_{S} f \log\frac{g}{f}\\
  &amp;\leq \log\int_{S} f\frac{g}{f} \quad (\text{Jensen 不等式})\\
  &amp;=\log\int_{S} g\\
  &amp;\leq \log 1 = 0
  \end{align*}
  \]</span></li>
<li><strong>推论</strong>：
<ul>
<li><span class="math inline">\(I(X;Y) \geq 0\)</span> ，当且仅当 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 相互独立等号成立。</li>
<li><span class="math inline">\(h(X|Y) \leq h(X)\)</span> 。</li>
</ul></li>
</ul></li>
<li><p><strong>定理(链式法则)</strong> <span class="math display">\[h(X_1,X_2,X_3,\cdots,X_n)=\sum_{i =
1}^{n}h(X_i|X_1,X_2,\cdots,X_{i - 1})\]</span></p>
<ul>
<li><strong>推论</strong>：
<ul>
<li><span class="math inline">\(h(X_1,X_2,\cdots,X_n) \leq \sum_{i =
1}^{n}h(X_i)\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>Hadamard 阿达玛不等式</strong> 设 <span class="math inline">\(\vec{X_{}} \sim N(0,K)\)</span>
是一个多元正态分布。 则有 <span class="math display">\[
\begin{align*}
h(X_1,X_2,\cdots,X_n)&amp;=\frac{1}{2}\log((2\pi e)^n|K|)\\
&amp;\leq \sum_{i = 1}^{n}\frac{1}{2}\log(2\pi e K_{ii})\\
&amp;=\frac{1}{2}\log((2\pi e K_{11} \times 2\pi e K_{22} \times \cdots
\times 2\pi e K_{nn}))
\end{align*}
\]</span></p>
<p>即 <span class="math inline">\(|K| \leq \prod_{i =
1}^{n}K_{ii}\)</span></p>
<ul>
<li>注意有关行列式的不等式可以由信息论中的不等式推导而得到。</li>
</ul></li>
</ol>
<h1 id="第三章-信道与信道容量">第三章 信道与信道容量</h1>
<h2 id="信道的数学模型">3.1 信道的数学模型</h2>
<h3 id="基本数学模型">基本数学模型</h3>
<ul>
<li><figure>
<img src="image-13.webp" srcset="/img/loading/loading3.gif" lazyload alt="数学模型">
<figcaption aria-hidden="true">数学模型</figcaption>
</figure></li>
<li><span class="math inline">\(\vec{X_{}}=(X_1, X_2, \cdots, X_i,
\cdots)\)</span>，<span class="math inline">\(X_i \in A = \{a_1, a_2,
\cdots, a_n\}\)</span>为输入；</li>
<li><span class="math inline">\(\vec{Y_{}}=(Y_1, Y_2, \cdots, Y_j,
\cdots)\)</span>，<span class="math inline">\(Y_j \in B = \{b_1, b_2,
\cdots, b_m\}\)</span>为输出。</li>
<li>用条件概率（转移概率）<span class="math inline">\(p(\vec{Y_{}}|\vec{X_{}})\)</span>来描述输入、输出之间的依赖关系。</li>
</ul>
<h3 id="无干扰信道无噪声">无干扰信道（无噪声）</h3>
<ul>
<li><span class="math inline">\(\vec{Y_{}} =
f(\vec{X_{}})\)</span>，已知<span class="math inline">\(\vec{X_{}}\)</span>就能确知<span class="math inline">\(\vec{Y_{}}\)</span> <span class="math display">\[
  p(\vec{Y_{}}|\vec{X_{}}) =
  \begin{cases}
  1, &amp;\vec{Y_{}} = f(\vec{X_{}}) \\
  0, &amp;\vec{Y_{}} \neq f(\vec{X_{}})
  \end{cases}
  \]</span></li>
<li>例子：
<ul>
<li>当输入<span class="math inline">\(a_1\)</span>对应输出<span class="math inline">\(b_1\)</span>，输入<span class="math inline">\(a_2\)</span>对应输出<span class="math inline">\(b_2\)</span>时，转移概率矩阵<span class="math inline">\(P = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1
\end{bmatrix}\)</span></li>
<li><figure>
<img src="image-14.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="有干扰无记忆信道">有干扰无记忆信道</h3>
<ul>
<li>无记忆：<span class="math display">\[p(\vec{Y_{}}|\vec{X_{}}) =
p(y_1|x_1)p(y_2|x_2)\cdots p(y_l|x_l)\]</span></li>
<li>只需分析单个符号的转移概率<span class="math inline">\(p(y_j|x_i)\)</span></li>
</ul>
<h4 id="二进制离散对称信道binary-symmetric-channelbsc">二进制离散对称信道（Binary
Symmetric Channel，BSC）</h4>
<ul>
<li>输入<span class="math inline">\(X \in A = \{0, 1\}\)</span></li>
<li>输出<span class="math inline">\(Y \in B = \{0, 1\}\)</span></li>
<li>$ BSC
<span class="math display">\[\begin{cases}
p(Y = 0|X = 1) = p(Y = 1|X = 0) = p \\
p(Y = 1|X = 1) = p(Y = 0|X = 0) = 1 - p
\end{cases}\]</span>
$</li>
<li>其中<span class="math inline">\(p\)</span>为错误概率，其转移关系和转移概率矩阵如下：</li>
<li><figure>
<img src="image-15.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
</ul>
<h4 id="离散无记忆信道discrete-memoryless-channeldmc">离散无记忆信道（Discrete
Memoryless Channel，DMC）</h4>
<ul>
<li>输入<span class="math inline">\(X \in \{a_1, a_2, \cdots,
a_n\}\)</span></li>
<li>输出<span class="math inline">\(Y \in \{b_1, b_2, \cdots,
b_m\}\)</span></li>
<li>转移概率矩阵<span class="math inline">\(P = [p(b_j|a_i)] =
[p_{ij}]_{n \times m} =  \begin{bmatrix}
  p_{11} &amp; p_{12} &amp; \cdots &amp; p_{1m} \\
  \vdots &amp; &amp; &amp; \\
  p_{n1} &amp; p_{n2} &amp; \cdots &amp; p_{nm}
  \end{bmatrix}_{n \times m}\)</span></li>
<li>并且满足<span class="math inline">\(\sum_{j = 1}^{m} p(b_j|a_i) =
1\)</span>，<span class="math inline">\(i = 1, 2, \cdots,
n\)</span></li>
<li><figure>
<img src="image-16.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
<li>二进制离散对称信道（BSC）是离散无记忆信道（DMC）的特例</li>
</ul>
<h4 id="离散输入连续输出信道">离散输入、连续输出信道</h4>
<ul>
<li>输入<span class="math inline">\(X \in \{a_1, a_2, \cdots,
a_n\}\)</span></li>
<li>输出<span class="math inline">\(Y \in \{-\infty,
+\infty\}\)</span></li>
<li>信道模型为<span class="math inline">\(Y = X + G\)</span>，其中<span class="math inline">\(G \in \{-\infty, +\infty\}\)</span>，<span class="math inline">\(p_G(n) \sim N(0, \sigma^2)\)</span></li>
<li>条件概率密度<span class="math inline">\(p_Y(y|a_i) \sim N(a_i,
\sigma^2)=\frac{1}{\sqrt{2 \pi \sigma^2}}e^{-\frac{(y -
a_i)^2}{2\sigma^2}}\)</span></li>
<li>图例：<img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"></li>
</ul>
<h4 id="波形信道">波形信道</h4>
<ul>
<li>当 <span class="math inline">\(t_B\)</span>、<span class="math inline">\(f_m\)</span> 受限，<span class="math inline">\(L =
2t_Bf_m\)</span> 时</li>
<li>输入 <span class="math inline">\(\vec{X_{}} = (X_1, X_2, \cdots,
X_L)\)</span></li>
<li>输出 <span class="math inline">\(\vec{Y_{}} = (Y_1, Y_2, \cdots,
Y_L)\)</span></li>
<li><figure>
<img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
<li><strong>时间离散，取值连续的多维连续信道</strong>，信道转移概率密度函数为：
<span class="math display">\[p_Y(\vec{y_{}}|\vec{x_{}}) = p_y
(y_1,y_2,\cdots,y_L | x_1,x_2,\cdots,x_L)\]</span></li>
<li><strong>连续无记忆信道</strong>： <span class="math display">\[p_Y(\vec{y_{}}|\vec{x_{}}) = p_y(y_1 |
x_1)p_y(y_2 | x_2)\cdots p_y(y_L | x_L) = \prod_{l = 1}^{L} p_Y (y_l|
x_l)\]</span></li>
</ul>
<h4 id="因此无记忆时重点讨论单符号信道">因此无记忆时重点讨论单符号信道！</h4>
<ul>
<li><p>信道模型为 <span class="math inline">\(y(t)=x(t)+n(t)\)</span></p></li>
<li><p>其中 <strong><span class="math inline">\(n(t)\)</span>
为加性噪声，与信号 <span class="math inline">\(x(t)\)</span>
相互独立</strong></p></li>
<li><figure>
<img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
<li><p>根据概率关系有： <span class="math display">\[p_{X,Y}(x,y)=p_{X,n}(x,n)=p_X(x)p_n(n)\]</span></p>
<p><span class="math display">\[p_Y(y|x)=\frac{p_{X,Y}(x,y)}{p_X(x)}=\frac{p_{X,n}(x,n)}{p_X(x)}
= p_n(n)\]</span></p></li>
<li><p>进一步考虑条件熵： <span class="math display">\[
  \begin{align*}
  H_c(Y|X)&amp;=-\iint_{R}p_{X,Y}(x,y)\log p_Y(y|x)dxdy\\
  &amp;=-\int_{R}p_X(x)dx\int_{R}p_Y(y|x)\log p_Y(y|x)dy\\
  &amp;=-\int_{R}p_n(n)\log p_n(n)dn\\
  &amp;=H_c(n)
  \end{align*}
  \]</span></p>
<p>条件熵 <span class="math inline">\(H_c(Y|X)\)</span>
称为<strong>噪声熵</strong></p></li>
<li><p>在加性多维连续信道中</p>
<ul>
<li><span class="math display">\[\vec{y_{}}=\vec{x_{}}+\vec{n_{}}\]</span></li>
<li>同理有 <span class="math inline">\(p_{\vec{Y_{}}}(\vec{y_{}}|\vec{x_{}}) =
p_n(\vec{n_{}})\)</span>，<span class="math inline">\(H_c(\vec{y_{}}|\vec{x_{}}) =
H_c(\vec{n_{}})\)</span></li>
</ul></li>
</ul>
<h3 id="有干扰有记忆信道">有干扰有记忆信道</h3>
<blockquote>
<p>略</p>
</blockquote>
<h3 id="信道容量的定义">信道容量的定义</h3>
<ul>
<li>定义信道的<strong>信息传输率 <span class="math inline">\(R\)</span></strong>
为信道中平均每个符号所传输的信息量： <span class="math display">\[
  \begin{align*}
  R=I(X;Y)&amp;=H(X)-H(X|Y)\quad \text{bit}/\text{信道符号}\\
  &amp;=H(Y)-H(Y|X)
  \end{align*}
  \]</span></li>
<li>设 <span class="math inline">\(T\)</span>
为信道中符号的平均传输时间，定义<strong>信息传输速率</strong>： <span class="math display">\[R_t = \frac{R}{T}=\frac{I(X;Y)}{T}\quad
\text{bit}/\text{秒}\]</span>
<ul>
<li><span class="math inline">\(I(X;Y)\)</span> 是输入符号分布概率 <span class="math inline">\(p(a_i)\)</span> 和信道转移概率 <span class="math inline">\(p(b_j|a_i)\)</span> 的函数，即 <span class="math display">\[I(X;Y)=f(p(a_i),p(b_j|a_i))\]</span></li>
</ul></li>
<li>对于某特定信道，<span class="math inline">\(p(b_j|a_i)\)</span>
确定，则 <span class="math inline">\(I(X;Y)\)</span> 是关于 <span class="math inline">\(p(a_i)\)</span> 的凹函数（<span class="math inline">\(\cap\)</span>型上凸函数），也即可以找到某种概率分布
<span class="math inline">\(p(a_i)\)</span>，使 <span class="math inline">\(I(X;Y)\)</span>
达到最大，该最大值为<strong>信道容量</strong>： <span class="math display">\[C = \max_{p(a_i)} I(X;Y)\quad
\text{bit}/\text{符号}\]</span>
<ul>
<li>若符号传送时间周期为 <span class="math inline">\(T\)</span>
秒，则<strong>单位时间信道容量</strong>为： <span class="math display">\[C_t = C/T\quad \text{bit}/\text{秒}\]</span></li>
</ul></li>
<li>对于固定信道参数信道，信道容量是个定值。实际传输时能否提供最大传输能力，取决于输入端的概率分布，定义<strong>信道绝对冗余度和相对冗余度</strong>：
<span class="math display">\[信道绝对冗余度 =C - I(X;Y)\]</span> <span class="math display">\[信道相对冗余度 =1-\frac{I(X;Y)}{C}\]</span></li>
</ul>
<h2 id="离散单个符号信道及其容量">3.2 离散单个符号信道及其容量</h2>
<h3 id="无干扰离散信道">无干扰离散信道</h3>
<ul>
<li>信道输入<span class="math inline">\(X \in
A=\{a_1,a_2,\cdots,a_n\}\)</span></li>
<li>输出<span class="math inline">\(Y \in B =
\{b_1,b_2,\cdots,b_m\}\)</span></li>
</ul>
<h4 id="无噪无损信道n-mxy一一对应">无噪无损信道：n =
m，X、Y一一对应</h4>
<ul>
<li>输入输出关系：<img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload alt="输入输出关系"></li>
<li>转移概率矩阵<span class="math inline">\(P = \{p(y_j|x_i)\} =
  \begin{bmatrix}
  1 &amp; 0 &amp; \cdots \\
  0 &amp; 1 &amp; \cdots \\
  \vdots &amp; \vdots &amp; \ddots &amp;
  \end{bmatrix}\)</span>，<span class="math inline">\(p(x_i|y_j) \in
\{0, 1\}\)</span>。</li>
<li><strong>噪声熵与疑义度</strong>： <span class="math display">\[H(Y|X)=H(X|Y)=0\]</span></li>
<li><strong>互信息</strong>： <span class="math display">\[I(X;Y)=I(Y;X)=H(X)=H(Y)\]</span>
当输入符号等概率分布时，<span class="math inline">\(I(X;Y)\)</span>最大。</li>
<li><strong>信道容量</strong>: <span class="math display">\[C =
\max_{p(a_i)} I(X;Y)=\max_{p(a_i)} H(X)=\log n\]</span></li>
</ul>
<h4 id="无噪有损信道n-m多个x对应一个y">无噪有损信道：n &gt;
m，多个X对应一个Y</h4>
<ul>
<li>输入输出关系：<img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload alt="输入输出关系"></li>
<li>多个输入对应一个输出，即<span class="math inline">\(n &gt;
m\)</span></li>
<li><strong>噪声熵</strong>: <span class="math display">\[H(Y|X)=\sum_{i,j}p(a_i,b_j)\log
p(b_j|a_i)=0\]</span></li>
<li><strong>疑义度</strong>: <span class="math display">\[H(X|Y)=\sum_{i,j}p(a_i,b_j)\log
p(a_i|b_j)\neq0\]</span></li>
<li><strong>互信息</strong>: <span class="math display">\[I(X;Y)=H(X)-H(X|Y)=H(Y)-H(Y|X)=H(Y)\neq0\]</span>
其中<span class="math inline">\(H(Y|X) = 0\)</span>，<span class="math inline">\(H(X|Y)\neq0\)</span> 由此可得<span class="math inline">\(H(X)=H(Y)+H(X|Y)\)</span>，所以<span class="math inline">\(H(X)\geq H(Y)\)</span> 。</li>
<li><strong>信道容量</strong>： <span class="math display">\[C =
\max_{p(a_i)} I(X;Y)=\max_{p(a_i)} H(Y) \overset{?}{=} \log
m\]</span></li>
</ul>
<h4 id="有噪无损信道n-m一个x对应多个y">有噪无损信道：n &lt;
m，一个X对应多个Y</h4>
<ul>
<li>输入输出关系：<img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload alt="输入输出关系"></li>
<li>信道噪声使一个输入对应多个输出，<span class="math inline">\(n &lt;
m\)</span></li>
<li><strong>噪声熵</strong>： <span class="math display">\[H(Y|X)=\sum_{i,j}p(a_i,b_j)\log
p(b_j|a_i)\neq0\]</span></li>
<li><strong>疑义度</strong>： <span class="math display">\[H(X|Y)=\sum_{i,j}p(a_i,b_j)\log
p(a_i|b_j)=0\]</span></li>
<li><strong>互信息</strong>： <span class="math display">\[I(X;Y)=H(X)-H(X|Y)=H(Y)-H(Y|X)=H(X)\neq0\]</span>
其中<span class="math inline">\(H(X|Y) = 0\)</span>，<span class="math inline">\(H(Y|X)\neq0\)</span> 由此可得<span class="math inline">\(H(Y)=H(X)+H(Y|X)\)</span>，所以<span class="math inline">\(H(Y)\geq H(X)\)</span> 。</li>
<li><strong>信道容量</strong>： <span class="math display">\[C =
\max_{p(a_i)} I(X;Y)=\max_{p(a_i)} H(X) = \log n\]</span></li>
</ul>
<h3 id="对称离散无记忆信道">对称离散无记忆信道</h3>
<ul>
<li><p>以下是两个转移概率矩阵示例： <span class="math display">\[
  \begin{bmatrix}
  \frac{1}{3} &amp; \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{6} \\
  \frac{1}{6} &amp; \frac{1}{6} &amp; \frac{1}{3} &amp; \frac{1}{3}
  \end{bmatrix}_{2\times4}
  \quad
  \begin{bmatrix}
  \frac{1}{2} &amp; \frac{1}{3} &amp; \frac{1}{6} \\
  \frac{1}{6} &amp; \frac{1}{2} &amp; \frac{1}{3} \\
  \frac{1}{3} &amp; \frac{1}{6} &amp; \frac{1}{2}
  \end{bmatrix}_{3\times3}
  \]</span></p></li>
<li><p><strong>对称特性判断</strong>：</p>
<ul>
<li>若每一行包含相同元素，称为输入对称</li>
<li>若每一列包含相同元素，称为输出对称</li>
<li>当行列都对称时，为<strong>对称DMC（离散无记忆信道）</strong>。</li>
</ul></li>
<li><p><strong>相关信息论公式</strong>：</p>
<ul>
<li><strong>互信息</strong>: <span class="math display">\[I(X;Y)=H(X)-H(X|Y)=H(Y)-H(Y|X)\]</span></li>
<li><strong>条件熵</strong>: <span class="math display">\[
  \begin{align*}
  H(Y|X)&amp;=-\sum_{i,j} p(a_i, b_j)\log p(b_j|a_i)\\
  &amp;=-\sum_{i,j} p(a_i) p(b_j|a_i)\log p(b_j|a_i)\\
  &amp;=-\sum_{i} p(a_i) \sum_{j} p(b_j|a_i)\log p(b_j|a_i)\\
  &amp;=\sum_{i} p(a_i) H(Y|a_i) （输入对称）\\
  &amp;= H(Y|a_i)，i = 1, 2, \cdots, n
  \end{align*}
  \]</span></li>
<li><strong>信道容量</strong>: <span class="math display">\[C =
\max_{p(a_i)} I(X;Y)=\max_{p(a_i)} H(Y)-H(Y|X)=\max_{p(a_i)}
H(Y)-H(Y|a_i)\]</span></li>
</ul></li>
<li><p>当<strong>输入符号等概率分布</strong>，即<span class="math inline">\(p(a_i)=\frac{1}{n}\)</span>时，设<span class="math inline">\(m\)</span>为输出符号数目，则有：</p>
<ul>
<li><span class="math inline">\(p(b_j)=\sum_{i}
p(a_i)p(b_j|a_i)=\frac{1}{n}\sum_{i} p(b_j|a_i)=\frac{1}{n}\cdot
\frac{n}{m}=\frac{1}{m}\)</span></li>
<li><span class="math inline">\(H(Y)=-\sum_{j} p(b_j)\log
p(b_j)=\sum_{j} \frac{1}{m}\log m=m\frac{1}{m}\log m=\log
m\)</span></li>
<li><strong>信道容量</strong><span class="math display">\[C = \log m -
H(Y|a_i)\]</span></li>
<li>其中<span class="math inline">\(m\)</span>为输出符号<span class="math inline">\(Y\)</span>数目，<span class="math inline">\(i = 1,
\cdots, n\)</span></li>
</ul></li>
<li><p>例题：<img src="image-98.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
<li><p><strong>一般离散无记忆模k加性噪声信道</strong></p>
<ul>
<li>信道模型: <span class="math inline">\(Y = X\oplus Z\bmod
k\)</span>，其中 <span class="math inline">\(X,Y,Z\in\{0,1,\cdots,k -
1\}\)</span></li>
<li>图例:<img src="image-23.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"></li>
<li><strong>加性噪声</strong>，有 <span class="math inline">\(p(y|x)=p(z)\)</span>
<ul>
<li><strong>条件熵</strong>: <span class="math display">\[
  \begin{align*}
  H(Y|X)&amp;=-\sum_{x,y}p(x)p(y|x)\log p(y|x)\\
  &amp;=-\sum_{x,z}p(x)p(z)\log p(z)\\
  &amp;=-\sum_{x}p(x)\sum_{z}p(z)\log p(z)\\
  &amp;=H(Z)
  \end{align*}
  \]</span></li>
<li><strong>信道容量</strong>: <span class="math display">\[
  \begin{align*}
  C&amp;=\max_{p(x)}H(Y)-H(Y|X)\\
  &amp;=\max_{p(x)}H(Y)-H(Z)\\
  &amp;=\log k - H(Z) \quad (\text{对称性})
  \end{align*}
  \]</span></li>
</ul></li>
<li>例题：<img src="image-26.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul></li>
</ul>
<h3 id="准对称离散无记忆信道">准对称离散无记忆信道</h3>
<ul>
<li><p>以下是两个转移概率矩阵示例： <span class="math display">\[P_1=\begin{bmatrix}\frac{1}{3}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{6}\\\frac{1}{6}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{3}\end{bmatrix}_{2\times
4} \quad
P_2=\begin{bmatrix}0.7&amp;0.1&amp;0.2\\0.2&amp;0.1&amp;0.7\end{bmatrix}_{2\times
3}\]</span></p></li>
<li><p><strong>信道特性</strong>：</p>
<ul>
<li>矩阵中<strong>各行元素相同，但各列元素不同</strong>，这种信道称为<strong>准对称DMC（离散无记忆信道）</strong>。</li>
</ul></li>
<li><p><strong>相关信息论公式</strong>：</p>
<ul>
<li><p>因为各行元素相同，所以 <span class="math inline">\(H(Y|X)=H(Y|a_i)\)</span> ，其中 <span class="math inline">\(i = 1,2,\cdots,n\)</span></p>
<ul>
<li>这表明在给定不同输入符号 <span class="math inline">\(a_i\)</span>
时，输出的条件熵是相同的</li>
</ul></li>
<li><p>由于各列元素不同，信道的输入和输出分布概率可以不同，并且 <span class="math inline">\(H(Y)\leq\log m\)</span> （<span class="math inline">\(m\)</span>为输出符号的数目）</p></li>
<li><p><strong>信道容量</strong>： <span class="math display">\[
  \begin{align*}
  C &amp;= \max_{p(x)}[H(Y)-H(Y|X)] \\
  &amp;\leq\log m - H(Y|a_i)\\
  &amp;=\log m+\sum_{j = 1}^{m}p_{ij}\log p_{ij}
  \end{align*}
  \]</span> 其中<span class="math inline">\(i = 1,2,\cdots,n\)</span>
，<span class="math inline">\(p_{ij}\)</span> 是转移概率矩阵中的元素</p>
<ul>
<li>这给出了准对称离散无记忆信道容量的一个<strong>上限估计</strong></li>
<li>求解：<strong>矩阵分解法</strong>、极值求导法</li>
</ul></li>
<li><p>例题：<img src="image-99.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul></li>
</ul>
<h3 id="矩阵分解法">矩阵分解法</h3>
<ul>
<li><strong>转移矩阵分解</strong>：
<ul>
<li>将<strong>准对称</strong>转移概率矩阵<strong>按概率列</strong>分成若干个互不相交的<strong>对称的子集</strong>。例如：
<ul>
<li><span class="math display">\[P_1 =
\begin{bmatrix}\frac{1}{3}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{6}\\\frac{1}{6}&amp;\frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{3}\end{bmatrix}\]</span>
可分解成<span class="math inline">\(\begin{bmatrix}\frac{1}{3}&amp;\frac{1}{6}\\\frac{1}{6}&amp;\frac{1}{3}\end{bmatrix}\)</span>，<span class="math inline">\(\begin{bmatrix}\frac{1}{3}\\\frac{1}{3}\end{bmatrix}\)</span>，<span class="math inline">\(\begin{bmatrix}\frac{1}{6}\\\frac{1}{6}\end{bmatrix}\)</span></li>
<li><span class="math display">\[P_2 =
\begin{bmatrix}0.7&amp;0.1&amp;0.2\\0.2&amp;0.1&amp;0.7\end{bmatrix}\]</span>
可分解成<span class="math inline">\(\begin{bmatrix}0.7&amp;0.2\\0.2&amp;0.7\end{bmatrix}\)</span>
，<span class="math inline">\(\begin{bmatrix}0.1\\0.1\end{bmatrix}\)</span>
。</li>
</ul></li>
</ul></li>
<li><strong>信道容量</strong>：
<ul>
<li>可以证明，当<strong>输入等概率分布</strong>时，可达到信道容量。
<span class="math display">\[C=\log n -
H(P_1',P_2',\cdots,P_m')-\sum_{k = 1}^{r}N_k\log
M_k\]</span></li>
<li>其中：
<ul>
<li><span class="math inline">\(n\)</span>为输入符号个数。</li>
<li><span class="math inline">\(P_1',P_2',\cdots,P_m'\)</span>
是原转移概率矩阵<span class="math inline">\(P\)</span>中一行的元素。</li>
<li><span class="math inline">\(N_k\)</span>是第<span class="math inline">\(k\)</span>个子矩阵中行元素之和。</li>
<li><span class="math inline">\(M_k\)</span>是第<span class="math inline">\(k\)</span>个子矩阵中列元素之和。</li>
<li><span class="math inline">\(r\)</span>是子矩阵个数。</li>
</ul></li>
</ul></li>
<li><strong>例题</strong>：<img src="image-100.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul>
<h3 id="一般离散无记忆信道">一般离散无记忆信道</h3>
<ul>
<li><p><strong>转移概率<span class="math inline">\(p(y|x)\)</span>固定</strong></p></li>
<li><p><strong>信道容量</strong>： <span class="math display">\[C =
\max_{p(x)}I(X;Y)=\max_{p(x)}I(p(x),p(y|x))\]</span></p>
<p>即求互信息<span class="math inline">\(I(X;Y)\)</span>关于输入概率分布<span class="math inline">\(p(x)\)</span>的极大值。</p></li>
<li><p><strong>互信息</strong>： <span class="math display">\[
  \begin{align*}
  I(X;Y)&amp;=\sum_{i}p(a_i)I(a_i;Y)\\
  &amp;=\sum_{i}p(a_i)\sum_{j}p(b_j|a_i)\log\frac{p(a_i|b_j)}{p(a_i)}
  \end{align*}
  \]</span></p></li>
<li><p>为使<span class="math inline">\(I(X;Y)\)</span>达到最大，输入符号概率集<span class="math inline">\(\{p(a_i)\}\)</span>必须满足的<strong>充分和必要条件</strong>是：</p>
<ul>
<li>对于所有<span class="math inline">\(p(a_i)&gt;0\)</span> 的符号<span class="math inline">\(a_i\)</span> ，有<span class="math inline">\(I(a_i;Y)=C\)</span></li>
<li>对于所有<span class="math inline">\(p(a_i)=0\)</span> 的符号<span class="math inline">\(a_i\)</span> ，有<span class="math inline">\(I(a_i;Y)\leq C\)</span></li>
<li>这意味着除概率为0的符号<span class="math inline">\(a_i\)</span>外，每个符号<span class="math inline">\(a_i\)</span> 对<span class="math inline">\(Y\)</span>提供相同的互信息</li>
</ul></li>
<li><p>注意：<strong>最佳输入分布不唯一！</strong></p></li>
<li><p>例题：<img src="image-33.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h2 id="离散序列信道及其容量">3.3 离散序列信道及其容量</h2>
<h3 id="信道模型与符号定义">信道模型与符号定义</h3>
<ul>
<li><figure>
<img src="image-24.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型">
<figcaption aria-hidden="true">信道模型</figcaption>
</figure></li>
<li>输入矢量为<span class="math inline">\(\vec{X_{}}=(X_1,X_2,\cdots,X_L)\)</span>，其中<span class="math inline">\(X_l\in\{a_1,a_2,\cdots,a_n\}\)</span></li>
<li>输出矢量为<span class="math inline">\(\vec{Y_{}}=(Y_1,Y_2,\cdots,Y_L)\)</span>，其中<span class="math inline">\(Y_l\in\{b_1,b_2,\cdots,b_m\}\)</span></li>
<li>条件概率表示为<span class="math inline">\(p(\vec{Y_{}}|\vec{X_{}})\)</span>
，即给定输入<span class="math inline">\(\vec{X_{}}\)</span>时输出<span class="math inline">\(\vec{Y_{}}\)</span>的概率。</li>
</ul>
<h3 id="无记忆离散序列信道">无记忆离散序列信道</h3>
<ul>
<li>对于无记忆离散序列信道： <span class="math display">\[p(\vec{Y_{}}|\vec{X_{}}) =
p(Y_1,\cdots,Y_L|X_1,\cdots,X_L)=\prod_{l = 1}^{L}p(Y_l|X_l)\]</span>
<ul>
<li>若信道是平稳的： <span class="math display">\[p(\vec{Y_{}}|\vec{X_{}})=(p(y|x))^{L}=p^{L}(y|x)\]</span></li>
</ul></li>
<li><strong>互信息与信道容量</strong>: <span class="math display">\[
  \begin{align*}
  I(\vec{X_{}};\vec{Y_{}})&amp;=H(\vec{X_{}}) -
H(\vec{X_{}}|\vec{Y_{}})=\sum
p(\vec{X_{}},\vec{Y_{}})\log\frac{p(\vec{X_{}}|\vec{Y_{}})}{p(\vec{X_{}})}\\
  &amp;=H(\vec{Y_{}}) - H(\vec{Y_{}}|\vec{X_{}})=\sum
p(\vec{X_{}},\vec{Y_{}})\log\frac{p(\vec{Y_{}}|\vec{X_{}})}{p(\vec{Y_{}})}
  \end{align*}
  \]</span>
<ul>
<li><strong>信道无记忆时</strong>： <span class="math display">\[I(\vec{X_{}};\vec{Y_{}})\leq\sum_{l =
1}^{L}I(X_l;Y_l)\]</span>
<ul>
<li>证明： 由定义有：<span class="math inline">\(I(\vec{X_{}};\vec{Y_{}})=H(\vec{Y_{}})-H(\vec{Y_{}}|\vec{X_{}})\)</span>和<span class="math inline">\(I(X_l;Y_l)=H(Y_l)-H(Y_l|X_l)\)</span>，利用<span class="math inline">\(H(X)\)</span>的链式法则有： ①<span class="math inline">\(H(\vec{Y_{}})=H(Y_1,Y_2,\cdots,Y_L)=H(Y_1)+H(Y_2|Y_1)+\cdots+H(Y_L|Y_1,Y_2,\cdots,Y_{L
- 1})\leq \sum_{l = 1}^{L}H(Y_l)\)</span> ②<span class="math inline">\(H(\vec{Y_{}}|\vec{X_{}})=H(Y_1|\vec{X_{}})+H(Y_2|Y_1,\vec{X_{}})+\cdots+H(Y_L|Y_1,Y_2,\cdots,Y_{L
- 1},\vec{X_{}})=\sum_{l =
1}^{L}H(Y_l|X_l)\)</span>（无记忆信道下，给定&nbsp;<span class="math inline">\(X_l\)</span>&nbsp;后，其他时刻的输入输出对确定&nbsp;<span class="math inline">\(Y_l\)</span>&nbsp;的不确定性没有额外帮助）
所以有：<span class="math inline">\(I(\vec{X_{}};\vec{Y_{}})=H(\vec{Y_{}})-H(\vec{Y_{}}|\vec{X_{}})\leq
\sum_{l = 1}^{L}H(Y_l)-\sum_{l = 1}^{L}H(Y_l|X_l)=\sum_{l =
1}^{L}I(X_l;Y_l)\)</span>。</li>
</ul></li>
<li><strong>输入矢量<span class="math inline">\(\vec{X_{}}\)</span>中各分量相互独立时</strong>：
<span class="math display">\[I(\vec{X_{}};\vec{Y_{}})\geq\sum_{l =
1}^{L}I(X_l;Y_l)\]</span>
<ul>
<li>证明： 由定义有：<span class="math inline">\(I(\vec{X_{}};\vec{Y_{}})=H(\vec{X_{}}) -
H(\vec{X_{}}|\vec{Y_{}})\)</span>和<span class="math inline">\(I(X_l;Y_l)=H(X_l)-H(X_l|Y_l)\)</span>，利用<span class="math inline">\(H(X)\)</span>的链式法则有： ①<span class="math inline">\(H(\vec{X_{}})=H(X_1,X_2,\cdots,X_L)=H(X_1)+H(X_2|X_1)+\cdots+H(X_L|X_1,X_2,\cdots,X_{L
- 1})=\sum_{l = 1}^{L}H(X_l)\)</span>（由于各分量相互独立） ②<span class="math inline">\(H(\vec{X_{}}|\vec{Y_{}})=H(X_1|\vec{Y_{}})+H(X_2|X_1,\vec{Y_{}})+\cdots+H(X_L|X_1,X_2,\cdots,X_{L
- 1},\vec{Y_{}})=\sum_{l = 1}^{L}H(X_l|\vec{Y_{}})\leq \sum_{l =
1}^{L}H(X_l|Y_l)\)</span>（已知更多信息&nbsp;<span class="math inline">\(\vec{Y_{}}\)</span>&nbsp;时，<span class="math inline">\(X_l\)</span>&nbsp;的不确定性不会比仅知道&nbsp;<span class="math inline">\(Y_l\)</span>&nbsp;时更大） 所以有：<span class="math inline">\(I(\vec{X_{}};\vec{Y_{}})=H(\vec{X_{}})-H(\vec{X_{}}|\vec{Y_{}})\geq
\sum_{l = 1}^{L}H(X_l)-\sum_{l = 1}^{L}H(X_l|\vec{Y_{}})=\sum_{l =
1}^{L}I(X_l;Y_l)\)</span>。</li>
</ul></li>
<li><strong>当输入矢量<span class="math inline">\(\vec{X_{}}\)</span>独立且信道无记忆时</strong>，上述两个性质统一取等号，此时<strong>信道容量</strong>：
<span class="math display">\[
  \begin{align*}
  C_L&amp;=\max_{p(x)}I(\vec{X_{}};\vec{Y_{}})=\max_{p(x)}\sum_{l =
1}^{L}I(X_l;Y_l)\\
  &amp;=\sum_{l = 1}^{L}\max_{p(x)}I(X_l;Y_l)=\sum_{l = 1}^{L}C_l
  \end{align*}
  \]</span>
<ul>
<li>当信道平稳时<span class="math inline">\(C_L = LC_1\)</span></li>
<li>一般情况下，<span class="math inline">\(I(\vec{X_{}};\vec{Y_{}})\leq
LC_1\)</span> ，其中<span class="math inline">\(C_1\)</span>是单个时刻的信道容量</li>
</ul></li>
</ul></li>
<li>输入矢量独立且信道无记忆时，相当于对单个信道进行<span class="math inline">\(L\)</span>次扩展的信道，也相当于<span class="math inline">\(L\)</span>个独立的信道并联在一起。</li>
<li>示例：<img src="image-101.webp" srcset="/img/loading/loading3.gif" lazyload alt="示例"></li>
</ul>
<h3 id="独立并联信道">独立并联信道</h3>
<ul>
<li>图例: <img src="image-25.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例"></li>
<li>每个信道输出<span class="math inline">\(Y_l\)</span>只与本信道的输入<span class="math inline">\(X_l\)</span>有关，即： <span class="math display">\[p(Y_1,Y_2,\cdots,Y_L|X_1,X_2,\cdots,X_L) =
p(Y_1|X_1)p(Y_2|X_2)\cdots p(Y_L|X_L)\]</span>
<strong>信道无记忆</strong>, 并且有 <span class="math display">\[I(\vec{X_{}};\vec{Y_{}})\leq\sum_{l =
1}^{L}I(X_l;Y_l)\]</span></li>
<li>并联信道容量 <span class="math display">\[C_{12\cdots L}=\max
I(\vec{X_{}};\vec{Y_{}})\leq\sum_{l = 1}^{L}C_l\]</span></li>
<li>当输入符号<span class="math inline">\(X_l\)</span>相互独立，且<span class="math inline">\(p(X_1,X_2,\cdots,X_L)\)</span>达到最佳分布时，容量最大，此时：
<span class="math display">\[C_{12\cdots L}=\sum_{l =
1}^{L}C_l\]</span></li>
</ul>
<h3 id="有记忆离散序列信道">有记忆离散序列信道</h3>
<blockquote>
<p>有记忆的离散序列信道复杂得多，不作介绍。</p>
</blockquote>
<h2 id="连续信道及其容量">3.4 连续信道及其容量</h2>
<h3 id="连续单符号加性信道">连续单符号加性信道</h3>
<h4 id="加性高斯信道">加性高斯信道</h4>
<ul>
<li><p><strong>信道模型</strong>：</p>
<ul>
<li><figure>
<img src="image-27.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型">
<figcaption aria-hidden="true">信道模型</figcaption>
</figure></li>
<li>$ y = x + n $</li>
<li>$ n $：加性噪声</li>
<li>$P_n(n) N(0, ^2) = e^{-} $。</li>
</ul></li>
<li><p><strong>微分熵</strong>： <span class="math display">\[H_c(n) =
-\int_{-\infty}^{+\infty} P_n(n) \log P_n(n) dn = \frac{1}{2} \log(2\pi
e \sigma^2) \]</span></p></li>
<li><p><strong>互信息</strong>： <span class="math display">\[
  \begin{align*}
  I(X;Y) &amp;= H_c(X) - H_c(X|Y) \\
  &amp;= H_c(Y) - H_c(Y|X) \\
  \end{align*}
  \]</span></p></li>
<li><p><strong>信道容量</strong>： <span class="math display">\[
  \begin{align*}
  C = \max_{p(x)} I(X;Y) &amp;= \max_{p(x)} [H_c(Y) - H_c(Y|X)] \\
  &amp;= \max_{p(x)} H_c(Y) - \frac{1}{2} \log(2\pi e \sigma^2)
  \end{align*}
  \]</span></p>
<p>其中 $ H_c(Y|X) $ 是噪声熵，由于<span class="math inline">\(x\)</span>与<span class="math inline">\(n\)</span>相独立，所以<span class="math inline">\(p(y|x) = p(x+n|x) = p(n)\)</span>，所以$ H_c(Y|X)
= H_n(n) = (2e ^2) $。</p></li>
<li><p><strong>求 $ H_c(Y) $ 最大值</strong>： <span class="math display">\[
  \begin{align*}
  &amp;y = x + n , y \in (-\infty, +\infty) ，y是功率受限信号\\
  &amp;\Rightarrow Y 正态分布时熵最大\\
  &amp;\Rightarrow Y 正态分布时信道容量最大\\
  \end{align*}
  \]</span></p></li>
<li><p><span class="math inline">\(y\)</span> 的功率 <span class="math inline">\(P\)</span>（其中 <span class="math inline">\(S\)</span> 是输入信号 <span class="math inline">\(x\)</span> 的平均功率，<span class="math inline">\(\sigma^2\)</span> 是噪声功率） <span class="math display">\[P = S + \sigma^2 \]</span></p>
<ul>
<li><p>若 <span class="math inline">\(P_Y(y) \sim N(0,
P)\)</span>，<span class="math inline">\(P_n(n)\sim N(0,
\sigma^2)\)</span>，<span class="math inline">\(x = y - n\)</span>，则
<span class="math inline">\(P_X(x) \sim N(0, S)\)</span>。</p></li>
<li><p>当输入 $ X $ 是均值为 0，方差为 $ S $
的高斯分布时，<strong>信息传输率</strong>达最大，等于<strong>信道容量</strong>：
<span class="math display">\[
  \begin{align*}
  C &amp;= \frac{1}{2} \log(2\pi e P) - \frac{1}{2} \log(2\pi e
\sigma^2) \\
  &amp;= \frac{1}{2} \log \frac{P}{\sigma^2} \\
  &amp;= \frac{1}{2} \log \left(1 + \frac{S}{\sigma^2}\right)\\
  &amp;= \frac{1}{2} \log(1 + SNR) \quad bit/符号
  \end{align*}
  \]</span></p>
<p>其中 <span class="math inline">\(SNR=\frac{S}{\sigma^2}\)</span>，<span class="math inline">\(SNR_{dB} = 10\log_{10}SNR\)</span>。</p></li>
</ul></li>
</ul>
<h4 id="加性非高斯信道">加性非高斯信道</h4>
<ul>
<li><p>对于加性、均值为 0、平均功率为 $ ^2 $ 的非高斯信道： <span class="math display">\[
  C = \max (H_c(Y) - H_c(n))
  \]</span></p></li>
<li><p>高斯分布时： <span class="math display">\[H_c(Y)_{max} =
\frac{1}{2} \log(2\pi e P) \]</span></p>
<p><span class="math display">\[H_c(n)_{max} = \frac{1}{2} \log(2\pi e
\sigma^2) \]</span></p></li>
<li><p>满足： <span class="math display">\[\frac{1}{2} \log(2\pi e P) -
\frac{1}{2} \log(2\pi e \sigma^2) \leq C \leq \frac{1}{2} \log(2\pi e P)
- H_c(n) \]</span></p></li>
</ul>
<h3 id="多维无记忆加性连续信道">多维无记忆加性连续信道</h3>
<ul>
<li><p><strong>信道模型</strong>：</p>
<ul>
<li><figure>
<img src="image-28.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型">
<figcaption aria-hidden="true">信道模型</figcaption>
</figure>
<ul>
<li>输入<span class="math inline">\(X\)</span>的总功率<span class="math inline">\(P = \sum_{l = 1}^{L}P_l\)</span>，<span class="math inline">\(P_l\)</span>是第<span class="math inline">\(l\)</span>个输入信号的功率</li>
<li><span class="math inline">\(\sigma_l^2\)</span>是第<span class="math inline">\(l\)</span>个噪声的功率</li>
</ul></li>
<li>信道无记忆 <span class="math display">\[
  p(\vec{y_{}}|\vec{x_{}}) = \prod_{l = 1}^{L} p(y_l|x_l)
  \]</span></li>
<li>加性噪声各时刻独立 <span class="math display">\[
  p_n(\vec{n_{}}) = p_y(\vec{y_{}}|\vec{x_{}}) = \prod_{l = 1}^{L}
p_n(n_l) \quad n_l \sim N(0, \sigma_l^2)
  \]</span></li>
</ul></li>
<li><p><strong>互信息</strong>： <span class="math display">\[
  I(\vec{X_{}}; \vec{Y_{}}) \leq \sum_{l = 1}^{L} I(X_l; Y_l) \leq
\sum_{l = 1}^{L} \frac{1}{2} \log(1 + \frac{P_l}{\sigma_l^2})
  \]</span></p></li>
<li><p><strong>信道容量</strong>： <span class="math display">\[
  C = \max_{p(x)} I(\vec{X_{}}; \vec{Y_{}}) = \sum_{l = 1}^{L}
\frac{1}{2} \log(1 + \frac{P_l}{\sigma_l^2}) \quad \text{bit}/L \text{
序列}
  \]</span></p>
<p>当且仅当输入随机变量 <span class="math inline">\(\vec{X_{}}\)</span>
中各分量统计独立，且均值为0，方差为 <span class="math inline">\(P_l\)</span>
的高斯分布时，才能达到此容量。</p></li>
</ul>
<ol type="1">
<li><p><strong><span class="math inline">\(L\)</span>
个高斯噪声每个单元时刻噪声功率相等</strong>，<span class="math inline">\(\sigma_l^2 = \sigma^2\)</span>，<span class="math inline">\(l \in \{1,2,\cdots,L\}\)</span>，有 <span class="math display">\[
C = \frac{L}{2} \log(1 + \frac{S}{\sigma^2}) \quad, \quad S =
\frac{P}{L}
\]</span> <span class="math inline">\(\vec{X_{}}\)</span> 的各分量满足
<span class="math inline">\(N(0,S)\)</span>
分布时，达到信道容量。</p></li>
<li><p><strong><span class="math inline">\(L\)</span>
个高斯噪声均值为0，方差不同且为 <span class="math inline">\(\sigma_l^2\)</span>
时</strong>，若输入信号的总平均功率受限，即 <span class="math display">\[
E\left[\sum_{l = 1}^{L} x_l^2\right] = \sum_{l = 1}^{L} E[x_l^2] =
\sum_{l = 1}^{L} P_l = P
\]</span></p>
<ul>
<li><figure>
<img src="image-29.webp" srcset="/img/loading/loading3.gif" lazyload alt="图例">
<figcaption aria-hidden="true">图例</figcaption>
</figure></li>
<li><p><strong>怎样合理分配各单元时刻的信号平均功率，才能使信道传输率最大？</strong>
用拉格朗日乘数法，作辅助函数 <span class="math display">\[
  f(P_1, P_2, \cdots, P_L) = \sum_{l = 1}^{L} \frac{1}{2} \log(1 +
\frac{P_l}{\sigma_l^2}) + \lambda (\sum_{l = 1}^{L} P_l - P)
  \]</span></p>
<p>对第一项求最大，第二项为约束条件 令 <span class="math inline">\(\frac{\partial f( )}{\partial P_l} =
0\)</span>，<span class="math inline">\(l = 1,2,\cdots,L\)</span> 得
<span class="math display">\[
  \begin{align*}
  \frac{1}{2} \frac{1}{P_l + \sigma_l^2} + \lambda = 0 \quad, \quad l =
1,2,\cdots,L\\
  \Rightarrow P_l + \sigma_l^2 = -\frac{1}{2\lambda} \quad, \quad l =
1,2,\cdots,L
  \end{align*}
  \]</span></p>
<p>令各时刻信道输出总功率（信号功率 <span class="math inline">\(P_l\)</span> + 噪声功率 <span class="math inline">\(\sigma_l^2\)</span>）相等，设为 <span class="math inline">\(V\)</span> <span class="math display">\[
  V = \frac{P + \sum_{l = 1}^{L} \sigma_l^2}{L}
  \]</span></p>
<p>当 <span class="math inline">\(P_l = V - \sigma_l^2 = \frac{P +
\sum_{l = 1}^{L} \sigma_l^2}{L} - \sigma_l^2\)</span>，<span class="math inline">\(l = 1,2,\cdots,L\)</span>
时，<strong>信道传输率达到最大</strong> <span class="math display">\[
  \begin{align*}
  C &amp;= \sum_{l = 1}^{L} \frac{1}{2} \log(1 +
\frac{P_l}{\sigma_l^2})  = \frac{1}{2} \sum_{l = 1}^{L} \log \frac{P +
\sum_{l = 1}^{L} \sigma_l^2}{L\sigma_l^2} \\
  &amp;= \frac{1}{2} \sum_{l = 1}^{L} \log \frac{V}{\sigma_l^2}
  \end{align*}
  \]</span></p>
<p>若 <span class="math inline">\(\sigma_l^2\)</span> 太大，大于 <span class="math inline">\(V\)</span>，则置 <span class="math inline">\(P_l =
0\)</span>，然后重新调整功率分配，直到 <span class="math inline">\(P_l\)</span> 不再出现负值。</p></li>
<li><p><strong>例题</strong>：<img src="image-88.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul></li>
</ol>
<h3 id="限时限频限功率加性高斯白噪声信道">限时限频限功率加性高斯白噪声信道</h3>
<h4 id="波形信道限时-t_b限频-omega">波形信道，限时 <span class="math inline">\(t_B\)</span>，限频 <span class="math inline">\(\omega\)</span></h4>
<ul>
<li><strong>信道模型</strong>：
<ul>
<li><figure>
<img src="image-30.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型">
<figcaption aria-hidden="true">信道模型</figcaption>
</figure></li>
</ul></li>
<li><strong>互信息</strong>： <span class="math display">\[
  \begin{align*}
  I(x(t); y(t)) &amp;= \lim_{L \to \infty} I(\vec{X_{}}; \vec{Y_{}}) \\
  &amp;= \lim_{L \to \infty} [H_c(\vec{X_{}}) -
H_c(\vec{X_{}}|\vec{Y_{}})] \\
  &amp;= \lim_{L \to \infty} [H_c(\vec{Y_{}}) -
H_c(\vec{Y_{}}|\vec{X_{}})] \quad \text{bit/波形}
  \end{align*}
  \]</span></li>
<li><strong>单位时间内的信息传输率</strong> <span class="math inline">\(R_t\)</span> 为： <span class="math display">\[
  R_t=\lim_{t_B \to \infty}\frac{1}{t_B}I(\vec{X_{}}; \vec{Y_{}})\quad
\text{ bit/秒} \quad (t_B：\text{秒/波形})
  \]</span></li>
<li><strong>信道容量</strong>: <span class="math display">\[
  C_t=\max_{p(x)}[\lim_{t_B \to \infty}\frac{1}{t_B}I(\vec{X_{}};
\vec{Y_{}})]\quad \text{ bit/秒}
  \]</span></li>
<li>带宽受限加性高斯白噪声 <span class="math inline">\(n(t)\)</span>，均值为0，功率谱密度 <span class="math inline">\(\frac{N_0}{2}\)</span></li>
</ul>
<h4 id="加性高斯白噪声">加性高斯白噪声</h4>
<ul>
<li><strong>模型</strong>： <img src="image-31.webp" srcset="/img/loading/loading3.gif" lazyload alt="模型">
<ul>
<li><span class="math inline">\(y(t)=x(t)+n(t)\)</span></li>
<li>相关函数:
<ul>
<li><span class="math inline">\(P_n(n)\sim N(0,\sigma^2)\)</span></li>
<li><span class="math inline">\(R_n(\tau) =
\frac{N_0}{2}\delta(\tau)\)</span></li>
<li>功率谱密度 <span class="math inline">\(\Phi_n(f) =
\frac{N_0}{2}\)</span></li>
<li>总噪声功率 $^2 = = N_0$</li>
<li><span class="math inline">\(N_0 = kT\)</span></li>
<li>波茨曼常数 <span class="math inline">\(k\)</span></li>
<li>绝对温度 <span class="math inline">\(T\)</span></li>
</ul></li>
</ul></li>
</ul>
<h4 id="低频带宽受限通信系统">低频带宽受限通信系统</h4>
<ul>
<li><p>在 <span class="math inline">\([0, t_B]\)</span> 内，采样个数
<span class="math inline">\(L = 2\omega
t_B\)</span>，各样本值彼此独立。</p></li>
<li><p>通信带宽为 $2$，噪声功率为 $2=N_0$ <span class="math display">\[
  \begin{align*}
  &amp;C=\frac{1}{2}\sum_{l = 1}^{L}\log(1 + \frac{P_l}{\sigma_l^2})\\
  &amp;\sigma_l^2 = P_n=\frac{\frac{N_0}{2}\cdot 2\omega \cdot
t_B}{L}=\frac{\frac{N_0}{2}\cdot 2\omega \cdot t_B}{2\omega \cdot
t_B}=\frac{N_0}{2}\\
  &amp;P_l = \frac{P_s t_B}{2\omega t_B}=\frac{P_s}{2\omega }
  \end{align*}
  \]</span></p></li>
<li><p>对于平稳系统 <span class="math display">\[
  \begin{align*}
  C&amp;=\frac{L}{2}\log(1 + \frac{P_s}{2\omega }\cdot\frac{2}{N_0})\\
  &amp;=\frac{L}{2}\log(1 + \frac{P_s}{N_0\omega })\\
  &amp;=\omega t_B\log(1 + \frac{P_s}{N_0\omega }) \quad \text{ bit}/L
\text{维符号序列}
  \end{align*}
  \]</span></p></li>
<li><p>单位时间的信道容量 <span class="math display">\[
  \begin{align*}
  C_t&amp;=\lim_{t_B \to \infty}\frac{C}{t_B}\\
  &amp;=\omega \log(1 + \frac{P_s}{N_0\omega })\quad \text{ bit/秒}\\
  &amp;=\omega \log(1 + SNR)\quad \text{ bit/秒}
  \end{align*}
  \]</span></p>
<p>其中:</p>
<ul>
<li><span class="math inline">\(P_s\)</span>：信号平均功率</li>
<li><span class="math inline">\(N_0\omega\)</span>：噪声在系统中的平均功率（<span class="math inline">\(\frac{N_0}{2}\cdot
2\omega=N_0\omega\)</span>）</li>
<li><span class="math inline">\(SNR_{dB}=10\log_{10}SNR\)</span></li>
</ul></li>
<li><p>例题：<img src="image-102.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h2 id="多输入多输出信道及其容量">3.5 多输入多输出信道及其容量</h2>
<blockquote>
<p>略</p>
</blockquote>
<h2 id="信源与信道的匹配">3.6 信源与信道的匹配</h2>
<ul>
<li><strong>符号匹配</strong>
<ul>
<li><figure>
<img src="image-32.webp" srcset="/img/loading/loading3.gif" lazyload alt="符号匹配">
<figcaption aria-hidden="true">符号匹配</figcaption>
</figure></li>
<li>信源编码：将信源符号转换为信道符号</li>
</ul></li>
<li><strong>信息匹配</strong>
<ul>
<li>信道绝对冗余度 <span class="math inline">\(R_a = C -
I(X;Y)\)</span></li>
<li>信道相对冗余度 <span class="math inline">\(R_r = 1 -
\frac{I(X;Y)}{C}\)</span></li>
<li>信道效率 <span class="math inline">\(E =
\frac{I(X;Y)}{C}\)</span></li>
</ul></li>
</ul>
<h1 id="第四章-信息率失真函数">第四章 信息率失真函数</h1>
<h2 id="信息率失真函数的概念和性质">4.1 信息率失真函数的概念和性质</h2>
<h3 id="失真函数">失真函数</h3>
<ul>
<li><p><strong>信源编码器模型</strong>：</p>
<ul>
<li><figure>
<img src="image-34.webp" srcset="/img/loading/loading3.gif" lazyload alt="失真函数">
<figcaption aria-hidden="true">失真函数</figcaption>
</figure></li>
<li>信源 <span class="math inline">\(X \in
\{a_1,a_2,\cdots,a_n\}\)</span></li>
<li>经信源编码器输出 <span class="math inline">\(Y \in
\{b_1,b_2,\cdots,b_m\}\)</span></li>
</ul></li>
<li><p><strong>失真函数</strong> <span class="math inline">\(d(x_i,y_j)\)</span> 定义为： <span class="math display">\[d(x_i,y_j)=\begin{cases}0, &amp; x_i = y_j \\
\alpha, &amp; \alpha&gt;0, x_i\neq y_j\end{cases}\]</span></p></li>
<li><p><strong>失真矩阵</strong> <span class="math inline">\(d\)</span>
定义为： <span class="math display">\[d = [d(x_i,y_j)]_{n×m} =
\begin{bmatrix}d(a_1,b_1)&amp;d(a_1,b_2)&amp;\cdots&amp;d(a_1,b_m)\\\cdots\\d(a_n,b_1)&amp;d(a_n,b_2)&amp;\cdots&amp;d(a_n,b_m)\end{bmatrix}\]</span></p></li>
<li><p><span class="math inline">\(d(x_i,y_j)\)</span>
的函数形式可任意选择，常用的有：</p>
<ul>
<li><strong>均方失真</strong>：<span class="math inline">\(d(x_i,y_j)=(x_i - y_j)^2\)</span>
（连续信源）</li>
<li><strong>绝对失真</strong>：<span class="math inline">\(d(x_i,y_j)=\vert x_i - y_j\vert\)</span>
（连续信源）</li>
<li><strong>相对失真</strong>：<span class="math inline">\(d(x_i,y_j)=\vert x_i - y_j\vert/\vert
x_i\vert\)</span> （连续信源）</li>
<li><strong>误码失真</strong>：<span class="math inline">\(d(x_i,y_j)=\delta(x_i,y_j)=\begin{cases}0, &amp;
x_i = y_j \\ 1, &amp; 其他\end{cases}\)</span> （离散信源）</li>
</ul></li>
<li><p>例题：<img src="image-89.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h3 id="平均失真">平均失真</h3>
<ul>
<li><p>对于离散随机变量，<strong>平均失真</strong> <span class="math inline">\(\overline{D}\)</span> 的计算公式为： <span class="math display">\[
  \begin{aligned}
  \overline{D} = E(d(x_i,y_j)) &amp;= \sum_{i = 1}^{n}\sum_{j =
1}^{m}p(a_i,b_j)d(a_i,b_j) \\
  &amp;= \sum_{i = 1}^{n}\sum_{j = 1}^{m}p(a_i)p(b_j|a_i)d(a_i,b_j)
  \end{aligned}
  \]</span></p>
<p>其中:</p>
<ul>
<li><span class="math inline">\(p(a_i)\)</span> 是信源符号分布</li>
<li><span class="math inline">\(p(b_j|a_i)\)</span>
是有失真编码器转移概率分布</li>
<li><span class="math inline">\(d(a_i,b_j)\)</span>
是离散随机变量失真函数</li>
</ul></li>
</ul>
<h3 id="信息率失真函数-rd">信息率失真函数 <span class="math inline">\(R(D)\)</span></h3>
<ul>
<li><p>将信源编码器看作信道：<img src="image-35.webp" srcset="/img/loading/loading3.gif" lazyload alt="假想信道"></p></li>
<li><p>编码的目的：</p>
<ul>
<li>使传输率 <span class="math inline">\(R\)</span> 尽量小</li>
<li>但是<span class="math inline">\(R\)</span> 越小，<span class="math inline">\(\overline{D}\)</span> 越大</li>
<li>在满足 <span class="math inline">\(\overline{D} \leq D\)</span>
条件下，选择一种编码方法使 <span class="math inline">\(R\)</span>
尽量小</li>
</ul></li>
<li><p><strong>信息传输率</strong> <span class="math inline">\(R=
I(X;Y)\)</span>，计算公式为： <span class="math display">\[
  \begin{aligned}
  R = I(X;Y) &amp; =\sum_{i,j}p(x_i,y_j)\log\frac{p(y_j|x_i)}{p(y_j)} \\
  &amp;
=\sum_{i,j}p(x_i)p(y_j|x_i)\log\frac{p(y_j|x_i)}{\sum_{i}p(x_i)p(y_j|x_i)}
  \end{aligned}
  \]</span></p></li>
<li><p>对于某特定信源，<span class="math inline">\(p(x_i)\)</span>
确定，<span class="math inline">\(I(X;Y)\)</span> 是关于 <span class="math inline">\(p(y_j|x_i)\)</span> 的凸函数（<span class="math inline">\(\cup\)</span>型下凸函数），可以从信道集合 <span class="math inline">\(P_D\)</span> 中找到一种信道 <span class="math inline">\(p(y_j|x_i)\)</span>，使 <span class="math inline">\(I(X;Y)\)</span> 最小。</p>
<ul>
<li><strong>信道集合</strong> <span class="math inline">\(P_D\)</span>（<span class="math inline">\(D\)</span>允许试验信道）定义为： <span class="math display">\[P_D = \{p(b_j|a_i) \quad|\quad \overline{D} \leq
D, i = 1,2,\cdots,n;j = 1,2,\cdots,m\}\]</span></li>
<li><strong>信息率失真函数</strong> <span class="math inline">\(R(D)\)</span> 为： <span class="math display">\[R(D)=\min_{P_D}I(X;Y)\]</span></li>
<li>对于<strong>离散无记忆信道</strong>，<span class="math inline">\(R(D)\)</span> 可写成： <span class="math display">\[R(D)=\min_{P_{ij}\in P_D}\sum_{i = 1}^{n}\sum_{j
= 1}^{m}p(a_i)p(b_j|a_i)\log\frac{p(b_j|a_i)}{p(b_j)}\]</span></li>
</ul></li>
<li><p>例题：<img src="image-36.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h3 id="信息率失真函数的性质">信息率失真函数的性质</h3>
<h4 id="rd函数的定义域"><span class="math inline">\(R(D)\)</span>函数的定义域</h4>
<ol type="1">
<li><strong><span class="math inline">\(D_{min}\)</span>和<span class="math inline">\(R(D_{min})\)</span></strong>
<ul>
<li>平均失真<span class="math inline">\(D\)</span>是失真函数<span class="math inline">\(d(x,y)\)</span>的数学期望，因此<span class="math inline">\(D\)</span>也是非负实数，所以<span class="math inline">\(D_{min} = 0\)</span>。</li>
<li><span class="math display">\[R(D_{min}) = R(0)=H(X)\]</span>
等式成立的条件：
<ul>
<li><span class="math inline">\(D_{min} =
0\)</span>：失真矩阵中每行至少有一个零，令条件概率在该行该处为1</li>
<li><span class="math inline">\(R(0) =
H(X)\)</span>：每一列最多只有一个零，否则多个<span class="math inline">\(X\)</span>对应一个<span class="math inline">\(Y\)</span>，<span class="math inline">\(R(0) =
H(Y) &lt; H(X)\)</span>。</li>
</ul></li>
<li>对于连续信源，<span class="math inline">\(R(D_{min}) =
R(0)=H_c(X)=\infty\)</span>。</li>
</ul></li>
<li><strong><span class="math inline">\(D_{max}\)</span>和<span class="math inline">\(R(D_{max})\)</span></strong>
<ul>
<li><p><span class="math display">\[D_{max}=\min_{R(D)=0} D\]</span>
<span class="math display">\[R(D_{max})=0\]</span></p></li>
<li><p>当<span class="math inline">\(R(D)=0\)</span>，即<span class="math inline">\(I(X;Y)=0\)</span>，<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>互相独立，<span class="math inline">\(p(y_j|x_i)=p(y_j)=p_j\)</span></p></li>
<li><p><span class="math display">\[\overline{D}=\sum_{i = 1}^{n}\sum_{j
= 1}^{m}p_ip_jd_{ij}\]</span> 其中<span class="math inline">\(p_i\)</span>、<span class="math inline">\(d_{ij}\)</span>已知，<span class="math inline">\(D_{max}\)</span>为满足<span class="math inline">\(\sum_{j}p_j = 1\)</span>条件下<span class="math inline">\(\overline{D}\)</span>的最小值。</p></li>
<li><p><span class="math display">\[
\begin{align*}
D_{max} &amp; =\min\sum_{j = 1}^{m}p_j\sum_{i = 1}^{n}p_id_{ij} \\
&amp;=\min_{j = 1,2,\cdots,m}\sum_{i = 1}^{n}p_id_{ij}
\end{align*}
\]</span> 即在<span class="math inline">\(j = 1, 2,
\cdots,m\)</span>中，找到<span class="math inline">\(\sum_{i =
1}^{n}p_id_{ij}\)</span>值最小的一列<span class="math inline">\(j\)</span>，此时取<span class="math inline">\(p_j
= 1\)</span>，其余置<span class="math inline">\(0\)</span></p></li>
</ul></li>
<li><strong><span class="math inline">\(R(D)\)</span>函数的定义域和值域</strong>
<ul>
<li><span class="math inline">\(R(D)\)</span>函数的最大定义域为<span class="math display">\[[0\quad, \min_{j = 1,2,\cdots,m}\sum_{i =
1}^{n}p_id_{ij}]\]</span></li>
<li><span class="math inline">\(R(D)\)</span>函数的最大值域为<span class="math display">\[[0, H(X)]\]</span></li>
<li><figure>
<img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload alt="函数图像">
<figcaption aria-hidden="true">函数图像</figcaption>
</figure></li>
</ul></li>
</ol>
<ul>
<li>例题：
<ul>
<li><figure>
<img src="image-90.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题">
<figcaption aria-hidden="true">例题</figcaption>
</figure></li>
<li><figure>
<img src="image-91.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题">
<figcaption aria-hidden="true">例题</figcaption>
</figure></li>
</ul></li>
</ul>
<h4 id="rd函数的下凸性和连续性"><span class="math inline">\(R(D)\)</span>函数的下凸性和连续性</h4>
<ul>
<li><figure>
<img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload alt="函数图像">
<figcaption aria-hidden="true">函数图像</figcaption>
</figure></li>
<li><p><strong>下凸性</strong>： <span class="math display">\[D^{\alpha}=\alpha D'+(1 - \alpha)D''
\quad 0\leq\alpha\leq1\]</span></p>
<p>有 <span class="math display">\[R(D^{\alpha})\leq\alpha R(D')+(1
- \alpha)R(D'')\]</span></p></li>
<li><p><strong>连续性</strong>： 设 <span class="math inline">\(D' =
D+\delta\)</span>，当 <span class="math inline">\(\delta\to0\)</span>
时，<span class="math inline">\(P_{D'}\to P_{D}\)</span> ，<span class="math inline">\(R(D')\to R(D)\)</span> 。</p></li>
</ul>
<h4 id="rd函数的单调递减性"><span class="math inline">\(R(D)\)</span>函数的单调递减性</h4>
<ul>
<li>允许的失真度越大，所要求的信息率就越小。</li>
<li>规定了允许失真 <span class="math inline">\(D\)</span>，及失真函数
<span class="math inline">\(d(i,j)\)</span>，可以找到 <span class="math inline">\(R(D)\)</span>，作为衡量信源编码压缩难度的一把尺子。</li>
</ul>
<h4 id="信息率失真函数与信道容量">信息率失真函数与信道容量</h4>
<table>
<thead>
<tr>
<th style="text-align: left;"></th>
<th style="text-align: left;">信道容量 <span class="math inline">\(C\)</span></th>
<th style="text-align: left;">信息率失真函数 <span class="math inline">\(R(D)\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">研究对象</td>
<td style="text-align: left;">信道</td>
<td style="text-align: left;">信源</td>
</tr>
<tr>
<td style="text-align: left;">给定条件</td>
<td style="text-align: left;"><span class="math inline">\(p(y_j\|x_i)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(p(x_i)\)</span></td>
</tr>
<tr>
<td style="text-align: left;">选择参数</td>
<td style="text-align: left;"><span class="math inline">\(p(x_i)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(p(y_j\|x_i)\)</span></td>
</tr>
<tr>
<td style="text-align: left;">结论</td>
<td style="text-align: left;"><span class="math inline">\(C =
\max_{p(x)}I(X;Y)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(R(D)=\min_{P_D}I(X;Y)\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><span class="math inline">\(H(X\|Y)=H(X)-I(X;Y)\)</span></td>
<td style="text-align: left;">噪声干扰丢失的信息量</td>
<td style="text-align: left;">编码压缩损失的信息量</td>
</tr>
</tbody>
</table>
<h2 id="信息率失真函数rd的计算参量表示法">4.2 信息率失真函数<span class="math inline">\(R(D)\)</span>的计算（参量表示法）</h2>
<h3 id="例题">例题</h3>
<ol type="1">
<li><strong>例题1</strong>： 已知<span class="math inline">\(X,Y\in\{0,1\}\)</span>，<span class="math inline">\(p(X) =\begin{cases}p, &amp;X=0 \\ 1-p, &amp;X=1
\end{cases}\)</span>，<span class="math inline">\(0 &lt;
p\leq\frac{1}{2}\)</span>，<span class="math inline">\(d(x,y)=\begin{cases}1, &amp; x\neq y \\ 0, &amp; x
= y\end{cases}\)</span> <strong>证明</strong>：<span class="math inline">\(R(D)=\begin{cases}H_b(p)-H_b(D), &amp; 0\leq D\leq
p \\ 0, &amp; D &gt; p\end{cases}\)</span>，其中<span class="math inline">\(H_b(p)=H(p,1 - p)\)</span>，<span class="math inline">\(H_b(D)=H(D,1 - D)\)</span>
<ul>
<li>由<span class="math inline">\(R(D)\)</span>性质可得<strong>定义域</strong>：
失真矩阵 <span class="math inline">\(d=\begin{bmatrix}0&amp;1\\1&amp;0\end{bmatrix}\)</span>，令转移概率矩阵
<span class="math inline">\(P=\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix}\)</span>
<span class="math inline">\(D_{min} = 0\)</span>，<span class="math inline">\(R(0)=H(X)=H_b(p)\)</span> <span class="math inline">\(D_{max}=\min[p,1 - p]\)</span> = p</li>
<li><strong>求<span class="math inline">\(R(D)\)</span></strong>： <span class="math inline">\(R(D)=\min I(X;Y)\)</span>，限制条件<span class="math inline">\(P_D = \{p(y|x) | \overline{D}=E(d(X,Y))\leq D\leq
D_{max} = p\}\)</span> 令 <span class="math inline">\(Z = d(X,Y) =
\begin{cases}1, &amp; x\neq y \\ 0, &amp; x = y\end{cases}\)</span>
<span class="math inline">\(p(x|y) = p(z|y)\)</span>，<span class="math inline">\(H(X|Y) = H(Z|Y)\)</span> 又<span class="math inline">\(p(z=1) = p_r(x \neq y)=E(d(X,Y))\leq D\leq p\leq
\frac{1}{2}\)</span> 且<span class="math inline">\(H_b(x)\)</span>函数关于<span class="math inline">\(\frac{1}{2}\)</span>对称，在<span class="math inline">\(0\leq x \leq\frac{1}{2}\)</span>范围内，<span class="math inline">\(H_b(x)\)</span>函数单调递增。 则<span class="math inline">\(H(Z) = H_b(p_r(x \neq y)) \leq H_b(D)\)</span>
<span class="math display">\[
  \begin{align*}
  I(X;Y)&amp;=H(X)-H(X|Y)\\
  &amp;=H_b(p)-H(X|Y)\\
  &amp;=H_b(p)-H(Z|Y)（令z=d(x,y)）\\
  &amp;\geq H_b(p)-H(Z) （H(Z|Y)\leq H(Z)）\\
  &amp;\geq H_b(p)-H_b(D) （H(Z) \leq H_b(D)）
  \end{align*}
  \]</span> 所以<span class="math inline">\(R(D) \geq
H_b(p)-H_b(D)\)</span></li>
<li><strong>证明下界可达</strong>： 构造反向BSC信道如图：<img src="image-41.webp" srcset="/img/loading/loading3.gif" lazyload alt="BSC信道"> 令<span class="math inline">\(X,Y\in\{0,1\}\)</span>，<span class="math inline">\(p(Y) =\begin{cases}p, &amp;Y=0 \\ 1-p, &amp;Y=1
\end{cases}\)</span>，<span class="math inline">\(d(x,y)=\begin{cases}1,
&amp; x\neq y \\ 0, &amp; x = y\end{cases}\)</span> 转移概率矩阵 <span class="math inline">\(P=\begin{bmatrix}1-D &amp; D\\D &amp; 1-D
\end{bmatrix}\)</span> 则<span class="math inline">\(R = I(X;Y) =
H(Y)-H(Y|X) =H_b(p)-H_b(D)\)</span>，达到下界 只需证明存在<span class="math inline">\(\alpha\)</span>满足<span class="math inline">\(0\leq\alpha\leq1\)</span>，使得<span class="math inline">\(p(X) =\begin{cases}\alpha, &amp;X=0 \\ 1-\alpha,
&amp;X=1 \end{cases}\)</span> 易知<span class="math inline">\(p =
\alpha(1 - D)+D(1 - \alpha)\)</span>，即<span class="math inline">\(\alpha=\frac{p - D}{1 - 2D}\)</span> 因为<span class="math inline">\(0 \leq D \leq p \leq \frac{1}{2}\)</span>，<span class="math inline">\(p+D\leq1\)</span> 由此可得<span class="math inline">\(0\leq\alpha=\frac{p - D}{1 -
2D}\leq1\)</span>，即存在<span class="math inline">\(\alpha\)</span>满足条件</li>
</ul></li>
<li><strong>例题2</strong>：<img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
<li><strong>结论</strong>：<strong>二元信源失真函数<span class="math inline">\(R(D)=\begin{cases}H_b(p)-H_b(D), &amp; 0\leq D\leq
p \\ 0, &amp; D &gt; p\end{cases}\)</span></strong></li>
</ol>
<h3 id="参量表示法">参量表示法</h3>
<ol type="1">
<li><p><strong>条件与记号</strong> 设离散信源的输入序列为 <span class="math display">\[
\begin{bmatrix} X \\ P \end{bmatrix} =
\begin{bmatrix} x_1 &amp; x_2 &amp; \cdots &amp; x_n \\ p(x_1) &amp;
p(x_2) &amp; \cdots &amp; p(x_n) \end{bmatrix}
\]</span></p>
<p>输出序列为 <span class="math display">\[
\begin{bmatrix} Y \\ P \end{bmatrix} =
\begin{bmatrix} y_1 &amp; y_2 &amp; \cdots &amp; y_m \\ p(y_1) &amp;
p(y_2) &amp; \cdots &amp; p(y_m) \end{bmatrix}
\]</span></p>
<p>字符传输的失真函数为 <span class="math inline">\(d(x_i,y_j)\)</span>
， <span class="math inline">\(i = 1,2,\cdots,n\)</span> ； <span class="math inline">\(j = 1,2,\cdots,m\)</span> 。
为了书写方便，引入记号： <span class="math display">\[
d_{ij} = d(x_i,y_j), \quad p_{ij} = p(y_j\mid x_i)\\
p_i = p(x_i), \quad q_j = p(y_j)
\]</span></p>
<p>式中 <span class="math display">\[p(y_j)=\sum_{i =
1}^{n}p(x_i)p(y_j\mid x_i)=\sum_{i = 1}^{n}p_ip_{ij}\]</span></p></li>
<li><p><strong>问题转换</strong> 信息率失真函数 <span class="math inline">\(R(D)\)</span> 的计算为在约束条件 <span class="math display">\[
\begin{cases}
\sum_{i = 1}^{n}\sum_{j = 1}^{m}p_ip_{ij}d_{ij} = D \\
\sum_{j = 1}^{m}p_{ij} = 1 \quad i = 1,2,\cdots,n
\end{cases} \quad ①
\]</span></p>
<p>下，求下式极小值问题。 <span class="math display">\[
I(X;Y)=\sum_{i = 1}^{n}\sum_{j = 1}^{m}p_ip_{ij}\ln\frac{p_{ij}}{q_j}
\quad ②
\]</span></p>
<p>应用拉格朗日乘法，引入乘子 <span class="math inline">\(s\)</span> 和
<span class="math inline">\(\mu_i\)</span> ， <span class="math inline">\(i = 1,2,\cdots,n\)</span>
将上述条件极值问题化成无条件极值问题： <span class="math display">\[
\frac{\partial}{\partial p_{ij}}\left[I(X;Y)-sD - \mu_i\sum_{j =
1}^{m}p_{ij}\right]=0\quad i = 1,2,\cdots,n \quad ③
\]</span></p></li>
<li><p><strong>求解</strong> 由上式 ③ 解出 <span class="math inline">\(p_{ij}\)</span> ，代入式 ② 中得到在约束条件式 ①
下的 <span class="math inline">\(I(X;Y)\)</span> 极小值，即 <span class="math inline">\(R(D)\)</span> 。</p>
<p><span class="math display">\[
\begin{align*}
\frac{\partial I(X;Y)}{\partial p_{ij}}&amp;=\frac{\partial}{\partial
p_{ij}}\left[\sum_{i = 1}^{n}\sum_{j =
1}^{m}p_ip_{ij}\ln\frac{p_{ij}}{q_j}\right]\\
&amp;=\frac{\partial}{\partial p_{ij}}\left[\sum_{i = 1}^{n}\sum_{j =
1}^{m}p_ip_{ij}\ln p_{ij}-\sum_{i = 1}^{n}\left(\sum_{j =
1}^{m}p_ip_{ij}\right)\ln q_j\right]\\
&amp;=\frac{\partial}{\partial p_{ij}}\left[\sum_{i = 1}^{n}\sum_{j =
1}^{m}p_ip_{ij}\ln p_{ij}-\sum_{j = 1}^{m}q_j\ln q_j\right]\\
&amp;=\left[p_ip_{ij}\frac{1}{p_{ij}} + p_i\ln
p_{ij}\right]-\left[q_j\frac{1}{q_j}\frac{\partial q_j}{\partial
p_{ij}}+\frac{\partial q_j}{\partial p_{ij}}\ln q_j\right]\\
&amp;=\left[p_i + p_i\ln p_{ij}\right]-\left[p_i + p_i\ln q_j\right]\\
&amp;=p_i\ln\frac{p_{ij}}{q_j}\\
     \frac{\partial [sD]}{\partial p_{ij}}&amp;=\frac{\partial}{\partial
p_{ij}}\left[s\sum_{i = 1}^{n}\sum_{j =
1}^{m}p_ip_{ij}d_{ij}\right]=sp_id_{ij}\\
\frac{\partial}{\partial p_{ij}}&amp;\left[\mu_i\sum_{j =
1}^{m}p_{ij}\right]=\mu_i
\end{align*}
\]</span></p>
<p>所以式 ③ 化为： <span class="math display">\[
p_i\ln\frac{p_{ij}}{q_j}-sp_id_{ij}-\mu_i = 0\quad     i =
1,2,\cdots,n;j = 1,2,\cdots,m \quad ④
\]</span></p>
<p>由式 ④ 解出 <span class="math inline">\(p_{ij}\)</span> ： <span class="math display">\[
p_{ij} = q_j\exp\{sd_{ij}\}\exp\left\{\frac{\mu_i}{p_i}\right\} \quad i
= 1,2,\cdots,n;j = 1,2,\cdots,m \quad ⑤
\]</span></p>
<p>令 <span class="math inline">\(\lambda_i=\exp\left\{\frac{\mu_i}{p_i}\right\}\)</span>
，代入式 ⑤ 中得到： <span class="math display">\[
p_{ij} = \lambda_iq_j\exp\{sd_{ij}\} \quad i = 1,2,\cdots,n;j =
1,2,\cdots,m \quad ⑥
\]</span></p>
<p>由 <span class="math inline">\(\sum_{j = 1}^{m}p_{ij} = 1\)</span>
，将式 ⑥ 对 <span class="math inline">\(j\)</span> 求和可得到 <span class="math display">\[
1=\sum_{j = 1}^{m}\lambda_iq_j\exp\{sd_{ij}\} \quad i = 1,2,\cdots,n
\quad ⑦
\]</span></p>
<p>由式 ⑦ 可解出 <span class="math inline">\(\lambda_i\)</span> 的值
<span class="math display">\[
\lambda_i=\frac{1}{\sum_{j = 1}^{m}q_j\exp\{sd_{ij}\}} \quad ⑧
\]</span></p>
<p>由 <span class="math inline">\(q_j=\sum_{i = 1}^{n}p_ip_{ij}\)</span>
，将式 ⑥ 两边同乘 <span class="math inline">\(p_i\)</span> ，并对 <span class="math inline">\(i\)</span> 求和可得到 <span class="math display">\[
q_j=\sum_{i = 1}^{n}p_ip_{ij}=\sum_{i =
1}^{n}\lambda_ip_iq_j\exp\{sd_{ij}\} \quad j = 1,2,\cdots,m \quad
\]</span></p>
<p>即 <span class="math display">\[
\sum_{i = 1}^{n}\lambda_ip_i\exp\{sd_{ij}\}=1 \quad j = 1,2,\cdots,m
\quad ⑨
\]</span></p>
<p>将式 ⑧ 代入式 ⑨ 中，可得到关于 <span class="math inline">\(q_j\)</span> 的 <span class="math inline">\(m\)</span> 个方程 <span class="math display">\[
\sum_{i = 1}^{n}\frac{p_i\exp\{sd_{ij}\}}{\sum_{l =
1}^{m}q_l\exp\{sd_{il}\}} = 1 \quad j = 1,2,\cdots,m \quad ⑩
\]</span></p>
<p>由式 ⑩ 中可以解出以 <span class="math inline">\(s\)</span> 为参量的
<span class="math inline">\(m\)</span> 个 <span class="math inline">\(q_j\)</span> 值，将这 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(q_j\)</span> 值代入式 ⑧ 中可以解出以 <span class="math inline">\(s\)</span> 为参量的 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(\lambda_i\)</span> 值，再将解得的 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(q_j\)</span> 值和 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(\lambda_i\)</span> 值代入式 ⑥ 中，可以解出以 <span class="math inline">\(s\)</span> 为参量的 <span class="math inline">\(mn\)</span> 个 <span class="math inline">\(p_{ij}\)</span> 值。</p>
<p>将解出的 <span class="math inline">\(mn\)</span> 个 <span class="math inline">\(p_{ij}\)</span> 值代入定义式中求出以 <span class="math inline">\(s\)</span> 为参量的平均失真度 <span class="math inline">\(D(s)\)</span> <span class="math display">\[
D(s)=\sum_{i = 1}^{n}\sum_{j =
1}^{m}\lambda_ip_iq_jd_{ij}\exp\{sd_{ij}\} \quad ⑪
\]</span></p>
<p>其中， <span class="math inline">\(\lambda_i\)</span> 和 <span class="math inline">\(q_j\)</span> 由式 ⑦ 和 ⑩ 求得。</p>
<p>将解出的 <span class="math inline">\(mn\)</span> 个 <span class="math inline">\(p_{ij}\)</span> 值代入式 ② 中得到在约束条件 ① 下的
<span class="math inline">\(I(X,Y)\)</span> 的极小值，即以 <span class="math inline">\(s\)</span> 为参量的信息率失真函数 <span class="math inline">\(R(s)\)</span> <span class="math display">\[
\begin{align*}
R(s)&amp;=\sum_{i = 1}^{n}\sum_{j =
1}^{m}\lambda_ip_iq_j\exp\{sd_{ij}\}\ln\frac{\lambda_iq_j\exp\{sd_{ij}\}}{q_j}\\
&amp;=\sum_{i = 1}^{n}\sum_{j =
1}^{m}\lambda_ip_iq_j\exp\{sd_{ij}\}(\ln\lambda_i + sd_{ij})\\
&amp;=\sum_{i = 1}^{n}p_i\ln\lambda_i\left[\sum_{j =
1}^{m}\lambda_iq_j\exp\{sd_{ij}\}\right]+s\sum_{i = 1}^{n}\sum_{j =
1}^{m}\lambda_ip_iq_jd_{ij}\exp\{sd_{ij}\}\\
&amp;=\sum_{i = 1}^{n}p_i\ln\lambda_i\left(\sum_{j =
1}^{m}p_{ij}\right)+sD(s)\\
&amp;=\sum_{i = 1}^{n}p_i\ln\lambda_i + sD(s) \quad ⑫
\end{align*}
\]</span></p>
<p>一般情况下，参量 <span class="math inline">\(s\)</span>
无法消去，因此得不到 <span class="math inline">\(R(D)\)</span>
的闭式解，只有在某些特定的简单问题中才能消去参量 <span class="math inline">\(s\)</span> ，得到 <span class="math inline">\(R(D)\)</span> 的闭式解。若无法消去参量 <span class="math inline">\(s\)</span> ，就需要进行逐点计算。下面分析一下参量
<span class="math inline">\(s\)</span> 的意义。</p>
<p>将 <span class="math inline">\(R(D)\)</span> 看成 <span class="math inline">\(D(s)\)</span> 和 <span class="math inline">\(s\)</span> 的隐函数，而 <span class="math inline">\(\lambda_i\)</span> 又是 <span class="math inline">\(s\)</span> 的函数，利用全微分公式对 <span class="math inline">\(R(D)\)</span> 求导，可得 <span class="math display">\[
\begin{align*}
\frac{\mathrm{d}R(D)}{\mathrm{d}D}&amp;=\frac{\partial R(s)}{\partial
D(s)}+\frac{\partial R(s)}{\partial
s}\left(\frac{\mathrm{d}s}{\mathrm{d}D}\right)+\sum_{i =
1}^{n}\frac{\partial R(s)}{\partial
\lambda_i}\left(\frac{\mathrm{d}\lambda_i}{\mathrm{d}D}\right)\\
&amp;=s + D(s)\frac{\mathrm{d}s}{\mathrm{d}D}+\sum_{i =
1}^{n}\frac{p_i}{\lambda_i}\cdot\frac{\mathrm{d}\lambda_i}{\mathrm{d}D}\\
&amp;=s+\left[D(s)+\sum_{i =
1}^{n}\frac{p_i}{\lambda_i}\cdot\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}\right]\frac{\mathrm{d}s}{\mathrm{d}D}
\quad ⑬
\end{align*}
\]</span></p>
<p>为求出 <span class="math inline">\(\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}\)</span>
，将式 ⑦ 对 <span class="math inline">\(s\)</span> 求导，得到 <span class="math display">\[
\sum_{i =
1}^{n}\left[p_i\exp\{sd_{ij}\}\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+\lambda_ip_id_{ij}\exp\{sd_{ij}\}\right]=0
\]</span></p>
<p>将上式两边同乘以 <span class="math inline">\(q_j\)</span> ，并对
<span class="math inline">\(j\)</span> 求和，可得 <span class="math display">\[
\sum_{j = 1}^{m}q_j\sum_{i =
1}^{n}\left[p_i\exp\{sd_{ij}\}\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+\lambda_ip_id_{ij}\exp\{sd_{ij}\}\right]=0
\]</span></p>
<p>即 <span class="math display">\[
\sum_{i = 1}^{n}p_i\left[\sum_{j =
1}^{m}q_j\exp\{sd_{ij}\}\right]\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+\sum_{i
= 1}^{n}\sum_{j = 1}^{m}\lambda_ip_iq_jd_{ij}\exp\{sd_{ij}\}=0
\]</span></p>
<p>将式 ⑧ 和 ⑫ 代入上式，可得 <span class="math display">\[
\sum_{i =
1}^{n}p_i\frac{1}{\lambda_i}\frac{\mathrm{d}\lambda_i}{\mathrm{d}s}+D(s)=0
\quad ⑭
\]</span></p>
<p>将式 ⑭ 代入式 ⑬ 中，可得 <span class="math display">\[
\frac{\mathrm{d}R(D)}{\mathrm{d}D}=s \quad ⑮
\]</span></p>
<p>式 ⑮ 表明，参量 <span class="math inline">\(s\)</span>
是信息率失真函数 <span class="math inline">\(R(D)\)</span> 的斜率。由
<span class="math inline">\(R(D)\)</span> 在 <span class="math inline">\(0 &lt; D &lt; D_{max}\)</span>
之间是严格单调减函数可知， <span class="math inline">\(s\)</span>
是负值，且是 <span class="math inline">\(D\)</span> 的递增函数，即 <span class="math inline">\(s\)</span> 将随 <span class="math inline">\(D\)</span> 的增加而增加。 由 <span class="math inline">\(R(D)\)</span> 的性质可知，在 <span class="math inline">\(D = 0\)</span> 处， <span class="math inline">\(R(D)\)</span> 的斜率有可能为 <span class="math inline">\(-\infty\)</span> ；当 <span class="math inline">\(D &gt; D_{max}\)</span> 时， <span class="math inline">\(R(D)=0\)</span> ，其斜率为零。所以参量 <span class="math inline">\(s\)</span> 的取值为 <span class="math inline">\((-\infty,0)\)</span> 。
进一步还可以证明：信息率失真函数 <span class="math inline">\(R(D)\)</span> 是参量 <span class="math inline">\(s\)</span> 的连续函数； <span class="math inline">\(R(D)\)</span> 的斜率，即参量 <span class="math inline">\(s\)</span> 是失真度 <span class="math inline">\(D\)</span> 的连续函数，在 <span class="math inline">\(D = D_{max}\)</span> 处， <span class="math inline">\(R(D)\)</span> 的斜率可能是不连续的。</p></li>
</ol>
<h1 id="第五章-信源编码">第五章 信源编码</h1>
<h2 id="信源编码与信道编码">信源编码与信道编码</h2>
<ul>
<li><strong>信源编码</strong>
<ul>
<li><strong>无失真信源编码——第一极限定理</strong>：离散信源</li>
<li><strong>限失真信源编码——第三极限定理</strong>：连续信源</li>
<li>在不失真或允许一定失真条件下，如何用尽可能少的符号来传送信源信息，以便提高信息传输率。</li>
</ul></li>
<li><strong>信道编码</strong>
<ul>
<li><strong>第二极限定理</strong>：离散和连续信道</li>
<li>在信道受干扰的情况下如何增加信号的抗干扰能力，同时又使得信息传输率最大。</li>
</ul></li>
<li><strong>信源编码的作用</strong>
<ol type="1">
<li><strong>符号变换</strong>：使信源的输出符号与信道的输入符号相匹配；</li>
<li><strong>信息匹配</strong>：使信息传输率达到信道容量；</li>
<li><strong>冗余度压缩</strong>：使编码效率等于或接近100%。</li>
</ol>
<ul>
<li>例题：<img src="image-42.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul></li>
<li><strong>信源编码的基础</strong>
<ol type="1">
<li><strong>无失真编码定理</strong>：可精确复制信源输出的消息，只适用于离散信源</li>
<li><strong>限失真编码定理</strong>：对于连续信源，只能在失真受限制的情况下进行限失真编码</li>
</ol></li>
</ul>
<h2 id="编码的概念">5.1 编码的概念</h2>
<h3 id="分组码">分组码</h3>
<ul>
<li><strong>分组码(Block Codes)</strong>：也叫块码
<ul>
<li>将信源消息分成若干组，即符号序列 <span class="math inline">\(x_{i}\)</span> ， <span class="math display">\[\begin{align*}x_{i}&amp;=(x_{i1}x_{i2} \cdots
x_{il} \cdots x_{iL})\\x_{il}&amp;\in A=\{a_{1}, a_{2}, \cdots, a_{i},
\cdots, a_{n}\}\end{align*}\]</span></li>
<li>每个符号序列 <span class="math inline">\(x_{i}\)</span>
依照<strong>固定码表</strong>映射成一个码字 <span class="math inline">\(y_{i}\)</span> ， <span class="math display">\[\begin{align*}y_{i}&amp;=(y_{i1}y_{i2} \cdots
y_{ik} \cdots y_{iK})\\y_{ik}&amp;\in B=\{b_{1}, b_{2}, \cdots, b_{i},
\cdots, b_{m}\}\end{align*}\]</span></li>
<li>只有分组码才有对应的码表，而非分组码中则不存在码表。</li>
<li><strong>模型</strong>：<img src="image-43.webp" srcset="/img/loading/loading3.gif" lazyload alt="模型"></li>
</ul></li>
<li><strong>定长码与变长码</strong>：码可分为两类：
<ul>
<li><strong>定长码</strong>：码中所有码字的长度都相同，如码1就是定长码(Fixed
Length Codes)。</li>
<li><strong>变长码</strong>：码中的码字长短不一，如码2就是变长码(Variable
Length Codes)。</li>
<li><table>
<thead>
<tr>
<th>符号 <span class="math inline">\(a_{i}\)</span></th>
<th>信源符号出现概率 <span class="math inline">\(p(a_{i})\)</span></th>
<th>码1</th>
<th>码2</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(a_{1}\)</span></td>
<td><span class="math inline">\(p(a_{1})\)</span></td>
<td>00</td>
<td>0</td>
</tr>
<tr>
<td><span class="math inline">\(a_{2}\)</span></td>
<td><span class="math inline">\(p(a_{2})\)</span></td>
<td>01</td>
<td>01</td>
</tr>
<tr>
<td><span class="math inline">\(a_{3}\)</span></td>
<td><span class="math inline">\(p(a_{3})\)</span></td>
<td>10</td>
<td>001</td>
</tr>
<tr>
<td><span class="math inline">\(a_{4}\)</span></td>
<td><span class="math inline">\(p(a_{4})\)</span></td>
<td>11</td>
<td>111</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><strong>码的属性</strong>：
<ul>
<li><strong>奇异码与非奇异码</strong>：
<ul>
<li>若信源符号和码字是一一对应的，则该码为<strong>非奇异码</strong>(Non-Singular
Codes)；</li>
<li>反之为<strong>奇异码</strong>(Singular Codes)</li>
</ul></li>
<li><strong>唯一可译码(Uniquely Decodable Codes_)</strong>：
<ul>
<li>任意有限长的码元序列，只能被唯一地分割成一个个的码字，便称为唯一可译码。</li>
<li>奇异码不是唯一可译码</li>
<li>唯一可译码分为非即时码和即时码
<ul>
<li><strong>非即时码</strong>指接收端收到一个完整的码字后不能立即译码，还需等下一个码字开始接收后才能判断是否可以译码</li>
<li><strong>即时码</strong>只要收到符号就表示该码字已完整，可以立即译码
，又称为<strong>非延长码</strong>(Undelayed
Codes)，任意一个码字都不是其它码字的前缀部分，又称为<strong>异前缀码</strong>(Prefix
Codes)。</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="码的分类">码的分类</h3>
<figure>
<img src="image-121.webp" srcset="/img/loading/loading3.gif" lazyload alt="码的分类">
<figcaption aria-hidden="true">码的分类</figcaption>
</figure>
<h3 id="即时码及其树图构造法">即时码及其树图构造法</h3>
<ul>
<li><p>即时码(非延长码或异前缀码)是唯一可译码的一类子码，可用树图来构造</p></li>
<li><p><strong>构造的要点</strong>：</p>
<ul>
<li>最上端为树根A，从根出发向下伸出树枝，树枝总数等于m(<strong>进制数</strong>)，树枝的尽头为节点。</li>
<li>从每个节点再伸出m个树枝，当某个节点被安排为码字后，就不再伸枝，这节点为<strong>终端节点</strong>。能再伸枝的节点成为<strong>中间节点</strong>。一直继续下去，直至都不能伸枝为止。</li>
<li>每个节点所伸出的树枝标上码符号，从根出发到终端点所走路径对应的码符号序列则为终端节点的码字。</li>
</ul></li>
<li><p><strong>用码树图构造码</strong></p>
<ul>
<li>在树的生长过程中，节点生出树枝，各树枝旁标出相应的码符，为了清晰起见相同码符的树枝方向相同，终端节点表示信源符号，从树根到终端节点所经过的树枝旁的码符按经过的顺序组成的序列构成码字。</li>
</ul></li>
<li><p><strong>用码树图判断即时码</strong></p>
<ul>
<li>如果表示信源符号的终端节点不再延伸，或到达任一
信源符号终端节点的路径不经过其它的终端节点，这样构
造的码满足即时码条件。</li>
</ul></li>
<li><p><strong>码树与码字对应关系</strong></p>
<table>
<thead>
<tr>
<th>树结构概念</th>
<th>编码概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>树根</td>
<td>码字的起点</td>
</tr>
<tr>
<td>树枝数</td>
<td>码的进制数</td>
</tr>
<tr>
<td>节点</td>
<td>码字或码字的一部分</td>
</tr>
<tr>
<td>终端节点</td>
<td>码字</td>
</tr>
<tr>
<td>节数</td>
<td>码长</td>
</tr>
<tr>
<td>非满树</td>
<td>变长码（码字为叶节点）</td>
</tr>
<tr>
<td>满树</td>
<td>等长码（码字为叶节点）</td>
</tr>
</tbody>
</table></li>
</ul>
<h3 id="克劳夫特不等式">克劳夫特不等式</h3>
<ul>
<li><p><strong>唯一可译码存在</strong>的充分必要条件是各码字的长度 <span class="math inline">\(K_{i}\)</span>
应符合<strong>克劳夫特不等式</strong>(Kraft Inequality) <span class="math display">\[\sum_{i=1}^{n} m^{-K_{i}} \leq 1\]</span></p>
<p>式中，m是编码进制数，n是信源符号数。</p>
<ul>
<li>必要性表现在如果码是唯一可译码，则必定满足该不等式</li>
<li>充分性表现在如果满足该不等式，则这种码长的唯一可译码一定存在，但并不表示所有满足不等式的一定是唯一可译码。</li>
<li>所以说，该不等式是唯一可译码存在的充要条件，而不是判别一个编码是否唯一可译码的充要条件</li>
</ul></li>
<li><p><strong>唯一可译码的判断方法</strong></p>
<ol type="1">
<li><strong>基本判断</strong>：
<ol type="1">
<li>观察是否是非奇异码，若是奇异码则一定不是唯一可译码。</li>
<li>计算是否满足Kraft不等式，若不满足一定不是唯一可译码。</li>
<li>将码画成一棵树图，观察是否满足即时码的树图的构造，若满足则是唯一可译码。</li>
</ol></li>
<li><strong>尾随后缀法</strong>： <img src="image-46.webp" srcset="/img/loading/loading3.gif" lazyload>
<ol type="1">
<li>考查 <span class="math inline">\(C\)</span> 中所有的码字，若 <span class="math inline">\(W_{i}\)</span> 是 <span class="math inline">\(W_{j}\)</span>
的前缀，则将相应的后缀作为一个尾随后缀码放入集合 <span class="math inline">\(F_{0}\)</span> 中</li>
<li>考查 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(F_{i}\)</span> 两个集合, <span class="math inline">\(W_{i} \in C\)</span> 是 <span class="math inline">\(W_{j} \in F_{i}\)</span> 的前缀或 <span class="math inline">\(W_{i} \in F_{i}\)</span> 是 <span class="math inline">\(W_{j} \in C\)</span>
的前缀，则将相应的后缀作为尾随后缀码放入集合 <span class="math inline">\(F_{i+1}\)</span> 中;</li>
<li><span class="math inline">\(F=\cup _{i} F_{i}\)</span> 即为码 <span class="math inline">\(C\)</span> 的尾随后缀集合;</li>
<li>构造尾随后缀集合F，若F中出现了<span class="math inline">\(C\)</span>中的元素，则算法终止，返回假(<span class="math inline">\(C\)</span>不是唯一可译码)；否则若F中没有出现新的元素，则返回真。</li>
</ol>
<ul>
<li><strong>例题</strong>：判断码<span class="math inline">\(C\)</span>：<span class="math inline">\(\{0, 1001,
1011, 1101, 1111, 011\}\)</span>是否是唯一可译码。
<ul>
<li>构造尾随后缀集合<span class="math inline">\(F\)</span>：码字 “0” 是
“011” 的前缀，其尾随后缀 “11” 是码字 “1011” 和 “1111”
的前缀，得尾随后缀为 “01” 和 “11” ，其中 “0” 是 “01” 的前缀，尾随后缀为
“1” ，“1” 又是 “1011” 的前缀，得到尾随后缀 “011” ，而 <strong>“011”
是<span class="math inline">\(C\)</span>中码字</strong>，所以码<span class="math inline">\(C\)</span>不是唯一可译码。</li>
<li>尾随后缀集合<span class="math inline">\(F = \{11, 01, 1, 001, 011,
111\}\)</span> ， “011” 是一个码字，因此不唯一可译。 <span class="math inline">\(0 \longrightarrow 11 \longrightarrow
01\longrightarrow 1 \longrightarrow 001\)</span>，<span class="math inline">\(\colorbox{yellow}{011}\)</span>，<span class="math inline">\(111\)</span></li>
</ul></li>
</ul></li>
</ol></li>
</ul>
<h2 id="无失真信源编码定理">5.2 无失真信源编码定理</h2>
<h3 id="无失真信源编码">无失真信源编码</h3>
<ul>
<li><strong>模型</strong>：<img src="image-44.webp" srcset="/img/loading/loading3.gif" lazyload alt="模型">
<ul>
<li><p>信源编码器输入的消息序列： <span class="math display">\[\begin{align*}X=(X_{1}X_{2} \cdots X_{l} \cdots
X_{L})\quad X_{l}\in\{a_{1}, \cdots a_{n}\}\end{align*}\]</span></p>
<p>输入的消息总共有 <span class="math inline">\(n^{L}\)</span>
种可能的组合 输出的码字为： <span class="math display">\[\begin{align*}Y=(Y_{1}Y_{2} \cdots Y_{k} \cdots
Y_{K_{L}})\quad Y_{k}\in\{b_{1}, \cdots b_{m}\}\end{align*}\]</span></p>
<p>输出的码字总共有 <span class="math inline">\(m^{K_{L}}\)</span>
种可能的组合。</p></li>
<li><p><span class="math inline">\(Y_{k}\)</span>有<span class="math inline">\(m\)</span>种可能取值，所以平均每个符号输出的最大信息量为<span class="math inline">\(\log m\)</span>（等概分布）。</p></li>
<li><p><span class="math inline">\(K_{L}\)</span>长码字的最大信息量为<span class="math inline">\(K_{L}\log m\)</span>，用该码字表示<span class="math inline">\(L\)</span>长的信源序列。</p></li>
<li><p>则传送一个信源符号需要的平均信息率为： <span class="math display">\[\overline{K}=\frac{K_{L}}{L}\log m =
\frac{1}{L}\log M \text{ bit/信源符号}\]</span></p>
<p>其中，<span class="math inline">\(M = m^{K_{L}}\)</span>是<span class="math inline">\(Y\)</span>所能编成的码字的个数。</p></li>
</ul></li>
<li><strong>无失真信源编码</strong>
<ul>
<li><strong>实现无失真的信源编码要求</strong>：
<ul>
<li>信源符号 <span class="math inline">\(X_{1}X_{2}\cdots X_{l} \cdots
X_{L}\)</span> 与码字 <span class="math inline">\(Y_{1}Y_{2}\cdots
Y_{k}\cdots Y_{K_{L}}\)</span> 是一一对应的；</li>
<li>能够无失真或无差错地从Y恢复X，也就是能正确地进行反变换或译码 ；</li>
<li>传送Y时所需要的信息率最小，信息率最小就是找到一种编码方式使<span class="math inline">\(\overline{K}  = \frac{K_L}{L} \log m =\frac{1}{L}
\log M\)</span>最小</li>
</ul></li>
<li><strong>无失真信源编码定理研究内容</strong>：
<ul>
<li>最小信息率为多少时，才能得到无失真的译码？</li>
<li>若小于这个信息率是否还能无失真地译码？</li>
</ul></li>
</ul></li>
</ul>
<h3 id="定长编码">定长编码</h3>
<h4 id="定长编码的基本概念">定长编码的基本概念</h4>
<ul>
<li>码长<span class="math inline">\(K\)</span>是定值，且是唯一可译码。</li>
<li>由<span class="math inline">\(L\)</span>个符号组成的、每个符号的熵为<span class="math inline">\(H_{L}(X)\)</span>的无记忆平稳信源符号序列<span class="math inline">\(X_{1}X_{2}...X_{l}...X_{L}\)</span>（每个符号<span class="math inline">\(n\)</span>种可能值）</li>
<li>输入的消息总共有<span class="math inline">\(n^{L}\)</span>种可能的组合。</li>
<li>可用<span class="math inline">\(K_{L}=K\)</span>个符号<span class="math inline">\(Y_{1}\)</span>，<span class="math inline">\(Y_{2}\)</span>，…，<span class="math inline">\(Y_{k}\)</span>，…，<span class="math inline">\(Y_{K_L}\)</span>（每个符号有<span class="math inline">\(m\)</span>种可能值）进行定长编码</li>
<li>输出的码字总共有<span class="math inline">\(m^{K}\)</span>种可能的组合</li>
<li><strong>若要对信源进行定长编码且无失真</strong>，必须满足： <span class="math display">\[n^{L} \leq m^{K} 或 \frac{K}{L} \geq \frac{\log
n}{\log m}\]</span>
<ul>
<li>只有当<span class="math inline">\(K\)</span>长的码符号序列数<span class="math inline">\(m^{K}\)</span>大于或等于信源的符号数<span class="math inline">\(n^{L}\)</span>时，才可能存在定长非奇异码。</li>
</ul></li>
</ul>
<h4 id="渐进均分性定理aep">渐进均分性定理（AEP）</h4>
<ul>
<li><strong>定理</strong>：<span class="math inline">\(\vec{X_{}}=(X_1
X_2 \cdots
X_L)\)</span>，为独立同分布（i.i.d）随机变量序列，具有渐近均分性质（AEP，Asymptotic
equipartition property）： <span class="math display">\[\forall
\varepsilon &gt; 0，当 L \to \infty时，p(X_1,X_2,\cdots,X_L) \to 2^{-L
H(X)}\]</span></li>
<li><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#渐进均分性定理aep">无失真信源编码定理</a></strong></li>
</ul>
<h4 id="定长编码定理">定长编码定理</h4>
<ul>
<li><p><strong>定理</strong>：对于由 <span class="math inline">\(L\)</span> 个符号组成的，每个符号的熵为 <span class="math inline">\(H_L(\vec{X_{}})\)</span> 的无记忆平稳符号序列
<span class="math inline">\(X_1, X_2, \cdots, X_L\)</span>，可用 <span class="math inline">\(K_L\)</span> 个符号 <span class="math inline">\(Y_1, Y_2, \cdots, Y_{K_L}\)</span>（每个符号有
<span class="math inline">\(m\)</span> 种可能值，即<span class="math inline">\(m\)</span>进制编码）进行定长编码。对于任意 <span class="math inline">\(\varepsilon &gt; 0\)</span>，<span class="math inline">\(\delta &gt; 0\)</span>，只要 <span class="math display">\[\overline{K} = \frac{K_L}{L}\log m \geq
H_L(\vec{X_{}}) + \varepsilon\]</span></p>
<p>则当 <span class="math inline">\(L\)</span>
足够大时，必可使译码差错小于 <span class="math inline">\(\delta\)</span>； 反之，当 <span class="math display">\[\overline{K} = \frac{K_L}{L}\log m \leq
H_L(\vec{X_{}}) - 2\varepsilon\]</span></p>
<p>时，译码差错一定是有限值，当 <span class="math inline">\(L \to
\infty\)</span> 时，译码几乎必定出错。</p></li>
<li><p><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#定长编码定理">无失真信源编码定理</a></strong></p></li>
<li><p><strong>定长编码定理含义</strong></p>
<ul>
<li><p>当编码器容许的输出信息率，也就是当每个信源符号所必须输出的二进制码长是
<span class="math display">\[
  \overline{K}=\frac{K_{L}}{L}\log m=\frac{1}{L}\log M
  \]</span></p>
<p>时，只要 <span class="math inline">\(\overline{K}&gt;H_{L}(X)\)</span>
，这种编码器一定可以做到<strong>几乎无失真</strong>，也就是收端的译码差错概率接近于零，<strong>条件是所取的符号数
<span class="math inline">\(L\)</span>足够大</strong>。</p></li>
<li><p>将定理的条件改写成： <span class="math display">\[
  K_{L}\log m&gt;L H_{L}(X)=H(X)
  \]</span> 其中：</p>
<ul>
<li>左边：<span class="math inline">\(K_{L}\)</span>长码字所能携带的最大信息。</li>
<li>右边：<span class="math inline">\(L\)</span>长信源序列携带的信息量。</li>
</ul>
<p>则：</p>
<ul>
<li>码字所能携带的信息量<strong>大于</strong>信源序列输出的信息量，则可以使传输<strong>几乎无失真</strong>，当然<strong>条件是
<span class="math inline">\(L\)</span>足够大</strong>。</li>
<li>反之，当 <span class="math inline">\(\overline{K} &lt;
H_{L}(X)\)</span>
时，不可能构成无失真的编码，也就是不可能做一种编码器，能使收端译码时差错概率趋于零。</li>
<li><span class="math inline">\(\overline{K}=H_{L}(X)\)</span>
时，则为临界状态，可能无失真，也可能有失真。</li>
</ul></li>
</ul></li>
<li><p><strong>信源长度 <span class="math inline">\(L\)</span></strong></p>
<ul>
<li><p>对定长编码，若要实现几乎无失真编码，则信源长度必须满足： <span class="math display">\[L \geq \frac{\sigma^{2}(X)}{\varepsilon^{2}
\delta}\]</span></p>
<p>其中：</p>
<ul>
<li><span class="math inline">\(\sigma^{2}(X)=E\{[I(x_{i}) -
H(X)]^{2}\}\)</span>，表示信源序列的自信息方差。</li>
<li><span class="math inline">\(\delta\)</span>：差错率要求（如<span class="math inline">\(10^{-6}\)</span>）</li>
<li><span class="math inline">\(\varepsilon =
\overline{K}-H_{L}(X)\)</span></li>
</ul></li>
<li><p>证明：见<a href="Ch5sup_无失真信源编码定理.md/#定长编码定理">无失真信源编码定理</a></p></li>
</ul></li>
<li><p><strong>编码效率<span class="math inline">\(\eta\)</span></strong></p>
<ul>
<li><p>编码效率定义为 <span class="math display">\[\eta =
\frac{H_{L}(X)}{\overline{K}}\]</span> 即信源的平均符号熵为<span class="math inline">\(H_{L}(X)\)</span>，采用平均二进制符号码长为<span class="math inline">\(\overline{K}\)</span>来编码，所得的效率。</p></li>
<li><p>无失真编码效率总是小于<span class="math inline">\(1\)</span>，且<strong>最佳编码效率</strong>为
<span class="math display">\[\eta =
\frac{H_{L}(X)}{H_{L}(X)+\varepsilon},\varepsilon &gt;
0\]</span></p></li>
<li><p>定长编码定理从理论上阐明了编码效率接近<span class="math inline">\(1\)</span>的理想定长编码器的存在性，它使输出符号的信息率与信源熵之比接近于<span class="math inline">\(1\)</span>，即只要<span class="math inline">\(L\)</span>足够大 <span class="math display">\[\frac{H_{L}(X)}{\frac{K_{L}}{L}\log m} \to
1\]</span></p>
<ul>
<li>但要在实际中实现，<span class="math inline">\(L\)</span>必须取无限长的信源符号进行统一编码。这样做实际上是不可能的，因<span class="math inline">\(L\)</span>非常大，无法实现。</li>
<li>当<span class="math inline">\(L\)</span>有限时，要做到高编码效率、低错误率，对于定长编码来说是不可能做到的。</li>
</ul></li>
</ul></li>
<li><p><strong>例题</strong>：<img src="image-92.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h3 id="变长编码">变长编码</h3>
<h4 id="变长编码的基本概念">变长编码的基本概念</h4>
<ul>
<li>在变长编码中，码长<span class="math inline">\(K_{i}\)</span>是变化的。</li>
<li><span class="math inline">\(m\)</span>进制平均码长：<span class="math inline">\(\overline{K^{'}} = \sum_{i}
p(a_{i})K_{i}\)</span></li>
<li>根据信源各个符号的统计特性，如概率大的符号用短码，概率小的用较长的码，使得编码后平均码长降低，从而提高编码效率。（统计匹配）</li>
</ul>
<h4 id="单个符号变长编码定理">单个符号变长编码定理</h4>
<ul>
<li><strong>定理</strong>：若离散无记忆信源的符号熵为 <span class="math inline">\(H(X)\)</span>
，每个信源符号用m进制码元进行变长编码，一定存在一种无失真编码方法，其(m进制)码字平均长度
<span class="math inline">\(\overline{K'}\)</span> 满足下列不等式
<span class="math display">\[\frac{H(X)}{\log m} \leq
\overline{K'}&lt;\frac{H(X)}{\log m}+1\]</span></li>
<li><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#单符号变长编码定理">无失真信源编码定理</a></strong></li>
</ul>
<h4 id="离散平稳无记忆序列变长编码定理香农第一定理">离散平稳无记忆序列变长编码定理(香农第一定理)</h4>
<ul>
<li><p>由单个符号变长编码定理推广而来： <span class="math display">\[
  \begin{align*}
  \frac{H(X)}{\log m} \leq &amp;\overline{K^{'}} &lt;
\frac{H(X)}{\log m} + 1 \\
  \Rightarrow \frac{LH_{L}(X)}{\log m} \leq &amp;\overline{K_{L}} &lt;
\frac{LH_{L}(X)}{\log m} + 1\\
  \Rightarrow H_{L}(X) \leq &amp;\overline{K} &lt; H_{L}(X)+\frac{\log
m}{L}
  \end{align*}
  \]</span></p></li>
<li><p><strong>定理</strong>：对于离散平稳无记忆信源，必存在一种无失真编码方法，使平均信息率
<span class="math inline">\(\overline{K}\)</span> 满足不等式 <span class="math display">\[H_{L}(X) \leq \overline{K} &lt;
H_{L}(X)+\frac{\log m}{L}\]</span></p>
<p>其中<span class="math inline">\(\overline{K} =
\frac{\overline{K_{L}}}{L}\log m\)</span>，当L足够大时，可使 <span class="math inline">\(\frac{\log m}{L}&lt;\varepsilon\)</span> ，得到
<span class="math display">\[H_{L}(X) \leq \overline{K} &lt;
H_{L}(X)+\varepsilon\]</span></p>
<p>其中<span class="math inline">\(\varepsilon\)</span>是任意小的正数。</p></li>
<li><p><strong>证明</strong>：<strong>见<a href="Ch5sup_无失真信源编码定理.md/#离散平稳无记忆序列变长编码定理香农第一定理">无失真信源编码定理</a></strong></p></li>
<li><p><strong>变长编码效率</strong>
变长编码效率的<strong>下界</strong>： <span class="math display">\[
  \eta=\frac{H_{L}(X)}{\overline{K}} &gt; \frac{H_{L}(X)}{H_{L}(X) +
\frac{\log m}{L}}
  \]</span></p>
<p>无失真编码效率总是小于1，可以用它来衡量各种编码方法的优劣。
为了衡量各种编码方法与最佳码的差距，定义<strong>码的剩余度</strong>为：
<span class="math display">\[
  \gamma = 1 - \eta = 1 - \frac{H_{L}(X)}{\frac{\overline{K_{L}}}{L}\log
m}= 1 - \frac{H_{L}(X)}{\overline{K}}
  \]</span></p>
<p>对某一信源和某一码符号集，若有一个唯一可译码，其平均长度小于所有其他唯一可译码的平均长度，则称该码为<strong>最佳码</strong>或<strong>紧致码</strong>。</p></li>
<li><p><strong>例题</strong>：</p>
<ul>
<li>例题1：<img src="image-93.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
<li>例题2：<img src="image-94.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul></li>
</ul>
<h3 id="香农编码">香农编码</h3>
<ul>
<li><p>香农第一定理指出了平均码长与信源熵之间的关系，同时也指出了可以通过编码使平均码长达到极限值，这是一个很重要的极限定理。</p></li>
<li><p>香农第一定理指出，选择每个码字的长度<span class="math inline">\(l_{i}\)</span>满足下式： <span class="math display">\[l_{i} =\left\lceil
\log\frac{1}{p(x_{i})}\right\rceil（向上取整）\]</span>或：<span class="math display">\[I(x_{i})\leq l_{i} &lt; I(x_{i}) + 1\]</span></p>
<p>这种编码方法称为香农编码</p></li>
<li><p><strong>编码步骤</strong></p>
<ol type="1">
<li>将信源消息符号按其出现的概率大小依次排列：<span class="math display">\[p_{1}\geq p_{2}\geq\cdots\geq p_{n}\]</span></li>
<li>依照下列不等式确定整数的码长<span class="math inline">\(K_{i}\)</span>：<span class="math display">\[-\log_{2}(p_{i})\leq l_{i} &lt; -\log_{2}(p_{i})
+ 1\]</span></li>
<li>为了编成唯一可译码，计算第<span class="math inline">\(i\)</span>个消息的累加概率：<span class="math display">\[P_{i}=\sum_{k = 1}^{i - 1}p(a_{k})\]</span></li>
<li>将累加概率<span class="math inline">\(P_{i}\)</span>变换成二进制数</li>
<li>取<span class="math inline">\(P_{i}\)</span>二进制数的小数点后<span class="math inline">\(l_{i}\)</span>位即为该消息符号的二进制码字</li>
</ol></li>
<li><p><strong>香农编码图示</strong></p>
<ul>
<li>累加概率<span class="math inline">\(P_{i}\)</span>把区间<span class="math inline">\([0,
1)\)</span>分割成许多小区间，每个小区间的长度等于各符号的概率<span class="math inline">\(p_{i}\)</span>，小区间内的任一点可用来代表该符号
：<span class="math inline">\(P_{i}=\sum_{k = 1}^{i -
1}p(a_{k})\)</span></li>
<li><figure>
<img src="image-45.webp" srcset="/img/loading/loading3.gif" lazyload alt="香农编码图示">
<figcaption aria-hidden="true">香农编码图示</figcaption>
</figure></li>
</ul></li>
<li><p><strong>例题</strong>：<img src="image-58.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></p></li>
</ul>
<h2 id="限失真信源编码定理">5.3 限失真信源编码定理</h2>
<h3 id="无失真与有失真信源编码">无失真与有失真信源编码</h3>
<ul>
<li>无失真信源编码是<strong>保熵的</strong>：通过信道的信息传输率<span class="math inline">\(R\)</span>等于信源熵<span class="math inline">\(H(X)\)</span>。</li>
<li>有失真信源编码属<strong>熵压缩编码</strong>，即编码后的信息率得到压缩。</li>
<li>采用有失真的熵压缩编码的原因：
<ul>
<li>保熵编码并非总是必需的；</li>
<li>保熵编码并非总是可能的；</li>
<li>降低信息率有利于传输和处理。</li>
</ul></li>
</ul>
<h3 id="限失真信源编码定理-1">限失真信源编码定理</h3>
<ul>
<li><p>信息率失真函数给出了失真小于<span class="math inline">\(D\)</span>时所必须具有的最小信息率<span class="math inline">\(R(D)\)</span>；只要信息率大于<span class="math inline">\(R(D)\)</span>，一定可以找到一种编码，使译码后的失真小于<span class="math inline">\(D\)</span>。</p></li>
<li><p><strong>限失真信源编码定理</strong>：设<strong>离散无记忆信源</strong><span class="math inline">\(X\)</span>的信息率失真函数为<span class="math inline">\(R(D)\)</span>，则当信息率<span class="math inline">\(R&gt;R(D)\)</span>，只要信源序列长度<span class="math inline">\(L\)</span>足够长，一定存在一种编码方法，其译码失真小于或等于<span class="math inline">\(D + \varepsilon\)</span>，<span class="math inline">\(\varepsilon\)</span>为任意小的正数。反之，若<span class="math inline">\(R &lt;
R(D)\)</span>，则无论采用什么样的编码方法，其译码失真必大于<span class="math inline">\(D\)</span>。</p></li>
<li><p>二元信源编码：</p>
<ul>
<li><p>对于任意小的<span class="math inline">\(\varepsilon\)</span>，每一个信源符号的平均码长满足如下公式：
<span class="math display">\[R(D) \leq \overline{K} &lt; R(D) +
\varepsilon\]</span></p>
<p>在失真限度内使信息率任意接近<span class="math inline">\(R(D)\)</span>的编码方法是存在的。然而，如果使信息率小于<span class="math inline">\(R(D)\)</span>，平均失真一定会超过失真限度<span class="math inline">\(D\)</span>。</p></li>
</ul></li>
<li><p>对于<strong>连续</strong>平稳无记忆信源，无法进行无失真编码，在<strong>限失真</strong>情况下，有与上述定理一样的编码定理。</p></li>
<li><p>限失真信源编码定理只能说明<strong>最佳编码是存在的</strong>，而具体构造编码方法却一无所知。因而就不能象无失真编码那样从证明过程中引出概率匹配的编码方法。一般只能从优化的思路去求最佳编码。实际上迄今尚无合适的可实现的编码方法可接近<span class="math inline">\(R(D)\)</span>这个界。</p></li>
</ul>
<h2 id="常用信源编码方法简介">5.4 常用信源编码方法简介</h2>
<h3 id="变长码与存储器容量">变长码与存储器容量</h3>
<ul>
<li><p><span class="math inline">\(T\)</span>秒内有<span class="math inline">\(N\)</span>个信源符号输出，信源输出符号速率<span class="math inline">\(S = N/T\)</span>，若符号的平均码长为<span class="math inline">\(\overline{K}\)</span>，则信道<strong>传输速率</strong>需要
<span class="math display">\[R_{t}=S\overline{K}\]</span></p></li>
<li><p><span class="math inline">\(N\)</span>个码字的长度分别为<span class="math inline">\(K_{i},i =
1,\ldots,N\)</span>，即在此期间输入存储器<span class="math inline">\(\sum_{i = 1}^{N}K_{i}\)</span> bit，输出信道<span class="math inline">\(R_{t}T\)</span>
bit，则在<strong>存储器里还剩</strong>： <span class="math display">\[X=\sum_{i = 1}^{N}K_{i}-R_{t}T\]</span></p></li>
<li><p>已知<span class="math inline">\(K_{i}\)</span>是随机变量，其均值和方差为： <span class="math display">\[
  \overline{K}=E[K_{i}]=\sum_{j = 1}^{m}p_{j}K_{j}\\
  \sigma^{2}=E[K_{i}^{2}]-\overline{K}^{2}=\sum_{j =
1}^{m}p_{j}K_{j}^{2}-\overline{K}^{2}
  \]</span></p>
<p>式中<span class="math inline">\(m\)</span>为信源符号集的元数。当<span class="math inline">\(N\)</span>足够大时，<span class="math inline">\(X\)</span>是许多独立同分布的随机变量之和，它近似于正态分布
<span class="math display">\[p_{X}(x)=\frac{1}{\sqrt{2\pi}\sigma_{X}}e^{-\frac{(x
- E[X])^{2}}{2\sigma_{X}^{2}}}\]</span></p>
<p>其均值和方差分别为： <span class="math display">\[
  E[X]=N\overline{K}-R_{t}T\]</span><span class="math display">\[
  \sigma_{X}^{2}=N\sigma^{2}
  \]</span></p></li>
<li><p>若信道速率满足<span class="math inline">\(R_{t}=S\overline{K}\)</span>，<span class="math inline">\(E[X]=0\)</span>。假设存储器容量为<span class="math inline">\(2A\sigma_{X}\)</span>，起始时存储器为半满，则<strong>溢出概率</strong>为：
<span class="math display">\[P(X &gt;
A\sigma_{X})=\phi(-A)=\int_{-\infty}^{-A}\varphi(x) dx\]</span></p>
<p><strong>取空概率</strong>为： <span class="math display">\[P(X &lt;
-A\sigma_{X})=\phi(-A)\]</span></p>
<p>其中<span class="math inline">\(\phi(x)\)</span>为标准正态分布函数，<span class="math inline">\(\varphi(x)\)</span>为标准正态分布密度函数。</p></li>
<li><p>若要求溢出和取空概率<span class="math inline">\(P_{e}=0.001\)</span>，查表得<span class="math inline">\(A = 3.08\)</span>，则存储器容量为： <span class="math display">\[C&gt;2A\sigma_{X}=2A\sqrt{N}\sigma =
6.16\sqrt{N}\sigma\]</span></p>
<ul>
<li>码方差<span class="math inline">\(\sigma\)</span>越大，要求存储器的容量也越大。</li>
<li>时间越长，<span class="math inline">\(N\)</span>越大，要求存储器的容量也越大。</li>
<li>存储器容量设定后，随着时间的增长，存储器溢出和取空的概率都将增大。</li>
</ul></li>
<li><p>一般来说，变长码只适用于有限长的信息传输（如传真）。实际使用时，可把长信息分段发送，也可以实时检测存储器的状态，调整输出。</p></li>
</ul>
<h3 id="分组码-1">分组码</h3>
<h4 id="香农shannon编码">香农(Shannon)编码</h4>
<ul>
<li>见<a href="#香农编码">香农编码</a></li>
<li><strong>编码步骤</strong>
<ol type="1">
<li>将信源消息符号按其出现的概率大小依次排列：<span class="math display">\[p_{1}\geq p_{2}\geq\cdots\geq p_{n}\]</span></li>
<li>依照下列不等式确定整数的码长<span class="math inline">\(K_{i}\)</span>：<span class="math display">\[-\log_{2}(p_{i})\leq l_{i} &lt; -\log_{2}(p_{i})
+ 1\]</span></li>
<li>为了编成唯一可译码，计算第<span class="math inline">\(i\)</span>个消息的累加概率：<span class="math display">\[P_{i}=\sum_{k = 1}^{i - 1}p(a_{k})\]</span></li>
<li>将累加概率<span class="math inline">\(P_{i}\)</span>变换成二进制数</li>
<li>取<span class="math inline">\(P_{i}\)</span>二进制数的小数点后<span class="math inline">\(l_{i}\)</span>位即为该消息符号的二进制码字</li>
</ol></li>
</ul>
<h4 id="哈夫曼huffman编码">哈夫曼(Huffman)编码</h4>
<ul>
<li><strong>特点</strong>
<ul>
<li>哈夫曼（Huffman）编码是分组码。</li>
<li>依据各符号出现的<strong>概率</strong>来构造码字。</li>
<li>基于二叉树的编码思想，所有可能的符号在哈夫曼树上对应为一个节点，节点的位置就是该符号的码字。这些节点都是终极节点，不再延伸，不会出现前缀码，因而唯一可译。</li>
<li>哈夫曼编码是一种效率比较高的<strong>变长无失真信源编码</strong>方法。</li>
</ul></li>
<li><strong>编码步骤</strong>：
<ol type="1">
<li>将信源消息符号按其出现的概率大小依次排列 <span class="math display">\[p_{1} \geq p_{2} \geq \cdots \geq
p_{n}\]</span></li>
<li>取两个概率最小的符号分别配以0和1两个码元，并将这两个概率相加作为一个新符号的概率，与未分配的二进符号的符号重新排队。</li>
<li>对重排后的两个概率最小符号重复步骤 2 的过程。</li>
<li>不断继续上述过程，直到最后两个符号配以0和1为止。</li>
<li>从最后一级开始，<strong>向前</strong>返回得到各个信源符号所对应的码元序列，即相应的码字。</li>
</ol></li>
<li>哈夫曼编码方法得到的码<strong>并非唯一</strong>的。
<ul>
<li>每次对信源缩减时，赋予信源最后两个概率最小的符号时，0和1是可以任意的，所以可以得到不同的哈夫曼码，但不会影响码字的长度。</li>
<li>对信源进行缩减时，若两个概率最小的符号合并后的概率与其它信源符号的概率相同时，这两者在缩减信源中进行概率排序，其位置放置次序是可以任意的，故会得到不同的哈夫曼码。此时将影响码字的长度，一般将<strong>合并的概率放在靠前位置</strong>，这样可获得<strong>较小的码方差</strong>。</li>
<li>不同的编法得到的码字长度<span class="math inline">\(K_{i}\)</span>也不尽相同。</li>
</ul></li>
<li>单符号信源编二进制哈夫曼码，编码效率主要决定于信源熵和平均码长之比。
<ul>
<li>对相同的信源编码，其熵是一样的，采用不同的编法得到的平均码长可能不同。</li>
<li>平均码长越短，编码效率就越高。</li>
</ul></li>
<li><strong>码方差</strong>： <span class="math display">\[
  \sigma_{I}^{2}=E\left[\left(K_{i}-\overline{K}\right)^{2}\right]=\sum_{i
= 1}^{q}p(a_{i})(K_{i}-\overline{K})^{2}
  \]</span>
<ul>
<li>例题：<img src="image-95.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul></li>
<li><strong>N进制哈夫曼编码</strong>：
<ul>
<li>在N进制哈夫曼编码中，为了得到最短平均码长，有时需要对信源符号作添加，使信源符号数量满足
<span class="math display">\[N + k(N - 1) \quad k\in N\]</span></li>
<li>平均二进制码长(信息率)为 <span class="math display">\[\overline{K} =
\frac{\overline{K_L}}{L}\log_2 N\]</span></li>
</ul></li>
<li><strong>用哈夫曼方法对信源序列编码</strong>
<ul>
<li>随着序列长度<span class="math inline">\(L\)</span>的增加，平均（二进制）码长迅速降低，接近信源熵值。</li>
<li>例题：信源输出两个符号，概率分布为<span class="math inline">\(P =
(0.9, 0.1)\)</span>，信源熵<span class="math inline">\(H(X)=0.469\)</span>比特/符号。采用二进制哈夫曼编码。
<ul>
<li><span class="math inline">\(L = 1,\overline{K}=1\)</span>
bit/符号</li>
<li><span class="math inline">\(L = 2,P'=(0.81, 0.09, 0.09,
0.01),\overline{K}=0.645\)</span> bit/符号</li>
<li><span class="math inline">\(L = 3,\overline{K}=0.533\)</span>
bit/符号</li>
<li><span class="math inline">\(L = 4,\overline{K}=0.494\)</span>
bit/符号</li>
</ul></li>
</ul></li>
</ul>
<h4 id="费诺fano编码">费诺(Fano)编码</h4>
<ul>
<li><strong>特点</strong>：
<ul>
<li>费诺（Fano）编码方法属于概率匹配编码</li>
<li>费诺码的编码方法实际上是一种构造码树的方法，所以费诺码是即时码
。</li>
<li>费诺码考虑了信源的统计特性，使概率大的信源符号能对应码长短的码字，从而有效地提高了编码效率。</li>
<li>但是费诺编码方法不一定使短码得到充分利用。尤其当信源符号较多时，若有一些符号概率分布很接近时，分两大组的组合方法会很多。可能某种分大组的结果，会使后面小组的“概率和”相差较远，使平均码长增加。</li>
</ul></li>
<li><strong>编码步骤</strong>：
<ol type="1">
<li>将信源消息符号按其出现的概率大小依次排列 <span class="math display">\[p_{1} \geq p_{2} \geq \cdots \geq
p_{n}\]</span></li>
<li>将依次排列的信源符号按概率值分为两大组，使两个组的概率之和近于相同，并对各组赋予一个二进制码元“0”和“1”；</li>
<li>将每一大组的信源符号进一步再分成两组，使划分后的两个组的概率之和近于相同，并又赋予两个组一个二进制符号“0”和“1”。</li>
<li>如此重复，直至每个组只剩下一个信源符号为止。</li>
<li>信源符号所对应的码字即为费诺码。</li>
</ol></li>
<li>适用场景：费诺码比较适合于每次分组概率都很接近的信源，特别是对每次分组概率都相等的信源进行编码时，可达到理想的编码效率。</li>
<li>例题：<img src="image-96.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul>
<h4 id="分组码的局限性">分组码的局限性</h4>
<ul>
<li>概率特性必须得到精确的测定，若其略有变化，还需更换码表。</li>
<li>对于二元信源，常常需要将多个符号合起来编码才能取得较好的效果。</li>
<li>当合并的符号数不大时，编码效率提高不明显，尤其是对于相关信源，结果难以令人满意。</li>
<li>而合并的符号数增大时，码表中的码字数增多，会导致设备越来越复杂
。</li>
</ul>
<h3 id="非分组码">非分组码</h3>
<h4 id="算术编码">算术编码</h4>
<ul>
<li><strong>特点</strong>：
<ul>
<li>算术码是一种<strong>非分组码</strong>，其基本思路是：
<ul>
<li>积累概率<span class="math inline">\(P(S)\)</span>把区间<span class="math inline">\([0,
1)\)</span>分割成许多小区间，每个小区间的长度等于各序列的概率<span class="math inline">\(p(S)\)</span>，小区间内的任一点可用来代表这序列。</li>
<li><figure>
<img src="image-47.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题">
<figcaption aria-hidden="true">例题</figcaption>
</figure></li>
</ul></li>
<li><strong>与<a href="#香农编码">香农编码</a>的区别</strong>：香农码考虑单个符号，算术编码考虑的是整个数据文件。</li>
</ul></li>
<li><strong>求序列的概率<span class="math inline">\(p(S)\)</span>和累计概率<span class="math inline">\(P(S)\)</span></strong>：
<ul>
<li>信源符号集<span class="math inline">\(A =
\{a_{1},a_{2},\cdots,a_{n}\}\)</span>，<span class="math inline">\(L\)</span>长信源序列共有<span class="math inline">\(n^{L}\)</span>种可能序列，因为序列长度<span class="math inline">\(L\)</span>很大，很难得到对应序列的概率和累积概率，只能从已知的信源符号概率中递推得到。</li>
<li>信源符号概率分布为：<span class="math display">\[P =
[p(a_{1}),p(a_{2}),\cdots,p(a_{n})]=[p_{1},p_{2},\cdots,p_{n}]\]</span></li>
<li>定义各符号的累积概率为：<span class="math display">\[P_{r}=\sum_{i =
1}^{r - 1}p_{i}\quad p_{r}=P_{r + 1}-P_{r}\]</span></li>
</ul></li>
<li><strong>累积概率递推公式</strong>
<ul>
<li><p><strong>二元序列</strong>： 有二元符号序列<span class="math inline">\(S =
011\)</span>，把3个二元符号的序列按自然二进制数排列，<span class="math inline">\(000, 001, 010, 011,\cdots\)</span>，则<span class="math inline">\(S\)</span>的累积概率为： <span class="math display">\[P(S)=p(000)+p(001)+p(010)\]</span></p>
<p>如果<span class="math inline">\(S\)</span>后面接一个“<span class="math inline">\(0\)</span>”，累积概率就成为： <span class="math display">\[
  \begin{align*}
  P(S,0)=&amp;P(0110)\\
  =&amp;p(0000)+p(0001)+p(0010)+\\
  &amp;p(0011)+p(0100)+p(0101)
  \end{align*}
  \]</span></p>
<p>由归一律，<span class="math inline">\(p(0000)+p(0001)=p(000)\)</span>等，得： <span class="math display">\[P(S,0)=P(0110)=p(000)+p(001)+p(010)=P(S)\]</span></p>
<p>同理， <span class="math display">\[
  \begin{align*}
  P(S,1)=&amp;P(0111)\\
  =&amp;p(0000)+p(0001)+p(0010)+\\
  &amp;p(0011)+p(0100)+p(0101)+p(0110)\\
  =&amp;P(S)+p(0110)\\
  =&amp;P(S)+p(S)p_{0}
  \end{align*}
  \]</span></p>
<p>当<span class="math inline">\(A =
\{0,1\}\)</span>，即<strong>二元信源</strong>时：<span class="math inline">\(P_{0}=0\)</span>；<span class="math inline">\(P_{1}=p_{0}\)</span><img src="image-48.webp" srcset="/img/loading/loading3.gif" lazyload>
<span class="math display">\[
  \begin{align*}
  &amp;P(S,0)=P(S)=P(S)+p(S)P_{0}\\
  &amp;P(S,1)=P(S)+p(S)p_{0}=P(S)+p(S)P_{1}
  \end{align*}
  \]</span></p>
<p>统一写作 <span class="math display">\[P(S,r)=P(S)+p(S)P_{r}\quad r =
0,1\]</span> <img src="image-49.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p><strong>一般递推公式</strong>
推广到多元序列，即可得到一般的递推公式： <span class="math display">\[
  \begin{align*}
  P(S,a_{r})=&amp;P(S)+p(S)P_{r}\\
  p(S,a_{r})=&amp;p(S)p_{r}
  \end{align*}
  \]</span> <img src="image-50.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>随着序列的长度不断增加，<span class="math inline">\(p(S)\)</span>越来越小，<span class="math inline">\(P(S)\)</span>所在区间的长度就越短，也就可以更加精确地确定<span class="math inline">\(P(S)\)</span>的位置。</li>
</ul></li>
</ul></li>
<li><strong>编码过程</strong>：
<ul>
<li>实际应用中，<strong>用码字<span class="math inline">\(C(S)\)</span>表示累积概率<span class="math inline">\(P(S)\)</span>，用状态区间<span class="math inline">\(A(S)\)</span>表示序列的概率<span class="math inline">\(p(S)\)</span></strong>，则递推公式为： <span class="math display">\[
  \begin{cases}
  C(S,r)=C(S)+A(S)P_{r}\\
  A(S,r)=A(S)p_{r}
  \end{cases}
  \]</span> <img src="image-51.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<ol type="1">
<li>设置两个存储器，起始时令<span class="math inline">\(A(\varphi)=1,C(\varphi)=0\)</span>，<span class="math inline">\(\varphi\)</span>表示空集，即起始时码字为<span class="math inline">\(0\)</span>，状态区间为<span class="math inline">\(1\)</span>。</li>
<li>每输入一个信源符号，存储器<span class="math inline">\(C\)</span>和<span class="math inline">\(A\)</span>就按照递推公式更新一次，直至信源符号输入完毕。</li>
<li>确定码长 <span class="math display">\[L=\left\lceil\log\frac{1}{A(S)}\right\rceil\]</span>
其中<span class="math inline">\(\lceil
x\rceil\)</span>代表大于或等于<span class="math inline">\(x\)</span>的最小整数。</li>
<li>取存储器<span class="math inline">\(C\)</span>小数点后<span class="math inline">\(L\)</span>位的内容作为该序列的码字输出；如果有尾数，就进位到第<span class="math inline">\(L\)</span>位，这样得到一个数<span class="math inline">\(C\)</span>。</li>
</ol></li>
<li><strong>译码过程</strong>：
<ol type="1">
<li>判断接收到的码字 <span class="math inline">\(C(S)\)</span>
落在哪个初始概率区间，从而确定第一个符号。</li>
<li>从 <span class="math inline">\(C(S)\)</span>
中减去对应首个符号的累积概率 <span class="math inline">\(P_{r}\)</span>
。</li>
<li>将相减后的数值乘以当前符号概率 <span class="math inline">\(p_{r}\)</span> 的倒数，放大至 <span class="math inline">\([0, 1]\)</span>
区间，以确定下一个符号所在的概率区间，进而确定下一个符号。</li>
<li>不断重复上述去掉累积概率、区间放大和确定符号的步骤，直到处理完整个码字，译出完整的符号序列。</li>
</ol></li>
<li><strong>示例</strong>：有四个符号<span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>，<span class="math inline">\(d\)</span>构成简单序列<span class="math inline">\(S = abda\)</span>，各符号及其对应概率如下表<img src="image-75.webp" srcset="/img/loading/loading3.gif" lazyload>
<ul>
<li><table>
<thead>
<tr>
<th>符号</th>
<th>符号概率<span class="math inline">\(p_i\)</span></th>
<th>符号累积概率<span class="math inline">\(P_j\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(a\)</span></td>
<td><span class="math inline">\(0.100(1/2)\)</span></td>
<td><span class="math inline">\(0.000\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(b\)</span></td>
<td><span class="math inline">\(0.010(1/4)\)</span></td>
<td><span class="math inline">\(0.100\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(c\)</span></td>
<td><span class="math inline">\(0.001(1/8)\)</span></td>
<td><span class="math inline">\(0.110\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(d\)</span></td>
<td><span class="math inline">\(0.001(1/8)\)</span></td>
<td><span class="math inline">\(0.111\)</span></td>
</tr>
</tbody>
</table></li>
<li><p><strong>算术编码过程如下</strong>：</p>
<ol type="1">
<li>设起始状态为空序列<span class="math inline">\(\varphi\)</span>，则<span class="math inline">\(A(\varphi)=1\)</span>，<span class="math inline">\(C(\varphi)=0\)</span>。</li>
<li>计算<span class="math inline">\(C(\varphi a)\)</span>和<span class="math inline">\(A(\varphi a)\)</span>： <span class="math display">\[
  \begin{cases}
  C(\varphi a)=C(\varphi)+A(\varphi)P_a = 0 + 1\times0 = 0\\
  A(\varphi a)=A(\varphi)p_a = 1\times0.1 = 0.1
  \end{cases}
  \]</span></li>
<li>计算<span class="math inline">\(C(ab)\)</span>和<span class="math inline">\(A(ab)\)</span>： <span class="math display">\[
  \begin{cases}
  C(ab)=C(a)+A(a)P_b = 0 + 0.1\times0.1 = 0.01\\
  A(ab)=A(a)p_b = 0.1\times0.01 = 0.001
  \end{cases}
  \]</span></li>
<li>计算<span class="math inline">\(C(abd)\)</span>和<span class="math inline">\(A(abd)\)</span>： <span class="math display">\[
  \begin{cases}
  C(abd)=C(ab)+A(ab)P_d = 0.01 + 0.001\times0.111 = 0.010111\\
  A(abd)=A(ab)p_d = 0.001\times0.001 = 0.000001
  \end{cases}
  \]</span></li>
<li>计算<span class="math inline">\(C(abda)\)</span>和<span class="math inline">\(A(abda)\)</span>： <span class="math display">\[
  \begin{cases}
  C(abda)=C(abd)+A(abd)P_a = 0.010111 + 0.000001\times0 = 0.010111\\
  A(abda)=A(abd)p_a = 0.000001\times0.1 = 0.0000001
  \end{cases}
  \]</span></li>
<li>计算编码长度<span class="math inline">\(L\)</span>：<span class="math display">\[L = \left\lceil\log\frac{1}{A(abcd)}\right\rceil
= 7\]</span> 取<span class="math inline">\(C(abda)\)</span>的小数点后<span class="math inline">\(7\)</span>位即为编码后的码字<span class="math inline">\(0101110\)</span>。</li>
</ol></li>
<li><p>该信源的熵为： <span class="math display">\[H(X)=\frac{1}{2}\log2+\frac{1}{4}\log4 +
2\times\frac{1}{8}\log8 = 1.75\ bit/符号\]</span></p>
<p>编码效率<span class="math display">\[\eta=\frac{1.75}{\frac{7}{4}} =
100\%\]</span></p></li>
<li><p><strong>译码过程如下</strong>： <img src="image-74.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ol type="1">
<li>已知编码后的数值<span class="math inline">\(C(S)=0.010111\)</span>，因为<span class="math inline">\(C(S)=0.010111 \in[0,0.1)\)</span>
，根据符号累积概率表，第一个符号为<span class="math inline">\(a\)</span>。</li>
<li>去掉累积概率<span class="math inline">\(P_a\)</span>：<span class="math inline">\(0.010111 - 0 = 0.010111\)</span>， 放大至<span class="math inline">\([0,1]\)</span>（乘以<span class="math inline">\(p_a^{-1}\)</span>）：<span class="math inline">\(0.010111\times2^1 = 0.10111\in[0.1,0.110)\)</span>
第二个符号为<span class="math inline">\(b\)</span>。</li>
<li>去掉累积概率<span class="math inline">\(P_b\)</span>：<span class="math inline">\(0.10111 - 0.1 = 0.00111\)</span>。 放大至<span class="math inline">\([0,1]\)</span>（乘以<span class="math inline">\(p_b^{-1}\)</span>）：<span class="math inline">\(0.00111\times2^2 = 0.111\in[0.111,1)\)</span>
第三个符号为<span class="math inline">\(d\)</span>。</li>
<li>去掉累积概率<span class="math inline">\(P_d\)</span>：<span class="math inline">\(0.111 - 0.111 = 0\)</span>。 放大至<span class="math inline">\([0,1]\)</span>（乘以<span class="math inline">\(p_d^{-1}\)</span>）：<span class="math inline">\(0\times2^3 = 0\in[0,0.1)\)</span>
第四个符号为<span class="math inline">\(a\)</span>。</li>
</ol></li>
</ul></li>
</ul>
<h4 id="lz编码">LZ编码</h4>
<ul>
<li><strong>特点</strong>：
<ul>
<li>LZ编码是一种<strong>字典编码</strong>，无需确定信源的统计特性。</li>
</ul></li>
<li><strong>LZ78 编码步骤</strong>
<ul>
<li>设信源符号集<span class="math inline">\(A =
(a_{1},a_{2},\cdots,a_{K})\)</span>共<span class="math inline">\(K\)</span>个符号，输入信源符号序列<span class="math inline">\(U =
(u_{1},u_{2},\cdots,u_{L})\)</span>，编码是将此序列分成不同的段。</li>
<li><strong>分段规则</strong>：尽可能取最少个相连的信源符号，并保证各段都不相同。
<ol type="1">
<li>在第<span class="math inline">\(i\)</span>步，从<span class="math inline">\(s_{i -
1}\)</span>短语后的第一个符号开始向后搜索此前未出现过的最短短语<span class="math inline">\(s_{i}\)</span>，将该短语添入字典第<span class="math inline">\(i\)</span>段。</li>
<li>假设<span class="math inline">\(s_{i}\)</span>去掉最后一个符号<span class="math inline">\(x\)</span>后所得的前缀是在第<span class="math inline">\(j\)</span>步出现的短语。</li>
<li>对<span class="math inline">\(s_{i}\)</span>的编码为<span class="math inline">\((j, x)\)</span>。<strong>对段号<span class="math inline">\(j\)</span>，用<span class="math inline">\(\lceil\log i\rceil\)</span>比特来表示，符号<span class="math inline">\(x\)</span>用<span class="math inline">\(\lceil\log
K\rceil\)</span>比特来表示。</strong></li>
</ol></li>
</ul></li>
<li><strong>LZ译码</strong>：无需接收方提前知晓字典内容，通过码字和逐步构建的字典就能完成译码
<ol type="1">
<li>接收到码字<span class="math inline">\((j,x)\)</span>后，在已建立或正在建立的字典中找到第<span class="math inline">\(j\)</span>个短语。</li>
<li>将符号<span class="math inline">\(x\)</span>添加到找到的第<span class="math inline">\(j\)</span>个短语后，形成新的短语。</li>
<li>把新生成的短语添入字典，以便后续译码使用。</li>
<li>对每个接收到的码字，不断重复上述步骤，直至完成所有码字的译码。</li>
</ol></li>
<li><strong>例题</strong>：
<ul>
<li><p><strong>编码</strong>：设<span class="math inline">\(U = \{a_1,
a_2, a_3, a_4\}\)</span>，信源序列为<span class="math inline">\(a_1,a_2,a_1,a_3,a_2,a_4,a_2,a_4,a_3,a_1,a_1,a_4\cdots\)</span>
，按照分段规则进行分段。符号编码表如下:</p>
<table>
<thead>
<tr>
<th><span class="math inline">\(a_1\)</span></th>
<th><span class="math inline">\(a_2\)</span></th>
<th><span class="math inline">\(a_3\)</span></th>
<th><span class="math inline">\(a_4\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>00</td>
<td>01</td>
<td>10</td>
<td>11</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>段号<span class="math inline">\(i\)</span></th>
<th>短语</th>
<th><span class="math inline">\(j\)</span></th>
<th><span class="math inline">\(x\)</span></th>
<th>码字</th>
<th>编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><span class="math inline">\(a_1\)</span></td>
<td>0</td>
<td><span class="math inline">\(a_1\)</span></td>
<td><span class="math inline">\((0,a_1)\)</span></td>
<td>0,00</td>
</tr>
<tr>
<td>2</td>
<td><span class="math inline">\(a_2\)</span></td>
<td>0</td>
<td><span class="math inline">\(a_2\)</span></td>
<td><span class="math inline">\((0,a_2)\)</span></td>
<td>0,01</td>
</tr>
<tr>
<td>3</td>
<td><span class="math inline">\(a_1a_3\)</span></td>
<td>1</td>
<td><span class="math inline">\(a_3\)</span></td>
<td><span class="math inline">\((1,a_3)\)</span></td>
<td>01,10</td>
</tr>
<tr>
<td>4</td>
<td><span class="math inline">\(a_2a_4\)</span></td>
<td>2</td>
<td><span class="math inline">\(a_4\)</span></td>
<td><span class="math inline">\((2,a_4)\)</span></td>
<td>10,11</td>
</tr>
<tr>
<td>5</td>
<td><span class="math inline">\(a_2a_4a_3\)</span></td>
<td>4</td>
<td><span class="math inline">\(a_3\)</span></td>
<td><span class="math inline">\((4,a_3)\)</span></td>
<td>100,10</td>
</tr>
<tr>
<td>6</td>
<td><span class="math inline">\(a_1a_1\)</span></td>
<td>1</td>
<td><span class="math inline">\(a_1\)</span></td>
<td><span class="math inline">\((1,a_1)\)</span></td>
<td>001,00</td>
</tr>
<tr>
<td>7</td>
<td><span class="math inline">\(a_4\)</span></td>
<td>0</td>
<td><span class="math inline">\(a_4\)</span></td>
<td><span class="math inline">\((0,a_4)\)</span></td>
<td>000,11</td>
</tr>
</tbody>
</table></li>
<li><p><strong>译码</strong>：码序列为00000101101011100100010000011。符号编码表如下：</p>
<table>
<thead>
<tr>
<th>段号<span class="math inline">\(i\)</span></th>
<th>编码</th>
<th><span class="math inline">\(j\)</span></th>
<th><span class="math inline">\(x\)</span></th>
<th>码字</th>
<th>短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0,00</td>
<td>0</td>
<td><span class="math inline">\(a_1\)</span></td>
<td><span class="math inline">\((0,a_1)\)</span></td>
<td><span class="math inline">\(a_1\)</span></td>
</tr>
<tr>
<td>2</td>
<td>0,01</td>
<td>0</td>
<td><span class="math inline">\(a_2\)</span></td>
<td><span class="math inline">\((0,a_2)\)</span></td>
<td><span class="math inline">\(a_2\)</span></td>
</tr>
<tr>
<td>3</td>
<td>01,10</td>
<td>1</td>
<td><span class="math inline">\(a_3\)</span></td>
<td><span class="math inline">\((1,a_3)\)</span></td>
<td><span class="math inline">\(a_1a_3\)</span></td>
</tr>
<tr>
<td>4</td>
<td>10,11</td>
<td>2</td>
<td><span class="math inline">\(a_4\)</span></td>
<td><span class="math inline">\((2,a_4)\)</span></td>
<td><span class="math inline">\(a_2a_4\)</span></td>
</tr>
<tr>
<td>5</td>
<td>100,10</td>
<td>4</td>
<td><span class="math inline">\(a_3\)</span></td>
<td><span class="math inline">\((4,a_3)\)</span></td>
<td><span class="math inline">\(a_2a_4a_3\)</span></td>
</tr>
<tr>
<td>6</td>
<td>001,00</td>
<td>1</td>
<td><span class="math inline">\(a_1\)</span></td>
<td><span class="math inline">\((1,a_1)\)</span></td>
<td><span class="math inline">\(a_1a_1\)</span></td>
</tr>
<tr>
<td>7</td>
<td>000,11</td>
<td>0</td>
<td><span class="math inline">\(a_4\)</span></td>
<td><span class="math inline">\((0,a_4)\)</span></td>
<td><span class="math inline">\(a_4\)</span></td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul>
<h4 id="游程编码rlerun-length-encoding">游程编码(RLE，run-length
encoding)</h4>
<ul>
<li>在二元序列中，连0段称为0游程，连1段称为1游程。</li>
<li>例如二元码序列：<span class="math inline">\(000101110010001\cdots\)</span>，可变换成下列游程序列：<span class="math inline">\(31132131\cdots\)</span> 。</li>
<li>若已知二元序列以0起始，从游程序列很容易恢复成原来的二元序列。</li>
<li>游程序列是多元序列，各长度可按哈夫曼编码或其它方法处理以达到压缩码率的目的。</li>
</ul>
<h4 id="mh-编码传真编码">MH 编码(传真编码)</h4>
<ul>
<li><strong>MH编码方法</strong>
<ol type="1">
<li>黑白游程分别对应不同的编码表。</li>
<li>游程长度在<span class="math inline">\(0\sim63\)</span>时，码字直接用相应的终端码（结尾码）表示。
<ul>
<li>例如：
<ul>
<li>白游程长度为<span class="math inline">\(0\)</span>，查表得码字<span class="math inline">\(000\)</span> 。</li>
<li>黑游程长度为<span class="math inline">\(24\)</span>
，查表得码字<span class="math inline">\(11111\)</span> 。</li>
</ul></li>
</ul></li>
<li>游程长度在<span class="math inline">\(64\sim1728\)</span>
，用一个组合码加上一个结尾码为相应码字。
<ul>
<li>例如：
<ul>
<li>白游程长度为<span class="math inline">\(65(=64 +
1)\)</span>，查表得码字<span class="math inline">\(11011\mid000111\)</span> 。</li>
<li>黑游程长度为<span class="math inline">\(856(=832+24)\)</span>
，查表得码字<span class="math inline">\(0000001001101\mid00000010111\)</span> 。</li>
</ul></li>
</ul></li>
<li>规定每行都从白游程开始，若实际出现黑游程开始的话，则在行首加上零长度白游程码字
，每行结束用一个结束码（EOL）。</li>
<li>每行恢复成<span class="math inline">\(1728\)</span>个像素，否则有错。</li>
<li>每页文件开始第一个数据前加一个结束码。每页尾连续使用<span class="math inline">\(6\)</span>个结束码表示结尾。</li>
<li>为了传输时实现同步操作，规定<span class="math inline">\(T\)</span>为每编码行的最小传输时间。一般规定<span class="math inline">\(T\)</span>最小为<span class="math inline">\(20ms\)</span>，最大为<span class="math inline">\(5s\)</span>。若编码行传输时间小于<span class="math inline">\(T\)</span>，则在结束码之前填以足够的“<span class="math inline">\(0\)</span>”码元（称填充码） 。</li>
</ol></li>
<li>页面数据结构<img src="image-76.webp" srcset="/img/loading/loading3.gif" lazyload alt="页面数据结构"></li>
<li>结尾码码表<img src="image-77.webp" srcset="/img/loading/loading3.gif" lazyload alt="结尾码码表"></li>
<li>组合基干码码表<img src="image-78.webp" srcset="/img/loading/loading3.gif" lazyload alt="组合基干码码表"></li>
<li>例题：<img src="image-97.webp" srcset="/img/loading/loading3.gif" lazyload alt="例题"></li>
</ul>
<h1 id="第五章补充-无失真信源编码">第五章补充 无失真信源编码</h1>
<h2 id="渐进均分性定理aep-1">渐进均分性定理（AEP）</h2>
<ul>
<li><p><strong>定理</strong>：<span class="math inline">\(\vec{X_{}}=(X_1 X_2 \cdots
X_L)\)</span>，为独立同分布（i.i.d）随机变量序列，具有渐近均分性质（AEP，Asymptotic
equipartition property）： <span class="math display">\[\forall
\varepsilon &gt; 0，当 L \to \infty时，p(X_1,X_2,\cdots,X_L) \to 2^{-L
H(X)}\]</span></p></li>
<li><p><strong>信源编码模型</strong>： <img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload alt="信源模型"></p>
<ul>
<li><span class="math inline">\(X_i \in
\{a_1,a_2,\cdots,a_n\}\)</span></li>
<li><span class="math inline">\(Y_i \in
\{b_1,b_2,\cdots,b_m\}\)</span></li>
</ul></li>
<li><p><strong>证明1</strong>：</p>
<ul>
<li><strong>自信息量</strong>： <span class="math display">\[
  \begin{align*}
  I(\vec{X_{}}) &amp;= -\log p(X_1,X_2,\cdots,X_L)\\
  &amp;=-\log p(X_1)-\log p(X_2)-\cdots-\log p(X_L)\\
  &amp;=\sum_{i = 1}^{L} I(X_i)
  \end{align*}
  \]</span></li>
<li><strong>均值</strong>(由i.i.d.)）： <span class="math display">\[
  E\{I(\vec{X_{}})\}=E\left\{\sum_{i = 1}^{L} I(X_i)\right\}=\sum_{i =
1}^{L} E\{I(X_i)\}=\sum_{i = 1}^{L} H(X_i)=L H(X)
  \]</span></li>
<li><strong>方差</strong>(由i.i.d.)： <span class="math display">\[
  D\{I(\vec{X_{}})\}=D\left\{\sum_{i = 1}^{L} I(X_i)\right\}=\sum_{i =
1}^{L} D\{I(X_i)\}=L D(I(X))
  \]</span> 其中 <span class="math display">\[
  D(I(X)) = E\left[(I(X)-H(X))^2\right]=\sum_{i = 1}^{n} p(x_i)(-\log
p(x_i)-H(X))^2
  \]</span></li>
<li>根据切比雪夫不等式 <span class="math display">\[
      P_r\{|X - \mu| \geq \varepsilon\} \leq
\frac{\sigma^2}{\varepsilon^2}\quad (\varepsilon&gt;0, \sigma&gt;0)
  \]</span> 有： <span class="math display">\[
  P_r\left\{\left|I(\vec{X_{}})-L H(X)\right| \geq L\varepsilon\right\}
\leq \frac{L D(I(X))}{(L\varepsilon)^2}
  \]</span> <span class="math display">\[
  P_r\left\{\left|\frac{I(\vec{X_{}})}{L}-H(X)\right| \geq
\varepsilon\right\} \leq \frac{D(I(X))}{L\varepsilon^2}
  \]</span> 当 <span class="math inline">\(L \to \infty\)</span> 时
<span class="math display">\[
  \begin{align*}
  &amp;\frac{D(I(X))}{L\varepsilon^2} \to 0,\\
  &amp;\frac{-\log p(X_1,X_2,\cdots,X_L)}{L} \to H(X),\\
  &amp;p(X_1,X_2,\cdots,X_L) \to 2^{-L H(X)}
  \end{align*}
  \]</span></li>
</ul></li>
<li><p><strong>证明2</strong>：</p>
<ul>
<li>AEP 也可由弱大数定律直接得到</li>
<li>当 <span class="math inline">\(X\)</span> 为 i.i.d，<span class="math inline">\(n\)</span> 很大时，<span class="math inline">\(\frac{1}{n}\sum_{i = 1}^{n} x_i \to E(X)\)</span>
<span class="math display">\[
  \begin{align*}
  -\frac{1}{L}\log p(X_1,X_2,\cdots,X_L)= &amp;-\frac{1}{L}\sum_{i =
1}^{L} \log p(X_i)\\
  \overset{a.s.}{\to} &amp;-E(\log p(X))\\
  = &amp;H(X)
  \end{align*}
  \]</span></li>
</ul></li>
<li><p><strong>典型集<span class="math inline">\(A_{\varepsilon}\)</span></strong></p>
<ul>
<li><p><strong>定义</strong> <span class="math display">\[
  \begin{align*}
  &amp;A_{\varepsilon}=\left\{\vec{x_{}}:\left|\frac{I(\vec{x_{}})}{L}-H(X)\right|
\leq \varepsilon\right\}\\
  &amp;A_{\varepsilon}^c=\left\{\vec{x_{}}:\left|\frac{I(\vec{x_{}})}{L}-H(X)\right|
&gt; \varepsilon\right\}\\
  &amp;A_{\varepsilon}+A_{\varepsilon}^c = X^L=\{\vec{x_{i}}\}\quad i =
1,2,\cdots,n^L
  \end{align*}
  \]</span></p></li>
<li><p><strong>性质</strong></p>
<ol type="1">
<li>若 <span class="math inline">\(\vec{x_{}} \in
A_{\varepsilon}\)</span>，则典型集中的元素几乎是等概率出现的： <span class="math display">\[2^{-L(H(X)+\varepsilon)} \leq p(\vec{x_{}}) \leq
2^{-L(H(X)-\varepsilon)}\]</span></li>
<li>当 <span class="math inline">\(L\)</span>
充分大时，典型集的概率近似为1： <span class="math display">\[P_r(A_\varepsilon) = \sum_{\vec{x_{}} \in
A_{\varepsilon}} p(\vec{x_{}})&gt;1 - \varepsilon\]</span></li>
<li>典型集中元素的个数： <span class="math display">\[|A_{\varepsilon}|
\leq 2^{L(H(X)+\varepsilon)}\]</span>
<ul>
<li>证明： <span class="math display">\[
  \begin{align*}
  1&amp;=\sum_{\vec{x_{}} \in X^L} p(\vec{x_{}}) \geq \sum_{\vec{x_{}}
\in A_{\varepsilon}} p(\vec{x_{}})\\
  &amp;\geq \sum_{\vec{x_{}} \in A_{\varepsilon}}
2^{-L(H(X)+\varepsilon)}=|A_{\varepsilon}|2^{-L(H(X)+\varepsilon)}\\
  \Rightarrow &amp;|A_{\varepsilon}| \leq 2^{L(H(X)+\varepsilon)}
  \end{align*}
  \]</span></li>
</ul></li>
<li>典型集中元素的个数： <span class="math display">\[|A_{\varepsilon}|
\geq (1 - \varepsilon)2^{L(H(X)-\varepsilon)}\]</span> 当 <span class="math inline">\(L\)</span> 充分大时，<span class="math inline">\(P_r(A_{\varepsilon}) &gt; 1 - \varepsilon\)</span>
<ul>
<li>证明： <span class="math display">\[
  \begin{align*}
  1-\varepsilon &amp;\leq P_r(A_{\varepsilon}) = \sum_{\vec{x_{}} \in
A_{\varepsilon}} p(\vec{x_{}})\\
  &amp; \leq \sum_{\vec{x_{}} \in A_{\varepsilon}}
2^{-L(H(X)-\varepsilon)}=|A_{\varepsilon}|2^{-L(H(X)-\varepsilon)}\\
  \Rightarrow |A_{\varepsilon}| &amp;\geq (1 -
\varepsilon)2^{L(H(X)-\varepsilon)}
  \end{align*}
  \]</span></li>
</ul></li>
</ol></li>
</ul></li>
</ul>
<h2 id="定长编码定理-1">定长编码定理</h2>
<ul>
<li><p><strong>定理</strong>：对于由 <span class="math inline">\(L\)</span> 个符号组成的，每个符号的熵为 <span class="math inline">\(H_L(\vec{X_{}})\)</span> 的无记忆平稳符号序列
<span class="math inline">\(X_1, X_2, \cdots, X_L\)</span>，可用 <span class="math inline">\(K_L\)</span> 个符号 <span class="math inline">\(Y_1, Y_2, \cdots, Y_{K_L}\)</span>（每个符号有
<span class="math inline">\(m\)</span> 种可能值，即<span class="math inline">\(m\)</span>进制编码）进行定长编码。对于任意 <span class="math inline">\(\varepsilon &gt; 0\)</span>，<span class="math inline">\(\delta &gt; 0\)</span>，只要 <span class="math display">\[\frac{K_L}{L}\log m \geq H_L(\vec{X_{}}) +
\varepsilon\]</span></p>
<p>则当 <span class="math inline">\(L\)</span>
足够大时，必可使译码差错小于 <span class="math inline">\(\delta\)</span>； 反之，当 <span class="math display">\[\frac{K_L}{L}\log m \leq H_L(\vec{X_{}}) -
2\varepsilon\]</span></p>
<p>时，译码差错一定是有限值，当 <span class="math inline">\(L \to
\infty\)</span> 时，译码几乎必定出错。</p></li>
<li><p><strong>证明</strong></p>
<ul>
<li><p>对 <span class="math inline">\(A_{\varepsilon}\)</span>
中的元素进行定长编码，为了唯一可译，码符号个数大于等于 <span class="math inline">\(|A_{\varepsilon}|\)</span>，即 <span class="math display">\[m^{K_L} \geq |A_{\varepsilon}|\]</span></p>
<p>此时<span class="math inline">\(|A_{\varepsilon}|\)</span>
取上界，记平均符号熵<span class="math inline">\(H_L(\vec{X_{}})\)</span>
为 <span class="math inline">\(H(X)\)</span> <span class="math display">\[
  \begin{align*}
  m^{K_L} &amp;\geq 2^{L(H(X) + \varepsilon)}\\
  K_L\log m &amp;\geq L(H(X) + \varepsilon)\\
  \frac{K_L}{L}\log m &amp;\geq H(X) + \varepsilon
  \end{align*}
  \]</span></p>
<p>此时，错误译码的概率为 <span class="math display">\[P_e =
P_r\{A_{\varepsilon}^c\} \leq
\frac{D(I(X))}{L\varepsilon^2}\]</span></p>
<p>若需 <span class="math inline">\(P_e \leq \delta\)</span>，则有 <span class="math display">\[
  \begin{align*}
  &amp;\frac{D(I(X))}{L\varepsilon^2} \leq \delta\\
  &amp;L \geq \frac{D(I(X))}{\varepsilon^2\delta}
  \end{align*}
  \]</span></p>
<p>即信源长度 <span class="math inline">\(L\)</span> 需满足 <span class="math inline">\(L \geq
\frac{D(I(X))}{\varepsilon^2\delta}\)</span></p></li>
<li><p>反之，若 <span class="math display">\[
  \begin{align*}
  &amp;\frac{K_L}{L}\log m \leq H(X) - 2\varepsilon\\
  &amp;\log m^{K_L} \leq L(H(X) - 2\varepsilon)\\
  &amp;m^{K_L} \leq 2^{L(H(X) - 2\varepsilon)} &lt; (1 -
\varepsilon)2^{L(H(X) - \varepsilon)} = |A_{\varepsilon}|_{min}
  \end{align*}
  \]</span></p>
<p>即 <span class="math inline">\(m^{K_L} &lt;
|A_{\varepsilon}|\)</span>，码字个数少于<span class="math inline">\(A_{\varepsilon}\)</span> 中的元素个数</p>
<p>此时只能在 <span class="math inline">\(A_{\varepsilon}\)</span>
中选取 <span class="math inline">\(m^{K_L}\)</span>
个元素进行一对一编码， <span class="math display">\[
  \begin{align*}
  P_r(只出现A_{\varepsilon}中的m^{K_L}个元素) &amp;\leq m^{K_L} \cdot
\max_{\vec{x_{}} \in A_{\varepsilon}} p(\vec{x_{}}) = m^{K_L}2^{-L(H(X)
- \varepsilon)}\\
  &amp;\leq 2^{L(H(X) - 2\varepsilon) - L(H(X) - \varepsilon)}\\
  &amp;= 2^{-L\varepsilon}
  \end{align*}
  \]</span></p>
<p>译码错误概率为 <span class="math inline">\(P_e = 1 -
2^{-L\varepsilon}\)</span> ，<span class="math inline">\(L \to
\infty\)</span>，<span class="math inline">\(P_e \to 1\)</span></p></li>
</ul></li>
</ul>
<h2 id="单符号变长编码定理">单符号变长编码定理</h2>
<ul>
<li><p><strong>定理</strong>：对于离散无记忆信源的符号 <span class="math inline">\(X\)</span>，其熵为 <span class="math inline">\(H(X)\)</span>，每个信源符号用 <span class="math inline">\(m\)</span>
进制码元进行变长编码，一定存在一种无失真编码方法，其（<span class="math inline">\(m\)</span> 进制）码元平均长度 <span class="math inline">\(\overline{k}\)</span> 满足下列不等式： <span class="math display">\[\frac{H(X)}{\log m} \leq \overline{k} &lt;
\frac{H(X)}{\log m} + 1\]</span></p>
<p>其中，<span class="math inline">\(\overline{k} = \sum_{i = 1}^{n}
p(a_i)l_i\)</span>，<span class="math inline">\(l_i\)</span> 为符号
<span class="math inline">\(a_i\)</span> 的码长。</p></li>
<li><p><strong>证明</strong>：</p>
<ul>
<li><strong>定义</strong>：<span class="math inline">\(l_i\)</span>
为符号 <span class="math inline">\(a_i\)</span> 的码长，<span class="math inline">\(p(a_i)\)</span> 为符号 <span class="math inline">\(a_i\)</span> 的概率，<span class="math inline">\(\overline{k} = \sum_{i = 1}^{n} p(a_i)l_i\)</span>
为码元平均长度。</li>
<li><figure>
<img src="image-57.webp" srcset="/img/loading/loading3.gif" lazyload alt="码元平均长度">
<figcaption aria-hidden="true">码元平均长度</figcaption>
</figure></li>
</ul>
<ol type="1">
<li><p><strong>证明必存在无失真编码，使得 <span class="math inline">\(H(X) - (\log m)\overline{k} \leq
0\)</span></strong> <span class="math display">\[
\begin{align*}
H(X) - (\log m)\overline{k} &amp;= -\sum_{i = 1}^{n} p(a_i)\log p(a_i) -
\sum_{i = 1}^{n} p(a_i)l_i\log m\\
&amp;=\sum_{i = 1}^{n} p(a_i)\log \frac{m^{-l_i}}{p(a_i)}
\end{align*}
\]</span></p>
<p>根据Jensen不等式 <span class="math inline">\(E[f(x)] \leq
f(E(x))\)</span>，有 <span class="math display">\[
\begin{align*}
H(X) - (\log m)\overline{k} &amp;=\sum_{i = 1}^{n} p(a_i)\log
\frac{m^{-l_i}}{p(a_i)}\\
&amp;\leq \log \sum_{i = 1}^{n} p(a_i)\frac{m^{-l_i}}{p(a_i)} = \log
\sum_{i = 1}^{n} m^{-l_i}
\end{align*}
\]</span></p>
<p>唯一可译码存在（无失真），因此 <span class="math inline">\(\sum_{i =
1}^{n} m^{-l_i} \leq 1\)</span> <span class="math display">\[
\begin{align*}
&amp;H(X) - (\log m)\overline{k} \leq \log 1 = 0\\
&amp;\Rightarrow \overline{k} \geq \frac{H(X)}{\log m}
\end{align*}
\]</span></p>
<p>若要等号成立 <span class="math display">\[
m^{-l_i} = p(a_i),\quad l_i = \frac{-\log p(a_i)}{\log m}
\]</span></p></li>
<li><p><strong>证明 <span class="math inline">\(\overline{k} &lt;
\frac{H(X)}{\log m} + 1\)</span></strong> 符号 <span class="math inline">\(a_i\)</span> 的码长 <span class="math inline">\(l_i\)</span> 需要是整数，因此取 <span class="math display">\[\frac{-\log p(a_i)}{\log m} \leq l_i &lt;
\frac{-\log p(a_i)}{\log m} + 1\]</span></p>
<p>由 <span class="math display">\[
\begin{align*}
&amp;\frac{-\log p(a_i)}{\log m} \leq l_i\\
&amp;\Rightarrow -\log m^{l_i} \leq \log p(a_i)\\
&amp;\Rightarrow m^{-l_i} \leq p(a_i)\\
&amp;\Rightarrow \sum_{i = 1}^{n} m^{-l_i} \leq \sum_{i = 1}^{n}
p(a_i)=1
\end{align*}
\]</span></p>
<p>表明 <span class="math inline">\(l_i\)</span>
满足唯一可译码存在的条件。 又由 <span class="math display">\[
\begin{align*}
l_i &amp;&lt; \frac{-\log p(a_i)}{\log m} + 1\\
\sum_{i = 1}^{n} l_i p(a_i) &amp;&lt; \sum_{i = 1}^{n}
p(a_i)(\frac{-\log p(a_i)}{\log m} + 1)\\
\overline{k} &amp;&lt; \frac{H(X)}{\log m} + 1
\end{align*}
\]</span></p></li>
</ol></li>
</ul>
<h2 id="离散平稳无记忆序列变长编码定理香农第一定理-1">离散平稳无记忆序列变长编码定理（香农第一定理）</h2>
<ul>
<li><p><strong>定理</strong>：对于平均符号熵为 <span class="math inline">\(H_L(\vec{X_{}})\)</span>
的离散平稳无记忆信源，必存在一种无失真编码方法，使平均信息率 <span class="math inline">\(\overline{K}\)</span> 满足不等式： <span class="math display">\[H_L(\vec{X_{}}) \leq \overline{K} &lt;
H_L(\vec{X_{}}) + \varepsilon\]</span></p>
<p>其中 <span class="math inline">\(\varepsilon\)</span>
为任意小正数，<span class="math inline">\(\overline{K} =
\frac{\overline{k}_L}{L} \log m\)</span>，<span class="math inline">\(\overline{k}_L\)</span> 为 <span class="math inline">\(L\)</span> 个符号的平均码长。</p></li>
<li><p><strong>证明</strong> 将 <span class="math inline">\(\vec{X_{}}=(X_1 X_2 \cdots X_L)\)</span>
作为一个整体，构成一个新的单符号信源。因此有： <span class="math display">\[
  \begin{align*}
  \frac{L H_L(\vec{X_{}})}{\log m} &amp;\leq \overline{k}_L &lt; \frac{L
H_L(\vec{X_{}})}{\log m} + 1\\
  H_L(\vec{X_{}}) &amp;\leq \frac{\overline{k}_L}{L} \log m &lt;
H_L(\vec{X_{}}) + \frac{\log m}{L}
  \end{align*}
  \]</span></p>
<p>令 <span class="math inline">\(\overline{K}= \frac{\overline{k}_L}{L}
\log m\)</span>，则有 <span class="math display">\[H_L(\vec{X_{}}) \leq
\overline{K} &lt; H_L(\vec{X_{}}) + \varepsilon \quad (L \to
\infty)\]</span></p>
<p>此时编码效率<span class="math display">\[\eta =
\frac{H_L(\vec{X_{}})}{\overline{K}} &gt;
\frac{H_L(\vec{X_{}})}{H_L(\vec{X_{}}) + \frac{\log
m}{L}}\]</span></p></li>
</ul>
<h1 id="第六章-信道编码">第六章 信道编码</h1>
<ul>
<li>信道传输会使接收信号出现差错，信道编码旨在提升传输可靠性，主要涉及两个层面的问题：
<ul>
<li>如何准确接收承载信息的信号：线路编码（通信原理）</li>
<li>怎样避免少量错误信号对信息内容产生影响：纠错编码</li>
</ul></li>
</ul>
<h2 id="信道编码概念和理论">6.1 6.2 信道编码概念和理论</h2>
<h3 id="差错和差错控制系统分类">差错和差错控制系统分类</h3>
<ul>
<li><p><strong>差错类型</strong></p>
<ul>
<li><strong>符号差错</strong>：由符号发生差错引起，也叫信号差错，信号差错概率用符号差错概率表示。</li>
<li><strong>差错比特</strong>：由信息比特发生差错引起，也叫信息差错，信息差错概率用误比特率表示。</li>
<li>对于二进制传输系统，符号差错等效于比特差错。</li>
<li>对于多进制系统，一个符号差错到底对应多少比特差错难以确定，因为一个符号由多个比特组成。</li>
</ul></li>
<li><p>两种八电平线路编码方法比较</p>
<table>
<thead>
<tr>
<th>量级</th>
<th>自然二进码</th>
<th>反射二进码(格雷码)</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>000</td>
<td>000</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>001</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>011</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>010</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>110</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>111</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>101</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>100</td>
</tr>
</tbody>
</table>
<ul>
<li>格雷码可以通过普通二进制码转换得到。</li>
<li>以下是生成格雷码的常见方法：
<ol type="1">
<li>最高位保留：格雷码的最高位（最左边） 与二进制码的最高位相同。</li>
<li>逐位异或：格雷码的每一位是二进制码当前位与上一位的异或结果。</li>
</ol></li>
</ul></li>
<li><p><strong>差错图样</strong>（error pattern）</p>
<ul>
<li><strong>定义</strong>：
<ul>
<li><strong>差错图样 <span class="math inline">\(E =\)</span> 发码 <span class="math inline">\(C -\)</span> 收码 <span class="math inline">\(R\)</span> <span class="math inline">\((\mod
q)\)</span></strong></li>
<li><strong>示例</strong>：8进制(<span class="math inline">\(q =
8\)</span>)码，若发码 <span class="math inline">\(C =
(0,2,5,4,7,5,2)\)</span> ，收码变为 <span class="math inline">\(R =
(0,1,5,4,7,5,4)\)</span> ，差错图样 <span class="math inline">\(E = C -
R = (0,1,0,0,0,0,6)\)</span>（模8）。</li>
</ul></li>
<li>二进制码：<span class="math inline">\(E = C \oplus R\)</span> 或
<span class="math inline">\(C = R \oplus
E\)</span>，差错图样中的“1”既是符号差错也是比特差错。</li>
<li><strong>汉明距离</strong>：两码字之间不同的位数叫它们之间的汉明距离，记作<span class="math inline">\(d(c_i,c_j)\)</span>，即<span class="math display">\[d(c_i,c_j) = \sum_{k=1}^{N}c_{ik}\oplus
c_{jk}\]</span></li>
<li><strong>差错图样类型</strong>
<ul>
<li><strong>随机差错</strong>：若差错图样上各码位的取值既与前后位置无关又与时间无关，即差错始终以相等的概率独立发生于各码字、各码元、各比特</li>
<li><strong>突发差错</strong>：前后相关、成堆出现。突发差错总是以差错码元开头、以差错码元结尾，头尾之间并不是每个码元都错，而是码元差错概率超过了某个额定值</li>
</ul></li>
</ul></li>
<li><p><strong>纠错码分类</strong></p>
<ul>
<li><strong>从功能角度</strong>：检错码 、纠错码</li>
<li><strong>对信息序列的处理方法</strong>：分组码、卷积码</li>
<li><strong>码元与原始信息位的关系</strong>：线性码、非线性码</li>
<li><strong>差错类型</strong>：纠随机差错码、纠突发差错码、介于中间的纠随机/突发差错码</li>
<li><strong>构码理论</strong>：代数码、几何码、算术码、组合码等</li>
</ul></li>
<li><p><strong>差错控制系统分类</strong></p>
<ul>
<li><strong>前向纠错（FEC）</strong>：发端信息经纠错编码后传送，收端通过纠错译码自动纠正传递过程中的差错</li>
<li><strong>反馈重发（ARQ）</strong>：收端通过检测接收码是否符合编码规律来判断，如判定码组有错，则通过反向信道通知发端重发该码组</li>
<li><strong>混合纠错（HEC）</strong>：前向纠错和反馈重发的结合，发端发送的码兼有检错和纠错两种能力</li>
</ul></li>
</ul>
<h3 id="矢量空间与码空间">矢量空间与码空间</h3>
<h4 id="矢量空间">矢量空间</h4>
<ul>
<li>**矢量*
<ul>
<li><span class="math inline">\(F\)</span>表示码元所在的<strong>数域</strong>，对于二进制码，<span class="math inline">\(F\)</span>代表二元域<span class="math inline">\(\{0,1\}\)</span>。</li>
<li>设<span class="math inline">\(n\)</span>重有序元素（<span class="math inline">\(n\)</span>重矢量）的集合<span class="math inline">\(V=\{v_i\}\)</span> <span class="math display">\[v_i = (v_{i0},v_{i1},\cdots,v_{ij},\cdots,v_{i(n
- 1)})\quad v_{ji}\in F\]</span></li>
<li>若满足条件：
<ol type="1">
<li><span class="math inline">\(V\)</span>中矢量元素在<strong>矢量加运算</strong>下构成加群。</li>
<li><span class="math inline">\(V\)</span>中矢量元素与数域<span class="math inline">\(F\)</span>元素的<strong>标乘</strong>封闭在<span class="math inline">\(V\)</span>中。</li>
<li>分配律、结合律成立。</li>
</ol>
则称集合<span class="math inline">\(V\)</span>是数域<span class="math inline">\(F\)</span>上的一个<span class="math inline">\(n\)</span><strong>重矢量空间</strong>，或称<span class="math inline">\(n\)</span>重线性空间，<span class="math inline">\(n\)</span>重矢量又称<span class="math inline">\(n\)</span>重(<span class="math inline">\(n\)</span>-tuples)。</li>
<li>码字又叫码矢、<span class="math inline">\(n\)</span>重(矢量) 。</li>
<li><strong>示例</strong>：<span class="math inline">\(n\)</span>维实数域矢量空间<span class="math inline">\(\mathbb{R}^n\)</span>，<span class="math inline">\(n\)</span>维复数域矢量空间<span class="math inline">\(\mathbb{C}^n\)</span>，<span class="math inline">\(n\)</span>维有限域矢量空间<span class="math inline">\(GF(q)^n\)</span>等。</li>
</ul></li>
<li><strong>码矢的运算法则</strong>
<ul>
<li>码矢的运算法则遵从矢量的运算法则，对于矢量<span class="math inline">\(v_i = (v_{i0},v_{i1},\cdots,v_{i(n -
1)})\)</span>，<span class="math inline">\(v_j =
(v_{j0},v_{j1},\cdots,v_{j(n - 1)})\)</span>，及标量<span class="math inline">\(\alpha\in F\)</span>（数域），定义：
<ul>
<li><strong>矢量加</strong>：<span class="math inline">\(v_i + v_j =
(v_{i0} + v_{j0},v_{i1} + v_{j1},\cdots,v_{i(n - 1)} + v_{j(n -
1)})\)</span>，所得结果仍是矢量。</li>
<li><strong>标乘（标量乘矢量）</strong>：<span class="math inline">\(\alpha v_i = (\alpha v_{i0},\alpha
v_{i1},\cdots,\alpha v_{i(n - 1)})\)</span>，所得结果是矢量 。</li>
<li><strong>点积或内积（矢量乘矢量）</strong>：<span class="math inline">\(v_i\cdot v_j = v_{i0}\cdot v_{j0} + v_{i1}\cdot
v_{j1} + \cdots + v_{i(n - 1)}\cdot v_{j(n -
1)}\)</span>，所得结果是标量。</li>
</ul></li>
</ul></li>
<li><strong>矢量空间中各元素间的关系</strong>
<ul>
<li><strong>线性组合</strong>：若<span class="math inline">\(v_k =
a_1v_1 + a_2v_2 + \cdots + a_lv_l\)</span> (<span class="math inline">\(a_i\in F\)</span>)，则称<span class="math inline">\(v_k\)</span>是<span class="math inline">\(v_1,v_2,\cdots,v_l\)</span>的线性组合。</li>
<li><strong>线性相关</strong>：若满足<span class="math inline">\(a_1v_1
+ a_2v_2 + \cdots + a_lv_l = 0\)</span>，(<span class="math inline">\(a_i\in F\)</span>且不全为<span class="math inline">\(0\)</span>)，则称<span class="math inline">\(v_1,v_2,\cdots,v_l\)</span>线性相关。其中任一矢量可表示为其它矢量的线性组合。</li>
<li><strong>线性无关或线性独立</strong>：一组矢量中的任意一个都不可能用其它矢量的线性组合来代替。</li>
</ul></li>
<li><strong>矢量空间与基底</strong>
<ul>
<li>如果存在一组线性无关的矢量<span class="math inline">\(v_1,v_2,\cdots,v_k\)</span>，这些矢量<strong>线性组合的集合</strong>就构成了一个<span class="math inline">\(k\)</span><strong>维矢量空间</strong><span class="math inline">\(V\)</span>，这组矢量就是这个矢量空间的<strong>基底</strong>。</li>
<li><strong>性质</strong>：
<ul>
<li><strong><span class="math inline">\(k\)</span>维矢量空间应包含<span class="math inline">\(k\)</span>个基底</strong>，可以说：<span class="math inline">\(k\)</span>个基底“张成”<span class="math inline">\(k\)</span>维矢量空间。</li>
<li><strong>基底不是唯一的</strong>。
<ul>
<li>示例：线性无关的两个矢量<span class="math inline">\((1,0)\)</span>和<span class="math inline">\((0,1)\)</span>以及<span class="math inline">\((-1,0)\)</span>和<span class="math inline">\((0,-1)\)</span>都可张成同一个2维实数域空间(<span class="math inline">\(x,y\)</span>) 。</li>
</ul></li>
</ul></li>
<li><strong>自然基底</strong>：矢量元素中包含一个<span class="math inline">\(1\)</span>而其余为<span class="math inline">\(0\)</span>的那组基底</li>
</ul></li>
<li><strong>子空间</strong>
<ul>
<li>若矢量空间<span class="math inline">\(V\)</span>的一个子集<span class="math inline">\(V_s\)</span>也能构成一个矢量空间，则称<span class="math inline">\(V_s\)</span>是<span class="math inline">\(V\)</span>的子空间 。</li>
<li><strong>示例</strong>：
<ul>
<li>二元域<span class="math inline">\(GF(2)\)</span>上三维三重矢量空间<span class="math inline">\(V\)</span>的三个自然基底是<span class="math inline">\((100)\)</span>，<span class="math inline">\((010)\)</span> ，<span class="math inline">\((001)\)</span> 。</li>
<li>以<span class="math inline">\((100)\)</span>为基底可张成一维三重子空间<span class="math inline">\(V_{s1}\)</span>，含<span class="math inline">\(2^1
= 2\)</span>个元素，即 <span class="math inline">\(V_{s1} =
\{(000),(100)\}\)</span> 。</li>
<li>以<span class="math inline">\((010),(001)\)</span>为基底可张成二维三重子空间<span class="math inline">\(V_{s2}\)</span>，含<span class="math inline">\(2^2
= 4\)</span>个元素，即 <span class="math inline">\(V_{s2} =
\{(000),(001),(010),(011)\}\)</span> 。</li>
<li><span class="math inline">\(V_{s1}\)</span>和<span class="math inline">\(V_{s2}\)</span>都是<span class="math inline">\(V\)</span>的子空间。</li>
</ul></li>
</ul></li>
<li><strong>矢量空间构成</strong>
<ul>
<li>每个矢量空间或子空间中必然包含<strong>零矢量</strong>。</li>
<li><strong>构成矢量的有序元素的个数称为“重”数，张成矢量空间的基底的个数称为“维”数</strong>。</li>
<li>一般情况下，由<span class="math inline">\(n\)</span>个<span class="math inline">\(n\)</span>重的基底张成<span class="math inline">\(n\)</span>维矢量空间<span class="math inline">\(V_n\)</span>，维数和重数一致。</li>
<li>子空间的引入使维数和重数可以不一样。</li>
<li><strong>维数不可能大于重数</strong>，而当维数小于重数时就说明这是一个子空间。</li>
</ul></li>
<li><strong>正交与对偶空间</strong>
<ul>
<li>若两个矢量点积为<span class="math inline">\(0\)</span>，即<span class="math inline">\(v_1 \cdot v_2 = 0\)</span>，则称<span class="math inline">\(v_1\)</span>和<span class="math inline">\(v_2\)</span><strong>矢量正交</strong>。</li>
<li>若某矢量空间中的任意元素与另一矢量空间中的任意元素正交，则称这两个<strong>矢量空间正交</strong>。
<ul>
<li>若两个矢量空间的基底正交，则这两个矢量空间一定正交。</li>
</ul></li>
<li>正交的两个子空间<span class="math inline">\(V_1\)</span>、<span class="math inline">\(V_2\)</span>互为<strong>对偶空间</strong>（Dual
Space），其中一个空间是另一个空间的<strong>零空间</strong>（null
space，也称零化空间）。</li>
</ul></li>
</ul>
<h4 id="码空间">码空间</h4>
<ul>
<li><strong>码空间</strong>
<ul>
<li><img src="image-59.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<ol type="1">
<li>码字<span class="math inline">\(c_i\)</span>是<span class="math inline">\(n\)</span>个码元的有序排列，是<span class="math inline">\(n\)</span>维<span class="math inline">\(n\)</span>重矢量空间<span class="math inline">\(V_n\)</span>的元素之一。</li>
<li>然而，矢量空间<span class="math inline">\(V_n\)</span>的元素不一定是码字。</li>
<li>将码字<span class="math inline">\(c_i\)</span>写作<span class="math inline">\((c_{i0}, c_{i1}, \cdots, c_{i(n -
1)})\)</span>，将码字的集合写成<span class="math inline">\(C\)</span>，称为码集。</li>
<li>码集不一定能构成<span class="math inline">\(V_n\)</span>的一个子空间，但对线性分组码而言，码集<span class="math inline">\(C\)</span>一定是<span class="math inline">\(V_n\)</span>的一个子空间。</li>
</ol></li>
<li><strong>分组编码的任务</strong>
<ul>
<li>通常<span class="math inline">\(q^n &gt;&gt;
q^k\)</span>，分组编码的任务是要在<span class="math inline">\(n\)</span>维<span class="math inline">\(n\)</span>重矢量空间的<span class="math inline">\(q^n\)</span>种可能组合中选择其中的<span class="math inline">\(q^k\)</span>个构成一个码空间，其元素就是许用码的码集。</li>
<li>因此分组编码的任务就是：
<ol type="1">
<li>选择一个<span class="math inline">\(k\)</span>维<span class="math inline">\(n\)</span>重子空间作为码空间。</li>
<li>确定由<span class="math inline">\(k\)</span>维<span class="math inline">\(k\)</span>重信息空间到<span class="math inline">\(k\)</span>维<span class="math inline">\(n\)</span>重码空间的映射方法。</li>
</ol></li>
<li>码空间的不同选择方法，以及信息组与码组的不同映射算法，就构成了不同的分组码。</li>
</ul></li>
</ul>
<h3 id="译码方法">译码方法</h3>
<ul>
<li><p><strong>译码的任务</strong></p>
<ul>
<li>译码器的任务是从受损的信息序列中尽可能正确地恢复出原信息。</li>
<li>译码算法的已知条件是：
<ul>
<li>实际接收到的码字序列<span class="math inline">\(\{r\}\)</span>，<span class="math inline">\(r =
(r_1, r_2, \cdots, r_N)\)</span>。</li>
<li>发端所采用的编码算法和该算法产生的码集<span class="math inline">\(X^N\)</span>，满足<span class="math inline">\(c_i
= (c_{i1}, c_{i2}, \cdots, c_{iN}) \in X^N\)</span> 。</li>
<li>信道模型及信道参数。</li>
</ul></li>
</ul></li>
<li><p><strong>信道模型</strong>：<img src="image-60.webp" srcset="/img/loading/loading3.gif" lazyload alt="信道模型"></p></li>
<li><p><strong>译码规则</strong>：见<a href="./Ch6sup_信道编码定理.md/#译码规则">译码规则</a></p></li>
<li><p><strong><a href="./Ch6sup_信道编码定理.md/#最大后验概率译码">最大后验概率译码</a></strong></p>
<ul>
<li><strong>最佳译码</strong>，也叫<strong>最大后验概率译码(MAP)</strong>：<span class="math display">\[\hat{c}_i=\arg\max_{1\leq i\leq
M}P(c_i|r)\]</span></li>
</ul></li>
<li><p><strong><a href="./Ch6sup_信道编码定理.md/#最大联合概率译码">最大联合概率译码</a></strong>
<span class="math display">\[P(c_i/r)=\frac{P(c_i)P(r/c_i)}{P(r)}\quad i
= 1, 2, \cdots, 2^K\]</span></p>
<ul>
<li><span class="math inline">\(P(c_i/r)\)</span>最大等效于<span class="math inline">\(P(c_i)P(r/c_i)\)</span>最大。</li>
<li><strong>最大联合概率译码</strong>：<span class="math display">\[\hat{c}_i=\arg\max_{1\leq i\leq
M}P(c_i)P(r|c_i)\]</span></li>
</ul></li>
<li><p><strong><a href="./Ch6sup_信道编码定理.md/#最大似然译码">最大似然译码</a></strong></p>
<ul>
<li>如果 构成码集的<span class="math inline">\(2^K\)</span>个码字以相同概率发送，满足<span class="math inline">\(P(c_i)=1/2^K\)</span>，<span class="math inline">\(i = 1, 2, \cdots, 2^K\)</span>
，在此前提下最佳译码等效于如下最大似然译码。</li>
<li><strong>最大似然译码</strong>(MLD)：码字等概率发送时：<span class="math display">\[\hat{c}_i=\arg\max_{1\leq i\leq
M}P(r|c_i)\]</span></li>
</ul></li>
<li><p><strong><a href="./Ch6sup_信道编码定理.md/#最小汉明距离译码">最小汉明距离译码</a></strong></p>
<ul>
<li><p>对于无记忆信道：<span class="math display">\[\max P(r/c_i)=\max
\prod_{j = 1}^{N}P(r_j/c_{ij})\]</span></p></li>
<li><p>对BSC信道： <span class="math display">\[P(r_j|c_{ij}) =
  \begin{cases}
  p, &amp; c_{ij} \neq r_j \\
  1 - p, &amp; c_{ij} = r_j
  \end{cases}\]</span></p>
<p><span class="math display">\[P(r|c_i)=\prod_{j = 1}^{N}P(r_j|c_{ij})
= p^d(1 - p)^{N - d}=(\frac{p}{1 - p})^d(1 - p)^N\]</span> 其中<span class="math inline">\(d\)</span>为<span class="math inline">\(r\)</span>与<span class="math inline">\(c_i\)</span>的汉明距离，可见，<strong><span class="math inline">\(d\)</span>越小，<span class="math inline">\(P(r|c_i)\)</span>越大</strong>。</p></li>
<li><p>BSC信道的最大似然译码可以简化为最小汉明距离译码。 <span class="math display">\[\hat{c}_i = \arg \min_{1 \leq i \leq M} d(r,
c_i)\]</span></p>
<ul>
<li>只要在接收端将收码<span class="math inline">\(r\)</span>与发码<span class="math inline">\(c_i\)</span>的各码元逐一比较，选择其中汉明距离最小的码字作为译码估值<span class="math inline">\(\hat{c}_i\)</span>。</li>
<li>由于BSC信道是对称的，只要发送的码字独立、等概，汉明距离译码也就是最佳译码。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="信道编码定理">信道编码定理</h3>
<ul>
<li>信道编码定理研究的问题：<img src="image-61.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h4 id="随机编码">随机编码</h4>
<ul>
<li>所有可能的编码：平均错误概率<span class="math inline">\(\overline{P}_e\)</span>
<ul>
<li>若<span class="math inline">\(\overline{P}_e \to
0\)</span>，必存在一种编码<span class="math inline">\(P_e \to 0\)</span>
。</li>
<li>用这种方法不能得知最优码是如何具体编出来的；却能得知最优码可以好到什么程度，并进而推导出有扰离散信道的编码定理，对指导编码技术具有特别重要的理论价值。</li>
</ul></li>
<li>在<span class="math inline">\((N,K)\)</span>分组编码器中随机选定的码集有<span class="math inline">\(q^{NM}\)</span>种。第<span class="math inline">\(m\)</span>个码集(记作<span class="math inline">\(\{c\}_m\)</span>)被随机选中的概率是<span class="math display">\[P(\{c\}_m)=q^{-(NM)}\]</span>
<ul>
<li>设与这种选择相对应的条件差错概率是<span class="math inline">\(P_e(\{c\}_m)\)</span> 。</li>
<li>全部码集的平均差错概率是<span class="math display">\[\overline{P}_e
= \sum_{m = 1}^{q^{NM}} P(\{c\}_m)P_e(\{c\}_m)=q^{-NM}\sum_{m =
1}^{q^{NM}} P_e(\{c\}_m)\]</span></li>
<li>必定存在某些码集<span class="math inline">\(P_e(\{c\}_m)&gt;\overline{P}_e\)</span>，某些码集<span class="math inline">\(P_e(\{c\}_m)&lt;\overline{P}_e\)</span> 。</li>
<li>若<span class="math inline">\(\overline{P}_e \to
0\)</span>，就必然存在一批码集<span class="math inline">\(P_e(\{c\}_{m})
\to 0\)</span>，即差错概率趋于零的好码一定存在 。</li>
</ul></li>
<li>码集点数<span class="math inline">\(M = q^K\)</span>占<span class="math inline">\(N\)</span>维矢量空间总点数<span class="math inline">\(q^N\)</span>的比例是<span class="math inline">\(F
= q^K/q^N = q^{-(N - K)}\)</span>
<ul>
<li>当<span class="math inline">\(K\)</span>和<span class="math inline">\(N\)</span>的差值拉大即冗余的空间点数增加时，平均而言码字的分布将变得稀疏，码字间的平均距离将变大，平均差错概率将变小。</li>
<li>当<span class="math inline">\(F \to 0\)</span>即<span class="math inline">\((N -
K)\to\infty\)</span>时，能否让平均差错概率<span class="math inline">\(\overline{P}_e \to 0\)</span> ？
<ul>
<li>Gallager在1965年推导了<span class="math inline">\(\overline{P}_e\)</span>的上边界，并证明这个上边界是按指数规律收敛的。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="信道编码定理-1">信道编码定理</h4>
<ul>
<li><span class="math inline">\(\overline{P}_e &lt; e^{-NE(R)}\)</span>
<ul>
<li><span class="math inline">\(E(R)\)</span>为可靠性函数，也叫误差指数
。</li>
<li><strong>码率</strong>：<span class="math inline">\(R = \frac{\log
M}{N}=\frac{\log q^K}{N}\)</span> 。</li>
<li><span class="math inline">\(M\)</span>是可能的信息组合数，<span class="math inline">\(M = q^K\)</span> ；<span class="math inline">\(N\)</span>是每码字的码元数；<span class="math inline">\(R\)</span>表示每码元携带的信息量（bit
/码元）。</li>
</ul></li>
<li><span class="math inline">\(E(R)\)</span>可靠性函数
<ul>
<li><span class="math inline">\(R\)</span>在<span class="math inline">\([0,R_0]\)</span>区间时，<span class="math inline">\(E(R) - R\)</span>曲线是斜率为<span class="math inline">\(-1\)</span>（<span class="math inline">\(-45^{\circ}\)</span>）的直线，<span class="math inline">\(E(R)\)</span>反比于<span class="math inline">\(R\)</span></li>
<li><span class="math inline">\(R_0 &lt; C\)</span>，临界速率</li>
<li>而当<span class="math inline">\(R = C\)</span>时<span class="math inline">\(E(R)=0\)</span>即可靠性为零。</li>
<li><img src="image-62.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><strong>噪声信道的信道编码定理</strong>
<ul>
<li><strong><a href="./Ch6sup_信道编码定理.md#信道编码正定理">正定理</a></strong>：只要传输率
<span class="math inline">\(R\)</span> 小于信道容量 <span class="math inline">\(C\)</span> ，总存在一种信道码（及解码器），在码长
<span class="math inline">\(N\)</span>
足够长的情况下，能够以所要求的任意小的差错概率实现可靠的通信。</li>
<li><strong><a href="./Ch6sup_信道编码定理.md#信道编码逆定理">逆定理</a></strong>：信道容量
<span class="math inline">\(C\)</span> 是可靠通信系统传输率 <span class="math inline">\(R\)</span> 的上边界，如果 <span class="math inline">\(R &gt; C\)</span>
，就不可能有任何一种编码能使差错概率任意小。</li>
</ul></li>
</ul>
<h4 id="联合信源信道编码定理">联合信源信道编码定理</h4>
<ul>
<li><strong>两步编码处理方法</strong>：
<ul>
<li><strong>信源编码</strong>：针对各自信源的不同特点，进行不同的数据压缩，用最有效的二元码来表达这些不同的信源。</li>
<li><strong>信道编码</strong>：对于共同传输的数字信道而言，输入端只看成是一系列二元码。信道编码只针对信道特性来进行，不考虑不同信源的不同特性。</li>
<li>信源压缩编码只考虑信源的统计特性；信道编码只考虑信道的统计特性。</li>
</ul></li>
<li><strong>特点</strong>：
<ul>
<li><strong>优点</strong>：设计简单、通用性好，可以分别形成标准。</li>
<li><strong>缺点</strong>：没有充分利用各自的优势，因而不是最佳的。</li>
</ul></li>
<li><strong>信源－信道编码定理内容</strong>：
<ul>
<li>若信源 <span class="math inline">\(S\)</span> 极限熵 <span class="math inline">\(H_{\infty}\)</span> 小于信道容量 <span class="math inline">\(C\)</span> ，则存在信源信道编码，使得 <span class="math inline">\(P_{e}\to0\)</span></li>
<li>反之，对于任意平稳随机序列，若极限熵 <span class="math inline">\(H_{\infty}&gt;C\)</span>
，则错误概率远离零，即不可能在信道中以任意小的错误概率发送这随机序列</li>
</ul></li>
<li><strong>总结</strong>：
<ul>
<li>当且仅当信源极限熵小于信道容量，在信道上能够无错误地传输平稳遍历信源。<strong><span class="math inline">\(H &lt; C\)</span>
是信源通过信道有效和可靠传输的充要条件</strong>。</li>
<li>如果信道的容量 <span class="math inline">\(C &gt; R(D)\)</span>
，则在信源和信道处用足够复杂的处理后，总能以失真度 <span class="math inline">\(D+\varepsilon\)</span> 再现信源的消息。</li>
</ul></li>
</ul>
<h3 id="纠错编码的基本思路">纠错编码的基本思路</h3>
<ul>
<li><strong>思路一</strong>：<span class="math display">\[\overline{P}_e
&lt; e^{-NE(R)}\]</span>
<ul>
<li><img src="image-63.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li><strong><span class="math inline">\(R\)</span>不变</strong>，信道容量大者其可靠性函数<span class="math inline">\(E(R)\)</span>也大
<ul>
<li><strong>增大信道容量<span class="math inline">\(C\)</span>的方法</strong>：
<ul>
<li>扩展带宽。</li>
<li>加大功率。</li>
<li>降低噪声。</li>
</ul></li>
</ul></li>
<li><strong><span class="math inline">\(C\)</span>不变</strong>，码率减小时其可靠性函数<span class="math inline">\(E(R)\)</span>增大
<ul>
<li><strong>减小码率<span class="math inline">\(R\)</span>的方法</strong>：
<ul>
<li><span class="math inline">\(Q\)</span>、<span class="math inline">\(N\)</span>不变而减小<span class="math inline">\(K\)</span>。</li>
<li><span class="math inline">\(Q\)</span>、<span class="math inline">\(K\)</span>不变而增大<span class="math inline">\(N\)</span>。</li>
<li><span class="math inline">\(N\)</span>、<span class="math inline">\(K\)</span>不变而减小<span class="math inline">\(Q\)</span>。</li>
</ul></li>
</ul></li>
<li><strong>增大码长<span class="math inline">\(N\)</span></strong></li>
</ul></li>
<li><strong>思路二：纠错能力的获取途径</strong>：
<ul>
<li><strong>利用冗余度</strong>：时间、频带、功率、设备复杂度。</li>
<li><strong>噪声均化(随机化、概率化)</strong>：增加码长、卷积、交错。</li>
</ul></li>
</ul>
<h2 id="线性分组码">6.3 线性分组码</h2>
<p><img src="image-64.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>构造一个<span class="math inline">\(k\)</span>维<span class="math inline">\(n\)</span>重子空间（码空间），使<span class="math inline">\(q^k\)</span>个信息元组一一对应映射到码空间。</li>
<li><strong>码率(编码效率)</strong>：<span class="math inline">\(R_c =
k/n\)</span></li>
</ul>
<h3 id="线性分组码的形成">线性分组码的形成</h3>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>码空间</strong>
<ul>
<li><strong>码空间</strong>：所有元素（即码字）都可以写成<span class="math inline">\(k\)</span>个基底的线性组合，表达式为<span class="math display">\[\mathbf{c} = m_{k - 1}\mathbf{g}_{k - 1}+\cdots +
m_{1}\mathbf{g}_{1}+m_{0}\mathbf{g}_{0}\]</span></li>
<li><span class="math inline">\(\mathbf{m}=(m_{k -
1},\cdots,m_{1},m_{0})\)</span>是<span class="math inline">\(k\)</span>维<span class="math inline">\(k\)</span>重信息组</li>
<li><span class="math inline">\(\mathbf{c}=(c_{n -
1},\cdots,c_{1},c_{0})\)</span>是码字。</li>
<li><span class="math inline">\(\mathbf{g}=(\mathbf{g}_{k -
1},\cdots,\mathbf{g}_{1},\mathbf{g}_{0})\)</span>是在<span class="math inline">\(n\)</span>维<span class="math inline">\(n\)</span>重空间<span class="math inline">\(V\)</span>中，从<span class="math inline">\(n\)</span>个基底中选取出来的<span class="math inline">\(k\)</span>个矢量作为码空间的<strong>基底</strong></li>
<li><img src="image-65.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><strong>映射规律</strong>：信息元作为基底线性组合的系数。</li>
<li><strong>生成矩阵</strong>：
<ul>
<li><strong>生成矩阵</strong><span class="math inline">\(\mathbf{G}_{k\times
n}=\begin{bmatrix}\mathbf{g}_{k -
1}\\\vdots\\\mathbf{g}_{1}\\\mathbf{g}_{0}\end{bmatrix}=\begin{bmatrix}g_{(k
- 1)(n - 1)}&amp;\cdots&amp;g_{(k - 1)1}&amp;g_{(k -
1)0}\\\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\g_{1(n -
1)}&amp;\cdots&amp;g_{11}&amp;g_{10}\\g_{0(n -
1)}&amp;\cdots&amp;g_{01}&amp;g_{00}\end{bmatrix}\)</span></li>
<li>码字<span class="math inline">\(\mathbf{c}\)</span>、消息<span class="math inline">\(\mathbf{m}\)</span>与生成矩阵<span class="math inline">\(\mathbf{G}\)</span>的关系为：<span class="math display">\[\mathbf{c_{1\times n}}=\mathbf{m_{1\times
k}}\mathbf{G_{k\times n}}\]</span>
<ul>
<li>其中<span class="math inline">\(\mathbf{c_{1\times
n}}\)</span>是<span class="math inline">\(n\)</span>维码字，<span class="math inline">\(\mathbf{m_{1\times k}}\)</span>是<span class="math inline">\(k\)</span>维信息组，<span class="math inline">\(\mathbf{G_{k\times n}}\)</span>是<span class="math inline">\(k\times n\)</span>生成矩阵。</li>
<li>因为<span class="math inline">\(k\)</span>个基底即<span class="math inline">\(\mathbf{G}\)</span>的<span class="math inline">\(k\)</span>个行矢量线性无关，矩阵<span class="math inline">\(\mathbf{G}\)</span>的秩一定等于<span class="math inline">\(k\)</span>。</li>
<li>当信息元确定后，码字仅由<span class="math inline">\(\mathbf{G}\)</span>矩阵决定，所以称这<span class="math inline">\(k\times n\)</span>矩阵<span class="math inline">\(\mathbf{G}\)</span>为该<span class="math inline">\((n,k)\)</span>线性分组码的生成矩阵。</li>
</ul></li>
<li><strong>特点</strong>:
<ul>
<li>想要保证<span class="math inline">\((n,k)\)</span>线性分组码能够构成<span class="math inline">\(k\)</span>维<span class="math inline">\(n\)</span>重子空间，<span class="math inline">\(G\)</span>的<span class="math inline">\(k\)</span>个行矢量<span class="math inline">\(g_{k
- 1},\cdots, g_{1},
g_{0}\)</span>必须是线性无关的，只有这样才符合作为基底的条件。</li>
<li>由于基底不是唯一的，所以<span class="math inline">\(G\)</span>也就不是唯一的。</li>
<li>不同的基底有可能生成同一码集，但因编码涉及码集和映射两个因素，码集一样而映射方法不同也不能说是同样的码。</li>
</ul></li>
</ul></li>
<li><strong>基底的选择</strong>：构造<span class="math inline">\((3,2)\)</span>线性分组码示例
<ul>
<li><img src="image-66.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>需要构造<span class="math inline">\(2\)</span>维<span class="math inline">\(3\)</span>重码空间。</li>
<li><span class="math inline">\(3\)</span>维<span class="math inline">\(3\)</span>重空间的<span class="math inline">\(3\)</span>个自然基底为<span class="math inline">\(100\)</span>，<span class="math inline">\(010\)</span>，<span class="math inline">\(001\)</span> 。</li>
<li>选择其中<span class="math inline">\(2\)</span>个基底<span class="math inline">\(010\)</span>，<span class="math inline">\(001\)</span>构成码空间，对应码集为<span class="math inline">\((000, 010, 001, 011)\)</span></li>
<li><span class="math inline">\(2\)</span>个基底的线性组合<span class="math inline">\(010\)</span>，<span class="math inline">\(011\)</span>也可以张成码空间 ，对应码集为<span class="math inline">\((000, 010, 011, 001)\)</span> 。</li>
<li>码集一样，对应关系不一样</li>
</ul></li>
<li><strong>示例</strong>：
<ul>
<li>对于<span class="math inline">\((6, 3)\)</span>线性分组码，<span class="math inline">\(k = 3\)</span>，<span class="math inline">\(2^k =
8\)</span>（消息数量）
<ul>
<li>基底<span class="math inline">\(\mathbf{g}_{2}=111010\)</span>，<span class="math inline">\(\mathbf{g}_{1}=110001\)</span>，<span class="math inline">\(\mathbf{g}_{0}=011101\)</span>。</li>
<li>则<span class="math inline">\(\mathbf{G}=\begin{bmatrix}\mathbf{g}_{2}\\\mathbf{g}_{1}\\\mathbf{g}_{0}\end{bmatrix}=\begin{bmatrix}111010\\110001\\011101\end{bmatrix}\)</span>
。 $
<span class="math display">\[\begin{aligned}
  \mathbf{c}&amp;=m_{k - 1}\mathbf{g}_{k - 1}+\cdots +
m_{1}\mathbf{g}_{1}+m_{0}\mathbf{g}_{0}\\
  &amp;=(m_{k - 1} \cdots m_{0})_{1\times
k}\times\begin{bmatrix}\mathbf{g}_{k -
1}\\\vdots\\\mathbf{g}_{0}\end{bmatrix}_{k\times n}\\
  &amp;=\mathbf{m}_{1\times k}\mathbf{G}_{k\times n}
  \end{aligned}\]</span>
$</li>
<li><table>
<thead>
<tr>
<th>信息<span class="math inline">\(\mathbf{u}=m_2m_1m_0\)</span></th>
<th>码字<span class="math inline">\(\mathbf{c}=c_5c_4c_3c_2c_1c_0\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>000000</td>
</tr>
<tr>
<td>001</td>
<td>011101</td>
</tr>
<tr>
<td>010</td>
<td>110001</td>
</tr>
<tr>
<td>011</td>
<td>101100</td>
</tr>
<tr>
<td>100</td>
<td>111010</td>
</tr>
<tr>
<td>101</td>
<td>100111</td>
</tr>
<tr>
<td>110</td>
<td>001011</td>
</tr>
<tr>
<td>111</td>
<td>010110</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ul></li>
</ul>
<h4 id="系统形式的生成矩阵与校验矩阵">系统形式的生成矩阵与校验矩阵</h4>
<ul>
<li><strong>系统形式的生成矩阵</strong>
<ul>
<li><p><span class="math inline">\((n,k)\)</span>码的任何生成矩阵都可以通过行运算（以及列置换）简化成“系统形式”
<span class="math display">\[\mathbf{G_S} = [I_k |
P]=\begin{bmatrix}1&amp;0&amp;\cdots&amp;0&amp;p_{(k - 1)(n - k -
1)}&amp;\cdots&amp;p_{(k - 1)1}&amp;p_{(k -
1)0}\\0&amp;1&amp;\vdots&amp;0&amp;p_{(k - 2)(n - k -
1)}&amp;\cdots&amp;p_{(k - 2)1}&amp;p_{(k -
2)0}\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\0&amp;0&amp;0&amp;1&amp;p_{0(n
- k - 1)}&amp;\cdots&amp;p_{01}&amp;p_{00}\end{bmatrix}\]</span></p>
<p>其中<span class="math inline">\(I_k\)</span>是<span class="math inline">\(k×k\)</span>单位矩阵，<span class="math inline">\(P\)</span>是<span class="math inline">\(k×(n -
k)\)</span>矩阵。</p></li>
</ul></li>
<li><strong>系统码</strong>
<ul>
<li><strong>码字结构</strong>：码字<span class="math inline">\(c\)</span>包含信息位（<span class="math inline">\(k\)</span>位）和校验位（<span class="math inline">\(n - k\)</span>位）<img src="image-67.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li><strong>特点</strong>：
<ul>
<li>前<span class="math inline">\(k\)</span>位由单位矩阵<span class="math inline">\(I_k\)</span>决定，等于把信息组<span class="math inline">\(m\)</span>原封不动搬到码字的前<span class="math inline">\(k\)</span>位</li>
<li>其余的<span class="math inline">\(n -
k\)</span>位叫<strong>冗余位</strong>或<strong>一致校验位</strong>，是前<span class="math inline">\(k\)</span>个信息位的线性组合。</li>
</ul></li>
<li><strong>定义</strong>：具备以上系统形式的<span class="math inline">\((n,k)\)</span>码叫做<strong>系统码</strong>。若生成矩阵<span class="math inline">\(G\)</span>不具备系统形式，则生成的码叫做非系统码。</li>
<li>系统化不改变码集，只是改变了映射规则。</li>
<li><strong>性质</strong>：
<ul>
<li><strong>等效矩阵</strong>：若通过行运算和列置换能将两个生成矩阵<span class="math inline">\(G\)</span>互等，则称这两个<span class="math inline">\(G\)</span>等效。</li>
<li><strong>形式转换</strong>：非系统码的<span class="math inline">\(G\)</span>可通过运算转变为系统码的<span class="math inline">\(G\)</span>。</li>
<li><strong>等效码</strong>：等效的两个<span class="math inline">\(G\)</span>生成的两个<span class="math inline">\((n,k)\)</span>线性码也是等效的。</li>
<li>因此，<strong>每个<span class="math inline">\((n,k)\)</span>线性码都可以和一个系统的<span class="math inline">\((n,k)\)</span>线性码等效</strong></li>
</ul></li>
</ul></li>
<li><strong>线性分组码空间构成</strong>
<ul>
<li><span class="math inline">\(n\)</span>维<span class="math inline">\(n\)</span>重空间<span class="math inline">\(V_n\)</span>有相互正交的<span class="math inline">\(n\)</span>个基底。</li>
<li>选择<span class="math inline">\(k\)</span>个基底构成码空间<span class="math inline">\(G\)</span> 。</li>
<li>选择另外的<span class="math inline">\((n -
k)\)</span>个基底构成空间<span class="math inline">\(H\)</span> 。</li>
<li><span class="math inline">\(G\)</span>和<span class="math inline">\(H\)</span>是对偶的，满足<span class="math inline">\(GH^T = 0\)</span>，<span class="math inline">\(HG^T = 0\)</span> 。</li>
<li><img src="image-70.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><strong>码空间与对偶空间</strong>
<ul>
<li>将<span class="math inline">\(H\)</span>空间的<span class="math inline">\(n - k\)</span>个基底排列起来可构成一个<span class="math inline">\((n - k)\times
n\)</span>矩阵，称为<strong>校验矩阵<span class="math inline">\(H\)</span></strong>
，用于校验接收到的码字是否正确。</li>
<li><span class="math inline">\(G\)</span>是<span class="math inline">\((n,k)\)</span>码的生成矩阵，<span class="math inline">\(H\)</span>是其校验矩阵。</li>
<li><span class="math inline">\(H\)</span>是<span class="math inline">\((n,n -
k)\)</span>对偶码的生成矩阵，它的每一行是一个基底，<span class="math inline">\(G\)</span>则是其校验矩阵。</li>
<li>满足<span class="math inline">\(GH^T = 0\)</span> ，且<span class="math inline">\(H = [ - P^T | I_{n -
k}]\)</span>，在二进制情况下，负号可省略。</li>
</ul></li>
<li><strong>生成矩阵与校验矩阵的关系</strong>
<ul>
<li>对于任何一个码字<span class="math inline">\(\mathbf{c}\)</span>，有<span class="math display">\[\mathbf{c}_{1\times n}\mathbf{H}_{n\times(n -
k)}^T = \mathbf{0}_{1\times(n - k)}\]</span></li>
<li>因为生成矩阵的每个行矢量是一个码字，所以必有<span class="math display">\[\mathbf{G}_{k\times n}\mathbf{H^T}_{n\times(n -
k)} = \mathbf{0}_{k\times(n - k)}\]</span></li>
<li>对于系统码的生成矩阵<span class="math inline">\(\mathbf{G_S}_{k
\times n} = [\mathbf{I}_k | \mathbf{P}_{k \times (n-k)}]\)</span>，有：
<span class="math display">\[
  \begin{align*}
  \mathbf{G_S}_{k\times n}[-\mathbf{P}_{(n - k)\times k}^T |
\mathbf{I}_{n - k}]^T&amp;=[\mathbf{I}_k | \mathbf{P}_{k\times(n -
k)}][-\mathbf{P}_{(n - k)\times k}^T | \mathbf{I}_{n - k}]^T\\
  &amp;=[-\mathbf{I}_k\mathbf{P}_{k\times(n -
k)}]+[\mathbf{P}_{k\times(n - k)}\mathbf{I}_{n - k}]\\
  &amp;=[-\mathbf{P}]+[\mathbf{P}]\\
  &amp;=\mathbf{0}_{k\times(n - k)}
  \end{align*}
  \]</span></li>
<li>由此可得<span class="math inline">\(\mathbf{H} = [-\mathbf{P}^T |
\mathbf{I}_{n - k}] = [\mathbf{P}^T | \mathbf{I}_{n - k}]\)</span>
，二进制码省略负号</li>
</ul></li>
<li><strong>示例</strong>：
<ul>
<li>同上例：<span class="math inline">\(G =
\begin{bmatrix}111010&amp;①\\110001&amp;②\\011101&amp;③\end{bmatrix}\Rightarrow
G_s = \begin{bmatrix}100111&amp;① + ③\\010110&amp;① + ②+ ③\\001011&amp;①
+ ②\end{bmatrix}\)</span></li>
<li><table>
<thead>
<tr>
<th>信息</th>
<th>码字</th>
<th>系统码字</th>
</tr>
</thead>
<tbody>
<tr>
<td>000</td>
<td>000000</td>
<td><strong>000000</strong></td>
</tr>
<tr>
<td>001</td>
<td>011101</td>
<td><strong>001011</strong></td>
</tr>
<tr>
<td>010</td>
<td>110001</td>
<td><strong>010110</strong></td>
</tr>
<tr>
<td>011</td>
<td>101100</td>
<td><strong>011101</strong></td>
</tr>
<tr>
<td>100</td>
<td>111010</td>
<td><strong>100111</strong></td>
</tr>
<tr>
<td>101</td>
<td>100111</td>
<td><strong>101100</strong></td>
</tr>
<tr>
<td>110</td>
<td>001011</td>
<td><strong>110001</strong></td>
</tr>
<tr>
<td>111</td>
<td>010110</td>
<td><strong>111010</strong></td>
</tr>
</tbody>
</table></li>
<li><strong>一致校验位</strong> <img src="image-68.webp" srcset="/img/loading/loading3.gif" lazyload>
<ul>
<li><p><span class="math display">\[\mathbf{c} =
(c_5c_4c_3c_2c_1c_0)=(m_2m_1m_0)
G_S=(m_2m_1m_0)\begin{bmatrix}100111\\010110\\001011\end{bmatrix}\]</span></p>
<p>可得： <span class="math display">\[
  \begin{cases}
  c_5 = m_2\\
  c_4 = m_1\\
  c_3 = m_0
  \end{cases}
  \]</span> 因此，校验位可按下面方程组计算：</p>
<p><span class="math display">\[
  \begin{cases}
  c_2 = m_2 + m_1 = c_5 + c_4\\
  c_1 = m_2 + m_1 + m_0 = c_5 + c_4 + c_3\\
  c_0 = m_2 + m_0 = c_5 + c_3
  \end{cases}
  \]</span></p>
<p>由于校验位和信息元之间是线性运算关系，所以叫<strong>线性分组码</strong>。</p></li>
<li><p>编码器<img src="image-69.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
</ul></li>
<li><strong>校验矩阵</strong>
<ul>
<li>由<span class="math display">\[
  \begin{cases}
  c_2 = c_5 + c_4\\
  c_1 = c_5 + c_4 + c_3\\
  c_0 = c_5 + c_3
  \end{cases}
  \]</span>在模2加法下可转化为<span class="math display">\[
  \begin{cases}
  c_5 + c_4 + 0 + c_2 + 0 + 0 = 0\\
  c_5 + c_4 + c_3 + 0 + c_1 + 0 = 0\\
  c_5 + 0 + c_3 + 0 + 0 + c_0 = 0
  \end{cases}
  \]</span></li>
<li>令<span class="math inline">\(\mathbf{c}_{1\times
n}=(c_5c_4c_3c_2c_1c_0)\)</span> ，<span class="math inline">\(\mathbf{0}_{1\times(n - k)}=(000)\)</span>
，有<span class="math inline">\((c_5c_4c_3c_2c_1c_0)\begin{bmatrix}111\\110\\011\\100\\010\\001\end{bmatrix}=[000]\)</span>
，校验矩阵<span class="math inline">\(\mathbf{H} =
\begin{bmatrix}110100\\111010\\101001\end{bmatrix}_{(n - k)\times
n}\)</span></li>
<li>满足<span class="math inline">\(\mathbf{c}_{1\times
n}\mathbf{H}_{n\times(n - k)}^T = \mathbf{0}_{1\times(n - k)}\)</span>
，<span class="math inline">\(\mathbf{H}\)</span>为校验矩阵，<strong>上式用来验证一个<span class="math inline">\(n\)</span>重矢量是否为码字</strong>。</li>
</ul></li>
<li><strong>综上</strong>：对于<span class="math inline">\((6,
3)\)</span>线性分组码，其中<span class="math inline">\(k =
3\)</span>，<span class="math inline">\(2^k = 8\)</span>（消息数量） ：
<ul>
<li>原始生成矩阵<span class="math inline">\(G =
\begin{bmatrix}111010\\110001\\011101\end{bmatrix}\)</span></li>
<li>系统形式的生成矩阵<span class="math inline">\(G_s =
\begin{bmatrix}100111\\010110\\001011\end{bmatrix} = [I_{k} |
P]\)</span></li>
<li>校验矩阵<span class="math inline">\(H = [P^T | I_{n - k}] =
\begin{bmatrix}110100\\111010\\101001\end{bmatrix}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="伴随式与标准阵列译码">伴随式与标准阵列译码</h3>
<h4 id="基本概念-1">基本概念</h4>
<ul>
<li><img src="image-71.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li><strong>定义差错图案<span class="math inline">\(E\)</span></strong>
<span class="math display">\[\mathbf{E}=(e_{n -
1},\cdots,e_{1},e_{0})=\mathbf{R}-\mathbf{C}=(r_{n - 1}-c_{n -
1},\cdots,r_{1}-c_{1},r_{0}-c_{0})\]</span>
<ul>
<li>在二进制码中，模2加与模2减等同，因此有<span class="math display">\[\mathbf{E}=\mathbf{R}+\mathbf{C} \quad
\mathbf{R}=\mathbf{C}+\mathbf{E}\]</span></li>
</ul></li>
<li><strong>定义伴随式<span class="math inline">\(S\)</span></strong>
<span class="math display">\[\mathbf{S}=(s_{n - k -
1},\cdots,s_{1},s_{0})=\mathbf{R}\mathbf{H}^T=\mathbf{E}\mathbf{H}^T\]</span>
<ul>
<li>因为<span class="math inline">\(\mathbf{C}\mathbf{H}^T = 0\)</span>
，所以<span class="math inline">\(\mathbf{R}\mathbf{H}^T=(\mathbf{C}+\mathbf{E})\mathbf{H}^T=\mathbf{C}\mathbf{H}^T+\mathbf{E}\mathbf{H}^T=\mathbf{E}\mathbf{H}^T\)</span>
<ul>
<li>若收码无误：则<span class="math inline">\(\mathbf{R}=\mathbf{C}\)</span>即<span class="math inline">\(\mathbf{E}=0\)</span> ，此时<span class="math inline">\(\mathbf{C}\mathbf{H}^T =\mathbf{E}\mathbf{H}^T =
\mathbf{R}\mathbf{H}^T = 0\)</span></li>
<li>若收码有误：即<span class="math inline">\(\mathbf{E}\neq0\)</span>
，则<span class="math inline">\(\mathbf{R}\mathbf{H}^T=\mathbf{E}\mathbf{H}^T\neq0\)</span></li>
</ul></li>
<li>在<span class="math inline">\(\mathbf{H}^T\)</span>固定的前提下，<span class="math inline">\(\mathbf{R}\mathbf{H}^T\)</span>仅与差错图案<span class="math inline">\(\mathbf{E}\)</span>有关，而与发送码<span class="math inline">\(\mathbf{C}\)</span>无关。</li>
</ul></li>
</ul>
<h4 id="编译码过程">编译码过程</h4>
<ul>
<li><strong>编译码过程</strong>
<ul>
<li><img src="image-72.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>差错图案<span class="math inline">\(\mathbf{E}\)</span>是<span class="math inline">\(n\)</span>重矢量，共有<span class="math inline">\(2^n\)</span>个可能的组合，而伴随式<span class="math inline">\(\mathbf{S}\)</span>是<span class="math inline">\((n - k)\)</span>重矢量，只有<span class="math inline">\(2^{n -
k}\)</span>个可能的组合，因此不同的差错图案可能有相同的伴随式。</li>
</ul></li>
<li><strong>差错图案E的求解</strong>
<ul>
<li><p>可以通过解线性方程求解<span class="math inline">\(\mathbf{E}\)</span>： <span class="math display">\[
  \begin{align*}
  \mathbf{S}&amp;=(s_{n - k -
1},\cdots,s_{1},s_{0})=\mathbf{E}\mathbf{H}^T\\
  &amp;=(e_{n - 1},\cdots,e_{1},e_{0})\begin{bmatrix}h_{(n - k - 1)(n -
1)}&amp;\cdots&amp;h_{(n - k - 1)1}&amp;h_{(n - k -
1)0}\\\vdots&amp;\ddots&amp;\vdots&amp;\vdots\\h_{1(n -
1)}&amp;\cdots&amp;h_{11}&amp;h_{10}\\h_{0(n -
1)}&amp;\cdots&amp;h_{01}&amp;h_{00}\end{bmatrix}^T
  \end{align*}
  \]</span></p>
<p>得到线性方程组： <span class="math display">\[
  \begin{cases}
  s_{n - k - 1}=e_{n - 1}h_{(n - k - 1)(n - 1)}+\cdots+e_{1}h_{(n - k -
1)1}+e_{0}h_{(n - k - 1)0}\\
  \vdots\\
  s_{1}=e_{n - 1}h_{1(n - 1)}+\cdots+e_{1}h_{11}+e_{0}h_{10}\\
  s_{0}=e_{n - 1}h_{0(n - 1)}+\cdots+e_{1}h_{01}+e_{0}h_{00}
  \end{cases}
  \]</span></p>
<p>上述方程组中有<span class="math inline">\(n\)</span>个未知数<span class="math inline">\(e_{n - 1},\cdots,e_{1},e_{0}\)</span>，却只有<span class="math inline">\(n - k\)</span>个方程，可知方程组有多解。
在有理数或实数域中，少一个方程就可能导致无限多个解，而在二元域中，少一个方程导致两个解，少两个方程四个解，以此类推，少<span class="math inline">\(n - (n - k)=k\)</span>个方程导致每个未知数有<span class="math inline">\(2^k\)</span>个解。 因此，由上述方程组解出的<span class="math inline">\(\mathbf{E}\)</span>可以有<span class="math inline">\(2^k\)</span>个解。到底取哪一个作为附加在收码<span class="math inline">\(\mathbf{R}\)</span>上的差错图案<span class="math inline">\(\mathbf{E}\)</span>的估值呢？
<strong>概率译码</strong>：把所有<span class="math inline">\(2^k\)</span>个解的重量(差错图案<span class="math inline">\(\mathbf{E}\)</span>中<span class="math inline">\(1\)</span>的个数)作比较，选择其中最轻（<span class="math inline">\(1\)</span>的个数最少）者作为<span class="math inline">\(\mathbf{E}\)</span>的估值。</p></li>
</ul></li>
<li><strong>标准阵列译码表</strong>: 列出伴随式对应的所有差错图案
<ul>
<li><p><strong>标准阵列构造方法</strong></p>
<ol type="1">
<li>先将<span class="math inline">\(2^k\)</span>个码字排成一行，作为标准阵列的第一行，并将全<span class="math inline">\(0\)</span>码字<span class="math inline">\(\mathbf{C}_1 =
(00\ldots0)\)</span>放在最左面的位置上。</li>
<li>然后在剩下的<span class="math inline">\((2^n - 2^k)\)</span>个<span class="math inline">\(n\)</span>重中选取一个重量最轻的<span class="math inline">\(n\)</span>重<span class="math inline">\(\mathbf{E}_2\)</span>放在全<span class="math inline">\(0\)</span>码字<span class="math inline">\(\mathbf{C}_1\)</span>下面，再将<span class="math inline">\(\mathbf{E}_2\)</span>分别和码字<span class="math inline">\(\mathbf{C}_2,\mathbf{C}_3,\cdots,\mathbf{C}_{2^k}\)</span>相加，放在对应码字下面构成阵列第二行。</li>
<li>在第二次剩下的<span class="math inline">\(n\)</span>重中，选取重量最轻的<span class="math inline">\(n\)</span>重<span class="math inline">\(\mathbf{E}_3\)</span>，放在<span class="math inline">\(\mathbf{E}_2\)</span>下面，并将<span class="math inline">\(\mathbf{E}_3\)</span>分别加到第一行各码字上，得到第三行。</li>
<li>继续这样做下去，直到全部<span class="math inline">\(n\)</span>重用完为止，得到给定<span class="math inline">\((n,k)\)</span>线性码的标准阵列。</li>
</ol>
<ul>
<li><strong>在标准阵列的同一行中没有相同的矢量，而且<span class="math inline">\(2^n\)</span>个<span class="math inline">\(n\)</span>重中任一个<span class="math inline">\(n\)</span>重在阵列中出现一次且仅出现一次</strong></li>
</ul></li>
<li><p>标准阵列译码表：<strong>标准阵列可能不唯一</strong></p>
<table style="width:100%;">

<thead>
<tr>
<th></th>
<th>伴随式</th>
<th>陪集首</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>子集头</td>
<td><span class="math inline">\(S_1\)</span></td>
<td><span class="math inline">\(\mathbf{C}_1=\mathbf{E}_1=0\)</span></td>
<td><span class="math inline">\(\mathbf{C}_2\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\mathbf{C}_{2^k}\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="math inline">\(S_2\)</span></td>
<td><span class="math inline">\(\mathbf{E}_2\)</span></td>
<td><span class="math inline">\(\mathbf{C}_2+\mathbf{E}_2\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\mathbf{C}_{2^k}+\mathbf{E}_2\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="math inline">\(S_3\)</span></td>
<td><span class="math inline">\(\mathbf{E}_3\)</span></td>
<td><span class="math inline">\(\mathbf{C}_2+\mathbf{E}_3\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\mathbf{C}_{2^k}+\mathbf{E}_3\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="math inline">\(\vdots\)</span></td>
<td><span class="math inline">\(\vdots\)</span></td>
<td><span class="math inline">\(\vdots\)</span></td>
<td><span class="math inline">\(\vdots\)</span></td>
<td><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr>
<td></td>
<td><span class="math inline">\(S_{2^{n - k}}\)</span></td>
<td><span class="math inline">\(\mathbf{E}_{2^{n - k}}\)</span></td>
<td><span class="math inline">\(\mathbf{C}_2+\mathbf{E}_{2^{n -
k}}\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\mathbf{C}_{2^k}+\mathbf{E}_{2^{n -
k}}\)</span></td>
</tr>
</tbody>
</table></li>
<li><p><strong>陪集和子集</strong></p>
<ul>
<li><strong>陪集</strong>：译码表中有<span class="math inline">\(2^{n -
k}\)</span>行，每行是一个陪集，每陪集的第一个元素(位于第一列)叫<strong>陪集首</strong>。同一陪集（同一行）中的所有元素对应共同的一个伴随式。第一行陪集的陪集首是全零伴随式<span class="math inline">\(\mathbf{S}_0\)</span>所对应的全零差错图案<span class="math inline">\(\mathbf{E}_0\)</span> (无差错)，而第<span class="math inline">\(j\)</span>行陪集的陪集首是伴随式<span class="math inline">\(\mathbf{S}_j\)</span>所对应的重量最小的差错图案<span class="math inline">\(\mathbf{E}_j\)</span> (<span class="math inline">\(\mathbf{C}_0 =
0,\mathbf{R}_j=\mathbf{E}_j\)</span>) 。</li>
<li><strong>子集</strong>：译码表中有<span class="math inline">\(2^k\)</span>列，每列是一个子集，每子集的第一个元素(位于第一行)叫<strong>子集头</strong>。同一子集（同一列）中的所有元素对应同一个码字，第一列子集的子集头是全零码字<span class="math inline">\(\mathbf{C}_0\)</span>，而第<span class="math inline">\(i\)</span>列子集的子集头是码字<span class="math inline">\(\mathbf{C}_i\)</span> (<span class="math inline">\(\mathbf{E}_0 =
0,\mathbf{R}_i=\mathbf{C}_i\)</span>) 。</li>
</ul></li>
<li><p><strong>检错纠错能力</strong>：根据<span class="math inline">\(\mathbf{E}\)</span>在标准阵列中的位置</p>
<ul>
<li>第一行：不可检错</li>
<li>第一列：可检错可纠错</li>
<li>剩余部分：可检错不可纠错</li>
</ul></li>
</ul></li>
<li><strong>具体译码过程</strong>：
<ol type="1">
<li>求生成矩阵<span class="math inline">\(\mathbf{G}\)</span>和校验矩阵<span class="math inline">\(\mathbf{H}\)</span>。</li>
<li>通过信息组<span class="math inline">\(\mathbf{m}\)</span>和生成矩阵<span class="math inline">\(\mathbf{G}\)</span>求出各子集头码字<span class="math inline">\(\mathbf{C}\)</span>。</li>
<li>构造标准阵列译码表。</li>
<li>根据标准阵列译码表，对收到的码字<span class="math inline">\(\mathbf{R}\)</span>进行译码。译码方法：
<ul>
<li>直接搜索码表，查得<span class="math inline">\(\mathbf{R}\)</span>所在列的子集头<span class="math inline">\(\mathbf{C}\)</span>，因此译码输出取为<span class="math inline">\(\mathbf{C}\)</span></li>
<li>先求伴随式 <span class="math inline">\(\mathbf{S} =
\mathbf{R}\mathbf{H^T}\)</span>，确定<span class="math inline">\(\mathbf{S}\)</span>所在行，再沿着行对码表作一维搜索找到
<span class="math inline">\(\mathbf{R}\)</span>，最后顺着所在列向上找出码字
<span class="math inline">\(\mathbf{C}\)</span></li>
<li>先求出伴随式 <span class="math inline">\(\mathbf{S} =
\mathbf{R}\mathbf{H^T}\)</span> 并确定 <span class="math inline">\(\mathbf{S}\)</span>
所对应的陪集首（差错图案）<span class="math inline">\(\mathbf{E}\)</span>，再将陪集首与收码相加得到码字
<span class="math inline">\(\mathbf{C}= \mathbf{R}+
\mathbf{E}\)</span></li>
</ul>
上述三种方法由上而下，查表的时间下降而所需计算量增大，实际使用时可针对不同情况选用。</li>
</ol></li>
<li><strong>示例</strong>： 一个<span class="math inline">\((5,2)\)</span>系统线性码的生成矩阵是<span class="math inline">\(G =
\begin{bmatrix}10111\\01101\end{bmatrix}\)</span> ，设收码<span class="math inline">\(\mathbf{R} =
(10101)\)</span>，构造标准阵列译码表，译出发码的估值。
<ul>
<li><p>求出校验矩阵：<span class="math inline">\(H = [P^T |
I_3]=\begin{bmatrix}11100\\10010\\11001\end{bmatrix}\)</span></p></li>
<li><p>分别以信息组<span class="math inline">\(\mathbf{m}=
(00)\)</span>、<span class="math inline">\((01)\)</span>、<span class="math inline">\((10)\)</span>、<span class="math inline">\((11)\)</span>及已知的<span class="math inline">\(G\)</span>求得<span class="math inline">\(4\)</span>个许用码字为<span class="math inline">\(\mathbf{C}_0 = (00000)\)</span>、<span class="math inline">\(\mathbf{C}_1 = (10111)\)</span> 、<span class="math inline">\(\mathbf{C}_2 = (01101)\)</span>、<span class="math inline">\(\mathbf{C}_3 = (11010)\)</span></p></li>
<li><p>构造标准阵列译码表</p>
<table>

<thead>
<tr>
<th>伴随式</th>
<th>陪集首</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(S_0 = 000\)</span></td>
<td><span class="math inline">\(E_0 + C_0 = 00000\)</span></td>
<td><span class="math inline">\(C_1 = 10111\)</span></td>
<td><span class="math inline">\(C_2 = 01101\)</span></td>
<td><span class="math inline">\(C_3 = 11010\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(S_1 = 111\)</span></td>
<td><span class="math inline">\(E_1 = 10000\)</span></td>
<td><span class="math inline">\(00111\)</span></td>
<td><span class="math inline">\(11101\)</span></td>
<td><span class="math inline">\(01010\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(S_2 = 101\)</span></td>
<td><span class="math inline">\(E_2 = 01000\)</span></td>
<td><span class="math inline">\(11111\)</span></td>
<td><span class="math inline">\(00101\)</span></td>
<td><span class="math inline">\(10010\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(S_3 = 100\)</span></td>
<td><span class="math inline">\(E_3 = 00100\)</span></td>
<td><span class="math inline">\(10011\)</span></td>
<td><span class="math inline">\(01001\)</span></td>
<td><span class="math inline">\(11110\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(S_4 = 010\)</span></td>
<td><span class="math inline">\(E_4 = 00010\)</span></td>
<td><span class="math inline">\(10101\)</span></td>
<td><span class="math inline">\(01111\)</span></td>
<td><span class="math inline">\(11000\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(S_5 = 001\)</span></td>
<td><span class="math inline">\(E_5 = 00001\)</span></td>
<td><span class="math inline">\(10110\)</span></td>
<td><span class="math inline">\(01100\)</span></td>
<td><span class="math inline">\(11011\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(S_6 = 011\)</span></td>
<td><span class="math inline">\(E_6 = 00011\)</span></td>
<td><span class="math inline">\(10100\)</span></td>
<td><span class="math inline">\(01110\)</span></td>
<td><span class="math inline">\(11001\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(S_7 = 110\)</span></td>
<td><span class="math inline">\(E_7 = 00110\)</span></td>
<td><span class="math inline">\(10001\)</span></td>
<td><span class="math inline">\(01011\)</span></td>
<td><span class="math inline">\(11100\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>将接收码<span class="math inline">\(\mathbf{R}=10101\)</span>译码，可选以下三种方法之一译码：</p>
<ol type="1">
<li>直接搜索码表，查得<span class="math inline">\((10101)\)</span>所在列的子集头是<span class="math inline">\((10111)\)</span>，因此译码输出取为<span class="math inline">\((10111)\)</span>。</li>
<li>先求伴随式<span class="math inline">\(\mathbf{R}H^T = (10101)\cdot
H^T = (010) = S_4\)</span>，确定<span class="math inline">\(S_4\)</span>所在行，再沿着行对码表作一维搜索找到<span class="math inline">\((10101)\)</span>，最后顺着所在列向上找出码字<span class="math inline">\((10111)\)</span>。</li>
<li>先求出伴随式<span class="math inline">\(\mathbf{R}H^T = (010) =
S_4\)</span>并确定<span class="math inline">\(S_4\)</span>所对应的陪集首（差错图案）<span class="math inline">\(E_4=(00010)\)</span>，再将陪集首与收码相加得到码字<span class="math inline">\(\mathbf{C}= \mathbf{R}+
E_4=(10101)+(00010)=(10111)\)</span>。</li>
</ol></li>
</ul></li>
</ul>
<h3 id="码距纠错能力mdc码及重量谱">码距、纠错能力、MDC码及重量谱</h3>
<ul>
<li><p><strong>汉明距离</strong>：两个码字<span class="math inline">\(c_i,
c_j\)</span>之间对应码元位上符号取值不同的个数，称为码字<span class="math inline">\(c_i, c_j\)</span>之间的汉明距离 <span class="math display">\[d(c_i, c_j)=\sum_{k = 0}^{n - 1}(c_{ik}\oplus
c_{jk})\]</span></p></li>
<li><p><strong>最小距离</strong>：在<span class="math inline">\((n,k)\)</span>线性码中，码字之间的最小汉明距离
<span class="math display">\[d_{min}=min(d(c_i, c_j)),c_i, c_j\in
C\]</span></p></li>
<li><p><strong>定理6.1</strong>：任何最小距离<span class="math inline">\(d_{min}\)</span>的线性分组码，其检错能力为<span class="math inline">\((d_{min}-1)\)</span>，纠错能力<span class="math inline">\(t\)</span>为<span class="math display">\[t =
\left\lfloor\frac{d_{min}-1}{2}\right\rfloor\]</span></p>
<ul>
<li>纠错能力<span class="math inline">\(t\)</span>是指在接收码中，最多允许有<span class="math inline">\(t\)</span>个差错图案而不致于误译的能力。（只要不到另一个点，你就能知道出错了）</li>
<li>检错能力是指在接收码中，最多允许有<span class="math inline">\(d_{min}-1\)</span>个差错图案而不致于误译的能力。（只要离原来的点比任何一个点都近，你就能知道原来的点）</li>
</ul></li>
<li><p><strong>纠错能力示意图</strong>：码集各码字间的距离是不同的，码距最小者决定码的特性，称之为最小距离<span class="math inline">\(d_{min}\)</span></p>
<ul>
<li><img src="image-73.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>如图中<span class="math inline">\(d_{min}=3\)</span>，纠错能力是<span class="math inline">\(1\)</span>，检错能力是<span class="math inline">\(2\)</span></li>
</ul></li>
<li><p><strong>最小距离计算</strong>：</p>
<ul>
<li><strong>汉明重量</strong>：码字中非<span class="math inline">\(0\)</span>码元符号的个数，称为该码字的汉明重量。<strong>在二元线性码中，码字重量就是码字中含“<span class="math inline">\(1\)</span>”的个数</strong> <span class="math display">\[w(c)=\sum_{i = 0}^{n - 1}c_i\]</span></li>
<li><strong>定理6.2</strong>：线性分组码的最小距离等于码集中非零码字的最小重量
<span class="math display">\[d_{min}=min\{w(C_i)\}\quad C_i\in
C及C_i\neq0\]</span><span class="math display">\[d(c_i, c_j)=w(c_i\oplus
c_j)=w(c_k)\quad c_i, c_j, c_k\in C\]</span></li>
<li><strong>定理6.3</strong>：<span class="math inline">\((n,k)\)</span>线性分组码最小距离等于<span class="math inline">\(d_{min}\)</span>的<strong>必要</strong>条件是：校验矩阵<span class="math inline">\(H\)</span>中任意<span class="math inline">\((d_{min}-1)\)</span>列线性无关。
<ul>
<li>将<span class="math inline">\(H\)</span>写成<span class="math inline">\(H = [h_{n - 1},\cdots, h_1,
h_0]\)</span>，其中<span class="math inline">\(h_{n - 1},\cdots, h_1,
h_0\)</span>为列矢量 <span class="math display">\[
  \begin{align*}
  cH^T &amp;= [c_{n - 1},\cdots, c_1, c_0]\begin{bmatrix}h_{n -
1}^T\\\vdots\\h_1^T\\h_0^T\end{bmatrix}\\
  &amp;=c_{n - 1}h_{n - 1}^T+\cdots + c_1h_1^T + c_0h_0^T = 0
  \end{align*}
  \]</span></li>
<li>若存在一个重量为<span class="math inline">\(d_{min}\)</span>的码字，则必有<span class="math inline">\(d_{min}\)</span>列线性相关</li>
</ul></li>
<li><strong>定理6.4</strong>：<span class="math inline">\((n,k)\)</span>线性分组码的最小距离必定小于等于<span class="math inline">\((n - k + 1)\)</span> <span class="math display">\[d_{min}\leq(n - k + 1)\]</span>
<ul>
<li>计算校验矩阵的秩，则<span class="math inline">\(H\)</span>的秩加<span class="math inline">\(1\)</span>就是最小距离<span class="math inline">\(d_{min}\)</span>的上限 。</li>
</ul></li>
</ul></li>
<li><p><strong>示例</strong>：对于<span class="math inline">\((7,
4)\)</span>线性码，<span class="math inline">\(H =
\begin{bmatrix}1110100\\0111010\\1101001\end{bmatrix}\)</span></p>
<ul>
<li>各列都不相同，任意<span class="math inline">\(2\)</span>列之和不等于<span class="math inline">\(0\)</span>，任何<span class="math inline">\(2\)</span>列线性无关；</li>
<li>存在<span class="math inline">\(2\)</span>列之和等于矩阵中某一列，即存在<span class="math inline">\(3\)</span>列线性相关</li>
<li>存在重量为<span class="math inline">\(3\)</span>的码字</li>
<li>能找到的最小线性相关的列数为<span class="math inline">\(3\)</span></li>
<li>所以该码的最小距离为<span class="math inline">\(d_{min} =
3\)</span>，小于<span class="math inline">\(n - k + 1 = 4\)</span>
。</li>
<li>该码的纠错能力为<span class="math inline">\(t =
\left\lfloor\frac{d_{min}-1}{2}\right\rfloor =
1\)</span>，检错能力为<span class="math inline">\(d_{min}-1=2\)</span>。</li>
</ul></li>
<li><p><strong>极大最小距离码 (MDC)</strong>：</p>
<ul>
<li><strong>定义</strong>：<span class="math inline">\(d_{min}=n - k +
1\)</span>的<span class="math inline">\((n,k)\)</span>线性码称为极大最小距离码 (MDC -
Maximized minimum Distance Code)。</li>
<li>总体的、平均的纠错能力不但与最小距离有关，而且与其余码距或者说与码字的重量分布特性有关。</li>
</ul></li>
</ul>
<h3 id="完备码perfect-code">完备码（Perfect code）</h3>
<h4 id="完备码定义与性质">完备码定义与性质</h4>
<ul>
<li><strong>汉明限</strong>：任何一个二元<span class="math inline">\((n,k)\)</span>线性分组码都有<span class="math inline">\(2^{n -
k}\)</span>个伴随式，若该码的纠错能力是<span class="math inline">\(t\)</span>，则对于任何一个重量小于等于<span class="math inline">\(t\)</span>的差错图案，都应有一个伴随式与之对应，即伴随式的数目满足条件<span class="math display">\[2^{n -
k}\geq\binom{n}{0}+\binom{n}{1}+\binom{n}{2}+\cdots+\binom{n}{t}\]</span>
此式称作<strong>汉明限</strong>，任何一个纠错码都应满足该条件。</li>
<li><strong>完备码定义</strong>：满足以下等式的二元<span class="math inline">\((n,k)\)</span>线性分组码 <span class="math display">\[2^{n -
k}=\binom{n}{0}+\binom{n}{1}+\binom{n}{2}+\cdots+\binom{n}{t}\]</span></li>
<li><strong>完备码性质</strong>：
<ol type="1">
<li>即该码的伴随式数目恰好和不大于<span class="math inline">\(t\)</span>个差错的图案数目相等。</li>
<li>相当于在标准译码阵列中能将所有重量不大于<span class="math inline">\(t\)</span>的差错图案选作陪集首，且没有一个陪集首的重量大于<span class="math inline">\(t\)</span>，此时校验位得到最充分的利用。</li>
<li>这样的二元<span class="math inline">\((n,k)\)</span>线性分组码称为<strong>完备码</strong>。</li>
</ol></li>
</ul>
<h4 id="汉明码hamming-code">汉明码（Hamming Code）</h4>
<ul>
<li><strong>定义</strong>：汉明码是纠错能力<span class="math inline">\(t
= 1\)</span>的一类码的统称。</li>
<li><strong>性质</strong>：
<ul>
<li><p>汉明码既有二进制的，也有非二进制的。</p></li>
<li><p>二进制时，汉明码码长<span class="math inline">\(n\)</span>和信息位<span class="math inline">\(k\)</span>服从规律<span class="math display">\[(n,k)=(2^m - 1,2^m - 1 - m)\]</span> 其中<span class="math inline">\(m = n - k\)</span>，是正整数。</p>
<table>

<thead>
<tr>
<th>正整数<span class="math inline">\(m=n-k\)</span></th>
<th>码长 <span class="math inline">\(n = 2^m - 1\)</span></th>
<th>信息位 <span class="math inline">\(k = 2^m - 1 - m\)</span></th>
<th>汉明码<span class="math inline">\((n,k)\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td><span class="math inline">\(2^3 - 1 = 7\)</span></td>
<td><span class="math inline">\(2^3 - 1 - 3 = 4\)</span></td>
<td><span class="math inline">\((7,4)\)</span></td>
</tr>
<tr>
<td>4</td>
<td><span class="math inline">\(2^4 - 1 = 15\)</span></td>
<td><span class="math inline">\(2^4 - 1 - 4 = 11\)</span></td>
<td><span class="math inline">\((15,11)\)</span></td>
</tr>
<tr>
<td>5</td>
<td><span class="math inline">\(2^5 - 1 = 31\)</span></td>
<td><span class="math inline">\(2^5 - 1 - 5 = 26\)</span></td>
<td><span class="math inline">\((31,26)\)</span></td>
</tr>
<tr>
<td>6</td>
<td><span class="math inline">\(2^6 - 1 = 63\)</span></td>
<td><span class="math inline">\(2^6 - 1 - 6 = 57\)</span></td>
<td><span class="math inline">\((63,57)\)</span></td>
</tr>
<tr>
<td>7</td>
<td><span class="math inline">\(2^7 - 1 = 127\)</span></td>
<td><span class="math inline">\(2^7 - 1 - 7 = 120\)</span></td>
<td><span class="math inline">\((127,120)\)</span></td>
</tr>
<tr>
<td>8</td>
<td><span class="math inline">\(2^8 - 1 = 255\)</span></td>
<td><span class="math inline">\(2^8 - 1 - 8 = 247\)</span></td>
<td><span class="math inline">\((255,247)\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
</tr>
</tbody>
</table></li>
<li><p>汉明码是完备码，因为满足等式<span class="math display">\[\binom{n}{0}+\binom{n}{1}=1 + n=1 + 2^m -
1=2^m=2^{n - k}\]</span></p></li>
</ul></li>
<li><strong>校验矩阵构成</strong>：汉明码的校验矩阵<span class="math inline">\(H\)</span>具有特殊性质，可简化构造方法。
<ul>
<li>一个<span class="math inline">\((n,k)\)</span>码的校验矩阵有<span class="math inline">\(n - k\)</span>行和<span class="math inline">\(n\)</span>列，二进制时<span class="math inline">\(n - k\)</span>个码元所能组成的列矢量总数是<span class="math inline">\(2^{n - k}\)</span>，除去全<span class="math inline">\(0\)</span>矢量后为<span class="math inline">\(2^{n
- k} - 1 = 2^m - 1 = n\)</span>，恰好和校验矩阵的列数<span class="math inline">\(n\)</span>相等。</li>
<li>只要排列所有列，通过列置换将矩阵<span class="math inline">\(H\)</span>转换成系统形式，就可以进一步得到相应的生成矩阵<span class="math inline">\(G\)</span>。</li>
</ul></li>
<li><strong>示例</strong>：构造一个<span class="math inline">\(m =
3\)</span>的二元<span class="math inline">\((7, 4)\)</span>汉明码。
<ul>
<li>先利用汉明码的特性构造一个<span class="math inline">\((7,
4)\)</span>汉明码的校验矩阵<span class="math inline">\(H\)</span>，再通过列置换将它变为系统形式：</li>
<li>校验矩阵<span class="math inline">\(H=\begin{bmatrix}0001111\\0110011\\1010101\end{bmatrix}\)</span>，经列置换得到<span class="math inline">\(\begin{bmatrix}1110100\\0111010\\1101001\end{bmatrix}=[P^T
| I_3]\)</span>，再得生成矩阵<span class="math inline">\(G = [I_4 |
P]=\begin{bmatrix}1000101\\0100111\\0010110\\0001011\end{bmatrix}\)</span>
#### 高莱（Golay）码</li>
</ul></li>
<li>是二进制<span class="math inline">\((23, 12)\)</span>线性码</li>
<li>最小距离<span class="math inline">\(d_{min}=7\)</span></li>
<li>纠错能力<span class="math inline">\(t = 3\)</span></li>
<li>高莱码是完备码，因为满足等式<span class="math display">\[2^{23 -
12}=2048=1+\binom{23}{1}+\binom{23}{2}+\binom{23}{3}\]</span></li>
<li>在<span class="math inline">\((23,12)\)</span>码上添加一位奇偶位即得二进制线性<span class="math inline">\((24, 12)\)</span>扩展高莱码，其最小距离<span class="math inline">\(d_{min}=8\)</span>。</li>
<li>编码步骤见<a href="#高莱golay码-1">高莱码编码步骤</a></li>
</ul>
<h3 id="循环码">循环码</h3>
<h4 id="基本概念与多项式描述">基本概念与多项式描述</h4>
<ul>
<li><p><strong>循环码的定义</strong>：设一个<span class="math inline">\((n,k)\)</span>线性分组码<span class="math inline">\(C\)</span>，如果它的任一码字的每一次循环移位都还是<span class="math inline">\(C\)</span>的一个码字，则称<span class="math inline">\(C\)</span>是<strong>循环码</strong>。 <span class="math display">\[
  \begin{align*}
  \forall: &amp;\boldsymbol{c}=(c_{n - 1},c_{n - 2},\cdots,c_{0})\in C\\
  &amp;\boldsymbol{c}_1=(c_{n - 2},c_{n - 3},\cdots,c_{0},c_{n - 1})\in
C\\
  &amp;\boldsymbol{c}_2=(c_{n - 3},c_{n - 4},\cdots,c_{0},c_{n - 1},c_{n
- 2})\in C\\
  &amp;\vdots\\
  &amp;\boldsymbol{c}_{n - 1}=(c_{0},c_{n - 1},\cdots,c_{2},c_{1})\in C
  \end{align*}
  \]</span></p></li>
<li><p><strong>循环码的数学描述</strong>：</p>
<ul>
<li><strong>循环码的特点</strong>：
<ul>
<li>它是线性分组码，其数学模型应具有线性特性。</li>
<li>具有循环特性。</li>
<li>码字的全体<strong>构成了<span class="math inline">\(n\)</span>维矢量空间中具有循环特性的<span class="math inline">\(k\)</span>维子空间</strong>。</li>
</ul></li>
<li><strong>线性分组码的多项式描述</strong>：
<ul>
<li>码字<span class="math display">\[\boldsymbol{c}=(c_{n - 1},c_{n -
2},\cdots,c_{0})\]</span></li>
<li>码多项式<span class="math display">\[c(x)=c_{n - 1}x^{n - 1}+c_{n -
2}x^{n - 2}+\cdots + c_1x + c_0\]</span></li>
<li>对于线性分组码<span class="math inline">\(C\)</span>，可以表示成码多项式构成的集合： <span class="math display">\[
  \begin{align*}
  &amp;C\leftrightarrow C(x)\\
  &amp;=\{c_{n - 1}x^{n - 1}+c_{n - 2}x^{n - 2}+\cdots + c_1x +
c_0\mid(c_{n - 1},c_{n - 2},\cdots,c_{0})\in C\}
  \end{align*}
  \]</span></li>
</ul></li>
</ul></li>
<li><p><strong>示例</strong>：<span class="math inline">\((7,
3)\)</span>线性分组码</p>
<ul>
<li>校验矩阵<span class="math inline">\(H=\begin{bmatrix}1&amp;0&amp;1&amp;1&amp;0&amp;0&amp;0\\1&amp;1&amp;1&amp;0&amp;1&amp;0&amp;0\\1&amp;1&amp;0&amp;0&amp;0&amp;1&amp;0\\0&amp;1&amp;1&amp;0&amp;0&amp;0&amp;1\end{bmatrix}\)</span>
生成矩阵<span class="math inline">\(G=\begin{bmatrix}1&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0\\0&amp;1&amp;0&amp;0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;1&amp;1&amp;0&amp;1\end{bmatrix}\)</span>
由<span class="math inline">\(\boldsymbol{c}=\boldsymbol{m}G\)</span>得码集（由两组码字循环构成的循环码）：
<img src="image-79.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>任取一码字
<ul>
<li>设<span class="math inline">\(\boldsymbol{c}=0011101\)</span>
，则<span class="math inline">\(c(x)=x^4 + x^3 + x^2 + 1\)</span>
。</li>
<li>移一位，<span class="math inline">\(\boldsymbol{c}_1 =
0111010\)</span> ，<span class="math inline">\(c_1(x)=x^5 + x^4 + x^3 +
x = xc(x)\)</span> 。</li>
<li>移两位，<span class="math inline">\(\boldsymbol{c}_2 =
1110100\)</span> ，<span class="math inline">\(c_2(x)=x^6 + x^5 + x^4 +
x^2 = x^2c(x)\)</span> 。</li>
<li>移三位，<span class="math inline">\(\boldsymbol{c}_3 =
1101001\)</span> ，<span class="math inline">\(c_3(x)=x^6 + x^5 + x^3 +
1 = x^3c(x)\pmod{(x^7 + 1)}\)</span> 。</li>
<li><span class="math inline">\(\vdots\)</span></li>
</ul></li>
</ul></li>
<li><p><strong>结论</strong>：如果将一个循环码的某一非零码字用码多项式表示出来，那么其他的非零码字多项式就可以用这个码字多项式（或码字多项式的和）乘上<span class="math inline">\(x\)</span>的一个幂，再求<span class="math inline">\((x^n + 1)\)</span>的余得到。</p></li>
<li><p><strong>说明</strong>：一个码字的移位最多能得到<span class="math inline">\(n\)</span>个码字，因此“循环码字的循环仍是码字”并不意味着循环码集可以从一个码字循环而得，还应包含码字的一些线性组合。</p></li>
</ul>
<h4 id="基本定理与矩阵描述">基本定理与矩阵描述</h4>
<ul>
<li><strong>循环码的生成多项式</strong>:
<ul>
<li><strong>定义</strong>：若<span class="math inline">\(g(x)\)</span>是一个<span class="math inline">\((n
- k)\)</span>次多项式，且是<span class="math inline">\((x^n +
1)\)</span>的因式，则由<span class="math inline">\(g(x)\)</span>可以生成一个<span class="math inline">\((n,k)\)</span>循环码，<span class="math inline">\(g(x)\)</span>称为该循环码的<strong>生成多项式</strong>。</li>
<li><strong>结论</strong>：
<ol type="1">
<li><p><strong>结论1</strong>：<span class="math inline">\(GF(2)\)</span>上的<span class="math inline">\((n,k)\)</span>循环码中，存在着一个次数为<span class="math inline">\((n - k)\)</span>的<strong>首一码多项式</strong>
<span class="math inline">\(g(x)\)</span>（首一：多项式最高幂次项系数<span class="math inline">\(g_{n - k}=1\)</span> ） <span class="math display">\[g(x)=x^{n - k}+g_{n - k - 1}x^{n - k - 1}+\cdots
+ g_2x^2 + g_1x + 1\]</span></p>
<p>使得所有码多项式都是<span class="math inline">\(g(x)\)</span>的倍式，即 <span class="math display">\[c(x)=m(x)\cdot g(x)\]</span></p>
<p>其中<span class="math display">\[m(x)=m_{k - 1}x^{k - 1}+\cdots +
m_1x + m_0\]</span></p>
<p>且所有小于<span class="math inline">\(n\)</span>次的<span class="math inline">\(g(x)\)</span>的倍式都是码多项式。
<strong>故循环码完全由它的生成多项式确定</strong>。</p></li>
<li><p><strong>结论2</strong>：<span class="math inline">\((n,k)\)</span>循环码的生成多项式<span class="math inline">\(g(x)\)</span>一定是<span class="math inline">\((x^n + 1)\)</span>的因子，即<span class="math display">\[g(x)\mid(x^n + 1)\quad或写成\quad x^n + 1 =
g(x)h(x)\]</span> 相反，如果<span class="math inline">\(g(x)\)</span>是<span class="math inline">\(x^n +
1\)</span>的<span class="math inline">\((n - k)\)</span>次因子，则<span class="math inline">\(g(x)\)</span>一定是<span class="math inline">\((n,k)\)</span>循环码的生成多项式。
<strong>生成多项式不唯一</strong>。</p></li>
<li><p><strong>结论3</strong>：任何码字的循环移位仍是码字，但并非由一个码字循环移位可以得到所有码字。</p></li>
<li><p><strong>结论4</strong>：当一个循环码给定其生成多项式<span class="math inline">\(g(x)\)</span>后，根据生成多项式就可以进行编码，但编出的码不一定为系统码。</p></li>
</ol></li>
<li><strong><span class="math inline">\((n,k)\)</span>循环码的构造</strong>：
<ol type="1">
<li>对<span class="math inline">\(x^n + 1\)</span>做因式分解，找出<span class="math inline">\((n - k)\)</span>次因式。</li>
<li>以该<span class="math inline">\((n -
k)\)</span>次因式为生成多项式<span class="math inline">\(g(x)\)</span>与不高于<span class="math inline">\((k - 1)\)</span>次信息多项式<span class="math inline">\(m(x)\)</span>相乘，即得到对应消息序列的码多项式。</li>
</ol></li>
</ul></li>
<li><strong>循环码的生成矩阵</strong>:
<ul>
<li><p><span class="math inline">\((n,k)\)</span>循环码是<span class="math inline">\(n\)</span>维线性空间中具有循环特性的<span class="math inline">\(k\)</span>维子空间，其生成矩阵可由码空间中任一组<span class="math inline">\(k\)</span>个线性无关的码字构成，这<span class="math inline">\(k\)</span>个线性无关的码字组成<span class="math inline">\((n,k)\)</span>循环码的基底，且基底不唯一。</p></li>
<li><p><strong>获得<span class="math inline">\(k\)</span>个线性无关码字的方法</strong>
<strong>当循环码的生成多项式<span class="math inline">\(g(x)\)</span>确定后，可取<span class="math inline">\(g(x)\)</span>本身加上移位<span class="math inline">\(k - 1\)</span>次所得到的<span class="math inline">\(k - 1\)</span>个码字，与<span class="math inline">\(g(x)\)</span>一起作为<span class="math inline">\(k\)</span>个基底</strong>，即： <span class="math display">\[
  \begin{align*}
  G&amp;=\begin{bmatrix}x^{k - 1}g(x)\\x^{k -
2}g(x)\\\vdots\\xg(x)\\g(x)\end{bmatrix}\\
  &amp;=\begin{bmatrix}g_{n - k}&amp;g_{n - k -
1}&amp;\cdots&amp;g_0&amp;0&amp;0&amp;\cdots&amp;0\\0&amp;g_{n -
k}&amp;g_{n - k -
1}&amp;\cdots&amp;g_0&amp;0&amp;\cdots&amp;0\\\vdots&amp;&amp;&amp;\ddots&amp;&amp;&amp;\vdots\\0&amp;\cdots&amp;0&amp;0&amp;g_{n
- k}&amp;g_{n - k - 1}&amp;\cdots&amp;g_0\end{bmatrix}
  \end{align*}
  \]</span></p>
<p>这<span class="math inline">\(k\)</span>个矢量线性无关，且由<span class="math inline">\(g(x)\)</span>循环移位得到，所以都是码字，它们构成一个<span class="math inline">\(k\times
n\)</span>的矩阵，即循环码的生成矩阵。</p></li>
</ul></li>
<li><strong>循环码的系统码</strong>
<ul>
<li><strong>系统循环码的编码</strong>：
<ul>
<li>码多项式<span class="math display">\[c(x)=x^{n -
k}m(x)+r(x)\]</span> 其中<span class="math inline">\(r(x)\)</span>是与码字中<span class="math inline">\((n - k)\)</span>个校验元相对应的<span class="math inline">\((n - k - 1)\)</span>次多项式。 对等式两边取<span class="math inline">\(\bmod g(x)\)</span>：</li>
<li>等式左边：<span class="math inline">\(c(x)=m(x)g(x)\)</span>，所以<span class="math inline">\(c(x)\bmod g(x)=0\)</span> 。</li>
<li>等式右边：必有<span class="math inline">\([x^{n - k}m(x)+r(x)]\bmod
g(x)=0\)</span> ，由于<span class="math inline">\(r(x)\)</span>的幂次<span class="math inline">\((n
- k - 1)\)</span>低于<span class="math inline">\(g(x)\)</span>的幂次<span class="math inline">\((n
- k)\)</span> ，要使等式右边为<span class="math inline">\(0\)</span>，必有<span class="math display">\[x^{n
- k}m(x)\bmod g(x)=r(x)\]</span></li>
</ul></li>
<li><strong>系统码的编码步骤</strong>：
<ol type="1">
<li>将信息多项式<span class="math inline">\(m(x)\)</span>乘以<span class="math inline">\(x^{n - k}\)</span> ，即左移<span class="math inline">\((n - k)\)</span>位</li>
<li>将<span class="math inline">\(x^{n - k}m(x)\)</span>除以<span class="math inline">\(g(x)\)</span> ，得到余式<span class="math inline">\(r(x)\)</span></li>
<li>得到系统循环码的码多项式：<span class="math inline">\(c(x)=x^{n -
k}m(x)+r(x)\)</span></li>
<li>将码多项式转换为码字。</li>
</ol></li>
<li><strong>系统码的生成矩阵</strong>
<ul>
<li>系统形式的生成矩阵 <span class="math inline">\(G = [I |
P]\)</span></li>
<li><span class="math display">\[G(x)=\begin{bmatrix}x^{n-1} +
p_{n-k}(x)\\x^{n-2} + p_{n-k-1}(x)\\\vdots\\x^{n-k+1} +
p_1(x)\\x^{n-k}  + p_0(x)\end{bmatrix}_{k \times n}\]</span> 其中<span class="math display">\[p_{i}(x)=x^{i+(n-k)}\bmod(g(x))\]</span></li>
</ul></li>
</ul></li>
<li><strong>示例</strong>：一个长度<span class="math inline">\(n =
7\)</span>的循环码的构造方法
<ol type="1">
<li><p><strong>求一种<span class="math inline">\((7,
4)\)</span>循环码</strong></p>
<ol type="1">
<li>对<span class="math inline">\(x^7 + 1\)</span>作因式分解： <span class="math inline">\(x^7 + 1=(x + 1)(x^3 + x^2 + 1)(x^3 + x +
1)\)</span> ，故<span class="math inline">\(x^7 + 1\)</span>有如下因式：
<ul>
<li>一次因式：<span class="math inline">\(x + 1\)</span>（一个）</li>
<li>三次因式：<span class="math inline">\(x^3 + x + 1\)</span>，<span class="math inline">\(x^3 + x^2 + 1\)</span>（两个）</li>
<li>四次因式：<span class="math inline">\((x + 1)(x^3 + x^2 + 1)=x^4 +
x^2 + x + 1\)</span> ，<span class="math inline">\((x + 1)(x^3 + x +
1)=x^4 + x^3 + x^2 + 1\)</span>（两个）</li>
<li>六次因式：<span class="math inline">\((x^3 + x^2 + 1)(x^3 + x +
1)=x^6 + x^5 + x^4 + x^3 + x^2 + x + 1\)</span>（一个）</li>
</ul></li>
<li>以<span class="math inline">\((n - k)\)</span>次因式作为生成多项式：
<ul>
<li><span class="math inline">\(n - k = 1\)</span>，<span class="math inline">\(k = 6\)</span>，生成一种<span class="math inline">\((7, 6)\)</span>循环码；</li>
<li><span class="math inline">\(n - k = 3\)</span>，<span class="math inline">\(k = 4\)</span>，生成两种<span class="math inline">\((7, 4)\)</span>循环码；</li>
<li><span class="math inline">\(n - k = 4\)</span>，<span class="math inline">\(k = 3\)</span>，生成两种<span class="math inline">\((7, 3)\)</span>循环码；</li>
<li><span class="math inline">\(n - k = 6\)</span>，<span class="math inline">\(k = 1\)</span>，生成一种<span class="math inline">\((7, 1)\)</span>循环码。</li>
</ul></li>
</ol>
<ul>
<li><p>求一种<span class="math inline">\((7,
4)\)</span>循环码，可选<span class="math inline">\(n - k =
3\)</span>次多项式<span class="math inline">\(x^3 + x^2 +
1\)</span>或<span class="math inline">\(x^3 + x +
1\)</span>为生成多项式。以选择<span class="math inline">\(g(x)=x^3 + x^2
+ 1\)</span>为例，<span class="math inline">\(n - k = 3\)</span>，<span class="math inline">\(k = 4\)</span>（信息位为<span class="math inline">\(4\)</span> ）。 设信息多项式为<span class="math display">\[m(x)=m_3x^3 + m_2x^2 + m_1x + m_0\]</span></p>
<p>则循环码编码后的码多项式为<span class="math display">\[c(x)=m(x)g(x)=(m_3x^3 + m_2x^2 + m_1x + m_0)(x^3
+ x^2 + 1)\]</span></p>
<table>
<thead>
<tr>
<th><span class="math inline">\(m\)</span></th>
<th><span class="math inline">\(m(x)\)</span></th>
<th><span class="math inline">\(c(x)\)</span></th>
<th><span class="math inline">\(c\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math inline">\(0000\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0\)</span></td>
<td><span class="math inline">\(0000000\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(0001\)</span></td>
<td><span class="math inline">\(1\)</span></td>
<td><span class="math inline">\(x^3 + x^2 + 1\)</span></td>
<td><span class="math inline">\(0001101\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(0010\)</span></td>
<td><span class="math inline">\(x\)</span></td>
<td><span class="math inline">\(x^4 + x^3 + x\)</span></td>
<td><span class="math inline">\(0011010\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(0011\)</span></td>
<td><span class="math inline">\(x + 1\)</span></td>
<td><span class="math inline">\(x^4 + x^2 + x + 1\)</span></td>
<td><span class="math inline">\(0010111\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(0100\)</span></td>
<td><span class="math inline">\(x^2\)</span></td>
<td><span class="math inline">\(x^5 + x^4 + x^2\)</span></td>
<td><span class="math inline">\(0101100\)</span></td>
</tr>
<tr>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
<td><span class="math inline">\(\cdots\)</span></td>
</tr>
</tbody>
</table>
<p>最终得： <img src="image-80.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
</ul></li>
<li><p><strong>求<span class="math inline">\(g(x)=x^3 + x^2 +
1\)</span>，<span class="math inline">\(k =
4\)</span>的循环码的生成矩阵</strong>： <span class="math display">\[
\begin{cases}
x^3g(x)\leftrightarrow1101000\\
x^2g(x)\leftrightarrow0110100\\
xg(x)\leftrightarrow0011010\\
g(x)\leftrightarrow0001101
\end{cases}
\Rightarrow
G=\begin{bmatrix}1101000\\0110100\\0011010\\0001101\end{bmatrix}
\]</span></p>
<p>当循环码的生成矩阵确定后，编码规则为<span class="math display">\[\boldsymbol{c}=\boldsymbol{m}G\]</span></p>
<p>例如，当<span class="math inline">\(\boldsymbol{m}=(1001)\)</span>时，<span class="math inline">\(\boldsymbol{c}=(1001)G = 1100101\)</span> 。
这与通过生成多项式计算结果相同：<span class="math inline">\(m(x)g(x)=(x^3 + 1)(x^3 + x^2 + 1)=x^6 + x^5 + x^2
+ 1\)</span>，对应码字也是<span class="math inline">\(1100101\)</span>
。</p></li>
<li><p><strong>求<span class="math inline">\(g(x)=x^3 + x^2 +
1\)</span>，<span class="math inline">\(m =
(1001)\)</span>的系统码字。</strong></p>
<ol type="1">
<li>计算<span class="math inline">\(x^{n - k}m(x)\)</span>：
<ul>
<li>因为<span class="math inline">\(n = 7\)</span>，<span class="math inline">\(k = 4\)</span>，<span class="math inline">\(m(x)=x^3 + 1\)</span>，所以<span class="math inline">\(x^{n - k}m(x)=x^3(x^3 + 1)=x^6 + x^3\)</span>
。</li>
</ul></li>
<li>计算<span class="math inline">\(x^{n - k}m(x)\)</span>除以<span class="math inline">\(g(x)\)</span>的余式<span class="math inline">\(r(x)\)</span>： 用<span class="math inline">\(x^6
+ x^3\)</span>除以<span class="math inline">\(x^3 + x^2 + 1\)</span>
，通过长除法： <img src="image-81.webp" srcset="/img/loading/loading3.gif" lazyload> 得到<span class="math inline">\(r(x)=x + 1\)</span> 。</li>
<li>得到系统循环码的码多项式<span class="math inline">\(c(x)\)</span>并转换为码字：
<ul>
<li><span class="math inline">\(c(x)=x^{n - k}m(x)+r(x)=x^6 + x^3 + x +
1\)</span> ，转换为码字<span class="math inline">\(c=(1001011)\)</span>
。</li>
</ul></li>
</ol></li>
<li><p><strong>求<span class="math inline">\((7, 4)\)</span>循环码<span class="math inline">\(g(x)=x^3 + x^2 +
1\)</span>系统形式的生成矩阵</strong>： 设<span class="math inline">\(G=\begin{bmatrix}g_3\\g_2\\g_1\\g_0\end{bmatrix}=\begin{bmatrix}1000p_{32}p_{31}p_{30}\\0100p_{22}p_{21}p_{20}\\0010p_{12}p_{11}p_{10}\\0001p_{02}p_{01}p_{00}\end{bmatrix}\)</span>
，<span class="math inline">\(G(x)=\begin{bmatrix}x^6 + p_3(x)\\x^5 +
p_2(x)\\x^4 + p_1(x)\\x^3 + p_0(x)\end{bmatrix}\)</span> 分别计算：</p>
<ul>
<li><span class="math inline">\(p_3(x)=x^6\bmod g(x)=x^2 +
x\)</span></li>
<li><span class="math inline">\(p_2(x)=x^5\bmod g(x)=x + 1\)</span></li>
<li><span class="math inline">\(p_1(x)=x^4\bmod g(x)=x^2 + x +
1\)</span></li>
<li><span class="math inline">\(p_0(x)=x^3\bmod g(x)=x^2 +
1\)</span></li>
</ul>
<p>最终得到<span class="math inline">\(G=\begin{bmatrix}1000110\\0100011\\0010111\\0001101\end{bmatrix}\)</span></p></li>
</ol></li>
</ul>
<h4 id="编译码方法及其实现电路">编译码方法及其实现电路</h4>
<ul>
<li><strong>循环码的编码</strong>
<ul>
<li><strong>编码步骤</strong>：
<ol type="1">
<li>将信息多项式<span class="math inline">\(m(x)\)</span>乘以<span class="math inline">\(x^{n - k}\)</span> ，即左移<span class="math inline">\((n - k)\)</span>位。</li>
<li>将<span class="math inline">\(x^{n - k}m(x)\)</span>除以<span class="math inline">\(g(x)\)</span> ，得到余式<span class="math inline">\(r(x)\)</span></li>
<li>得到系统循环码的码多项式<span class="math inline">\(c(x)=x^{n -
k}m(x)+r(x)\)</span></li>
<li>将码多项式转换为码字。</li>
</ol></li>
<li><strong>用除法器实现<span class="math inline">\((7,3)\)</span>循环编码器</strong>： <img src="image-82.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li><strong>除法器编码示例</strong>： <img src="image-83.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><strong>循环码的译码</strong>
<ul>
<li><strong>译码步骤</strong>：
<ol type="1">
<li>计算接收多项式<span class="math inline">\(R(x)\)</span>的伴随多项式<span class="math inline">\(S(x)\)</span> ，伴随式为<span class="math inline">\(0\)</span>则认为无差错</li>
<li>根据<span class="math inline">\(S(x)\)</span>找出相应错误图样多项式<span class="math inline">\(e(x)\)</span></li>
<li>将<span class="math inline">\(e(x)\)</span>和<span class="math inline">\(R(x)\)</span>模<span class="math inline">\(2\)</span>加，得到译码输出<span class="math inline">\(\hat{c}(x)\)</span> 。</li>
</ol></li>
<li><strong>伴随式计算及错误检测</strong>：
<ul>
<li>设接收多项式为<span class="math inline">\(R(x)\)</span>
，码多项式为<span class="math inline">\(c(x)\)</span>
，错误图样多项式为<span class="math inline">\(e(x)\)</span> ，则<span class="math display">\[R(x)=c(x)+e(x)\]</span> 用生成多项式<span class="math inline">\(g(x)\)</span>除<span class="math inline">\(R(x)\)</span>得伴随式<span class="math display">\[s(x)=R(x)\bmod g(x)=e(x)\bmod g(x)\]</span>
<strong>可通过译码电路高效实现</strong></li>
</ul></li>
</ul></li>
</ul>
<h4 id="高莱golay码">高莱（Golay）码</h4>
<ul>
<li><strong>二进制高莱码（Golay (23,12)码）的编码</strong>
<ul>
<li>二进制高莱码是一种循环码，其生成多项式为： <span class="math display">\[g(x)=x^{11}+x^{9}+x^{7}+x^{6}+x^{5}+x +
1\]</span></li>
<li><strong>编码步骤</strong>：
<ol type="1">
<li><strong>信息位准备</strong>：假设有12位的信息位，记为<span class="math inline">\(m(x)\)</span>。</li>
<li><strong>生成多项式</strong>：使用生成多项式<span class="math inline">\(g(x)\)</span>。</li>
<li><strong>计算校验位</strong>：
<ul>
<li>将信息位<span class="math inline">\(m(x)\)</span>左移11位（即乘以<span class="math inline">\(x^{11}\)</span> ），得到<span class="math inline">\(x^{11}m(x)\)</span>。</li>
<li>计算<span class="math inline">\(x^{11}m(x)\)</span>除以<span class="math inline">\(g(x)\)</span>的余数<span class="math inline">\(r(x)\)</span>。</li>
<li>将余数<span class="math inline">\(r(x)\)</span>添加到<span class="math inline">\(x^{11}m(x)\)</span>的末尾，得到编码后的码字<span class="math inline">\(c(x)=x^{11}m(x)+r(x)\)</span>。</li>
</ul></li>
</ol></li>
</ul></li>
<li><strong>扩展高莱码（Golay (24,12)码）的编码</strong>
<ul>
<li>扩展高莱码是在二进制高莱码的基础上增加一个奇偶校验位。</li>
<li><strong>编码步骤</strong>：
<ol type="1">
<li><strong>二进制高莱码编码</strong>：首先使用二进制高莱码的编码方法，生成23位的码字<span class="math inline">\(c(x)\)</span> 。</li>
<li><strong>计算奇偶校验位</strong>：
<ul>
<li>计算23位码字中1的个数。</li>
<li>如果1的个数为奇数，则添加1作为奇偶校验位；如果为偶数，则添加0
。</li>
</ul></li>
<li><strong>生成扩展码字</strong>：将奇偶校验位添加到23位码字的末尾，得到24位的扩展高莱码。</li>
</ol></li>
</ul></li>
</ul>
<h4 id="循环冗余校验cyclic-redundancy-checkcrc">循环冗余校验（Cyclic
Redundancy Check，CRC）</h4>
<ul>
<li><strong>原理</strong>：
<ul>
<li>把数据视作二进制数<span class="math inline">\(D\)</span></li>
<li>确定校验序列长度<span class="math inline">\(r\)</span></li>
<li>选择长度为<span class="math inline">\(r + 1\)</span>的生成序列<span class="math inline">\(G\)</span></li>
<li><span class="math inline">\(D\)</span>后面添加<span class="math inline">\(r\)</span>个<span class="math inline">\(0\)</span>后除以<span class="math inline">\(G\)</span> ，余数为校验序列<span class="math inline">\(R\)</span></li>
<li>将<span class="math inline">\(R\)</span>附加在<span class="math inline">\(D\)</span>后面作为实际传输数据。</li>
<li><strong>检错</strong>：接收方将接收到的数据除以<span class="math inline">\(G\)</span> ，若余数为<span class="math inline">\(0\)</span> ，则认为无出错，否则认为传输出错</li>
</ul></li>
<li><strong>特点</strong>：可检测长度小于<span class="math inline">\(r +
1\)</span> bits的所有突发错误。<img src="image-84.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li><strong>CRC示例</strong>：<img src="image-85.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li><strong>常用CRC版本</strong>：<img src="image-86.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li><strong>CRC有效性</strong>：<img src="image-87.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h1 id="第六章补充-信道编码">第六章补充 信道编码</h1>
<p><img src="image-52.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h2 id="译码规则和译码错误概率">译码规则和译码错误概率</h2>
<ul>
<li>已知信道转移错误概率 <span class="math inline">\(p =
0.9\)</span>，转移情况如下：<img src="image-53.webp" srcset="/img/loading/loading3.gif" lazyload>
<ul>
<li>若规定：
<ul>
<li><span class="math inline">\(Y = 0 \to \hat{X} = 0\)</span></li>
<li><span class="math inline">\(Y = 1 \to \hat{X} = 1\)</span></li>
<li>即 <span class="math inline">\(F(y_1) = x_1\)</span>，<span class="math inline">\(F(y_2) = x_2\)</span>，则译码错误概率 <span class="math inline">\(P_e = 0.9\)</span>。</li>
</ul></li>
<li>反之若：
<ul>
<li><span class="math inline">\(Y = 0 \to \hat{X} = 1\)</span></li>
<li><span class="math inline">\(Y = 1 \to \hat{X} = 0\)</span></li>
<li>即 <span class="math inline">\(F(y_1) = x_2\)</span>，<span class="math inline">\(F(y_2) = x_1\)</span>，则译码错误概率 <span class="math inline">\(P_e = 0.1\)</span>。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="译码规则">译码规则</h3>
<ul>
<li><strong>定义译码规则</strong>：<span class="math display">\[F(y_j) =
x_i\quad i = 1, 2, \cdots, n；j = 1, 2, \cdots, m\]</span></li>
<li>示例：
<ul>
<li>设转移概率矩阵 <span class="math inline">\(P=\begin{bmatrix}0.5&amp;0.3&amp;0.2\\0.2&amp;0.3&amp;0.5\\0.3&amp;0.3&amp;0.4\end{bmatrix}_{(n\times
m)}\)</span>，共有<span class="math inline">\(n^m\)</span>种译码规则，如：
<ul>
<li>译码规则 <span class="math inline">\(A\)</span>：<span class="math inline">\(F(y_1) = x_1\)</span>；<span class="math inline">\(F(y_2) = x_2\)</span>；<span class="math inline">\(F(y_3) = x_3\)</span>。</li>
<li>译码规则 <span class="math inline">\(B\)</span>：<span class="math inline">\(F(y_1) = x_1\)</span>；<span class="math inline">\(F(y_2) = x_3\)</span>；<span class="math inline">\(F(y_3) = x_2\)</span>。</li>
<li><span class="math inline">\(\cdots\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="错误概率">错误概率</h3>
<ul>
<li>若 <span class="math inline">\(F(y_j) = x_i^*\)</span>，则：
<ul>
<li><strong>正确概率</strong>：<span class="math display">\[p(F(y_j)|y_j)=p(x_i^*|y_j)\]</span></li>
<li><strong>错误概率</strong>：<span class="math display">\[p(e|y_j)=1 -
p(x_i^*|y_j)\]</span></li>
<li><strong>平均错误概率</strong>： <span class="math display">\[
  \begin{align*}
  P_e &amp;= E[p(e|y_j)]\\
  &amp;=\sum_{j = 1}^{m}p(y_j)p(e|y_j)\\
  &amp;=\sum_{j = 1}^{m}p(y_j)(1 - p(x_i^*|y_j))\\
  &amp;=\sum_{j = 1}^{m}p(y_j)-\sum_{j = 1}^{m}p(x_i^*,y_j)\\
  &amp;=1-\sum_{j = 1}^{m}p(x_i^*,y_j)\\
  &amp;=\sum_{Y, X-X^*}p(x,y)
  \end{align*}
  \]</span></li>
</ul></li>
</ul>
<h3 id="最佳译码规则">最佳译码规则</h3>
<ul>
<li><p>最佳译码就是使平均错误概率最小 <span class="math display">\[P_e=\sum_{j = 1}^{m}p(y_j)p(e|y_j)\]</span></p>
<p>只需使 <span class="math inline">\(p(e|y_j)\)</span> 最小（<span class="math inline">\(j = 1, 2, \cdots, m\)</span>），而 <span class="math inline">\(p(e|y_j)=1 - p(x_i|y_j)=1 -
p(F(y_j)|y_j)\)</span>。</p>
<p>因此，<strong>最佳译码</strong>规则 <span class="math inline">\(F(y_j)=x^*\)</span>，满足 <span class="math display">\[p(x^*|y_j) \geq p(x_i|y_j),\quad i = 1, 2,
\cdots, n\]</span></p></li>
</ul>
<h4 id="最大后验概率译码">最大后验概率译码</h4>
<ul>
<li>最大后验概率译码满足最佳译码规则：<span class="math display">\[x^*=\arg\max_{1\leq i\leq
n}p(x_i|y_j)\]</span></li>
<li><span class="math display">\[
  F:\left\{
  \begin{array}{l}
  F(b_j)=a_j^*\in A, b_j\in B\\
  P(a_j^*|b_j)\geq P(a_i|b_j), a_i\in A
  \end{array}
  \right.
  \]</span></li>
</ul>
<h4 id="最大联合概率译码">最大联合概率译码</h4>
<ul>
<li><p>根据贝叶斯公式<span class="math inline">\(p(x_i|y_j)=\frac{p(y_j|x_i)p(x_i)}{p(y_j)}\)</span>：
<span class="math display">\[\max_{x_i} p(x_i|y_j) = \max_{x_i}
\frac{p(y_j|x_i)p(x_i)}{p(y_j)}\]</span></p></li>
<li><p>则<strong>最大联合概率译码</strong>为： <span class="math display">\[x^*=\arg\max_{1\leq i\leq
n}p(y_j|x_i)p(x_i)\]</span></p></li>
<li><p><span class="math display">\[
  F:\left\{
  \begin{array}{l}
  F(b_j)=a_j^*\in A, b_j\in B\\
  P(a_j^*, b_j)\geq P(a_i, b_j), a_i\in A
  \end{array}
  \right.
  \]</span></p></li>
</ul>
<h4 id="最大似然译码">最大似然译码</h4>
<ul>
<li><p>当<span class="math inline">\(p(x_i)=\frac{1}{n}\)</span>时，即<strong>信源符号等概率分布时</strong>，有<strong>最大似然译码</strong>：
<span class="math display">\[x^*=\arg\max_{1\leq i\leq
n}p(y_j|x_i)\]</span></p></li>
<li><p><span class="math display">\[
  F:\left\{
  \begin{array}{l}
  F(b_j)=a_j^*\in A, b_j\in B\\
  P(b_j|a_j^*)\geq P(b_j|a_i), a_i\in A
  \end{array}
  \right.
  \]</span></p></li>
<li><p><strong>示例</strong>：已知转移概率矩阵<span class="math inline">\(P =
      \begin{bmatrix}
      \frac{1}{2}&amp;\frac{1}{3}&amp;\frac{1}{6}\\
      \frac{1}{6}&amp;\frac{1}{2}&amp;\frac{1}{3}\\
      \frac{1}{3}&amp;\frac{1}{6}&amp;\frac{1}{2}
      \end{bmatrix}\)</span>，且<span class="math inline">\(p(x_1)=p(x_2)=p(x_3)=\frac{1}{3}\)</span>，则：</p>
<ul>
<li><span class="math inline">\(F(y_1)=\arg\max(p(y_1|x_1),p(y_1|x_2),p(y_1|x_3))
= x_1\)</span></li>
<li><span class="math inline">\(F(y_2)=\arg\max(\frac{1}{3},\frac{1}{2},\frac{1}{6})
= x_2\)</span></li>
<li><span class="math inline">\(F(y_3)= x_3\)</span></li>
<li><strong>译码规则A</strong>：<span class="math inline">\(\begin{cases}F(y_1)=x_1\\F(y_2)=x_2\\F(y_3)=x_3\end{cases}\)</span>，为最佳译码规则
此时<span class="math inline">\(P_e=\frac{1}{3}(\frac{1}{3}+\frac{1}{6}+\frac{1}{3}+\frac{1}{6}+\frac{1}{3}+\frac{1}{6})=\frac{1}{2}\)</span></li>
<li><strong>译码规则B</strong>：<span class="math inline">\(\begin{cases}F(y_1)=x_1\\F(y_2)=x_3\\F(y_3)=x_2\end{cases}\)</span>
此时<span class="math inline">\(P_e=\frac{1}{3}(\frac{1}{6}+\frac{1}{3}+\frac{1}{3}+\frac{1}{2}+\frac{1}{6}+\frac{1}{2})=\frac{2}{3}\)</span></li>
<li><strong>结论：最佳译码规则的错误概率最小</strong></li>
</ul></li>
</ul>
<h4 id="最小汉明距离译码">最小汉明距离译码</h4>
<ul>
<li><span class="math display">\[\hat{C}_i=\arg\max_{1\leq i\leq
M}p(\vec{r_{}}|\vec{C_{0}})p(\vec{C_{0}}),\quad M = q^k\]</span></li>
<li>在二进制对称信道（BSC）中：
<ul>
<li><span class="math inline">\(p(\vec{r_{}}|\vec{C_{0}})=\prod_{j =
1}^{n}p(r_j|c_{ij})\)</span> ，且 <span class="math inline">\(p(r_j|c_{ij}) =
  \begin{cases}
  p, &amp; c_{ij} \neq r_j \\
  1 - p, &amp; c_{ij} = r_j
  \end{cases}\)</span>，其中<span class="math inline">\(p=P_e&lt;\frac{1}{2}\)</span>。</li>
<li>进一步推导可得<span class="math display">\[p(\vec{r_{}}|\vec{C_{0}})=\prod_{j =
1}^{n}p(r_j|c_{ij})=p^d(1 - p)^{n - d}=(\frac{p}{1 - p})^d(1 -
p)^n\]</span></li>
<li>其中 <span class="math display">\[d =
dis(\vec{r_{}},\vec{C_{0}})=w(\vec{r_{}}\oplus\vec{C_{0}})=\sum_{j =
1}^{n}r_j\oplus c_{ij}\]</span> 即 <span class="math inline">\(\vec{r_{}}\)</span> 与 <span class="math inline">\(\vec{C_{0}}\)</span> 的汉明距离。</li>
<li>由于 <span class="math inline">\(\frac{p}{1 - p} \leq 1\)</span>
，<span class="math inline">\((1 - p)^n\)</span> 是常数，所以 <span class="math inline">\(d\)</span> 越大，<span class="math inline">\(p(\vec{r_{}}|\vec{C_{0}})\)</span> 越小。求 <span class="math inline">\(\max p(\vec{r_{}}|\vec{C_{0}})\)</span>
的问题就转化成求最小汉明距离问题。</li>
</ul></li>
</ul>
<h3 id="译码错误与信道条件的关系">译码错误与信道条件的关系</h3>
<ul>
<li><p>译码时发生的错误是由信道中噪声引起的，错误概率 <span class="math inline">\(P_e\)</span> 与信道疑义度 <span class="math inline">\(H(X|Y)\)</span>
满足以下关系（<strong>费诺不等式</strong>）： <span class="math display">\[H(X|Y) \leq H(P_e) + P_e \log (n -
1)\]</span></p></li>
<li><p><strong>证明</strong>： <span class="math display">\[
  \begin{align*}
  右式=&amp;H(P_e, 1 - P_e) + P_e \log (n - 1)\\
  =&amp;P_e \log \frac{1}{P_e} + (1 - P_e) \log \frac{1}{1 - P_e} + P_e
\log (n - 1)\\
  =&amp;\sum_{Y, X - X^*} p(x, y) \log \frac{n - 1}{P_e} + \sum_{Y}
p(x^*, y) \log \frac{1}{1 - P_e}
  \end{align*}
  \]</span></p>
<p><span class="math display">\[
  \begin{align*}
  左式=&amp;H(X|Y)\\
  =&amp;\sum_{x, y} p(x, y) \log \frac{1}{p(x|y)}\\
  =&amp;\sum_{Y, X - X^*} p(x, y) \log \frac{1}{p(x|y)} + \sum_{Y}
p(x^*, y) \log \frac{1}{p(x^*|y)}
  \end{align*}
  \]</span></p>
<p>因此： <span class="math display">\[
  \begin{align*}
  &amp;H(X|Y) - H(P_e) - P_e \log (n - 1)\\
  =&amp;\sum_{Y, X - X^*} p(x, y) \log \frac{P_e}{(n - 1) p(x|y)} +
\sum_{Y} p(x^*, y) \log \frac{1 - P_e}{p(x^*|y)}\\
  \leq&amp;\sum_{Y, X - X^*} p(x, y) \left[\frac{P_e}{(n - 1) p(x|y)} -
1\right] + \sum_{Y} p(x^*, y) \left[\frac{1 - P_e}{p(x^*|y)} -
1\right]\\
  &amp;(利用\log x \leq x - 1放缩)\\
  =&amp;\frac{P_e}{n - 1} \underbrace{\sum_{Y, X - X^*} p(y)}_{= n - 1}
- \underbrace{\sum_{Y, X - X^*} p(x, y)}_{= P_e} + (1 - P_e) \sum_{Y}
p(y) - (1 - P_e)\\
  =&amp;P_e - P_e + (1 - P_e) - (1 - P_e)\\
  =&amp;0
  \end{align*}
  \]</span></p>
<p>由此可得： <span class="math display">\[H(X|Y) \leq H(P_e) + P_e \log
(n - 1)\]</span></p>
<p><span class="math display">\[P_e \geq \frac{H(X|Y) - 1}{\log (n -
1)}\]</span></p></li>
</ul>
<h2 id="信道编码定理-2">信道编码定理</h2>
<p><img src="image-54.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<h3 id="错误概率与编码方法">错误概率与编码方法</h3>
<ul>
<li>转移概率如图：<img src="image-55.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>采用<strong>简单重复编码</strong>，<span class="math inline">\(k =
1\)</span> ，<span class="math inline">\(n = 3\)</span> ，则<span class="math inline">\(0\rightarrow000\)</span>（<span class="math inline">\(\vec{C_{1}}\)</span>），<span class="math inline">\(1\rightarrow111\)</span>（<span class="math inline">\(\vec{C_{2}}\)</span>）</li>
<li>已知信道转移概率 <span class="math inline">\(p = 0.01\)</span>
，<span class="math inline">\(\overline{p}=1-p=0.99\)</span>
，转移概率矩阵：<img src="image-56.webp" srcset="/img/loading/loading3.gif" lazyload> <!-- $$P =\begin{bmatrix}
      & 000(r_1)  & 001(r_2)  & 010(r_3)  & 011(r_4)  & 100(r_5)  & 101(r_6)  & 110(r_7)  & 111(r_8)\\
  000 & (1-p)^3   & (1-p)^2p  & (1-p)^2p  & p^2(1-p)  & (1-p)^2p  & p^2(1-p)  & p^2(1-p)  & p^3\\
  111 & p^3       & p^2(1-p)  & p^2(1-p)  & (1-p)^2p  & p^2(1-p)  & (1-p)^2p  & (1-p)^2p  & (1-p)^3
  \end{bmatrix}$$ --></li>
<li>译码规则为 <span class="math inline">\(F(\vec{r_{1}})=\vec{C_{1}}\)</span> ，<span class="math inline">\(F(\vec{r_{2}})=\vec{C_{1}}\)</span> ，<span class="math inline">\(F(\vec{r_{3}})=\vec{C_{1}}\)</span> ，<span class="math inline">\(F(\vec{r_{4}})=\vec{C_{2}}\)</span> ，<span class="math inline">\(F(\vec{r_{5}})=\vec{C_{1}}\)</span> ，<span class="math inline">\(F(\vec{r_{6}})=\vec{C_{2}}\)</span> ，<span class="math inline">\(F(\vec{r_{7}})=\vec{C_{2}}\)</span> ，<span class="math inline">\(F(\vec{r_{8}})=\vec{C_{2}}\)</span> 。</li>
<li>错误概率 <span class="math display">\[P_e=\frac{1}{2}[p^3 + p^2(1 -
p)+(1 - p)p^2 + p^2(1 - p)+p(1 - p)^2 + p^2(1 - p)+p(1 - p)^2 +
p^3]\approx3\times10^{-4}\]</span></li>
<li>增大 <span class="math inline">\(n\)</span> ，会继续降低平均错误概率
<span class="math inline">\(P_e\)</span> ：
<ul>
<li><span class="math inline">\(n = 1\)</span> ，<span class="math inline">\(P_e = 0.01\)</span> ；</li>
<li><span class="math inline">\(n = 3\)</span> ，<span class="math inline">\(P_e\approx3\times10^{-4}\)</span> ；</li>
<li><span class="math inline">\(n = 5\)</span> ，<span class="math inline">\(P_e\approx10^{-5}\)</span> ；</li>
<li><span class="math inline">\(n = 6\)</span> ，<span class="math inline">\(P_e\approx4\times10^{-7}\)</span> ；</li>
<li><span class="math inline">\(n = 9\)</span> ，<span class="math inline">\(P_e\approx10^{-8}\)</span> ；</li>
<li><span class="math inline">\(n = 11\)</span> ，<span class="math inline">\(P_e\approx5\times10^{-10}\)</span> 。</li>
</ul></li>
<li>信息传输率 <span class="math inline">\(R=\frac{H(X)}{n}=\frac{\log
M}{n}=\frac{k}{n}\text{ bit/符号}\)</span> 。随着 <span class="math inline">\(n\)</span>
增大，信息传输率减小。思考是否能找到一种编码方法，使 <span class="math inline">\(P_e\)</span> 充分小，且 <span class="math inline">\(R\)</span> 维持在一定水平？</li>
</ul>
<h3 id="有噪信道编码定理香农第二定理">有噪信道编码定理（香农第二定理）</h3>
<h4 id="信道编码正定理">信道编码正定理</h4>
<ul>
<li><strong>定理</strong>：设有一离散无记忆平稳信道，其信道容量为 <span class="math inline">\(C\)</span> ，只要待传送的信息率 <span class="math inline">\(R &lt; C\)</span> ，则存在一种编码，当输入长度
<span class="math inline">\(n\)</span>
足够大时，译码错误概率任意小。</li>
<li><strong>证明</strong>：
<ul>
<li><p>消息序列长度为 <span class="math inline">\(k\)</span> ，个数为
<span class="math inline">\(M = 2^k\)</span> ，码长为 <span class="math inline">\(n\)</span> 。记信息传输率 <span class="math inline">\(R=\frac{\log M}{n}=\frac{\log
2^k}{n}=\frac{k}{n}=C - \varepsilon\)</span> （<span class="math inline">\(\varepsilon&gt;0\)</span>），则 <span class="math inline">\(k = n(C - \varepsilon)\)</span> ，<span class="math inline">\(M = 2^{n(C -
\varepsilon)}\)</span>。<strong>只需证当 <span class="math inline">\(n\to\infty\)</span> 时，可使 <span class="math inline">\(P_e\to0\)</span>。</strong></p></li>
<li><p><strong>编码</strong>：从 <span class="math inline">\(2^n\)</span> 个矢量集中找出 <span class="math inline">\(2^{n(C - \varepsilon)}\)</span>
个码字组成一组码。</p></li>
<li><p><strong>BSC信道</strong>：错误概率 <span class="math inline">\(p&lt;\frac{1}{2}\)</span> ，信道容量 <span class="math inline">\(C = 1 - H(p)\)</span> 。</p></li>
<li><p>设发送码字 <span class="math inline">\(\vec{C_{0}}\)</span>
，接收到 <span class="math inline">\(\vec{r_{}}\)</span> ，<span class="math inline">\(\vec{C_{0}}\)</span> 与 <span class="math inline">\(\vec{r_{}}\)</span> 之间的平均汉明距离为 <span class="math inline">\(np\)</span> 。</p></li>
<li><p><strong>译码方法</strong>：以 <span class="math inline">\(\vec{r_{}}\)</span> 为球心，以 <span class="math inline">\(np\)</span> 为半径的球体内寻找码字 <span class="math inline">\(\vec{C_{0}}\)</span>
。为保证译码可靠，将球体稍微扩大，令半径为 <span class="math inline">\(n(p+\varepsilon)=np_{\varepsilon}\)</span> ，<span class="math inline">\(\varepsilon&gt;0\)</span> 任意小，用 <span class="math inline">\(S(np_{\varepsilon})\)</span>
表示这个球体。如果球体内只有一个唯一的码字，则判定这个码字为发送的码字
<span class="math inline">\(\vec{C_{0}}\)</span> 。</p></li>
<li><p><strong>译码错误概率 <span class="math inline">\(P_e\)</span>
表达式</strong>： <span class="math display">\[
  \begin{align*}
  P_e &amp;= P\{\vec{C_{0}}\notin
S(np_{\varepsilon})\}+P\{\vec{C_{0}}\in S(np_{\varepsilon})\}\cdot
P\{\text{找到一个其他码字}\in S(np_{\varepsilon})\}\\
  &amp;\leq P\{\vec{C_{0}}\notin
S(np_{\varepsilon})\}+P\{\text{找到一个其他码字}\in
S(np_{\varepsilon})\}
  \end{align*}
  \]</span></p></li>
<li><p>根据大数定理，<span class="math inline">\(\vec{C_{0}}\)</span> 与
<span class="math inline">\(\vec{r_{}}\)</span> 之间的汉明距离（即 <span class="math inline">\(\vec{C_{0}}\)</span>
在信道传输中错误比特数）超过平均值 <span class="math inline">\(n(p +
\varepsilon)\)</span> 的概率很小。因此当 <span class="math inline">\(n\)</span> 足够大时： <span class="math display">\[P\{\vec{C_{0}}\notin S(np_{\varepsilon})\} &lt;
\delta\]</span></p>
<p><span class="math display">\[
  \begin{align*}
  P\{\text{至少有一个其他码字} \in S(np_{\varepsilon})\} &amp;\leq
\sum_{\vec{C_{i}} \neq \vec{C_{0}}} P\{\vec{C_{i}} \in
S(np_{\varepsilon})\} \\
  &amp;\leq (M - 1)P\{\vec{C_{*}} \in S(np_{\varepsilon})\}
  \end{align*}
  \]</span> 其中 <span class="math inline">\(P\{\vec{C_{i}} \in
S(np_{\varepsilon})\} = \max_{\vec{C_{i}} \neq \vec{C_{0}}}
P\{\vec{C_{i}} \in S(np_{\varepsilon})\}\)</span> 。</p></li>
<li><p>由此可得： <span class="math display">\[P_e \leq \delta + (M -
1)P\{\vec{C_{*}} \in S(np_{\varepsilon})\}\]</span> 其中<span class="math inline">\(\vec{C_{*}} \neq \vec{C_{0}}\)</span>，<span class="math inline">\(\vec{C_{*}}\)</span> 为与 <span class="math inline">\(\vec{C_{0}}\)</span> 距离最近的码字
右式前一项与编码无关，后一项依赖于码字的选择。</p></li>
<li><p><strong>随机编码</strong>：从 <span class="math inline">\(2^n\)</span> 个可能的序列中，随机选取 <span class="math inline">\(M\)</span> 个作为有效码字。每次选一个码字有 <span class="math inline">\(2^n\)</span> 种可能，选 <span class="math inline">\(M\)</span> 个码字，共有 <span class="math inline">\(2^{nM}\)</span> 种不同的编码方式。</p>
<ul>
<li>对于每一种编码方式都有： <span class="math display">\[P_e \leq
\delta + (M - 1)P\{\vec{C_{*}} \in S(np_{\varepsilon})\},\quad
\vec{C_{*}} \neq \vec{C_{0}}\]</span></li>
<li>对 <span class="math inline">\(2^{nM}\)</span> 种可能的编码取平均：
<span class="math display">\[E[P_e] \leq \delta + (M -
1)E[P\{\vec{C_{*}} \in S(np_{\varepsilon})\}]\]</span></li>
<li>于是，所有可能落在 <span class="math inline">\(S(np_{\varepsilon})\)</span> 内的序列总数为：
<span class="math display">\[N(np_{\varepsilon}) = C_{n}^{0} + C_{n}^{1}
+ C_{n}^{2} + \cdots + C_{n}^{np_{\varepsilon}} = \sum_{k =
0}^{np_{\varepsilon}} C_{n}^{k}\]</span></li>
<li>则 <span class="math display">\[E[P\{\vec{C_{*}} \in
S(np_{\varepsilon})\}] = \frac{N(np_{\varepsilon})}{2^{n}} = \sum_{k =
0}^{np_{\varepsilon}} C_{n}^{k}/2^{n}\]</span></li>
</ul></li>
<li><p>引用二项式系数不等式 <span class="math inline">\(\sum_{k =
0}^{np_{\varepsilon}} C_{n}^{k} \leq 2^{nH(p_{\varepsilon})}\)</span>
（<span class="math inline">\(p_{\varepsilon} &lt;
\frac{1}{2}\)</span>），可得：<span class="math display">\[E[P_e] \leq
\delta + M2^{-n[1 - H(p_{\varepsilon})]}\quad (p_{\varepsilon} &lt;
\frac{1}{2})\]</span></p>
<ul>
<li>式中 <span class="math display">\[
  \begin{align*}
  1 - H(p_{\varepsilon}) &amp;= 1 - H(p + \varepsilon)\\
  &amp;= 1 - H(p) + H(p) - H(p + \varepsilon)\\
  &amp;= C - [H(p + \varepsilon) - H(p)]
  \end{align*}
  \]</span></li>
<li>因为 <span class="math inline">\(H(p)\)</span> 是 <span class="math inline">\(p\)</span> 的上凸函数，所以有： <span class="math display">\[
  \begin{align*}
  H(p + \varepsilon) &amp;\leq H(p) + \varepsilon\frac{dH(p)}{dp}\\
  &amp;\leq H(p) + \varepsilon\log\frac{1 - p}{p} \quad (p &lt;
\frac{1}{2}, \log\frac{1 - p}{p} &gt; 0)
  \end{align*}
  \]</span></li>
<li>进而可得 <span class="math inline">\(1 - H(p_{\varepsilon}) \geq C -
\varepsilon\log\frac{1 - p}{p}\)</span> 。</li>
<li>令 <span class="math inline">\(\varepsilon_1 =
\varepsilon\log\frac{1 - p}{p}\)</span> ，<span class="math inline">\(M
= 2^{n(C - \varepsilon_2)}\)</span> ，则： <span class="math display">\[E[P_e] \leq \delta + 2^{n(C - \varepsilon_2) -
n(C - \varepsilon_1)} = \delta + 2^{-n(\varepsilon_2 -
\varepsilon_1)}\]</span></li>
<li>式中 <span class="math inline">\(\varepsilon_2 - \varepsilon_1 =
\varepsilon_2 - \varepsilon\log\frac{1 - p}{p}\)</span> ，只要 <span class="math inline">\(\varepsilon\)</span> 足够小，总能满足 <span class="math inline">\(\varepsilon_2 - \varepsilon_1 &gt; 0\)</span> 。当
<span class="math inline">\(n \to \infty\)</span> 时，<span class="math inline">\(E[P_e] \to 0\)</span> 。</li>
</ul></li>
<li><p>因为 <span class="math inline">\(E[P_e]\)</span> 是对所有 <span class="math inline">\(2^{nM}\)</span>
种随机编码求导的平均值，所以必然存在一些码字错误概率 <span class="math inline">\(&lt; E[P_e]\)</span> 。故必存在一种编码，当 <span class="math inline">\(n \to \infty\)</span> 时， <span class="math inline">\(P_e \to 0\)</span> 。</p></li>
</ul></li>
</ul>
<h4 id="信道编码逆定理">信道编码逆定理</h4>
<ul>
<li><strong>逆定理</strong>：设有一离散无记忆平稳信道，其信道容量为
<span class="math inline">\(C\)</span> 。对于任意 <span class="math inline">\(\varepsilon&gt;0\)</span> ，若选用码字总数 <span class="math inline">\(M = 2^{n(C + \varepsilon)}\)</span>（信息传输率
<span class="math inline">\(R=\frac{\log M}{n}=C +
\varepsilon&gt;C\)</span>），则无论 <span class="math inline">\(n\)</span> 取多大，也找不到一种码，使译码错误概率
<span class="math inline">\(P_e\)</span> 任意小。</li>
<li><strong>证明</strong>：
<ul>
<li>已知信息传输率 <span class="math inline">\(R=\frac{\log M}{n}=C +
\varepsilon\)</span> ，其中 <span class="math inline">\(M = 2^{n(C +
\varepsilon)}\)</span> 为码字总数。</li>
<li>假设 <span class="math inline">\(M\)</span> 个码字等概率分布 <span class="math display">\[H(X^n)=\log M = n(C + \varepsilon)\]</span>
<ul>
<li><span class="math inline">\(n\)</span> 次扩展信道的平均互信息为
<span class="math display">\[I(X^n;Y^n)=H(X^n)-H(X^n|Y^n)\leq
nC\]</span></li>
<li>由此可得 <span class="math display">\[H(X^n|Y^n)\geq H(X^n)-nC =
n\varepsilon\]</span></li>
<li>根据费诺不等式： <span class="math display">\[
  \begin{align*}
  H(X^n|Y^n)&amp;\leq H(P_e,1 - P_e)+P_e\log(M - 1)\\
  &amp;\leq 1+P_e\log M\\
  &amp;=1+P_e n(C + \varepsilon)
  \end{align*}
  \]</span></li>
<li>由于 <span class="math inline">\(n\varepsilon\leq H(X^n|Y^n)\leq
1+P_e n(C + \varepsilon)\)</span> ，所以有： <span class="math display">\[
  \begin{align*}
  n\varepsilon&amp;\leq 1+P_e n(C + \varepsilon)\\
  P_e&amp;\geq\frac{n\varepsilon - 1}{n(C +
\varepsilon)}=\frac{\varepsilon+\frac{1}{n}}{C + \varepsilon}
  \end{align*}
  \]</span></li>
<li>当 <span class="math inline">\(n\to\infty\)</span> 时， <span class="math inline">\(P_e\)</span> 不会趋于 <span class="math inline">\(0\)</span> 。</li>
</ul></li>
<li>因此，当信息传输率 <span class="math inline">\(R&gt;C\)</span>
时，无法完成消息的无错误传输。香农第二定理和它的逆定理表明：在任何信道中，信道容量等于进行可靠传输的最大信息传输率。</li>
</ul></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/SJTU-Notes/" class="category-chain-item">SJTU Notes</a>
  
  
    <span>></span>
    
  <a href="/categories/SJTU-Notes/%E6%95%B0%E5%AD%A6/" class="category-chain-item">数学</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/SJTU/" class="print-no-link">#SJTU</a>
      
        <a href="/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/" class="print-no-link">#信息论</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>信息论基础</div>
      <div>https://youyeyejie.github.io/_posts/信息论基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>youyeyejie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年4月23日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年6月20日</div>
        </div>
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/_posts/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/" title="量子力学">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">量子力学</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/_posts/%E5%8E%9D%E8%A7%92%E5%90%AC%E6%B6%9B/" title="厝角听涛">
                        <span class="hidden-mobile">厝角听涛</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"youyeyejie/youyeyejie.github.io","repo-id":"R_kgDOO-Uo1g","category":"General","category-id":"DIC_kwDOO-Uo1s4Crz5J","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>







  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>
<div class="footer-inner">
    <div class="powered-by">
        <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
        <i class="iconfont icon-love"></i>
        <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
        <i class="iconfont icon-love"></i>
        <a href="https://cloud.umami.is/share/1fs3cnD9TAP8JzML" target="_blank" rel="nofollow noopener"><span>Umami</span></a>
    </div>
    <div class="hitokoto">
        <i class="fas fa-quote-left"></i>
        <a target="_blank" rel="noopener" href="https://developer.hitokoto.cn/" id="hitokoto_text"><span id="hitokoto">且以群词 注解我这座荒山</span></a>
        <script src="/js/Hitokoto.js" defer></script>
    </div>
    <div class="data">
        <span class="total-word-container">
            <i class="fas fa-chart-bar"></i>
            <span id="g-total-word-id"></span>
            字汇长河
        </span>
        &nbsp;
        <span id="total-posts-container">
            <i class="fas fa-file-alt"></i>
            <span id="g-total-posts-id"></span>
            文舟靠岸
        </span>
        &nbsp;
        <span id="busuanzi_container_site_pv">
            <i class="fas fa-eye"></i>
            <span id="busuanzi_value_site_pv">1314</span>
            目光所及
        </span>
        &nbsp;
        <span id="busuanzi_container_site_uv">
            <i class="fas fa-user-friends"></i>
            <span id="busuanzi_value_site_uv">520</span>
            访客驻足
        </span>
    </div>
    <div class="duration">
        <i class="fas fa-calendar"></i>
        <span id="duration-container">人生缓缓&nbsp;自有答案</span>
        <script src="/js/Duration.js"></script>
    </div>
</div>

<link href="/css/Footer.css" type="text/css" rel="stylesheet"/>
<script>
    document.querySelectorAll("[id^='busuanzi_value_']").forEach(element => {
        element.id = element.id.replace("busuanzi_value_", "vercount_value_");
    });
</script>
<script defer src="https://events.vercount.one/js"></script>
<!-- <script src="https://npm.elemecdn.com/penndu@1.0.0/bsz.js" defer></script> -->
<!-- <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script> -->
<!-- <script async src="https://busuanzi.icodeq.com/busuanzi.pure.mini.js"></script> -->
<!-- <script async src="https://busuanzi.sukap.cn/busuanzi.pure.mini.js"></script> -->
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/busuanzi.pure.mini.js" ></script>




  
<script src="/js/DynamicLine.js"></script>
<script src="/js/LinkCard.js"></script>
<script src="/js/RandomBanner.js"></script>
<script src="/js/Background.js"></script>
<script src="/js/ScrollAnimation.js"></script>
<script src="/js/Sidebar.js"></script>
<script src="/js/TabDisplay.js"></script>
<script src="/js/Umami.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  <script type="text/javascript">
  document.getElementById("g-total-word-id").innerHTML = "492k";
  document.getElementById('g-total-posts-id').textContent ="52";
</script>

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start -->
<script src="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.js"></script>

  <script>
  const CODE_CONFIG = {
    beautify: true,
    highlightCopy: true,
    highlightLang: true,
    highlightHeightLimit: 360,
    isHighlightShrink: false,
    copy: {
      success: 'Copy Success',
      error: 'Copy Error',
      noSupport: 'Browser Not Support',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body>
</html>
