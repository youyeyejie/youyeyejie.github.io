

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><!-- hexo injector head_begin start --><meta name="msvalidate.01" content="DF9F232801BA9D0CABB002E4774A3228" />
<meta name="google-site-verification" content="vOm5Zs9tuUlEh-wVBlpvs_spnOou-q2CoTiFQ1ZV1h4" />
<script defer src="https://cloud.umami.is/script.js" data-website-id="0369421f-4354-4d7b-99c7-ae077c591b4f"></script>
<!-- hexo injector head_begin end -->
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar/avatar2.webp">
  <link rel="icon" href="/img/avatar/avatar2.webp">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="youyeyejie">
  <meta name="keywords" content="yyyj,YYYJ,youyeyejie,有野野芥">
  
    <meta name="description" content="NIS3365 现代密码学 笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="现代密码学">
<meta property="og:url" content="https://youyeyejie.github.io/_posts/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/index.html">
<meta property="og:site_name" content="有野野芥的博客">
<meta property="og:description" content="NIS3365 现代密码学 笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youyeyejie.github.io/img/cover/nis3365.webp">
<meta property="article:published_time" content="2025-11-05T02:05:07.000Z">
<meta property="article:modified_time" content="2025-11-13T11:47:58.835Z">
<meta property="article:author" content="youyeyejie">
<meta property="article:tag" content="SJTU">
<meta property="article:tag" content="现代密码学">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://youyeyejie.github.io/img/cover/nis3365.webp">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>现代密码学 - 有野野芥的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">
<link rel="stylesheet" href="//lib.baomitu.com/font-awesome/6.1.2/css/all.min.css">


<link  rel="stylesheet" href="/css/main.css" />




  
<link rel="stylesheet" href="/css/Background.css">
<link rel="stylesheet" href="/css/CodeBlock.css">
<link rel="stylesheet" href="/css/CodeInLine.css">
<link rel="stylesheet" href="/css/Crypto.css">
<link rel="stylesheet" href="/css/Gallery.css">
<link rel="stylesheet" href="/css/IndexImgHover.css">
<link rel="stylesheet" href="/css/LinkCard.css">
<link rel="stylesheet" href="/css/ScrollAnimation.css">
<link rel="stylesheet" href="/css/ScrollBar.css">
<link rel="stylesheet" href="/css/Sidebar.css">
<link rel="stylesheet" href="/css/StrongInDark.css">
<link rel="stylesheet" href="/css/TitleGradient.css">
<link rel="stylesheet" href="/css/Tooltip.css">
<link rel="stylesheet" href="/css/UnifyImgWidth.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"youyeyejie.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":false,"default":"TEXT"},"copy_btn":false,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading/loading3.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style>
    <style>
    .code-expand-btn:not(.expand-done) ~ div.codeblock,
    .code-expand-btn:not(.expand-done) ~ * div.codeblock {
      overflow: hidden;
      height: 360px;
    }
    </style>
  <!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body><!-- hexo injector body_begin start --><div id="web_bg"></div><div id="tooltip" class="tooltip"></div><!-- hexo injector body_begin end -->
  <div id="loader-container"> 
    <div id="loader" class="loader"></div>
    <div class="loader-inner">
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
    </div>
</div>

<script src="/js/RainbowLoading.js" type="text/javascript"></script>
<link href="/css/RainbowLoading.css" type="text/css" rel="stylesheet"/><div id="rightmenu-wrapper">
  <ul class="list-v rightmenu" id="rightmenu-content">
	    <li class="navigation menuNavigation-Content">
            <a class="nav icon-only fix-cursor-default" aria-label="back" onclick="history.back()"><i class="fa-solid fa-chevron-left"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="forward" onclick="history.forward()"><i class="fa-solid fa-chevron-right"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="reload" onclick="window.location.reload()"><i class="fa-solid fa-rotate-right"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="top" onclick="scrollToTopSmooth();"><i class="fa-solid fa-chevron-up"></i></a>
            <a class="nav icon-only fix-cursor-default" aria-label="bottom" onclick="scrollToBottomSmooth();"><i class="fa-solid fa-chevron-down"></i></a>
	    </li>

        <hr class="menuLoad-Content" style="display: block;" id="top-line">

        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="copyLink();">
                <span>
                    <i class="fa-solid fa-link"></i>
                    复制链接
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="copy-selected-text" hidden>
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="copySelectedText();">
                <span>
                    <i class="fa-solid fa-copy"></i>
                    &nbsp;复制选中
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="search-selected-text-BING" hidden>
            <a class="vlts-menu fix-cursor-default" target="_blank" onclick="searchSelectedTextBing();">
                <span>
                    <i class="fa-solid fa-magnifying-glass-arrow-right"></i>
                    &nbsp;必应搜索
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="go-to-link" hidden>
            <a class="vlts-menu fix-cursor-default" target="_blank">
                <span>
                    <i class="fa-solid fa-arrow-up-right-from-square" style="margin-right: 1px;"></i>
                    &nbsp;打开链接
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="download-image" hidden>
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="downloadImage();">
                <span>
                    <i class="fa-solid fa-image"></i>
                    &nbsp;下载图片
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;" id="copy-image-link" hidden>
            <a class="vlts-menu fix-cursor-default" target="_self" onclick="copyImageLink();">
                <span>
                    <i class="fa-solid fa-link"></i>
                    复制图片链接
                </span>
            </a>
        </li>

		<hr class="menuLoad-Content" style="display: block;">

        <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" onclick="RandomGo()">
		        <span>
			        <i class="fa-solid fa-paper-plane"></i>
                    &nbsp;随便看看
		        </span>
		    </a>
	    </li>
	    <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
		        <span>
			        <i class="fa-solid fa-magnifying-glass"></i>
                    &nbsp;站内搜索
		        </span>
		    </a>
	    </li>
        <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" href="/categories/">
		        <span>
			        <i class="iconfont icon-category-fill"></i>
                    &nbsp;博客分类
		        </span>
		    </a>
	    </li>
        <li class="menuLoad-Content" style="display: block;">
		    <a class="vlts-menu fix-cursor-default" target="_self" href="/tags/">
		        <span>
			        <i class="fa-solid fa-tags"></i>
                    &nbsp;文章标签
		        </span>
		    </a>
	    </li>
        
	    <hr class="menuLoad-Content" style="display: block;">

        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="toggle-color-mode" target="_self" onclick="toggleColorMode();">
                <span>
                    <i id="toggle-color-mode-icon" class="fa-solid fa-circle-half-stroke"></i>
                    &nbsp;切换昼夜
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="random-change-background" target="_self" onclick="randomChangeBackground();">
                <span style="margin-left: 1px;">
                    <i id="random-change-background-icon" class="fa-solid fa-image"></i>
                    &nbsp;切换背景
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="toggle-background-mode" target="_self" onclick="toggleBackgroundMode();">
                <span>
                    <i id="toggle-background-mode-icon" class="fa-solid fa-toggle-on" style="margin-right: -1px;"></i>
                    &nbsp;全屏背景
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="toggle-reading-mode" target="_self" onclick="toggleReadingMode();">
                <span>
                    <i id="toggle-reading-mode-icon" class="fa-solid fa-toggle-off" style="margin-right: -1px;"></i>
                    &nbsp;阅读模式
                </span>
            </a>
        </li>
        <li class="menuLoad-Content" style="display: block;">
            <a class="vlts-menu fix-cursor-default" id="toggle-tab-display" target="_self" onclick="toggleTabDisplay();">
                <span>
                    <i id="toggle-tab-display-icon" class="fa-solid fa-toggle-on" style="margin-right: -1px;"></i>
                    &nbsp;自定义标签
                </span>
            </a>
        </li>
    </ul>
</div>


<script src="/js/RightMenu.js" type="text/javascript"></script>
<link href="/css/RightMenu.css" type="text/css" rel="stylesheet"/>

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <!-- <strong>YYYJ&#39;s Blog</strong> -->
       <strong class="navbar-title">YYYJ&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://www.travellings.cn/go-by-clouds.html" target="_self">
                <i class="fas fa-train-subway"></i>
                <span>开往</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="fa-solid fa-folder-open"></i>
                <span>更多</span>
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/" target="_self">
                    <i class="iconfont icon-archive-fill"></i>
                    <span>归档</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/" target="_self">
                    <i class="fa-solid fa-tags"></i>
                    <span>标签</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/links/" target="_self">
                    <i class="iconfont icon-link-fill"></i>
                    <span>友链</span>
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/DayDream-Gallery/" target="_self">
                    <i class="fas fa-images"></i>
                    <span>图集</span>
                  </a>
                
              </div>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner/random.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="现代密码学"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        youyeyejie
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-11-05 10:05" pubdate>
          2025年11月5日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          30k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          250 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="SJTU Notes"
        id="heading-23fc8849f7fe9b9a570be52f7807b4ac" role="tab" data-toggle="collapse" href="#collapse-23fc8849f7fe9b9a570be52f7807b4ac"
        aria-expanded="true"
      >
        SJTU Notes
        <span class="list-group-count">(23)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-23fc8849f7fe9b9a570be52f7807b4ac"
           role="tabpanel" aria-labelledby="heading-23fc8849f7fe9b9a570be52f7807b4ac">
        
        
          
          
  <div class="category-post-list">
    
    
  </div>

          
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="信安"
        id="heading-cffe32285a0c065bb2a100ac3411f2b7" role="tab" data-toggle="collapse" href="#collapse-cffe32285a0c065bb2a100ac3411f2b7"
        aria-expanded="true"
      >
        信安
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-cffe32285a0c065bb2a100ac3411f2b7"
           role="tabpanel" aria-labelledby="heading-cffe32285a0c065bb2a100ac3411f2b7">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/" title="网络空间安全导论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">网络空间安全导论</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/" title="抽象代数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">抽象代数</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/" title="现代密码学"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">现代密码学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" title="系统安全"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">系统安全</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="其他"
        id="heading-0d98c74797e49d00bcc4c17c9d557a2b" role="tab" data-toggle="collapse" href="#collapse-0d98c74797e49d00bcc4c17c9d557a2b"
        aria-expanded="false"
      >
        其他
        <span class="list-group-count">(3)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-0d98c74797e49d00bcc4c17c9d557a2b"
           role="tabpanel" aria-labelledby="heading-0d98c74797e49d00bcc4c17c9d557a2b">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E5%86%9B%E4%BA%8B%E7%90%86%E8%AE%BA/" title="军事理论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">军事理论</span>
        </a>
      
    
      
      
        <a href="/_posts/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/" title="量子力学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">量子力学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%95%B0%E5%AD%A6%E5%8F%B2/" title="数学史"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数学史</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="数学"
        id="heading-6e65831863dbf272b7a65cd8df1a440d" role="tab" data-toggle="collapse" href="#collapse-6e65831863dbf272b7a65cd8df1a440d"
        aria-expanded="false"
      >
        数学
        <span class="list-group-count">(4)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-6e65831863dbf272b7a65cd8df1a440d"
           role="tabpanel" aria-labelledby="heading-6e65831863dbf272b7a65cd8df1a440d">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/" title="概率统计"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">概率统计</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">离散数学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="信息论基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">信息论基础</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/" title="抽象代数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">抽象代数</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="红课"
        id="heading-d8a06b9d7f3a9a1c8566414f651abd41" role="tab" data-toggle="collapse" href="#collapse-d8a06b9d7f3a9a1c8566414f651abd41"
        aria-expanded="false"
      >
        红课
        <span class="list-group-count">(5)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-d8a06b9d7f3a9a1c8566414f651abd41"
           role="tabpanel" aria-labelledby="heading-d8a06b9d7f3a9a1c8566414f651abd41">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/" title="中国近现代史纲要"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">中国近现代史纲要</span>
        </a>
      
    
      
      
        <a href="/_posts/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3%E6%A6%82%E8%AE%BA/" title="习近平新时代中国特色社会主义思想概论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">习近平新时代中国特色社会主义思想概论</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/" title="思想道德与法治"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">思想道德与法治</span>
        </a>
      
    
      
      
        <a href="/_posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="马克思主义基本原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">马克思主义基本原理</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%AF%9B%E6%B3%BD%E4%B8%9C%E6%80%9D%E6%83%B3%E5%92%8C%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA%E4%BD%93%E7%B3%BB%E6%A6%82%E8%AE%BA/" title="毛泽东思想和中国特色社会主义理论体系概论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">毛泽东思想和中国特色社会主义理论体系概论</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
    
    
    
    <div class="category-sub row nomargin-x">
      <a class="category-subitem collapsed
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="计科"
        id="heading-d693442450db119d90f9261fa53eb2f7" role="tab" data-toggle="collapse" href="#collapse-d693442450db119d90f9261fa53eb2f7"
        aria-expanded="false"
      >
        计科
        <span class="list-group-count">(10)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse " id="collapse-d693442450db119d90f9261fa53eb2f7"
           role="tabpanel" aria-labelledby="heading-d693442450db119d90f9261fa53eb2f7">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/_posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数据结构</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">离散数学</span>
        </a>
      
    
      
      
        <a href="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" title="计算机组成与系统结构"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">计算机组成与系统结构</span>
        </a>
      
    
      
      
        <a href="/_posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="信息论基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">信息论基础</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">编译原理</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="操作系统原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统原理</span>
        </a>
      
    
      
      
        <a href="/_posts/%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E5%8F%8A%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B/" title="安全模型开发及安全编程"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">安全模型开发及安全编程</span>
        </a>
      
    
      
      
        <a href="/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E5%85%A8/" title="数据库原理及安全"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数据库原理及安全</span>
        </a>
      
    
      
      
        <a href="/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C/" title="计算机通信网络"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">计算机通信网络</span>
        </a>
      
    
      
      
        <a href="/_posts/%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/" title="算法计算复杂度分析"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">算法计算复杂度分析</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">现代密码学</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>本笔记基于上海交通大学 <em>邱卫东老师</em> 2025-2026
学年秋季学期教学内容进行整理，部分图片来自邱老师的课件，若有侵权请联系删除。</p>
</blockquote>
<h1 id="密码学与计算机安全">密码学与计算机安全</h1>
<ul>
<li>安全服务要求
<ul>
<li>机密性</li>
<li>完整性</li>
<li>可用性</li>
<li>消息认证(鉴别)</li>
<li>不可否认性</li>
<li>身份鉴别</li>
<li>访问控制</li>
<li>有效性</li>
</ul></li>
<li>基本术语
<ul>
<li>密码技术（Cryptography）：把可理解的消息变换成不可理解消息，同时又可恢复原消息的方法和原理的一门科学或艺术。</li>
<li>明文（plaintext）：变换前的原始消息</li>
<li>密文（ciphertext）：变换后的消息</li>
<li>密码算法（cipher）：用于改变消息的替换或变换算法</li>
<li>密钥（key）：用于密码变换的，只有发送者或接收者拥有的秘密消息</li>
<li>编码（encipher /encode）：把明文变为密文的过程</li>
<li>译码（decipher /decode）：把密文变为明文的过程</li>
<li>密码分析（cryptanalysis
/codebreaking）：在没有密钥的情况下，破解密文的原理与方法</li>
<li>密码学（cryptology）：包括加密理论与解密理论的学科</li>
</ul></li>
<li>密码学算法分类:
<ul>
<li>私钥加密算法(private-key encryption
algorithms)/对称加密算法(symmetric encryption algorithms)
<ul>
<li>分组密码</li>
<li>流密码/序列密码</li>
</ul></li>
<li>公钥加密算法(public-key encryption
algorithms)/非对称加密算法(asymmetric encryption algorithms)</li>
<li>数字签名算法(digital signature algorithms)</li>
<li>哈希函数（hash functions）</li>
</ul></li>
<li>密码分析学
<ul>
<li>唯密文攻击 (ciphertext only)
<ul>
<li>只知道算法与一些密文</li>
<li>利用统计方法</li>
<li>需要能够识别明文</li>
</ul></li>
<li>已知明文攻击（known plaintext）
<ul>
<li>知道一些明文/密文对</li>
<li>利用已知的明文密文对进行攻击</li>
</ul></li>
<li>选择明文攻击（chosen plaintext）
<ul>
<li>能够选择明文并得到相应的密文</li>
<li>利用算法的结构进行攻击</li>
</ul></li>
<li>选择密文攻击（chosen ciphertext）
<ul>
<li>能够选择密文并得到对应的明文</li>
<li>利用对算法结构的知识进行攻击</li>
</ul></li>
</ul></li>
<li>算法复杂性类型
<ul>
<li>常数级: 复杂性不依赖于 <span class="math inline">\(n\)</span>，用
<span class="math inline">\(O(1)\)</span> 表示</li>
<li>线性复杂度: 复杂度是 <span class="math inline">\(O(n)\)</span></li>
<li>多项式复杂度: 复杂度是 <span class="math inline">\(O(n^k)\)</span>，<span class="math inline">\(k\)</span> 是一常数</li>
<li>指数性复杂度: 复杂度是 <span class="math inline">\(O(cf(n))\)</span>，<span class="math inline">\(c\)</span> 是一常数，<span class="math inline">\(f(n)\)</span> 是指数函数</li>
<li>指数型算法: 复杂度高于任何多项式函数，如 <span class="math inline">\(O(2^n)\)</span>， <span class="math inline">\(O(n!)\)</span>，<span class="math inline">\(O(n^{\log{n}})\)</span> 等</li>
</ul></li>
<li>问题复杂性及其分类
<ul>
<li>P类问题
<ul>
<li>多项式时间内可解的问题</li>
<li>例如：排序、矩阵乘法、最短路径等</li>
</ul></li>
<li>NP类问题
<ul>
<li>多项式时间内可验证的问题</li>
<li>例如：旅行商问题、子集和问题等</li>
</ul></li>
</ul></li>
<li>无条件安全与计算安全
<ul>
<li>无条件安全（unconditional security）
<ul>
<li>即使攻击者拥有无限计算资源，也无法破解密码</li>
<li>例如：一次性密码本(one-time pad)</li>
</ul></li>
<li>计算安全（computational security）
<ul>
<li>在现有计算资源下，破解密码在合理时间内不可行，或者破解密码所需的代价超过了其价值</li>
<li>例如：RSA、AES等现代密码算法</li>
</ul></li>
</ul></li>
</ul>
<h1 id="古典密码算法">古典密码算法</h1>
<h2 id="古典代换密码">古典代换密码</h2>
<h3 id="凯撒密码">凯撒密码</h3>
<ul>
<li>替换方法：每个字母用其后的第三个字母替换
<ul>
<li>例子：<span class="math inline">\(A \to D, B \to E, C \to F, \ldots,
X \to A, Y \to B, Z \to C\)</span></li>
</ul></li>
<li>一般形式：令 <span class="math inline">\(P = C = K =
\mathbb{Z}_{26}\)</span>，对 <span class="math inline">\(0 \leq i &lt;
26\)</span>，任意 <span class="math inline">\(x, y \in
\mathbb{Z}_{26}\)</span> 加密函数为 <span class="math display">\[E(x) =
(x + i) \bmod 26\]</span> 解密函数为 <span class="math display">\[D(y) =
(y - i) \bmod 26\]</span></li>
<li>密钥长度：1（位移量）</li>
<li>密钥空间：25（因为位移26会回到原字母）</li>
<li>缺点：字母频率不变，容易被频率分析法破解</li>
</ul>
<h3 id="混合单表代换密码">混合单表代换密码</h3>
<ul>
<li>替换方法：每个字母用另一个字母替换，但不是简单的位移，每个字母随机映射到另一个字母</li>
<li>一般形式：令 <span class="math inline">\(P = C = K =
\mathbb{Z}_{26}\)</span>，对 <span class="math inline">\(0 \leq i &lt;
26\)</span>，任意 <span class="math inline">\(x, y \in
\mathbb{Z}_{26}\)</span> 加密函数为 <span class="math display">\[E(x) =
(ax + b) \bmod 26\]</span> 解密函数为 <span class="math display">\[D(y)
= a^{-1}(y - b) \bmod 26\]</span> 其中 <span class="math inline">\(a, b
\in \mathbb{Z}_{26}\)</span>，且 <span class="math inline">\(\gcd(a, 26)
= 1\)</span></li>
<li>密钥长度：<span class="math inline">\(26\)</span></li>
<li>密钥空间：<span class="math inline">\(26! \approx
2^{88}\)</span>，比凯撒密码更安全</li>
<li>有多种方法，一种简单方法是写没有重复字母的“密钥字”，其它字母按顺序写在密钥字最后字母后面
<ul>
<li>例如，给定密钥字 “JULIUSCAESAR” ，则映射为： <span class="math display">\[
  \begin{aligned}
  Plain: &amp; \mathtt{ABCDEFGHIJKLMNOPQRSTUVWXYZ} \\
  Cipher: &amp; \mathtt{JULISCAERTVWXYZBDFGHKMNOPQ}
  \end{aligned}
  \]</span></li>
</ul></li>
<li>缺点：字母频率不变，容易被频率分析法破解</li>
</ul>
<h3 id="维吉尼亚密码">维吉尼亚密码</h3>
<ul>
<li>替换方法：使用多个单字母代换表，因此一个字母可以被多个字母代换</li>
<li>一般形式：令 <span class="math inline">\(P = C = K =
\mathbb{Z}_{26}\)</span>，设 <span class="math inline">\(m \in
\mathbb{Z}^+\)</span> 为密钥长度，任意 <span class="math inline">\(x, y
\in \mathbb{Z}_{26}\)</span>，<span class="math inline">\(k = (k_1, k_2,
\ldots, k_m) \in \mathbb{Z}_{26}^m\)</span>，加密函数为 <span class="math display">\[E(x_i) = (x_i + k_{(i \bmod m) + 1}) \bmod
26\]</span> 解密函数为 <span class="math display">\[D(y_i) = (y_i -
k_{(i \bmod m) + 1}) \bmod 26\]</span></li>
<li>密钥长度：<span class="math inline">\(m\)</span></li>
<li>密钥空间：<span class="math inline">\(26^m\)</span>，比混合单表代换密码更安全</li>
<li>例子：明文 “ATTACKATDAWN” ，密钥 “LEMON” ，加密过程如下： <span class="math display">\[
  \begin{aligned}
  Plain:  &amp; \mathtt{A T T A C K A T D A W N} \\
  Key:    &amp; \mathtt{L E M O N L E M O N L E} \\
  Cipher: &amp; \mathtt{L X F O P V E F R N H R}
  \end{aligned}
  \]</span></li>
<li>优点：字母频率被打乱，更难被频率分析法破解</li>
<li>缺点：如果密钥较短，仍然可能被频率分析法破解</li>
</ul>
<h2 id="古典置换密码">古典置换密码</h2>
<p>思想：按一定规则写出明文，按另一规则读出密文。</p>
<h3 id="scytale-密码">Scytale 密码</h3>
<ul>
<li>替换方法：将明文写在一个圆柱体上，然后沿着圆柱体的长度读取密文</li>
<li>密钥是纸条和圆柱的宽度</li>
</ul>
<h3 id="轨道栅栏密码">轨道栅栏密码</h3>
<ul>
<li>替换方法：将明文写在多个“轨道”上，然后按轨道顺序读取密文</li>
<li>例子：明文 “WEAREDISCOVEREDFLEEATONCE” ，轨道数为 3 ，加密过程如下：
<span class="math display">\[
  \begin{aligned}
  &amp;\mathtt{W . . . E . . . C . . . R . . . L . . . T . . . E} \\
  &amp;\mathtt{. E . R . D . S . O . E . E . F . E . A . O . C .} \\
  &amp;\mathtt{. . A . . . I . . . V . . . D . . . E . . . N .}
  \end{aligned}
  \]</span>
<ul>
<li>密文为 “WECRLTEERDSOEEFEAOCAIVDEN”</li>
</ul></li>
</ul>
<h3 id="几何图形密码">几何图形密码</h3>
<ul>
<li>替换方法：以一种形式写下消息，以另一种形式读取消息</li>
<li>例子：以行的形式写下消息，以列的形式读取消息
<ul>
<li>明文 “HELLOTHERE” ，矩阵宽度为 3 ，加密过程如下： <span class="math display">\[
  \begin{aligned}
  &amp;\mathtt{H E L} \\
  &amp;\mathtt{L O T} \\
  &amp;\mathtt{H E R} \\
  &amp;\mathtt{E}
  \end{aligned}
  \]</span>
<ul>
<li>密文为 “HLHEEOELTR”</li>
</ul></li>
</ul></li>
</ul>
<h3 id="行变换密码">行变换密码</h3>
<ul>
<li>替换方法：加密时按行写出明文字母，以写密钥给出的顺序按行写出密文；解密时按行写出密文字母，以读密钥给出的顺序按行写出明文</li>
<li>例子：明文 “HELLOTHERE” ，写密钥为 “1342” ，加密过程如下： <span class="math display">\[
  \begin{aligned}
  &amp;\mathtt{H E L L} \\
  &amp;\mathtt{O T H E} \\
  &amp;\mathtt{R E}
  \end{aligned}
  \]</span>
<ul>
<li>密文为 “HLLEOHETRE”</li>
</ul></li>
<li>例子：密文 “HLLEOHETRE” ，写密钥为 “1423” ，解密过程如下： <span class="math display">\[
  \begin{aligned}
  &amp;\mathtt{H L L E} \\
  &amp;\mathtt{O H E T} \\
  &amp;\mathtt{R E}
  \end{aligned}
  \]</span>
<ul>
<li>明文为 “HELLOTHERE”</li>
</ul></li>
<li>可以用一个英文单词做密钥，指定以字母顺序做为读取或写密文（或明文）</li>
</ul>
<h3 id="列变换密码">列变换密码</h3>
<ul>
<li>替换方法：加密时按列写出明文字母，以写密钥给出的顺序按列写出密文；解密时按列写出密文字母，以读密钥给出的顺序按列写出明文</li>
</ul>
<h2 id="中国古典密码">中国古典密码</h2>
<ul>
<li>藏头诗</li>
<li>反切码</li>
</ul>
<h1 id="序列密码">序列密码</h1>
<ul>
<li>序列密码(stream
cipher)是一种对明文消息流中的每一个符号分别进行加密的对称密钥密码，又称为流密码</li>
<li>流密码和分组密码之间的区别并不是绝对的
<ul>
<li>流密码可以通过使用分组密码的 CFB 模式、OFB 模式或 CTR
模式来构建</li>
<li>在 ECB 或 CBC
下的分组密码，可以视为一种操作于大字符上的流密码。</li>
</ul></li>
</ul>
<h2 id="序列密码概述-stream-cipher">序列密码概述 (Stream Cipher)</h2>
<ul>
<li>定义：也称流密码：将被加密的消息 <span class="math inline">\(m\)</span> 分成连续的符号(一般为比特串)，<span class="math inline">\(m=m_1 m_2 m_3 \cdots\)</span>；然后使用密钥流
<span class="math inline">\(k=k_1 k_2 k_3 \cdots\)</span> 中的第 <span class="math inline">\(i\)</span>个元素 <span class="math inline">\(k_i\)</span> 对 <span class="math inline">\(m\)</span> 的第 <span class="math inline">\(i\)</span> 个元素 <span class="math inline">\(m_i\)</span> 执行加密变换，<span class="math inline">\(i=1,2,3,\cdots\)</span>；所有的加密输出连接在一起就构成了对
<span class="math inline">\(m\)</span> 执行加密后的密文 <span class="math inline">\(c\)</span>。</li>
</ul>
<figure>
<img src="image-25.webp" srcset="/img/loading/loading3.gif" lazyload alt="流密码">
<figcaption aria-hidden="true">流密码</figcaption>
</figure>
<ul>
<li>结构：
<ul>
<li>简单结构： <img src="image-26.webp" srcset="/img/loading/loading3.gif" lazyload alt="流密码结构"></li>
<li>完整结构： <img src="image-27.webp" srcset="/img/loading/loading3.gif" lazyload alt="流密码完整结构"></li>
<li>如何生成一个可以用作密钥流的“随机”比特序列，要求易于使用，但又不能太短以至于不安全</li>
<li>通常加、解密所需要的这种序列是由一个确定性（deterministic）的密钥流生成器（key
generator）产生的，该生成器的输入是一个容易记住的密钥，称之为密钥流生成器的初始密钥或种子（seed）密钥</li>
</ul></li>
<li>安全性：
<ul>
<li>流密码的安全性完全取决于密钥的安全等级</li>
<li>实用的流密码以少量的、一定长度的种子密钥经过逻辑运算产生周期较长、可用于加解密运算的伪随机序列。</li>
</ul></li>
</ul>
<h3 id="同步流密码-synchronous-stream-ciphers">同步流密码 (Synchronous
stream ciphers)</h3>
<figure>
<img src="image-28.webp" srcset="/img/loading/loading3.gif" lazyload alt="同步流密码">
<figcaption aria-hidden="true">同步流密码</figcaption>
</figure>
<ul>
<li>密钥流的产生与明文消息流相互独立</li>
<li>密钥流与明文串无关，所以同步流密码中的每个密文 <span class="math inline">\(c_i\)</span> 不依赖于之前的明文 <span class="math inline">\(m_{i−1}，\cdots，m_1\)</span>。从而，同步流密码的一个重要优点就是无错误传播：在传输期间一个密文字符被改变只影响该符号的恢复，不会对后继的符号产生影响。</li>
</ul>
<h3 id="自同步流密码-self-synchronizing-stream-ciphers">自同步流密码
(Self-synchronizing stream ciphers)</h3>
<figure>
<img src="image-29.webp" srcset="/img/loading/loading3.gif" lazyload alt="自同步流密码">
<figcaption aria-hidden="true">自同步流密码</figcaption>
</figure>
<ul>
<li>密钥流与之前已经产生的若干密文有关 <span class="math display">\[\begin{aligned}
  &amp;\sigma_i=(c_{i-t},c_{i-t+1},\cdots,c_{i-1}) \\
  &amp;k_i=G(\sigma_i,K)\\
  &amp;c_i=E(k_i,m_i)
  \end{aligned}\]</span></li>
</ul>
<h2 id="密钥流的生成方式">密钥流的生成方式</h2>
<ul>
<li>密钥流的生成方法：
<ul>
<li>有多种产生同步密钥流生成器的方法</li>
<li>最普遍的是使用一种称为线性反馈移位寄存器（Linear Feedback Shift
Register，LFSR）
<ul>
<li>LFSR 的结构非常适合硬件实现；</li>
<li>LFSR 的结构便于使用代数方法进行理论分析；</li>
<li>产生的序列的周期可以很大；</li>
<li>产生的序列具有良好的统计特性。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="线性反馈移位寄存器lfsr">线性反馈移位寄存器（LFSR）</h3>
<ul>
<li><p>反馈移位寄存器： <img src="image-30.webp" srcset="/img/loading/loading3.gif" lazyload alt="反馈移位寄存器"></p>
<ul>
<li>上图为一个反馈移位寄存器的流程图，信号从左到右。</li>
<li><span class="math inline">\(a_i\)</span> 表示存储单元，取值为 0 或
1，<span class="math inline">\(a_i\)</span> 的个数 <span class="math inline">\(n\)</span>
称为反馈移位寄存器的<strong>级</strong>。</li>
<li>在某一时刻，这些级的内容构成该反馈移位寄存器的一个<strong>状态</strong>，共有
<span class="math inline">\(2^n\)</span>
个可能的状态，每一个状态对应于与 <span class="math inline">\(\mathbb{F}_2\)</span> 上的一个 <span class="math inline">\(n\)</span> 维向量，用 <span class="math inline">\((a_1,a_2,…,a_n)\)</span> 表示。</li>
<li>函数 <span class="math inline">\(f\)</span> 是一个 <span class="math inline">\(n\)</span>
元布尔函数，称之为<strong>反馈函数</strong>。</li>
</ul></li>
<li><p>线性反馈移位寄存器（LFSR） <img src="image-31.webp" srcset="/img/loading/loading3.gif" lazyload alt="线性反馈移位寄存器"></p>
<ul>
<li>反馈函数 <span class="math inline">\(f\)</span> 是线性的，即 <span class="math display">\[
  f(a_1,a_2,\cdots,a_n)=c_n a_1\oplus c_{n-1} a_2\oplus\cdots\oplus c_1
a_n
  \]</span> 其中 <span class="math inline">\(c_i \in
\mathbb{F}_2\)</span>，<span class="math inline">\(\oplus\)</span>
为模二加法，和乘法均在 <span class="math inline">\(\mathbb{F}_2\)</span>
上进行。</li>
<li>令 <span class="math inline">\(a_i(t)\)</span> 为第 <span class="math inline">\(i\)</span> 级在时刻 <span class="math inline">\(t\)</span> 的内容，则 LFSR 的状态转移可表示为：
<span class="math display">\[
  \begin{aligned}
  &amp;a_i^{(t+1)}=a_{i+1}^{(t)} \\
  &amp;a_n^{(t+1)}=c_n a_1^{(t)}\oplus c_{n-1} a_2^{(t)}\oplus
\cdots\oplus c_1 a_n^{(t)}
  \end{aligned}
  \]</span></li>
<li>则称多项式 <span class="math inline">\(C(x)=1+c_1 x+c_2
x^2+\cdots+c_n x^n\)</span> 为该 LFSR 的
<strong>联接多项式</strong>（connection polynomial）。</li>
<li>线性反馈移位寄存器的状态转移可以用矩阵表示： <span class="math display">\[\begin{bmatrix}
  a_1^{(t+1)}\\
  a_2^{(t+1)}\\
  \vdots\\
  a_n^{(t+1)}
  \end{bmatrix}=
  \begin{bmatrix}
  0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0\\
  0 &amp; 0 &amp; 1 &amp; \cdots &amp; 0\\
  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
  0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1\\
  c_n &amp; c_{n-1} &amp; c_{n-2} &amp; \cdots &amp; c_1
  \end{bmatrix}
  \begin{bmatrix}
  a_1^{(t)}\\
  a_2^{(t)}\\
  \vdots\\
  a_n^{(t)}
  \end{bmatrix}\]</span></li>
</ul></li>
</ul>
<h4 id="m-序列与最大周期移位寄存器"><span class="math inline">\(m\)</span> 序列与最大周期移位寄存器</h4>
<ul>
<li>根据 LFSR 的状态转移图可以看出，一个 <span class="math inline">\(n\)</span> 级 LFSR 序列的周期最大只能为 <span class="math inline">\(2^n−1\)</span>
<ul>
<li>全零状态总是独立循环的且产生的是全零序列</li>
</ul></li>
<li><span class="math inline">\(\mathbb{F_2}\)</span> 上 <span class="math inline">\(n\)</span> 次多项式为联接多项式的 <span class="math inline">\(n\)</span> 级 LFSR 所产生的非零序列的周期为 <span class="math inline">\(2^n−1\)</span>，称这个序列是 <span class="math inline">\(n\)</span> 级最大的线性移位寄存器周期序列，简称
<span class="math inline">\(m\)</span> 序列（Maximal length
sequence）。</li>
<li>如果一个 <span class="math inline">\(n\)</span> 级 LFSR 产生了 <span class="math inline">\(m\)</span> 序列，则该 LFSR 的状态转移图仅由 <span class="math inline">\(2\)</span>
个圈构成，其中一个是由全零状态构成的长度为 <span class="math inline">\(1\)</span> 的圈，另一个是由全部其余 <span class="math inline">\(2^n−1\)</span> 个状态构成的长度为 <span class="math inline">\(2^n−1\)</span> 的圈。</li>
<li><strong>定义</strong>：若 <span class="math inline">\(f(x)\)</span>
是 <span class="math inline">\(GF(q)\)</span> 上的不可约多项式且 <span class="math inline">\(f(x)\)</span> 的根是 <span class="math inline">\(GF(q^n)\)</span> 的本原元，则称 <span class="math inline">\(f(x)\)</span> 为 <span class="math inline">\(GF(q)\)</span> 上的本原多项式。
<ul>
<li>一个 <span class="math inline">\(n\)</span> 级 LFSR
为最长移位寄存器的充要条件是它的联接多项式为 <span class="math inline">\(\mathbb{F_2}\)</span> 上的 <span class="math inline">\(n\)</span> 次本原多项式 <span class="math inline">\(C(x)\)</span>。</li>
<li>当 <span class="math inline">\(2^n−1\)</span> 为素数时， <span class="math inline">\(\mathbb{F_2}\)</span> 上的每一个 <span class="math inline">\(n\)</span> 次不可约多项式均为 <span class="math inline">\(n\)</span> 次本原多项式。</li>
</ul></li>
</ul>
<h3 id="伪随机序列">伪随机序列</h3>
<ul>
<li>伪随机序列：在统计意义上与真正的随机序列没有区别的确定性序列</li>
<li><strong>游程</strong>：
<ul>
<li>在二进制序列中，连续的一串 0 或 1 称为一个游程(run)。</li>
<li>游程的长度是指该串中 0 或 1 的个数。</li>
</ul></li>
<li><strong>Golomb 随机性假设</strong>：
<ul>
<li>在每一周期内，0 的个数与 1 的个数近似相等；</li>
<li>在每一周期内，长度为 <span class="math inline">\(i\)</span>
的游程数占游程总数的 <span class="math inline">\(1/2^i\)</span>；</li>
<li>定义自相关函数 <span class="math display">\[
  C(\tau) = \sum_{i=1}^{n}(-1)^{(a_i+a_{i+\tau})} =\begin{cases}
  n，&amp; \tau \equiv 0 \bmod n \\
  c，&amp; \tau \neq 0
  \end{cases}
  \]</span> 其值 <span class="math inline">\(c\)</span>
为一个常数。</li>
</ul></li>
<li><span class="math inline">\(m\)</span>
<strong>序列的伪随机性</strong>：
<ul>
<li>在 <span class="math inline">\(n\)</span> 级 <span class="math inline">\(m\)</span> 序列的一个周期段内，1 出现的次数恰为
<span class="math inline">\(2^{(n−1)}\)</span>，0 出现的次数恰为 <span class="math inline">\(2^{(n−1)}−1\)</span> ；</li>
<li>在 <span class="math inline">\(n\)</span> 级 <span class="math inline">\(m\)</span> 序列的一个周期段内，游程总数为 <span class="math inline">\(2^{(n−1)}\)</span>；长为 <span class="math inline">\(k(1\leq k\leq n−2)\)</span> 的 0-游程（或
1-游程）数为 <span class="math inline">\(2^{(n−2−k)}\)</span>；长为
<span class="math inline">\(n−1\)</span> 的游程只有 1 个，为
0-游程；长为 <span class="math inline">\(n\)</span> 的游程也只有 1
个，为 1-游程；</li>
<li>自相关函数是二值的，且为 <span class="math display">\[
  C(\tau) = \begin{cases}
  2^n-1，&amp; \tau \equiv 0 \bmod 2^n−1 \\
  -1，&amp; \tau \neq 0
  \end{cases}
  \]</span> 其值 <span class="math inline">\(c\)</span>
为一个常数。</li>
</ul></li>
<li><strong>线性复杂度</strong>：
<ul>
<li>二元序列 <span class="math inline">\(a=a_1 a_2 a_3 \cdots\)</span>
的线性复杂度：能够输出该序列的最短线性移位寄存器的级数
<ul>
<li>例如，给定序列 <span class="math inline">\(0,1,1,0,1,1,\ldots\)</span>，联接多项式 <span class="math inline">\(x^2+x+1\)</span> 的 LFSR
可以生成该序列，联接多项式为 <span class="math inline">\(x^3+1\)</span>
的 LFSR 也可以生成该序列。但联接多项式为 <span class="math inline">\(x+1\)</span> 的 LFSR
则无法做到这一点，所以，该序列的线性复杂度为 <span class="math inline">\(2\)</span></li>
</ul></li>
<li>如果序列的线性复杂度为 <span class="math inline">\(l(≥1)\)</span>，则只要知道序列中任意相继的 <span class="math inline">\(2l\)</span> 位，就可确定整个序列</li>
<li>序列线性复杂度是流密码安全性的重要指标</li>
</ul></li>
<li><strong>安全的密钥流应该满足这样三个基本条件</strong>：
<ul>
<li><strong>周期充分长</strong>：一般不少于 <span class="math inline">\(10^{16}\)</span>；</li>
<li><strong>随机统计特性好</strong>（即基本满足 Golomb
的随机性公设）；</li>
<li><strong>线性复杂度足够大</strong>：线性复杂度为序列长度的一半是比较合适的。</li>
</ul></li>
</ul>
<h3 id="基于lfsr的伪随机序列生成器">基于LFSR的伪随机序列生成器</h3>
<ul>
<li>在 LFSR
的基础上加入非线性化的手段，产生适合于流密码应用的密钥序列。这也是目前实现密钥流生成器的主流方法，可进一步将这种方法分为三类：
<ul>
<li>滤波生成器</li>
<li>组合生成器</li>
<li>钟控生成器</li>
</ul></li>
</ul>
<h4 id="滤波生成器">滤波生成器</h4>
<ul>
<li>由一个 <span class="math inline">\(n\)</span> 级线性移位寄存器和一个
<span class="math inline">\(m\)</span> (<span class="math inline">\(&lt;n\)</span>) 元非线性滤波函数 <span class="math inline">\(g\)</span> 组成</li>
<li><span class="math inline">\(g\)</span> 为一个 <span class="math inline">\(m\)</span>
元布尔函数，滤波函数的输出为密钥流序列，工作模式如下图：</li>
</ul>
<figure>
<img src="image-32.webp" srcset="/img/loading/loading3.gif" lazyload alt="滤波生成器">
<figcaption aria-hidden="true">滤波生成器</figcaption>
</figure>
<h4 id="组合生成器">组合生成器</h4>
<ul>
<li>若干个线性移位寄存器 <span class="math inline">\(LFSR_i
(i=1,…,n)\)</span> 和一个非线性组合函数 <span class="math inline">\(f\)</span>
组成，组合函数的输出构成密钥流序列。组合生成器工作模式如下：</li>
</ul>
<figure>
<img src="image-33.webp" srcset="/img/loading/loading3.gif" lazyload alt="组合生成器">
<figcaption aria-hidden="true">组合生成器</figcaption>
</figure>
<ul>
<li>其中 <span class="math inline">\(LFSR_i (i=1,\cdots,n)\)</span> 为
<span class="math inline">\(n\)</span> 个级数分别为 <span class="math inline">\(r_1,r_2,\cdots,r_n\)</span>
的线性移位寄存器，相应的移位寄存器序列为 <span class="math inline">\(\{a_{i_{j}}\} \left(i=1,\cdots,n
\right)\)</span>，函数 <span class="math inline">\(f
\left(x_{1},x_{2},\cdots,x_{n} \right)\)</span> 是 <span class="math inline">\(n\)</span> 元布尔函数。</li>
<li>使用组合生成器可以极大地提高序列的周期。事实上，如果 <span class="math inline">\(r_1,r_2,\cdots,r_n\)</span> 两两互质，函数 <span class="math inline">\(f(x_1，x_2，\cdots，x_n)\)</span>
与各变元均有关，则 <span class="math inline">\(\{k_j\}\)</span> 的周期为
<span class="math inline">\(\prod_{i=1}^{n}(2^{r_i}-1)\)</span></li>
</ul>
<h4 id="钟控生成器">钟控生成器</h4>
<ul>
<li>基本思想：用一个或多个移位寄存器来控制另一个或多个移位寄存器的时钟，这样的序列生成器叫做钟控生成器（clock-controlled
generator），也叫停走生成器（stop and go
generator），最终的输出被称为钟控序列，基本模型如图所示。</li>
</ul>
<figure>
<img src="image-34.webp" srcset="/img/loading/loading3.gif" lazyload alt="钟控生成器">
<figcaption aria-hidden="true">钟控生成器</figcaption>
</figure>
<ul>
<li>基本假设：<span class="math inline">\(LFSR_1\)</span> 和 <span class="math inline">\(LFSR_2\)</span> 分别输出序列 <span class="math inline">\(\{a_k\}\)</span> 和 <span class="math inline">\(\{b_k\}\)</span>。当 <span class="math inline">\(LFSR_1\)</span> 输出 1 时，移位时钟脉冲通过与门使
<span class="math inline">\(LFSR_2\)</span>
进行一次移位，从而生成下一位。当 <span class="math inline">\(LFSR_1\)</span> 输出 0
时，移位时钟脉冲无法通过与门影响 <span class="math inline">\(LFSR_2\)</span>，因此 <span class="math inline">\(LFSR_2\)</span> 重复输出前一位。
<ul>
<li>例如:
<ul>
<li><span class="math inline">\(LFSR_1\)</span> 输出周期序列 <span class="math inline">\(1,0,1,0,1,1,0,1,0,1,\cdots\)</span></li>
<li><span class="math inline">\(LFSR_2\)</span> 输出周期为 3 的序列
<span class="math inline">\(a_0,a_1,a_2,a_0,a_1,a_2,\cdots\)</span></li>
<li>则上述钟控生成器输出的钟控序列为 <span class="math inline">\(a_0,a_0,a_1,a_1,a_2,a_0,a_0,a_1,a_1,a_2,\cdots\)</span>，周期为
5。</li>
</ul></li>
</ul></li>
<li>交错停走式生成器（一种钟控序列）
<ul>
<li>交错停走式生成器(interleaved stop-and-go
generator)是钟控生成器的一种特殊形式，由三个移位寄存器 <span class="math inline">\(LFSR_1，LFSR_2\)</span> 和 <span class="math inline">\(LFSR_3\)</span> 组成，其中 <span class="math inline">\(LFSR_1\)</span> 控制 <span class="math inline">\(LFSR_2\)</span> 和 <span class="math inline">\(LFSR_3\)</span> 的时钟，<span class="math inline">\(LFSR_2\)</span> 和 <span class="math inline">\(LFSR_3\)</span>
的输出通过异或门得到最终的输出序列，如下图所示。</li>
<li><figure>
<img src="image-35.webp" srcset="/img/loading/loading3.gif" lazyload alt="钟控生成器">
<figcaption aria-hidden="true">钟控生成器</figcaption>
</figure></li>
<li><span class="math inline">\(LFSR_1\)</span> 的输出是 1 时，<span class="math inline">\(LFSR_2\)</span> 被时钟驱动；当 <span class="math inline">\(LFSR_1\)</span> 的输出是 0 时，<span class="math inline">\(LFSR_3\)</span> 被时钟驱动。最后，<span class="math inline">\(LFSR_1\)</span> 的输出与 <span class="math inline">\(LFSR_2\)</span>
的输出做异或运算即为这个交错式停走生成器的输出，输出的序列具有长周期和大的线性复杂度。</li>
</ul></li>
</ul>
<h2 id="实用流密码">实用流密码</h2>
<ul>
<li>实用流密码：RC4、A5/1、A5/2、E0等</li>
</ul>
<h3 id="a5">A5</h3>
<ul>
<li>A5 是 GSM
中执行加密运算的流密码算法，它用于从用户手机到基站的连接加密。</li>
<li>A5
中的钟控机制是：如果在某一时刻钟控单元中三个值的某两个或三个相同，则对应的移位寄存器在下一时刻被驱动，而剩下的一个（或
0 个）值对应的移位寄存器则停走。</li>
</ul>
<p><img src="image-36.webp" srcset="/img/loading/loading3.gif" lazyload alt="A5算法的结构"> <img src="image-37.webp" srcset="/img/loading/loading3.gif" lazyload alt="A5中的钟控机制"> <img src="image-86.webp" srcset="/img/loading/loading3.gif" lazyload alt="移位寄存器具体参数"></p>
<ul>
<li>A5算法的效率很高，输出的序列统计性好，能够通过所有的已知测试。但使用的移位寄存器太短，极易受穷尽攻击。若A5采用级数较长的移位寄存器则会更安全。</li>
</ul>
<h3 id="rc4">RC4</h3>
<ul>
<li>RC4 是由 Ron Rivest 在 1987
年设计的一种流密码算法，是目前应用最广泛的流密码算法之一。RC4
的核心是一个伪随机字节生成器，RC4
的加密和解密过程相同，都是将明文或密文与伪随机字节流进行逐字节异或运算</li>
<li>相关参数：
<ul>
<li>参数 <span class="math inline">\(n\)</span>，长为 <span class="math inline">\(n\)</span> 的秘密内部状态(<span class="math inline">\(2^n\)</span> 数组)，通常取 <span class="math inline">\(n=8\)</span></li>
<li>对应的内部状态由 <span class="math inline">\(256=2^8\)</span> 个元素
<span class="math inline">\(S[0], \cdots, S[255]\)</span>
构成，每个元素都是 <span class="math inline">\(0\sim 255\)</span>
间的一个数字</li>
<li>输入是一个可变长度的密钥，该密钥用于初始化内部状态。</li>
<li>输出是状态中按照一定方式选出的某一个元素 <span class="math inline">\(K\)</span>，该输出构成密钥流的一个字节，加解密时这个字节
<span class="math inline">\(K\)</span> 与一个明文/密文字节执行 <span class="math inline">\(XOR\)</span> 运算。</li>
<li>每生成一个 <span class="math inline">\(K\)</span>
值，内部状态中的元素会被重新置换一次，以便下次生成 <span class="math inline">\(K\)</span> 值</li>
</ul></li>
<li>RC4 算法： <img src="image-38.webp" srcset="/img/loading/loading3.gif" lazyload alt="RC4算法"></li>
<li>密钥调度算法：
<ul>
<li>用来设置内部状态 <span class="math inline">\(S[0], \cdots,
S[255]\)</span> 的随机排列</li>
<li>开始时，内部状态被初始化为 <span class="math inline">\(0\sim
255\)</span>，即 <span class="math inline">\(S[i]=i(i=0,\cdots,255)\)</span></li>
<li>密钥长度可变，假设为 <span class="math inline">\(L\)</span>
个字节，<span class="math inline">\((K[0], \cdots,
K[L−1])\)</span>，一般 <span class="math inline">\(L\)</span> 在 5～32
之间</li>
<li>用这 <span class="math inline">\(L\)</span>
个字节不断重复填充，直至得到 <span class="math inline">\((K[0], \cdots,
K[255])\)</span>。数组 <span class="math inline">\(K\)</span>
将被用于对内部状态 <span class="math inline">\(S\)</span>
进行随机化</li>
<li><figure>
<img src="image-39.webp" srcset="/img/loading/loading3.gif" lazyload alt="RC4密钥调度算法">
<figcaption aria-hidden="true">RC4密钥调度算法</figcaption>
</figure></li>
</ul></li>
<li>伪随机生成算法：
<ul>
<li>它从内部状态中选取一个随机元素作为密钥流中的一个字节，并修改内部状态以便下一次选取。选取过程取决于两个索引值
<span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>，它们的初始值均为
0。具体选取过程如下：</li>
<li><figure>
<img src="image-40.webp" srcset="/img/loading/loading3.gif" lazyload alt="伪随机生成算法">
<figcaption aria-hidden="true">伪随机生成算法</figcaption>
</figure></li>
</ul></li>
<li>示例： <img src="image-72.webp" srcset="/img/loading/loading3.gif" lazyload alt="RC4示例"></li>
</ul>
<h2 id="轻量级密码算法">轻量级密码算法</h2>
<ul>
<li>轻量级密码算法（lightweight
cryptography）是指在资源受限的环境下使用的密码算法，通常用于物联网设备、嵌入式系统和智能卡等场景。</li>
<li>资源受限环境终端设备的特点
<ul>
<li>数量巨大（电卡、汽车ETC等）</li>
<li>内存资源较少</li>
<li>处理（计算）能力有限</li>
<li>功耗要求严格</li>
</ul></li>
</ul>
<h1 id="分组密码">分组密码</h1>
<h2 id="常见的分组密码算法">常见的分组密码算法</h2>
<table>

<thead>
<tr>
<th>算法</th>
<th>分组长度（bit）</th>
<th>密钥长度（bit）</th>
<th>轮数</th>
</tr>
</thead>
<tbody>
<tr>
<td>DES</td>
<td>64</td>
<td>56（实际有效长度，存储为64bit含8bit校验）</td>
<td>16</td>
</tr>
<tr>
<td>3DES（Triple DES）</td>
<td>64</td>
<td>112（2个56bit密钥）或168（3个56bit密钥）</td>
<td>48</td>
</tr>
<tr>
<td>IDEA</td>
<td>64</td>
<td>128</td>
<td>8</td>
</tr>
<tr>
<td>AES</td>
<td>128</td>
<td>128、192、256</td>
<td>10、12、14</td>
</tr>
<tr>
<td>Blowfish</td>
<td>64</td>
<td>32-448（以8bit为步长递增）</td>
<td>16</td>
</tr>
<tr>
<td>Twofish</td>
<td>128</td>
<td>128、192、256</td>
<td>16</td>
</tr>
<tr>
<td>Camellia</td>
<td>128</td>
<td>128、192、256</td>
<td>18、20、22</td>
</tr>
<tr>
<td>SM4</td>
<td>128</td>
<td>128</td>
<td>32</td>
</tr>
</tbody>
</table>
<ul>
<li><p>在分组密码中，消息被分成许多块，每块都要被加密，类似于许多字符被替换
<img src="image-2.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>理想的方法是使用尽可能大的替换模块，但不实际，因为对每个 64-bit
的模块，将需要 <span class="math inline">\(2^{64}\)</span>
个实体的替换表，因此使用一些小的模块代替</p></li>
</ul>
<h2 id="分组密码的基本结构">分组密码的基本结构</h2>
<h3 id="spn-结构">SPN 结构</h3>
<figure>
<img src="image-1.webp" srcset="/img/loading/loading3.gif" lazyload alt="SPN Structure">
<figcaption aria-hidden="true">SPN Structure</figcaption>
</figure>
<ul>
<li><strong>SPN</strong>（Substitution-Permutation
Network，替换-置换网络）结构
<ul>
<li>由多轮替换和置换组成</li>
<li>每轮包括两个主要操作：替换（Substitution）和置换（Permutation）</li>
<li>替换使用S盒（Substitution
box）实现，将输入的位模式映射到输出的位模式，提供<strong>混淆</strong>效果</li>
<li>置换使用P盒（Permutation
box）实现，重新排列输入的位，提供<strong>扩散</strong>效果</li>
<li>通过多轮的替换和置换，增加了密码的复杂性和安全性</li>
</ul></li>
</ul>
<figure>
<img src="image-3.webp" srcset="/img/loading/loading3.gif" lazyload alt="S-box &amp; P-box">
<figcaption aria-hidden="true">S-box &amp; P-box</figcaption>
</figure>
<h3 id="feistel-结构">Feistel 结构</h3>
<figure>
<img src="image.webp" srcset="/img/loading/loading3.gif" lazyload alt="Feistel Network">
<figcaption aria-hidden="true">Feistel Network</figcaption>
</figure>
<ul>
<li><strong>Feistel 网络</strong> 结构
<ul>
<li>将输入数据分成两个相等的部分，通常称为左半部（<span class="math inline">\(L\)</span>）和右半部（<span class="math inline">\(R\)</span>）
<ul>
<li>每轮操作包括一个函数 <span class="math inline">\(F\)</span>，该函数接受右半部（<span class="math inline">\(R_{i-1}\)</span>）和一个子密钥（<span class="math inline">\(K_i\)</span>）作为输入，输出一个与左半部大小相同的值</li>
<li>然后将左半部（<span class="math inline">\(L_{i-1}\)</span>）与函数
<span class="math inline">\(F\)</span>
的输出进行异或运算，结果成为新的右半部（<span class="math inline">\(R_i\)</span>）</li>
<li>右半部保持不变，成为新的左半部（<span class="math inline">\(L_i\)</span>）</li>
</ul></li>
<li>这种结构的优点是加密和解密过程非常相似，只需使用相同的函数 <span class="math inline">\(F\)</span> 和子密钥，但顺序相反</li>
<li>加密过程：第 <span class="math inline">\(i\)</span> 轮将 <span class="math inline">\((L_{i-1}, R_{i-1})\)</span>映射到<span class="math inline">\((L_i, R_i)\)</span>如下： <span class="math display">\[
  \begin{aligned}
  &amp;L_i=R_{i-1} \\
  &amp;R_i=L_{i-1} \oplus F(R_{i-1}, K_i)
  \end{aligned}
  \]</span></li>
<li>解密过程与加密过程类似，只需将子密钥的顺序反转： <span class="math display">\[
  \begin{aligned}
  &amp;R_{i-1}=L_i \\
  &amp;L_{i-1}=R_i \oplus F(R_{i-1}, K_i)=R_i \oplus F(L_i, K_i)
  \end{aligned}
  \]</span></li>
</ul></li>
</ul>
<h2 id="分组密码的设计原则">分组密码的设计原则</h2>
<ul>
<li><strong>雪崩效应</strong>（Avalanche Effect）
<ul>
<li>输入改变 1 bit, 导致近一半的输出比特发生变化</li>
<li>一个函数 <span class="math inline">\(F\)</span>
具有好的雪崩特性是指：对 <span class="math inline">\(2^m\)</span>
个明文向量, 分为 <span class="math inline">\(2^{(m−1)}\)</span> 个向量对
<span class="math inline">\((x_i,
x_i')\)</span>，每对向量只有一个比特不同，定义 <span class="math inline">\(V_i=f(x_i) \oplus f(x_i')\)</span>，则近一半的
<span class="math inline">\(V_i\)</span> 为 1</li>
</ul></li>
<li><strong>完备性效应</strong>（Completeness Effect）
<ul>
<li>每个输出比特是所有输入比特的复杂函数的输出</li>
<li>一个函数 <span class="math inline">\(F\)</span>
具有好的完备性是指：对密文输出向量的每一比特 <span class="math inline">\(j\)</span>，<span class="math inline">\(0&lt;j&lt;m\)</span>，至少存在一个明文对 <span class="math inline">\((x_i,  x_i')\)</span>，此明文对只在第 <span class="math inline">\(i\)</span> 比特不同，且 <span class="math inline">\(F(x_i)\)</span> 与 <span class="math inline">\(F(x_i')\)</span> 的第 <span class="math inline">\(j\)</span> 比特不同</li>
</ul></li>
<li><strong>不可预测性</strong>（Unpredictability）
<ul>
<li>给定部分输入或输出，无法有效地预测剩余的输入或输出</li>
</ul></li>
<li>设计密码时, 下列参数需要考虑：
<ul>
<li>分组大小（block
size）：增加分组长度会提高安全性，但降低了密码运算速度</li>
<li>密钥大小（key
size）：增加密钥长度，可以提高安全性（使得穷搜索困难），但降低了密码速度</li>
<li>轮数：增加轮数可以提高安全性，但降低速度</li>
<li>子密钥生成：子密钥生成越复杂，就越安全，但降低速度</li>
<li>轮函数：复杂的轮函数能够使的密码分析困难，但降低速度</li>
</ul></li>
</ul>
<h2 id="分组密码理论">分组密码理论</h2>
<h3 id="lucifer-密码">Lucifer 密码</h3>
<figure>
<img src="image-4.webp" srcset="/img/loading/loading3.gif" lazyload alt="Lucifer">
<figcaption aria-hidden="true">Lucifer</figcaption>
</figure>
<ul>
<li>第一个可用的代换（S）-置换（P）密码</li>
<li>密钥编排：
<ul>
<li>Lucifer 密码是 Feistel 网络，分组长度是 128-bit, 密钥长度是
128-bit</li>
<li>每轮使用的子密钥是密钥的左半部分</li>
<li>密钥每次要循环左移 56-bit, 所以密钥的每部分都参加运算</li>
</ul></li>
<li>加密过程：
<ul>
<li>左半部分 <span class="math inline">\(L_i\)</span> 和右半部分 <span class="math inline">\(R_i\)</span> 的计算如下： <span class="math display">\[
  \begin{aligned}
  &amp;L_i=R_{i−1} \\
  &amp;R_i=L_{i−1} \oplus F(R_{i−1}, K_i)
  \end{aligned}
  \]</span></li>
<li>其中 <span class="math inline">\(F\)</span> 函数的结构如下：
<ul>
<li>输入 <span class="math inline">\(R_{i−1}\)</span> (64-bit) 被分为 8
个字节经过 S-盒替换，每个字节根据密钥 <span class="math inline">\(K_i\)</span> 的左 8-bit 中的一位选择 S0 或 S1</li>
<li>然后与密钥 <span class="math inline">\(K_i\)</span> 的全部 64-bit
进行异或运算</li>
<li>然后经过 P-盒置换，得到 64-bit 的输出</li>
</ul></li>
<li><figure>
<img src="image-5.webp" srcset="/img/loading/loading3.gif" lazyload alt="Function F">
<figcaption aria-hidden="true">Function F</figcaption>
</figure></li>
</ul></li>
<li>安全性
<ul>
<li>Lucifer 没有经过很强的分析</li>
<li>现在认为是理论可破的 (通过差分分析)</li>
<li>现在不被使用</li>
<li>是 DES 的前身</li>
</ul></li>
</ul>
<h3 id="s-des-simplified-des">S-DES (Simplified DES)</h3>
<figure>
<img src="image-6.webp" srcset="/img/loading/loading3.gif" lazyload alt="S-DES 方案示意图">
<figcaption aria-hidden="true">S-DES 方案示意图</figcaption>
</figure>
<ul>
<li>供教学而非安全的加密算法，与DES的特性和结构类似，但参数较小。</li>
<li>加密算法涉及五个函数：
<ul>
<li>初始置换 <span class="math inline">\(IP\)</span> (initial
permutation)</li>
<li>复合函数 <span class="math inline">\(f_{K1}\)</span>，它是由密钥
<span class="math inline">\(K\)</span> 确定的，具有代换和置换功能</li>
<li>转换函数 <span class="math inline">\(SW\)</span></li>
<li>复合函数 <span class="math inline">\(f_{K2}\)</span></li>
<li>初始置换 <span class="math inline">\(IP\)</span> 的逆置换 <span class="math inline">\(IP^{-1}\)</span></li>
</ul></li>
<li>数学表示
<ul>
<li>设明文为 <span class="math inline">\(M\)</span>，密钥为 <span class="math inline">\(K\)</span>，则密文 <span class="math inline">\(C\)</span> 可表示为： <span class="math display">\[C =
IP^{-1}(f_{K2}(SW(f_{K1}(IP(M)))))\]</span></li>
<li>解密过程与加密过程类似，只需将子密钥的顺序反转： <span class="math display">\[M =
IP^{-1}(f_{K1}(SW(f_{K2}(IP(C)))))\]</span></li>
<li>其中:
<ul>
<li><span class="math inline">\(K_1 =
P_8(LS_{1}(P_{10}(K)))\)</span></li>
<li><span class="math inline">\(K_2 =
P_8(LS_{2}(LS_{1}(P_{10}(K))))\)</span></li>
</ul></li>
</ul></li>
<li>S-DES 的密钥生成：
<ul>
<li><figure>
<img src="image-7.webp" srcset="/img/loading/loading3.gif" lazyload alt="S-DES 密钥生成示意图">
<figcaption aria-hidden="true">S-DES 密钥生成示意图</figcaption>
</figure></li>
<li>设 10bit 的密钥为 <span class="math inline">\(K =
(k_1,k_2,\cdots,k_{10})\)</span>
<ul>
<li><span class="math inline">\(P_{10}(k_1,k_2,\cdots,k_{10})=(k_3,k_5,k_2,k_7,k_4,k_{10},k_1,k_9,k_8,k_6)\)</span></li>
<li><span class="math inline">\(P_8(k_1,k_2,\cdots,k_{10})=(k_6,k_3,k_7,k_4,k_8,k_5,k_{10},k_9)\)</span></li>
</ul></li>
<li><span class="math inline">\(LS_{1}\)</span> 为循环左移 1 位， <span class="math inline">\(LS_{2}\)</span> 为循环左移 2 位</li>
<li>示例：
<ul>
<li>若 <span class="math inline">\(K=(1010000010)\)</span></li>
<li><span class="math inline">\(P_{10}(K)=(1000001100)\)</span></li>
<li><span class="math inline">\(LS_{1}(10000)\parallel
LS_{1}(01100)=(00001\parallel 11000)\)</span></li>
<li><span class="math inline">\(K_1=P_8(0000111000)=(10100100)\)</span></li>
<li><span class="math inline">\(LS_{2}(00001)\parallel
LS_{2}(11000)=(00100\parallel 00011)\)</span></li>
<li><span class="math inline">\(K_2=P_8(0010000011)=(01000011)\)</span></li>
</ul></li>
</ul></li>
<li>S-DES 的加密运算:
<ul>
<li><figure>
<img src="image-11.webp" srcset="/img/loading/loading3.gif" lazyload alt="S-DES 加密运算示意图">
<figcaption aria-hidden="true">S-DES 加密运算示意图</figcaption>
</figure></li>
</ul>
<ol type="1">
<li><span class="math inline">\(IP\)</span> 置换
<ul>
<li>初始置换用 <span class="math inline">\(IP\)</span> 函数： <span class="math display">\[ IP = \begin{bmatrix}
  1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 \\
  2 &amp; 6 &amp; 3 &amp; 1 &amp; 4 &amp; 8 &amp; 5 &amp; 7
  \end{bmatrix} \]</span></li>
<li>末端算法的置换为 <span class="math inline">\(IP\)</span> 的逆置换：
<span class="math display">\[IP^{-1}  = \begin{bmatrix}
  1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 \\
  4 &amp; 1 &amp; 3 &amp; 5 &amp; 7 &amp; 2 &amp; 8 &amp; 6
  \end{bmatrix} \]</span></li>
<li><span class="math inline">\(IP^{-1} (IP(X))=X\)</span></li>
</ul></li>
<li>函数 <span class="math inline">\(f_k\)</span>: <span class="math display">\[f_k (L,R)=(L⊕F(R,SK),R)\]</span>
<ul>
<li>其中 <span class="math inline">\(L\parallel R\)</span> 为 8 位输入,
左右各为 4 位, <span class="math inline">\(F\)</span> 为从 4 位集到 4
位集的一个映射, 并不要求是 1-1 的。<span class="math inline">\(SK\)</span> 为子密钥。</li>
</ul></li>
<li>对映射 <span class="math inline">\(F\)</span> 来说：
<ul>
<li>首先输入是一个 4 位数 <span class="math inline">\((n_1,n_2,n_3,n_4)\)</span>，第一步运算是扩张/置换(E/P)运算：
<span class="math display">\[E/P = \begin{bmatrix}
  4 &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; 3 &amp; 4 &amp; 1
  \end{bmatrix} \]</span></li>
<li>然后分左右 4 位进入两个 S 盒运算</li>
</ul></li>
<li>对两个 S 盒：<span class="math inline">\(S_0\)</span> 和 <span class="math inline">\(S_1\)</span>
<ul>
<li><span class="math inline">\(S_0\)</span> 和 <span class="math inline">\(S_1\)</span> 的定义如下： <span class="math display">\[S_0 = \begin{bmatrix}
  1 &amp; 0 &amp; 3 &amp; 2 \\
  3 &amp; 2 &amp; 1 &amp; 0 \\
  0 &amp; 2 &amp; 1 &amp; 3 \\
  2 &amp; 1 &amp; 0 &amp; 3
  \end{bmatrix},\quad S_1 = \begin{bmatrix}
  0 &amp; 1 &amp; 2 &amp; 3 \\
  2 &amp; 0 &amp; 1 &amp; 3 \\
  3 &amp; 0 &amp; 1 &amp; 0 \\
  2 &amp; 1 &amp; 0 &amp; 3
  \end{bmatrix} \]</span></li>
<li>按下述规则运算：
<ul>
<li>将第 <span class="math inline">\(1\)</span> 和第 <span class="math inline">\(4\)</span> 的输入比特做为 <span class="math inline">\(2bit\)</span> 数，指示为S盒的一个行；将第 <span class="math inline">\(2\)</span> 和第 <span class="math inline">\(3\)</span>
的输入比特做为S盒的一个列。如此确定为S盒矩阵的 <span class="math inline">\((i,j)\)</span> 数。</li>
<li>例如：<span class="math inline">\((P_{0,0}
P_{0,3})=(00),  并且(P_{0,1} P_{0,2})=(1 0)\)</span>，确定了 <span class="math inline">\(S_0\)</span> 中的第 <span class="math inline">\(0\)</span> 行 <span class="math inline">\(2\)</span> 列 <span class="math inline">\((0,2)\)</span> 的系数为 <span class="math inline">\(3\)</span>，记为 <span class="math inline">\((11)\)</span> 输出。</li>
</ul></li>
</ul></li>
<li><span class="math inline">\(P_4\)</span> 置换
<ul>
<li>由 <span class="math inline">\(S_0, S_1\)</span> 输出的 4-bit 经置换
<span class="math display">\[P_4 = \begin{bmatrix}
  2 &amp; 4 &amp; 3 &amp; 1
  \end{bmatrix}\]</span></li>
<li>它的输出就是 <span class="math inline">\(F\)</span> 函数的输出</li>
</ul></li>
<li>将 <span class="math inline">\(F\)</span> 的输出与左半部分 <span class="math inline">\(L\)</span>
进行异或运算，得到新的左半部分，再与原本的右半部分 <span class="math inline">\(R\)</span> 组合，得到 <span class="math inline">\(f_k\)</span> 的输出</li>
<li>交换函数 <span class="math inline">\(SW\)</span>
<ul>
<li>交换函数 <span class="math inline">\(SW\)</span> 将 8-bit
输入的左右两半交换位置</li>
<li>即 <span class="math inline">\(SW(L\parallel R)=R\parallel
L\)</span></li>
</ul></li>
<li>再进行一次 <span class="math inline">\(f_k\)</span>
运算，使用第二个子密钥 <span class="math inline">\(K_2\)</span></li>
<li>最后进行 <span class="math inline">\(IP^{-1}\)</span>
置换，得到密文</li>
</ol></li>
</ul>
<h3 id="des">DES</h3>
<figure>
<img src="image-8.webp" srcset="/img/loading/loading3.gif" lazyload alt="DES">
<figcaption aria-hidden="true">DES</figcaption>
</figure>
<ul>
<li>Feistel 结构
<ul>
<li>密钥 <span class="math inline">\(K\)</span> 长度：56-bit</li>
<li>分组（输入）长度：64-bit</li>
<li>密文（输出）长度：64-bit</li>
<li>轮数：16 轮</li>
</ul></li>
<li>算法分三个阶段实现：
<ol type="1">
<li>对明文 <span class="math inline">\(X\)</span>，通过一个固定的初始置换 <span class="math inline">\(IP\)</span> 得到 <span class="math inline">\(X_0\)</span>，分为左右两部分 <span class="math display">\[X_0=IP(X)=L_0\parallel R_0\]</span></li>
<li>函数 <span class="math inline">\(F\)</span> 的 <span class="math inline">\(16\)</span> 次迭代：<span class="math inline">\(L_i\parallel R_i (1 \leq i \leq 16)\)</span> <span class="math display">\[
\begin{aligned}
&amp;L_i=R_{i−1} \\
&amp;R_i=L_{i−1} \oplus F(R_{i−1}, K_i)
\end{aligned}
\]</span>
<ul>
<li>其中 <span class="math inline">\(K_i\)</span> 是长为 48
位的子密钥。子密钥 <span class="math inline">\(K_1,K_2,\cdots,K_{16}\)</span> 是作为密钥 <span class="math inline">\(K\)</span>（56 位）的函数而计算出的。</li>
</ul></li>
<li>对比特串 <span class="math inline">\(R_{16}\parallel L_{16}\)</span>
使用逆置换 <span class="math inline">\(IP^{-1}\)</span> 得到密文 <span class="math inline">\(Y\)</span>。 <span class="math display">\[Y=IP^{-1}(R_{16}\parallel L_{16})\]</span></li>
</ol></li>
<li>初始置换 <span class="math inline">\(IP\)</span> 和 <span class="math inline">\(IP^{-1}\)</span>
的定义：表中的数字表示这个比特在置换前的位置 <span class="math display">\[IP = \begin{bmatrix}
  58 &amp; 50 &amp; 42 &amp; 34 &amp; 26 &amp; 18 &amp; 10 &amp; 2 \\
  60 &amp; 52 &amp; 44 &amp; 36 &amp; 28 &amp; 20 &amp; 12 &amp; 4 \\
  62 &amp; 54 &amp; 46 &amp; 38 &amp; 30 &amp; 22 &amp; 14 &amp; 6 \\
  64 &amp; 56 &amp; 48 &amp; 40 &amp; 32 &amp; 24 &amp; 16 &amp; 8 \\
  57 &amp; 49 &amp; 41 &amp; 33 &amp; 25 &amp; 17 &amp; 9 &amp; 1 \\
  59 &amp; 51 &amp; 43 &amp; 35 &amp; 27 &amp; 19 &amp; 11 &amp; 3 \\
  61 &amp; 53 &amp; 45 &amp; 37 &amp; 29 &amp; 21 &amp; 13 &amp; 5 \\
  63 &amp; 55 &amp; 47 &amp; 39 &amp; 31 &amp; 23 &amp; 15 &amp; 7
  \end{bmatrix}\]</span> <span class="math display">\[IP^{-1} =
\begin{bmatrix}
  40 &amp; 8 &amp; 48 &amp; 16 &amp; 56 &amp; 24 &amp; 64 &amp; 32 \\
  39 &amp; 7 &amp; 47 &amp; 15 &amp; 55 &amp; 23 &amp; 63 &amp; 31 \\
  38 &amp; 6 &amp; 46 &amp; 14 &amp; 54 &amp; 22 &amp; 62 &amp; 30 \\
  37 &amp; 5 &amp; 45 &amp; 13 &amp; 53 &amp; 21 &amp; 61 &amp; 29 \\
  36 &amp; 4 &amp; 44 &amp; 12 &amp; 52 &amp; 20 &amp; 60 &amp; 28 \\
  35 &amp; 3 &amp; 43 &amp; 11 &amp; 51 &amp; 19 &amp; 59 &amp; 27 \\
  34 &amp; 2 &amp; 42 &amp; 10 &amp; 50 &amp; 18 &amp; 58 &amp; 26 \\
  33 &amp; 1 &amp; 41 &amp; 9 &amp; 49 &amp; 17 &amp; 57 &amp; 25
  \end{bmatrix}\]</span></li>
<li>扩展置换 <span class="math inline">\(E\)</span>：用于将 32
位的输入扩展为 48 位，表中第 <span class="math inline">\(i\)</span>
个数据 <span class="math inline">\(j\)</span> 表示输出的第 <span class="math inline">\(i\)</span> 位为输入的第 <span class="math inline">\(j\)</span> 位。 <span class="math display">\[E =
\begin{bmatrix}
  32 &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 \\
  4 &amp; 5 &amp; 6 &amp; 7 &amp; 8 &amp; 9 \\
  8 &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 \\
  12 &amp; 13 &amp; 14 &amp; 15 &amp; 16 &amp; 17 \\
  16 &amp; 17 &amp; 18 &amp; 19 &amp; 20 &amp; 21 \\
  20 &amp; 21 &amp; 22 &amp; 23 &amp; 24 &amp; 25 \\
  24 &amp; 25 &amp; 26 &amp; 27 &amp; 28 &amp; 29 \\
  28 &amp; 29 &amp; 30 &amp; 31 &amp; 32 &amp; 1
  \end{bmatrix}\]</span></li>
<li>置换 <span class="math inline">\(P\)</span>：表中第 <span class="math inline">\(i\)</span> 个数据 <span class="math inline">\(j\)</span> 表示输出的第 <span class="math inline">\(i\)</span> 位为输入的第 <span class="math inline">\(j\)</span> 位 <span class="math display">\[P =
\begin{bmatrix}
  16 &amp; 7 &amp; 20 &amp; 21 &amp; 29 &amp; 12 &amp; 28 &amp; 17 \\
  1 &amp; 15 &amp; 23 &amp; 26 &amp; 5 &amp; 18 &amp; 31 &amp; 10 \\
  2 &amp; 8 &amp; 24 &amp; 14 &amp; 32 &amp; 27 &amp; 3 &amp; 9 \\
  19 &amp; 13 &amp; 30 &amp; 6 &amp; 22 &amp; 11 &amp; 4 &amp; 25
  \end{bmatrix}\]</span></li>
<li>S-box-1 <span class="math display">\[S_1 = \begin{bmatrix}
  14 &amp; 4 &amp; 13 &amp; 1 &amp; 2 &amp; 15 &amp; 11 &amp; 8 &amp; 3
&amp; 10 &amp; 6 &amp; 12 &amp; 5 &amp; 9 &amp; 0 &amp; 7 \\
  0 &amp; 15 &amp; 7 &amp; 4 &amp; 14 &amp; 2 &amp; 13 &amp; 1 &amp; 10
&amp; 6 &amp; 12 &amp; 11 &amp; 9 &amp; 5 &amp; 3 &amp; 8 \\
  4 &amp; 1 &amp; 14 &amp; 8 &amp; 13 &amp; 6 &amp; 2 &amp; 11 &amp; 15
&amp; 12 &amp; 9 &amp; 7 &amp; 3 &amp; 10 &amp; 5 &amp; 0 \\
  15 &amp; 2 &amp; 8 &amp; 14 &amp; 6 &amp; 11 &amp; 1 &amp; 3 &amp; 4
&amp; 9 &amp; 7 &amp; 5 &amp; 13 &amp; 10 &amp; 0 &amp; 12
  \end{bmatrix}\]</span></li>
<li><span class="math inline">\(F\)</span> 函数的说明
<ul>
<li><span class="math inline">\(F(R_{i−1}, K_i)\)</span>
的非线性表示如下：函数 <span class="math inline">\(F\)</span>
有两个输入：一半消息 <span class="math inline">\(R_{i−1}\)</span>（32-bit）作第一个输入，<span class="math inline">\(48\)</span> 比特的子密钥 <span class="math inline">\(K_i\)</span> (48-bit)
作为第二个输入。产生的输出为长度为 <span class="math inline">\(32\)</span> 位串。 <img src="image-9.webp" srcset="/img/loading/loading3.gif" lazyload alt="F Function"></li>
</ul>
<ol type="1">
<li>对<span class="math inline">\(R_{i−1}\)</span> ，先利用扩展函数<span class="math inline">\(E\)</span>，扩展成 <span class="math inline">\(48\)</span> 位 <span class="math inline">\(E(R_{i−1})\)</span></li>
<li>计算 <span class="math inline">\(A = E(R_{i−1})\oplus
K_i\)</span>，结果写成 <span class="math inline">\(8\)</span> 个 <span class="math inline">\(6\)</span> 位串 <span class="math display">\[
\begin{aligned}
&amp;A=A_1\parallel A_2\parallel A_3\parallel A_4\parallel A_5\parallel
A_6\parallel A_7\parallel A_8 \\
&amp;A_j=a_1 a_2 a_3 a_4 a_5 a_6
\end{aligned}
\]</span></li>
<li>使用 <span class="math inline">\(8\)</span> 个 S 盒，每个 <span class="math inline">\(S_j\)</span> 是一个固定的 <span class="math inline">\(4 \times 16\)</span> 矩阵，它的元素取 <span class="math inline">\(0 \sim 15\)</span> 的整数。给定 <span class="math inline">\(A_j\)</span>，计算 <span class="math inline">\(B_j=S_j (A_j)\)</span>，其中 <span class="math inline">\(B_j\)</span> 是一个 <span class="math inline">\(4\)</span> 位串，<span class="math inline">\(B_j=b_1 b_2 b_3 b_4\)</span>。
<ul>
<li>计算 <span class="math inline">\(S_j (A_j)\)</span> 如下：<span class="math inline">\(a_1 a_6\)</span> 两个比特确定了 <span class="math inline">\(S_j\)</span> 的行数, <span class="math inline">\(r
(0\leq r \leq 3)\)</span>；而 <span class="math inline">\(a_2 a_3 a_4
a_5\)</span> 四个比特确定了 <span class="math inline">\(S_j\)</span>
的列数 <span class="math inline">\(c (0\leq c \leq 15)\)</span>。最后
<span class="math inline">\(S_j (A_j)\)</span> 的值为S-盒矩阵 <span class="math inline">\(S_j\)</span> 中 <span class="math inline">\(r\)</span> 行 <span class="math inline">\(c\)</span> 列的元素 <span class="math inline">\((r,c)\)</span>，得 <span class="math inline">\(B_j=S_j (A_j)\)</span>。</li>
</ul></li>
<li>最后，<span class="math inline">\(P\)</span> 为固定置换。</li>
</ol></li>
<li>DES使用的特定轮函数
<ul>
<li>初始置换 <span class="math inline">\(IP\)</span>：对明文输入进行次序的打乱。</li>
<li>逆置换 <span class="math inline">\(IP^{-1}\)</span></li>
<li>扩展函数 <span class="math inline">\(E\)</span>（32到48）</li>
<li>置换函数 <span class="math inline">\(P\)</span>（32到32）</li>
<li>8个 S 盒 <span class="math inline">\(S_1, S_2, \ldots,
S_8\)</span>（6到4）</li>
</ul></li>
<li>密钥编排：由密钥 <span class="math inline">\(K\)</span> 计算子密钥
<span class="math inline">\(K(i)\)</span>
<ul>
<li><figure>
<img src="image-83.webp" srcset="/img/loading/loading3.gif" lazyload alt="轮密钥生成示意图">
<figcaption aria-hidden="true">轮密钥生成示意图</figcaption>
</figure></li>
<li>密钥 <span class="math inline">\(K\)</span> 是长度为 64 的位串，56
位参加子密钥编排。8
位是奇偶校验位（为了检错），在密钥编排的计算中，不参加运算。
<ol type="1">
<li>给定 64 位的密钥 <span class="math inline">\(K\)</span>，放弃奇偶校验位 <span class="math inline">\((8, 16, \ldots, 64)\)</span> 并根据固定置换 <span class="math inline">\(PC1\)</span> 来排列 <span class="math inline">\(K\)</span> 中剩下的位。我们写 <span class="math display">\[PC1(K)=C_0\parallel D_0\]</span> 其中 <span class="math inline">\(C_0\)</span> 由 <span class="math inline">\(PC1(K)\)</span> 的前 28 位组成；<span class="math inline">\(D_0\)</span> 由后 28 位组成。</li>
<li>对 <span class="math inline">\(1 \leq i \leq 16\)</span>，计算 <span class="math display">\[C_i=LS_i (C_{i−1}) \quad D_i=LS_i
(D_{i−1})\]</span> 其中 <span class="math inline">\(LS_i\)</span>
表示循环左移 2 或 1 个位置，取决于 <span class="math inline">\(i\)</span> 的值。
<ul>
<li><span class="math inline">\(i=1,2,9,16\)</span> 时移 1
个位置，否则移 2 位置</li>
<li><span class="math inline">\(K_i=PC2(C_i\parallel
D_i)\)</span>，<span class="math inline">\(PC2\)</span> 为固定置换，将前
28 位中的 24 位置换，并去掉 9、18、22、25，将后 28 位中的 24
位置换，并去掉 35、38、43、54 位</li>
</ul></li>
</ol></li>
<li>一共 16 轮迭代，总共生成 16 个 48 比特的子密钥 <span class="math inline">\(K_1, K_2, \ldots, K_{16}\)</span>。</li>
</ul></li>
</ul>
<h3 id="des-triple-des">3DES (Triple DES)</h3>
<ul>
<li>由于 DES 的密钥长度较短，容易受到穷举攻击，因此提出了 Triple
DES（3DES）来增强安全性。</li>
<li>3DES 的工作原理是对数据进行三次 DES
加密和解密操作，通常使用两种或三种不同的密钥。</li>
<li>Two-Key 3DES:
<ul>
<li>使用两个密钥 <span class="math inline">\(K_1\)</span> 和 <span class="math inline">\(K_2\)</span>，加密过程为：<span class="math display">\[C = E_{K_2}(D_{K_2}(E_{K_1}(M)))\]</span></li>
<li>解密过程为：<span class="math display">\[M =
D_{K_1}(E_{K_2}(D_{K_2}(C)))\]</span></li>
</ul></li>
<li>Three-Key 3DES:
<ul>
<li>使用三个密钥 <span class="math inline">\(K_1\)</span>、<span class="math inline">\(K_2\)</span> 和 <span class="math inline">\(K_3\)</span>，加密过程为：<span class="math display">\[C = E_{K_3}(D_{K_2}(E_{K_1}(M)))\]</span></li>
<li>解密过程为：<span class="math display">\[M =
D_{K_1}(E_{K_2}(D_{K_3}(C)))\]</span></li>
</ul></li>
<li>密钥长度：
<ul>
<li>标准DES：56 bit</li>
<li>Two-Key 3DES：112 bit</li>
<li>Three-Key 3DES：168 bit</li>
</ul></li>
</ul>
<h3 id="idea">IDEA</h3>
<figure>
<img src="image-10.webp" srcset="/img/loading/loading3.gif" lazyload alt="IDEA">
<figcaption aria-hidden="true">IDEA</figcaption>
</figure>
<ul>
<li>Feistel 结构
<ul>
<li>密钥长度：128位（抗强力攻击能力比DES强）</li>
<li>分组长度：64位
<ul>
<li>子分组长度：16位</li>
</ul></li>
<li>密文长度：64位</li>
<li>轮数：8轮 + 1次输出变换</li>
</ul></li>
<li>IDEA的“混淆”和“扩散”设计原则来自三种运算，它们易于软、硬件实现（加密速度快）：
<ol type="1">
<li>异或运算：<span class="math inline">\(\oplus\)</span></li>
<li>整数模 <span class="math inline">\(2^{16}\)</span> 加：<span class="math inline">\(\boxplus\)</span></li>
<li>整数模 <span class="math inline">\(2^{16}+1\)</span> 乘：<span class="math inline">\(\odot\)</span> (IDEA的S盒)</li>
<li>MA 单元 <img src="image-79.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ol></li>
<li>IDEA 的加密
<ul>
<li><p><img src="image-80.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>IDEA 加密一轮迭代过程框图 <img src="image-81.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li>每一轮输入为 64-bit 的数据块，分为 4 个 16-bit 的子块 <span class="math inline">\(X_1, X_2, X_3, X_4\)</span></li>
<li>使用 6 个 16-bit 的子密钥 <span class="math inline">\(Z_{6i+1},
Z_{6i+2}, \ldots, Z_{6i+6}\)</span> 对数据进行处理，产生 4 个 16-bit
的输出子块 <span class="math inline">\(Y_1, Y_2, Y_3,
Y_4\)</span>，作为下一轮的输入</li>
</ul></li>
<li><p>最后一轮后进行输出变换，使用 4 个子密钥 <span class="math inline">\(Z_{49}, Z_{50}, Z_{51}, Z_{52}\)</span>
对数据进行处理，产生最终的密文输出 <img src="image-82.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
</ul></li>
<li>密钥生成
<ul>
<li>52 个 16-bit 的子密钥从 128-bit 的密钥中生成
<ul>
<li>前 8 个子密钥 <span class="math inline">\(Z_1, Z_2, \ldots,
Z_8\)</span> 直接从密钥中取出；</li>
<li>对密钥进行 25-bit 的循环左移，得到接下来 8 个子密钥 <span class="math inline">\(Z_9, Z_{10}, \ldots, Z_{16}\)</span>；</li>
<li>再进行 25-bit 的循环左移，得到接下来的 8 个子密钥 <span class="math inline">\(Z_{17}, Z_{18}, \ldots, Z_{24}\)</span>；</li>
<li>依此类推，重复进行直到 52 个子密钥都产生出来。</li>
</ul></li>
</ul></li>
<li>IDEA 的解密
<ul>
<li>加密解密实质相同，但使用不同的密钥；</li>
<li>解密密钥以如下方法从加密子密钥中导出：
<ul>
<li>解密循环第 <span class="math inline">\(r\)</span> 轮的头 4
个子密钥从加密循环第 <span class="math inline">\(10-r\)</span> 轮的头 4
个子密钥中导出；</li>
<li>每一轮的解密密钥与加密密钥有以下关系：
<ul>
<li>第 1 和第 4 个子密钥取乘法逆元；</li>
<li>第 2 和第 3 个子密钥取加法逆元；</li>
<li>第 5 和第 6 个子密钥直接对应；</li>
</ul></li>
</ul></li>
</ul></li>
<li>IDEA 的安全性
<ul>
<li>IDEA 是 PGP 的一部分；</li>
<li>IDEA 能抗差分分析和相关分析；</li>
<li>IDEA 似乎没有 DES 意义下的弱密钥；</li>
<li>Bruce Schneier 认为 IDEA 是 DES 的最好替代。</li>
</ul></li>
<li>先进分组密码的特点
<ul>
<li>IDEA 是 PGP 的一部分；</li>
<li>可变密钥长度</li>
<li>混合操作</li>
<li>依赖数据的循环移位</li>
<li>依赖于密钥的循环移位</li>
<li>依赖 S 盒</li>
<li>冗长的密钥调度算法</li>
<li>可变的 F 函数和可变的明文/密文长度</li>
<li>可变的循环次数</li>
<li>在每次循环中都对两半数据进行操作</li>
</ul></li>
</ul>
<h3 id="aes">AES</h3>
<ul>
<li>AES (Rijndael) 算法结构
<ul>
<li>Rijndael：可变块长、可变密钥长度</li>
<li>参数：
<ol type="1">
<li><strong>分组长度</strong>：AES的分组长度为128位。</li>
<li><strong>密钥长度</strong>：AES支持多种密钥长度，包括128位、192位和256位。</li>
<li><strong>轮数</strong>：根据密钥长度的不同，AES的轮数也不同：
<ul>
<li>128位密钥：10轮</li>
<li>192位密钥：12轮</li>
<li>256位密钥：14轮</li>
</ul></li>
</ol></li>
<li>不是 Feistel 结构，而是 SPN 结构</li>
<li>单个 8 位到 8 位的 S-盒</li>
</ul></li>
<li>加解密流程图：<img src="image-12.webp" srcset="/img/loading/loading3.gif" lazyload alt="AES 加解密流程图"></li>
<li><strong>轮函数</strong>：Rijndael
的轮函数每一轮迭代的结构都一样，由下述 4
个不同的变换构成，只是最后一轮省略了列混合变换。
<ul>
<li><figure>
<img src="image-84.webp" srcset="/img/loading/loading3.gif" lazyload alt="Rijndael 算法轮函数">
<figcaption aria-hidden="true">Rijndael 算法轮函数</figcaption>
</figure></li>
</ul>
<ol type="1">
<li><strong>字节替换</strong>（SubByte）：对数据的每一字节应用一个非线性变换。
<ul>
<li><figure>
<img src="image-85.webp" srcset="/img/loading/loading3.gif" lazyload alt="AES SubByte">
<figcaption aria-hidden="true">AES SubByte</figcaption>
</figure></li>
<li>矩阵中各字节被固定的 8 位查找表中对应的特定字节所替换。
<ul>
<li><span class="math inline">\(16 \times 16\)</span> 矩阵表中纵向的
<span class="math inline">\(x\)</span> 取自状态矩阵中的高4比特，横向的
<span class="math inline">\(y\)</span> 取自低4比特</li>
</ul></li>
<li>替代的过程如下表， <span class="math inline">\(x\)</span> 行和 <span class="math inline">\(y\)</span> 列的数据就用来替代的数据 <img src="image-13.webp" srcset="/img/loading/loading3.gif" lazyload alt="AES S-box"></li>
</ul></li>
<li><strong>行移位</strong>（ShiftRow）：对每一行的字节循环重新排序。
<ul>
<li>每一行都向左循环位移某个偏移量。属于置换（permutation）运算
<ul>
<li>第 0 行不变</li>
<li>第 1 行循环左移 1 位</li>
<li>第 2 行循环左移 2 位</li>
<li>第 3 行循环左移 3 位</li>
</ul></li>
<li><figure>
<img src="image-14.webp" srcset="/img/loading/loading3.gif" lazyload alt="AES ShiftRow">
<figcaption aria-hidden="true">AES ShiftRow</figcaption>
</figure></li>
</ul></li>
<li><strong>列混合</strong>（MixColumn）：对矩阵的列应用一个线性变换。
<ul>
<li>将状态的每一列视为 <span class="math inline">\(GF(2^8)\)</span>
上多项式 <span class="math inline">\(S(x)\)</span>,
然后和一个固定多项式在模 <span class="math inline">\(x^4+1\)</span>
下相乘，变换公式如下： <span class="math display">\[
  \begin{aligned}
  &amp;S^\prime(x) = a(x) \otimes S(x)\\
  &amp;S^\prime_{0c} = \{02\} \times S_{0c} \oplus \{03\} \times S_{1c}
\oplus \{01\} \times S_{2c} \oplus \{01\} \times S_{3c}\\
  &amp;S^\prime_{1c} = \{01\} \times S_{0c} \oplus \{02\} \times S_{1c}
\oplus \{03\} \times S_{2c} \oplus \{01\} \times S_{3c}\\
  &amp;S^\prime_{2c} = \{01\} \times S_{0c} \oplus \{01\} \times S_{1c}
\oplus \{02\} \times S_{2c} \oplus \{03\} \times S_{3c}\\
  &amp;S^\prime_{3c} = \{03\} \times S_{0c} \oplus \{01\} \times S_{1c}
\oplus \{01\} \times S_{2c} \oplus \{02\} \times S_{3c}
  \end{aligned}
  \]</span>
<ul>
<li>加法：等价于异或 <span class="math inline">\(XOR,
\oplus\)</span>。</li>
<li>乘法：定义为 <span class="math inline">\(GF(2^8)\)</span>
上模不可约多项式 <span class="math inline">\(x^4 +1\)</span>
的乘法。</li>
</ul></li>
<li>此步骤亦可视为 Rijndael 有限域之下的矩阵乘法, <span class="math inline">\(a(x)\)</span> 存在关于 <span class="math inline">\(x^4+1\)</span> 的逆元。</li>
<li><figure>
<img src="image-15.webp" srcset="/img/loading/loading3.gif" lazyload alt="AES MixColumn">
<figcaption aria-hidden="true">AES MixColumn</figcaption>
</figure></li>
</ul></li>
<li><strong>轮密钥加</strong>（AddRoundKey）：把轮密钥混合到中间数据。
<ul>
<li>对状态和轮密钥进行简单的异或运算。</li>
<li>轮密钥是通过密钥调度算法从主密钥中产生，轮密钥长度等于分组长度；</li>
<li>轮密钥加运算需要用到 <span class="math inline">\(4\)</span> 个导出的
<span class="math inline">\(32\)</span> 比特子密钥；</li>
<li><figure>
<img src="image-16.webp" srcset="/img/loading/loading3.gif" lazyload alt="AES AddRoundKey">
<figcaption aria-hidden="true">AES AddRoundKey</figcaption>
</figure></li>
</ul></li>
</ol></li>
<li><strong>轮密钥生成</strong>：
<ul>
<li>AES 使用密钥扩展算法从初始密钥生成每一轮所需的轮密钥。 <img src="image-17.webp" srcset="/img/loading/loading3.gif" lazyload alt="轮密钥生成示意图"></li>
<li>每一轮需要用到 <span class="math inline">\(N_b\)</span>
比特的子密钥，共 <span class="math inline">\(N_r\)</span>
轮，加上第一次轮密钥加时也需要一轮，共 <span class="math inline">\(N_r +
1\)</span> 个子密钥。
<ul>
<li>对于AES-128，<span class="math inline">\(N_b = 128\)</span>，<span class="math inline">\(N_r = 10\)</span>，需要<span class="math inline">\(10 \times 128 + 128=
1408\)</span>比特子密钥。</li>
<li>第 <span class="math inline">\(0\)</span>
轮密钥就是初始密钥本身。</li>
<li>第 <span class="math inline">\(i\)</span> 轮密钥是密钥扩展函数在第
<span class="math inline">\(i-1\)</span> 轮密钥的基础上生成的。</li>
</ul></li>
<li>第 <span class="math inline">\(i-1\)</span> 轮的 <span class="math inline">\(16\)</span> 个字节的子密钥被分成 <span class="math inline">\(4\)</span> 组来处理，每组 <span class="math inline">\(4\)</span> 个字节。
<ul>
<li>最后一组的 <span class="math inline">\(4\)</span>
个字节先执行一个字节的循环左移，由 S 盒（这个 S 盒与字节替代时的 S
盒是一样的）来进行替代处理</li>
<li>然后这 <span class="math inline">\(4\)</span> 个字节结果中的第 <span class="math inline">\(1\)</span>
个字节和轮常数相异或，这个常数是由是预先定义的，可以查表得到： <img src="image-18.webp" srcset="/img/loading/loading3.gif" lazyload alt="常数 a"></li>
<li>最后，为了得到第 <span class="math inline">\(i\)</span>
轮密钥，把得到的 <span class="math inline">\(4\)</span> 个字节的结果和
<span class="math inline">\(i-1\)</span> 轮密钥的最初 <span class="math inline">\(4\)</span> 个字节按位相异或，得到 <span class="math inline">\(i\)</span> 轮密钥的最初 <span class="math inline">\(4\)</span> 个字节</li>
<li>然后又和密钥的接下来 <span class="math inline">\(4\)</span>
个字节按位相异或，得到 <span class="math inline">\(i\)</span>
轮密钥的接下来 <span class="math inline">\(4\)</span>
个字节，以此类推。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="分组密码的工作模式">分组密码的工作模式</h2>
<ul>
<li>定义：分组密码加密固定长度的信息，例如：DES 加密 64-bit，使用 56-bit
密钥，需要一种使用方法，加密任意长度的消息，这种使用方法叫做工作模式（Modes
of Operation）。</li>
<li>分类：
<ul>
<li>Block Modes(分组密码模式)
<ul>
<li>ECB(Electronic Codebook)：电子密码本模式</li>
<li>CBC(Cipher Block Chaining)：密码分组链接模式</li>
</ul></li>
<li>Stream Modes(流密码模式)
<ul>
<li>CFB(Cipher Feedback)：密码反馈模式</li>
<li>OFB(Output Feedback)：输出反馈模式</li>
<li>CTR(Counter)：计数器模式</li>
</ul></li>
</ul></li>
<li>在 CFB、OFB 和 CTR 模式中，仅使用加密算法（不需要解密算法）
<ul>
<li>这就是为什么 Rijndael（AES）针对加密进行了优化</li>
<li>这些模式不应与公钥加密算法一起使用</li>
</ul></li>
</ul>
<h3 id="ecb工作模式-electronic-code-book">ECB工作模式 (Electronic Code
Book)</h3>
<ul>
<li>ECB（electronic
codebook）模式是最简单的运行模式，它将消息分成相互独立的加密模块，每次的加密密钥都相同。</li>
<li>密钥为 <span class="math inline">\(K\)</span>，明文块 <span class="math inline">\(P_1, P_2, \ldots, P_t\)</span>，密文块 <span class="math inline">\(C_1, C_2, \ldots, C_t\)</span>
<ul>
<li>加密：<span class="math inline">\(C_i = E_K[P_i]\)</span></li>
<li>解密：<span class="math inline">\(P_i = D_K[C_i]\)</span></li>
<li><figure>
<img src="image-19.webp" srcset="/img/loading/loading3.gif" lazyload alt="ECB">
<figcaption aria-hidden="true">ECB</figcaption>
</figure></li>
</ul></li>
<li><strong>工作模式特点</strong>：
<ul>
<li>ECB 在用于短数据（如加密密钥）时非常理想，因此如果需要安全地传输 DES
密钥，ECB 是最合适的模式</li>
<li><strong>最大特性</strong>：相同的明文块在相同的密钥下会生成相同的密文块
<ul>
<li>需要加密的消息通常具有非常规则的格式</li>
<li>重复的片段、特殊的头部信息、连续的 0 等是非常常见的</li>
<li>无法隐藏数据模式、不太安全的</li>
</ul></li>
<li>块是独立于其他块进行加密的
<ul>
<li>重新排列密文块会导致相应的明文块重新排列</li>
<li>密文块可以从一条消息中剪切并粘贴到另一条消息中，可能不会被检测到</li>
</ul></li>
<li><strong>错误传播</strong>：密文块中的一个比特错误只会影响相应的明文块（导致生成乱码）</li>
<li>总体而言：不建议用于超过一个块的消息，或者如果密钥被重复用于多个块</li>
</ul></li>
<li>ECB
用于长消息时可能不够安全，如果消息有固定结构，密码分析者有可能找出这种关系。
<ul>
<li>如果已知消息总是以某个预定义字段开始，那么分析者就可能得到很多明文密文对。</li>
<li>如果消息有重复的元素而重复的周期是 64-bit（以 DES
为例）的倍数，那么密码分析者就能够识别这些元素。</li>
</ul></li>
</ul>
<h3 id="cbc工作模式-cipher-block-chaining">CBC工作模式 (Cipher Block
Chaining)</h3>
<ul>
<li>CBC（Cipher Block
Chaining）模式将消息分成模块，加密是相互联系的，每个明文分组在加密前都与前一个密文分组进行异或运算。</li>
<li>密钥为 <span class="math inline">\(K\)</span>，明文块 <span class="math inline">\(P_1, P_2, \ldots, P_t\)</span>，密文块 <span class="math inline">\(C_1, C_2, \ldots, C_t\)</span>，初始向量 <span class="math inline">\(IV\)</span>。
<ul>
<li>加密：CBC
模式一次对一个明文分组加密，每次加密使用同一密钥，加密算法的输入是当前明文分组和前一次密文分组的异或，因此加密算法的输入不会显示出与这次的明文分组之间的固定关系，所以重复的明文分组不会在密文中暴露出这种重复关系。
<span class="math display">\[
  \begin{aligned}
  C_j &amp;=E_{K} [C_{(j-1)} \oplus P_j] \\
  C_0 &amp;=IV
  \end{aligned}
  \]</span></li>
<li>解密：每一个密文分组被解密后，再与前一个密文分组异或以恢复明文分组。
<span class="math display">\[
  \begin{aligned}
  P_j &amp;=D_{K} [C_j] \oplus C_{(j-1)} \\
  &amp;= D_K [E_K [C_{(j-1)} \oplus P_j]] \oplus C_{(j-1)} \\
  &amp;= C_{(j-1)} \oplus P_j \oplus C_{(j-1)} \\
  &amp;= P_j \\
  C_0 &amp;=IV
  \end{aligned}
  \]</span></li>
<li><figure>
<img src="image-20.webp" srcset="/img/loading/loading3.gif" lazyload alt="CBC">
<figcaption aria-hidden="true">CBC</figcaption>
</figure></li>
</ul></li>
<li>初始化向量 <span class="math inline">\(IV\)</span> 的完整性
<ul>
<li>在产生第 1 个密文分组时，需要有一个初始向量 <span class="math inline">\(IV\)</span> 与第 1 个明文分组异或。解密时，<span class="math inline">\(IV\)</span> 和解密算法对第 1
个密文分组的输出进行异或以恢复第 1 个明文分组。</li>
<li><span class="math inline">\(IV\)</span>
对于收发双方都应是己知的，为使安全性最高，<span class="math inline">\(IV\)</span> 应像密钥一样被保护，可使用 ECB
模式来发送 <span class="math inline">\(IV\)</span>。保护 <span class="math inline">\(IV\)</span> 的原因如下： <span class="math display">\[
  \begin{aligned}
  C_1 &amp;= E_K[IV \oplus P_1] \\
  P_1 &amp;= IV \oplus D_K[C_1]
  \end{aligned}
  \]</span></li>
<li>如果攻击者能欺骗接收方使用不同的 <span class="math inline">\(IV\)</span> 值，就能够在明文的第 1
个分组中插入自己选择的比特值，这是因为用 <span class="math inline">\(X(i)\)</span> 表示 64-bit 分组 <span class="math inline">\(X\)</span> 的第 <span class="math inline">\(i\)</span> 个比特，那么 <span class="math inline">\(P_1(i)=IV(i)\oplus
D_K[C_1](i)\)</span>，由异或的性质得 <span class="math inline">\(P_1(i)^\prime = IV(i)^\prime \oplus
D_K[C_1](i)\)</span>，其中撇号 <span class="math inline">\(\prime\)</span> 表示比特补。
<ul>
<li>意味着如果攻击者篡改 <span class="math inline">\(IV\)</span>
中的某些比特，则接收方收到的 <span class="math inline">\(P_1\)</span>
中相应的比特也发生了变化。</li>
</ul></li>
</ul></li>
<li>由于 CBC 模式的链接机制，CBC 模式对加密长于 64
比特的消息非常合适。</li>
<li>CBC 模式除能够获得保密性外，<strong>还能用于认证（生成 MAC
码），进行用户鉴别</strong>。</li>
<li><strong>工作模式特点</strong>
<ul>
<li>在相同密钥 <span class="math inline">\(K\)</span> 但不同初始向量
<span class="math inline">\(IV\)</span>
下加密相同的明文，会生成不同的密文
<ul>
<li>重新排列密文块会影响解密</li>
<li>然而，对先前明文块的依赖仅通过前一个密文块 <span class="math inline">\(C_{(j-1)}\)</span> 实现</li>
<li>正确解密一个密文块仅需要前一个密文块是正确的</li>
</ul></li>
<li><strong>错误传播</strong>：
<ul>
<li>密文块 <span class="math inline">\(C_j\)</span>
中的一个比特错误会影响第 <span class="math inline">\(j\)</span> 个和第
<span class="math inline">\((j+1)\)</span> 个明文块</li>
<li><span class="math inline">\(P_j^\prime\)</span> 完全变为乱码，而
<span class="math inline">\(P_{j+1}^\prime\)</span> 在 <span class="math inline">\(C_j\)</span> 发生错误的比特位置也会出现错误</li>
</ul></li>
</ul></li>
</ul>
<h3 id="cfb工作模式-cipher-feedback">CFB工作模式 (Cipher Feedback)</h3>
<ul>
<li>用于加密字符流，逐个字符处理</li>
<li>消息被看作比特流，被加到分组密文的输出，并把结果反馈到下一阶段</li>
<li>标准允许反馈任意比特 (1,8 or 64 or whatever)，记作 CFB-1, CFB-8,
CFB-64 等</li>
<li>密钥为 <span class="math inline">\(K\)</span>，明文块 <span class="math inline">\(P_1, P_2, \ldots, P_t\)</span>，密文块 <span class="math inline">\(C_1, C_2, \ldots, C_t\)</span>，初始向量 <span class="math inline">\(IV_0\)</span>。以 CFB-64 为例：
<ul>
<li>加密： <span class="math display">\[
  \begin{aligned}
  C_i &amp;= P_i \oplus E_{K}[J_{i}][0:r] \\
  J_{i} &amp;= (J_{i−1}) \ll r \parallel C_{i−1} \\
  J_{1} &amp;= IV_0
  \end{aligned}
  \]</span>
<ul>
<li>设传送的每个单元（如一个字符）是 <span class="math inline">\(r\)</span> 比特长度，通常取 <span class="math inline">\(r=8\)</span>，与 CBC
模式一样，明文单元被链接在一起，使得密文块 <span class="math inline">\(C_m\)</span> 依赖于明文块 <span class="math inline">\(P_m\)</span> 以及所有先前的明文块</li>
<li>方法：
<ul>
<li>加密算法的输入是 64 比特移位寄存器，其初值为某个初始向量 <span class="math inline">\(IV_0\)</span>。</li>
<li>加密算法输出的最左（最高有效位）<span class="math inline">\(r\)</span> 比特与明文的第一个单元 <span class="math inline">\(P_1\)</span> 进行异或，产生密文的第一个单元 <span class="math inline">\(C_1\)</span>，并传送该单元。</li>
<li>然后将移位寄存器的内容左移 <span class="math inline">\(r\)</span>
位并将 <span class="math inline">\(C_1\)</span>
送入送入移位寄存器最右边的 <span class="math inline">\(r\)</span>
位。这一过程一直进行到明文的所有单元都被加密为止。</li>
</ul></li>
</ul></li>
<li>解密： <span class="math display">\[
  \begin{aligned}
  P_i &amp;= C_i \oplus E_{K}[J_{i}][0:r] \\
  J_{i} &amp;= (J_{i−1}) \ll r \parallel C_{i−1} \\
  J_{1} &amp;= IV_0
  \end{aligned}
  \]</span>
<ul>
<li>解密时，将收到的密文单元与加密函数的输出进行异或。</li>
<li><strong>注意这时仍然使用加密算法而不是解密算法</strong></li>
</ul></li>
<li><figure>
<img src="image-21.webp" srcset="/img/loading/loading3.gif" lazyload alt="CFB">
<figcaption aria-hidden="true">CFB</figcaption>
</figure></li>
</ul></li>
<li>CFB 模式除能获得保密性外，还能用于认证。</li>
<li>工作模式特点：
<ul>
<li>适合数据以比特或字节为单位出现</li>
<li>在相同密钥 <span class="math inline">\(K\)</span> 但不同初始向量
<span class="math inline">\(IV\)</span>
下加密相同的明文，会生成不同的密文</li>
<li><span class="math inline">\(IV\)</span> 可以直接发送</li>
<li>密文块 <span class="math inline">\(C_m\)</span> 依赖于明文块 <span class="math inline">\(P_m\)</span> 以及所有先前的明文块
<ul>
<li>重新排列密文块会影响解密。</li>
<li>正确解密一个密文块需要其前 <span class="math inline">\(\lceil n/r
\rceil\)</span> 个密文块是正确的（对于 DES, <span class="math inline">\(n=64\)</span>）。</li>
</ul></li>
<li><strong>错误传播</strong>：
<ul>
<li>密文块 <span class="math inline">\(C_m\)</span>
中的一个比特错误会影响该块及后续 <span class="math inline">\(\lceil n/r
\rceil\)</span> 个密文块的解密（错误会在移位寄存器中持续 <span class="math inline">\(\lceil n/r \rceil\)</span> 步）
<ul>
<li><span class="math inline">\(P_m^\prime\)</span> 在 <span class="math inline">\(C_m\)</span>
发生错误的比特位置也会出现错误，而其他错误的明文块则完全变为乱码</li>
<li>攻击者可能会在第 <span class="math inline">\(m\)</span>
个明文块中引起可预测的比特变化</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="ofb工作模式-output-feedback">OFB工作模式 (Output Feedback)</h3>
<ul>
<li>另一种流加密方法，OFB 是将加密算法的输出反馈到移位寄存器，而 CFB
是将密文单元反馈到移位寄存器</li>
<li>密钥为 <span class="math inline">\(K\)</span>，明文块 <span class="math inline">\(P_1, P_2, \ldots, P_t\)</span>，密文块 <span class="math inline">\(C_1, C_2, \ldots, C_t\)</span>，初始向量 <span class="math inline">\(IV_0\)</span>。以 OFB-64 为例：
<ul>
<li>加密： <span class="math display">\[
  \begin{aligned}
  C_i &amp;= P_i \oplus O_i[0:r] \\
  O_i &amp;= E_{K}[I_i] \\
  I_i &amp;= (I_{i−1}) \ll r \parallel O_{i−1}[0:r] \\
  I_1 &amp;= IV_0
  \end{aligned}
  \]</span></li>
<li>解密： <span class="math display">\[
  \begin{aligned}
  P_i &amp;= C_i \oplus O_i[0:r] \\
  O_i &amp;= E_{K}[I_i] \\
  I_i &amp;= (I_{i−1}) \ll r \parallel O_{i−1}[0:r] \\
  I_1 &amp;= IV_0
  \end{aligned}
  \]</span></li>
<li><figure>
<img src="image-22.webp" srcset="/img/loading/loading3.gif" lazyload alt="OFB">
<figcaption aria-hidden="true">OFB</figcaption>
</figure></li>
</ul></li>
<li>工作模式特点：
<ul>
<li>每条新消息应使用不同的 <span class="math inline">\(IV\)</span>，否则消息将使用相同的密钥流进行加密</li>
<li><span class="math inline">\(IV\)</span> 可以直接发送
<ul>
<li>如果 <span class="math inline">\(IV\)</span>
被攻击者修改，则加密将无法恢复（与 CFB 不同）</li>
</ul></li>
<li>密文块 <span class="math inline">\(C_m\)</span> 仅依赖于明文块 <span class="math inline">\(P_m\)</span>（不依赖于先前的明文块）
<ul>
<li>重新排列密文块会影响解密</li>
</ul></li>
<li><strong>错误传播</strong>：
<ul>
<li>比特错误不会传播，密文块 <span class="math inline">\(C_m\)</span>
中的一个比特错误仅影响该密文块的解密
<ul>
<li><span class="math inline">\(P_m^\prime\)</span> 在 <span class="math inline">\(C_m\)</span> 发生错误的比特位置也会出现错误</li>
<li>攻击者可能会在第 <span class="math inline">\(m\)</span>
个明文块中引起可预测的比特变化</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="ctr工作模式-counter">CTR工作模式 (Counter)</h3>
<ul>
<li>与 CFB、OFB 相似，CTR
将块密码变为流密码，通过递增一个加密计数器以产生连续的密钥流</li>
<li>加/解密过程：
<ul>
<li><figure>
<img src="image-24.webp" srcset="/img/loading/loading3.gif" lazyload alt="加/解密过程">
<figcaption aria-hidden="true">加/解密过程</figcaption>
</figure></li>
</ul></li>
<li>工作模式特点：
<ul>
<li>效率高
<ul>
<li>可并行加密</li>
<li>预处理</li>
<li>吞吐量仅受可使用并行数量的限制</li>
</ul></li>
<li>加密数据块的随机访问</li>
<li>可证明安全</li>
<li>周期长度取决于计数器的大小（通常为 <span class="math inline">\(2^n\)</span>）</li>
<li>第 <span class="math inline">\(i\)</span>
个块可以独立于其他块进行解密
<ul>
<li>可并行化（与 OFB 不同）</li>
<li>支持随机访问</li>
</ul></li>
<li><strong>与明文进行异或运算的值可以预先计算</strong></li>
</ul></li>
</ul>
<h2 id="对称密码算法分析">对称密码算法分析</h2>
<h3 id="强力攻击general-attack">强力攻击（General Attack）</h3>
<ul>
<li>密钥空间穷搜索, 又称穷举攻击</li>
<li>以 DES 为例：
<ul>
<li>64 位密钥，有效密钥长度为 56-bit</li>
<li>密钥有 <span class="math inline">\(2^{56} = 72,057,584,037,927,936 ≈
7.2\)</span> 亿亿</li>
</ul></li>
<li>技术进步使穷举搜索成为可能
<ul>
<li>算力提升</li>
<li>GPU</li>
<li>量子计算</li>
</ul></li>
</ul>
<h3 id="密法分析攻击">密法分析攻击</h3>
<ul>
<li>分类：
<ul>
<li>Ciphertext-only
attack（唯密文攻击）：仅通过观察密文推导出解密密钥或明文。</li>
<li>Known-plaintext
attack（已知明文攻击）：使用一定数量的明文及其对应的密文。</li>
<li>Chosen-plaintext
attack（选择明文攻击）：选择明文并获得相应的密文。</li>
<li>Adaptive chosen-plaintext
attack（自适应选择明文攻击）：选择明文攻击，其中明文的选择可能依赖于先前请求中收到的密文。</li>
<li>Chosen-ciphertext
attack（选择密文攻击）：选择密文并获得相应的明文。</li>
<li>Adaptive chosen-ciphertext
attack（自适应选择密文攻击）：选择密文攻击，其中密文的选择可能依赖于先前请求中收到的明文。</li>
</ul></li>
<li>差分密码分析</li>
</ul>
<h1 id="公钥密码">公钥密码</h1>
<ul>
<li>公钥密码算法，又称非对称密码算法，是指加密和解密使用不同密钥的密码算法。</li>
<li>对称加密体制的缺陷
<ul>
<li>密钥分配问题：通信双方要进行加密通信，需要通过秘密的安全信道来协商加密密钥，而这种安全信道可能很难实现</li>
<li>密钥管理问题：在有多个用户的网络中，任何两个用户之间都需要有共享的秘密钥，当网络中的用户
<span class="math inline">\(n\)</span>
很大时，需要管理的密钥数目是非常大 <span class="math inline">\(n(n−1)/2\)</span></li>
<li>没有签名功能：当主体 A 收到主体 B
的电子文档（电子数据）时，无法向第三方证明此电子文档却是来源于 B</li>
</ul></li>
</ul>
<h2 id="公钥密码体制的基本原理">公钥密码体制的基本原理</h2>
<ul>
<li>Public-Key / Two-key / Asymmetric Cryptography
<ul>
<li>公钥（Public
Key）：加密密钥，任何人都可以知道，用于加密或者验证签名</li>
<li>私钥（Private
Key）：解密密钥，只有密钥拥有者知道，用于解密或者签名</li>
<li>加密或验证签名者不能解密或生成签名</li>
</ul></li>
<li>公钥加密方案 <img src="image-41.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>公钥密码理论：
<ul>
<li>由私钥及其他密码信息容易计算出公钥</li>
<li>由公钥及算法描述，计算出私钥在计算上不可行</li>
<li>由公钥及密文，计算出对应的明文在计算上不可行</li>
<li>因此，公钥可以发布给其他人</li>
<li>密钥分配问题不是一个容易的问题</li>
</ul></li>
<li>公钥算法分类
<ul>
<li>Public-Key Distribution Schemes (PKDS)
<ul>
<li>用于交换秘密信息（依赖于双方主体）</li>
<li>常用于对称加密算法的密钥</li>
</ul></li>
<li>Public-Key Encryption (PKE)
<ul>
<li>用于加密任何消息</li>
<li>任何人可以用公钥加密消息</li>
<li>只有私钥拥有者可以解密消息</li>
<li>任何公钥加密方案能够用于密钥分配方案 PKDS</li>
<li>许多公钥加密方案也是数字签名方案</li>
</ul></li>
<li>Signature Schemes (SS)
<ul>
<li>用于生成对某消息的数字签名</li>
<li>私钥拥有者生成签名</li>
<li>任何人都可以用公钥验证签名</li>
</ul></li>
</ul></li>
<li>公钥的安全性
<ul>
<li>依赖于足够大的困难性差别</li>
<li>类似于对称算法，穷搜索理论上可以破解公钥密码</li>
<li>但实际上，密钥足够长（&gt;512-bit），穷搜索不可行</li>
<li>一般情况下，有一些已知的困难问题</li>
<li>要求足够大的密钥长度（&gt;512-bit）</li>
<li>导致加密速度比对称算法慢</li>
</ul></li>
</ul>
<h2 id="diffie-hellman-密钥交换协议">Diffie-Hellman 密钥交换协议</h2>
<ul>
<li>公钥分配方案
<ul>
<li>不能用于交换任意消息</li>
<li>可以建立共享密钥（双方共享）</li>
<li>依赖于双方的公私钥值</li>
<li>基于有限域上的指数问题</li>
<li>安全性是<strong>基于计算离散对数的困难性</strong></li>
</ul></li>
</ul>
<h3 id="diffie-hellman-setup">Diffie-Hellman Setup</h3>
<ul>
<li>两个通信主体 A 和 B 希望在公开信道上建立密钥</li>
<li>初始化：
<ul>
<li>选择一个大素数 <span class="math inline">\(p\)</span> 和一个生成元
<span class="math inline">\(g\)</span> (<span class="math inline">\(1
&lt; g &lt; p\)</span>)</li>
<li><span class="math inline">\(p\)</span> 和 <span class="math inline">\(g\)</span> 公开</li>
</ul></li>
<li>密钥生成：
<ul>
<li>A 选择一个私钥 <span class="math inline">\(x_A\)</span> (<span class="math inline">\(1 &lt; x_A &lt; p\)</span>)</li>
<li>B 选择一个私钥 <span class="math inline">\(x_B\)</span> (<span class="math inline">\(1 &lt; x_B &lt; p\)</span>)</li>
<li>A 计算公钥 <span class="math inline">\(y_A = g^{x_A} \bmod
p\)</span></li>
<li>B 计算公钥 <span class="math inline">\(y_B = g^{x_B} \bmod
p\)</span></li>
<li>A 和 B 分别公开各自的公钥 <span class="math inline">\(y_A\)</span>
和 <span class="math inline">\(y_B\)</span></li>
</ul></li>
<li>密钥计算：
<ul>
<li>A 计算共享密钥 <span class="math inline">\(K_{AB} = y_B^{x_A} \bmod
p = g^{x_A x_B} \bmod p\)</span></li>
<li>B 计算共享密钥 <span class="math inline">\(K_{AB} = y_A^{x_B} \bmod
p = g^{x_A x_B} \bmod p\)</span></li>
<li>由于模幂运算的性质，A 和 B 计算出的共享密钥 <span class="math inline">\(K_{AB}\)</span> 是相同的</li>
</ul></li>
<li>示例：
<ul>
<li>选取素数 <span class="math inline">\(p=97\)</span>, 及生成元 <span class="math inline">\(g=5\)</span></li>
<li>Alice 选取秘密 <span class="math inline">\(x_A=36\)</span> &amp;
计算公钥 <span class="math inline">\(y_A=5^{36}=50 \bmod
97\)</span></li>
<li>Bob 选取秘密 <span class="math inline">\(x_B=58\)</span> &amp;
计算公钥 <span class="math inline">\(y_B=5^{58}=44 \bmod
97\)</span></li>
<li>Alice and Bob 交换公钥</li>
<li>Alice 计算公享秘密 <span class="math inline">\(K=44^{36}=75 \bmod
97\)</span></li>
<li>Bob 计算公享秘密 <span class="math inline">\(K=50^{58}=75 \bmod
97\)</span></li>
</ul></li>
</ul>
<h3 id="diffie-hellman-in-practice">Diffie-Hellman in Practice</h3>
<ul>
<li>两个主体每次可以选择新的私钥，并计算及交换新的公钥</li>
<li>可以抵挡被动攻击，但不能抵挡主动攻击</li>
<li>每次可以给出一个新的共享密钥</li>
<li>为抵抗主动攻击（如中间人攻击），需要其他新的协议，也可以建立长期公钥</li>
</ul>
<h3 id="man-in-the-middle-attack中间人攻击">Man-in-the-Middle
Attack（中间人攻击）</h3>
<ul>
<li>两个通信主体 A 和 B，以及一个攻击者 E</li>
<li>初始化：
<ul>
<li>选择一个大素数 <span class="math inline">\(p\)</span> 和一个生成元
<span class="math inline">\(g\)</span> (<span class="math inline">\(1
&lt; g &lt; p\)</span>)</li>
<li><span class="math inline">\(p\)</span> 和 <span class="math inline">\(g\)</span> 公开</li>
</ul></li>
<li>密钥生成：
<ul>
<li>A 选择一个私钥 <span class="math inline">\(x_A\)</span> (<span class="math inline">\(1 &lt; x_A &lt; p\)</span>)，计算公钥 <span class="math inline">\(y_A = g^{x_A} \bmod p\)</span></li>
<li>B 选择一个私钥 <span class="math inline">\(x_B\)</span> (<span class="math inline">\(1 &lt; x_B &lt; p\)</span>)，计算公钥 <span class="math inline">\(y_B = g^{x_B} \bmod p\)</span></li>
</ul></li>
<li>密钥计算：
<ul>
<li>A 将公钥 <span class="math inline">\(y_A\)</span> 发送给 B，但被 E
截获
<ul>
<li>E 选择一个私钥 <span class="math inline">\(x_A^\prime\)</span>，计算公钥 <span class="math inline">\(y_A^\prime = g^{x_A^\prime} \bmod p\)</span>
发送给 B</li>
</ul></li>
<li>B 将公钥 <span class="math inline">\(y_B\)</span> 发送给 A，但被 E
截获
<ul>
<li>E 选择一个私钥 <span class="math inline">\(x_B^\prime\)</span>，计算公钥 <span class="math inline">\(y_B^\prime = g^{x_B^\prime} \bmod p\)</span>
发送给 A</li>
</ul></li>
<li>A 和 E 共享密钥 <span class="math inline">\(K_{AE} =
(y_B^\prime)^{x_A} \bmod p = g^{x_A x_B^\prime} \bmod p\)</span></li>
<li>B 和 E 共享密钥 <span class="math inline">\(K_{BE} =
(y_A^\prime)^{x_B} \bmod p = g^{x_A^\prime x_B} \bmod p\)</span></li>
</ul></li>
<li>结果：
<ul>
<li>A 和 E 共享密钥 <span class="math inline">\(K_{AE}\)</span></li>
<li>B 和 E 共享密钥 <span class="math inline">\(K_{BE}\)</span></li>
<li>A 和 B 之间没有共享密钥</li>
</ul></li>
</ul>
<h2 id="rsa">RSA</h2>
<ul>
<li>使用最广泛的公钥加密算法
<ul>
<li>由 Ron Rivest, Adi Shamir 和 Leonard Adleman 在 1977 年提出</li>
<li><strong>基于大整数分解的困难性</strong></li>
</ul></li>
</ul>
<h3 id="rsa-密钥生成">RSA 密钥生成</h3>
<ul>
<li>随机选择两个大素数 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>（&gt;500-bit）
<ul>
<li>计算模数 <span class="math inline">\(n = p \times q\)</span></li>
<li>计算欧拉函数 <span class="math inline">\(\phi(n) =
(p-1)(q-1)\)</span></li>
</ul></li>
<li>随机选择一个加密指数 <span class="math inline">\(e\)</span>，满足
<span class="math inline">\(1 &lt; e &lt; \phi(n)\)</span> 且 <span class="math inline">\(\gcd(e, \phi(n)) = 1\)</span>
<ul>
<li>计算解密指数 <span class="math inline">\(d\)</span>，满足 <span class="math inline">\(d \times e \equiv 1 \bmod \phi(n)\)</span> 且
<span class="math inline">\(1 &lt; d &lt; \phi(n)\)</span></li>
</ul></li>
<li>得到密钥对：
<ul>
<li>公钥为 <span class="math inline">\(K = \{e, n\}\)</span></li>
<li>私钥为 <span class="math inline">\(K^{-1} = \{d, p,
q\}\)</span></li>
</ul></li>
</ul>
<h3 id="rsa-参数选择">RSA 参数选择</h3>
<ul>
<li>需要选择足够大的素数 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>（&gt;500-bit）</li>
<li>通常选择小的加密指数 <span class="math inline">\(e\)</span>，且与
<span class="math inline">\(\phi(n)\)</span> 互质
<ul>
<li>常用 <span class="math inline">\(e\)</span> 的值为 <span class="math inline">\(3, 17, 65537 (= 2^{16} + 1)\)</span></li>
<li><span class="math inline">\(e\)</span> 对所有用户可以是相同的</li>
<li>最初建议使用 <span class="math inline">\(e=3\)</span></li>
</ul></li>
<li>解密指数 <span class="math inline">\(d\)</span> 比较大</li>
</ul>
<h3 id="rsa-加解密算法">RSA 加解密算法</h3>
<ul>
<li>加密：
<ul>
<li>使用公钥 <span class="math inline">\(K = \{e, n\}\)</span></li>
<li>将消息 <span class="math inline">\(M\)</span> 映射为整数 <span class="math inline">\(m\)</span>，满足 <span class="math inline">\(0
\leq m &lt; n\)</span></li>
<li>计算密文 <span class="math inline">\(c = m^e \bmod n\)</span></li>
</ul></li>
<li>解密：
<ul>
<li>使用私钥 <span class="math inline">\(K^{-1} = \{d, p,
q\}\)</span></li>
<li>计算明文 <span class="math inline">\(m = c^d \bmod n\)</span></li>
</ul></li>
<li>示例：
<ol type="1">
<li>选素数 <span class="math inline">\(p=47\)</span> 和 <span class="math inline">\(q=71\)</span>，得 <span class="math inline">\(n=pq=47\times 71=3337\)</span>，<span class="math inline">\(\phi(n)=(p-1)(q-1)=46\times 70=3220\)</span></li>
<li>选择 <span class="math inline">\(e=79\)</span>，求得解密指数 <span class="math inline">\(d=e^{-1}\bmod \phi(n)=1019\)</span></li>
<li>公开公钥 <span class="math inline">\(K=\{n=3337,
e=79\}\)</span>，保留私钥 <span class="math inline">\(K^{-1}=\{d=1019,
p=47, q=71\}\)</span></li>
<li>现要发送明文 <span class="math inline">\(688\)</span>，计算：<span class="math inline">\(688^{79} \bmod 3337=1570\)</span></li>
<li>收到密文 <span class="math inline">\(1570\)</span> 后，用私钥 <span class="math inline">\(d=1019\)</span> 进行解密：<span class="math inline">\(1570^{1019} \bmod 3337=688\)</span></li>
</ol></li>
</ul>
<h3 id="rsa-理论">RSA 理论</h3>
<ul>
<li>基于 Fermat’s Theorem
<ul>
<li>如果 <span class="math inline">\(n = pq\)</span>，其中 <span class="math inline">\(p, q\)</span> 是素数，则有：<span class="math inline">\(x^{(\phi(n))} = 1 \bmod n\)</span>，对于所有与
<span class="math inline">\(n\)</span> 互质的 <span class="math inline">\(x\)</span>，即 <span class="math inline">\(\gcd(x,
n) = 1\)</span>，其中 <span class="math inline">\(\phi(n) =
(p−1)(q−1)\)</span>。</li>
<li>在 RSA 中，<span class="math inline">\(e\)</span> 和 <span class="math inline">\(d\)</span> 是经过特殊选择的：
<ul>
<li>即 <span class="math inline">\(e \cdot d = 1 \bmod \phi(n)\)</span>
或 <span class="math inline">\(e \cdot d = 1 + R \cdot
\phi(n)\)</span>。</li>
</ul></li>
<li>因此可以推导出： <span class="math display">\[
  C^d = M^{(e \cdot d)} = M^{(1 + R \cdot \phi(n))} = M^1 \cdot
(M^{(\phi(n))})^R = M^1 \cdot 1^R = M^1 \bmod n = M
  \]</span></li>
<li>这表明解密后的明文 <span class="math inline">\(M\)</span>
与加密前的明文一致。</li>
</ul></li>
<li>相关理论 <img src="image-42.webp" srcset="/img/loading/loading3.gif" lazyload> <img src="image-43.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>RSA 加密实质上是一种 <span class="math inline">\(\mathbb{Z}_n
\rightarrow \mathbb{Z}_n\)</span> 上的单表代换
<ul>
<li>给定 <span class="math inline">\(n = p \times q\)</span> 和合法明文
<span class="math inline">\(m \in
\mathbb{Z}_n\)</span>，可以唯一地计算出密文 <span class="math inline">\(c = (m^e \bmod n) \in \mathbb{Z}_n\)</span>，对于
<span class="math inline">\(m \neq m^\prime\)</span>，有 <span class="math inline">\(c \neq c^\prime\)</span></li>
<li><span class="math inline">\(\mathbb{Z}_n\)</span>
中的任一元素（<span class="math inline">\(0, p, q\)</span>
的倍数除外）是一个明文，但它也是与某个明文相对应的一个密文。</li>
<li>因此，RSA是 <span class="math inline">\(\mathbb{Z}_n \rightarrow
\mathbb{Z}_n\)</span> 的一种单表代换密码，关键在于 <span class="math inline">\(n\)</span>
极大时在不知陷门信息下极难确定这种对应关系，而用模指数算法又易于实现一种给定的代换。正由于这种一一对应性使RSA不仅可以用于加密也可以用于数字签字。</li>
</ul></li>
</ul>
<h3 id="rsa-的安全性">RSA 的安全性</h3>
<ul>
<li><p>基于大整数分解的困难性</p>
<ul>
<li>需要分解模 <span class="math inline">\(n\)</span> 的素因子 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span>，才能计算出 <span class="math inline">\(\phi(n)\)</span>，进而计算出解密指数 <span class="math inline">\(d\)</span></li>
</ul></li>
<li><p>要求分解模 <span class="math inline">\(n\)</span></p>
<ul>
<li>在理论上，RSA的安全性取决于模 <span class="math inline">\(n\)</span>
分解的困难，但数学上至今还未证明分解模就是攻击RSA的最佳方法，也未证明分解大整数就是NP问题，可能有尚未发现的多项式时间分解算法。</li>
<li>人们完全可以设想有另外的途径破译 RSA，如求解密指数 <span class="math inline">\(d\)</span> 或找到 <span class="math inline">\((p_1-1)(p_2-1)\)</span> 等。</li>
<li>但这些途径都不比分解 <span class="math inline">\(n\)</span>
来得容易。甚至 Alexi 等在 1988 曾揭示，从 RSA 加密的密文恢复某些 bit
的困难性也和恢复整组明文一样困难。</li>
</ul></li>
<li><p>采用广义数域筛选分解不同长度 RSA 公钥模所需的计算机资源</p>
<table>
<thead>
<tr>
<th>密钥长(bit)</th>
<th>所需的MIPS-年</th>
</tr>
</thead>
<tbody>
<tr>
<td>116(Blacknet密钥)</td>
<td>400</td>
</tr>
<tr>
<td>129</td>
<td>5,000</td>
</tr>
<tr>
<td>512</td>
<td>30,000</td>
</tr>
<tr>
<td>768</td>
<td>200,000,000</td>
</tr>
<tr>
<td>1024</td>
<td>300,000,000,000</td>
</tr>
<tr>
<td>2048</td>
<td>300,000,000,000,000,000,000</td>
</tr>
</tbody>
</table>
<ul>
<li>MIPS-年指以每秒执行1,000,000条指令的计算机运行一年</li>
</ul></li>
</ul>
<h3 id="rsa-的实现问题">RSA 的实现问题</h3>
<ul>
<li>需要计算模 300 digits (or 1024+ bits) 的乘法
<ul>
<li>计算机不能直接处理这么大的数（计算速度很慢）</li>
<li>需要考虑其它技术，加速 RSA 的实现</li>
</ul></li>
<li>RSA 的快速实现
<ul>
<li>加密很快，指数小</li>
<li>解密比较慢，指数较大</li>
<li>利用中国剩余定理 CRT：对 RSA 解密算法生成两个解密方程（利用 <span class="math inline">\(M = C^d \bmod R\)</span> ）
<ul>
<li>即： <span class="math display">\[
  \begin{aligned}
  M_1 = M \bmod p\\
  M_2 = M \bmod q
  \end{aligned}
  \]</span></li>
<li>解方程： <span class="math display">\[
  \begin{aligned}
  M = M_1 \bmod p\\
  M = M_2 \bmod q
  \end{aligned}
  \]</span></li>
<li>具有唯一解（利用 CRT）：<span class="math inline">\(M = (q \cdot
q' \cdot M_1 + p \cdot p' \cdot M_2) \bmod R\)</span>
<ul>
<li>其中 <span class="math inline">\(q \cdot q' \bmod p = 1 ,   p
\cdot p' \bmod q = 1\)</span></li>
</ul></li>
</ul></li>
<li><figure>
<img src="image-46.webp" srcset="/img/loading/loading3.gif" lazyload alt="中国剩余定理">
<figcaption aria-hidden="true">中国剩余定理</figcaption>
</figure></li>
</ul></li>
</ul>
<h2 id="rabin">RABIN</h2>
<ul>
<li><strong>第一个可证安全的公钥加密方案</strong></li>
<li><strong>基于模合数下求平方根的困难性，即二次剩余问题</strong></li>
<li>说明：
<ul>
<li>二次剩余问题，给定一个奇合数 <span class="math inline">\(n\)</span>
和整数 <span class="math inline">\(a\)</span>，判断 <span class="math inline">\(a\)</span> 是否为 <span class="math inline">\(\bmod n\)</span>
的平方剩余或二次剩余，即判断是否存在整数 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(x^2
\equiv a \bmod n\)</span></li>
<li>模 <span class="math inline">\(n\)</span> 的平方根问题(SQROOT)，在
<span class="math inline">\(n\)</span> 的分解未知的情况下，求模 <span class="math inline">\(n\)</span> 的平方根，即求解同余式 <span class="math inline">\(x^2 \equiv a \bmod n\)</span></li>
<li>在模 <span class="math inline">\(n = pq\)</span>
的分解未知情况下，上述问题均为困难问题</li>
</ul></li>
<li>进一步说明：
<ul>
<li>RSA 的破译难度不超过大数分解</li>
<li>Rabin 的提出是对 RSA 的一种修正</li>
<li>可以证明对它的破译等价于对 <span class="math inline">\(n\)</span>
的分解</li>
<li>RSA 是选择加密密钥 <span class="math inline">\(e\)</span> 满足 <span class="math inline">\(1 &lt; e &lt; \phi(n)\)</span> 且 <span class="math inline">\((e, \phi(n)) = 1\)</span>，Rabin 是取 <span class="math inline">\(e = 2\)</span></li>
</ul></li>
</ul>
<h3 id="二次剩余的概念">二次剩余的概念</h3>
<ul>
<li>令 <span class="math inline">\(QR_n\)</span> 表示模 <span class="math inline">\(n\)</span> 的二次剩余集合，<span class="math inline">\(QR_n \triangleq \{a \mid \exists x \in Z, x^2
\equiv a \bmod n\}\)</span>
<ul>
<li><span class="math inline">\(Z\)</span> 表示整数集合</li>
<li>即若存在 <span class="math inline">\(x \in Z\)</span> 满足 <span class="math inline">\(x^2 \equiv a \bmod n\)</span>，则称 <span class="math inline">\(a \in QR_n\)</span>，表 <span class="math inline">\(a\)</span> 为模 <span class="math inline">\(n\)</span> 的二次剩余，否则 <span class="math inline">\(a \notin QR_n\)</span> 或称 <span class="math inline">\(a\)</span> 为非二次剩余。非二次剩余集合用 <span class="math inline">\(NQR_n\)</span> 表示它。</li>
</ul></li>
<li><strong>定理1</strong>：假定 <span class="math inline">\(n = p_1
p_2\)</span>，<span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_2\)</span> 是不相同的素数，<span class="math inline">\(Z_n\)</span> 中有 <span class="math inline">\((p_1−1)(p_2−1)/4\)</span> 个元素属于 <span class="math inline">\(QR_n\)</span>，每个属于 <span class="math inline">\(QR_n\)</span> 的元素有 <span class="math inline">\(4\)</span> 个平方根。</li>
<li><strong>定理2</strong>：若 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\gamma\)</span> 属于本质上不同的 <span class="math inline">\(\beta\)</span> 的平方根, 且 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\gamma\)</span> 为小于 <span class="math inline">\(n/2\)</span> 的正整数，<span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\gamma\)</span> 满足 <span class="math inline">\(x^2 \equiv \beta \bmod n\)</span>，则 <span class="math inline">\(\gcd(\alpha+\gamma,n)=p_1\)</span>, 或 <span class="math inline">\(\gcd(\alpha+\gamma,n)=p_2\)</span>,
其中必有一式成立。</li>
</ul>
<h3 id="rabin-密钥生成">RABIN 密钥生成</h3>
<ul>
<li>令 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span> 是两个素数，在模 4 下与 3 同余（即
<span class="math inline">\(p \bmod 4 = q \bmod 4 = 3\)</span>），计算
<span class="math inline">\(n=pq\)</span>（这样的 <span class="math inline">\(n\)</span> 称为 blum 整数）。</li>
<li>公钥为 <span class="math inline">\(K=\{n\}\)</span></li>
<li>私钥为 <span class="math inline">\(K^{-1}=\{p,q\}\)</span></li>
</ul>
<h3 id="rabin-加解密算法">RABIN 加解密算法</h3>
<ul>
<li>加密：设 <span class="math inline">\(M\)</span>
为待加密消息，计算密文 <span class="math display">\[
  C=M^2 \bmod n, \quad 0 \leq M &lt; n
  \]</span></li>
<li>解密：计算 <span class="math display">\[
  \begin{aligned}
  &amp;\begin{cases}
  W_1 = C^{(p+1)/4} \bmod p \\
  W_2 = p - C^{(p+1)/4} \bmod p \\
  W_3 = C^{(q+1)/4} \bmod q \\
  W_4 = q - C^{(q+1)/4} \bmod q
  \end{cases} \\
  &amp;\begin{cases}
  u = q \cdot (q^{-1} \bmod p) \\
  v = p \cdot (p^{-1} \bmod q)
  \end{cases} \\
  &amp;\begin{cases}
  M_1 = (u \cdot W_1 + v \cdot W_3) \bmod n \\
  M_2 = (u \cdot W_1 + v \cdot W_4) \bmod n \\
  M_3 = (u \cdot W_2 + v \cdot W_3) \bmod n \\
  M_4 = (u \cdot W_2 + v \cdot W_4) \bmod n
  \end{cases}
  \end{aligned}
  \]</span>
<ul>
<li>利用中国剩余定理，可以得到 <span class="math inline">\(4\)</span>
个解 <span class="math inline">\(M_1, M_2, M_3,
M_4\)</span>，其中必有一个与 <span class="math inline">\(M\)</span>
相同，若 <span class="math inline">\(M\)</span> 是文字消息则易于识别；若
<span class="math inline">\(M\)</span> 是随机数字流，则无法确定哪一个
<span class="math inline">\(M_i\)</span> 是正确的消息。</li>
</ul></li>
<li>定理： <img src="image-44.webp" srcset="/img/loading/loading3.gif" lazyload> <img src="image-45.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h3 id="rabin-的安全性">RABIN 的安全性</h3>
<ul>
<li>定理：设 <span class="math inline">\(n=pq\)</span>, <span class="math inline">\(p\)</span>、<span class="math inline">\(q\)</span>
为blum整数，<span class="math inline">\(x^2 \equiv a \bmod n\)</span>
有解，则求解该同余式等价于分解大整数 <span class="math inline">\(n\)</span>
<ul>
<li>证明：
<ul>
<li>原同余式等价于 <span class="math display">\[
  \begin{aligned}
  x^2 \equiv a \bmod p \\
  x^2 \equiv a \bmod q
  \end{aligned}
  \]</span></li>
<li>若能求出四个解 <span class="math inline">\(x_1, -x_1, x_2,
-x_2\)</span>，且 <span class="math inline">\(x_1\)</span> 和 <span class="math inline">\(x_2\)</span> 模 <span class="math inline">\(n\)</span> 不同余且为小于 <span class="math inline">\(n/2\)</span> 的正整数，则由 <span class="math inline">\(x_1^2 \equiv a \bmod p\)</span> 和 <span class="math inline">\(x_2^2 \equiv a \bmod q\)</span> 可得 <span class="math inline">\(x_1 \equiv x_2 \bmod n\)</span>，而 <span class="math inline">\(x_1 + x_2 &lt; n\)</span>, 不可能为 <span class="math inline">\(n\)</span> 的倍数，所以 <span class="math inline">\(x_1 - x_2\)</span> 和 <span class="math inline">\(x_1 + x_2\)</span> 分别含有 <span class="math inline">\(n\)</span> 的一个因子，也即 <span class="math display">\[
  \begin{aligned}
  \gcd(x_1 - x_2, n)\\
  \gcd(x_1 + x_2, n)
  \end{aligned}
  \]</span></li>
<li>因此就相当于分解了整数 <span class="math inline">\(n\)</span>。</li>
<li>反之，如果知道 <span class="math inline">\(n\)</span>
的分解，则类似于解密过程可将同余式的四个解求出来</li>
</ul></li>
</ul></li>
<li>等价于对 <span class="math inline">\(n\)</span> 的因数分解
<ul>
<li>选择密文攻击不安全</li>
<li>对 Rabin 签名的选择密文攻击可以描述如下：攻击者首先随机选取整数
<span class="math inline">\(r\)</span> ，并且计算 <span class="math inline">\(C = r^2 \bmod
n\)</span>；如果攻击者能够成功骗取签名者对 <span class="math inline">\(m\)</span> 进行签名，他将能够以 1/2 的概率从签名
<span class="math inline">\(s\)</span> 和 <span class="math inline">\(x\)</span> 中破解 <span class="math inline">\(n\)</span> 的分解。</li>
<li>因为签名者不知道 <span class="math inline">\(x\)</span>，对 <span class="math inline">\(m\)</span> 的签名 <span class="math inline">\(s\)</span> 若不同于 <span class="math inline">\(x\)</span>，即 <span class="math inline">\(s
\not\equiv x \bmod n\)</span>，则由定理2可从 <span class="math inline">\(\gcd(s+x,n)\)</span> 得到 <span class="math inline">\(n\)</span> 的素数因子 <span class="math inline">\(p_1\)</span> 或 <span class="math inline">\(p_2\)</span>。</li>
</ul></li>
</ul>
<h3 id="rsa-vs-rabin">RSA VS RABIN</h3>
<ul>
<li>安全性</li>
<li>加密
<ul>
<li>Rabin 仅一次乘法运算</li>
</ul></li>
<li>解密
<ul>
<li>Rabin 解密比 RSA 困难，解密过程要解一个求平方根的问题，当 <span class="math inline">\((p_1−1)/2\)</span> 和 <span class="math inline">\((p_2−1)/2\)</span>
为奇数，要做两次幂运算，还要解中国剩余定理</li>
</ul></li>
</ul>
<h2 id="elgamal">ElGamal</h2>
<ul>
<li>Diffie-Hellman key distribution scheme 的变形
<ul>
<li>能够用于安全交换密钥</li>
<li>1985年由ElGamal提出</li>
<li>安全性是<strong>基于求解离散对数问题的困难性</strong></li>
<li>缺点：增加了消息长度（2倍）</li>
</ul></li>
</ul>
<h3 id="elgamal-密钥生成">ElGamal 密钥生成</h3>
<ul>
<li>选取一个大素数 <span class="math inline">\(p\)</span> 及生成元 <span class="math inline">\(g\)</span></li>
<li>随机选取一个私钥 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(0 &lt; x &lt; p-1\)</span>
<ul>
<li>计算公钥 <span class="math inline">\(y = g^{x} \bmod p\)</span></li>
</ul></li>
<li>公钥为 <span class="math inline">\(K = \{p, g, y\}\)</span></li>
<li>私钥为 <span class="math inline">\(K^{-1} = \{x\}\)</span></li>
</ul>
<h3 id="elgamal-加解密算法">ElGamal 加解密算法</h3>
<ul>
<li>为加密 <span class="math inline">\(M\)</span>:
<ul>
<li><strong>发送者</strong>选择随机数 <span class="math inline">\(k，0
&lt; k &lt; p−1\)</span>，<span class="math inline">\(k\)</span>
需要永久保密或销毁</li>
<li>计算消息密钥 <span class="math inline">\(K\)</span>： <span class="math display">\[
  K = y^k \bmod p
  \]</span></li>
<li>计算密文对：<span class="math inline">\(C =
\{C_1,C_2\}\)</span>，并发送到接收者 <span class="math display">\[
  \begin{aligned}
  C_1 &amp;= g^k \bmod p\\
  C_2 &amp;= KM \bmod p
  \end{aligned}
  \]</span></li>
</ul></li>
<li>为解密 <span class="math inline">\(C = \{C_1,C_2\}\)</span>:
<ul>
<li><strong>接收者</strong>首先计算 <span class="math inline">\(K\)</span> <span class="math display">\[
  K = C_1^{x} \bmod p = g^{(k\cdot x)} \bmod p = y^k \bmod p
  \]</span></li>
<li>然后利用费马小定理计算 <span class="math inline">\(K^{-1}\)</span>:
<span class="math display">\[
  K^{-1} = K^{p-2} \bmod p
  \]</span></li>
<li>计算明文 <span class="math inline">\(M\)</span>: <span class="math display">\[
  M = C_2\cdot K^{-1} \bmod p
  \]</span></li>
</ul></li>
<li>示例：
<ul>
<li>选择 <span class="math inline">\(p=97\)</span> 以及生成元 <span class="math inline">\(g=5\)</span></li>
<li>接收者 Bob：
<ul>
<li>选择私钥 <span class="math inline">\(x_B=58\)</span></li>
<li>计算并发布公钥 <span class="math inline">\(y_B=5^{58} \bmod 97 =
44\)</span></li>
</ul></li>
<li>Alice 要加密 <span class="math inline">\(M=3\)</span>
<ul>
<li>首先得到 Bob 的公开密钥 <span class="math inline">\(y_B=44\)</span></li>
<li>选择随机 <span class="math inline">\(k=36\)</span> 计算: <span class="math inline">\(K=44^{36} \bmod 97 = 75\)</span></li>
<li>计算密文对: <span class="math display">\[
  \begin{aligned}
  C_1 &amp;= g^k \bmod p = 5^{36} \bmod 97 = 50\\
  C_2 &amp;= K\cdot M \bmod p = 75\cdot 3 \bmod 97 = 31
  \end{aligned}
  \]</span></li>
<li>发送 <span class="math inline">\(\{50,31\}\)</span> 给 Bob</li>
</ul></li>
<li>Bob 接收密文 <span class="math inline">\(\{50,31\}\)</span>
<ul>
<li>恢复 <span class="math inline">\(K=50^{58} \bmod 97 =
75\)</span></li>
<li>计算 <span class="math inline">\(K^{-1} = 22 \bmod 97\)</span></li>
<li>恢复明文 <span class="math inline">\(M = (31\cdot 22) \bmod 97 =
3\)</span></li>
</ul></li>
</ul></li>
</ul>
<h2 id="ecc">ECC</h2>
<ul>
<li>椭圆曲线密码体制（Elliptic Curve Cryptography，ECC）
<ul>
<li>于 1985 年，由 Neal Koblitz 和 Victor Miller 分别独立提出</li>
<li>数学难题：<strong>基于椭圆曲线的离散对数难题</strong></li>
<li>ECC 算法所需的密钥长度远比 RSA 算法低</li>
<li>有研究指出，ECC 算法 160-bit 密钥长度所提供的安全性，与 RSA 算法
1024-bit 密钥所提供的安全性相当</li>
</ul></li>
</ul>
<h3 id="椭圆曲线的概念">椭圆曲线的概念</h3>
<ul>
<li>椭圆曲线（Elliptic Curve）
<ul>
<li>由于连续的椭圆曲线，并不适合进行加解密操作，因此考虑将其定义在有限域上</li>
<li>域的定义：
<ul>
<li>可以在其上进行加、减、乘、除运算，而结果不会超出其范围的集合</li>
<li>有理数域、实数域、复数域，但整数集合不是</li>
</ul></li>
<li>有限域的定义：
<ul>
<li>域 <span class="math inline">\(F\)</span>
只包含有限个元素。有限域中元素的个数称为阶</li>
<li>每个有限域的阶必为素数的幂，即有限域的阶可表示为 <span class="math inline">\(p^n\)</span></li>
<li>该有限域通常称为 Galois 域，记为 <span class="math inline">\(GF(p^n)\)</span></li>
</ul></li>
</ul></li>
<li>通信双方（A和B）共享一套公开的椭圆曲线参数，包括曲线方程（如 <span class="math inline">\(y^2 = x^3 + ax + b\)</span>）、一个公开基点 <span class="math inline">\(G\)</span>，以及 <span class="math inline">\(G\)</span> 的阶 <span class="math inline">\(p\)</span>（最小正整数 <span class="math inline">\(n\)</span> 满足 <span class="math inline">\(nG=O\)</span>，<span class="math inline">\(O\)</span> 为无穷远点）</li>
<li>椭圆曲线的核心数学基础：
<ul>
<li>在有限域上的椭圆曲线定义“点加”和“点乘”</li>
<li>点乘是核心——即一个整数（私钥）与曲线上一个固定点（基点G）进行多次点加，得到曲线上另一个点（公钥）。该过程“正向易、反向难”，是安全性的根本</li>
</ul></li>
<li>椭圆曲线（Elliptic Curve）
<ul>
<li>椭圆曲线方程计算公式 <span class="math display">\[
  y^2 \equiv x^3 + ax + b \bmod p
  \]</span></li>
<li>椭圆曲线上的点加法
<ul>
<li>设 <span class="math inline">\(P(x_1,y_1)\)</span> 和 <span class="math inline">\(Q(x_2,y_2)\)</span> 是椭圆曲线 <span class="math inline">\(E\)</span> 上的两个点，定义点加运算 <span class="math inline">\(R = P + Q\)</span> 如下：
<ul>
<li>若 <span class="math inline">\(P \neq Q\)</span>，则连接 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span> 的直线与曲线 <span class="math inline">\(E\)</span> 相交于第三个点 <span class="math inline">\(R^\prime\)</span>，则 <span class="math inline">\(R\)</span> 是 <span class="math inline">\(R^\prime\)</span> 关于 <span class="math inline">\(x\)</span> 轴的对称点</li>
<li>若 <span class="math inline">\(P = Q\)</span>，则过点 <span class="math inline">\(P\)</span> 的切线与曲线 <span class="math inline">\(E\)</span> 相交于另一个点 <span class="math inline">\(R^\prime\)</span>，则 <span class="math inline">\(R\)</span> 是 <span class="math inline">\(R^\prime\)</span> 关于 <span class="math inline">\(x\)</span> 轴的对称点</li>
</ul></li>
<li>数学表达：设 <span class="math inline">\(P = (x_1,
y_1)\)</span>，<span class="math inline">\(Q = (x_2, y_2)\)</span>，则
<ul>
<li>若 <span class="math inline">\(x_1 = x_2\)</span> 且 $y_1 = -y_2
$，则 <span class="math inline">\(P + Q = O\)</span>（无穷远点），记
<span class="math inline">\(P=-Q\)</span></li>
<li>否则，设 <span class="math inline">\(R = P + Q = (x_3,
y_3)\)</span>，则 <span class="math display">\[
  \begin{aligned}
  &amp;x_3 = \lambda^2 - x_1 - x_2 \bmod p \\
  &amp;y_3 = \lambda(x_1 - x_3) - y_1 \bmod p \\
  &amp;\lambda =
  \begin{cases}
  \frac{y_2 - y_1}{x_2 - x_1} \bmod p, &amp; x_1 \neq x_2 \\
  \frac{3x_1^2 + a}{2y_1} \bmod p, &amp; x_1 = x_2, y_1 \neq 0 \\
  \end{cases}
  \end{aligned}
  \]</span></li>
</ul></li>
<li>点加法满足交换律和结合律</li>
</ul></li>
<li>椭圆曲线上的点乘法
<ul>
<li>设 <span class="math inline">\(P\)</span> 是椭圆曲线 <span class="math inline">\(E\)</span> 上的一个点，<span class="math inline">\(k\)</span> 是一个整数，定义点乘运算 <span class="math inline">\(Q = kP\)</span> 如下：
<ul>
<li>若 <span class="math inline">\(k = 0\)</span>，则 <span class="math inline">\(Q\)</span> 是无穷远点 <span class="math inline">\(O\)</span></li>
<li>若 <span class="math inline">\(k &gt; 0\)</span>，则 <span class="math inline">\(Q\)</span> 是将点 <span class="math inline">\(P\)</span> 自身加 <span class="math inline">\(k\)</span> 次的结果，即在 <span class="math inline">\(P\)</span> 点作切线交于曲线并取关于 <span class="math inline">\(x\)</span> 轴对称点 <span class="math inline">\(P_1\)</span>，重复 <span class="math inline">\(k\)</span> 次得到 <span class="math inline">\(Q =
P_k\)</span></li>
<li>若 <span class="math inline">\(k &lt; 0\)</span>，则 <span class="math inline">\(Q\)</span> 是将点 <span class="math inline">\(-P\)</span> 自身加 <span class="math inline">\(|k|\)</span> 次的结果，即取 <span class="math inline">\(P\)</span> 关于 <span class="math inline">\(x\)</span> 轴的对称点 <span class="math inline">\(-P\)</span>，重复 <span class="math inline">\(|k|\)</span> 次得到 <span class="math inline">\(Q
= P_{|k|}\)</span></li>
</ul></li>
<li>点乘法满足分配律和结合律</li>
</ul></li>
</ul></li>
</ul>
<h3 id="ecc-密钥生成">ECC 密钥生成</h3>
<ol type="1">
<li>公开参数
<ul>
<li>选取定义在有限域 <span class="math inline">\(GF(p)\)</span>
上的椭圆曲线 <span class="math inline">\(E_p(a,b):
y^2=x^3+ax+b\)</span></li>
<li>选取椭圆曲线上一点作为基点 <span class="math inline">\(G(x_G,y_G)\)</span>（公开固定点，类似 DH 中的
<span class="math inline">\(g\)</span>）</li>
<li>有限域的模值 <span class="math inline">\(p\)</span> （类似 DH
中的大质数 <span class="math inline">\(p\)</span>）</li>
</ul></li>
<li>公私钥生成
<ul>
<li>选定一个大数 <span class="math inline">\(x\)</span> 作为私钥</li>
<li>生成公钥 <span class="math inline">\(Q=xG\)</span> （类似 DH 中的
<span class="math inline">\(y=g^x\)</span>）</li>
<li>公钥为 <span class="math inline">\(K = \{p, G, Q\}\)</span></li>
<li>私钥为 <span class="math inline">\(K^{-1} = \{x\}\)</span></li>
</ul></li>
</ol>
<h3 id="ecc-加解密算法">ECC 加解密算法</h3>
<ul>
<li>加密
<ul>
<li>选取一个随机数 <span class="math inline">\(k\)</span>，<span class="math inline">\(1 &lt; k &lt; p-1\)</span></li>
<li>对于要加密的明文 <span class="math inline">\(M\)</span>，分别计算：
<span class="math display">\[
  \begin{aligned}
  R &amp;= kG \\
  K &amp;= kQ \\
  S &amp;= M + K
  \end{aligned}
  \]</span></li>
<li>生成密文 <span class="math inline">\(C=(R, S)\)</span></li>
</ul></li>
<li>解密
<ul>
<li>接收密文 <span class="math inline">\(C=(R, S)\)</span></li>
<li>计算： <span class="math display">\[
  \begin{aligned}
  T &amp;= xR ~(= x(kG) = k(xG) = kQ = K) \\
  M &amp;= S - T ~(= S - K = M)
  \end{aligned}
  \]</span></li>
</ul></li>
</ul>
<h3 id="ecc-vs-rsa">ECC VS RSA</h3>
<ul>
<li>与 RSA 相比，ECC 在许多方面都有优势：
<ul>
<li>抗攻击性强。相同的密钥长度，其抗攻击性要比 RSA 强很多倍。</li>
<li>计算量小，处理速度快。ECC 总的速度比 RSA 要快。</li>
<li>存储空间占用小。</li>
</ul></li>
</ul>
<h3 id="ecc-的应用">ECC 的应用</h3>
<ul>
<li>ECC 的签名算法：ECDSA</li>
<li>ECC 与 DH 算法的结合：ECDH、ECDHE</li>
<li>增强的密钥交换算法：ECMQV</li>
<li>国密标准公钥加密算法：SM2</li>
</ul>
<h4 id="ecdsa">ECDSA</h4>
<ul>
<li>基于 ECC 的签名算法：ECDSA（Elliptic Curve Digital Signature Alg）
<ul>
<li>不同于 ECC，ECDSA 主要目的是确保消息 M 不被篡改和伪装</li>
<li>ECDSA 不对消息 M 进行加密，因此无法保证其机密性</li>
<li>ECDSA 的密钥生成过程与 ECC 相同</li>
<li>基础思路：使用私钥进行签名，使用公钥进行验签</li>
</ul></li>
<li>ECDSA 签名与验签算法
<ul>
<li>使用椭圆曲线参数 <span class="math inline">\(E_p(a,b):
y^2=x^3+ax+b\)</span>，基点 <span class="math inline">\(G\)</span>，以及私钥 <span class="math inline">\(x\)</span> 和公钥 <span class="math inline">\(Q=xG\)</span></li>
<li>签名算法
<ol type="1">
<li>计算消息摘要 <span class="math inline">\(h=H(M)\)</span></li>
<li>计算签名 <span class="math inline">\(s=xh\)</span></li>
<li>输出消息签名对 <span class="math inline">\((M,s)\)</span></li>
</ol></li>
<li>验签算法
<ol type="1">
<li>计算消息摘要 <span class="math inline">\(h=H(M)\)</span></li>
<li>计算 <span class="math inline">\(sG\)</span> 和 <span class="math inline">\(hQ\)</span></li>
<li>若 <span class="math inline">\(sG =
hQ\)</span>，则签名有效；否则签名无效</li>
</ol></li>
</ul></li>
</ul>
<h4 id="ecdh-与-ecdhe">ECDH 与 ECDHE</h4>
<ul>
<li>基于 ECC 的密钥分配（交换）算法：
<ul>
<li>ECDH：Elliptic Curve Diffie-Hellman</li>
<li>ECDHE：Elliptic Curve Diffie-Hellman Ephemeral</li>
</ul></li>
<li>与传统 D-H 方案相同，该方案不能用于交换任意信息
<ul>
<li>传统 D-H 方案基于有限域上的离散对数计算困难问题</li>
<li>ECDH、ECDHE 基于有限域上椭圆曲线离散对数计算困难问题</li>
</ul></li>
<li>ECDH 密钥交换算法
<ol type="1">
<li>双方公开椭圆曲线参数 <span class="math inline">\(E_p(a,b):
y^2=x^3+ax+b\)</span>，基点 <span class="math inline">\(G\)</span></li>
<li>双方生成各自的公私钥对 <span class="math inline">\((x_A,
Q_A=x_AG)\)</span> 和 <span class="math inline">\((x_B,
Q_B=x_BG)\)</span></li>
<li>双方交换公钥 <span class="math inline">\(Q_A\)</span> 和 <span class="math inline">\(Q_B\)</span></li>
<li>双方分别计算共享密钥： <span class="math display">\[
\begin{aligned}
K_A &amp;= x_A Q_B = x_A (x_B G) \\
K_B &amp;= x_B Q_A = x_B (x_A G) \\
K_A &amp;= K_B
\end{aligned}
\]</span></li>
</ol></li>
<li>ECDHE 密钥交换算法
<ul>
<li>与 ECDH 相同，但每次会话使用不同的临时密钥对 <span class="math inline">\((x_A^\prime, Q_A^\prime=x_A^\prime G)\)</span> 和
<span class="math inline">\((x_B^\prime, Q_B^\prime=x_B^\prime
G)\)</span></li>
<li>提供<strong>前向保密性</strong>：即使服务器存储的长期私钥泄露，也不会影响历史通信的安全</li>
</ul></li>
<li>ECDH、ECDHE、DH、DHE 的比较
<ul>
<li>ECDH 无法提供前向安全性，ECDHE 则解决了这一缺点</li>
<li>ECDHE 由于生成了多轮密钥，因此需要服务器提供密钥管理功能</li>
<li>DH 也可以提供类似的算法 DHE</li>
<li>DHE 由于密钥长度、需要大量乘法运算等原因，性能很差</li>
</ul></li>
<li>ECDHE 由于其良好的运算性能及安全性，目前在工业界广泛应用
<ul>
<li>TLS 1.2+</li>
<li>WPA3 SAE(Simultaneous Authentication of Equals)
对等实体同时验证</li>
</ul></li>
</ul>
<h4 id="ecmqv">ECMQV</h4>
<ul>
<li>基于 ECC 的增强型密钥交换算法：ECMQV（Elliptic Curve
Menezes-Qu-Vanstone）</li>
<li>引入可信中心，获取通信双方的公钥 <span class="math inline">\(Q_a,
Q_b\)</span> 及私钥 <span class="math inline">\(k_a, k_b\)</span> 分别为
Alice 和 Bob 的私钥</li>
<li>ECMQV 密钥交换算法
<ol type="1">
<li>选择椭圆曲线参数 <span class="math inline">\(E_p(a,b):
y^2=x^3+ax+b\)</span>，基点 <span class="math inline">\(G\)</span></li>
<li>Alice 选择随机数 <span class="math inline">\(r_a\)</span>，计算临时公钥 <span class="math inline">\(R_a = r_a G\)</span>，并发送给 Bob，计算 <span class="math inline">\(R_a\)</span> 的 <span class="math inline">\(x\)</span> 坐标 <span class="math inline">\(\overline{R_a}\)</span></li>
<li>Bob 选择随机数 <span class="math inline">\(r_b\)</span>，计算临时公钥 <span class="math inline">\(R_b = r_b G\)</span>，并发送给 Alice，计算 <span class="math inline">\(R_b\)</span> 的 <span class="math inline">\(x\)</span> 坐标 <span class="math inline">\(\overline{R_b}\)</span></li>
<li>Alice 验证 <span class="math inline">\(R_b\)</span>，计算其 <span class="math inline">\(x\)</span> 坐标 <span class="math inline">\(\overline{R_b}\)</span>，计算共享密钥： <span class="math display">\[
\begin{aligned}
&amp;s_a = r_a + \overline{R_b} k_a \bmod p \\
&amp;K_{a,b} = s_a (Q_b + \overline{R_b} R_b)
\end{aligned}
\]</span></li>
<li>Bob 验证 <span class="math inline">\(R_a\)</span>，计算其 <span class="math inline">\(x\)</span> 坐标 <span class="math inline">\(\overline{R_a}\)</span>，计算共享密钥： <span class="math display">\[
\begin{aligned}
&amp;s_b = r_b + \overline{R_a} k_b \bmod p \\
&amp;K_{b,a} = s_b (Q_a + \overline{R_a} R_a)
\end{aligned}
\]</span></li>
<li>由于 <span class="math inline">\(K_{a,b} = K_{b,a}\)</span>，因此
Alice 和 Bob 获得相同的共享密钥</li>
</ol></li>
<li>ECMQV 算法的分析
<ul>
<li>与 DH 密钥交换协议的共享密钥为 <span class="math inline">\(r_A,r_B,p\)</span> 不同，ECMQV
共享的信息包括了一个重要结构 <span class="math inline">\((\overline{R_a}
k_a, \overline{R_b} k_b, P)\)</span>，这是一个既利用了随机数 <span class="math inline">\(r_A,
r_B\)</span>，也使用了通信双方的公钥计算出来的结构</li>
<li><span class="math inline">\(s_b=(r_b+\overline{R_b} k_b) \bmod
p\)</span> 可以看作 Bob 对 <span class="math inline">\(R_b\)</span>
的“隐式签名”。“签名”是因为只有 Bob 可以计算这个值；“隐式”是因为 Alice
在计算共享秘密的时候可以利用 <span class="math inline">\(s_b
P=R_b+\overline{R_b} Q_b\)</span> 间接验证其正确性</li>
</ul></li>
<li>ECMQV 算法的优势与不足
<ul>
<li>优势
<ul>
<li>使用双重公钥，可以防止中间人攻击</li>
<li>隐式签名的方式，避免产生额外开销（引入 CA 等）</li>
</ul></li>
<li>不足
<ul>
<li>计算过程复杂，运算量大</li>
</ul></li>
</ul></li>
<li>ECMQV 算法的应用
<ul>
<li>ANSI X9.63、IEEE 1363-2000、ISO/IEC 15946-3 等</li>
</ul></li>
</ul>
<h2 id="sm2">SM2</h2>
<ul>
<li>SM2
算法是中国国家密码管理局（CNCA）发布的一种基于椭圆曲线的非对称加密算法，包含密钥交换、数字签名和公钥加密等功能具体为：
<ul>
<li>SM2-1 椭圆曲线数字签名算法</li>
<li>SM2-2 椭圆曲线密钥交换协议</li>
<li>SM2-3 椭圆曲线公钥加密算法</li>
</ul></li>
</ul>
<h3 id="sm2-密钥生成">SM2 密钥生成</h3>
<ol type="1">
<li>公开参数
<ul>
<li>选取定义在有限域 <span class="math inline">\(GF(p)\)</span>
上的椭圆曲线 <span class="math inline">\(E_p(a,b):
y^2=x^3+ax+b\)</span></li>
<li>选取椭圆曲线上一点作为基点 <span class="math inline">\(G\)</span></li>
<li>有限域的模值 <span class="math inline">\(p\)</span></li>
</ul></li>
<li>计算公私钥对
<ul>
<li>选定一个大数 <span class="math inline">\(k\)</span> 作为私钥</li>
<li>生成公钥 <span class="math inline">\(Q=kG\)</span></li>
<li>公钥为 <span class="math inline">\(K = \{Q\}\)</span>，私钥为 <span class="math inline">\(K^{-1} = \{k\}\)</span></li>
</ul></li>
</ol>
<h3 id="sm2-加解密算法">SM2 加解密算法</h3>
<ul>
<li>加密
<ol type="1">
<li>选取随机数 <span class="math inline">\(r\)</span>，<span class="math inline">\(1 &lt; r &lt; p-1\)</span></li>
<li>计算点 <span class="math inline">\(C_1 = rG\)</span></li>
<li>计算点 <span class="math inline">\(S = rQ = (x_S, y_S)\)</span></li>
<li>计算密钥 <span class="math inline">\(t = KDF(x_S \parallel y_S,
klen(M))\)</span>
<ul>
<li>其中 <span class="math inline">\(KDF\)</span> 是密钥派生函数，<span class="math inline">\(klen(M)\)</span> 是明文 <span class="math inline">\(M\)</span> 的比特长度</li>
</ul></li>
<li>计算密文 <span class="math inline">\(C_2 = M \oplus t\)</span></li>
<li>计算 <span class="math inline">\(C_3 = Hash(x_S \parallel M
\parallel y_S)\)</span></li>
<li>生成密文 <span class="math inline">\(C = (C_1, C_2,
C_3)\)</span></li>
</ol></li>
<li>解密
<ol type="1">
<li>计算点 <span class="math inline">\(S = C_1 \cdot
k^{-1}\)</span></li>
<li>计算密钥 <span class="math inline">\(t = KDF(x_S \parallel y_S,
klen(C_2))\)</span></li>
<li>计算明文 <span class="math inline">\(M = C_2 \oplus t\)</span></li>
<li>验证 <span class="math inline">\(C_3 = Hash(x_S \parallel M
\parallel y_S)\)</span></li>
</ol></li>
</ul>
<h3 id="sm2-vs-ecc">SM2 VS ECC</h3>
<ul>
<li>在加密过程中，引入了多个校验点</li>
<li>引入密钥派生函数（KDF），增强了 SM2 算法随机性，提高破解强度</li>
<li>引入哈希函数（如 SM3），加入了对传递消息完整性校验的特性</li>
<li>加密运算是异或操作，运算速度快</li>
<li>密文长度有所扩张，对于计算带宽要求更高</li>
</ul>
<h2 id="公钥密码现状">公钥密码现状</h2>
<ul>
<li>已知的安全算法是有限域上指数运算素数域 <span class="math inline">\(GF(p)\)</span> 上的整数运算
<ul>
<li>多项式运算 <span class="math inline">\(GF(2^n)\)</span></li>
<li>椭圆曲线上的运算</li>
<li>基于其它困难问题的体制</li>
<li>NTRU</li>
</ul></li>
<li>实际应用
<ul>
<li>实现速度较慢
<ul>
<li>通常用于交换对称算法的加密密钥</li>
<li>数字签名算法</li>
</ul></li>
</ul></li>
</ul>
<h3 id="简单攻击方法弱参数攻击以-rsa-为例">简单攻击方法（弱参数攻击，以
RSA 为例）</h3>
<h4 id="共模攻击">共模攻击</h4>
<ul>
<li>当多个用户使用相同的模数 <span class="math inline">\(n\)</span>，使用不同的公钥指数 <span class="math inline">\(e\)</span> 对同一明文 <span class="math inline">\(x\)</span>
进行加密时，攻击者可通过共模攻击还原出明文 <span class="math inline">\(x\)</span>。</li>
<li>攻击条件
<ol type="1">
<li>使用相同的模数 <span class="math inline">\(n\)</span></li>
<li>对同一明文 <span class="math inline">\(x\)</span> 加密</li>
<li>各公钥指数 <span class="math inline">\(e_1,e_2,\cdots,e_k\)</span>
之间两两互质</li>
</ol></li>
<li>攻击原理（以两个用户为例）
<ol type="1">
<li>设 <span class="math inline">\(e_1\)</span> 和 <span class="math inline">\(e_2\)</span> 是两个互素的不同密钥，共用模为 <span class="math inline">\(n\)</span>，对同一消息 <span class="math inline">\(x\)</span> 加密得 <span class="math display">\[
\begin{aligned}
y_1 &amp;= x^{e_1} \bmod n \\
y_2 &amp;= x^{e_2} \bmod n
\end{aligned}
\]</span></li>
<li>攻击者已知 <span class="math inline">\(n,y_1,y_2,e_1,e_2\)</span>，由于 <span class="math inline">\(\gcd(e_1,e_2)=1\)</span>，所以存在整数 <span class="math inline">\(a,b\)</span> 使得 <span class="math inline">\(e_1a+e_2b=1\)</span>。</li>
<li>计算明文： <span class="math display">\[
\begin{aligned}
x &amp;= (y_1^a \cdot y_2^b) \bmod n \\
&amp;= (x^{e_1})^a \cdot (x^{e_2})^b \bmod n \\
&amp;= x^{e_1a + e_2b} \bmod n \\
&amp;= x^1 \bmod n \\
&amp;= x
\end{aligned}
\]</span></li>
</ol></li>
<li>为对抗该攻击，建议每个用户使用不同的模数 <span class="math inline">\(n\)</span>。</li>
</ul>
<h4 id="低加密指数攻击">低加密指数攻击</h4>
<ul>
<li>当公钥指数 <span class="math inline">\(e\)</span> 取过小值（如 <span class="math inline">\(e=3\)</span>、<span class="math inline">\(e=17\)</span>）时，若同一明文被多次加密（或加密后数据满足特定条件），攻击者可通过数学运算直接还原明文，无需破解私钥。</li>
<li>攻击条件
<ol type="1">
<li>公钥指数 <span class="math inline">\(e\)</span> 取较小值，典型值为
<span class="math inline">\(e=3\)</span> 或 <span class="math inline">\(17\)</span></li>
<li>同一明文 <span class="math inline">\(x\)</span> 被不同的模数 <span class="math inline">\(n_1,n_2,\cdots,n_k\)</span> 多次加密</li>
</ol></li>
<li>攻击原理（以 <span class="math inline">\(e=3\)</span> 为例）
<ol type="1">
<li><p>设有三个用户，公钥分别为 <span class="math inline">\((e=3,n_1)\)</span>、<span class="math inline">\((e=3,n_2)\)</span> 和 <span class="math inline">\((e=3,n_3)\)</span>，对同一消息 <span class="math inline">\(x\)</span> 加密得密文 <span class="math display">\[
\begin{aligned}
y_1 &amp;= x^3 \bmod n_1 \\
y_2 &amp;= x^3 \bmod n_2 \\
y_3 &amp;= x^3 \bmod n_3
\end{aligned}
\]</span></p></li>
<li><p>攻击者已知 <span class="math inline">\(n_1,n_2,n_3,y_1,y_2,y_3\)</span>，可利用中国剩余定理求解以下同余方程组
<span class="math display">\[
\begin{aligned}
X &amp;\equiv y_1 \bmod n_1 \\
X &amp;\equiv y_2 \bmod n_2 \\
X &amp;\equiv y_3 \bmod n_3
\end{aligned}
\]</span></p>
<p>若 <span class="math inline">\(n_1,n_2,n_3\)</span>
互素，则该方程组有唯一解 <span class="math inline">\(X\)</span> 满足
<span class="math inline">\(0 \leq X &lt; N\)</span>，其中 <span class="math inline">\(N = n_1 n_2 n_3\)</span></p></li>
<li><p>计算明文： <span class="math display">\[
x = \sqrt[3]{X}
\]</span></p></li>
</ol></li>
<li>为对抗该攻击，建议公钥指数 <span class="math inline">\(e\)</span>
取较大值（如 <span class="math inline">\(e=2^{16}+1=65537\)</span>），或在加密前对明文进行填充处理（如使用
OAEP 填充方案）。</li>
<li>当 <span class="math inline">\(e &lt; n\)</span>，<span class="math inline">\(d &lt; n/4\)</span> 时，同样可以攻破这类 RSA
系统</li>
</ul>
<h1 id="认证与哈希函数">认证与哈希函数</h1>
<h2 id="消息认证">消息认证</h2>
<ul>
<li>认证的定义：
<ul>
<li>认证 (Authentication)
是防止主动攻击的重要技术，对开发系统安全性有重要作用</li>
</ul></li>
<li>认证的主要目的
<ul>
<li><strong>实体认证</strong>（验证发送者非冒充）</li>
<li><strong>消息认证</strong>（验证信息的完整性）</li>
</ul></li>
<li>网络环境中的攻击（认证的需求）
<ol type="1">
<li>泄漏</li>
<li>通信量分析</li>
<li>伪装（假消息）</li>
<li>内容篡改（插入，删除，调换和修改）</li>
<li>序号篡改（消息序号的修改）</li>
<li>计时篡改（消息延迟或回放）</li>
<li>抵赖（否认收或发某消息）</li>
</ol>
<ul>
<li>1-2 加密，3-6 消息认证，7 数字签名</li>
</ul></li>
<li>认证系统模型
<ul>
<li><strong>保密</strong>和<strong>认证</strong>是信息系统安全的两个方面，但它们是两个不同属性的
问题，认证不能自动提供保密性，而保密性也不能自然提供认证功能。一个纯认证系统的模型如下图所示：
<img src="image-47.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
</ul>
<h2 id="消息认证方法认证函数">消息认证方法（认证函数）</h2>
<ul>
<li>为了认证消息的<strong>完整性</strong>和<strong>未被篡改</strong>，需要对消息生成某种形式上的认证符，通过对认证符的分析，可以得知原始消息是否完整，是否被修改。</li>
<li>三类主要的消息认证方法 / 认证函数：
<ul>
<li>消息加密
<ul>
<li>将整个需要认证的消息加密，将<strong>密文</strong>作为认证符。</li>
</ul></li>
<li>消息认证码（MAC）
<ul>
<li>将需要认证的消息通过一个公共函数作用，<strong>产生的结果和使用的密钥</strong>一起作为认证符</li>
</ul></li>
<li>哈希函数（哈希函数）
<ul>
<li>将需要认证的消息通过一个公共函数映射为定长的哈希值，以<strong>哈希值</strong>作为认证符</li>
</ul></li>
</ul></li>
<li>注意
<ul>
<li>认证函数类似加密函数，但它是<strong>不可逆</strong>的，这个性质使其比加密函数更难破解</li>
<li>认证函数并不提供数字签名，因为认证函数是对称的，发送者和接收者使用相同的密钥</li>
</ul></li>
</ul>
<h3 id="消息加密">消息加密</h3>
<h4 id="对称加密">对称加密</h4>
<ul>
<li>下图的通信双方，用户 A 为发送方，用户 B 为接收方。用户 B
接收到信息后，通过解密来判决信息是否来自 A，信息是否是完整的，有无窜扰。
<img src="image-48.webp" srcset="/img/loading/loading3.gif" lazyload alt="对称加密"></li>
<li><span class="math inline">\(A \rightarrow B:  E(K, M)\)</span>
<ul>
<li><strong>具有保密性</strong>
<ul>
<li>仅 A 和 B 共享密钥 <span class="math inline">\(K\)</span></li>
</ul></li>
<li>提供一定程度的<strong>可认证性</strong>
<ul>
<li>讯息是否来自 A
<ul>
<li>仅 A 和 B 共享密钥 <span class="math inline">\(K\)</span>，消息仅可能来自 A</li>
<li>密钥泄露则认证失效</li>
</ul></li>
<li>传输中是否被篡改
<ul>
<li>收到密文解密得到乱码无法判断是被篡改还是传输错误</li>
<li>需要某种结构或冗余</li>
</ul></li>
</ul></li>
<li>不提供签名
<ul>
<li>发送者可以否认消息，声称是接受者伪造的</li>
</ul></li>
</ul></li>
<li>基于 DES 的消息鉴别码
<ul>
<li>被鉴别消息分成连续的 64-bit 分组：<span class="math inline">\(M_1,
M_2, \cdots, M_n\)</span>（必要时用 0 填充）</li>
<li>使用DES算法 <span class="math inline">\(E(CBC)\)</span>，密钥 <span class="math inline">\(K\)</span>，数据鉴别码计算如下: <span class="math display">\[
  \begin{aligned}
  C_1  &amp;=  E_k (M_1) \\
  C_2  &amp;=  E_k (M_2 \oplus C_1) \\
  &amp;\vdots \\
  C_n  &amp;=  E_k (M_n \oplus C_{n-1})
  \end{aligned}
  \]</span></li>
</ul></li>
</ul>
<h4 id="公钥加密">公钥加密</h4>
<ul>
<li><span class="math inline">\(A \rightarrow B : E(PK_B, M)\)</span>
<ul>
<li>发送方用接收方的公钥加密消息，接收方用私钥解密（与对称密钥加密原理相同，需要某种特定消息结构）</li>
<li><strong>具有保密性</strong>
<ul>
<li>消息只能被 B 解密</li>
</ul></li>
<li><strong>不提供认证</strong>
<ul>
<li>任何人都可以用 <span class="math inline">\(B\)</span>
的公钥加密消息并发送给 <span class="math inline">\(B\)</span>，无法确认消息来自 <span class="math inline">\(A\)</span></li>
</ul></li>
<li><figure>
<img src="image-49.webp" srcset="/img/loading/loading3.gif" lazyload alt="公钥加密：保密性">
<figcaption aria-hidden="true">公钥加密：保密性</figcaption>
</figure></li>
</ul></li>
<li><span class="math inline">\(A \rightarrow B : E(SK_A, M)\)</span>
<ul>
<li>发送方用自己的私钥加密消息，接收方用发送方的公钥解密</li>
<li><strong>提供认证和签名</strong>
<ul>
<li>只有 A 能生成该密文，B 用 A 的公钥解密后能确认消息来自 A</li>
</ul></li>
<li><strong>不提供保密性</strong>
<ul>
<li>任何人都可以用 A 的公钥解密消息</li>
</ul></li>
<li><figure>
<img src="image-50.webp" srcset="/img/loading/loading3.gif" lazyload alt="公钥加密：可认证性">
<figcaption aria-hidden="true">公钥加密：可认证性</figcaption>
</figure></li>
</ul></li>
<li><span class="math inline">\(A \rightarrow B : E(PK_B, E(SK_A,
M))\)</span>
<ul>
<li>发送方先用自己的密钥加密以提供认证，然后使用接收方公钥加密提供保密性。缺点是效率不高。</li>
<li><strong>具有保密性</strong>
<ul>
<li>消息只能被 B 解密</li>
</ul></li>
<li><strong>提供认证和签名</strong>
<ul>
<li>只有 A 能生成该密文，B 用 A 的公钥解密后能确认消息来自 A</li>
</ul></li>
<li><figure>
<img src="image-51.webp" srcset="/img/loading/loading3.gif" lazyload alt="公钥加密：保密性、可认证性">
<figcaption aria-hidden="true">公钥加密：保密性、可认证性</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="消息认证码-mac">消息认证码 MAC</h3>
<ul>
<li>认证码（MAC，Message Authentication Code），也称密码检验和
<ul>
<li>对选定消息 <span class="math inline">\(M\)</span>，使用一个密钥
<span class="math inline">\(K\)</span>，通过一个编码函数 <span class="math inline">\(C\)</span> 产生一个短小的定长数据分组 <span class="math inline">\(MAC\)</span>，称认证码，并将它附加在消息中，提供认证功能</li>
<li><span class="math inline">\(MAC = C_k(M)\)</span> ，其中:
<ul>
<li><span class="math inline">\(M\)</span> 是可变长的消息</li>
<li><span class="math inline">\(K\)</span> 是共享密钥</li>
<li><span class="math inline">\(C_k(M)\)</span> 是定长的认证码</li>
</ul></li>
</ul></li>
<li>应用认证码，如果只有收发方知道密钥，同时收到的 MAC 与计算得出的 MAC
匹配:
<ul>
<li>确认消息未被更改</li>
<li>确信消息来自所谓的发送者</li>
<li>如果消息包含序号，可确信该序号的正确性</li>
</ul></li>
<li>消息认证码的基本用法
<ol type="1">
<li><span class="math inline">\(A \rightarrow B:  M \parallel C_k
(M)\)</span>
<ul>
<li><strong>提供认证</strong>，因仅 A 和 B 共享 <span class="math inline">\(K\)</span>;</li>
<li><img src="image-52.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><span class="math inline">\(A \rightarrow B:  E_{K_2} (M \parallel
C_{K_1} (M))\)</span>：先认证，后加密
<ul>
<li><strong>提供认证</strong>，因仅 A 和 B 共享 <span class="math inline">\(K_1\)</span>;</li>
<li><strong>提供保密</strong>，因仅 A 和 B 共享 <span class="math inline">\(K_2\)</span>;</li>
<li><img src="image-53.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><span class="math inline">\(A \rightarrow B:  E_{K_2} (M) \parallel
C_{K_1} (E_{K_2} (M))\)</span>：先加密，后认证
<ul>
<li><strong>提供认证</strong>，因仅 A 和 B 共享 <span class="math inline">\(K_1\)</span>;</li>
<li><strong>提供保密</strong>，因仅 A 和 B 共享 <span class="math inline">\(K_2\)</span>;</li>
<li><img src="image-54.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
</ol></li>
<li>为什么使用消息认证（而不是用常规加密）
<ul>
<li>适用于消息广播</li>
<li>消息加密解密的工作量比较大</li>
<li>某些应用不关心消息的保密而只关心消息的真实性</li>
<li>认证函数与保密函数的分离能提供结构上的灵活性(认证与保密可在网络协议的不同层次进行)</li>
<li>认证码可延长消息的保护期限，同时能处理消息内容（使用加密，当消息解密后，保护就失效了）</li>
</ul></li>
<li>MAC 函数应有如下性质（假设攻击者没有 <span class="math inline">\(K\)</span>）：
<ul>
<li>有 <span class="math inline">\(M\)</span> 和 <span class="math inline">\(C_k(M)\)</span>，试图生成 <span class="math inline">\(M'\)</span>，使得 <span class="math inline">\(C_k(M')=
C_k(M)\)</span>，这在计算上不可行；</li>
<li><span class="math inline">\(C_k(M)\)</span> 应能均匀分布；
<ul>
<li>对于随机选取的消息 <span class="math inline">\(M\)</span> 和 <span class="math inline">\(M'\)</span>，<span class="math inline">\(C_k(M)= C_k(M')\)</span> 的概率为 <span class="math inline">\(2^{-n}\)</span>，其中 <span class="math inline">\(n\)</span> 为 MAC 的比特长度；</li>
<li>消息 <span class="math inline">\(M'\)</span> 为 <span class="math inline">\(M\)</span> 的某种已知代换，即 <span class="math inline">\(M' = f(M)\)</span>，则 <span class="math inline">\(C_k(M)= C_k(M')\)</span> 的概率为 <span class="math inline">\(2^{-n}\)</span></li>
</ul></li>
</ul></li>
</ul>
<h3 id="哈希函数">哈希函数</h3>
<ul>
<li>哈希函数 / 散列函数 / 杂凑函数
<ul>
<li>哈希函数是将任意长度的消息映射成一个较短的定长输出消息的函数。</li>
<li>如下形式：<span class="math inline">\(h = H(M)\)</span>，<span class="math inline">\(M\)</span> 是变长的消息，<span class="math inline">\(h\)</span> 是定长的哈希值。</li>
<li>哈希函数的目的是为文件、消息或其它的分组数据产生“数字指纹”（缩微图）。</li>
</ul></li>
<li><strong>哈希函数与认证函数的区别</strong>？
<ul>
<li>哈希函数本身不提供认证功能，只是单纯计算消息的哈希值摘要。</li>
<li>哈希函数加上密钥就可以构成认证函数（如 HMAC）。</li>
<li>哈希函数主要用于消息完整性验证，而认证函数主要用于身份验证和消息完整性验证。</li>
</ul></li>
<li>使用哈希码提供消息鉴别的方式
<ol type="1">
<li><span class="math inline">\(A \rightarrow B:  E_k (M \parallel H(M)
)\)</span>
<ul>
<li>提供保密（仅 A 和 B 共享 <span class="math inline">\(K\)</span>）</li>
<li>提供鉴别（加密保护 <span class="math inline">\(H(M)\)</span>）</li>
</ul></li>
<li><span class="math inline">\(A \rightarrow B:  M \parallel E_k
(H(M))\)</span>
<ul>
<li>提供鉴别（加密保护 <span class="math inline">\(H(M)\)</span>）</li>
</ul></li>
<li><span class="math inline">\(A \rightarrow B:  M \parallel E_{K_{Ra}}
(H(M))\)</span>
<ul>
<li>提供鉴别和数字签名（加密保护 <span class="math inline">\(H(M)\)</span> , 且仅 A 能生成 <span class="math inline">\(E_{K_{Ra}} (H(M))\)</span>）</li>
</ul></li>
<li><span class="math inline">\(A \rightarrow B:  E_k (M \parallel
E_{K_{Ra}} (H(M)) )\)</span>
<ul>
<li>提供鉴别和数字签名</li>
<li>提供保密（仅 A 和 B 共享 <span class="math inline">\(K\)</span>）</li>
</ul></li>
<li><span class="math inline">\(A \rightarrow B:  M \parallel H(M
\parallel S)\)</span>
<ul>
<li>提供鉴别（<span class="math inline">\(S\)</span>
是通信双方共享的一个秘密值，仅 A 和 B 共享 <span class="math inline">\(S\)</span>）</li>
</ul></li>
<li><span class="math inline">\(A \rightarrow B:  E_k (M \parallel H(M
\parallel S ))\)</span>
<ul>
<li>提供鉴别（仅 A 和 B 共享 <span class="math inline">\(S\)</span>）</li>
<li>提供保密（仅 A 和 B 共享 <span class="math inline">\(K\)</span>）</li>
</ul></li>
</ol></li>
<li>哈希函数的需求
<ul>
<li><span class="math inline">\(H\)</span> 能用于任何大小的数据分组</li>
<li><span class="math inline">\(H\)</span> 产生定长输出 <span class="math inline">\(h\)</span></li>
<li>对任意给定的 <span class="math inline">\(x\)</span>，<span class="math inline">\(H(x)\)</span>
要相对易于计算，使得软硬件实现都实际可行</li>
<li>对任意给定的码 <span class="math inline">\(h\)</span>，寻求 <span class="math inline">\(x\)</span> 使得 <span class="math inline">\(H(x)=h\)</span>
在计算上是不可行的（<strong>单向性</strong>）</li>
<li>任意给定分组 <span class="math inline">\(x\)</span>，寻求不等于
<span class="math inline">\(x\)</span> 的 <span class="math inline">\(y\)</span>，使得 <span class="math inline">\(H(y)=
H(x)\)</span> 在计算上不可行（<strong>弱抗碰撞性</strong>）</li>
<li>寻求任意使得 <span class="math inline">\(H(x)=H(y)\)</span> 的 <span class="math inline">\((x,y)\)</span>
对在计算上不可行（<strong>强抗碰撞性</strong>）</li>
</ul></li>
<li>单向函数
<ul>
<li>函数 <span class="math inline">\(F\)</span> 从集合 <span class="math inline">\(A\)</span> 映射到集合 <span class="math inline">\(B\)</span>，如果对任意 <span class="math inline">\(A\)</span> 中的元素 <span class="math inline">\(a\)</span>，计算 <span class="math inline">\(F(a)\)</span> 是容易的，但对任意 <span class="math inline">\(B\)</span> 中的元素 <span class="math inline">\(b\)</span>，要找到 <span class="math inline">\(A\)</span> 中一个元素 <span class="math inline">\(a\)</span> 满足 <span class="math inline">\(b=F(a)\)</span> 是困难的，则函数 <span class="math inline">\(F\)</span> 称为单向函数。</li>
<li>对于单向函数 <span class="math inline">\(F\)</span>，如果有了某个陷门 <span class="math inline">\(k\)</span>，则计算一个元素 <span class="math inline">\(a\)</span> 满足 <span class="math inline">\(b=F(a)\)</span>
也是容易的，那么这个单向函数称为<strong>陷门单向函数</strong>。</li>
</ul></li>
<li>常见的哈希函数算法 <img src="image-68.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h4 id="简单的哈希函数构造方法">简单的哈希函数构造方法</h4>
<ul>
<li>简单的哈希函数（异或方式）
<ul>
<li>每个分组按比特异或: <span class="math display">\[
  C_i  =  b_{i1} \oplus b_{i2} \oplus\cdots\oplus  b_{im}
  \]</span></li>
<li>其中：
<ul>
<li><span class="math inline">\(C_i\)</span> 是第 <span class="math inline">\(i\)</span> 个比特的哈希码，<span class="math inline">\(1 \leq i \leq n\)</span></li>
<li><span class="math inline">\(m\)</span> 是输入的 <span class="math inline">\(n\)</span> 比特分组</li>
<li><span class="math inline">\(b_{ij}\)</span> 是第 <span class="math inline">\(j\)</span> 分组的第 <span class="math inline">\(i\)</span> 比特</li>
</ul></li>
<li>简单的奇偶校验</li>
</ul></li>
<li>简单的哈希函数的改进方案
<ul>
<li>先将 <span class="math inline">\(n\)</span> 比特的哈希值设置为
0</li>
<li>按如下方式依次处理数据分组：
<ul>
<li>将当前的哈希值循环左移一位</li>
<li>将数据分组与哈希值异或形成新的哈希值</li>
</ul></li>
<li>这将起到输入数据完全随机化的效果，并且将输入中的数据格式掩盖掉</li>
</ul></li>
</ul>
<h4 id="杂凑函数的代表性设计模式">杂凑函数的代表性设计模式</h4>
<ul>
<li><p>MD 结构 (Merkle-Damgård Construction) <img src="image-55.webp" srcset="/img/loading/loading3.gif" lazyload alt="Merkle-Damgård Construction（1989）"></p>
<ul>
<li>其中：
<ul>
<li><span class="math inline">\(IV\)</span>：初值</li>
<li><span class="math inline">\(CV_i\)</span>：链接变量</li>
<li><span class="math inline">\(Y_i\)</span>：第 <span class="math inline">\(i\)</span> 个输入分组</li>
<li><span class="math inline">\(f\)</span>：压缩函数</li>
<li><span class="math inline">\(L\)</span>：输入分组数</li>
<li><span class="math inline">\(n\)</span>：杂凑输出长度</li>
<li><span class="math inline">\(b\)</span>：输入分组长度</li>
<li>最后一组不足 <span class="math inline">\(b\)</span>
比特则填充，最后分组通常包括杂凑输入的总长度</li>
</ul></li>
<li>迭代：
<ul>
<li>设 <span class="math inline">\(M=(Y_0, \cdots, Y_L)\)</span>，则
<span class="math inline">\(CV_0=IV=\)</span> 初始 <span class="math inline">\(n\)</span> 比特值 <span class="math display">\[
  \begin{cases}
  CV_i = f(CV_{i-1},Y_{i-1}),&amp; 1\leq i\leq L\\
  H(M) = CV_L
  \end{cases}
  \]</span></li>
</ul></li>
<li>安全性：如果压缩函数是抗碰撞的，则 <span class="math inline">\(H\)</span> 是抗碰撞的。</li>
</ul></li>
<li><p>海绵结构 (Sponge Construction)</p>
<ul>
<li>海绵结构是一种用于构建哈希函数和伪随机数生成器的设计模式。它通过反复吸收输入数据并挤压输出数据来实现信息的混合和压缩。</li>
<li>主要组成部分：
<ul>
<li>状态（State）：海绵结构的核心，包含吸收和挤压过程中的中间数据。</li>
<li>吸收（Absorb）：将输入数据分块并与状态进行混合的过程。</li>
<li>挤压（Squeeze）：从状态中提取输出数据的过程。</li>
</ul></li>
<li>海绵结构的工作原理：
<ol type="1">
<li>初始化状态为零。</li>
<li>吸收阶段：将输入数据分块，每个分块与状态进行异或操作，然后通过一个固定的转换函数更新状态。</li>
<li>挤压阶段：从状态中提取输出数据，直到达到所需的输出长度。</li>
</ol></li>
</ul></li>
</ul>
<h2 id="md5">MD5</h2>
<h3 id="概述">概述</h3>
<ul>
<li>MD: Message Digest（报文摘要）</li>
<li>Rivest 设计（RSA 中的 R）</li>
<li>符合 Merkle-Damgård 结构</li>
<li>输入：任意长度报文</li>
<li>输出：128 比特的摘要</li>
<li>分组长度：512 比特</li>
</ul>
<h3 id="md5-算法描述">MD5 算法描述</h3>
<figure>
<img src="image-56.webp" srcset="/img/loading/loading3.gif" lazyload alt="MD5 算法整体描述">
<figcaption aria-hidden="true">MD5 算法整体描述</figcaption>
</figure>
<ol type="1">
<li>添加填充位（一个 <span class="math inline">\(1\)</span> 和若干个
<span class="math inline">\(0\)</span>）
<ul>
<li>在消息的最后添加适当的填充位使得数据位的长度满足 <span class="math inline">\(length \equiv 448 \bmod 512\)</span>。
<ul>
<li>需要注意：如果报文是 <span class="math inline">\(448\)</span>
比特，则填充 <span class="math inline">\(512\)</span> 比特形成 <span class="math inline">\(960\)</span> 比特的报文。填充比特首位为 <span class="math inline">\(1\)</span>，其余位全 <span class="math inline">\(0\)</span>。</li>
</ul></li>
<li>填充完后，信息的长度就为 <span class="math inline">\(k \times
512+448 \mathrm{~bit}\)</span></li>
</ul></li>
<li>添加长度
<ul>
<li>原始消息长度（二进制位的个数）用 <span class="math inline">\(64\)</span> 位表示。如果长度超过 <span class="math inline">\(2^{64}\)</span> 位，则仅取最低 <span class="math inline">\(64\)</span> 位，即 <span class="math inline">\(\bmod 2^{64}\)</span>。</li>
<li>到此为止，我们已经得到一个 <span class="math inline">\(512\)</span>
位的整倍数长度的新的消息。
<ul>
<li>可以表示为 <span class="math inline">\(L\)</span> 个 <span class="math inline">\(512\)</span> 位的数据块：<span class="math inline">\(Y_0,Y_1,\cdots,Y_{L−1}\)</span>。</li>
<li>其长度为 <span class="math inline">\(L\times 512
\mathrm{~bit}\)</span>。</li>
<li>令 <span class="math inline">\(N=L\times 16\)</span>，则长度为 <span class="math inline">\(N\)</span> 个 <span class="math inline">\(32\)</span> 位的字。</li>
<li>令 <span class="math inline">\(X[0,\cdots,N-1]\)</span>
表示以<strong>字</strong>为单位的消息表示。</li>
</ul></li>
</ul></li>
<li>初始化 MD 缓存
<ul>
<li>使用一个 <span class="math inline">\(128\)</span>
比特缓存存放杂凑的中间和最后结果。缓存表示为 <span class="math inline">\(4\)</span> 个 <span class="math inline">\(32\)</span> 比特的缓存器 <span class="math inline">\((A,B,C,D)\)</span></li>
<li>初始化值（16进制表示）： <span class="math display">\[
  \begin{aligned}
  A &amp;= \mathtt{67452301} \quad B = \mathtt{EFCDAB89} \\
  C &amp;= \mathtt{98BADCFE} \quad D = \mathtt{10325476}
  \end{aligned}
  \]</span></li>
<li>初始化格式：小数在前的格式存储，即字的低位字节放在高地址字节上，像32位的比特串：
<span class="math display">\[
  \begin{aligned}
  A &amp;: \mathtt{01~23~45~67} \quad B : \mathtt{89~AB~CD~EF} \\
  C &amp;: \mathtt{FE~DC~BA~98} \quad D : \mathtt{76~54~32~10}
  \end{aligned}
  \]</span></li>
</ul></li>
<li>处理 <span class="math inline">\(512\)</span> 比特（<span class="math inline">\(16\)</span> 个字）报文分组，每个分组处理包括 4
个循环，每个循环 16 步，共 <span class="math inline">\(L\)</span>
个分组。
<ul>
<li>核心是一个包含 4 个循环的压缩函数 <span class="math inline">\(g_i\)</span>。
<ul>
<li>4 个循环结构相似，但每次使用的原始逻辑函数不同，分别记为 <span class="math inline">\(F,G,H,I\)</span>。</li>
</ul></li>
<li>输入：
<ul>
<li>当前处理的 <span class="math inline">\(512\)</span> 比特分组 <span class="math inline">\((Y_q)\)</span></li>
<li><span class="math inline">\(128\)</span> 比特缓存值 <span class="math inline">\((A,B,C,D)\)</span>（即上一次迭代的输出 <span class="math inline">\(CV_q\)</span>）</li>
</ul></li>
<li>循环：
<ul>
<li>使用表 <span class="math inline">\(T[1, \cdots, 64]\)</span> 的
<span class="math inline">\(1/4\)</span>，该表由正弦函数给出，即 <span class="math inline">\(T[i]=2^{32}×|sin⁡(𝑖)|\)</span> 的整数部分。</li>
<li><span class="math inline">\(T\)</span> 表提供了随机化的 <span class="math inline">\(32\)</span>
位模板，消除了在输入数据中的任何规律性的特征。</li>
</ul></li>
<li>输出：
<ul>
<li>第 <span class="math inline">\(4\)</span> 次循环输出加到第 <span class="math inline">\(1\)</span> 次循环的输入上产生 <span class="math inline">\(CV_{(q+1)}\)</span>。</li>
<li>相加是缓存中 <span class="math inline">\(4\)</span> 个字分别与 <span class="math inline">\(CV_q\)</span> 中对应的 <span class="math inline">\(4\)</span> 个字以模 <span class="math inline">\(2^{32}\)</span> 相加。</li>
</ul></li>
</ul></li>
<li>输出
<ul>
<li>所有 <span class="math inline">\(L\)</span> 个 <span class="math inline">\(512\)</span> 比特的分组处理完成后，第 <span class="math inline">\(L\)</span> 个阶段的输出作为报文的 <span class="math inline">\(128\)</span> 比特摘要。</li>
</ul></li>
</ol>
<ul>
<li>总结 MD5 操作如下： <span class="math display">\[
  \begin{aligned}
  &amp;CV_0 = IV \\
  &amp;CV_{(q+1)} = SUM_{32} (CV_q, RF_I [Y_q, RF_H [Y_q, RF_G [Y_q,
RF_F [Y_q, CV_q]]]] ) \\
  &amp;MD5 = CV_L
  \end{aligned}
  \]</span>
<ul>
<li>其中
<ul>
<li><span class="math inline">\(SUM_{32}\)</span>：对输入对中的每个字执行模 <span class="math inline">\(2^{32}\)</span> 加</li>
<li><span class="math inline">\(IV\)</span>：缓存 <span class="math inline">\(ABCD\)</span> 的初值，第3步定义</li>
<li><span class="math inline">\(Y_q\)</span>：第 <span class="math inline">\(q\)</span> 个长度为 <span class="math inline">\(512\)</span> 比特的报文分组</li>
<li><span class="math inline">\(L\)</span>：报文的分组数</li>
<li><span class="math inline">\(CV_q\)</span>：处理第 <span class="math inline">\(q\)</span> 个报文分组时的连续变量</li>
<li><span class="math inline">\(RF_x\)</span>：使用原始逻辑函数 <span class="math inline">\(x\)</span> 的循环函数</li>
<li><span class="math inline">\(MD5\)</span>：最终的报文摘要</li>
</ul></li>
</ul></li>
</ul>
<h3 id="单个-512-bit-分组的-md5-处理过程">单个 512-bit 分组的 MD5
处理过程</h3>
<figure>
<img src="image-57.webp" srcset="/img/loading/loading3.gif" lazyload alt="MD5 单个512-bit分组的处理过程">
<figcaption aria-hidden="true">MD5
单个512-bit分组的处理过程</figcaption>
</figure>
<h3 id="md5-的压缩函数">MD5 的压缩函数</h3>
<figure>
<img src="image-58.webp" srcset="/img/loading/loading3.gif" lazyload alt="MD5 的压缩函数">
<figcaption aria-hidden="true">MD5 的压缩函数</figcaption>
</figure>
<ul>
<li><span class="math inline">\(f\)</span> 由 4 个循环组成，每个循环包括
16 步操作，每一步的基本形式如下： <span class="math display">\[
  \begin{aligned}
  &amp;A \leftarrow D \\
  &amp;B \leftarrow B + ((A + g_i(B, C, D) + M(k,i) + T(k,i)) \lll
s(k,i)) \\
  &amp;C \leftarrow B \\
  &amp;D \leftarrow C \\
  \end{aligned}
  \]</span></li>
<li>其中：
<ul>
<li><span class="math inline">\(A,B,C,D\)</span>：缓存中的4个字，在每一步有指明的顺序</li>
<li><span class="math inline">\(i\)</span>：当前循环编号，<span class="math inline">\(i=1,\cdots,4\)</span></li>
<li><span class="math inline">\(k\)</span>：当前步骤编号，<span class="math inline">\(k=1,\cdots,16\)</span></li>
<li><span class="math inline">\(g_i\)</span>：第 <span class="math inline">\(i\)</span> 轮的逻辑函数，原始函数 <span class="math inline">\(F,G,H,I\)</span> 中的一个 <span class="math display">\[
  \begin{aligned}
  g_1 &amp;= F(B,C,D) = (B\land C)\lor(\lnot B\land D)\\
  g_2 &amp;= G(B,C,D) = (B\land D)\lor(C\land\lnot D)\\
  g_3 &amp;= H(B,C,D) = B\oplus C\oplus D\\
  g_4 &amp;= I(B,C,D) = C\oplus\bigl(B\lor\lnot D\bigr)
  \end{aligned}
  \]</span></li>
<li><span class="math inline">\(M(k,i)\)</span>：对应于当前分组按字划分的 <span class="math inline">\(X[1,\cdots,16]\)</span> 中的某一个 32 比特字 <span class="math display">\[
  \begin{aligned}
  M(k,1) &amp;= X[k] \\
  M(k,2) &amp;= X[(1+5(k-1)) \bmod16] \\
  M(k,3) &amp;= X[(5+3(k-1)) \bmod16] \\
  M(k,4) &amp;= X[(7(k-1)) \bmod16]
  \end{aligned}
  \]</span></li>
<li><span class="math inline">\(T(k,i)\)</span>：矩阵 <span class="math inline">\(T\)</span> 中的常数
<ul>
<li><span class="math inline">\(T[k] = \lfloor 2^{32} \times
|\sin(k+16(i-1))| \rfloor\)</span></li>
</ul></li>
<li><span class="math inline">\(\lll s(k,i)\)</span>：32
比特的字循环左移 <span class="math inline">\(s(k,i)\)</span> 位 <img src="image-87.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li><span class="math inline">\(+\)</span>：在 <span class="math inline">\(\bmod 2^{32}\)</span> 下进行的加法</li>
</ul></li>
</ul>

    <div class="fold">
      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">
        <div class="fold-arrow">▶</div>MD5的处理过程
      </div>
      <div class="fold-collapse collapse" id="collapse-8f7bdefe">
        <div class="fold-content">
          <figure class="shiki plaintext"><div class="codeblock"><div class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div><div class="code"><pre class="shiki one-dark-pro"><code><span class="line"><span style="color: #abb2bf"># Round 1</span></span>
<span class="line"><span style="color: #abb2bf">A = FF(A, B, C, D, X[0], 7, 0xd76aa478)</span></span>
<span class="line"><span style="color: #abb2bf">B = FF(B, A, C, D, X[1], 12, 0xe8c7b756)</span></span>
<span class="line"><span style="color: #abb2bf">C = FF(C, B, A, D, X[2], 17, 0x242070db)</span></span>
<span class="line"><span style="color: #abb2bf">D = FF(D, C, B, A, X[3], 22, 0xc1bdceee)</span></span>
<span class="line"><span style="color: #abb2bf">A = FF(A, B, C, D, X[4], 7, 0xf57c0faf)</span></span>
<span class="line"><span style="color: #abb2bf">B = FF(B, A, C, D, X[5], 12, 0x4787c62a)</span></span>
<span class="line"><span style="color: #abb2bf">C = FF(C, B, A, D, X[6], 17, 0xa8304613)</span></span>
<span class="line"><span style="color: #abb2bf">D = FF(D, C, B, A, X[7], 22, 0xfd469501)</span></span>
<span class="line"><span style="color: #abb2bf">A = FF(A, B, C, D, X[8], 7, 0x698098d8)</span></span>
<span class="line"><span style="color: #abb2bf">B = FF(B, A, C, D, X[9], 12, 0x8b44f7af)</span></span>
<span class="line"><span style="color: #abb2bf">C = FF(C, B, A, D, X[10], 17, 0xffff5bb1)</span></span>
<span class="line"><span style="color: #abb2bf">D = FF(D, C, B, A, X[11], 22, 0x895cd7be)</span></span>
<span class="line"><span style="color: #abb2bf">A = FF(A, B, C, D, X[12], 7, 0x6b901122)</span></span>
<span class="line"><span style="color: #abb2bf">B = FF(B, A, C, D, X[13], 12, 0xfd987193)</span></span>
<span class="line"><span style="color: #abb2bf">C = FF(C, B, A, D, X[14], 17, 0xa679438e)</span></span>
<span class="line"><span style="color: #abb2bf">D = FF(D, C, B, A, X[15], 22, 0x49b40821)</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf"># Round 2</span></span>
<span class="line"><span style="color: #abb2bf">A = GG(A, B, C, D, X[1], 5, 0xf61e2562)</span></span>
<span class="line"><span style="color: #abb2bf">B = GG(B, A, C, D, X[6], 9, 0xc040b340)</span></span>
<span class="line"><span style="color: #abb2bf">C = GG(C, B, A, D, X[11], 14, 0x265e5a51)</span></span>
<span class="line"><span style="color: #abb2bf">D = GG(D, C, B, A, X[0], 20, 0xe9b6c7aa)</span></span>
<span class="line"><span style="color: #abb2bf">A = GG(A, B, C, D, X[5], 5, 0xd62f105d)</span></span>
<span class="line"><span style="color: #abb2bf">B = GG(B, A, C, D, X[10], 9, 0x02441453)</span></span>
<span class="line"><span style="color: #abb2bf">C = GG(C, B, A, D, X[15], 14, 0xd8a1e681)</span></span>
<span class="line"><span style="color: #abb2bf">D = GG(D, C, B, A, X[4], 20, 0xe7d3fbc8)</span></span>
<span class="line"><span style="color: #abb2bf">A = GG(A, B, C, D, X[9], 5, 0x21e1cde6)</span></span>
<span class="line"><span style="color: #abb2bf">B = GG(B, A, C, D, X[14], 9, 0xc33707d6)</span></span>
<span class="line"><span style="color: #abb2bf">C = GG(C, B, A, D, X[3], 14, 0xf4d50d87)</span></span>
<span class="line"><span style="color: #abb2bf">D = GG(D, C, B, A, X[8], 20, 0x455a14ed)</span></span>
<span class="line"><span style="color: #abb2bf">A = GG(A, B, C, D, X[13], 5, 0xa9e3e905)</span></span>
<span class="line"><span style="color: #abb2bf">B = GG(B, A, C, D, X[2], 9, 0xfcefa3f8)</span></span>
<span class="line"><span style="color: #abb2bf">C = GG(C, B, A, D, X[7], 14, 0x676f02d9)</span></span>
<span class="line"><span style="color: #abb2bf">D = GG(D, C, B, A, X[12], 20, 0x8d2a4c8a)</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf"># Round 3</span></span>
<span class="line"><span style="color: #abb2bf">A = HH(A, B, C, D, X[5], 4, 0xfffa3942)</span></span>
<span class="line"><span style="color: #abb2bf">B = HH(B, A, C, D, X[8], 11, 0x8771f681)</span></span>
<span class="line"><span style="color: #abb2bf">C = HH(C, B, A, D, X[11], 16, 0x6d9d6122)</span></span>
<span class="line"><span style="color: #abb2bf">D = HH(D, C, B, A, X[14], 23, 0xfde5380c)</span></span>
<span class="line"><span style="color: #abb2bf">A = HH(A, B, C, D, X[1], 4, 0xa4beea44)</span></span>
<span class="line"><span style="color: #abb2bf">B = HH(B, A, C, D, X[4], 11, 0x4bdecfa9)</span></span>
<span class="line"><span style="color: #abb2bf">C = HH(C, B, A, D, X[7], 16, 0xf6bb4b60)</span></span>
<span class="line"><span style="color: #abb2bf">D = HH(D, C, B, A, X[10], 23, 0xbebfbc70)</span></span>
<span class="line"><span style="color: #abb2bf">A = HH(A, B, C, D, X[13], 4, 0x289b7ec6)</span></span>
<span class="line"><span style="color: #abb2bf">B = HH(B, A, C, D, X[0], 11, 0xeaa127fa)</span></span>
<span class="line"><span style="color: #abb2bf">C = HH(C, B, A, D, X[3], 16, 0xd4ef3085)</span></span>
<span class="line"><span style="color: #abb2bf">D = HH(D, C, B, A, X[6], 23, 0x04881d05)</span></span>
<span class="line"><span style="color: #abb2bf">A = HH(A, B, C, D, X[9], 4, 0xd9d4d039)</span></span>
<span class="line"><span style="color: #abb2bf">B = HH(B, A, C, D, X[12], 11, 0xe6db99e5)</span></span>
<span class="line"><span style="color: #abb2bf">C = HH(C, B, A, D, X[15], 16, 0x1fa27cf8)</span></span>
<span class="line"><span style="color: #abb2bf">D = HH(D, C, B, A, X[2], 23, 0x289b7ec6)</span></span>
<span class="line"><span style="color: #abb2bf"></span></span>
<span class="line"><span style="color: #abb2bf"># Round 4</span></span>
<span class="line"><span style="color: #abb2bf">A = II(A, B, C, D, X[0], 6, 0xf4292244)</span></span>
<span class="line"><span style="color: #abb2bf">B = II(B, A, C, D, X[7], 10, 0x432aff97)</span></span>
<span class="line"><span style="color: #abb2bf">C = II(C, B, A, D, X[14], 15, 0xab9423a7)</span></span>
<span class="line"><span style="color: #abb2bf">D = II(D, C, B, A, X[5], 21, 0xfc93a039)</span></span>
<span class="line"><span style="color: #abb2bf">A = II(A, B, C, D, X[12], 6, 0x655b59c3)</span></span>
<span class="line"><span style="color: #abb2bf">B = II(B, A, C, D, X[3], 10, 0x8f0ccc92)</span></span>
<span class="line"><span style="color: #abb2bf">C = II(C, B, A, D, X[10], 15, 0xffeff47d)</span></span>
<span class="line"><span style="color: #abb2bf">D = II(D, C, B, A, X[1], 21, 0x85845dd1)</span></span>
<span class="line"><span style="color: #abb2bf">A = II(A, B, C, D, X[8], 6, 0x6fa87e4f)</span></span>
<span class="line"><span style="color: #abb2bf">B = II(B, A, C, D, X[15], 10, 0xfe2ce6e0)</span></span>
<span class="line"><span style="color: #abb2bf">C = II(C, B, A, D, X[6], 15, 0xa3014314)</span></span>
<span class="line"><span style="color: #abb2bf">D = II(D, C, B, A, X[13], 21, 0x4e0811a1)</span></span>
<span class="line"><span style="color: #abb2bf">A = II(A, B, C, D, X[4], 6, 0xf7537e82)</span></span>
<span class="line"><span style="color: #abb2bf">B = II(B, A, C, D, X[11], 10, 0xbd3af235)</span></span>
<span class="line"><span style="color: #abb2bf">C = II(C, B, A, D, X[2], 15, 0x2ad7d2bb)</span></span>
<span class="line"><span style="color: #abb2bf">D = II(D, C, B, A, X[9], 21, 0xeb86d391)</span></span></code></pre></div></div></figure>
        </div>
      </div>
    </div>
<h3 id="md4-vs-md5">MD4 VS MD5</h3>
<ul>
<li>MD4（1990 年 10 月作为 RFC1320 发表）by Ron Rivest at MIT（MD5
的前身）</li>
<li>MD4 的设计目标：
<ul>
<li>安全性：寻找两个具有相同消息摘要的消息计算不可行</li>
<li>速度：32 位体系结构下计算速度快</li>
<li>简明与紧凑：易于编程</li>
<li>有利于小数在前的结构（Intel 80xxx, Pentium）</li>
</ul></li>
<li>MD4 与 MD5 的区别：
<ul>
<li>MD4 用 3 轮，每轮 16 步，MD5 用 4 轮，每轮 16 步</li>
<li>MD4 中第一轮没有常量加；MD5 中 64 步每一步用了一个不同的常量 <span class="math inline">\(T[i]\)</span></li>
<li>MD5 用了四个基本逻辑函数，每轮一个；MD4 用了三个</li>
<li>MD5 每轮加上前一步的结果；MD4 没有（雪崩效应）</li>
</ul></li>
</ul>
<h3 id="md5的应用">MD5的应用</h3>
<ul>
<li>MD5
的典型应用是对一段明文消息（message）生成消息摘要（message-digest），防止消息被篡改</li>
<li>MD5 广泛应用于数字签名中</li>
<li>广泛应用于 unix、Linux 等操作系统用于保护用户口令</li>
</ul>
<h3 id="md5口令的逆向简析">MD5口令的逆向简析</h3>
<ol type="1">
<li>思路（一）
<ul>
<li>MD5 对于 1 个 block 数据（512bit）进行 64 步运算。然而在第 61
步之后，即 II(A, B, C, D, M4, 6, 0xf7537e82) 之后，<span class="math inline">\(A\)</span> 的数据不再改变，因此可以首先判断 <span class="math inline">\(A\)</span>
与目标是否一致，如果不一致接下来的运算就是没有必要的，从而减少 3
步不必要的运算，提高效率 5%。</li>
</ul></li>
<li>思路（二）
<ul>
<li><p>观察F，G函数，将 <span class="math display">\[
  \begin{aligned}
  F(X,Y,Z) &amp;= (X\land Y)\lor ((\neg X)\land Z) \\
  G(X,Y,Z) &amp;= (X\land Z)\lor (Y\land(\neg Z))
  \end{aligned}
  \]</span></p>
<p>改写为： <span class="math display">\[
  \begin{aligned}
  F(X,Y,Z) &amp;= Z \oplus (X \land (Y \oplus Z)) \\
  G(X,Y,Z) &amp;= Y \oplus (Z \land (X \oplus Y))
  \end{aligned}
  \]</span></p>
<p>在同样结果的前提下减少一条指令，提高性能.</p></li>
<li><p>使用 BFI_INT 指令：对于 <span class="math inline">\(F\)</span>
函数而言，<span class="math inline">\((X\land Y)\lor ((\neg X)\land
Z)\)</span> 在新版驱动下能被直接替换为 <span class="math inline">\(bitselct(Z, Y, X)\)</span>，可以将其编译成 1
条指令。<span class="math inline">\(G\)</span> 函数类似，可用 <span class="math inline">\(bitselct(Y, X, Z)\)</span> 替代。</p></li>
</ul></li>
<li>思路（三）
<ul>
<li>在已知口令值 MD5 的 A，B，C，D 的情况下，可以逆推至 50
步，此时状态寄存器 A，B，C，D 应该与该口令正向计算至 49
步后的状态寄存器一致；</li>
<li>如果不一致，则该口令接下去的计算一定不会得到想要的 MD5
值，可以省略。</li>
<li>例如口令 1 算至 49
步后，与逆向哈希不一致，那么口令就不是我们寻找的口令，省略接下去的步骤</li>
</ul></li>
</ol>
<h2 id="sha-1">SHA-1</h2>
<h3 id="概述-1">概述</h3>
<ul>
<li>输入：长度小于 <span class="math inline">\(2^{64}\)</span>
位的任意长度报文；</li>
<li>输出：160 位消息摘要；</li>
<li>分组长度：512 位；</li>
<li>SHA 由美国国家标准技术研究所 NIST 开发，作为联邦信息处理标准于 1993
年发表（FIPS PUB 180），1995 年修订，作为 SHA-1(FIPS PUB 180-1)，SHA-1
基于 MD4 设计。</li>
</ul>
<h3 id="sha-1-算法描述">SHA-1 算法描述</h3>
<figure>
<img src="image-59.webp" srcset="/img/loading/loading3.gif" lazyload alt="SHA-1 算法整体描述">
<figcaption aria-hidden="true">SHA-1 算法整体描述</figcaption>
</figure>
<ol type="1">
<li>添加填充位（一个 <span class="math inline">\(1\)</span> 和若干个
<span class="math inline">\(0\)</span>）
<ul>
<li>在消息的最后添加适当的填充位使得数据位的长度满足 <span class="math inline">\(length \equiv 448 \bmod 512\)</span>。
<ul>
<li>需要注意：如果报文是 <span class="math inline">\(448\)</span>
比特，则填充 <span class="math inline">\(512\)</span> 比特形成 <span class="math inline">\(960\)</span> 比特的报文。填充比特首位为 <span class="math inline">\(1\)</span>，其余位全 <span class="math inline">\(0\)</span>。</li>
</ul></li>
<li>填充完后，信息的长度就为 <span class="math inline">\(k \times
512+448 \mathrm{~bit}\)</span></li>
</ul></li>
<li>添加长度
<ul>
<li>原始消息长度（二进制位的个数）用 <span class="math inline">\(64\)</span> 位表示</li>
<li>到此为止，我们已经得到一个 <span class="math inline">\(512\)</span>
位的整倍数长度的新的消息。
<ul>
<li>可以表示为 <span class="math inline">\(L\)</span> 个 <span class="math inline">\(512\)</span> 位的数据块：<span class="math inline">\(Y_0,Y_1,\cdots,Y_{L−1}\)</span>。</li>
<li>其长度为 <span class="math inline">\(L\times 512
\mathrm{~bit}\)</span>。</li>
<li>令 <span class="math inline">\(N=L\times 16\)</span>，则长度为 <span class="math inline">\(N\)</span> 个 <span class="math inline">\(32\)</span> 位的字。</li>
<li>令 <span class="math inline">\(X[0,\cdots,N-1]\)</span>
表示以<strong>字</strong>为单位的消息表示。</li>
</ul></li>
</ul></li>
<li>初始化 MD 缓存
<ul>
<li>使用一个 <span class="math inline">\(160\)</span> 位 MD
缓冲区用以保存中间和最终哈希函数的结果。它可以表示为 <span class="math inline">\(5\)</span> 个 <span class="math inline">\(32\)</span> 位的寄存器 <span class="math inline">\((A,B,C,D,E)\)</span>。</li>
<li>初始化为： <span class="math display">\[
  \begin{aligned}
  A &amp;= \mathtt{67452301} \quad B = \mathtt{EFCDAB89} \\
  C &amp;= \mathtt{98BADCFE} \quad D = \mathtt{10325476} \\
  E &amp;= \mathtt{C3D2E1F0}
  \end{aligned}
  \]</span></li>
<li>前四个与MD5相同，但存储为高端字节存储方式，即字的低位字节放在低地址字节上：
<span class="math display">\[
  \begin{aligned}
  A &amp;: \mathtt{67~45~23~01} \quad B : \mathtt{EF~CD~AB~89} \\
  C &amp;: \mathtt{98~BA~DC~FE} \quad D : \mathtt{10~32~54~76} \\
  E &amp;: \mathtt{C3~D2~E1~F0}
  \end{aligned}
  \]</span></li>
</ul></li>
<li>处理 <span class="math inline">\(512\)</span> 比特（<span class="math inline">\(16\)</span> 个字）报文分组，每个分组处理包括 4
个循环，每个循环 20 步，共 <span class="math inline">\(L\)</span>
个分组。
<ul>
<li>核心是一个包含 4 个循环的压缩函数 <span class="math inline">\(g_i\)</span>。
<ul>
<li>四个基本逻辑函数：<span class="math inline">\(g_1,g_2,g_3,g_4\)</span></li>
</ul></li>
<li>输入：
<ul>
<li>当前处理的 <span class="math inline">\(512\)</span> 比特分组 <span class="math inline">\((Y_q)\)</span></li>
<li><span class="math inline">\(160\)</span> 比特缓存值 <span class="math inline">\((A,B,C,D,E)\)</span>（即上一次迭代的输出 <span class="math inline">\(CV_q\)</span>）</li>
</ul></li>
<li>循环：
<ul>
<li>每次循环分别使用一个额外的常数 <span class="math inline">\(K_i\)</span>，即 <span class="math inline">\([2^{30}\times \sqrt{2}]\)</span>，<span class="math inline">\([20\times\sqrt{3}]\)</span>，<span class="math inline">\([20\times\sqrt{5}]\)</span>，<span class="math inline">\([20\times\sqrt{10}]\)</span></li>
</ul></li>
<li>输出：
<ul>
<li>第 <span class="math inline">\(4\)</span> 次循环输出加到第 <span class="math inline">\(1\)</span> 次循环的输入上产生 <span class="math inline">\(CV_{(q+1)}\)</span>。</li>
<li>相加是缓存中 <span class="math inline">\(5\)</span> 个字分别与 <span class="math inline">\(CV_q\)</span> 中对应的 <span class="math inline">\(5\)</span> 个字以模 <span class="math inline">\(2^{32}\)</span> 相加。</li>
</ul></li>
</ul></li>
<li>输出。
<ul>
<li>所有 <span class="math inline">\(L\)</span> 个 <span class="math inline">\(512\)</span> 比特的分组处理完成后，第 <span class="math inline">\(L\)</span> 个阶段的输出作为报文的 <span class="math inline">\(160\)</span> 比特摘要。</li>
</ul></li>
</ol>
<ul>
<li>总结SHA-1操作如下： <span class="math display">\[
  \begin{aligned}
  &amp;CV_0=IV \\
  &amp;CV_{q+1}= SUM_{32}(CV_q, ABCDE_q) \\
  &amp;SHA-1=CV_L \\
  \end{aligned}
  \]</span>
<ul>
<li>其中
<ul>
<li><span class="math inline">\(IV\)</span>：缓存 <span class="math inline">\(ABCDE\)</span> 的初值，第3步定义</li>
<li><span class="math inline">\(ABCDE_q\)</span>：第 <span class="math inline">\(q\)</span> 个报文分组最后一次循环输出</li>
<li><span class="math inline">\(L\)</span>：报文的分组数</li>
<li><span class="math inline">\(SUM_{32}\)</span>：对输入对中的每个字执行模 <span class="math inline">\(2^{32}\)</span> 加</li>
<li><span class="math inline">\(SHA-1\)</span>：最终的报文摘要</li>
</ul></li>
</ul></li>
</ul>
<h3 id="单个-512-bit-分组的-sha-1-处理过程">单个 512-bit 分组的 SHA-1
处理过程</h3>
<figure>
<img src="image-60.webp" srcset="/img/loading/loading3.gif" lazyload alt="SHA-1 单个512-bit分组的处理过程">
<figcaption aria-hidden="true">SHA-1
单个512-bit分组的处理过程</figcaption>
</figure>
<h3 id="sha-1-的压缩函数">SHA-1 的压缩函数</h3>
<figure>
<img src="image-62.webp" srcset="/img/loading/loading3.gif" lazyload alt="SHA-1 的压缩函数">
<figcaption aria-hidden="true">SHA-1 的压缩函数</figcaption>
</figure>
<ul>
<li><span class="math inline">\(f\)</span> 由 4 个循环组成，每个循环包括
20 步操作，每一步的基本形式如下： <span class="math display">\[
  \begin{aligned}
  &amp;A\leftarrow E + g_i(B, C, D) + (A \lll 5) + M(k, i) + K_i \\
  &amp;B\leftarrow A \\
  &amp;C\leftarrow B \lll 30 \\
  &amp;D\leftarrow C \\
  &amp;E\leftarrow D \\
  \end{aligned}
  \]</span></li>
<li>其中
<ul>
<li><span class="math inline">\(A, B, C, D, E\)</span>：缓存中的 5
个字</li>
<li><span class="math inline">\(i\)</span>：当前循环编号，<span class="math inline">\(1 \leq i \leq 4\)</span></li>
<li><span class="math inline">\(k\)</span>：当前步骤编号，<span class="math inline">\(1 \leq k \leq 20\)</span></li>
<li><span class="math inline">\(g_i(B, C, D)\)</span>：第 <span class="math inline">\(i\)</span> 轮的原始逻辑函数 <span class="math display">\[
  \begin{aligned}
  g_1 (B, C, D) &amp;= (B \land C) \lor (\lnot B \land D) \\
  g_2 (B, C, D) &amp;= B \oplus C \oplus D \\
  g_3 (B, C, D) &amp;= (B \land C) \lor (B \land D) \lor (C \land D) \\
  g_4 (B, C, D) &amp;= B \oplus C \oplus D \\
  \end{aligned}
  \]</span></li>
<li><span class="math inline">\(\lll x\)</span>：<span class="math inline">\(32\)</span> 比特常数循环左移 <span class="math inline">\(x\)</span> 位</li>
<li><span class="math inline">\(K_i\)</span>（图中的 <span class="math inline">\(T(i)\)</span>）：一个额外的常数，前面有定义 <span class="math display">\[
  \begin{aligned}
  K_1 &amp;= [2^{30}\times \sqrt{2}] = \mathtt{5A827999} \\
  K_2 &amp;= [20\times\sqrt{3}] = \mathtt{6ED9EBA1} \\
  K_3 &amp;= [20\times\sqrt{5}] = \mathtt{8F1BBCDC} \\
  K_4 &amp;= [20\times\sqrt{10}] = \mathtt{CA62C1D6} \\
  \end{aligned}
  \]</span></li>
<li><span class="math inline">\(W(j)\)</span>（图中的 <span class="math inline">\(M(k, i)\)</span>，<span class="math inline">\(j =
20(i-1) + (k-1)\)</span>）：当前 <span class="math inline">\(512\)</span> 比特输入报文分组导出的一个 <span class="math inline">\(32\)</span> 比特字 <span class="math display">\[
  W(j) =
  \begin{cases}
  X[j], &amp; 0 \leq j \leq 15 \\
  W(j-16) \oplus W(j-14) \oplus W(j-8) \oplus W(j-3) \lll 1, &amp; 16
\leq j \leq 79
  \end{cases}
  \]</span>
<ul>
<li><img src="image-61.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><span class="math inline">\(+\)</span>：在 <span class="math inline">\(\bmod 2^{32}\)</span> 下进行的加法</li>
</ul></li>
</ul>
<h3 id="md4-vs-md5-vs-sha-1">MD4 VS MD5 VS SHA-1</h3>
<table>
<thead>
<tr>
<th></th>
<th>MD4</th>
<th>MD5</th>
<th>SHA-1</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hash值</td>
<td>128 bit</td>
<td>128 bit</td>
<td>160 bit</td>
</tr>
<tr>
<td>分组处理长度</td>
<td>512 bit</td>
<td>512 bit</td>
<td>512 bit</td>
</tr>
<tr>
<td>基本字长</td>
<td>32 bit</td>
<td>32 bit</td>
<td>32 bit</td>
</tr>
<tr>
<td>步数</td>
<td>48(3*16)</td>
<td>64(4*16)</td>
<td>80(4*20)</td>
</tr>
<tr>
<td>消息长</td>
<td><span class="math inline">\(\leq 2^{64}\)</span> bit</td>
<td>No limit</td>
<td><span class="math inline">\(\leq 2^{64}\)</span> bit</td>
</tr>
<tr>
<td>基本逻辑函数</td>
<td>3</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>常数个数</td>
<td>3</td>
<td>64</td>
<td>4</td>
</tr>
<tr>
<td>速度</td>
<td>1</td>
<td>1/7</td>
<td>3/4</td>
</tr>
</tbody>
</table>
<ul>
<li>SHA-1 = MD4 ＋ 扩展变换 ＋ 外加一轮 ＋ 更好的雪崩；</li>
<li>MD5 = MD4 ＋ 改进的比特杂凑 ＋ 外加一轮 ＋ 更好的雪崩。</li>
</ul>
<h2 id="sha-2">SHA-2</h2>
<h3 id="概述-2">概述</h3>
<ul>
<li><p>SHA-1 VS SHA-2 VS SM3 VS SHA-3</p>
<table style="width:100%;">

<thead>
<tr>
<th>参数</th>
<th>SHA-1</th>
<th>SHA-2-256</th>
<th>SHA-2-384</th>
<th>SHA-2-512</th>
<th>SM3</th>
<th>SHA-3-224</th>
<th>SHA-3-256</th>
<th>SHA-3-384</th>
<th>SHA-3-512</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息摘要长度</td>
<td>160位</td>
<td>256位</td>
<td>384位</td>
<td>512位</td>
<td>256位</td>
<td>224位</td>
<td>256位</td>
<td>384位</td>
<td>512位</td>
</tr>
<tr>
<td>消息最大长度</td>
<td>&lt;<span class="math inline">\(2^{64}\)</span></td>
<td>&lt;<span class="math inline">\(2^{64}\)</span></td>
<td>&lt;<span class="math inline">\(2^{128}\)</span></td>
<td>&lt;<span class="math inline">\(2^{128}\)</span></td>
<td>&lt;<span class="math inline">\(2^{64}\)</span></td>
<td>无限制</td>
<td>无限制</td>
<td>无限制</td>
<td>无限制</td>
</tr>
<tr>
<td>块大小</td>
<td>512位</td>
<td>512位</td>
<td>1024位</td>
<td>1024位</td>
<td>512位</td>
<td>1152位</td>
<td>1088位</td>
<td>832位</td>
<td>576位</td>
</tr>
<tr>
<td>字长</td>
<td>32位</td>
<td>32位</td>
<td>64位</td>
<td>64位</td>
<td>32位</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>步骤数</td>
<td>80步</td>
<td>64步</td>
<td>80步</td>
<td>80步</td>
<td>64步</td>
<td>24步</td>
<td>24步</td>
<td>24步</td>
<td>24步</td>
</tr>
<tr>
<td>安全强度</td>
<td>80位</td>
<td>128位</td>
<td>192位</td>
<td>256位</td>
<td>128位</td>
<td>112位</td>
<td>128位</td>
<td>192位</td>
<td>256位</td>
</tr>
</tbody>
</table></li>
<li><p>SHA-2 的应用</p>
<ol type="1">
<li>主流安全协议/工具：TLS/SSL（网络传输加密）、PGP（邮件加密）、SSH（远程登录安全）、S/MIME（邮件签名）、Bitcoin（区块链哈希验证）、IPsec（网络层加密）。</li>
<li>政府与商业规范：
<ul>
<li>美国政府要求敏感非机密信息需使用 SHA 系列，早期允许
SHA-1，后因安全问题调整；</li>
<li>NIST 明确要求：2010 年后，联邦机构需停止使用 SHA-1
处理“需抗碰撞”的应用，全面改用 SHA-2 家族。</li>
</ul></li>
</ol></li>
</ul>
<h3 id="sha-2-512">SHA-2-512</h3>
<ul>
<li>最大长度小于 <span class="math inline">\(2^{128}\)</span> 位，并生成
<span class="math inline">\(512\)</span> 位消息摘要作为输出。</li>
<li>哈希函数操作可以分为两个阶段：
<ol type="1">
<li>预处理</li>
<li>哈希计算</li>
</ol></li>
</ul>
<h4 id="sha-512-算法描述">SHA-512 算法描述</h4>
<figure>
<img src="image-63.webp" srcset="/img/loading/loading3.gif" lazyload alt="SHA-512 算法整体描述">
<figcaption aria-hidden="true">SHA-512 算法整体描述</figcaption>
</figure>
<ol type="1">
<li>填充比特（Append padding bits）</li>
<li>添加长度（Append length）</li>
<li>初始化哈希缓冲区（Initialize hash buffer） <span class="math display">\[
\begin{aligned}
&amp;a = \mathtt{6A09E667F3BCC908} \quad b = \mathtt{BB67AE8584CAA73B}
\\
&amp;c = \mathtt{3C6EF372FE94F82B} \quad d = \mathtt{A54FF53A5F1D36F1}
\\
&amp;e = \mathtt{510E527FADE682D1} \quad f = \mathtt{9B05688C2B3E6C1F}
\\
&amp;g = \mathtt{1F83D9ABFB41BD6B} \quad h = \mathtt{5BE0CD19137E2179}
\end{aligned}
\]</span></li>
<li>分块处理（Process message in 1024-bit (16-64bit word) blocks）
<ul>
<li>处理每个 <span class="math inline">\(1024\)</span> 比特（<span class="math inline">\(16\)</span> 个 <span class="math inline">\(64\)</span> 比特字）报文分组，每个分组处理包括
<span class="math inline">\(80\)</span> 步，共 <span class="math inline">\(N\)</span> 个分组。</li>
</ul></li>
<li>输出结果（Output）</li>
</ol>
<ul>
<li>总结 SHA-512 操作如下： <span class="math display">\[
  \begin{aligned}
  &amp;H_0 = IV \\
  &amp;H_i = SUM_{64}(H_{i-1}, ABCDEFG_i) \\
  &amp;MD = H_N \\
  \end{aligned}
  \]</span>
<ul>
<li>其中：
<ul>
<li><span class="math inline">\(IV\)</span>：缓存 <span class="math inline">\(ABCDEFGH\)</span> 的初始值，定义在步骤3中。</li>
<li><span class="math inline">\(ABCDEFGH_i\)</span>：第 <span class="math inline">\(i\)</span> 个消息块的最后一轮处理的输出。</li>
<li><span class="math inline">\(N\)</span>：消息中的块数（包括填充和长度字段）。</li>
<li><span class="math inline">\(SUM_{64}\)</span>：对该对输入的每个字分别执行模
<span class="math inline">\(2^{64}\)</span> 加法。</li>
<li><span class="math inline">\(MD\)</span>：最终的消息摘要。</li>
</ul></li>
</ul></li>
</ul>
<h4 id="单个-1024-bit-分组的-sha-512-处理过程">单个 1024-bit 分组的
SHA-512 处理过程</h4>
<figure>
<img src="image-64.webp" srcset="/img/loading/loading3.gif" lazyload alt="SHA-512 单个1024-bit分组的处理过程">
<figcaption aria-hidden="true">SHA-512
单个1024-bit分组的处理过程</figcaption>
</figure>
<h4 id="sha-512-的压缩函数">SHA-512 的压缩函数</h4>
<ul>
<li><span class="math inline">\(f\)</span> 由 80
步操作组成，每一步的基本形式如下： <img src="image-65.webp" srcset="/img/loading/loading3.gif" lazyload> <span class="math display">\[
  \begin{aligned}
  &amp;T_1 = h + \mathrm{Ch}(e,f,g) + (\sum_{1}^{512} e) + W_i + K_i \\
  &amp;T_2 = (\sum_{0}^{512} a) + \mathrm{Maj}(a,b,c) \\
  &amp;a \leftarrow T_1 + T_2 \\
  &amp;b \leftarrow a \\
  &amp;c \leftarrow b \\
  &amp;d \leftarrow c \\
  &amp;e \leftarrow d + T_1 \\
  &amp;f \leftarrow e \\
  &amp;g \leftarrow f \\
  &amp;h \leftarrow g \\
  \end{aligned}
  \]</span></li>
<li>其中：
<ul>
<li><span class="math inline">\(a,b,c,d,e,f,g,h\)</span>：缓存中的 8
个字</li>
<li><span class="math inline">\(i\)</span>：步骤编号，<span class="math inline">\(0 \leq i \leq 79\)</span></li>
<li><span class="math inline">\(\mathrm{Ch}(e,f,g) = (e \land
f)\oplus(\lnot e \land g)\)</span>，如果 <span class="math inline">\(e\)</span> 为真则选择 <span class="math inline">\(f\)</span>，否则选择 <span class="math inline">\(g\)</span></li>
<li><span class="math inline">\(\mathrm{Maj}(a,b,c) = (a \land
b)\oplus(a \land c)\oplus(b \land c)\)</span>，选择多数值</li>
<li><span class="math inline">\(\sum_{0}^{512}\)</span> 和 <span class="math inline">\(\sum_{1}^{512}\)</span>：定义如下 <span class="math display">\[
  \begin{aligned}
  &amp;\sum_{0}^{512}(x) = (x \ggg 28) \oplus (x \ggg 34) \oplus (x \ggg
39) \\
  &amp;\sum_{1}^{512}(x) = (x \ggg 14) \oplus (x \ggg 18) \oplus (x \ggg
41) \\
  \end{aligned}
  \]</span>
<ul>
<li>其中：
<ul>
<li><span class="math inline">\(x \ggg n\)</span> 表示 <span class="math inline">\(x\)</span> 循环右移 <span class="math inline">\(n\)</span> 位</li>
<li><span class="math inline">\(x \gg n\)</span> 表示 <span class="math inline">\(x\)</span> 逻辑右移 <span class="math inline">\(n\)</span> 位</li>
</ul></li>
</ul></li>
<li><span class="math inline">\(W_i\)</span>：当前 <span class="math inline">\(1024\)</span> 比特输入报文分组导出的一个 <span class="math inline">\(64\)</span> 比特字。
<ul>
<li><span class="math inline">\(W_i\)</span> 的前 16
个字直接取自当前分组中的 16 个字，余下的字定义为: <span class="math display">\[
  W_i = \sigma_1^{512}(W_{i-2}) + W_{i-7} + \sigma_0^{512}(W_{i-15}) +
W_{i-16}, ~16 &lt; i \leq 79
  \]</span></li>
<li>其中 <span class="math display">\[
  \begin{aligned}
  &amp;\sigma_0(x)^{512} = (x \ggg 1) \oplus (x \ggg 8) \oplus (x \gg 7)
\\
  &amp;\sigma_1(x)^{512} = (x \ggg 19) \oplus (x \ggg 61) \oplus (x \gg
6) \\
  \end{aligned}
  \]</span></li>
<li><img src="image-66.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><span class="math inline">\(K_i\)</span>：步骤 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(64\)</span> 比特常数值</li>
<li><span class="math inline">\(+\)</span>：在 <span class="math inline">\(\bmod 2^{64}\)</span> 下进行的加法</li>
</ul></li>
</ul>
<h3 id="sha-2-256">SHA-2-256</h3>
<ul>
<li>SHA-256 与 SHA-512 类似，区别在于：
<ul>
<li>使用 <span class="math inline">\(32\)</span> 比特字代替 <span class="math inline">\(64\)</span> 比特字</li>
<li>使用不同的初始哈希值</li>
<li>使用不同的常数值</li>
<li>使用不同的位操作（循环移位和逻辑移位的位数不同） <span class="math display">\[
  \begin{aligned}
  &amp;\sum_{0}^{256}(x) = (x \ggg 2) \oplus (x \ggg 13) \oplus (x \ggg
22) \\
  &amp;\sum_{1}^{256}(x) = (x \&gt;&gt;g 6) \oplus (x \ggg 11) \oplus (x
\ggg 25) \\
  &amp;\sigma_0(x)^{256} = (x \ggg 7) \oplus (x \ggg 18) \oplus (x \gg
3) \\
  &amp;\sigma_1(x)^{256} = (x \ggg 17) \oplus (x \ggg 19) \oplus (x \gg
10) \\
  \end{aligned}
  \]</span></li>
</ul></li>
<li>最大长度小于 <span class="math inline">\(2^{64}\)</span> 位，并生成
<span class="math inline">\(256\)</span> 位消息摘要作为输出。</li>
</ul>
<h3 id="sha-2-384">SHA-2-384</h3>
<ul>
<li>SHA-384 与 SHA-512 类似，区别在于：
<ul>
<li>使用不同的初始哈希值</li>
<li>最终输出时只取前 <span class="math inline">\(384\)</span>
位作为消息摘要</li>
</ul></li>
<li>最大长度小于 <span class="math inline">\(2^{128}\)</span> 位，并生成
<span class="math inline">\(384\)</span> 位消息摘要作为输出。</li>
</ul>
<h2 id="sm3">SM3</h2>
<h3 id="概述-3">概述</h3>
<ul>
<li>中国国家密码管理局于 2010
年发布的哈希函数标准，适用于数字签名等密码应用。</li>
<li>输入：长度小于 <span class="math inline">\(2^{64}\)</span>
位的任意长度报文</li>
<li>输出：256 位消息摘要</li>
<li>分组长度：512 位</li>
</ul>
<h3 id="sm3-算法描述">SM3 算法描述</h3>
<ol type="1">
<li>填充与添加长度（Append padding bits and length） <img src="image-71.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>消息扩展（Message extension）
<ul>
<li>将每个 <span class="math inline">\(512\)</span> 比特的消息分组扩展为
<span class="math inline">\(132\)</span> 个 <span class="math inline">\(32\)</span> 比特的字：<span class="math inline">\(W_0, W_1, \cdots, W_{67}\)</span> 和 <span class="math inline">\(W_0', W_1', \cdots,
W_{63}'\)</span></li>
<li>定义为: <span class="math display">\[
  \begin{aligned}
  &amp;W_j =
  \begin{cases}
  X_j, &amp;~0 \leq j \leq 15 \\
  P_1(W_{j-16} \oplus W_{j-9} \oplus (W_{j-3} \lll 15)) \oplus (W_{j-13}
\lll 7) \oplus W_{j-6}, &amp;~16 \leq j \leq 67 \\
  \end{cases} \\
  &amp;W_j' = W_j \oplus W_{j+4}, ~0 \leq j \leq 63 \\
  \end{aligned}
  \]</span></li>
<li>其中：<span class="math inline">\(P_1(X) = X \oplus (X \ggg 15)
\oplus (X \ggg 23)\)</span></li>
</ul></li>
<li>初始化哈希缓冲区（Initialize hash buffer）</li>
<li>迭代计算（Iterative calculation）
<ul>
<li>对消息包 <span class="math inline">\(B^{(0)},B^{(1)},\cdots，B^{(K)}\)</span>进行迭代，迭代函数为：
<span class="math display">\[
  V_{(i+1)} = CF(V_i, B^{(i)}), ~0 \leq i \leq K
  \]</span></li>
<li><span class="math inline">\(CF\)</span> 是压缩函数。 <span class="math display">\[
  \begin{aligned}
  &amp;A \leftarrow TT1 \\
  &amp;B \leftarrow A \\
  &amp;C \leftarrow B \lll 9 \\
  &amp;D \leftarrow C \\
  &amp;E \leftarrow P_0 (TT2) \\
  &amp;F \leftarrow E \\
  &amp;G \leftarrow F \lll 19 \\
  &amp;H \leftarrow G \\
  \end{aligned}
  \]</span>
<ul>
<li>其中 <span class="math display">\[
  \begin{aligned}
  &amp;FF_j(x,y,z)=\begin{cases}
  x \oplus y \oplus z, &amp;0 \leq j \leq 15 \\
  (x \land y) \lor (x \land z) \lor (y \land z), &amp;16 \leq j \leq 63
\\
  \end{cases} \\
  &amp;GG_j(x,y,z)=\begin{cases}
  x \oplus y \oplus z, &amp;0 \leq j \leq 15 \\
  (x \land y) \lor (\lnot x \land z), &amp;16 \leq j \leq 63 \\
  \end{cases} \\
  &amp;SS1(A, e, j) = ((A \lll 12) + e + (T_j \lll j)) \lll 7 \\
  &amp;SS2(A, e, j) = SS1(A, e, j) \oplus (A \lll 12) \\
  &amp;TT1 = (FF_j(A, B, C) + D + SS2(A, e, j) + W_j') \\
  &amp;TT2 = (GG_j(E, F, G) + H + SS1(A, e, j) + W_j) \\
  \end{aligned}
  \]</span></li>
</ul></li>
</ul></li>
<li>输出结果
<ul>
<li>每次 512 位数据压缩操作后： <span class="math display">\[
  V_{i+1} = V_i \oplus ABCDEFGH
  \]</span>
<ul>
<li>更新哈希值</li>
<li>输入迭代函数，开始下一个数据包的轮次操作。</li>
<li>计算最后一个数据包的结果，即哈希值。</li>
</ul></li>
</ul></li>
</ol>
<ul>
<li>单个 512-bit 分组的 SM3 处理过程 <img src="image-67.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul>
<h2 id="sha-3">SHA-3</h2>
<h3 id="海绵结构">海绵结构</h3>
<p><img src="image-69.webp" srcset="/img/loading/loading3.gif" lazyload alt="SPONGE 压缩函数"> <img src="image-70.webp" srcset="/img/loading/loading3.gif" lazyload alt="DUPLEX 双工函数"></p>
<ul>
<li>吸收阶段（Absorbing phase）
<ul>
<li><span class="math inline">\(r\)</span> 代表速率，消息填充后被分成
<span class="math inline">\(r\)</span>
比特分组，异或到内部置换的分组中，依次进行处理</li>
<li><span class="math inline">\(c\)</span> 代表安全长度，<span class="math inline">\(c=2d\)</span>，<span class="math inline">\(d\)</span> 为哈希长度</li>
<li><span class="math inline">\(b\)</span> 代表总比特数，<span class="math inline">\(b=r+c\)</span></li>
<li><span class="math inline">\(f\)</span> 代表内部置换函数，SHA-3
的内部置换函数为 Keccak-f[b]</li>
<li>填充规则：<span class="math inline">\(pad10^∗1\)</span>，即在消息后添加一个 <span class="math inline">\(1\)</span>，然后添加若干个 <span class="math inline">\(0\)</span>，最后再添加一个 <span class="math inline">\(1\)</span>，使得填充后的消息长度为 <span class="math inline">\(r\)</span> 的整数倍。</li>
<li>对于 SHA-3-256，<span class="math inline">\(d=256\)</span>，<span class="math inline">\(c=512\)</span>，<span class="math inline">\(b=1600\)</span>，<span class="math inline">\(r=1088\)</span>，<span class="math inline">\(f\)</span> 为 Keccak-f[1600]</li>
</ul></li>
<li>挤压阶段（Squeezing phase）
<ul>
<li>处理完所有 <span class="math inline">\(r\)</span>
比特分组后，对最终的状态，用同样的内部置换 <span class="math inline">\(f\)</span> 处理，提取哈希值。
<ul>
<li>提取初始输出：从吸收阶段结束后的状态中，提取前 <span class="math inline">\(r\)</span> 比特作为初始输出数据。</li>
<li>如果需要的输出长度 <span class="math inline">\(d \leq r\)</span>
，直接截取前 <span class="math inline">\(d\)</span> 比特作为结果。</li>
<li>如果需要的输出长度 <span class="math inline">\(d &gt; r\)</span>
，则：
<ul>
<li>先提取前 <span class="math inline">\(r\)</span>
比特，加入输出结果；</li>
<li>对当前状态应用置换函数 <span class="math inline">\(f[b]\)</span>，更新状态；再次从更新后的状态中提取前
<span class="math inline">\(r\)</span> 比特，加入输出结果；</li>
<li>重复上述过程，直到输出总长度超过 <span class="math inline">\(d\)</span> 比特，然后截取前 <span class="math inline">\(d\)</span> 比特作为最终结果。</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="sha-3-的-6-个实例">SHA-3 的 6 个实例</h3>
<ul>
<li>固定哈希长度的 SHA3-224/256/384/512</li>
<li>可变哈希长度的 SHAKE256 和 SHAKE512</li>
</ul>
<table>
<thead>
<tr>
<th>算法</th>
<th>哈希长度 <span class="math inline">\(d\)</span></th>
<th>安全长度 <span class="math inline">\(c\)</span></th>
<th>速率 <span class="math inline">\(r\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>SHA3-224</td>
<td>224 bit</td>
<td>448 bit</td>
<td>1152 bit</td>
</tr>
<tr>
<td>SHA3-256</td>
<td>256 bit</td>
<td>512 bit</td>
<td>1088 bit</td>
</tr>
<tr>
<td>SHA3-384</td>
<td>384 bit</td>
<td>768 bit</td>
<td>768 bit</td>
</tr>
<tr>
<td>SHA3-512</td>
<td>512 bit</td>
<td>1024 bit</td>
<td>576 bit</td>
</tr>
<tr>
<td>SHAKE256</td>
<td>可变</td>
<td>512 bit</td>
<td>1088 bit</td>
</tr>
<tr>
<td>SHAKE512</td>
<td>可变</td>
<td>1024 bit</td>
<td>576 bit</td>
</tr>
</tbody>
</table>
<h3 id="keccak-f1600-置换函数">Keccak-f[1600] 置换函数</h3>
<p><img src="image-73.webp" srcset="/img/loading/loading3.gif" lazyload></p>
<ul>
<li><p>分组长度为 <span class="math inline">\(1600\)</span>
比特的迭代置换函数，共迭代 <span class="math inline">\(24\)</span>
轮</p></li>
<li><p><span class="math inline">\(1600\)</span> 比特的分组状态 <span class="math inline">\(A\)</span>，组织成 <span class="math inline">\(5\times  5\times 64\)</span> 的 <span class="math inline">\(3\)</span> 维数组，每个比特由 <span class="math inline">\(A[x,y,z]\)</span> 坐标表示，<span class="math inline">\(0\leq x,y&lt;5, 0\leq z&lt;64\)</span></p></li>
<li><p>每轮包括 <span class="math inline">\(5\)</span> 步： <span class="math inline">\(R := \iota \circ \chi \circ  \pi \circ \rho \circ
\theta\)</span> ，其中，<span class="math inline">\(\theta, \rho, \pi,
\iota\)</span> 是线性运算， <span class="math inline">\(\chi\)</span>
是唯一的非线性运算</p></li>
<li><p><span class="math inline">\(\theta\)</span>：the mixing layer</p>
<ul>
<li><img src="image-74.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>对任意坐标为[<span class="math inline">\(x,y,z\)</span>] 的比特
<ol type="1">
<li><span class="math inline">\(\theta\)</span>
首先分别计算出该比特左侧列 [<span class="math inline">\(x-1,z\)</span>]
和右后侧列 [<span class="math inline">\(x+1,z-1\)</span>]
的整列异或值；</li>
<li>然后将两个列异或值与原比特的值进行异或， 从而更新当前比特的值。</li>
</ol></li>
<li>表达式描述 <span class="math display">\[
  \begin{aligned}
  &amp;C[x,z]=\oplus_{y=0}^{4} A[x,y,z] \\
  &amp;D[x,z]=C[x-1,z]\oplus C[x+1,z-1] \\
  &amp;A[x,y,z]=A[x,y,z]\oplus D[x,z] \\
  \end{aligned}
  \]</span></li>
</ul></li>
<li><p><span class="math inline">\(\rho\)</span>：the intra-slice bit
transposition</p>
<ul>
<li><p><img src="image-75.webp" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>在 lane 内部对 <span class="math inline">\(64\)</span>
个比特进行循环移位操作，循环移位的值由 lane 坐标 <span class="math inline">\(R(x,y)\)</span> 确定。 <span class="math display">\[
  A[x,y] = A[x,y] \lll R(x,y)
  \]</span></p></li>
<li><p>其中，<span class="math inline">\(R(x,y)\)</span>
是预定义的循环移位幅度</p>
<table>
<thead>
<tr>
<th>x &nbsp;y</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>36</td>
<td>3</td>
<td>41</td>
<td>18</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>44</td>
<td>10</td>
<td>45</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>62</td>
<td>6</td>
<td>43</td>
<td>15</td>
<td>61</td>
</tr>
<tr>
<td>3</td>
<td>28</td>
<td>55</td>
<td>25</td>
<td>21</td>
<td>56</td>
</tr>
<tr>
<td>4</td>
<td>27</td>
<td>20</td>
<td>39</td>
<td>8</td>
<td>14</td>
</tr>
</tbody>
</table></li>
</ul></li>
<li><p><span class="math inline">\(\pi\)</span>：the intra-slice bit
transposition</p>
<ul>
<li><img src="image-76.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>slice 内的 <span class="math inline">\(25\)</span>
个比特位置变换，所有 <span class="math inline">\(64\)</span> 个 slice
的置换运算相同 <span class="math display">\[
  A[y, (2x+3y)\bmod 5]=A[x,y]
  \]</span></li>
</ul></li>
<li><p><span class="math inline">\(\chi\)</span>：the nonlinear
layer</p>
<ul>
<li><img src="image-77.webp" srcset="/img/loading/loading3.gif" lazyload></li>
<li>在 row 上的非线性运算</li>
<li>可看作 5 比特的 S 盒 <span class="math display">\[
  A[x,y]=A[x,y]\oplus(A[x+1,y]\oplus1)\cdot A[x+2,y]
  \]</span></li>
<li><span class="math inline">\(\chi\)</span> 的代数次数为 2，<span class="math inline">\(\chi^{−1}\)</span> 的代数次数为 3</li>
</ul></li>
<li><p><span class="math inline">\(\iota\)</span> – round constant</p>
<ul>
<li>在每轮给坐标为 <span class="math inline">\([𝑥, 𝑦] = [0, 0]\)</span>
的 lane 异或一个预先计算好的轮常量 <span class="math inline">\(RC\)</span> <span class="math display">\[
  A[0,0]=A[0,0]\oplus RC[i]
  \]</span></li>
<li>轮常量 <span class="math inline">\(RC\)</span> 由一个 LFSR 函数生成
<img src="image-78.webp" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li><p>小结：内部状态 <span class="math inline">\(A\)</span>，任意比特为
<span class="math inline">\(A[x,y,z]\)</span></p>
<ul>
<li><span class="math inline">\(\theta\)</span> step
<ul>
<li><span class="math inline">\(C[x,z]=\oplus_{y=0}^{4}
A[x,y,z]\)</span>.</li>
<li><span class="math inline">\(D[x,z]=C[x-1,z]\oplus
C[x+1,z-1]\)</span>.</li>
<li><span class="math inline">\(A[x,y,z]=A[x,y,z]\oplus
D[x,z]\)</span></li>
</ul></li>
<li><span class="math inline">\(\rho\)</span> step
<ul>
<li><span class="math inline">\(A[x,y]=A[x,y]\lll R[x,y]\)</span></li>
</ul></li>
<li><span class="math inline">\(\pi\)</span> step
<ul>
<li><span class="math inline">\(A[y,(2x+3y)\bmod 5]=A[x,y]\)</span></li>
</ul></li>
<li><span class="math inline">\(\chi\)</span> step
<ul>
<li><span class="math inline">\(A[x,y]=A[x,y]\oplus(A[x+1,y]\oplus1)\cdot
A[x+2,y]\)</span></li>
</ul></li>
<li><span class="math inline">\(\iota\)</span> step
<ul>
<li><span class="math inline">\(A[0,0]=A[0,0]\oplus RC[i]\)</span></li>
</ul></li>
</ul></li>
</ul>
<h1 id="数字签名算法">数字签名算法</h1>
<h2 id="数字签名方案">数字签名方案</h2>
<ul>
<li>公钥签名方案：
<ul>
<li>利用私钥生成签名</li>
<li>利用公钥验证签名</li>
</ul></li>
<li>只有私钥的拥有者才能生成签名，所以能够用于证明谁生成的消息</li>
<li>任何知道公钥的人可以验证消息（他们要确认公钥拥有者的身份，这是公钥的密钥分配问题）</li>
<li>通常不对整个消息签名，因为这将会使交换信息长度增加一倍
<ul>
<li>使用消息的 hash 值</li>
</ul></li>
<li>数字签名可以<strong>提供消息的不可否认性</strong></li>
</ul>
<h2 id="rsa-签名方案">RSA 签名方案</h2>
<ul>
<li>RSA 加密解密是可交换的</li>
<li>可以用于数字签名方案</li>
</ul>
<h3 id="rsa-密钥生成-1">RSA 密钥生成</h3>
<ul>
<li>选择两个大素数 <span class="math inline">\(p\)</span> 和 <span class="math inline">\(q\)</span></li>
<li>计算 <span class="math inline">\(n = p \cdot q\)</span></li>
<li>计算 <span class="math inline">\(\phi(n) = (p - 1)(q -
1)\)</span></li>
<li>选择公钥指数 <span class="math inline">\(e\)</span>，满足 <span class="math inline">\(1 &lt; e &lt; \phi(n)\)</span> 且 <span class="math inline">\(\gcd(e, \phi(n)) = 1\)</span></li>
<li>计算私钥指数 <span class="math inline">\(d\)</span>，满足 <span class="math inline">\(d \cdot e \equiv 1 \bmod \phi(n)\)</span></li>
<li>公钥是 <span class="math inline">\((e, n)\)</span></li>
<li>私钥是 <span class="math inline">\((d, p, q)\)</span></li>
</ul>
<h3 id="rsa-签名生成与验证">RSA 签名生成与验证</h3>
<ul>
<li>给定 RSA 方案 <span class="math inline">\(\{K=(e, n), K^{-1}=(d, p,
q)\}\)</span>
<ul>
<li>要签名消息 <span class="math inline">\(M\)</span>：计算： <span class="math display">\[
  \begin{cases}
  h = H(M) \\
  S = h^{d} (\bmod n) \\
  \end{cases}
  \Rightarrow (M, S)
  \]</span></li>
<li>要验证签名, 计算： <span class="math display">\[
  \begin{cases}
  h = H(M) \\
  h' = S^{e}(\bmod n) \\
  \end{cases}
  \Rightarrow h^{\prime} = h?
  \]</span></li>
</ul></li>
</ul>
<h3 id="rsa-签名方案的使用">RSA 签名方案的使用</h3>
<ul>
<li>使用RSA加密、认证:
<ul>
<li>假设 A 发送消息给 B
<ul>
<li>用发送者的私钥签名：<span class="math inline">\(S = M^{d_A} \bmod
n_A\)</span></li>
<li>用接收者的公钥加密：<span class="math inline">\(C = S^{e_B} \bmod
n_B\)</span></li>
</ul></li>
<li>接收者 B 解密:
<ul>
<li><span class="math inline">\(S = C^{d_B} \bmod n_B\)</span></li>
<li>验证签名：<span class="math inline">\(M = S^{e_A} \bmod
n_A\)</span></li>
</ul></li>
</ul></li>
<li>看起来，一个消息可用 RSA 先加密再签名而不改变大小
<ul>
<li>但是，加密使用的是消息接收者的模，签名是消息发送者的模，后者可能比前者小</li>
<li>如果先加密再签名，可能会导致加密后的消息大于签名模，无法使用 RSA
进行签名（RSA 要求 <span class="math inline">\(0 &lt; M &lt;
n\)</span>）</li>
<li>交换两者顺序，先签名再加密可以避免这个问题</li>
</ul></li>
<li>签名常使用 HASH 函数值
<ul>
<li>用 <span class="math inline">\(h=H(M)\)</span> 代替消息 <span class="math inline">\(M\)</span> 进行签名</li>
</ul></li>
</ul>
<h2 id="elgamal-签名方案">ElGamal 签名方案</h2>
<ul>
<li>ElGamal 加密算法是不可交换的</li>
<li>存在一个相关的签名算法</li>
<li>安全性是<strong>基于计算离散对数的困难性</strong></li>
</ul>
<h3 id="elgamal-密钥生成-1">ElGamal 密钥生成</h3>
<ul>
<li>选择共享的素数 <span class="math inline">\(p\)</span> 和公开的生成元
<span class="math inline">\(g\)</span></li>
<li>每个用户选择一个随机数作为私钥 <span class="math inline">\(x\)</span></li>
<li>计算各自的公开密钥：<span class="math inline">\(y = g^x \bmod
p\)</span></li>
<li>公钥是 <span class="math inline">\((y, g, p)\)</span></li>
<li>私钥是 <span class="math inline">\((x)\)</span></li>
</ul>
<h3 id="elgamal-签名生成与验证">ElGamal 签名生成与验证</h3>
<ul>
<li>签名消息 <span class="math inline">\(M\)</span>：
<ul>
<li>选择随机数 <span class="math inline">\(k\)</span>，满足 <span class="math inline">\(\gcd(k, p - 1) = 1\)</span>
<ul>
<li><span class="math inline">\(k\)</span>
应该被销毁或保密，不能重复使用</li>
</ul></li>
<li>计算 <span class="math inline">\(K = g^{k} \bmod p\)</span></li>
<li>用 Euclidean (inverse) 扩展算法求 <span class="math inline">\(S\)</span>：
<ul>
<li><span class="math inline">\(M = x \cdot K + k \cdot S \bmod (p -
1)\)</span> ;</li>
<li>即求 <span class="math inline">\(S = k^{-1}(M - x \cdot K) \bmod (p
- 1)\)</span></li>
</ul></li>
<li>发送 <span class="math inline">\((M, K, S)\)</span>，其中 <span class="math inline">\((K, S)\)</span> 是对 <span class="math inline">\(M\)</span> 的签名</li>
</ul></li>
<li>验证 <span class="math inline">\((K, S)\)</span> 是对 <span class="math inline">\(M\)</span> 的签名:
<ul>
<li><span class="math inline">\(y^{K} \cdot K^{S} \equiv g^{M} \bmod
p\)</span></li>
</ul></li>
<li>同 ElGamal 加密方案，签名信息也是消息的 2 倍
<ul>
<li>通常对消息的 HASH 值进行签名</li>
</ul></li>
</ul>
<h3 id="elgamal-签名方案举例">ElGamal 签名方案举例</h3>
<ul>
<li>密钥生成：
<ul>
<li>取 <span class="math inline">\(p = 11, g = 2\)</span></li>
<li>选择私钥 <span class="math inline">\((x = 8)\)</span></li>
<li>计算公钥：
<ul>
<li><span class="math inline">\(y = g^x \bmod p = 2^8 \bmod 11 =
3\)</span></li>
<li>公钥是 <span class="math inline">\((y = 3, g = 2, p =
11)\)</span></li>
</ul></li>
</ul></li>
<li>对 <span class="math inline">\(M = 5\)</span> 签名：
<ul>
<li>选择随机数 <span class="math inline">\(k = 9\)</span></li>
<li>确定 <span class="math inline">\(\gcd(9, 10) = 1\)</span></li>
<li>计算：<span class="math inline">\(K = g^{k} \bmod p = 2^9 \bmod 11 =
6\)</span></li>
<li>求解： <span class="math display">\[
  5 = 8 \times 6 + 9 \cdot S \bmod 10;
  \]</span>
<ul>
<li>因为 <span class="math inline">\(9^{-1} \equiv 9 \bmod
10\)</span></li>
<li>所以 <span class="math inline">\(S = k^{-1}(M - x \cdot K) \bmod (p
- 1) = 9 \times (5 - 8 \times 6) \bmod 10 = 3\)</span></li>
</ul></li>
<li>签名是 <span class="math inline">\((K = 6, S = 3)\)</span></li>
</ul></li>
<li>要验证签名，确认： <span class="math display">\[
  \begin{aligned}
  &amp;y^{K} \cdot K^{S} \bmod p = 3 ^ {6} \cdot 6 ^ {3} \bmod 11 = 10
\\
  &amp;g^{M} \bmod p = 2 ^ {5} \bmod 11 = 10 \\
  \end{aligned}
  \]</span></li>
</ul>
<h2 id="dsa-digital-signature-algorithm">DSA (Digital Signature
Algorithm)</h2>
<ul>
<li>DSA 是数字签名算法，DSS 是数字签名标准</li>
<li>DSA 是 ElGamal 及 Schnorr algorithms 的变形</li>
<li>生成 320 bit 签名</li>
<li>安全性是<strong>基于计算离散对数的困难性</strong></li>
<li>被广泛接受</li>
</ul>
<h3 id="dsa-密钥生成">DSA 密钥生成</h3>
<ul>
<li>首先选取公开参数 <span class="math inline">\((p, q, g)\)</span>：
<ul>
<li>选取大素数 <span class="math inline">\(p\)</span>
<ul>
<li>512 ～ 1024 bit（64 倍数）</li>
</ul></li>
<li>选取素数 <span class="math inline">\(q\)</span>
<ul>
<li>160 bit</li>
<li><span class="math inline">\(q\)</span> 是 <span class="math inline">\(p - 1\)</span> 的因子</li>
</ul></li>
<li>选择 <span class="math inline">\(g = h^{(p - 1) / q}\)</span>
<ul>
<li>满足对任何 <span class="math inline">\(h &lt; p - 1, h^{(p - 1) / q}
(\bmod p) &gt; 1\)</span></li>
</ul></li>
</ul></li>
<li>每个用户选取私钥并计算他们的公钥:
<ul>
<li>选取 <span class="math inline">\(x &lt; q\)</span></li>
<li>计算 <span class="math inline">\(y = g^{x} \bmod p\)</span></li>
<li>公钥是 <span class="math inline">\((y, p, q, g)\)</span></li>
<li>私钥是 <span class="math inline">\((x)\)</span></li>
</ul></li>
</ul>
<h3 id="dsa-签名生成与验证">DSA 签名生成与验证</h3>
<ul>
<li>签名消息 <span class="math inline">\(M\)</span>
<ul>
<li>生成随机签名密钥 <span class="math inline">\(k\)</span>，满足 <span class="math inline">\(k &lt; q\)</span></li>
<li>计算 <span class="math display">\[
  \begin{aligned}
  &amp;K = (g^{k} \bmod p) \bmod q \\
  &amp;S = k^{-1} \cdot (\mathrm{HASH}(M) + x \cdot K) \pmod{q}
  \end{aligned}
  \]</span></li>
</ul></li>
<li>发送签名 <span class="math inline">\((K, S)\)</span> 及消息 <span class="math inline">\(M\)</span></li>
<li>验证签名, 计算: <span class="math display">\[
  \begin{cases}
  w = S^{-1} \pmod{q} \\
  u1 = (\mathrm{HASH}(M)\cdot w) \pmod{q} \\
  u2 = K\cdot w \pmod{q} \\
  v = g^{u1}\cdot y^{u2} \pmod{p}\pmod{q} \\
  \end{cases}\quad
  \Rightarrow v = K?
  \]</span></li>
</ul>
<h3 id="dsa-安全性">DSA 安全性</h3>
<ul>
<li>基于离散对数</li>
<li>最初建议使用一个共同的 modulus p</li>
<li>现在建议不同的工作组使用不同的 <span class="math inline">\((p, q,
g)\)</span></li>
<li>Gus Simmons 发现存在潜信道，能够泄露私钥</li>
</ul>
<h2 id="带密钥的-hash">带密钥的 HASH</h2>
<ul>
<li>以上的签名方法都是公钥技术
<ul>
<li>计算与数据量较大</li>
</ul></li>
<li>需要私钥的认证方案
<ul>
<li>好的方法是使用快速的 hash 函数：</li>
<li>密钥与消息同时参加运算： <span class="math display">\[
  KeyedHash = \mathbf{Hash}(Key \parallel Message)
  \]</span></li>
<li>存在一些弱点</li>
</ul></li>
<li>随后建议： <span class="math display">\[
  KeyedHash = \mathbf{Hash} (Key_1 \parallel \mathbf{Hash} (Key_2
\parallel Message))
  \]</span></li>
</ul>
<h3 id="hmac">HMAC</h3>
<ul>
<li>HMAC 是使用带密钥的 HASH 函数的结果</li>
<li>成为 internet 标准（RFC2104）</li>
<li>结构: <span class="math display">\[
  HMAC_K = \mathbf{Hash}((K^+ \oplus opad) \parallel \mathbf{Hash}((K^+
\oplus \text{ipad}) \parallel M))
  \]</span>
<ul>
<li><span class="math inline">\(K^+\)</span>：经过填充的密钥</li>
<li><span class="math inline">\(opad, ipad\)</span>：特殊的填充值
<ul>
<li><span class="math inline">\(opad=01011010\)</span> 重复 <span class="math inline">\(b/8\)</span> 次</li>
<li><span class="math inline">\(ipad=00110110\)</span> 重复 <span class="math inline">\(b/8\)</span> 次</li>
</ul></li>
</ul></li>
<li>安全性是基于原来的 HASH 函数的安全性</li>
<li>任何 MD5, SHA-1, RIPEMD-160 都可以这样使用</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/SJTU-Notes/" class="category-chain-item">SJTU Notes</a>
  
  
    <span>></span>
    
  <a href="/categories/SJTU-Notes/%E4%BF%A1%E5%AE%89/" class="category-chain-item">信安</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/SJTU/" class="print-no-link">#SJTU</a>
      
        <a href="/tags/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/" class="print-no-link">#现代密码学</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>现代密码学</div>
      <div>https://youyeyejie.github.io/_posts/现代密码学/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>youyeyejie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年11月5日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年11月13日</div>
        </div>
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/_posts/%E5%88%86%E5%B1%82%E5%8F%AF%E5%AF%BC%E8%88%AA%E5%B0%8F%E4%B8%96%E7%95%8C%E5%9B%BEHNSW%E7%AE%80%E4%BB%8B/" title="分层可导航小世界图HNSW简介">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">分层可导航小世界图HNSW简介</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/_posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%89%E5%85%A8/" title="数据库原理及安全">
                        <span class="hidden-mobile">数据库原理及安全</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"youyeyejie/youyeyejie.github.io","repo-id":"R_kgDOO-Uo1g","category":"General","category-id":"DIC_kwDOO-Uo1s4Crz5J","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>







  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>
<div class="footer-inner">
    <div class="powered-by">
        <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
        <i class="iconfont icon-love"></i>
        <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
        <i class="iconfont icon-love"></i>
        <a href="https://cloud.umami.is/share/1fs3cnD9TAP8JzML" target="_blank" rel="nofollow noopener"><span>Umami</span></a>
    </div>
    <div class="hitokoto">
        <i class="fas fa-quote-left"></i>
        <a target="_blank" rel="noopener" href="https://developer.hitokoto.cn/" id="hitokoto_text"><span id="hitokoto">且以群词 注解我这座荒山</span></a>
        <script src="/js/Hitokoto.js" defer></script>
    </div>
    <div class="data">
        <span class="total-word-container">
            <i class="fas fa-chart-bar"></i>
            <span id="g-total-word-id"></span>
            字汇长河
        </span>
        &nbsp;
        <span id="total-posts-container">
            <i class="fas fa-file-alt"></i>
            <span id="g-total-posts-id"></span>
            文舟靠岸
        </span>
        &nbsp;
        <span id="busuanzi_container_site_pv">
            <i class="fas fa-eye"></i>
            <span id="busuanzi_value_site_pv">1314</span>
            目光所及
        </span>
        &nbsp;
        <span id="busuanzi_container_site_uv">
            <i class="fas fa-user-friends"></i>
            <span id="busuanzi_value_site_uv">520</span>
            访客驻足
        </span>
    </div>
    <div class="duration">
        <i class="fas fa-calendar"></i>
        <span id="duration-container">人生缓缓&nbsp;自有答案</span>
        <script src="/js/Duration.js"></script>
    </div>
</div>

<link href="/css/Footer.css" type="text/css" rel="stylesheet"/>
<script>
    document.querySelectorAll("[id^='busuanzi_value_']").forEach(element => {
        element.id = element.id.replace("busuanzi_value_", "vercount_value_");
    });
</script>
<script defer src="https://events.vercount.one/js"></script>
<!-- <script src="https://npm.elemecdn.com/penndu@1.0.0/bsz.js" defer></script> -->
<!-- <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script> -->
<!-- <script async src="https://busuanzi.icodeq.com/busuanzi.pure.mini.js"></script> -->
<!-- <script async src="https://busuanzi.sukap.cn/busuanzi.pure.mini.js"></script> -->
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="/js/busuanzi.pure.mini.js" ></script>




  
<script src="/js/Crypto.js"></script>
<script src="/js/LinkCard.js"></script>
<script src="/js/RandomBanner.js"></script>
<script src="/js/Background.js"></script>
<script src="/js/ScrollAnimation.js"></script>
<script src="/js/Sidebar.js"></script>
<script src="/js/TabDisplay.js"></script>
<script src="/js/Tooltip.js"></script>
<script src="/js/Umami.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  <script type="text/javascript">
  document.getElementById("g-total-word-id").innerHTML = "651k";
  document.getElementById('g-total-posts-id').textContent ="63";
</script>

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start -->
<script src="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.js"></script>

  <script>
  const CODE_CONFIG = {
    beautify: true,
    highlightCopy: true,
    highlightLang: true,
    highlightHeightLimit: 360,
    isHighlightShrink: false,
    copy: {
      success: 'Copy Success',
      error: 'Copy Error',
      noSupport: 'Browser Not Support',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body>
</html>
