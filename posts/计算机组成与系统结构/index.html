

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><!-- hexo injector head_begin start --><meta name="msvalidate.01" content="DF9F232801BA9D0CABB002E4774A3228" />
<meta name="google-site-verification" content="vOm5Zs9tuUlEh-wVBlpvs_spnOou-q2CoTiFQ1ZV1h4" />
<!-- hexo injector head_begin end -->
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar/avatar2.png">
  <link rel="icon" href="/img/avatar/avatar2.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="youyeyejie">
  <meta name="keywords" content="yyyj,YYYJ,youyeyejie,有野野芥">
  
    <meta name="description" content="NIS2331 计算机组成与系统结构 笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机组成与系统结构">
<meta property="og:url" content="https://youyeyejie.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="有野野芥的博客">
<meta property="og:description" content="NIS2331 计算机组成与系统结构 笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://youyeyejie.github.io/img/cover/nis2331.jpg">
<meta property="article:published_time" content="2025-01-23T01:09:34.000Z">
<meta property="article:modified_time" content="2025-06-23T10:20:58.236Z">
<meta property="article:author" content="youyeyejie">
<meta property="article:tag" content="SJTU">
<meta property="article:tag" content="计算机组成">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://youyeyejie.github.io/img/cover/nis2331.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>计算机组成与系统结构 - 有野野芥的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">
<link rel="stylesheet" href="//lib.baomitu.com/font-awesome/6.1.2/css/all.min.css">


<link  rel="stylesheet" href="/css/main.css" />




  
<link rel="stylesheet" href="/css/CodeBlock.css">
<link rel="stylesheet" href="/css/CodeInLine.css">
<link rel="stylesheet" href="/css/Footer.css">
<link rel="stylesheet" href="/css/FrostedGlassBg.css">
<link rel="stylesheet" href="/css/IndexImgHover.css">
<link rel="stylesheet" href="/css/LinkCard.css">
<link rel="stylesheet" href="/css/RainbowLoading.css">
<link rel="stylesheet" href="/css/ScrollAnimation.css">
<link rel="stylesheet" href="/css/ScrollBar.css">
<link rel="stylesheet" href="/css/StrongInDark.css">
<link rel="stylesheet" href="/css/TitleGradient.css">
<link rel="stylesheet" href="/css/TitleNeon.css">
<link rel="stylesheet" href="/css/UnifyImgWidth.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"youyeyejie.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":false,"default":"TEXT"},"copy_btn":false,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading/loading3.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.css">
<style>:root{--hl-color:#abb2bf;--hl-bg:#282c34;--hltools-bg:#21252b;--hltools-color:#bbbbbc;--hlnumber-bg:#282c34;--hlnumber-color:#495162;--hlscrollbar-bg:#373c47;--hlexpand-bg:linear-gradient(180deg,rgba(40,44,52,0.1),rgba(40,44,52,0.9))}</style>
    <style>
    .code-expand-btn:not(.expand-done) ~ div.codeblock,
    .code-expand-btn:not(.expand-done) ~ * div.codeblock {
      overflow: hidden;
      height: 360px;
    }
    </style>
  <!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  <div id="loader-container"> 
    <div id="loader" class="loader"></div>
    <div class="loader-inner">
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
        <div class="loader-line-wrap">
            <div class="loader-line"></div>
        </div>
    </div>
</div>

  <header>
    

<div class="header-inner" style="height: 100vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <!-- <strong>YYYJ&#39;s Blog</strong> -->
       <strong class="navbar-title">YYYJ&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="https://www.travellings.cn/go-by-clouds.html" target="_self">
                <i class="fas fa-train-subway"></i>
                <span>开往</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/banner/banner.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="计算机组成与系统结构"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        youyeyejie
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-01-23 09:09" pubdate>
          2025年1月23日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          106 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        

      
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar category-bar" style="margin-right: -1rem">
    





<div class="category-list">
  
  
    
    
    
    <div class="category row nomargin-x">
      <a class="category-item 
          list-group-item category-item-action col-10 col-md-11 col-xm-11" title="SJTU Notes"
        id="heading-23fc8849f7fe9b9a570be52f7807b4ac" role="tab" data-toggle="collapse" href="#collapse-23fc8849f7fe9b9a570be52f7807b4ac"
        aria-expanded="true"
      >
        SJTU Notes
        <span class="list-group-count">(14)</span>
        <i class="iconfont icon-arrowright"></i>
      </a>
      
      <div class="category-collapse collapse show" id="collapse-23fc8849f7fe9b9a570be52f7807b4ac"
           role="tabpanel" aria-labelledby="heading-23fc8849f7fe9b9a570be52f7807b4ac">
        
        
          
  <div class="category-post-list">
    
    
      
      
        <a href="/posts/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/" title="中国近现代史纲要"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">中国近现代史纲要</span>
        </a>
      
    
      
      
        <a href="/posts/%E4%B9%A0%E8%BF%91%E5%B9%B3%E6%96%B0%E6%97%B6%E4%BB%A3%E4%B8%AD%E5%9B%BD%E7%89%B9%E8%89%B2%E7%A4%BE%E4%BC%9A%E4%B8%BB%E4%B9%89%E6%80%9D%E6%83%B3%E6%A6%82%E8%AE%BA/" title="习近平新时代中国特色社会主义思想概论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">习近平新时代中国特色社会主义思想概论</span>
        </a>
      
    
      
      
        <a href="/posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="信息论基础"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">信息论基础</span>
        </a>
      
    
      
      
        <a href="/posts/%E5%86%9B%E4%BA%8B%E7%90%86%E8%AE%BA/" title="军事理论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">军事理论</span>
        </a>
      
    
      
      
        <a href="/posts/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/" title="思想道德与法治"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">思想道德与法治</span>
        </a>
      
    
      
      
        <a href="/posts/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/" title="抽象代数"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">抽象代数</span>
        </a>
      
    
      
      
        <a href="/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/" title="操作系统原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">操作系统原理</span>
        </a>
      
    
      
      
        <a href="/posts/%E6%95%B0%E5%AD%A6%E5%8F%B2/" title="数学史"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">数学史</span>
        </a>
      
    
      
      
        <a href="/posts/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/" title="概率统计"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">概率统计</span>
        </a>
      
    
      
      
        <a href="/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">编译原理</span>
        </a>
      
    
      
      
        <a href="/posts/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/" title="网络空间安全导论"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">网络空间安全导论</span>
        </a>
      
    
      
      
        <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" title="计算机组成与系统结构"
           class="list-group-item list-group-item-action
           active">
          <span class="category-post">计算机组成与系统结构</span>
        </a>
      
    
      
      
        <a href="/posts/%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6/" title="量子力学"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">量子力学</span>
        </a>
      
    
      
      
        <a href="/posts/%E9%A9%AC%E5%85%8B%E6%80%9D%E4%B8%BB%E4%B9%89%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="马克思主义基本原理"
           class="list-group-item list-group-item-action
           ">
          <span class="category-post">马克思主义基本原理</span>
        </a>
      
    
  </div>

        
      </div>
    </div>
  
</div>


  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">计算机组成与系统结构</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>本笔记基于上海交通大学 <em>许可老师</em> 2024-2025
学年秋季学期教学内容进行整理，部分图片来源于网络，如有侵权请联系删除。</p>
</blockquote>
<h1 id="ch12-导论-计算机的演变和性能">Ch1~2 导论 计算机的演变和性能</h1>
<h2 id="计算机发展简史">计算机发展简史</h2>
<ul>
<li>第一代：真空管</li>
<li>第二代：晶体管</li>
<li>第三代：集成电路</li>
<li>第三代以后：超大规模集成电路</li>
</ul>
<h2 id="ias计算机">IAS计算机</h2>
<ul>
<li>1945年，冯·诺依曼提出的计算机体系结构</li>
</ul>
<h2 id="摩尔定律">摩尔定律</h2>
<ul>
<li>集成电路的集成度每年翻一倍，后修正为18个月</li>
<li>影响：
<ul>
<li>集成度增加的同时单芯片成本几乎不变；</li>
<li>高集成度，电路短，速度快；</li>
<li>体积、能耗、冷却需求小；</li>
<li>片外互联少，可靠性高。</li>
</ul></li>
</ul>
<h2 id="微处理器速度">微处理器速度</h2>
<h3 id="芯片制造技术">芯片制造技术</h3>
<ul>
<li>当代处理器内置技术：
<ul>
<li>流水线</li>
<li>分支预测</li>
<li>超标量执行</li>
<li>数据流分析</li>
<li>推测执行</li>
</ul></li>
</ul>
<h2 id="性能平衡">性能平衡</h2>
<ul>
<li>问题1：处理器比主存快太多
<ol type="1">
<li>提高一次性读取数据位数；</li>
<li>改进DRAM接口（使用cache）；</li>
<li>减少主存访问频度（多级cache）；</li>
<li>提高互联带宽（更高速的总线，改进总线层次）</li>
</ol></li>
<li>问题2：频繁操作、高吞吐量的IO与处理器间的数据传输
<ol type="1">
<li>提高IO设备速度；</li>
<li>减少IO操作频度（使用cache）；</li>
<li>改进IO接口（DMA）；</li>
<li>改进互联结构（高速总线、改变互联结构）</li>
</ol></li>
</ul>
<h2 id="改进芯片组成和体系结构">改进芯片组成和体系结构</h2>
<h3 id="提高处理器速度的方法">提高处理器速度的方法：</h3>
<ol type="1">
<li>提高硬件速度：缩小逻辑门尺寸，提高时钟频率（CLK）
<ul>
<li>但是时钟频率和逻辑密度的增加会造成：功率增加、RC延迟增长、内存延迟和吞吐量滞后更严重</li>
</ul></li>
<li>增加处理器与主存间高速缓存的大小和速度</li>
<li>改变体系结构：更复杂的指令执行逻辑，并行、流水线、超标量
<ul>
<li>上述方法收益递减，因此目前新方向是多核</li>
</ul></li>
</ol>
<h2 id="计算机性能评估">计算机性能评估</h2>
<ol type="1">
<li>时钟速度（也叫时钟频率）：传统
<ul>
<li>缺点：不同指令需要的时钟周期不同；有流水线的处理器在相同时钟频率下执行的指令更多</li>
</ul></li>
<li>CPI（程序每条机器指令所需的平均时间周期数）：
<ul>
<li>通常不同类指令的CPI不同</li>
<li><span class="math inline"><em>I</em><sub><em>c</em></sub></span>：规定时间内执行的机器指令总条数</li>
<li><span class="math inline"><em>C</em><em>P</em><em>I</em><sub><em>i</em></sub></span>，<span class="math inline"><em>I</em><sub><em>i</em></sub></span>：给定程序中i类指令的CPI和执行条数</li>
<li><span class="math inline"><em>f</em></span>：时钟频率，<span class="math display">$$τ=\frac{1}{f}$$</span></li>
<li>有： <span class="math display">$$
  \begin{aligned}
  CPI&amp;=\frac{\sum_{i=1}^{n}(CPI_i×I_i)}{I_c}\\
  T&amp;=I_c×CPI×τ
  \end{aligned}
  $$</span></li>
</ul></li>
<li>MIPS速率（每秒执行的百万条指令的数量）：
<ul>
<li><span class="math display">$$MIPS=\frac{I_c}{T\times
10^6}=\frac{f}{CPI\times 10^6}$$</span></li>
<li>注：关于CPI与MIPS计算，课本p43有例题</li>
</ul></li>
<li>MFLOPS速率（每秒执行的百万次浮点运算的数量）：
<ul>
<li>是由于CISC相比RISC，一条指令耗时更长但功能更多，用MIPS可能不合适</li>
<li><span class="math display">$$MFLOPS=\frac{\text{程序中执行的浮点操作数量}}{\text{执行时间}\times
10^6}$$</span></li>
</ul></li>
<li>SPEC速度度量：
<ul>
<li>以基准程序i在参照系统上的运行时间作为基准程序i的参考运行时间<span class="math inline"><em>T</em><em>r</em><em>e</em><em>f</em><sub><em>i</em></sub></span></li>
<li>以基准程序i在被测系统上的运行时间作为基准程序i的参考运行时间<span class="math inline"><em>T</em><em>s</em><em>u</em><em>t</em><sub><em>i</em></sub></span></li>
<li><span class="math display">$$r_i=\frac{Tref_i}{Tsut_i}$$</span>
<ul>
<li>是参考时间/被测时间，速度更快的机器比值更高</li>
</ul></li>
<li><span class="math display">$$r_G=(\prod_{i=1}^{n}r_i)^{\frac{1}{n}}$$</span>
<ul>
<li>作几何平均，作为被测机器的SPEC速度度量</li>
</ul></li>
</ul></li>
<li>SPEC频率度量：
<ul>
<li>测量执行多个任务的吞吐量，多个基准程序的拷贝同时执行</li>
<li><span class="math display">$$r_i=\frac{N×Tref_i}{Tsut_i}$$</span></li>
<li><span class="math inline"><em>T</em><em>r</em><em>e</em><em>f</em><sub><em>i</em></sub></span>为基准程序i在参照系统上运行的时间，N是同时执行的程序数量</li>
<li><span class="math inline"><em>T</em><em>s</em><em>u</em><em>t</em><sub><em>i</em></sub></span>为N个基准程序在被测系统上从开始执行到全部完成所需时间</li>
</ul></li>
</ol>
<h2 id="amdahl定律衡量多个处理器的加速比">Amdahl定律：衡量多个处理器的加速比</h2>
<p><span class="math display">$$
\text{加速比}=\frac{\text{增强前的性能（执行时间）}}{\text{增强后的性能（执行时间）}}=
\frac{\text{程序在单处理器上的执行时间}}{\text{程序在N个并行处理器上的执行时间}}
$$</span></p>
<p>令：<span class="math inline"><em>f</em></span>为程序中可以无限并行执行的部分，<span class="math inline">1 − <em>f</em></span>为程序中固定只能串行执行的部分，<span class="math inline"><em>T</em></span>为程序在单处理器上的执行时间，<span class="math inline"><em>N</em></span>为并行系统的处理器数，则：</p>
<p><span class="math display">$$Speedup=\frac{T}{T(1-f)+\frac{Tf}{N}}=\frac{1}{(1-f)+\frac{f}{N}}$$</span></p>
<p>结论：</p>
<ul>
<li><span class="math inline"><em>f</em></span>非常小时并行处理意义不大；</li>
<li><span class="math display">$$\lim_{N→∞}Speedup=\frac{1}{1-f}$$</span></li>
</ul>
<h2 id="总线数据传输率">总线数据传输率</h2>
<p><span class="math display">$$\text{总线数据传输率}=\frac{\text{一段时间内传输的数据量}}{\text{这段时间}}$$</span></p>
<h1 id="ch3-计算机功能和互连的顶层视图">Ch3
计算机功能和互连的顶层视图</h1>
<h2 id="计算机的寄存器">计算机的寄存器</h2>
<ul>
<li>PC：程序计数器，保存下条要执行的指令的地址</li>
<li>IR：指令寄存器</li>
<li>MAR：内存地址寄存器，保存地址</li>
<li>MBR：内存缓冲寄存器，保存数据</li>
</ul>
<h2 id="机器周期和指令周期">机器周期和指令周期</h2>
<ol type="1">
<li>机器周期（CPU周期）：
<ul>
<li>定义：从寄存器中取出两个数，执行一次ALU操作，并将结果存回寄存器所需时间</li>
<li>人为规定的对一条指令执行过程的划分</li>
<li>一个机器周期一般包含了多个时钟周期，一个指令周期包含了多个机器周期；一个指令周期包含多个流水线阶段，一个流水线阶段包含了一至多个机器周期。</li>
</ul></li>
<li>指令周期：单条指令所需要的处理时间，可粗略分为取指周期和执行周期
<ul>
<li>取指周期：
<ul>
<li>CPU从PC获得地址并读取该地址存储的指令，PC++（除非指令修改PC），指令被加载到指令寄存器IR，CPU译指</li>
</ul></li>
<li>执行周期：
<ul>
<li>计算操作数地址，获取操作数（从内存或IO到CPU），数据操作，数据保存（从CPU到内存或IO）</li>
</ul></li>
</ul></li>
</ol>
<figure>
<img src="image-29.png" srcset="/img/loading/loading3.gif" lazyload alt="指令周期状态图">
<figcaption aria-hidden="true">指令周期状态图</figcaption>
</figure>
<h2 id="中断">中断</h2>
<ol type="1">
<li>类型：
<ul>
<li>程序中断（溢出、除0）</li>
<li>CPU定时器中断</li>
<li>IO中断</li>
<li>硬件故障</li>
</ul></li>
<li>无中断程序：
<ul>
<li>CPU必须等待IO操作完成才能执行自己的下一条指令，图中的④表示为IO操作做准备的一系列指令，⑤表示IO操作完成后用来完成操作（收尾，比如设置标志之类）的一系列指令。</li>
<li><figure>
<img src="image.png" srcset="/img/loading/loading3.gif" lazyload alt="无中断程序流">
<figcaption aria-hidden="true">无中断程序流</figcaption>
</figure></li>
</ul></li>
<li>中断：
<ul>
<li>CPU在调用IO时仅执行④（准备代码和实际IO指令），之后马上返回用户程序。</li>
<li>在IO操作的过程中，CPU也在执行用户程序指令。</li>
<li>在IO完成IO操作后，即IO准备好接受服务后，IO向处理器发出中断请求信号。</li>
<li>处理器响应中断请求，挂起当前程序，执行中断处理程序（图中的⑤）。</li>
<li>中断处理程序执行完成后，CPU恢复用户程序的执行。</li>
<li><figure>
<img src="image-1.png" srcset="/img/loading/loading3.gif" lazyload alt="有中断程序流">
<figcaption aria-hidden="true">有中断程序流</figcaption>
</figure></li>
</ul></li>
<li>中断周期：指令周期的一部分
<ul>
<li>处理器检查是否有中断请求，若没有，则执行下一条指令；若有，则：
<ul>
<li>挂起当前程序，保存上下文；</li>
<li>将PC设置为中断处理程序的起始地址；</li>
<li>处理中断；</li>
<li>恢复上下文并继续执行被中断的程序。</li>
</ul></li>
</ul></li>
<li>多中断：两种解决方法
<ul>
<li>禁止中断：
<ul>
<li>CPU在处理中断时禁止其他中断；</li>
<li>CPU处理完当前中断后检测是否还存在未响应的中断；</li>
<li>中断严格按照顺序处理。</li>
</ul></li>
<li>定义优先级：高优先级中断可中断低优先级中断，嵌套处理。</li>
</ul></li>
</ol>
<h2 id="计算机顶层互联">计算机顶层互联</h2>
<ol type="1">
<li>内存：
<ul>
<li>输入：读写控制信号，地址，数据</li>
<li>输出：数据</li>
</ul></li>
<li>IO模块：通过多个端口控制多个外设
<ul>
<li>输入：读写控制信号，地址，来自计算机的数据，来自外设的数据</li>
<li>输出：送给CPU的数据，送给外设的数据数据，中断信号</li>
</ul></li>
<li>CPU：
<ul>
<li>输入：指令、数据、中断信号</li>
<li>输出：地址、控制信号、数据</li>
</ul></li>
</ol>
<h2 id="计算机总线">计算机总线：</h2>
<p>连接两个及以上设备的共享的通信通道，一次只能有一个设备传输成功</p>
<ol type="1">
<li>系统总线：连接主要计算机组件（CPU、M、IO）的总线
<ul>
<li>系统总线又分为：
<ul>
<li>数据总线：数据总线的宽度是决定系统整体性能的关键因素，称为字长。</li>
<li>地址总线：地址总线的位宽决定了系统可能的最大内存容量。</li>
<li>控制总线、控制对数据总线、地址总线的访问和应用。</li>
</ul></li>
</ul></li>
<li>总线类型：
<ul>
<li>专用总线：数据线和地址线分离</li>
<li>复用总线：数据和地址共享线路，靠数据有效/地址有效控制。线路少，单控制复杂，性能低</li>
</ul></li>
<li>单一总线：传输延迟、总线带宽瓶颈</li>
<li>总线仲裁：
<ul>
<li>不止一个模块能控制总线，但同一时刻只有一个模块能控制总线。</li>
<li>集中式：总线仲裁器控制总线的访问</li>
<li>分布式：每个模块都能宣布对总线的控制</li>
</ul></li>
<li>时序
<ul>
<li>同步时序：时钟信号决定事件发生，一个0-1变化称为一个总线周期，通常以上升沿同步，通常一个总线周期对应一个事件。</li>
<li>异步时序：完全依赖线路引脚通知。</li>
</ul></li>
<li>PCI Express
<ul>
<li>高带宽、独立于处理器的总线，可用于中间层和外设总线，为高速IO子系统提供了更好的性能。（图形、网络、磁盘控制器）</li>
</ul></li>
</ol>
<h1 id="ch4-cache存储器">Ch4 Cache存储器</h1>
<h2 id="cache的传输单位">Cache的传输单位</h2>
<ol type="1">
<li>字：存储器组织的天然单位，存储器单次传输所能传输数据的宽度</li>
<li>可寻址单元：能唯一确定地址的最小单位。一般是字或字节。
<ul>
<li>地址位数 <span class="math inline"><em>A</em></span>
与可寻址单元个数 <span class="math inline"><em>N</em></span>：<span class="math inline">2<sup><em>A</em></sup> = <em>N</em></span></li>
</ul></li>
<li>传输单位：
<ul>
<li>对主存：一次读出/写入存储器的位数，通常是数据总线宽度。</li>
<li>对外存：以块为单位</li>
</ul></li>
</ol>
<h2 id="cache访问数据单元的方式">Cache访问数据单元的方式</h2>
<ol type="1">
<li>顺序访问：必须以特定线性顺序访问，访问时间高度变化。
<ul>
<li>磁带</li>
</ul></li>
<li>直接访问：存储器中每个数据块有唯一地址，以此先通过块间跳转找到块，再在块内顺序搜索定位可寻址单元。访问时间变化。
<ul>
<li>磁盘</li>
</ul></li>
<li>随机访问：存储器中每个可寻址位置都是唯一的，以此直接定位可寻址单元。访问时间固定。
<ul>
<li>主存</li>
</ul></li>
<li>关联存取：属于随机访问类型的存储器，根据数据部分内容确定存储位置，存取时间与数据位置无关。
<ul>
<li>Cache</li>
</ul></li>
</ol>
<h2 id="cache性能">Cache性能</h2>
<ol type="1">
<li>访问时间（延迟）：
<ul>
<li>对随机访问存储器：读写操作所需时间</li>
<li>对非随机访问存储器：定位时间</li>
</ul></li>
<li>存储器周期时间：随机访问存储器，访问时间+第二次访问开始前所需额外时间</li>
<li>传输速率：通常以 <span class="math inline"><em>b</em><em>i</em><em>t</em>/<em>s</em>(<em>b</em><em>p</em><em>s</em>)</span>为单位
<ul>
<li>对随机： <span class="math display">$$\text{传输速率}=\frac{1}{\text{周期时间}}$$</span></li>
<li>对非随机：
<ul>
<li><span class="math display">$$T_n=T_A+\frac{n}{R}$$</span></li>
<li><span class="math inline"><em>T</em><sub><em>n</em></sub>=</span>
读/写n位的平均时间；</li>
<li><span class="math inline"><em>T</em><sub><em>A</em></sub>=</span>
平均访问时间；</li>
<li><span class="math inline"><em>n</em>=</span> 位数；<span class="math inline"><em>R</em>=</span> 传输速率，以 <span class="math inline"><em>b</em><em>p</em><em>s</em></span> 为单位。</li>
</ul></li>
</ul></li>
</ol>
<h2 id="cache特性">Cache特性</h2>
<ul>
<li>越快越贵</li>
<li>越快越耗能</li>
<li>越大越慢</li>
<li>越大越便宜</li>
<li>越大越耗能</li>
</ul>
<h2 id="访问局部性原理">访问局部性原理：</h2>
<ul>
<li>在程序执行期间，CPU对指令、数据的访问往往比较集中，即在某一段时间内，CPU对某些指令或数据的访问频率较高，这种现象称为访问局部性。
<ul>
<li>时间局部性：如果某个数据被访问过，那么在不久的将来，它很可能会再次被访问。</li>
<li>空间局部性：如果某个数据被访问过，那么它附近的数据很可能会被访问。</li>
</ul></li>
</ul>
<h2 id="存储器分层">存储器分层：</h2>
<ul>
<li>从上至下：
<ul>
<li>容量越来越大</li>
<li>每位价格越来越便宜</li>
<li>速度越来越慢</li>
<li>访问频率越来越低（依赖于访问局部性原理）</li>
</ul></li>
</ul>
<h2 id="cache原理和操作">Cache原理和操作：</h2>
<ul>
<li>主存由多个块构成，每个块包含 <span class="math inline"><em>K</em></span> 个字。</li>
<li>Cache由多个块构成，每个块称为一行，每行包括 <span class="math inline"><em>K</em></span>
个字以及若干位标签、控制位（行的大小为 <span class="math inline"><em>K</em></span> 个字，不算标签和控制位）。</li>
<li>主存和Cache之间以块为单位传输，Cache和CPU之间以字为单位传输。</li>
<li>Cache读操作：
<ul>
<li>检查数据是否在Cache中；</li>
<li>若命中，直接访问Cache；</li>
<li>若缺失，从主存中加载包含这个字的块，并将这个字送到CPU中，两个操作同时发生。</li>
</ul></li>
<li>Cache写操作：
<ul>
<li>检查数据是否在Cache中；</li>
<li>若命中，直接更新Cache行；</li>
<li>若缺失，从主存中加载包含这个字的块，并更新Cache行。</li>
</ul></li>
</ul>
<h2 id="主存块与cache行之间的映射方式">主存块与Cache行之间的映射方式</h2>
<figure>
<img src="image-2.png" srcset="/img/loading/loading3.gif" lazyload alt="Cache映射">
<figcaption aria-hidden="true">Cache映射</figcaption>
</figure>
<h3 id="直接映射">直接映射</h3>
<p><span class="math display"><em>i</em> = <em>j</em> mod &nbsp;<em>m</em></span></p>
<p><span class="math inline"><em>i</em>=</span> 高速缓存行号；<span class="math inline"><em>j</em>=</span> 主存块号；<span class="math inline"><em>m</em>=</span> 高速缓存行总数。</p>
<figure>
<img src="image-31.png" srcset="/img/loading/loading3.gif" lazyload alt="直接映射">
<figcaption aria-hidden="true">直接映射</figcaption>
</figure>
<ul>
<li>从主存来看：
<ul>
<li>主存地址长度 = <span class="math inline">(<em>s</em> + <em>w</em>)</span> 位，其中最低 <span class="math inline"><em>w</em></span> 位指定主存的一个块内的 <span class="math inline">2<sup><em>w</em></sup></span>
个字中的一个字/字节，剩下 <span class="math inline"><em>s</em></span>
位指定主存内的 <span class="math inline">2<sup><em>s</em></sup></span>
个块中的一块</li>
<li>可寻址单元个数 = <span class="math inline">2<sup>(<em>s</em> + <em>w</em>)</sup></span>
个字/字节</li>
<li>块大小=行大小 = <span class="math inline">2<sup><em>w</em></sup></span> 个字/字节</li>
</ul></li>
<li>从Cache来看：
<ul>
<li>主存地址最高 <span class="math inline"><em>s</em></span> 位 = 低
<span class="math inline"><em>r</em></span> 位 + 高 <span class="math inline">(<em>s</em> − <em>r</em>)</span> 位，其中低 <span class="math inline"><em>r</em></span> 位指定 Cache 的 <span class="math inline">2<sup><em>r</em></sup></span> 行中的一行，高 <span class="math inline">(<em>s</em> − <em>r</em>)</span>
位被当作标签存储。</li>
<li>Cache行数：<span class="math inline">2<sup><em>r</em></sup></span>
行</li>
<li>Cache大小：<span class="math inline">2<sup>(<em>r</em> + <em>w</em>)</sup></span>
个字/字节</li>
<li>标签大小：<span class="math inline">(<em>s</em> − <em>r</em>)</span>
位</li>
<li>即：<span class="math inline">(<em>s</em> − <em>r</em>)</span>
位标签 + <span class="math inline"><em>r</em></span> 位Cache内行号 =
<span class="math inline"><em>s</em></span> 位主存块号</li>
</ul></li>
<li>优点：简单便宜</li>
<li>缺点：任何给定块都只有固定的Cache存储位置。若程序需要访问的两个块正好映射到同一行，这两个块就会不断交换，降低命中率，称为抖动。</li>
</ul>
<h3 id="全关联映射">全关联映射：</h3>
<p>允许每个主存块加载到任意Cache行，标签 = 主存块号</p>
<figure>
<img src="image-30.png" srcset="/img/loading/loading3.gif" lazyload alt="全关联映射">
<figcaption aria-hidden="true">全关联映射</figcaption>
</figure>
<ul>
<li>优点：命中率提高</li>
<li>缺点：访问时需要复杂电路并行检查全部行的标签</li>
</ul>
<h3 id="k路组关联映射">K路组关联映射</h3>
<figure>
<img src="image-32.png" srcset="/img/loading/loading3.gif" lazyload alt="组关联映射">
<figcaption aria-hidden="true">组关联映射</figcaption>
</figure>
<p><span class="math display">$$
\begin{aligned}
m=v \times k\\
i=j \mod v
\end{aligned}
$$</span></p>
<p><span class="math inline"><em>i</em></span> = Cache的组号；<span class="math inline"><em>j</em></span> = 主存块号；<span class="math inline"><em>m</em></span> = Cache中的行数；<span class="math inline"><em>v</em></span> = 组数；<span class="math inline"><em>k</em></span> = 每组中的行数。</p>
<ul>
<li>从主存来看：
<ul>
<li>主存地址长度 = <span class="math inline">(<em>s</em> + <em>w</em>)</span> 位，其中最低 <span class="math inline"><em>w</em></span> 位指定主存的一个块内的 <span class="math inline">2<sup><em>w</em></sup></span>
个字中的一个字/字节，剩下 <span class="math inline"><em>s</em></span>
位指定主存内的 <span class="math inline">2<sup><em>s</em></sup></span>
个块中的一块</li>
<li>可寻址单元个数 = <span class="math inline">2<sup>(<em>s</em> + <em>w</em>)</sup></span>
个字/字节</li>
<li>块大小 = 行大小 = <span class="math inline">2<sup><em>w</em></sup></span> 个字/字节</li>
</ul></li>
<li>从Cache来看：
<ul>
<li>主存地址最高 <span class="math inline"><em>s</em></span> 位 = 低
<span class="math inline"><em>d</em></span> 位 + 高 <span class="math inline">(<em>s</em> − <em>d</em>)</span> 位，其中低 <span class="math inline"><em>d</em></span> 位指定 Cache 的 <span class="math inline">2<sup><em>d</em></sup></span> 组中的一组，高 <span class="math inline">(<em>s</em> − <em>d</em>)</span>
位被当作标签存储。</li>
<li>Cache组数：<span class="math inline"><em>v</em> = 2<sup><em>d</em></sup></span> 行</li>
<li>Cache行数：<span class="math inline"><em>m</em> = <em>k</em><em>v</em> = <em>k</em> × 2<sup><em>d</em></sup></span></li>
<li>Cache大小：<span class="math inline"><em>k</em> × 2<sup>(<em>d</em> + <em>w</em>)</sup></span>
个字/字节</li>
<li>标签大小：<span class="math inline">(<em>s</em> − <em>d</em>)</span>
位</li>
<li>即：<span class="math inline">(<em>s</em> − <em>d</em>)</span>
位标签 + <span class="math inline"><em>d</em></span> 位Cache内组号 =
<span class="math inline"><em>s</em></span> 位主存块号</li>
</ul></li>
<li>优点：灵活，标签较小，且只需并行比较组内的 <span class="math inline"><em>k</em></span> 个标签</li>
</ul>
<h2 id="替换算法">替换算法</h2>
<p>当Cache已满而又有新块需要调入，就必须替换Cache中的块。</p>
<ul>
<li>最近最少使用算法（LRU）
<ul>
<li>替换组内在Cache中最久没有被引用过的块。以2路组关联为例，当组中一行被引用时，其USE位置1，另一行USE置0。替换时选择USE为0的行。</li>
</ul></li>
<li>先进先出算法（FIFO）
<ul>
<li>替换组内最早进入Cache的块。</li>
</ul></li>
<li>最不经常使用（LFU）：
<ul>
<li>替换组内使用频率最低的块。</li>
</ul></li>
<li>随机
<ul>
<li>随机选择组内的一个块进行替换。</li>
</ul></li>
</ul>
<h2 id="写策略">写策略</h2>
<ul>
<li>通写（写直达）：所有写都会施加于Cache和主存。任何其他处理器和Cache都可以监视到主存的改变以维护一致性。
<ul>
<li>优点：简单</li>
<li>缺点：产生大量主存流量，让写变慢</li>
</ul></li>
<li>回写：CPU写的更新仅在Cache中执行，此时USE为置1。当一个块被替换时，仅当USE位为1才会被写回主存。
<ul>
<li>优点：最小化主存写操作</li>
<li>缺点：部分主存在块替换前是无效的，IO存取只能通过Cache进行。</li>
</ul></li>
</ul>
<h2 id="行块大小">行/块大小</h2>
<p>随着行大小从很小到较大，命中率先上升后下降。</p>
<ul>
<li>原因：
<ul>
<li>行较大时Cache中行数较少；</li>
<li>行较大时离访问位置较远的字再次访问概率低（局部性原理）</li>
</ul></li>
</ul>
<h1 id="ch5-内部存储器">Ch5 内部存储器</h1>
<h2 id="半导体存储器类型">半导体存储器类型</h2>
<table>
<thead>
<tr>
<th>存储器类型</th>
<th>种类</th>
<th>可擦除性</th>
<th>写机制</th>
<th>易失性</th>
</tr>
</thead>
<tbody>
<tr>
<td>随机存储器(RAM)</td>
<td>读-写存储器</td>
<td>电，字节级</td>
<td>电</td>
<td>易失</td>
</tr>
<tr>
<td>只读存储器(ROM)</td>
<td>只读存储器</td>
<td>不能</td>
<td>掩模</td>
<td>不易失</td>
</tr>
<tr>
<td>可编程ROM(PROM)</td>
<td>只读存储器</td>
<td>不能</td>
<td>电</td>
<td>不易失</td>
</tr>
<tr>
<td>可擦PROM(EPROM)</td>
<td>读多次存储器</td>
<td>紫外线，字节级</td>
<td>电</td>
<td>不易失</td>
</tr>
<tr>
<td>电可擦PROM(EEPROM)</td>
<td>读多次存储器</td>
<td>电，字节级</td>
<td>电</td>
<td>不易失</td>
</tr>
<tr>
<td>快闪存储器</td>
<td>读多次存储器</td>
<td>电，块级</td>
<td>电</td>
<td>不易失</td>
</tr>
</tbody>
</table>
<p>注：SRAM和DRAM都需要持续供电。</p>
<h2 id="dram动态ram">DRAM（动态RAM）</h2>
<ul>
<li>数据被存储为电容上的电荷</li>
<li>由于电容有漏电的天性，DRAM需要定期充电（刷新）。</li>
<li>结构简单，成本较低，速度较慢。常用于主存。</li>
</ul>
<h2 id="sram静态ram">SRAM（静态RAM）</h2>
<ul>
<li>用触发器逻辑门存储数据</li>
<li>不漏电，不需要定期刷新（但也需要持续供电！）</li>
<li>结构更复杂，成本更高，体积更大，但速度更快。常用于Cache。</li>
</ul>
<h2 id="存储器芯片组织">存储器芯片组织</h2>
<ol type="1">
<li>位扩展：增加存储模块单次传输所能传输的位
<ul>
<li>N块芯片读取相同的地址，每块芯片同时输出其在相同行列位置上存储的数据（假设输出
<span class="math inline"><em>m</em></span>
bit），则存储模块的一个地址可以存储 <span class="math inline">(<em>N</em> × <em>m</em>)<em>b</em><em>i</em><em>t</em></span>
数据。</li>
<li>例：位扩展前，一个芯片只能输出 <span class="math inline">1</span>
bit；位扩展后，<span class="math inline">8</span>
个芯片同时根据MAR信号输出 <span class="math inline">8</span>
bit数据。</li>
<li><figure>
<img src="image-3.png" srcset="/img/loading/loading3.gif" lazyload alt="位扩展">
<figcaption aria-hidden="true">位扩展</figcaption>
</figure></li>
</ul></li>
<li>字位扩展：增加存储模块的大小（即增加存储模块能够存储的字的数量）
<ul>
<li>假设一组芯片有 <span class="math inline"><em>N</em></span>
个，存储模块由 <span class="math inline"><em>M</em></span>
组芯片构成，此时地址要增加 <span class="math inline">log<sub>2</sub><em>M</em></span> bit，用于选择 <span class="math inline"><em>M</em></span> 组芯片中的一组。</li>
<li><figure>
<img src="image-4.png" srcset="/img/loading/loading3.gif" lazyload alt="字扩展">
<figcaption aria-hidden="true">字扩展</figcaption>
</figure></li>
</ul></li>
<li>字节级精度的访问
<ul>
<li>存储模块一次传输能够传输 <span class="math inline"><em>N</em></span>
bit数据（一般 <span class="math inline"><em>N</em></span>
为8的倍数）,则可以实现字节级精度访问。需要在原地址信号的基础上添加 <span class="math inline">$\log_2 \frac{N}{8}$</span> 位地址。</li>
<li>以 <span class="math inline"><em>N</em> = 16</span>
为例，此时地址新添加 <span class="math inline">1</span> 位作为最低位。
<ul>
<li>若要读取 <span class="math inline">16</span>
bit数据，且地址为偶数，则新添加的最低位置 <span class="math inline">0</span>，可一次读取完成。</li>
<li>若地址为奇数则新添加的最低位置 <span class="math inline">1</span>，需要两次读取：CPU先读取奇数地址上的 <span class="math inline">16</span> bit，只保留A9-A16芯片上的 <span class="math inline">8</span> bit作为低 <span class="math inline">8</span> bit；CPU再将地址 <span class="math inline">+1</span> 读取 <span class="math inline">16</span>
bit，只保留A1-A9芯片上的 <span class="math inline">8</span> bit作为高
<span class="math inline">8</span> bit。</li>
</ul></li>
</ul></li>
<li>数据对齐
<ul>
<li>例如，<span class="math inline">2</span>
Byte的short型变量的地址通常为偶数，<span class="math inline">4</span>
Byte的int型变量的地址通常为 <span class="math inline">4</span>
的倍数。</li>
<li>否则，读取时CPU要进行两次读取。</li>
</ul></li>
</ol>
<h2 id="纠错码">纠错码</h2>
<p>数据 <span class="math inline"><em>M</em></span> bit，校验码/纠错码
<span class="math inline"><em>K</em></span> bit，实际存储 <span class="math inline">(<em>M</em> + <em>K</em>)</span> bit。</p>
<figure>
<img src="image-5.png" srcset="/img/loading/loading3.gif" lazyload alt="纠错码">
<figcaption aria-hidden="true">纠错码</figcaption>
</figure>
<h3 id="以汉明码和文氏图为例">以汉明码和文氏图为例</h3>
<figure>
<img src="image-6.png" srcset="/img/loading/loading3.gif" lazyload alt="汉明码与文氏图!">
<figcaption aria-hidden="true">汉明码与文氏图!</figcaption>
</figure>
<ul>
<li>初始数据为 <span class="math inline">1110</span>，放在 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>B</em></span>、<span class="math inline"><em>C</em></span> 三个圈相交位置；</li>
<li>在 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>B</em></span>、<span class="math inline"><em>C</em></span>
三个圈中生成纠错码，满足每个圈中四个数字异或结果为 <span class="math inline">0</span>；</li>
<li>若传输过程中出现错误，可进行定位；</li>
<li>发现 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>C</em></span> 两个圈中异或结果不为 <span class="math inline">0</span>，<span class="math inline"><em>B</em></span> 异或结果为 <span class="math inline">0</span>，则错误出现在与 <span class="math inline"><em>A</em></span>、<span class="math inline"><em>C</em></span> 相交但不与 <span class="math inline"><em>B</em></span> 相交的位置。</li>
</ul>
<h3 id="纠错码设计">纠错码设计：</h3>
<p>数据 <span class="math inline"><em>M</em></span> bit，校验码/纠错码
<span class="math inline"><em>K</em></span> bit，实际存储 <span class="math inline">(<em>M</em> + <em>K</em>)</span>
bit，则应满足：<span class="math inline">2<sup><em>K</em></sup> − 1 ≥ <em>M</em> + <em>K</em></span></p>
<ul>
<li>纠错码全 <span class="math inline">0</span> 表示 <span class="math inline">(<em>M</em> + <em>K</em>)</span> bit
数据都正常，因此 <span class="math inline"><em>K</em></span> bit
纠错码能表示 <span class="math inline">2<sup><em>K</em></sup> − 1</span>
个数，要求 <span class="math inline"><em>K</em></span> bit
纠错码必须能表示 <span class="math inline">(<em>M</em> + <em>K</em>)</span> bit
数据的位置，因此有上述关系式。</li>
</ul>
<figure>
<img src="image-7.png" srcset="/img/loading/loading3.gif" lazyload alt="例子">
<figcaption aria-hidden="true">例子</figcaption>
</figure>
<p>具体纠错过程为：</p>
<ul>
<li>根据右图公式计算纠错码 <span class="math inline"><em>C</em>8<sup>′</sup>&nbsp;<em>C</em>4′&nbsp;<em>C</em>2′&nbsp;<em>C</em>1′</span>，与存储的原纠错码
<span class="math inline"><em>C</em>8&nbsp;<em>C</em>4&nbsp;<em>C</em>2&nbsp;<em>C</em>1</span>
一一异或，得到结果 <span class="math inline"><em>C</em>8′′<em>C</em>4′′<em>C</em>2′′<em>C</em>1′′</span></li>
<li>若只有一项异或结果为1，即只有一个纠错码与原纠错码不同，则错误出现在该纠错码上，翻转该纠错码即可。例如，若只有
<span class="math inline"><em>C</em>8′′ = 1</span>，即 <span class="math inline"><em>C</em>8′′&nbsp;<em>C</em>4′′&nbsp;<em>C</em>2′′&nbsp;<em>C</em>1′′ = 1000</span>，表示位置8出错，即
<span class="math inline"><em>C</em>8</span> 自身出错。</li>
<li>若有两项异或结果为1，即有两个纠错码与原纠错码不同，则错误出现在纠错码所表示的位置对应的数据上。例如，若
<span class="math inline"><em>C</em>1′′ = <em>C</em>4′′ = 1</span>，即
<span class="math inline"><em>C</em>8′′&nbsp;<em>C</em>4′′&nbsp;<em>C</em>2′′&nbsp;<em>C</em>1′′ = 0101</span>，则错误出现在位置
<span class="math inline">0101</span> 对应数据，即 <span class="math inline"><em>D</em>2</span>
上；从右图的公式里也可以看到，只有 <span class="math inline"><em>D</em>2</span> 能同时影响 <span class="math inline"><em>C</em>1<em>C</em>4</span>。</li>
</ul>
<h1 id="ch6-外部存储器">Ch6 外部存储器</h1>
<h2 id="磁盘数据组织">磁盘数据组织</h2>
<ol type="1">
<li>磁道：一组同心圆环。相邻磁道间由磁道间隔隔开（防止相互干扰）。</li>
<li>扇区：最小读写单位。一个磁道通常被划分成多个扇区，相邻扇区由扇区间隔隔开。</li>
</ol>
<figure>
<img src="image-33.png" srcset="/img/loading/loading3.gif" lazyload alt="磁道与扇区">
<figcaption aria-hidden="true">磁道与扇区</figcaption>
</figure>
<h2 id="磁盘读写机制">磁盘读写机制</h2>
<p>由于角速度相同时，线速度外大内小，必须补偿，使得磁头读取所有的位的速度相同。</p>
<figure>
<img src="image-8.png" srcset="/img/loading/loading3.gif" lazyload alt="磁盘读写机制!">
<figcaption aria-hidden="true">磁盘读写机制!</figcaption>
</figure>
<ol type="1">
<li>恒定角速度：增大外层扇区间隔。
<ul>
<li>优点：构造简单，磁头移到固定位置等待扇区来即可。</li>
<li>缺点：浪费了外层磁道容量。</li>
</ul></li>
<li>多区段记录：每个区段包含多个磁道，区段内每个磁道位数固定，半径大的区段内的磁道比半径小的区段内的磁道容纳更多的位。同一区段的读取角速度相同，不同区段读取角速度不同。
<ul>
<li>优点：充分利用磁道容量。</li>
<li>缺点：需要更复杂的电路控制角速度。</li>
</ul></li>
</ol>
<h2 id="寻找扇区">寻找扇区</h2>
<p>附加数据标记磁道和扇区，这些数据只对磁盘驱动器可见。</p>
<h2 id="磁头">磁头</h2>
<ul>
<li>固定磁头：一个磁道一个磁头，安装在一个固定支架上</li>
<li>可移动磁头：每面一个，可伸缩支架</li>
</ul>
<h2 id="多盘片">多盘片</h2>
<figure>
<img src="image-9.png" srcset="/img/loading/loading3.gif" lazyload alt="多盘片">
<figcaption aria-hidden="true">多盘片</figcaption>
</figure>
<h2 id="ssd">SSD</h2>
<ul>
<li>优点：高速启动，低噪音，机械可靠性更高</li>
<li>缺点：成本较高，容量较低，写入寿命较短</li>
</ul>
<h2 id="磁盘性能参数">磁盘性能参数：</h2>
<h3 id="传送时间">传送时间：</h3>
<p><span class="math display">$$T=\frac{b}{rN}$$</span></p>
<p>其中：</p>
<ul>
<li><span class="math inline"><em>b</em></span> = 传送的字节数；</li>
<li><span class="math inline"><em>r</em></span> =
磁盘旋转速率（转/秒）；</li>
<li><span class="math inline"><em>N</em></span> = 每磁道字节数。</li>
</ul>
<h3 id="平均存取时间">平均存取时间：</h3>
<p><span class="math display">$$T_a=T_s+\frac{1}{2r}+\frac{b}{rN}$$</span></p>
<p>其中：</p>
<ul>
<li><span class="math inline"><em>T</em><sub><em>s</em></sub></span> =
平均寻道时间，指磁盘移动支架使磁头对准磁道所需时间；</li>
<li><span class="math inline">$\frac{1}{2r}$</span> =
平均旋转延迟，是磁道旋转半圈的时间。
<ul>
<li>旋转延迟，指等待相关扇区旋转到磁头可读写位置的时间。</li>
</ul></li>
<li><span class="math inline">$\frac{b}{rN}$</span> =
传送时间，指从磁道上读取或写入 <span class="math inline"><em>b</em></span> 字节所需的时间。</li>
</ul>
<h2 id="磁盘调度算法">磁盘调度算法</h2>
<ul>
<li>先来先服务算法（FCFS）：
<ul>
<li>按照请求到达的顺序处理磁盘请求。</li>
<li>优点：简单，公平。</li>
<li>缺点：可能导致长时间等待，尤其是当请求分布不均时。</li>
</ul></li>
<li>最短寻道时间优先算法（SSTF）：
<ul>
<li>选择距离当前磁头位置最近的请求进行处理。</li>
<li>优点：减少平均寻道时间。</li>
<li>缺点：可能导致饥饿现象，即某些请求长时间得不到处理。</li>
</ul></li>
<li>扫描算法（SCAN）：
<ul>
<li>磁头在磁盘上来回扫描，处理沿途的请求。</li>
<li>优点：减少平均寻道时间，避免饥饿现象。</li>
<li>缺点：可能导致某些请求等待较长时间。</li>
</ul></li>
<li>循环扫描算法（C-SCAN）：
<ul>
<li>磁头在磁盘上来回扫描，但当到达一端时，磁头直接跳到另一端继续扫描。</li>
<li>优点：提供更均匀的服务，避免了长时间等待。</li>
<li>缺点：可能导致某些请求等待较长时间。</li>
</ul></li>
</ul>
<h2 id="磁盘冗余阵列raid">磁盘冗余阵列（RAID）</h2>
<p>使用多个磁盘增加冗余提高可靠性，本质是一组物理磁盘驱动器，但被操作系统看作一整个逻辑驱动器</p>
<ul>
<li>在阵列上条带分布</li>
<li>冗余磁盘用于存储校验信息</li>
</ul>
<table style="width:100%;">

<thead>
<tr>
<th>RAID级别</th>
<th>描述</th>
<th>数据可用性</th>
<th>大型I/O数据传输能力</th>
<th>小型I/O请求率</th>
<th>需要的磁盘数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>无冗余</td>
<td>无</td>
<td>非常高</td>
<td>低于单个磁盘</td>
<td>N</td>
</tr>
<tr>
<td>1</td>
<td>镜像</td>
<td>非常高</td>
<td>读操作可达单个磁盘的两倍；写操作与单个磁盘相同</td>
<td>读操作比单个磁盘高；写操作与单个磁盘相同</td>
<td>2N</td>
</tr>
<tr>
<td>2</td>
<td>通过海明码冗余</td>
<td>所有列出的选择中最高</td>
<td>大约是单个磁盘的两倍</td>
<td>远高于单个磁盘；可与RAID 3、4、5相比较</td>
<td>N+m（m与logN成正比）</td>
</tr>
<tr>
<td>3</td>
<td>位交叉奇偶校验</td>
<td>所有列出的选择中最高</td>
<td>远高于单个磁盘；可与RAID 2、4、5相比较</td>
<td>大约是单个磁盘的两倍</td>
<td>N+1</td>
</tr>
<tr>
<td>4</td>
<td>块交叉奇偶校验</td>
<td>无</td>
<td>远高于单个磁盘；可与RAID 2、3、5相比较</td>
<td>读操作与RAID 0相同；写操作明显低于单个磁盘</td>
<td>N+1</td>
</tr>
<tr>
<td>5</td>
<td>块交叉分布奇偶校验</td>
<td>高</td>
<td>远高于单个磁盘；可与RAID 2、3、4相比较</td>
<td>读操作与RAID 0相同；写操作一般低于单个磁盘</td>
<td>N+1</td>
</tr>
<tr>
<td>6</td>
<td>块交叉双分布奇偶校验</td>
<td>所有列出的选择中最高</td>
<td>读操作与RAID 0相同；写操作低于RAID 5</td>
<td>读操作与RAID 0相同；写操作明显低于RAID 5</td>
<td>N+2</td>
</tr>
</tbody>
</table>
<h1 id="ch7-输入输出">Ch7 输入输出</h1>
<h2 id="外部设备">外部设备</h2>
<ul>
<li>外部设备：计算机系统外部的设备，通常通过IO模块与计算机系统连接。</li>
<li>人可读的
<ul>
<li>显示屏、打印机、键盘</li>
</ul></li>
<li>机器可读的
<ul>
<li>磁盘（功能上是存储器，但结构上被I/O模块控制）、传感器</li>
</ul></li>
<li>通信设备
<ul>
<li>网卡，调制解调器</li>
</ul></li>
</ul>
<figure>
<img src="image-35.png" srcset="/img/loading/loading3.gif" lazyload alt="外部设备">
<figcaption aria-hidden="true">外部设备</figcaption>
</figure>
<h2 id="io模块">IO模块</h2>
<ul>
<li>为什么需要IO模块
<ul>
<li>各种外设操作逻辑、数据格式和字长都不一样，且运行速度比主存和CPU慢很多</li>
</ul></li>
<li>主要功能
<ul>
<li>通过系统总线或中央交换机与CPU和内存连接；</li>
<li>通过定制数据线连接一至多个外设；</li>
<li>具体包括：控制和定时，与CPU、内存和外设通信，数据缓冲，检错</li>
</ul></li>
</ul>
<figure>
<img src="image-34.png" srcset="/img/loading/loading3.gif" lazyload alt="IO模块">
<figcaption aria-hidden="true">IO模块</figcaption>
</figure>
<h2 id="读io步骤">读IO步骤</h2>
<ul>
<li>CPU查询IO模块状态</li>
<li>IO返回设备状态</li>
<li>若设备就绪，CPU请求数据传输</li>
<li>IO从外设处获取数据</li>
<li>IO将数据放到数据总线上传给CPU</li>
</ul>
<h2 id="io设备寻址">IO设备寻址</h2>
<ol type="1">
<li>内存映射寻址：
<ul>
<li>内存位置和IO设备共享同一个地址空间</li>
<li>CPU把IO模块的状态和数据寄存器看作内存位置</li>
<li>访问内存和操作IO所需机器指令相同</li>
</ul></li>
<li>独立寻址：
<ul>
<li>CPU将内存和IO模块看作两个独立的地址空间</li>
<li>需要IO或内存选择线控制</li>
<li>需要特殊的IO命令操作IO</li>
</ul></li>
</ol>
<h2 id="io技术">IO技术</h2>
<ol type="1">
<li>可编程式IO：无中断，数据通过CPU传输，即IO-CPU-内存
<ul>
<li>在IO模块操作未完成，CPU一直保持定期检查IO状态的周期，浪费CPU时间。</li>
</ul>
<figure>
<img src="image-36.png" srcset="/img/loading/loading3.gif" lazyload alt="编程式IO">
<figcaption aria-hidden="true">编程式IO</figcaption>
</figure></li>
<li>中断驱动式IO：有中断，数据通过CPU传输，即IO-CPU-内存
<ul>
<li>CPU向IO模块发出命令后执行其他程序。当IO操作完成时，即IO模块就绪时，IO模块会向CPU发送中断请求，CPU响应中断请求并开始传输数据。</li>
<li>无需CPU一直周期性检查，克服了CPU等待的问题。</li>
</ul>
<figure>
<img src="image-37.png" srcset="/img/loading/loading3.gif" lazyload alt="中断驱动式IO">
<figcaption aria-hidden="true">中断驱动式IO</figcaption>
</figure></li>
<li>存储器直接存储（DMA）：有中断，数据通过DMA传输，即IO-DMA-CPU
<ul>
<li>DMA操作：CPU通知DMA相关命令，之后CPU执行其他程序；DMA负责传输数据；DMA传输完成后，向CPU发出中断请求。</li>
<li>周期窃取：DMA必须在CPU不使用总线时，或迫使处理器挂起，才能够使用总线传输数据。一般地，CPU在访问总线前被挂起，DMA接管一个总线周期传输一个字，然后CPU继续访问总线。稍微降低了CPU速度，不是中断，CPU不用转换现场。</li>
</ul></li>
</ol>
<h2 id="中断处理">中断处理</h2>
<ul>
<li>中断认可信号是CPU告诉发出中断的IO：我已经收到了你的中断请求信号并开始处理，你可以停止发送中断请求信号了。</li>
<li>PSW：程序状态字，一个寄存器，存储CPU状态。</li>
<li>软件部分：即中断服务程序（ISR）。</li>
</ul>
<h2 id="中断请求的定位和优先级">中断请求的定位和优先级</h2>
<ol type="1">
<li>多中断信号线法：直接在CPU与每个IO模块之间提供多中断信号线，一般不用，硬件太复杂。</li>
<li>软件轮询法：CPU检测到中断后，执行中断服务程序，中断服务程序挨个轮询每个IO模块，找到所有发出中断的。
<ul>
<li>优先级：由中断服务程序决定先处理哪个。</li>
<li>优点：硬件简单，优先级安排、修改简单，灵活。</li>
<li>缺点：速度慢。</li>
</ul></li>
<li>菊花链法（硬件轮询、向量）：所有IO共享一条中断请求线，但是中断响应线以菊花链形式连接各个IO模块。
<ul>
<li>CPU感知到中断后，发出中断响应信号，沿菊花链传播。</li>
<li>当中断响应信号传播到某个IO模块时：
<ul>
<li>若该IO发出了中断，则会在数据线上放向量（一个字，IO模块的地址或唯一标识符，CPU认为其指向适合的设备服务例程）。CPU会根据向量来定位IO模块并处理中断。该IO模块的中断处理完后，才会将中断响应信号传给下个IO模块；</li>
<li>若该IO没有发出中断，则直接将中断响应信号传给下个IO模块；</li>
</ul></li>
<li>优先级：菊花链上游的IO模块中断优先级更高。是固定的，不灵活。</li>
<li>优点：速度快。</li>
<li>缺点：优先级固定，不灵活。</li>
</ul></li>
<li>总线仲裁（向量）：由中断控制器控制哪个IO模块能够获得总线控制权。IO模块只有获得总线控制权后才能发送中断，一次只有一个IO模块能发送中断，中断控制器检测到CPU的中断响应信号时，将发出中断的IO模块对应向量放到数据线上。</li>
</ol>
<h1 id="ch9-计算机算术">Ch9 计算机算术</h1>
<h2 id="整数2的补码法">整数：2的补码法</h2>
<ul>
<li><span class="math inline"><em>N</em></span>
bit整数，最高位为符号位，0表示正数，1表示负数。</li>
<li>正数：最高位为0，剩下 <span class="math inline"><em>N</em> − 1</span> 位为二进制。</li>
<li>负数：先写出对应正数，然后对 <span class="math inline"><em>N</em></span> 位全部按位取反，再将其视作无符号数
<span class="math inline">+1</span>。</li>
<li>表示范围：<span class="math inline"><em>N</em></span>
bit能表示：<span class="math inline">[−2<sup><em>N</em> − 1</sup>, 2<sup><em>N</em> − 1</sup> − 1]</span>范围内的整数。</li>
<li>符号填充：符号位移到新最高位，空余的，对正数填全0，对负数填全1。</li>
</ul>
<h2 id="整数的加减法">整数的加减法</h2>
<ul>
<li>用加法实现减法</li>
<li>溢出规则：两个数相加，若他们同为正或同为负，当且仅当结果符号相反时发生上溢。</li>
</ul>
<h2 id="无符号乘法">无符号乘法</h2>
<figure>
<img src="image-10.png" srcset="/img/loading/loading3.gif" lazyload alt="无符号乘法">
<figcaption aria-hidden="true">无符号乘法</figcaption>
</figure>
<ul>
<li><span class="math inline"><em>M</em> × <em>Q</em> = <em>A</em><em>Q</em></span>，<span class="math inline"><em>M</em></span> 为被乘数，<span class="math inline"><em>Q</em></span> 为乘数，<span class="math inline"><em>A</em><em>Q</em></span> 为结果，由寄存器 <span class="math inline"><em>A</em></span> 和寄存器 <span class="math inline"><em>Q</em></span> 拼接而成。</li>
<li>每个循环，若 <span class="math inline"><em>Q</em></span>
最低位为1，则将 <span class="math inline"><em>M</em></span> 加在 <span class="math inline"><em>A</em></span> 上；若为0，则不相加。</li>
<li>然后将 <span class="math inline"><em>A</em><em>Q</em></span>
整体右移一位，<span class="math inline"><em>Q</em></span>
最低位舍弃，<span class="math inline"><em>A</em></span>
最高位为相加的溢出位。</li>
<li><span class="math inline"><em>Q</em></span>
有几位，就执行几个循环。</li>
</ul>
<h2 id="有符号乘法booth算法">有符号乘法：Booth算法</h2>
<figure>
<img src="image-11.png" srcset="/img/loading/loading3.gif" lazyload alt="Booth">
<figcaption aria-hidden="true">Booth</figcaption>
</figure>
<ul>
<li><span class="math inline"><em>Q</em><sub>0</sub><em>Q</em><sub>−1</sub> = 10</span>，则
<span class="math inline"><em>A</em> = <em>A</em> − <em>M</em></span>（记忆：最高位为1，负数，减），然后shift</li>
<li><span class="math inline"><em>Q</em><sub>0</sub><em>Q</em><sub>−1</sub> = 01</span>，则
<span class="math inline"><em>A</em> = <em>A</em> + <em>M</em></span>（记忆：最高位为0，正数，加），溢出位舍去，然后shift</li>
<li><span class="math inline"><em>Q</em><sub>0</sub><em>Q</em><sub>−1</sub> = 00</span>
或 <span class="math inline">11</span>，则直接shift</li>
<li>Shift将<span class="math inline"><em>Q</em><sub>−1</sub></span>
舍去，<span class="math inline"><em>Q</em><sub>0</sub></span> 位移到
<span class="math inline"><em>Q</em><sub>−1</sub></span>，新最高位和原最高位相同。</li>
<li><span class="math inline"><em>Q</em></span>
有几位，循环几个周期。最终结果为 <span class="math inline"><em>A</em><em>Q</em></span> 相拼接，不算 <span class="math inline"><em>Q</em><sub>−1</sub></span>！</li>
</ul>
<figure>
<img src="image-12.png" srcset="/img/loading/loading3.gif" lazyload alt="例子">
<figcaption aria-hidden="true">例子</figcaption>
</figure>
<h2 id="浮点数表示">浮点数表示</h2>
<p>以32bit为例：</p>
<ul>
<li>1bit符号位 <span class="math inline"><em>m</em></span> + 8bit指数
<span class="math inline"><em>E</em></span>（移码表示）+ 23bit有效数
<span class="math inline"><em>B</em></span>
<ul>
<li>移码表示：<span class="math inline"><em>N</em></span>
bit二进制，按照无符号数理解，得到在<span class="math inline">0&nbsp;2<sup><em>N</em></sup> − 1</span>之间的整数，再减去一个固定的偏阶（为<span class="math inline">2<sup><em>N</em> − 1</sup> − 1</span>），得到真正的指数，范围为<span class="math inline">−2<sup><em>N</em> − 1</sup> + 1&nbsp;2<sup><em>N</em> − 1</sup></span>
<ul>
<li>8bit 范围为-127~+128</li>
</ul></li>
</ul></li>
<li>规格化数：有效数的最高位一定为1，且不实际存储到内存中。因此，23bit有效数
<span class="math inline"><em>B</em></span>
实际表示24bit，表示一个二进制小数：1.B</li>
<li>综上，浮点数被表示为：<span class="math inline">(−1)<sup><em>m</em></sup> × 1.<em>B</em> × 2<sup><em>E</em> − 2<sup><em>N</em> − 1</sup> + 1</sup></span></li>
<li>范围：
<ul>
<li>以32bit为例：正数在<span class="math inline">2<sup>−127</sup>&nbsp;(2 − 2<sup>−23</sup>) × 2<sup>128</sup></span>，负数在<span class="math inline">−(2 − 2<sup>−23</sup>) × 2<sup>128</sup>&nbsp; − 2<sup>−127</sup></span></li>
<li>因此有正上溢、正下溢、负上溢、负下溢</li>
</ul></li>
</ul>
<p><img src="image-13.png" srcset="/img/loading/loading3.gif" lazyload></p>
<p><img src="image-14.png" srcset="/img/loading/loading3.gif" lazyload></p>
<figure>
<img src="image-15.png" srcset="/img/loading/loading3.gif" lazyload alt="32bit float">
<figcaption aria-hidden="true">32bit float</figcaption>
</figure>
<h3 id="ieee754的一些特殊表示">IEEE754的一些特殊表示:</h3>
<ul>
<li>当<span class="math inline"><em>E</em> = 0</span>且<span class="math inline"><em>M</em> = 0</span>时,表示0。</li>
<li>当<span class="math inline"><em>E</em> = 0</span>且<span class="math inline"><em>M</em> ≠ 0</span>时,表示非规格化数(下溢数)。</li>
<li>当<span class="math inline"><em>E</em> = 255</span>且<span class="math inline"><em>M</em> = 0</span>时,表示∞。</li>
<li>当<span class="math inline"><em>E</em> = 255</span>且<span class="math inline"><em>M</em> ≠ 0</span>时, 表示NAN。</li>
</ul>
<h2 id="浮点数加减法">浮点数加减法：</h2>
<ol type="1">
<li>零检查
<ul>
<li>若是减法运算，则改变减数符号并改为加法运算。若某个操作数为0，则另一个操作数直接作为结果。否则，将存储的23bit有效数扩充成24bit实际有效数。</li>
</ul></li>
<li>对齐
<ul>
<li>若两数指数不相等，则增加较小的指数，并右移其有效位数。若此过程中出现有效位数为0，则另一个数直接作为结果。</li>
</ul></li>
<li>有效数相加
<ul>
<li>即1.B相加。若产生上溢，则右移有效位数并增加指数。若此操作产生了指数上溢，报错。</li>
</ul></li>
<li>规格化
<ul>
<li>若加法结果最高位不为1，则左移有效位数并减小指数。若此操作产生了指数下溢，报错。</li>
</ul></li>
</ol>
<p>注：有效数右移时可以在右边增加保护位以确保精度。 <img src="image-38.png" srcset="/img/loading/loading3.gif" lazyload alt="浮点数加减法"></p>
<h2 id="浮点数乘法">浮点数乘法</h2>
<ol type="1">
<li>预处理
<ul>
<li>零检查：若有一个操作数为 <span class="math inline">0</span>，则另一个操作数直接作为结果。</li>
<li>符号位计算：<span class="math inline"><em>m</em> = <em>m</em><sub>1</sub> ⊕ <em>m</em><sub>2</sub></span>，即两个操作数的符号位进行异或运算。</li>
<li>规格化</li>
</ul></li>
<li>指数相加
<ul>
<li><span class="math inline"><em>E</em> = <em>E</em><sub>1</sub> + <em>E</em><sub>2</sub> − 127</span>，即两个操作数的指数相加后减去偏阶。</li>
</ul></li>
<li>有效数相乘
<ul>
<li><span class="math inline"><em>B</em> = <em>B</em><sub>1</sub> × <em>B</em><sub>2</sub></span>，即两个操作数的有效数相乘。</li>
</ul></li>
<li>规格化
<ul>
<li>若乘法结果的有效数最高位不为 <span class="math inline">1</span>，则左移有效位数并减小指数。若此操作产生了指数下溢，报错。</li>
<li>若乘法结果的有效数最高位为 <span class="math inline">1</span>，则直接将结果存储为 <span class="math inline">1.<em>B</em></span> 的形式。</li>
</ul></li>
</ol>
<figure>
<img src="image-39.png" srcset="/img/loading/loading3.gif" lazyload alt="浮点数乘法">
<figcaption aria-hidden="true">浮点数乘法</figcaption>
</figure>
<h2 id="浮点数除法">浮点数除法</h2>
<ol type="1">
<li>零检查</li>
<li>指数相减
<ul>
<li><span class="math inline"><em>E</em> = <em>E</em><sub>1</sub> − <em>E</em><sub>2</sub> + 127</span>，即被除数的指数减去除数的指数后加上偏阶。</li>
</ul></li>
<li>判断溢出</li>
<li>有效数相除</li>
<li>规格化</li>
</ol>
<h1 id="ch10-指令集特征和功能">Ch10 指令集：特征和功能</h1>
<h2 id="机器指令的要素">机器指令的要素</h2>
<ul>
<li>操作码</li>
<li>源操作数引用</li>
<li>结果操作数引用</li>
<li>下一条指令引用</li>
</ul>
<h2 id="操作数个数">操作数个数</h2>
<ul>
<li>三地址：操作数1，操作数2，结果，<span class="math inline"><em>c</em> = <em>a</em> + <em>b</em></span></li>
<li>双地址：其中一个地址既是操作数也存储结果，<span class="math inline"><em>a</em> = <em>a</em> + <em>b</em></span></li>
<li>单地址：寄存器操作</li>
<li>零地址：pop，push等</li>
<li>更多的地址：更复杂强大的指令，更复杂的CPU，更少的程序指令数</li>
<li>更少的地址：更简单的指令和CPU，更多的程序指令数</li>
</ul>
<h2 id="移位操作">移位操作</h2>
<ol type="1">
<li>逻辑移位
<ul>
<li>逻辑右移1位相当于：无符号整数除以2</li>
<li>逻辑左移1位相当于：无符号整数乘以2</li>
<li><figure>
<img src="image-16.png" srcset="/img/loading/loading3.gif" lazyload alt="逻辑移位">
<figcaption aria-hidden="true">逻辑移位</figcaption>
</figure></li>
</ul></li>
<li>算数移位
<ul>
<li>算术右移1位相当于：带符号整数除以2</li>
<li>算术左移1位相当于：带符号整数乘以2</li>
<li><figure>
<img src="image-17.png" srcset="/img/loading/loading3.gif" lazyload alt="逻辑移位">
<figcaption aria-hidden="true">逻辑移位</figcaption>
</figure></li>
</ul></li>
<li>循环移位：
<ul>
<li>保留所有被处理的位，检查某一位的状态，高低位交换</li>
<li>循环右移 &amp; 循环左移</li>
<li><figure>
<img src="image-18.png" srcset="/img/loading/loading3.gif" lazyload alt="循环移位">
<figcaption aria-hidden="true">循环移位</figcaption>
</figure></li>
</ul></li>
</ol>
<h2 id="数端">数端</h2>
<ul>
<li>大数端(big-endian ordering)：最高有效字节存放在最低的地址上</li>
<li>小数端(little-endian ordering)：最高有效字节存放在最高的地址上</li>
</ul>
<h2 id="内存对齐">内存对齐</h2>
<ul>
<li>内存对齐是指数据在内存中存放时，地址必须是某个特定值的倍数，以提高访问效率。</li>
<li>例如，32位数据要求在4字节对齐的地址上存放，64位数据要求在8字节对齐的地址上存放。</li>
</ul>
<h1 id="ch11-指令集寻址方式和指令模式">Ch11
指令集：寻址方式和指令模式</h1>
<h3 id="符号说明">符号说明：</h3>
<ul>
<li><span class="math inline"><em>A</em></span>：指令中出现的地址/数据的内容</li>
<li><span class="math inline"><em>R</em></span>：指令中出现的寄存器存储的地址/数据的内容</li>
<li><span class="math inline"><em>E</em><em>A</em></span>：被访问位置的实际有效地址</li>
<li><span class="math inline">(<em>X</em>)</span>：位置<span class="math inline"><em>X</em></span>的内容</li>
</ul>
<h2 id="立即寻址">立即寻址</h2>
<ul>
<li>操作数 = <span class="math inline"><em>A</em></span></li>
<li>优点：不要求存储访问，速度快</li>
<li>缺点：操作数范围受限</li>
</ul>
<h2 id="直接寻址">直接寻址</h2>
<ul>
<li><span class="math inline"><em>E</em><em>A</em> = <em>A</em></span>，即实际访问位置的地址写在指令中。</li>
<li>优点：只需要一次内存引用。</li>
<li>缺点：地址范围受限。</li>
<li><figure>
<img src="image-19.png" srcset="/img/loading/loading3.gif" lazyload alt="直接寻址">
<figcaption aria-hidden="true">直接寻址</figcaption>
</figure></li>
</ul>
<h2 id="间接寻址">间接寻址</h2>
<ul>
<li><span class="math inline"><em>E</em><em>A</em> = (<em>A</em>)</span>，即指令中存储的地址指向一个内存位置，该位置存储着实际访问位置真正的地址。</li>
<li>优点：地址范围更大。</li>
<li>缺点：需要两次内存引用（第一次获取真正地址，第二次获取实际数据）。</li>
<li><figure>
<img src="image-20.png" srcset="/img/loading/loading3.gif" lazyload alt="间接寻址">
<figcaption aria-hidden="true">间接寻址</figcaption>
</figure></li>
</ul>
<h2 id="寄存器寻址类似直接寻址">寄存器寻址（类似直接寻址）</h2>
<ul>
<li><span class="math inline"><em>E</em><em>A</em> = <em>R</em></span>，即指令中存储的地址指向一个寄存器，实际访问内容存储在该寄存器中。</li>
<li>优点：无需内存引用；指令中寄存器地址通常较短。</li>
<li>缺点：寄存器地址空间有限。</li>
</ul>
<h2 id="寄存器间接寻址类似间接寻址">寄存器间接寻址（类似间接寻址）</h2>
<ul>
<li><span class="math inline"><em>E</em><em>A</em> = (<em>R</em>)</span>，即指令中存储的地址指向一个寄存器，该寄存器存储着实际访问位置的真正地址。</li>
<li>优点：地址范围更大；相比间接寻址只需一次内存访问；指令内地址更短。</li>
<li><figure>
<img src="image-21.png" srcset="/img/loading/loading3.gif" lazyload alt="寄存器间接寻址">
<figcaption aria-hidden="true">寄存器间接寻址</figcaption>
</figure></li>
</ul>
<h2 id="偏移寻址寄存器间接寻址和直接寻址的结合">偏移寻址（寄存器间接寻址和直接寻址的结合）</h2>
<ul>
<li><span class="math inline"><em>E</em><em>A</em> = (<em>R</em>) + <em>A</em></span>，实际地址由寄存器内容与指令内地址相加得到。
<ul>
<li>相对寻址：
<ul>
<li><span class="math inline"><em>R</em> = <em>P</em><em>C</em></span>，<span class="math inline"><em>A</em></span> 为补码，有效地址 = 指令地址 +
偏移量（可正可负）。</li>
</ul></li>
<li>基址寄存器寻址：
<ul>
<li><span class="math inline">(<em>R</em>)</span> 为基址，<span class="math inline"><em>A</em></span>
为偏移量（相对寻址是其特例）。</li>
</ul></li>
<li>变址寻址：
<ul>
<li><span class="math inline"><em>A</em></span> 为基址，<span class="math inline">(<em>R</em>)</span> 为偏移量，常用于迭代场景。</li>
</ul></li>
</ul></li>
<li><figure>
<img src="image-22.png" srcset="/img/loading/loading3.gif" lazyload alt="偏移寻址">
<figcaption aria-hidden="true">偏移寻址</figcaption>
</figure></li>
</ul>
<h2 id="堆栈寻址">堆栈寻址</h2>
<ul>
<li>操作数在栈顶，通过指令隐式对栈顶进行操作</li>
<li>本质是通过存储在寄存器中的栈指针进行寄存器间接寻址，对栈顶元素进行操作。</li>
</ul>
<h1 id="ch12-cpu结构和功能">Ch12 CPU结构和功能</h1>
<h2 id="cpu内部结构">CPU内部结构</h2>
<ul>
<li>包含ALU（算术逻辑单元）、CU（控制单元）、寄存器组、状态标志等。</li>
<li>内部处理器总线用于在ALU和寄存器间传递数据，因ALU仅能操作CPU内部存储数据。</li>
</ul>
<figure>
<img src="image-40.png" srcset="/img/loading/loading3.gif" lazyload alt="CPU内部结构">
<figcaption aria-hidden="true">CPU内部结构</figcaption>
</figure>
<h2 id="寄存器组织">寄存器组织</h2>
<ol type="1">
<li>用户可见寄存器：
<ul>
<li>通用寄存器：多功能用途。</li>
<li>数据寄存器：仅存储数据。</li>
<li>地址寄存器：可能通用或专用于特定寻址模式（如栈指针）。</li>
<li>设计问题：通用化灵活但指令长；专用化指令短但不灵活；寄存器数量过少需频繁访存，过多则收益不显著。</li>
</ul></li>
<li>控制和状态寄存器：
<ul>
<li>程序计数器（PC）：保存下条指令地址。</li>
<li>指令寄存器（IR）：存储最近读取的指令。</li>
<li>内存地址寄存器（MAR）：保存地址，与地址总线直接相连。</li>
<li>内存缓冲寄存器（MBR）：保存数据，与数据总线直接相连。</li>
<li>程序状态字（PSW）：包含条件码等状态信息。</li>
</ul></li>
</ol>
<h2 id="指令周期的数据流">指令周期的数据流</h2>
<ol type="1">
<li>取指周期
<ul>
<li>下条指令地址：PC → MAR → 地址总线 → 主存。</li>
<li>指令：主存 → 数据总线 → MBR → IR，同时PC++（除非指令修改PC）。</li>
<li><figure>
<img src="image-41.png" srcset="/img/loading/loading3.gif" lazyload alt="取值周期">
<figcaption aria-hidden="true">取值周期</figcaption>
</figure></li>
</ul></li>
<li>间接周期（如有）
<ul>
<li>MBR的低N位 → MAR → 地址总线。</li>
<li><figure>
<img src="image-42.png" srcset="/img/loading/loading3.gif" lazyload alt="间接寻址">
<figcaption aria-hidden="true">间接寻址</figcaption>
</figure></li>
</ul></li>
<li>执行周期
<ul>
<li>复杂多样，取决于具体指令。</li>
</ul></li>
<li>中断周期
<ul>
<li>PC复制到MBR，特定地址由控制单元给MAR，MBR数据存至主存。</li>
<li>PC装载中断服务程序地址</li>
<li><figure>
<img src="image-43.png" srcset="/img/loading/loading3.gif" lazyload alt="中断周期">
<figcaption aria-hidden="true">中断周期</figcaption>
</figure></li>
</ul></li>
</ol>
<h2 id="流水线技术">流水线技术</h2>
<ol type="1">
<li>经典六阶段流水：
<ul>
<li>取指令(FI)</li>
<li>指令译码(DI)</li>
<li>计算操作数(CO)</li>
<li>取操作数(FO)</li>
<li>执行指令(EI)</li>
<li>写操作数(WO)</li>
</ul></li>
<li>条件转移与流水线总清：
<ul>
<li>条件转移可能导致流水线停顿，需清空流水线并重新取指。</li>
<li><img src="image-44.png" srcset="/img/loading/loading3.gif" lazyload></li>
</ul></li>
<li>流水线性能增强的限制：
<ul>
<li>访存冲突（FI，FO，WO）</li>
<li>每个指令执行时间不完全相同</li>
<li>转移指令</li>
<li>中断</li>
</ul></li>
<li>流水线阶段并非越多越好：阶段越多开销越大，单指令执行时间越长，且相关性更复杂。</li>
<li>流水线性能
<ul>
<li>流水线周期时间：通过流水线把一组指令推进一个阶段所需时间 <span class="math display"><em>τ</em> = <em>τ</em><sub><em>m</em></sub> + <em>d</em></span>
其中<span class="math inline"><em>τ</em><sub><em>m</em></sub></span>
为最大阶段延迟，<span class="math inline"><em>d</em></span>
为锁存器延迟（通常可忽略）。</li>
<li>n条指令总时间：<span class="math display"><em>T</em><sub><em>k</em>, <em>n</em></sub> = [<em>k</em> + (<em>n</em> − 1)]<em>τ</em></span>（k阶段流水线，无分支）。</li>
<li>加速比：<span class="math display">$$S_k = \frac{nk\tau}{[k +
(n-1)]\tau} = \frac{nk}{k + n - 1}$$</span> 当<span class="math inline"><em>n</em> → ∞</span>时，<span class="math inline">lim <em>S</em><sub><em>k</em></sub> = <em>k</em></span>。</li>
</ul></li>
<li>流水线冲突：流水线由于条件不允许继续执行而停顿
<ul>
<li>资源冲突：
<ul>
<li>访存冲突（FI/FO/WO同时请求内存）</li>
<li>ALU冲突（多条指令同时需ALU）</li>
</ul></li>
<li>数据冲突：
<ol type="1">
<li>写后读（RAW）：前指令修改数据，后指令读取时数据未更新。</li>
<li>读后写（WAR）：后指令写数据时，前指令尚未读取该数据。</li>
<li>写后写（WAW）：后指令写数据覆盖前指令未完成的写操作。</li>
</ol></li>
</ul></li>
</ol>
<h2 id="条件分支处理">条件分支处理</h2>
<ul>
<li>多指令流：复制流水线初始部分，同时取两条指令，但可能引发资源争用。</li>
<li>预取分支目标：识别转移时取两个分支指令，仅做取指和译指直至某分支执行。</li>
<li>循环缓冲区：存储最近取的顺序指令，转移时检查目标是否存在，适用于循环。</li>
<li>分支预测：
<ul>
<li>静态预测：如预测从不跳转、总是跳转、按操作码预测。</li>
<li>动态预测：如1位预测（根据上次跳转预测）、2位预测（连续两次失败才反转预测）。</li>
</ul></li>
</ul>
<figure>
<img src="image-45.png" srcset="/img/loading/loading3.gif" lazyload alt="2位预测">
<figcaption aria-hidden="true">2位预测</figcaption>
</figure>
<h2 id="转移历史表">转移历史表</h2>
<ul>
<li>在预测分支并取来转移目标指令时，条件转移语句还没完成译指、计算操作数，无法得到转移目标语句的地址。</li>
<li>转移历史表：通过表格维护转移目标
<ul>
<li>分支语句的地址</li>
<li>转移目标语句的地址</li>
<li>转移历史位</li>
</ul></li>
<li>预测转移时：
<ul>
<li>从表中直接查询得出转移目标地址</li>
<li>如果该分支语句在表中不存在：等到操作数计算完成后，加入表中</li>
</ul></li>
</ul>
<h1 id="ch13-精简指令集计算机risc">Ch13 精简指令集计算机RISC</h1>
<h2 id="risc的主要特性">RISC的主要特性</h2>
<ul>
<li>大量通用寄存器，使用编译器优化寄存器用法。</li>
<li>有限、简单的指令集。</li>
<li>强调优化指令流水线。</li>
</ul>
<h2 id="现代精简指令集的特点">现代精简指令集的特点</h2>
<ul>
<li>每个机器周期一条指令。</li>
<li>寄存器-寄存器操作。</li>
<li>简单的寻址模式和指令格式。</li>
</ul>
<h2 id="cisc">CISC</h2>
<ol type="1">
<li>朝向CISC的原因：
<ul>
<li>出现了功能强大的复杂高级程序设计语言（HLL）</li>
<li>导致程序设计语言与汇编语言之间的语义间隙增大</li>
<li>出现了更复杂的机器指令、寻址方式，硬件实现的HLL语句</li>
</ul></li>
<li>CISC的目标：
<ul>
<li>提高执行效率</li>
<li>简化编译</li>
<li>用复杂的机器指令执行复杂的HLL语句</li>
</ul></li>
</ol>
<h2 id="对hll操作的研究">对HLL操作的研究</h2>
<figure>
<img src="image-23.png" srcset="/img/loading/loading3.gif" lazyload alt="HLL操作动态频度">
<figcaption aria-hidden="true">HLL操作动态频度</figcaption>
</figure>
<ul>
<li>HLL操作动态频度：过程调用在机器指令加权和存储器加权下占比很高，尤其存储器加权场景。</li>
<li>操作数：局部标量变量占多数，数组/结构次之。</li>
<li>过程调用：
<ul>
<li>非常耗时的原因：
<ul>
<li>过程传递的参量和变量数、过程嵌套深度</li>
<li>大部分过程调用的传送的参变量、使用的局部标量变量不多</li>
<li>很少出现长的一系列调用跟着一系列返回</li>
</ul></li>
</ul></li>
<li>结论：
<ul>
<li>过程调用是HLL中最耗时的操作，应该优化</li>
<li>优化方法：优化寄存器的使用（从而减少访存）；优化流水线（减少分支影响）；</li>
</ul></li>
</ul>
<h2 id="优化方法">优化方法</h2>
<h3 id="大寄存器组硬件方案">大寄存器组（硬件方案）</h3>
<ul>
<li><p>依据/适用情况：参数、局部变量少，调用深度有限</p></li>
<li><p>寄存器（几百个）分为很多个组，每个过程对应一组寄存器</p></li>
<li><p>发生过程调用时，直接切换到另一个寄存器组（将过程调用优化为寄存器访问）</p></li>
<li><p>对程序，任何时刻只有一组寄存器可见</p></li>
<li><p>解决参数和返回值传递：</p>
<p><img src="image-24.png" srcset="/img/loading/loading3.gif" lazyload></p></li>
<li><p>解决全局变量：用一组全局寄存器，所有过程可见</p></li>
<li><p>解决深度过深：将一部分寄存器存储在内存中</p></li>
<li><p>进一步优化：环形寄存器组织</p>
<figure>
<img src="image-25.png" srcset="/img/loading/loading3.gif" lazyload alt="环形寄存器组织">
<figcaption aria-hidden="true">环形寄存器组织</figcaption>
</figure></li>
</ul>
<h3 id="寄存器优化软件方案">寄存器优化（软件方案）</h3>
<ol type="1">
<li>编译器的优化
<ul>
<li>编译器为每个变量指派一个虚拟寄存器</li>
<li>并通过某种方法将虚拟寄存器映射到真实寄存器</li>
<li>生命周期不重叠的虚拟寄存器可以共享同一个真实寄存器</li>
<li>实在安排不下，就考虑内存</li>
</ul></li>
<li>实现方法：图着色法
<ol type="1">
<li>画点，每个点代表一个虚拟寄存器</li>
<li>连线，在两个生命周期有重叠的虚拟寄存器之间连线</li>
<li>着色，若有n个真实寄存器，则尽量用n种颜色给图上色，要求相邻（有连线）的节点颜色不能相同；无法上色的节点就存在内存里。</li>
</ol>
<figure>
<img src="image-26.png" srcset="/img/loading/loading3.gif" lazyload alt="图着色法">
<figcaption aria-hidden="true">图着色法</figcaption>
</figure></li>
</ol>
<h2 id="risc流水线">RISC流水线</h2>
<h3 id="流水线的效果">流水线的效果</h3>
<figure>
<img src="image-46.png" srcset="/img/loading/loading3.gif" lazyload alt="流水线的效果">
<figcaption aria-hidden="true">流水线的效果</figcaption>
</figure>
<h3 id="流水线优化">流水线优化</h3>
<ul>
<li>空指令（NOOP）：在流水线阶段插入空操作，解决数据相关性，保证指令顺序执行。
<ul>
<li><figure>
<img src="image-47.png" srcset="/img/loading/loading3.gif" lazyload alt="空指令">
<figcaption aria-hidden="true">空指令</figcaption>
</figure></li>
</ul></li>
<li>延迟转移：交换分支指令与前序指令位置，使分支延迟期间执行有效指令，适用于无条件分支。
<ul>
<li><figure>
<img src="image-48.png" srcset="/img/loading/loading3.gif" lazyload alt="延迟分支">
<figcaption aria-hidden="true">延迟分支</figcaption>
</figure></li>
</ul></li>
<li>循环展开</li>
</ul>
<h1 id="ch14-指令级并行性和超标量处理器">Ch14
指令级并行性和超标量处理器</h1>
<h2 id="超标量和超流水的区别">超标量和超流水的区别</h2>
<ul>
<li>超标量：多条指令同时启动独立执行，即多条流水线</li>
<li>超流水：流水线阶段时间短于时钟周期，内部时钟速率加倍，外部周期内发两条指令。</li>
</ul>
<figure>
<img src="image-49.png" srcset="/img/loading/loading3.gif" lazyload alt="超标量与超流水">
<figcaption aria-hidden="true">超标量与超流水</figcaption>
</figure>
<h2 id="指令相关性">指令相关性</h2>
<ol type="1">
<li>数据相关性：访问操作数的位置有冲突
<ol type="1">
<li>写后读（RAW）或真相关：
<ul>
<li>一条指令修改寄存器或内存位置，后续指令读取该内存或寄存器位置中的数据。</li>
<li>冲突：写操作完成之前发生了读操作</li>
</ul></li>
<li>读后写（WAR）或反相关
<ul>
<li>冲突：读操作发生前完成了写操作</li>
<li>乱序发射会造成读后写冲突（按序发射一定不会出现前面的指令还没开始执行后面的指令已经执行完成的情况）</li>
</ul></li>
<li>写后写或输出相关
<ul>
<li>冲突：写操作的顺序与预期顺序相反</li>
<li>乱序完成会造成写后写冲突</li>
</ul></li>
</ol></li>
<li>过程相关性
<ul>
<li>即转移后的指令不能再转移指令未执行前执行</li>
<li>超标量中，若某条流水线上发生了分支预测错误，则所有流水线上都要进行流水线总清！</li>
</ul></li>
<li>资源相关性
<ul>
<li>访存冲突、ALU冲突</li>
</ul></li>
</ol>
<h2 id="乱序执行">乱序执行</h2>
<ul>
<li>按序发射按序完成：指令按顺序发射和完成，可能因相关性停顿。</li>
<li>按序发射乱序完成：指令按序发射，完成顺序可乱序，可能会造成写后写相关性，引发WAW冲突。</li>
<li>乱序发射乱序完成：指令发射顺序可乱序，需指令窗口检测相关性，可能会造成读后写相关性，引发WAR冲突。</li>
</ul>
<h2 id="寄存器重命名解决写后写和读后写相关性">寄存器重命名：解决写后写和读后写相关性</h2>
<ul>
<li>产生写后写相关性和读后写相关性的原因：
<ul>
<li>寄存器值不再反应程序流顺序</li>
</ul></li>
<li>解决方法：
<ul>
<li>寄存器重命名
<ul>
<li>由CPU硬件动态分配寄存器</li>
<li>每产生一个新的寄存器值就分配一个新的真实寄存器</li>
</ul></li>
</ul></li>
</ul>
<h1 id="ch17-并行处理">Ch17 并行处理</h1>
<h2 id="并行处理机分类">并行处理机分类</h2>
<ul>
<li>单指令单数据流（SISD）：传统单处理器。</li>
<li>单指令多数据流（SIMD）：同一指令对不同数据组在不同处理器执行。</li>
<li>多指令单数据流（MISD）：未实现。</li>
<li>多指令多数据流（MIMD）：分为紧耦合、松耦合。</li>
</ul>
<h2 id="紧耦合">紧耦合</h2>
<ul>
<li>处理器共享存储器，通过共享存储器相互通信</li>
</ul>
<h3 id="对称多处理器smp">对称多处理器（SMP）</h3>
<ol type="1">
<li>定义
<ul>
<li>共享内存、IO，通过共享总线分时共享</li>
<li>存储器在任何范围内的存储时间对各个处理器大致相同</li>
<li>所有处理器能完成同样的功能(对称)，地位平等</li>
<li>系统由一个集中式操作系统控制</li>
</ul></li>
<li>优点：
<ul>
<li>性能好，可以并行执行</li>
<li>可用性，单个故障总体不会停机</li>
<li>增量式增长和可扩展性</li>
</ul></li>
</ol>
<h3 id="非一致性内存访问numa">非一致性内存访问（NUMA）</h3>
<p>存储器在不同范围内的存储时间对不同处理器是不同的</p>
<h2 id="cache一致性问题与mesi协议">Cache一致性问题与MESI协议</h2>
<ol type="1">
<li>问题：
<ul>
<li>同一数据在不同的Cache中都有副本</li>
<li>CPU读取数据时会先检查Cache，导致不同的CPU眼里的内存不一样</li>
<li>回写显然会导致不一致，写直达也会，不过可以通过监听消除</li>
</ul></li>
<li>目录协议
<ul>
<li>收集维护有关数据块的副本放在哪里的信息</li>
<li>目录放在主存中</li>
<li>优点：适用于多总线或复杂的大型系统</li>
<li>缺点：产生了中央瓶颈</li>
</ul></li>
<li>监听协议
<ul>
<li>Cache必须识别每一行是否共享、是否与主存相同</li>
<li>优点：适合使用总线的多处理机</li>
<li>缺点：增大了总线传输量</li>
<li>有两种策略：
<ol type="1">
<li>写-失效：适用于回写
<ul>
<li>多个监听者，单个修改者</li>
<li>某Cache写操作时，其他Cache中的该行数据失效</li>
<li>发出写操作的处理器将获得数据独享直到其他Cache访问该行</li>
<li>例子：MESI协议</li>
</ul></li>
<li>写-更新：适用于写直达
<ul>
<li>多个读者，多个写者</li>
<li>更新的字被广播到其他Cache</li>
</ul></li>
</ol></li>
</ul></li>
</ol>
<h3 id="mesi协议">MESI协议</h3>
<ul>
<li>M（Modified）：已修改，数据仅在本Cache，未写回主存。</li>
<li>E（Exclusive）：独占，数据在本Cache和主存，其他Cache无副本。</li>
<li>S（Shared）：共享，数据在本Cache和主存，其他Cache有副本。</li>
<li>I（Invalid）：失效，数据不在本Cache或已过时。</li>
</ul>
<p><img src="image-28.png" srcset="/img/loading/loading3.gif" lazyload> <img src="image-27.png" srcset="/img/loading/loading3.gif" lazyload alt="MESI协议状态转换"></p>
<h2 id="松耦合如集群">松耦合（如集群）</h2>
<ul>
<li>独立处理器或SMP互联，分布式存储器，通信通过网络。</li>
<li>优点：可扩展性强、可用性高、性价比高。</li>
</ul>
<h2 id="集群与smp对比">集群与SMP对比</h2>
<ul>
<li>共同点：
<ul>
<li>提供多处理器支持高端应用</li>
<li>均商用化，SMP历史更久。</li>
</ul></li>
<li>SMP优点：
<ul>
<li>易于配置管理</li>
<li>接近单处理器模型</li>
<li>占用物理空间小</li>
<li>耗电少</li>
<li>稳定</li>
</ul></li>
<li>集群优点：
<ul>
<li>运行中可增减机器</li>
<li>高增量</li>
<li>绝对可扩展性强</li>
<li>高可用性</li>
</ul></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/SJTU-Notes/" class="category-chain-item">SJTU Notes</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/SJTU/" class="print-no-link">#SJTU</a>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/" class="print-no-link">#计算机组成</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>计算机组成与系统结构</div>
      <div>https://youyeyejie.github.io/posts/计算机组成与系统结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>youyeyejie</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年1月23日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年6月23日</div>
        </div>
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/%E4%BF%A1%E6%81%AF%E8%AE%BA%E5%9F%BA%E7%A1%80/" title="信息论基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">信息论基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/%E6%80%9D%E6%83%B3%E9%81%93%E5%BE%B7%E4%B8%8E%E6%B3%95%E6%B2%BB/" title="思想道德与法治">
                        <span class="hidden-mobile">思想道德与法治</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments">
      
    <div id="giscus" class="giscus"></div>
    <script type="text/javascript">
      Fluid.utils.loadComments('#giscus', function() {
        var options = {"repo":"youyeyejie/youyeyejie.github.io","repo-id":"R_kgDOO-Uo1g","category":"General","category-id":"DIC_kwDOO-Uo1s4Crz5J","theme-light":"light","theme-dark":"dark","mapping":"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top","lang":"zh-CN"};
        var attributes = {};
        for (let option in options) {
          if (!option.startsWith('theme-')) {
            var key = option.startsWith('data-') ? option : 'data-' + option;
            attributes[key] = options[option];
          }
        }
        var light = 'light';
        var dark = 'dark';
        window.GiscusThemeLight = light;
        window.GiscusThemeDark = dark;
        attributes['data-theme'] = document.documentElement.getAttribute('data-user-color-scheme') === 'dark' ? dark : light;
        for (let attribute in attributes) {
          var value = attributes[attribute];
          if (value === undefined || value === null || value === '') {
            delete attributes[attribute];
          }
        }
        var s = document.createElement('script');
        s.setAttribute('src', 'https://giscus.app/client.js');
        s.setAttribute('crossorigin', 'anonymous');
        for (let attribute in attributes) {
          s.setAttribute(attribute, attributes[attribute]);
        }
        var ss = document.getElementsByTagName('script');
        var e = ss.length > 0 ? ss[ss.length - 1] : document.head || document.documentElement;
        e.parentNode.insertBefore(s, e.nextSibling);
      });
    </script>
    <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>







  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
</div>
<div class="footer-inner">
    <div class="powered-by">
        <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
        <i class="iconfont icon-love"></i>
        <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
    </div>
    <div class="hitokoto">
        <i class="fas fa-quote-left"></i>
        <a target="_blank" rel="noopener" href="https://developer.hitokoto.cn/" id="hitokoto_text"><span id="hitokoto">Getting poem...</span></a>
        <script src="/js/Hitokoto.js" defer></script>
    </div>
    <div class="data">
        <span class="total-word-container">
            <i class="fas fa-chart-bar"></i>
            <span id="g-total-word-id"></span>
            字汇长河
        </span>
        &nbsp;
        <span id="total-posts-container">
            <i class="fas fa-file-alt"></i>
            <span id="g-total-posts-id"></span>
            <script src="/js/TotalPosts.js"></script>
            文舟靠岸
        </span>
        &nbsp;
        <span id="busuanzi_container_site_pv">
            <i class="fas fa-eye"></i>
            <span id="busuanzi_value_site_pv"></span>
            目光所及
        </span>
        &nbsp;
        <span id="busuanzi_container_site_uv">
            <i class="fas fa-user-friends"></i>
            <span id="busuanzi_value_site_uv"></span>
            访客驻足
        </span>
        <script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script>
    </div>
    <div class="duration">
        <i class="fas fa-calendar"></i>
        <span id="timeDate">Getting date...</span>
        <span id="times">Getting time...</span>
        <script src="/js/Duration.js"></script>
    </div>
</div>
  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/js/DynamicLine.js"></script>
<script src="/js/LinkCard.js"></script>
<script src="/js/RainbowLoading.js"></script>
<script src="/js/ScrollAnimation.js"></script>
<script src="/js/TabDisplay.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  <script type="text/javascript">
  document.getElementById("g-total-word-id").innerHTML = "268k";
</script>

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start -->
<script src="https://cdn.jsdelivr.net/npm/hexo-shiki-plugin@latest/lib/codeblock.js"></script>

  <script>
  const CODE_CONFIG = {
    beautify: true,
    highlightCopy: true,
    highlightLang: true,
    highlightHeightLimit: 360,
    isHighlightShrink: false,
    copy: {
      success: 'Copy Success',
      error: 'Copy Error',
      noSupport: 'Browser Not Support',
    }
  };
  console.log(
    `%c hexo-shiki-plugin %c v1.0.27 %c https://github.com/nova1751/hexo-shiki-plugin`,
    "color: #fff; background: #5f5f5f",
    "color: #fff; background: #80c8f8",
    ""
  );
  </script>
  <!-- hexo injector body_end end --></body>
</html>
